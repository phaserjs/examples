(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Phaser", [], factory);
	else if(typeof exports === 'object')
		exports["Phaser"] = factory();
	else
		root["Phaser"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 851);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse

function hasGetterOrSetter (def)
{
    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');
}

function getProperty (definition, k, isClassDescriptor)
{
    //  This may be a lightweight object, OR it might be a property that was defined previously.
    
    //  For simple class descriptors we can just assume its NOT previously defined.
    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);

    if (!isClassDescriptor && def.value && typeof def.value === 'object')
    {
        def = def.value;
    }

    //  This might be a regular property, or it may be a getter/setter the user defined in a class.
    if (def && hasGetterOrSetter(def))
    {
        if (typeof def.enumerable === 'undefined')
        {
            def.enumerable = true;
        }

        if (typeof def.configurable === 'undefined')
        {
            def.configurable = true;
        }

        return def;
    }
    else
    {
        return false;
    }
}

function hasNonConfigurable (obj, k)
{
    var prop = Object.getOwnPropertyDescriptor(obj, k);

    if (!prop)
    {
        return false;
    }

    if (prop.value && typeof prop.value === 'object')
    {
        prop = prop.value;
    }

    if (prop.configurable === false)
    {
        return true;
    }

    return false;
}

function extend (ctor, definition, isClassDescriptor, extend)
{
    for (var k in definition)
    {
        if (!definition.hasOwnProperty(k))
        {
            continue;
        }

        var def = getProperty(definition, k, isClassDescriptor);

        if (def !== false)
        {
            //  If Extends is used, we will check its prototype to see if the final variable exists.
            
            var parent = extend || ctor;

            if (hasNonConfigurable(parent.prototype, k))
            {
                //  Just skip the final property
                if (Class.ignoreFinals)
                {
                    continue;
                }

                //  We cannot re-define a property that is configurable=false.
                //  So we will consider them final and throw an error. This is by
                //  default so it is clear to the developer what is happening.
                //  You can set ignoreFinals to true if you need to extend a class
                //  which has configurable=false; it will simply not re-define final properties.
                throw new Error('cannot override final property \'' + k + '\', set Class.ignoreFinals = true to skip');
            }

            Object.defineProperty(ctor.prototype, k, def);
        }
        else
        {
            ctor.prototype[k] = definition[k];
        }
    }
}

function mixin (myClass, mixins)
{
    if (!mixins)
    {
        return;
    }

    if (!Array.isArray(mixins))
    {
        mixins = [ mixins ];
    }

    for (var i = 0; i < mixins.length; i++)
    {
        extend(myClass, mixins[i].prototype || mixins[i]);
    }
}

/**
 * Creates a new class with the given descriptor.
 * The constructor, defined by the name `initialize`,
 * is an optional function. If unspecified, an anonymous
 * function will be used which calls the parent class (if
 * one exists).
 *
 * You can also use `Extends` and `Mixins` to provide subclassing
 * and inheritance.
 *
 * @class  Class
 * @constructor
 * @param {Object} definition a dictionary of functions for the class
 * @example
 *
 *      var MyClass = new Phaser.Class({
 *      
 *          initialize: function() {
 *              this.foo = 2.0;
 *          },
 *
 *          bar: function() {
 *              return this.foo + 5;
 *          }
 *      });
 */
function Class (definition)
{
    if (!definition)
    {
        definition = {};
    }

    //  The variable name here dictates what we see in Chrome debugger
    var initialize;
    var Extends;

    if (definition.initialize)
    {
        if (typeof definition.initialize !== 'function')
        {
            throw new Error('initialize must be a function');
        }

        initialize = definition.initialize;

        //  Usually we should avoid 'delete' in V8 at all costs.
        //  However, its unlikely to make any performance difference
        //  here since we only call this on class creation (i.e. not object creation).
        delete definition.initialize;
    }
    else
    {
        if (definition.Extends)
        {
            var base = definition.Extends;

            initialize = function ()
            {
                base.apply(this, arguments);
            };
        }
        else
        {
            initialize = function () {};
        }
    }

    if (definition.Extends)
    {
        initialize.prototype = Object.create(definition.Extends.prototype);
        initialize.prototype.constructor = initialize;

        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)

        Extends = definition.Extends;

        delete definition.Extends;
    }
    else
    {
        initialize.prototype.constructor = initialize;
    }

    //  Grab the mixins, if they are specified...
    var mixins = null;

    if (definition.Mixins)
    {
        mixins = definition.Mixins;
        delete definition.Mixins;
    }

    //  First, mixin if we can.
    mixin(initialize, mixins);

    //  Now we grab the actual definition which defines the overrides.
    extend(initialize, definition, true, Extends);

    return initialize;
}

Class.extend = extend;
Class.mixin = mixin;
Class.ignoreFinals = false;

module.exports = Class;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @author       Richard Davey <rich@phaser.io>
 * @copyright    2017 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

var Class = __webpack_require__(0);
var Components = __webpack_require__(8);
var DataProxy = __webpack_require__(448);

var GameObject = new Class({

    initialize:

    /**
     * The base class that all Game Objects extend.
     * You don't create GameObjects directly and they cannot be added to the display list.
     * Instead, use them as the base for your own custom classes.
     *
     * @class GameObject
     * @namespace Phaser.GameObjects
     * @constructor
     *
     * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.
     * @param {string} type - A textual representation of the type of Game Object, i.e. `sprite`.
     */
    function GameObject (scene, type)
    {
        /**
         * The Scene to which this Game Object belongs.
         * Game Objects can only belong to one Scene.
         *
         * @property {Phaser.Scene} scene
         * @protected
         */
        this.scene = scene;

        /**
         * A textual representation of this Game Object, i.e. `sprite`.
         * Used internally by Phaser but is available for your own custom classes to populate.
         *
         * @property {string} type
         */
        this.type = type;

        /**
         * The name of this Game Object.
         * Empty by default and never populated by Phaser, this is left for developers to use.
         *
         * @property {string} [name='']
         */
        this.name = '';

        /**
         * The active state of this Game Object.
         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.
         * An active object is one which is having its logic and internal systems updated.
         *
         * @property {boolean} [active=true]
         */
        this.active = true;

        /**
         * The Tab Index of the Game Object.
         * Reserved for future use by plugins and the Input Manager.
         *
         * @property {integer} [tabIndex=-1]
         */
        this.tabIndex = -1;

        /**
         * A proxy to the Data class.
         * It allows you to store, query and get key/value paired information specific to this Game Object.
         *
         * @property {DataProxy} data
         */
        this.data = new DataProxy(scene, this);

        /**
         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.
         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.
         * If those components are not used by your custom class then you can use this bitmask as you wish.
         *
         * @property {integer} [renderFlags=15]
         */
        this.renderFlags = 15;

        /**
         * A bitmask that controls if this Game Object is drawn by a Camera or not.
         * Not usually set directly. Instead call `Camera.ignore`.
         *
         * @property {number} [cameraFilter=0]
         * @see Phaser.Cameras.Camera.ignore
         */
        this.cameraFilter = 0;

        /**
         * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.
         * Not usually set directly. Instead call `GameObject.setInteractive()`.
         *
         * @property {Phaser.Input.InteractiveObject|null} [input=null]
         * @see setInteractive
         */
        this.input = null;

        /**
         * If this Game Object is enabled for physics then this property will contain a reference to a Physics Body.
         *
         * @property {Phaser.Physics.Body|null} [body=null]
         */
        this.body = null;

        //  Tell the Scene to re-sort the children
        this.scene.sys.sortChildrenFlag = true;
    },

    /**
     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.
     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.
     *
     * @method setActive
     *
     * @param {boolean} value - True if this Game Object should be set as active, false if not.
     * @return {GameObject} This GameObject.
     */
    setActive: function (value)
    {
        this.active = value;

        return this;
    },

    /**
     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.
     * The `name` property is not populated by Phaser and is presented for your own use.
     *
     * @example game objects/image/set name.js
     * @tutorial game objects/basics
     *
     * @method setName
     *
     * @param {string} value - The name to be given to this Game Object.
     * @return {GameObject} This GameObject.
     */
    setName: function (value)
    {
        this.name = value;

        return this;
    },

    /**
     * Pass this Game Object to the Input Manager to enable it for Input.
     *
     * @example game objects/image/set interactive.js
     * @tutorial input/basics
     * 
     * @method setInteractive
     *
     * @param {any} [shape] - A geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
     * @param {function} [callback] - A callback to be invoked when the Game Object is interacted with.
     * @return {GameObject} This GameObject.
     */
    setInteractive: function (shape, callback)
    {
        this.scene.sys.inputManager.enable(this, shape, callback);

        return this;
    },

    //  To be overridden by custom GameObjects. Allows base objects to be used in a Pool.
    update: function ()
    {
    },

    /**
     * Returns a JSON representation of the Game Object.
     *
     * @method toJSON
     *
     * @return {object} A JSON representation of the Game Object.
     */
    toJSON: function ()
    {
        return Components.ToJSON(this);
    },

    /**
     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
     *
     * @method willRender
     *
     * @return {boolean} True if the Game Object should be rendered, otherwise false.
     */
    willRender: function ()
    {
        return (GameObject.RENDER_MASK === this.renderFlags);
    },

    /**
     * Destroys this Game Object removing it from the Display List and Update List and
     * severing all ties to parent resources.
     * 
     * Also removes itself from the Input Manager and Physics Manager if previously enabled.
     * 
     * Use this to remove a Game Object from your game if you don't ever plan to use it again.
     * As long as no reference to it exists within your own code it should become free for
     * garbage collection by the browser.
     * 
     * If you just want to temporarily disable an object then look at using the
     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.
     *
     * @method destroy
     */
    destroy: function ()
    {
        this.scene.sys.displayList.remove(this);
        this.scene.sys.updateList.remove(this);

        if (this.input)
        {
            this.scene.sys.inputManager.clear(this);
        }

        if (this.body)
        {
            this.scene.sys.physicsManager.remove(this);
        }

        this.active = false;

        this.data = undefined;

        this.scene = undefined;
    }

});

/**
 * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.
 *
 * @constant {integer} RENDER_MASK
 * @default
 */
GameObject.RENDER_MASK = 15;

module.exports = GameObject;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var Event = new Class({

    initialize:

    function Event (type)
    {
        this.type = type;

        //  The element that initiated the event.
        this.target;

        this._propagate = true;
    },

    reset: function (target)
    {
        this.target = target;

        this._propagate = true;
    },

    stopPropagation: function ()
    {
        this._propagate = false;
    }

});

module.exports = Event;


/***/ }),
/* 3 */
/***/ (function(module, exports) {


var NOOP = function ()
{
    //  NOOP (No Operation) Callback
};

module.exports = NOOP;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

//  Source object
//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
//  The default value to use if the key doesn't exist

var GetValue = function (source, key, defaultValue)
{
    if (!source || typeof source === 'number')
    {
        return defaultValue;
    }
    else if (source.hasOwnProperty(key))
    {
        return source[key];
    }
    else if (key.indexOf('.'))
    {
        var keys = key.split('.');
        var parent = source;
        var value = defaultValue;

        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++)
        {
            if (parent.hasOwnProperty(keys[i]))
            {
                //  Yes it has a key property, let's carry on down
                value = parent[keys[i]];

                parent = parent[keys[i]];
            }
            else
            {
                //  Can't go any further, so reset to default
                value = defaultValue;
                break;
            }
        }

        return value;
    }
    else
    {
        return defaultValue;
    }
};

module.exports = GetValue;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var GameObjectCreator = new Class({

    initialize:

    function GameObjectCreator (scene)
    {
        this.scene = scene;
    },

    destroy: function ()
    {
        this.scene = null;
    }

});

//  Static method called directly by the Game Object creator functions

GameObjectCreator.register = function (type, factoryFunction)
{
    // console.log('register', type);

    if (!GameObjectCreator.prototype.hasOwnProperty(type))
    {
        GameObjectCreator.prototype[type] = factoryFunction;
    }
};

module.exports = GameObjectCreator;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var GameObjectFactory = new Class({

    initialize:

    function GameObjectFactory (scene)
    {
        this.scene = scene;

        this.displayList;
        this.updateList;
    },

    boot: function (sys)
    {
        this.displayList = sys.displayList;
        this.updateList = sys.updateList;
    },

    existing: function (child)
    {
        if (child.renderCanvas || child.renderWebGL)
        {
            this.displayList.add(child);
        }

        if (child.preUpdate)
        {
            this.updateList.add(child);
        }

        return child;
    },

    destroy: function ()
    {
        this.scene = null;
        this.displayList = null;
        this.updateList = null;
    }

});

//  Static method called directly by the Game Object factory functions

GameObjectFactory.register = function (type, factoryFunction)
{
    // console.log('register', type);

    if (!GameObjectFactory.prototype.hasOwnProperty(type))
    {
        GameObjectFactory.prototype[type] = factoryFunction;
    }
};

module.exports = GameObjectFactory;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var MATH = __webpack_require__(13);
var GetValue = __webpack_require__(4);

//  Allowed types:

//  Implicit
//  {
//      x: 4
//  }
//
//  From function
//  {
//      x: function ()
//  }
//
//  Randomly pick one element from the array
//  {
//      x: [a, b, c, d, e, f]
//  }
//
//  Random integer between min and max:
//  {
//      x: { randInt: [min, max] }
//  }
//
//  Random float between min and max:
//  {
//      x: { randFloat: [min, max] }
//  }

var GetAdvancedValue = function (source, key, defaultValue)
{
    var value = GetValue(source, key, null);

    if (value === null)
    {
        return defaultValue;
    }
    else if (Array.isArray(value))
    {
        return MATH.RND.pick(value);
    }
    else if (typeof value === 'object')
    {
        if (value.hasOwnProperty('randInt'))
        {
            return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);
        }
        else if (value.hasOwnProperty('randFloat'))
        {
            return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);
        }
    }
    else if (typeof value === 'function')
    {
        return value(key);
    }

    return value;
};

module.exports = GetAdvancedValue;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.GameObjects.Components

module.exports = {

    Alpha: __webpack_require__(444),
    Animation: __webpack_require__(445),
    BlendMode: __webpack_require__(446),
    ComputedSize: __webpack_require__(447),
    Flip: __webpack_require__(449),
    GetBounds: __webpack_require__(450),
    Origin: __webpack_require__(451),
    RenderTarget: __webpack_require__(452),
    ScaleMode: __webpack_require__(453),
    ScrollFactor: __webpack_require__(454),
    Size: __webpack_require__(455),
    Texture: __webpack_require__(456),
    Tint: __webpack_require__(457),
    ToJSON: __webpack_require__(458),
    Transform: __webpack_require__(459),
    TransformMatrix: __webpack_require__(17),
    Visible: __webpack_require__(460)

};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = {

    VERSION: '3.0.0',

    BlendModes: __webpack_require__(42),
    ScaleModes: __webpack_require__(35),

    AUTO: 0,
    CANVAS: 1,
    WEBGL: 2,
    HEADLESS: 3,

    FOREVER: -1,

    NONE: 4,
    UP: 5,
    DOWN: 6,
    LEFT: 7,
    RIGHT: 8

};

module.exports = CONST;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var GetAdvancedValue = __webpack_require__(7);
var ScaleModes = __webpack_require__(35);
var BlendModes = __webpack_require__(42);

var BuildGameObject = function (scene, gameObject, config)
{
    //  Position

    gameObject.x = GetAdvancedValue(config, 'x', 0);
    gameObject.y = GetAdvancedValue(config, 'y', 0);
    gameObject.depth = GetAdvancedValue(config, 'depth', 0);

    //  Flip

    gameObject.flipX = GetAdvancedValue(config, 'flipX', false);
    gameObject.flipY = GetAdvancedValue(config, 'flipY', false);

    //  Scale
    //  Either: { scale: 2 } or { scale: { x: 2, y: 2 }}

    var scale = GetAdvancedValue(config, 'scale', null);

    if (typeof scale === 'number')
    {
        gameObject.setScale(scale);
    }
    else if (scale !== null)
    {
        gameObject.scaleX = GetAdvancedValue(scale, 'x', 1);
        gameObject.scaleY = GetAdvancedValue(scale, 'y', 1);
    }

    //  ScrollFactor
    //  Either: { scrollFactor: 2 } or { scrollFactor: { x: 2, y: 2 }}

    var scrollFactor = GetAdvancedValue(config, 'scrollFactor', null);

    if (typeof scrollFactor === 'number')
    {
        gameObject.setScrollFactor(scrollFactor);
    }
    else if (scrollFactor !== null)
    {
        gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, 'x', 1);
        gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, 'y', 1);
    }

    //  Rotation

    gameObject.rotation = GetAdvancedValue(config, 'rotation', 0);

    var angle = GetAdvancedValue(config, 'angle', null);

    if (angle !== null)
    {
        gameObject.angle = angle;
    }

    //  Alpha

    gameObject.alpha = GetAdvancedValue(config, 'alpha', 1);

    //  Origin
    //  Either: { origin: 0.5 } or { origin: { x: 0.5, y: 0.5 }}

    var origin = GetAdvancedValue(config, 'origin', null);

    if (typeof origin === 'number')
    {
        gameObject.setOrigin(origin);
    }
    else if (origin !== null)
    {
        var ox = GetAdvancedValue(config, 'x', 0.5);
        var oy = GetAdvancedValue(config, 'y', 0.5);

        gameObject.setOrigin(ox, oy);
    }

    //  ScaleMode

    gameObject.scaleMode = GetAdvancedValue(config, 'scaleMode', ScaleModes.DEFAULT);

    //  BlendMode

    gameObject.blendMode = GetAdvancedValue(config, 'blendMode', BlendModes.NORMAL);

    //  Visible

    gameObject.visible = GetAdvancedValue(config, 'visible', true);

    //  Add to Scene

    var add = GetAdvancedValue(config, 'add', true);

    if (add)
    {
        scene.sys.displayList.add(gameObject);

        if (gameObject.preUpdate)
        {
            scene.sys.updateList.add(gameObject);
        }
    }

    return gameObject;
};

module.exports = BuildGameObject;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

//  Source object
//  The key as a string, can only be 1 level deep (no periods), must exist at the top level of the source object
//  The default value to use if the key doesn't exist

var GetFastValue = function (source, key, defaultValue)
{
    var t = typeof(source);

    if (!source || t === 'number' || t === 'string')
    {
        return defaultValue;
    }
    else if (source.hasOwnProperty(key))
    {
        return source[key];
    }
    else
    {
        return defaultValue;
    }
};

module.exports = GetFastValue;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var Point = new Class({

    initialize:

    function Point (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;

        this.y = y;
    },

    setTo: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    }

});

module.exports = Point;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var RND = __webpack_require__(227);

var MATH_CONST = {

    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,

    //  Random Data Generator
    RND: new RND()

};

module.exports = MATH_CONST;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var TWEEN_CONST = {

    //  TweenData:

    CREATED: 0,
    INIT: 1,
    DELAY: 2,
    OFFSET_DELAY: 3,
    PENDING_RENDER: 4,
    PLAYING_FORWARD: 5,
    PLAYING_BACKWARD: 6,
    HOLD_DELAY: 7,
    REPEAT_DELAY: 8,
    COMPLETE: 9,

    //  Tween specific (starts from 20 to cleanly allow extra TweenData consts in the future)

    PENDING_ADD: 20,
    PAUSED: 21,
    LOOP_DELAY: 22,
    ACTIVE: 23,
    COMPLETE_DELAY: 24,
    PENDING_REMOVE: 25,
    REMOVED: 26

};

module.exports = TWEEN_CONST;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(9);
var Smoothing = __webpack_require__(76);

// The pool into which the canvas elements are placed.
var pool = [];

//  Automatically apply smoothing(false) to created Canvas elements
var _disableContextSmoothing = false;

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games on the same page
//  can share the one single pool

// The CanvasPool is a global static object, that allows Phaser to recycle and pool Canvas DOM elements.
var CanvasPool = function ()
{
    // Creates a new Canvas DOM element, or pulls one from the pool if free.
    var create = function (parent, width, height, type)
    {
        if (width === undefined) { width = 1; }
        if (height === undefined) { height = 1; }
        if (type === undefined) { type = CONST.CANVAS; }

        var canvas;
        var container = first(type);

        if (container === null)
        {
            container = {
                parent: parent,
                canvas: document.createElement('canvas'),
                type: type
            };

            pool.push(container);

            canvas = container.canvas;
        }
        else
        {
            container.parent = parent;

            canvas = container.canvas;
        }

        canvas.width = width;
        canvas.height = height;

        if (_disableContextSmoothing && type === CONST.CANVAS)
        {
            Smoothing.disable(canvas.getContext('2d'));
        }
        
        return canvas;
    };

    var create2D = function (parent, width, height)
    {
        return create(parent, width, height, CONST.CANVAS);
    };

    var createWebGL = function (parent, width, height)
    {
        return create(parent, width, height, CONST.WEBGL);
    };

    // Gets the first free canvas index from the pool.
    var first = function (type)
    {
        if (type === undefined) { type = CONST.CANVAS; }

        pool.forEach(function (container)
        {
            if (!container.parent && container.type === type)
            {
                return container;
            }
        });

        return null;
    };

    //  Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.
    //  The canvas has its width and height set to 1, and its parent attribute nulled.
    var remove = function (parent)
    {
        //  Check to see if the parent is a canvas object
        var isCanvas = parent instanceof HTMLCanvasElement;

        pool.forEach(function (container)
        {
            if ((isCanvas && container.canvas === parent) || (!isCanvas && container.parent === parent))
            {
                // console.log('CanvasPool.remove found and removed');
                container.parent = null;
                container.canvas.width = 1;
                container.canvas.height = 1;
            }
        });
    };

    //  Gets the total number of used canvas elements in the pool.
    var total = function ()
    {
        var c = 0;

        pool.forEach(function (container)
        {
            if (container.parent)
            {
                c++;
            }
        });

        return c;
    };

    //  Gets the total number of free canvas elements in the pool.
    var free = function ()
    {
        return pool.length - total();
    };

    //  Disable context smoothing on any new Canvas element created
    var disableSmoothing = function ()
    {
        _disableContextSmoothing = true;
    };

    //  Enable context smoothing on any new Canvas element created
    var enableSmoothing = function ()
    {
        _disableContextSmoothing = false;
    };

    return {
        create2D: create2D,
        create: create,
        createWebGL: createWebGL,
        disableSmoothing: disableSmoothing,
        enableSmoothing: enableSmoothing,
        first: first,
        free: free,
        pool: pool,
        remove: remove,
        total: total
    };
};

//  If we export the called function here, it'll only be invoked once (not every time it's required).
module.exports = CanvasPool();


/***/ }),
/* 16 */
/***/ (function(module, exports) {

var FILE_CONST = {

    LOADER_IDLE: 0,
    LOADER_LOADING: 1,
    LOADER_PROCESSING: 2,
    LOADER_COMPLETE: 3,
    LOADER_DESTROYED: 4,

    FILE_PENDING: 5,      // file is in the load queue but not yet started
    FILE_LOADING: 6,      // file has been started to load by the loader (onLoad called)
    FILE_LOADED: 7,       // file has loaded successfully, awaiting processing
    FILE_FAILED: 8,       // file failed to load
    FILE_PROCESSING: 9,   // file is being processed (onProcess callback)
    FILE_WAITING_LINKFILE: 10,   // file is being processed (onProcess callback)
    FILE_ERRORED: 11,   // file is being processed (onProcess callback)
    FILE_COMPLETE: 12,     // file has finished processing
    FILE_DESTROYED: 13,     // file has been destroyed

    TEXTURE_ATLAS_JSON_ARRAY: 20,
    TEXTURE_ATLAS_JSON_HASH: 21

};

module.exports = FILE_CONST;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var TransformMatrix = new Class({

    initialize:

    function TransformMatrix (a, b, c, d, tx, ty)
    {
        if (a === undefined) { a = 1; }
        if (b === undefined) { b = 0; }
        if (c === undefined) { c = 0; }
        if (d === undefined) { d = 1; }
        if (tx === undefined) { tx = 0; }
        if (ty === undefined) { ty = 0; }

        this.matrix = new Float32Array([ a, b, c, d, tx, ty, 0, 0, 1 ]);

        this.decomposedMatrix = {
            translateX: 0,
            translateY: 0,
            scaleX: 1,
            scaleY: 1,
            rotation: 0
        };
    },

    loadIdentity: function ()
    {
        var matrix = this.matrix;
        
        matrix[0] = 1;
        matrix[1] = 0;
        matrix[2] = 0;
        matrix[3] = 1;
        matrix[4] = 0;
        matrix[5] = 0;

        return this;
    },

    translate: function (x, y)
    {
        var matrix = this.matrix;

        matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];
        matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];

        return this;
    },

    scale: function (x, y)
    {
        var matrix = this.matrix;

        matrix[0] *= x;
        matrix[1] *= x;
        matrix[2] *= y;
        matrix[3] *= y;

        return this;
    },

    rotate: function (radian)
    {
        var radianSin = Math.sin(radian);
        var radianCos = Math.cos(radian);

        return this.transform(radianCos, -radianSin, radianSin, radianCos, 0, 0);
    },

    multiply: function (otherMatrix)
    {
        var matrix = this.matrix;

        var a0 = matrix[0];
        var b0 = matrix[1];
        var c0 = matrix[2];
        var d0 = matrix[3];
        var tx0 = matrix[4];
        var ty0 = matrix[5];

        var a1 = otherMatrix[0];
        var b1 = otherMatrix[1];
        var c1 = otherMatrix[2];
        var d1 = otherMatrix[3];
        var tx1 = otherMatrix[4];
        var ty1 = otherMatrix[5];

        matrix[0] = a1 * a0 + b1 * c0;
        matrix[1] = a1 * b0 + b1 * d0;
        matrix[2] = c1 * a0 + d1 * c0;
        matrix[3] = c1 * b0 + d1 * d0;
        matrix[4] = tx1 * a0 + ty1 * c0 + tx0;
        matrix[5] = tx1 * b0 + ty1 * d0 + ty0;

        return this;
    },

    transform: function (a, b, c, d, tx, ty)
    {
        var matrix = this.matrix;

        var a0 = matrix[0];
        var b0 = matrix[1];
        var c0 = matrix[2];
        var d0 = matrix[3];
        var tx0 = matrix[4];
        var ty0 = matrix[5];

        matrix[0] = a * a0 + b * c0;
        matrix[1] = a * b0 + b * d0;
        matrix[2] = c * a0 + d * c0;
        matrix[3] = c * b0 + d * d0;
        matrix[4] = tx * a0 + ty * c0 + tx0;
        matrix[5] = tx * b0 + ty * d0 + ty0;

        return this;
    },

    transformPoint: function (x, y, point)
    {
        if (point === undefined) { point = { x: 0, y: 0 }; }

        var matrix = this.matrix;

        var a = matrix[0];
        var b = matrix[1];
        var c = matrix[2];
        var d = matrix[3];
        var tx = matrix[4];
        var ty = matrix[5];

        point.x = x * a + y * c + tx;
        point.y = x * b + y * d + ty;

        return point;
    },

    invert: function ()
    {
        var matrix = this.matrix;

        var a = matrix[0];
        var b = matrix[1];
        var c = matrix[2];
        var d = matrix[3];
        var tx = matrix[4];
        var ty = matrix[5];

        var n = a * d - b * c;

        matrix[0] = d / n;
        matrix[1] = -b / n;
        matrix[2] = -c / n;
        matrix[3] = a / n;
        matrix[4] = (c * ty - d * tx) / n;
        matrix[5] = -(a * ty - b * tx) / n;

        return this;
    },

    setTransform: function (a, b, c, d, tx, ty)
    {
        var matrix = this.matrix;

        matrix[0] = a;
        matrix[1] = b;
        matrix[2] = c;
        matrix[3] = d;
        matrix[4] = tx;
        matrix[5] = ty;

        return this;
    },

    decomposeMatrix: function ()
    {
        var decomposedMatrix = this.decomposedMatrix;

        var matrix = this.matrix;

        var a = matrix[0];
        var b = matrix[1];
        var c = matrix[2];
        var d = matrix[3];

        var a2 = a * a;
        var b2 = b * b;
        var c2 = c * c;
        var d2 = d * d;

        var sx = Math.sqrt(a2 + c2);
        var sy = Math.sqrt(b2 + d2);

        decomposedMatrix.translateX = matrix[4];
        decomposedMatrix.translateY = matrix[5];

        decomposedMatrix.scaleX = sx;
        decomposedMatrix.scaleY = sy;

        decomposedMatrix.rotation = Math.acos(a / sx) * (Math.atan(-c / a) < 0 ? -1 : 1);

        return decomposedMatrix;
    },

    /* identity + translate + rotate + scale */
    applyITRS: function (x, y, rotation, scaleX, scaleY)
    {
        var matrix = this.matrix;

        var sr = Math.sin(rotation);
        var cr = Math.cos(rotation);

        // Translate
        matrix[4] = x;
        matrix[5] = y;

        // Rotate and Scale
        matrix[0] = cr * scaleX;
        matrix[1] = -sr * scaleX;
        matrix[2] = sr * scaleY;
        matrix[3] = cr * scaleY;

        return this;
    }

});

module.exports = TransformMatrix;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

//  Encapsulates a 2D rectangle defined by its corner point in the top-left
//  and its extends in x (width) and y (height)

var Rectangle = new Class({

    initialize:

    function Rectangle (x, y, width, height)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (width === undefined) { width = 0; }
        if (height === undefined) { height = 0; }

        this.x = x;

        this.y = y;

        this.width = width;

        this.height = height;
    },

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    },

    //  TOP
    getLineA: function ()
    {
        return { x1: this.x, y1: this.y, x2: this.right, y2: this.y };
    },

    //  RIGHT
    getLineB: function ()
    {
        return { x1: this.right, y1: this.y, x2: this.right, y2: this.bottom };
    },

    //  BOTTOM
    getLineC: function ()
    {
        return { x1: this.right, y1: this.bottom, x2: this.x, y2: this.bottom };
    },

    //  LEFT
    getLineD: function ()
    {
        return { x1: this.x, y1: this.bottom, x2: this.x, y2: this.y };
    },

    left: {

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    },

    centerX: {

        get: function ()
        {
            return this.x + (this.width / 2);
        },

        set: function (value)
        {
            this.x = value - (this.width / 2);
        }

    },

    centerY: {

        get: function ()
        {
            return this.y + (this.height / 2);
        },

        set: function (value)
        {
            this.y = value - (this.height / 2);
        }

    }

});

module.exports = Rectangle;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GetFastValue = __webpack_require__(11);
var CONST = __webpack_require__(16);
var GetURL = __webpack_require__(787);
var MergeXHRSettings = __webpack_require__(195);
var XHRLoader = __webpack_require__(788);
var XHRSettings = __webpack_require__(103);

//  Phaser.Loader.File

var File = new Class({

    initialize:

    // old signature: type, key, url, responseType, xhrSettings, config
    function File (fileConfig)
    {
        //  file type (image, json, etc) for sorting within the Loader
        this.type = GetFastValue(fileConfig, 'type', false);

        //  unique cache key (unique within its file type)
        this.key = GetFastValue(fileConfig, 'key', false);

        if (!this.type || !this.key)
        {
            throw new Error('Error calling \'Loader.' + this.type + '\' invalid key provided.');
        }

        //  The URL of the file, not including baseURL
        this.url = GetFastValue(fileConfig, 'url');

        if (this.url === undefined)
        {
            this.url = GetFastValue(fileConfig, 'path', '') + this.key + '.' + GetFastValue(fileConfig, 'extension', '');
        }
        else
        {
            this.url = GetFastValue(fileConfig, 'path', '').concat(this.url);
        }

        //  Set when the Loader calls 'load' on this file
        this.src = '';

        this.xhrSettings = XHRSettings(GetFastValue(fileConfig, 'responseType', undefined));

        if (GetFastValue(fileConfig, 'xhrSettings', false))
        {
            this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, 'xhrSettings', {}));
        }

        this.xhrLoader = null;

        this.state = CONST.FILE_PENDING;

        //  Set by onProgress (only if loading via XHR)
        this.bytesTotal = 0;
        this.bytesLoaded = -1;
        this.percentComplete = -1;

        //  For CORs based loading.
        //  If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)
        this.crossOrigin = undefined;

        //  The actual processed file data
        this.data = undefined;

        //  A config object that can be used by file types to store transitional data
        this.config = GetFastValue(fileConfig, 'config', {});

        //  Multipart file? (i.e. an atlas and its json together)
        this.linkFile = undefined;
        this.linkType = '';

        this.callback = null;
    },

    resetXHR: function ()
    {
        this.xhrLoader.onload = undefined;
        this.xhrLoader.onerror = undefined;
        this.xhrLoader.onprogress = undefined;
    },

    //  Called when the Image loads
    //  ProgressEvent
    onLoad: function (event)
    {
        this.resetXHR();

        this.callback(this, true);
    },

    onError: function (event)
    {
        this.resetXHR();

        this.callback(this, false);
    },

    onProgress: function (event)
    {
        if (event.lengthComputable)
        {
            this.bytesLoaded = event.loaded;
            this.bytesTotal = event.total;

            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);
        }

        // console.log(this.percentComplete + '% (' + this.bytesLoaded + ' bytes)');
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.onComplete();

        callback(this);
    },

    onComplete: function ()
    {
        if (this.linkFile)
        {
            if (this.linkFile.state === CONST.FILE_WAITING_LINKFILE)
            {
                //  The linkfile has finished processing, and is waiting for this file, so let's do them both
                this.state = CONST.FILE_COMPLETE;
                this.linkFile.state = CONST.FILE_COMPLETE;
            }
            else
            {
                //  The linkfile still hasn't finished loading and/or processing yet
                this.state = CONST.FILE_WAITING_LINKFILE;
            }
        }
        else
        {
            this.state = CONST.FILE_COMPLETE;
        }
    },

    //  Called by the Loader, starts the actual file downloading
    load: function (callback, baseURL, globalXHR)
    {
        if (baseURL === undefined) { baseURL = ''; }

        this.callback = callback;

        this.src = GetURL(this, baseURL);

        if (this.src.indexOf('data:') === 0)
        {
            console.log('Local data URI');
        }
        else
        {
            this.xhrLoader = XHRLoader(this, globalXHR);
        }
    }

});

module.exports = File;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji 
//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl

var Class = __webpack_require__(0);

var Vector2 = new Class({

    initialize:

    function Vector2 (x, y)
    {
        if (typeof x === 'object')
        {
            this.x = x.x || 0;
            this.y = x.y || 0;
        }
        else
        {
            this.x = x || 0;
            this.y = y || 0;
        }
    },

    clone: function ()
    {
        return new Vector2(this.x, this.y);
    },

    copy: function (src)
    {
        this.x = src.x || 0;
        this.y = src.y || 0;

        return this;
    },

    set: function (x, y)
    {
        if (typeof x === 'object')
        {
            this.x = x.x || 0;
            this.y = x.y || 0;
        }
        else
        {
            this.x = x;
            this.y = y;
        }

        return this;
    },

    equals: function (v)
    {
        return ((this.x === v.x) && (this.y === v.y));
    },

    angle: function ()
    {
        // computes the angle in radians with respect to the positive x-axis

        var angle = Math.atan2(this.y, this.x);

        if (angle < 0)
        {
            angle += 2 * Math.PI;
        }

        return angle;
    },

    add: function (src)
    {
        this.x += src.x;
        this.y += src.y;

        return this;
    },

    subtract: function (src)
    {
        this.x -= src.x;
        this.y -= src.y;

        return this;
    },

    multiply: function (src)
    {
        this.x *= src.x;
        this.y *= src.y;

        return this;
    },

    scale: function (value)
    {
        if (isFinite(value))
        {
            this.x *= value;
            this.y *= value;
        }
        else
        {
            this.x = 0;
            this.y = 0;
        }

        return this;
    },

    divide: function (src)
    {
        this.x /= src.x;
        this.y /= src.y;

        return this;
    },

    negate: function ()
    {
        this.x = -this.x;
        this.y = -this.y;

        return this;
    },

    distance: function (src)
    {
        var dx = src.x - this.x;
        var dy = src.y - this.y;

        return Math.sqrt(dx * dx + dy * dy);
    },

    distanceSq: function (src)
    {
        var dx = src.x - this.x;
        var dy = src.y - this.y;

        return dx * dx + dy * dy;
    },

    length: function ()
    {
        var x = this.x;
        var y = this.y;

        return Math.sqrt(x * x + y * y);
    },

    lengthSq: function ()
    {
        var x = this.x;
        var y = this.y;

        return x * x + y * y;
    },

    normalize: function ()
    {
        var x = this.x;
        var y = this.y;
        var len = x * x + y * y;

        if (len > 0)
        {
            len = 1 / Math.sqrt(len);
            this.x = x * len;
            this.y = y * len;
        }
    
        return this;
    },

    /**
    * Right-hand normalize (make unit length) this Vector
    */
    normalizeRightHand: function ()
    {
        var x = this.x;

        this.x = this.y * -1;
        this.y = x;

        return this;
    },

    dot: function (src)
    {
        return this.x * src.x + this.y * src.y;
    },

    cross: function (src)
    {
        return this.x * src.y - this.y * src.x;
    },

    lerp: function (src, t)
    {
        if (t === undefined) { t = 0; }

        var ax = this.x;
        var ay = this.y;

        this.x = ax + t * (src.x - ax);
        this.y = ay + t * (src.y - ay);

        return this;
    },

    transformMat3: function (mat)
    {
        var x = this.x;
        var y = this.y;
        var m = mat.val;

        this.x = m[0] * x + m[3] * y + m[6];
        this.y = m[1] * x + m[4] * y + m[7];

        return this;
    },

    transformMat4: function (mat)
    {
        var x = this.x;
        var y = this.y;
        var m = mat.val;

        this.x = m[0] * x + m[4] * y + m[12];
        this.y = m[1] * x + m[5] * y + m[13];

        return this;
    },

    reset: function ()
    {
        this.x = 0;
        this.y = 0;

        return this;
    }

});

Vector2.prototype.sub = Vector2.prototype.subtract;
Vector2.prototype.mul = Vector2.prototype.multiply;
Vector2.prototype.div = Vector2.prototype.divide;
Vector2.prototype.dist = Vector2.prototype.distance;
Vector2.prototype.distSq = Vector2.prototype.distanceSq;
Vector2.prototype.len = Vector2.prototype.length;
Vector2.prototype.lenSq = Vector2.prototype.lengthSq;

module.exports = Vector2;


/***/ }),
/* 21 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetBottom = function (gameObject)
{
    return (gameObject.y + gameObject.height) - (gameObject.height * gameObject.originY);
};

module.exports = GetBottom;


/***/ }),
/* 22 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetLeft = function (gameObject)
{
    return gameObject.x - (gameObject.width * gameObject.originX);
};

module.exports = GetLeft;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetRight = function (gameObject)
{
    return (gameObject.x + gameObject.width) - (gameObject.width * gameObject.originX);
};

module.exports = GetRight;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

/**
* The y coordinate of the Game Object.
* This is the same as `y - offsetY`.
*
* @property {number} top
*/

var GetTop = function (gameObject)
{
    return gameObject.y - (gameObject.height * gameObject.originY);
};

module.exports = GetTop;


/***/ }),
/* 25 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetBottom = function (gameObject, value)
{
    gameObject.y = (value - gameObject.height) + (gameObject.height * gameObject.originY);

    return gameObject;
};

module.exports = SetBottom;


/***/ }),
/* 26 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetLeft = function (gameObject, value)
{
    gameObject.x = value + (gameObject.width * gameObject.originX);

    return gameObject;
};

module.exports = SetLeft;


/***/ }),
/* 27 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetRight = function (gameObject, value)
{
    gameObject.x = (value - gameObject.width) + (gameObject.width * gameObject.originX);

    return gameObject;
};

module.exports = SetRight;


/***/ }),
/* 28 */
/***/ (function(module, exports) {

/**
* The y coordinate of the Game Object.
* This is the same as `y - offsetY`.
*
* @property {number} top
*/

var SetTop = function (gameObject, value)
{
    gameObject.y = value + (gameObject.height * gameObject.originY);

    return gameObject;
};

module.exports = SetTop;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var DataBuffer32 = new Class({

    initialize:

    function DataBuffer32 (byteSize)
    {
        this.dwordLength = 0;
        this.dwordCapacity = byteSize / 4;
        this.buffer = new ArrayBuffer(byteSize);
        this.floatView = new Float32Array(this.buffer);
        this.intView = new Int32Array(this.buffer);
        this.uintView = new Uint32Array(this.buffer);
    },

    clear: function ()
    {
        this.dwordLength = 0;
    },

    getByteLength: function ()
    {
        return this.dwordLength * 4;
    },

    getByteCapacity: function ()
    {
        return this.buffer.byteLength;
    },

    allocate: function (dwordSize)
    {
        var currentLength = this.dwordLength;
        this.dwordLength += dwordSize;
        return currentLength;
    },

    getUsedBufferAsFloat: function ()
    {
        return this.floatView.subarray(0, this.dwordLength);
    },

    getUsedBufferAsInt: function ()
    {
        return this.intView.subarray(0, this.dwordLength);
    },

    getUsedBufferAsUint: function ()
    {
        return this.uintView.subarray(0, this.dwordLength);
    }

});

module.exports = DataBuffer32;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var EventBinding = __webpack_require__(424);

var EventDispatcher = new Class({

    initialize:

    function EventDispatcher ()
    {
        this.bindings = {};
        this.filters = [];
        this.hasFilters = false;
    },

    getBinding: function (type)
    {
        if (this.bindings.hasOwnProperty(type))
        {
            return this.bindings[type];
        }
    },

    createBinding: function (type)
    {
        if (!this.getBinding(type))
        {
            this.bindings[type] = new EventBinding(this, type);
        }

        return this.bindings[type];
    },

    on: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, false);
        }

        return this;
    },

    once: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, true);
        }

        return this;
    },

    //  Add a callback that is notified every time this EventDispatcher dispatches an event
    //  no matter what the event type is. Filters are invoked first, before any bindings,
    //  and can stop events if they wish (in which case they'll never reach the bindings)
    filter: function (callback)
    {
        var i = this.filters.indexOf(callback);

        if (i === -1)
        {
            //  Add the filter
            this.filters.push(callback);
        }
        else
        {
            //  Remove the filter
            this.filters.splice(i, 1);
        }
        
        this.hasFilters = (this.filters.length > 0);

        return this;
    },

    has: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.has(listener);
        }
        else
        {
            return false;
        }
    },

    total: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.total();
        }
    },

    //  Removes an event listener.
    //  If there is no matching listener registered with the EventDispatcher, a call to this method has no effect.
    off: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.remove(listener);
        }

        return this;
    },

    _dispatchHandler: function (event)
    {
        event.reset(this);

        //  Pass the event through the filters first

        if (this.hasFilters)
        {
            for (var i = 0; i < this.filters.length; i++)
            {
                this.filters[i].call(this, event);

                //  Did the filter kill the event? If so, we can abort now
                if (!event._propagate)
                {
                    return;
                }
            }
        }

        var binding = this.getBinding(event.type);

        if (binding)
        {
            binding.dispatch(event);
        }
    },

    dispatch: function (event)
    {
        if (Array.isArray(event))
        {
            for (var i = 0; i < event.length; i++)
            {
                this._dispatchHandler(event[i]);
            }
        }
        else
        {
            this._dispatchHandler(event);
        }
    },

    //  Removes all listeners, but retains the event type entries
    removeAll: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.removeAll();
        }

        return this;
    },

    removeAllFilters: function ()
    {
        this.filters.length = 0;

        this.hasFilters = false;

        return this;
    },

    delete: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.destroy();

            delete this.bindings[type];
        }

        return this;
    },

    deleteAll: function ()
    {
        for (var binding in this.bindings)
        {
            binding.destroy();
        }

        this.bindings = {};
    },

    destroy: function ()
    {
        this.deleteAll();
        this.removeAllFilters();
    }

});

module.exports = EventDispatcher;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var GameObject = __webpack_require__(1);
var Components = __webpack_require__(8);
var SpriteRender = __webpack_require__(531);

var Sprite = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.ScrollFactor,
        Components.Size,
        Components.Texture,
        Components.Tint,
        Components.Transform,
        Components.Visible,
        SpriteRender
    ],

    initialize:

    function Sprite (scene, x, y, texture, frame)
    {
        GameObject.call(this, scene, 'Sprite');

        this.anims = new Components.Animation(this);

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
    },

    preUpdate: function (time, delta)
    {
        this.anims.update(time, delta);
    },

    play: function (key, startFrame)
    {
        this.anims.play(key, startFrame);

        return this;
    },

    toJSON: function ()
    {
        var data = Components.ToJSON(this);

        //  Extra Sprite data is added here

        return data;
    }

});

module.exports = Sprite;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

var Contains = function (rect, x, y)
{
    if (rect.width <= 0 || rect.height <= 0)
    {
        return false;
    }

    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);
};

module.exports = Contains;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GetColor = __webpack_require__(100);
var GetColor32 = __webpack_require__(177);

var Color = new Class({

    initialize:

    function Color (red, green, blue, alpha)
    {
        if (red === undefined) { red = 0; }
        if (green === undefined) { green = 0; }
        if (blue === undefined) { blue = 0; }
        if (alpha === undefined) { alpha = 255; }

        //  All private
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 255;

        this.gl = [ 0.0, 0.0, 0.0, 1.0 ];

        this._color = 0;
        this._color32 = 0;
        this._rgba = '';

        this.setTo(red, green, blue, alpha);
    },

    transparent: function ()
    {
        this.red = 0;
        this.green = 0;
        this.blue = 0;
        this.alpha = 0;

        return this.update();
    },

    //  Values are in the range 0 to 255
    setTo: function (red, green, blue, alpha)
    {
        if (alpha === undefined) { alpha = 255; }

        this.red = red;
        this.green = green;
        this.blue = blue;
        this.alpha = alpha;

        return this.update();
    },

    //  Values are in the range 0 to 1
    setGLTo: function (red, green, blue, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.redGL = red;
        this.greenGL = green;
        this.blueGL = blue;
        this.alphaGL = alpha;

        return this.update();
    },

    setFromRGB: function (color)
    {
        this.red = color.r;
        this.green = color.g;
        this.blue = color.b;

        if (color.hasOwnProperty('a'))
        {
            this.alpha = color.a;
        }

        return this.update();
    },

    update: function ()
    {
        this._color = GetColor(this.r, this.g, this.b);
        this._color32 = GetColor32(this.r, this.g, this.b, this.a);
        this._rgba = 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + (this.a / 255) + ')';

        return this;
    },

    //  Same as setRGB but performs safety checks on all the values given
    clone: function ()
    {
        return new Color(this.r, this.g, this.b, this.a);
    },

    color: {

        get: function ()
        {
            return this._color;
        }

    },

    color32: {

        get: function ()
        {
            return this._color32;
        }

    },

    rgba: {

        get: function ()
        {
            return this._rgba;
        }

    },

    //  Gets and sets the red value, normalized to the 0 to 1 range
    redGL: {

        get: function ()
        {
            return this.gl[0];
        },

        set: function (value)
        {
            this.gl[0] = Math.min(Math.abs(value), 1);

            this.r = Math.floor(this.gl[0] * 255);

            this.update();
        }

    },

    greenGL: {

        get: function ()
        {
            return this.gl[1];
        },

        set: function (value)
        {
            this.gl[1] = Math.min(Math.abs(value), 1);

            this.g = Math.floor(this.gl[1] * 255);

            this.update();
        }

    },

    blueGL: {

        get: function ()
        {
            return this.gl[2];
        },

        set: function (value)
        {
            this.gl[2] = Math.min(Math.abs(value), 1);

            this.b = Math.floor(this.gl[2] * 255);

            this.update();
        }

    },

    alphaGL: {

        get: function ()
        {
            return this.gl[3];
        },

        set: function (value)
        {
            this.gl[3] = Math.min(Math.abs(value), 1);

            this.a = Math.floor(this.gl[3] * 255);

            this.update();
        }

    },

    //  Gets and sets the red value, normalized to the 0 to 255 range
    red: {

        get: function ()
        {
            return this.r;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.r = Math.min(value, 255);

            this.gl[0] = value / 255;

            this.update();
        }

    },

    green: {

        get: function ()
        {
            return this.g;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.g = Math.min(value, 255);

            this.gl[1] = value / 255;

            this.update();
        }

    },

    blue: {

        get: function ()
        {
            return this.b;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.b = Math.min(value, 255);

            this.gl[2] = value / 255;

            this.update();
        }

    },

    alpha: {

        get: function ()
        {
            return this.a;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.a = Math.min(value, 255);

            this.gl[3] = value / 255;

            this.update();
        }

    }

});

module.exports = Color;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji 
//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl

var Class = __webpack_require__(0);

var Vector3 = new Class({

    initialize:

    function Vector3 (x, y, z)
    {
        if (typeof x === 'object')
        {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
        }
        else
        {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
        }
    },

    clone: function ()
    {
        return new Vector3(this.x, this.y, this.z);
    },

    crossVectors: function (a, b)
    {
        var ax = a.x;
        var ay = a.y;
        var az = a.z;
        var bx = b.x;
        var by = b.y;
        var bz = b.z;

        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;

        return this;
    },

    equals: function (v)
    {
        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z));
    },

    copy: function (src)
    {
        this.x = src.x;
        this.y = src.y;
        this.z = src.z || 0;

        return this;
    },

    set: function (x, y, z)
    {
        if (typeof x === 'object')
        {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
        }
        else
        {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
        }

        return this;
    },

    add: function (v)
    {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z || 0;

        return this;
    },

    subtract: function (v)
    {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z || 0;

        return this;
    },

    multiply: function (v)
    {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z || 1;

        return this;
    },

    scale: function (scale)
    {
        if (isFinite(scale))
        {
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
        }
        else
        {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }

        return this;
    },

    divide: function (v)
    {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z || 1;

        return this;
    },

    negate: function ()
    {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;

        return this;
    },

    distance: function (v)
    {
        var dx = v.x - this.x;
        var dy = v.y - this.y;
        var dz = v.z - this.z || 0;

        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    },

    distanceSq: function (v)
    {
        var dx = v.x - this.x;
        var dy = v.y - this.y;
        var dz = v.z - this.z || 0;

        return dx * dx + dy * dy + dz * dz;
    },

    length: function ()
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;

        return Math.sqrt(x * x + y * y + z * z);
    },

    lengthSq: function ()
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;

        return x * x + y * y + z * z;
    },

    normalize: function ()
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var len = x * x + y * y + z * z;

        if (len > 0)
        {
            len = 1 / Math.sqrt(len);

            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
        }

        return this;
    },

    dot: function (v)
    {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    },

    cross: function (v)
    {
        var ax = this.x;
        var ay = this.y;
        var az = this.z;
        var bx = v.x;
        var by = v.y;
        var bz = v.z;

        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;

        return this;
    },

    lerp: function (v, t)
    {
        if (t === undefined) { t = 0; }

        var ax = this.x;
        var ay = this.y;
        var az = this.z;

        this.x = ax + t * (v.x - ax);
        this.y = ay + t * (v.y - ay);
        this.z = az + t * (v.z - az);

        return this;
    },

    transformMat3: function (mat)
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var m = mat.val;

        this.x = x * m[0] + y * m[3] + z * m[6];
        this.y = x * m[1] + y * m[4] + z * m[7];
        this.z = x * m[2] + y * m[5] + z * m[8];

        return this;
    },

    transformMat4: function (mat)
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var m = mat.val;

        this.x = m[0] * x + m[4] * y + m[8] * z + m[12];
        this.y = m[1] * x + m[5] * y + m[9] * z + m[13];
        this.z = m[2] * x + m[6] * y + m[10] * z + m[14];

        return this;
    },

    transformQuat: function (q)
    {
        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;

        // calculate quat * vec
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return this;
    },

    /**
     * Multiplies this Vector3 by the specified matrix, 
     * applying a W divide. This is useful for projection,
     * e.g. unprojecting a 2D point into 3D space.
     *
     * @method project
     * @param {Matrix4} the 4x4 matrix to multiply with 
     * @return {Vector3} this object for chaining
     */
    project: function (mat)
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var m = mat.val;

        var a00 = m[0];
        var a01 = m[1];
        var a02 = m[2];
        var a03 = m[3];
        var a10 = m[4];
        var a11 = m[5];
        var a12 = m[6];
        var a13 = m[7];
        var a20 = m[8];
        var a21 = m[9];
        var a22 = m[10];
        var a23 = m[11];
        var a30 = m[12];
        var a31 = m[13];
        var a32 = m[14];
        var a33 = m[15];

        var lw = 1 / (x * a03 + y * a13 + z * a23 + a33);

        this.x = (x * a00 + y * a10 + z * a20 + a30) * lw;
        this.y = (x * a01 + y * a11 + z * a21 + a31) * lw;
        this.z = (x * a02 + y * a12 + z * a22 + a32) * lw;

        return this;
    },

    /**
     * Unproject this point from 2D space to 3D space.
     * The point should have its x and y properties set to
     * 2D screen space, and the z either at 0 (near plane)
     * or 1 (far plane). The provided matrix is assumed to already
     * be combined, i.e. projection * view * model.
     *
     * After this operation, this vector's (x, y, z) components will
     * represent the unprojected 3D coordinate.
     * 
     * @param  {Vector4} viewport          screen x, y, width and height in pixels
     * @param  {Matrix4} invProjectionView combined projection and view matrix
     * @return {Vector3}                   this object, for chaining
     */
    unproject: function (viewport, invProjectionView)
    {
        var viewX = viewport.x;
        var viewY = viewport.y;
        var viewWidth = viewport.z;
        var viewHeight = viewport.w;
        
        var x = this.x - viewX;
        var y = (viewHeight - this.y - 1) - viewY;
        var z = this.z;

        this.x = (2 * x) / viewWidth - 1;
        this.y = (2 * y) / viewHeight - 1;
        this.z = 2 * z - 1;

        return this.project(invProjectionView);
    },

    reset: function ()
    {
        this.x = 0;
        this.y = 0;
        this.z = 0;

        return this;
    }

});

Vector3.prototype.sub = Vector3.prototype.subtract;
Vector3.prototype.mul = Vector3.prototype.multiply;
Vector3.prototype.div = Vector3.prototype.divide;
Vector3.prototype.dist = Vector3.prototype.distance;
Vector3.prototype.distSq = Vector3.prototype.distanceSq;
Vector3.prototype.len = Vector3.prototype.length;
Vector3.prototype.lenSq = Vector3.prototype.lengthSq;

module.exports = Vector3;


/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = {

    DEFAULT: 0,
    LINEAR: 0,
    NEAREST: 1

};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var DataBuffer16 = new Class({

    initialize:

    function DataBuffer16 (byteSize)
    {
        this.wordLength = 0;
        this.wordCapacity = byteSize / 2;
        this.buffer = new ArrayBuffer(byteSize);
        this.intView = new Int16Array(this.buffer);
        this.uintView = new Uint16Array(this.buffer);
    },

    clear: function ()
    {
        this.wordLength = 0;
    },

    getByteLength: function ()
    {
        return this.wordLength * 2;
    },

    getByteCapacity: function () 
    {
        return this.buffer.byteLength;
    },

    allocate: function (wordSize)
    {
        var currentLength = this.wordLength;
        this.wordLength += wordSize;
        return currentLength;
    },

    getUsedBufferAsShort: function ()
    {
        return this.intView.subarray(0, this.wordLength);
    },

    getUsedBufferAsWord: function ()
    {
        return this.uintView.subarray(0, this.wordLength);
    }

});

module.exports = DataBuffer16;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(16);
var File = __webpack_require__(19);
var GetFastValue = __webpack_require__(11);

//  Phaser.Loader.FileTypes.ImageFile

var ImageFile = new Class({

    Extends: File,

    initialize:

    // this.load.image('pic', 'assets/pics/taikodrummaster.jpg');
    // this.load.image({ key: 'pic', file: 'assets/pics/taikodrummaster.jpg' });
    // this.load.image({
    //     key: 'bunny',
    //     file: 'assets/sprites/bunny.png',
    //     xhr: {
    //         user: 'root',
    //         password: 'th3G1bs0n',
    //         timeout: 30,
    //         header: 'Content-Type',
    //         headerValue: 'text/xml'
    //     }
    // });
    // this.load.image({ key: 'bunny' });
    // this.load.image({ key: 'bunny', extension: 'jpg' });
    function ImageFile (key, url, path, xhrSettings, config)
    {
        var fileKey = (typeof key === 'string') ? key : GetFastValue(key, 'key', '');

        var fileConfig = {
            type: 'image',
            extension: GetFastValue(key, 'extension', 'png'),
            responseType: 'blob',
            key: fileKey,
            url: GetFastValue(key, 'file', url),
            path: path,
            xhrSettings: GetFastValue(key, 'xhr', xhrSettings),
            config: GetFastValue(key, 'config', config)
        };

        File.call(this, fileConfig);
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.data = new Image();

        this.data.crossOrigin = this.crossOrigin;

        var _this = this;

        this.data.onload = function ()
        {
            URL.revokeObjectURL(_this.data.src);

            _this.onComplete();

            callback(_this);
        };

        this.data.onerror = function ()
        {
            URL.revokeObjectURL(_this.data.src);

            _this.state = CONST.FILE_ERRORED;

            callback(_this);
        };

        this.data.src = URL.createObjectURL(this.xhrLoader.response);
    }

});

ImageFile.create = function (loader, key, url, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new ImageFile(key[i], url, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new ImageFile(key, url, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = ImageFile;


/***/ }),
/* 38 */
/***/ (function(module, exports) {

var Contains = function (circle, x, y)
{
    //  Check if x/y are within the bounds first
    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom)
    {
        var dx = (circle.x - x) * (circle.x - x);
        var dy = (circle.y - y) * (circle.y - y);

        return (dx + dy) <= (circle.radius * circle.radius);
    }
    else
    {
        return false;
    }
};

module.exports = Contains;


/***/ }),
/* 39 */
/***/ (function(module, exports) {

var Angle = function (line)
{
    return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
};

module.exports = Angle;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

// A triangle is a plane created by connecting three points.
// The first two arguments specify the first point, the middle two arguments
// specify the second point, and the last two arguments specify the third point.

var Triangle = new Class({

    initialize:

    function Triangle (x1, y1, x2, y2, x3, y3)
    {
        this.x1 = 0;
        this.y1 = 0;

        this.x2 = 0;
        this.y2 = 0;

        this.x3 = 0;
        this.y3 = 0;

        this.setTo(x1, y1, x2, y2, x3, y3);
    },

    setTo: function (x1, y1, x2, y2, x3, y3)
    {
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }
        if (x3 === undefined) { x3 = 0; }
        if (y3 === undefined) { y3 = 0; }

        this.x1 = x1;
        this.y1 = y1;

        this.x2 = x2;
        this.y2 = y2;

        this.x3 = x3;
        this.y3 = y3;

        return this;
    },

    getLineA: function ()
    {
        return { x1: this.x1, y1: this.y1, x2: this.x2, y2: this.y2 };
    },

    getLineB: function ()
    {
        return { x1: this.x2, y1: this.y2, x2: this.x3, y2: this.y3 };
    },

    getLineC: function ()
    {
        return { x1: this.x3, y1: this.y3, x2: this.x1, y2: this.y1 };
    },

    left: {

        get: function ()
        {
            return Math.min(this.x1, this.x2, this.x3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.x1 <= this.x2 && this.x1 <= this.x3)
            {
                diff = this.x1 - value;
            }
            else if (this.x2 <= this.x1 && this.x2 <= this.x3)
            {
                diff = this.x2 - value;
            }
            else
            {
                diff = this.x3 - value;
            }

            this.x1 -= diff;
            this.x2 -= diff;
            this.x3 -= diff;
        }

    },

    right: {

        get: function ()
        {
            return Math.max(this.x1, this.x2, this.x3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.x1 >= this.x2 && this.x1 >= this.x3)
            {
                diff = this.x1 - value;
            }
            else if (this.x2 >= this.x1 && this.x2 >= this.x3)
            {
                diff = this.x2 - value;
            }
            else
            {
                diff = this.x3 - value;
            }

            this.x1 -= diff;
            this.x2 -= diff;
            this.x3 -= diff;
        }

    },

    top: {

        get: function ()
        {
            return Math.min(this.y1, this.y2, this.y3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.y1 <= this.y2 && this.y1 <= this.y3)
            {
                diff = this.y1 - value;
            }
            else if (this.y2 <= this.y1 && this.y2 <= this.y3)
            {
                diff = this.y2 - value;
            }
            else
            {
                diff = this.y3 - value;
            }

            this.y1 -= diff;
            this.y2 -= diff;
            this.y3 -= diff;
        }

    },

    bottom: {

        get: function ()
        {
            return Math.max(this.y1, this.y2, this.y3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.y1 >= this.y2 && this.y1 >= this.y3)
            {
                diff = this.y1 - value;
            }
            else if (this.y2 >= this.y1 && this.y2 >= this.y3)
            {
                diff = this.y2 - value;
            }
            else
            {
                diff = this.y3 - value;
            }

            this.y1 -= diff;
            this.y2 -= diff;
            this.y3 -= diff;
        }

    }

});

module.exports = Triangle;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Events

module.exports = {

    DRAG: __webpack_require__(730),
    DRAG_END: __webpack_require__(728),
    DRAG_ENTER: __webpack_require__(729),
    DRAG_LEAVE: __webpack_require__(731),
    DRAG_OVER: __webpack_require__(732),
    DRAG_START: __webpack_require__(733),
    DROP: __webpack_require__(734),

    GAME_OBJECT_DOWN: __webpack_require__(735),
    GAME_OBJECT_MOVE: __webpack_require__(736),
    GAME_OBJECT_OUT: __webpack_require__(737),
    GAME_OBJECT_OVER: __webpack_require__(738),
    GAME_OBJECT_UP: __webpack_require__(739),

    POINTER_DOWN: __webpack_require__(740),
    POINTER_MOVE: __webpack_require__(741),
    POINTER_OUT: __webpack_require__(742),
    POINTER_OVER: __webpack_require__(743),
    POINTER_UP: __webpack_require__(744)

};


/***/ }),
/* 42 */
/***/ (function(module, exports) {

//  Phaser.BlendModes

module.exports = {

    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16

};


/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = {
    vert: [
        'uniform mat4 u_view_matrix;',
        'attribute vec2 a_position;',
        'attribute vec2 a_tex_coord;',
        'attribute vec3 a_color;',
        'attribute float a_alpha;',
        'varying vec2 v_tex_coord;',
        'varying vec3 v_color;',
        'varying float v_alpha;',
        'void main () {',
        '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
        '   v_tex_coord = a_tex_coord;',
        '   v_color = a_color;',
        '   v_alpha = a_alpha;',
        '}'
    ].join('\n'),
    frag: [
        'precision mediump float;',
        'uniform sampler2D u_sampler2D;',
        'varying vec2 v_tex_coord;',
        'varying vec3 v_color;',
        'varying float v_alpha;',
        'void main() {',
        '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord) * vec4(v_color, v_alpha);',
        '}'
    ].join('\n')
};


/***/ }),
/* 44 */
/***/ (function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var GetCenterX = function (gameObject)
{
    return gameObject.x - (gameObject.width * gameObject.originX) + (gameObject.width * 0.5);
};

module.exports = GetCenterX;


/***/ }),
/* 45 */
/***/ (function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var GetCenterY = function (gameObject)
{
    return gameObject.y - (gameObject.height * gameObject.originY) + (gameObject.height * 0.5);
};

module.exports = GetCenterY;


/***/ }),
/* 46 */
/***/ (function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

//  Phaser.Utils.Bounds.GetCenterX(bob)
//  Phaser.Utils.Bounds.CenterOn(bob, x, y)
//  Phaser.Utils.Bounds.CenterX(bob, x)
//  Phaser.Utils.Bounds.CenterY(bob, x)

var SetCenterX = function (gameObject, x)
{
    var offsetX = gameObject.width * gameObject.originX;

    gameObject.x = (x + offsetX) - (gameObject.width * 0.5);

    return gameObject;
};

module.exports = SetCenterX;


/***/ }),
/* 47 */
/***/ (function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

//  Phaser.Utils.Bounds.GetCenterX(bob)
//  Phaser.Utils.Bounds.CenterOn(bob, x, y)
//  Phaser.Utils.Bounds.CenterX(bob, x)
//  Phaser.Utils.Bounds.CenterY(bob, x)

var SetCenterY = function (gameObject, y)
{
    var offsetY = gameObject.height * gameObject.originY;

    gameObject.y = (y + offsetY) - (gameObject.height * 0.5);

    return gameObject;
};

module.exports = SetCenterY;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var Systems = __webpack_require__(232);

var Scene = new Class({

    initialize:

    function Scene (config)
    {
        //  The Scene Systems. You must never overwrite this property, or all hell will break lose.
        this.sys = new Systems(this, config);
    },

    //  Should be overridden by your own Scenes
    update: function ()
    {
    },

    //  Should be overridden by your own Scenes
    render: function ()
    {
    }

});

module.exports = Scene;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    ADD_ANIMATION_EVENT: __webpack_require__(339),
    PAUSE_ALL_ANIMATION_EVENT: __webpack_require__(340),
    REMOVE_ANIMATION_EVENT: __webpack_require__(341),
    RESUME_ALL_ANIMATION_EVENT: __webpack_require__(342)
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var OS = {

    //  @property {boolean} desktop - Is running on a desktop?
    desktop: false,

    //  @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView
    webApp: false,

    //  @property {boolean} iOS - Is running on iOS?
    iOS: false,

    //  @property {number} iOSVersion - If running in iOS this will contain the major version number.
    iOSVersion: 0,

    //  @property {boolean} iPhone - Is running on iPhone?
    iPhone: false,

    //  @property {boolean} iPad - Is running on iPad?
    iPad: false,

    //  @property {boolean} cocoonJS - Is the game running under CocoonJS?
    cocoonJS: false,
    
    //  @property {boolean} cocoonJSApp - Is this game running with CocoonJS.App?
    cocoonJSApp: false,
    
    //  @property {boolean} cordova - Is the game running under Apache Cordova?
    cordova: false,
    
    //  @property {boolean} node - Is the game running under Node.js?
    node: false,
    
    //  @property {boolean} nodeWebkit - Is the game running under Node-Webkit?
    nodeWebkit: false,
    
    //  @property {boolean} electron - Is the game running under GitHub Electron?
    electron: false,
    
    //  @property {boolean} ejecta - Is the game running under Ejecta?
    ejecta: false,

    //  @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?
    crosswalk: false,

    //  @property {boolean} android - Is running on android?
    android: false,

    //  @property {boolean} chromeOS - Is running on chromeOS?
    chromeOS: false,

    //  @property {boolean} linux - Is running on linux?
    linux: false,

    //  @property {boolean} macOS - Is running on macOS?
    macOS: false,

    //  @property {boolean} windows - Is running on windows?
    windows: false,

    //  @property {boolean} windowsPhone - Is running on a Windows Phone?
    windowsPhone: false,

    //  @property {boolean} vita - Is running on a PlayStation Vita?
    vita: false,

    //  @property {boolean} kindle - Is running on an Amazon Kindle?
    kindle: false,

    //  @property {number} pixelRatio - PixelRatio of the host device?
    pixelRatio: 1

};

function init ()
{
    var ua = navigator.userAgent;

    if (/Windows/.test(ua))
    {
        OS.windows = true;
    }
    else if (/Mac OS/.test(ua))
    {
        OS.macOS = true;
    }
    else if (/Linux/.test(ua))
    {
        OS.linux = true;
    }
    else if (/Android/.test(ua))
    {
        OS.android = true;
    }
    else if (/iP[ao]d|iPhone/i.test(ua))
    {
        OS.iOS = true;
        (navigator.appVersion).match(/OS (\d+)/);
        OS.iOSVersion = parseInt(RegExp.$1, 10);
    }
    else if (/Kindle/.test(ua) || (/\bKF[A-Z][A-Z]+/).test(ua) || (/Silk.*Mobile Safari/).test(ua))
    {
        OS.kindle = true;

        // This will NOT detect early generations of Kindle Fire, I think there is no reliable way...
        // E.g. "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-us; Silk/1.1.0-80) AppleWebKit/533.16 (KHTML, like Gecko) Version/5.0 Safari/533.16 Silk-Accelerated=true"
    }
    else if (/CrOS/.test(ua))
    {
        OS.chromeOS = true;
    }
    else if ((/Playstation Vita/).test(ua))
    {
        OS.vita = true;
    }

    if (/Windows Phone/i.test(ua) || (/IEMobile/i).test(ua))
    {
        OS.android = false;
        OS.iOS = false;
        OS.macOS = false;
        OS.windows = true;
        OS.windowsPhone = true;
    }

    var silk = (/Silk/).test(ua);

    if (OS.windows || OS.macOS || (OS.linux && !silk) || OS.chromeOS)
    {
        OS.desktop = true;
    }

    //  Windows Phone / Table reset
    if (OS.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua))))
    {
        OS.desktop = false;
    }

    //  WebApp mode in iOS
    if (navigator.standalone)
    {
        OS.webApp = true;
    }
    
    if (window.cordova !== undefined)
    {
        OS.cordova = true;
    }
    
    if ((typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined'))
    {
        OS.node = true;
    }
    
    if (OS.node && typeof process.versions === 'object')
    {
        OS.nodeWebkit = !!process.versions['node-webkit'];
        
        OS.electron = !!process.versions.electron;
    }
    
    if (navigator.isCocoonJS)
    {
        OS.cocoonJS = true;

        try
        {
            OS.cocoonJSApp = (typeof CocoonJS !== 'undefined');
        }
        catch (error)
        {
            OS.cocoonJSApp = false;
        }
    }

    if (window.ejecta !== undefined)
    {
        OS.ejecta = true;
    }

    if ((/Crosswalk/).test(ua))
    {
        OS.crosswalk = true;
    }

    OS.iPhone = ua.toLowerCase().indexOf('iphone') !== -1;
    OS.iPad = ua.toLowerCase().indexOf('ipad') !== -1;

    OS.pixelRatio = window['devicePixelRatio'] || 1;

    return OS;
}

module.exports = init();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(275)))

/***/ }),
/* 51 */
/***/ (function(module, exports) {

//  http://www.blackpawn.com/texts/pointinpoly/

var Contains = function (triangle, x, y)
{
    var v0x = triangle.x3 - triangle.x1;
    var v0y = triangle.y3 - triangle.y1;

    var v1x = triangle.x2 - triangle.x1;
    var v1y = triangle.y2 - triangle.y1;

    var v2x = x - triangle.x1;
    var v2y = y - triangle.y1;

    var dot00 = (v0x * v0x) + (v0y * v0y);
    var dot01 = (v0x * v1x) + (v0y * v1y);
    var dot02 = (v0x * v2x) + (v0y * v2y);
    var dot11 = (v1x * v1x) + (v1y * v1y);
    var dot12 = (v1x * v2x) + (v1y * v2y);

    // Compute barycentric coordinates
    var b = ((dot00 * dot11) - (dot01 * dot01));
    var inv = (b === 0) ? 0 : (1 / b);
    var u = ((dot11 * dot02) - (dot01 * dot12)) * inv;
    var v = ((dot00 * dot12) - (dot01 * dot02)) * inv;

    return (u >= 0 && v >= 0 && (u + v < 1));
};

module.exports = Contains;


/***/ }),
/* 52 */
/***/ (function(module, exports) {

/**
* Force a value within the boundaries by clamping it to the range `min`, `max`.
*
* @method Phaser.Math#clamp
* @param {float} v - The value to be clamped.
* @param {float} min - The minimum bounds.
* @param {float} max - The maximum bounds.
* @return {number} The clamped value.
*/
var Clamp = function (value, min, max)
{
    return Math.max(min, Math.min(max, value));
};

module.exports = Clamp;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji 
//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl

var Class = __webpack_require__(0);

var EPSILON = 0.000001;

var Matrix4 = new Class({

    initialize:

    function Matrix4 (m)
    {
        this.val = new Float32Array(16);

        if (m)
        {
            //  Assume Matrix4 with val:
            this.copy(m);
        }
        else
        {
            //  Default to identity
            this.identity();
        }
    },

    clone: function ()
    {
        return new Matrix4(this);
    },

    set: function (src)
    {
        return this.copy(src);
    },

    copy: function (src)
    {
        var out = this.val;
        var a = src.val;

        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];

        return this;
    },

    fromArray: function (a)
    {
        var out = this.val;

        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];

        return this;
    },

    identity: function ()
    {
        var out = this.val;

        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;

        return this;
    },

    transpose: function ()
    {
        var a = this.val;

        var a01 = a[1];
        var a02 = a[2];
        var a03 = a[3];
        var a12 = a[6];
        var a13 = a[7];
        var a23 = a[11];

        a[1] = a[4];
        a[2] = a[8];
        a[3] = a[12];
        a[4] = a01;
        a[6] = a[9];
        a[7] = a[13];
        a[8] = a02;
        a[9] = a12;
        a[11] = a[14];
        a[12] = a03;
        a[13] = a13;
        a[14] = a23;

        return this;
    },

    invert: function ()
    {
        var a = this.val;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a03 = a[3];

        var a10 = a[4];
        var a11 = a[5];
        var a12 = a[6];
        var a13 = a[7];

        var a20 = a[8];
        var a21 = a[9];
        var a22 = a[10];
        var a23 = a[11];

        var a30 = a[12];
        var a31 = a[13];
        var a32 = a[14];
        var a33 = a[15];

        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;

        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;

        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;


        // Calculate the determinant
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det)
        {
            return null;
        }

        det = 1 / det;

        a[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        a[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        a[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        a[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        a[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        a[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        a[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        a[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        a[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        a[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        a[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        a[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        a[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        a[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        a[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        a[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

        return this;
    },

    adjoint: function ()
    {
        var a = this.val;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a03 = a[3];

        var a10 = a[4];
        var a11 = a[5];
        var a12 = a[6];
        var a13 = a[7];

        var a20 = a[8];
        var a21 = a[9];
        var a22 = a[10];
        var a23 = a[11];

        var a30 = a[12];
        var a31 = a[13];
        var a32 = a[14];
        var a33 = a[15];

        a[0] = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
        a[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
        a[2] = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
        a[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
        a[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
        a[5] = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
        a[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
        a[7] = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
        a[8] = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
        a[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
        a[10] = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
        a[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
        a[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
        a[13] = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
        a[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
        a[15] = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));

        return this;
    },

    determinant: function ()
    {
        var a = this.val;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a03 = a[3];

        var a10 = a[4];
        var a11 = a[5];
        var a12 = a[6];
        var a13 = a[7];

        var a20 = a[8];
        var a21 = a[9];
        var a22 = a[10];
        var a23 = a[11];

        var a30 = a[12];
        var a31 = a[13];
        var a32 = a[14];
        var a33 = a[15];

        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;

        // Calculate the determinant
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    },

    multiply: function (src)
    {
        var a = this.val;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a03 = a[3];

        var a10 = a[4];
        var a11 = a[5];
        var a12 = a[6];
        var a13 = a[7];

        var a20 = a[8];
        var a21 = a[9];
        var a22 = a[10];
        var a23 = a[11];

        var a30 = a[12];
        var a31 = a[13];
        var a32 = a[14];
        var a33 = a[15];

        var b = src.val;

        // Cache only the current line of the second matrix
        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        var b3 = b[3];

        a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];

        a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];

        a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];

        a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        return this;
    },

    translate: function (v)
    {
        var x = v.x;
        var y = v.y;
        var z = v.z;
        var a = this.val;

        a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];

        return this;
    },

    scale: function (v)
    {
        var x = v.x;
        var y = v.y;
        var z = v.z;
        var a = this.val;

        a[0] = a[0] * x;
        a[1] = a[1] * x;
        a[2] = a[2] * x;
        a[3] = a[3] * x;

        a[4] = a[4] * y;
        a[5] = a[5] * y;
        a[6] = a[6] * y;
        a[7] = a[7] * y;

        a[8] = a[8] * z;
        a[9] = a[9] * z;
        a[10] = a[10] * z;
        a[11] = a[11] * z;

        return this;
    },

    //  Axis = vec3, angle = radians
    makeRotationAxis: function (axis, angle)
    {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp

        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x;
        var y = axis.y;
        var z = axis.z;
        var tx = t * x;
        var ty = t * y;

        this.set(
            tx * x + c, tx * y - s * z, tx * z + s * y, 0,
            tx * y + s * z, ty * y + c, ty * z - s * x, 0,
            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
            0, 0, 0, 1
        );

        return this;
    },

    rotate: function (rad, axis)
    {
        var a = this.val;
        var x = axis.x;
        var y = axis.y;
        var z = axis.z;
        var len = Math.sqrt(x * x + y * y + z * z);

        if (Math.abs(len) < EPSILON)
        {
            return null;
        }
        
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;

        var s = Math.sin(rad);
        var c = Math.cos(rad);
        var t = 1 - c;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a03 = a[3];

        var a10 = a[4];
        var a11 = a[5];
        var a12 = a[6];
        var a13 = a[7];

        var a20 = a[8];
        var a21 = a[9];
        var a22 = a[10];
        var a23 = a[11];

        // Construct the elements of the rotation matrix
        var b00 = x * x * t + c;
        var b01 = y * x * t + z * s;
        var b02 = z * x * t - y * s;

        var b10 = x * y * t - z * s;
        var b11 = y * y * t + c;
        var b12 = z * y * t + x * s;

        var b20 = x * z * t + y * s;
        var b21 = y * z * t - x * s;
        var b22 = z * z * t + c;

        // Perform rotation-specific matrix multiplication
        a[0] = a00 * b00 + a10 * b01 + a20 * b02;
        a[1] = a01 * b00 + a11 * b01 + a21 * b02;
        a[2] = a02 * b00 + a12 * b01 + a22 * b02;
        a[3] = a03 * b00 + a13 * b01 + a23 * b02;
        a[4] = a00 * b10 + a10 * b11 + a20 * b12;
        a[5] = a01 * b10 + a11 * b11 + a21 * b12;
        a[6] = a02 * b10 + a12 * b11 + a22 * b12;
        a[7] = a03 * b10 + a13 * b11 + a23 * b12;
        a[8] = a00 * b20 + a10 * b21 + a20 * b22;
        a[9] = a01 * b20 + a11 * b21 + a21 * b22;
        a[10] = a02 * b20 + a12 * b21 + a22 * b22;
        a[11] = a03 * b20 + a13 * b21 + a23 * b22;

        return this;
    },

    rotateX: function (rad)
    {
        var a = this.val;
        var s = Math.sin(rad);
        var c = Math.cos(rad);

        var a10 = a[4];
        var a11 = a[5];
        var a12 = a[6];
        var a13 = a[7];

        var a20 = a[8];
        var a21 = a[9];
        var a22 = a[10];
        var a23 = a[11];

        // Perform axis-specific matrix multiplication
        a[4] = a10 * c + a20 * s;
        a[5] = a11 * c + a21 * s;
        a[6] = a12 * c + a22 * s;
        a[7] = a13 * c + a23 * s;
        a[8] = a20 * c - a10 * s;
        a[9] = a21 * c - a11 * s;
        a[10] = a22 * c - a12 * s;
        a[11] = a23 * c - a13 * s;

        return this;
    },

    rotateY: function (rad)
    {
        var a = this.val;
        var s = Math.sin(rad);
        var c = Math.cos(rad);

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a03 = a[3];

        var a20 = a[8];
        var a21 = a[9];
        var a22 = a[10];
        var a23 = a[11];

        // Perform axis-specific matrix multiplication
        a[0] = a00 * c - a20 * s;
        a[1] = a01 * c - a21 * s;
        a[2] = a02 * c - a22 * s;
        a[3] = a03 * c - a23 * s;
        a[8] = a00 * s + a20 * c;
        a[9] = a01 * s + a21 * c;
        a[10] = a02 * s + a22 * c;
        a[11] = a03 * s + a23 * c;

        return this;
    },

    rotateZ: function (rad)
    {
        var a = this.val;
        var s = Math.sin(rad);
        var c = Math.cos(rad);

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a03 = a[3];

        var a10 = a[4];
        var a11 = a[5];
        var a12 = a[6];
        var a13 = a[7];

        // Perform axis-specific matrix multiplication
        a[0] = a00 * c + a10 * s;
        a[1] = a01 * c + a11 * s;
        a[2] = a02 * c + a12 * s;
        a[3] = a03 * c + a13 * s;
        a[4] = a10 * c - a00 * s;
        a[5] = a11 * c - a01 * s;
        a[6] = a12 * c - a02 * s;
        a[7] = a13 * c - a03 * s;

        return this;
    },

    fromRotationTranslation: function (q, v)
    {
        // Quaternion math
        var out = this.val;

        var x = q.x;
        var y = q.y;
        var z = q.z;
        var w = q.w;

        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;

        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;

        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;

        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;

        out[0] = 1 - (yy + zz);
        out[1] = xy + wz;
        out[2] = xz - wy;
        out[3] = 0;

        out[4] = xy - wz;
        out[5] = 1 - (xx + zz);
        out[6] = yz + wx;
        out[7] = 0;

        out[8] = xz + wy;
        out[9] = yz - wx;
        out[10] = 1 - (xx + yy);
        out[11] = 0;

        out[12] = v.x;
        out[13] = v.y;
        out[14] = v.z;
        out[15] = 1;

        return this;
    },

    fromQuat: function (q)
    {
        var out = this.val;

        var x = q.x;
        var y = q.y;
        var z = q.z;
        var w = q.w;

        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;

        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;

        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;

        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;

        out[0] = 1 - (yy + zz);
        out[1] = xy + wz;
        out[2] = xz - wy;
        out[3] = 0;

        out[4] = xy - wz;
        out[5] = 1 - (xx + zz);
        out[6] = yz + wx;
        out[7] = 0;

        out[8] = xz + wy;
        out[9] = yz - wx;
        out[10] = 1 - (xx + yy);
        out[11] = 0;

        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;

        return this;
    },

    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {Number} left Left bound of the frustum
     * @param {Number} right Right bound of the frustum
     * @param {Number} bottom Bottom bound of the frustum
     * @param {Number} top Top bound of the frustum
     * @param {Number} near Near bound of the frustum
     * @param {Number} far Far bound of the frustum
     * @returns {Matrix4} this for chaining
     */
    frustum: function (left, right, bottom, top, near, far)
    {
        var out = this.val;

        var rl = 1 / (right - left);
        var tb = 1 / (top - bottom);
        var nf = 1 / (near - far);

        out[0] = (near * 2) * rl;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;

        out[4] = 0;
        out[5] = (near * 2) * tb;
        out[6] = 0;
        out[7] = 0;

        out[8] = (right + left) * rl;
        out[9] = (top + bottom) * tb;
        out[10] = (far + near) * nf;
        out[11] = -1;

        out[12] = 0;
        out[13] = 0;
        out[14] = (far * near * 2) * nf;
        out[15] = 0;

        return this;
    },

    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {number} fovy Vertical field of view in radians
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {Matrix4} this for chaining
     */
    perspective: function (fovy, aspect, near, far)
    {
        var out = this.val;
        var f = 1.0 / Math.tan(fovy / 2);
        var nf = 1 / (near - far);

        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;

        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;

        out[8] = 0;
        out[9] = 0;
        out[10] = (far + near) * nf;
        out[11] = -1;

        out[12] = 0;
        out[13] = 0;
        out[14] = (2 * far * near) * nf;
        out[15] = 0;

        return this;
    },

    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {Matrix4} this for chaining
     */
    ortho: function (left, right, bottom, top, near, far)
    {
        var out = this.val;
        var lr = left - right;
        var bt = bottom - top;
        var nf = near - far;

        //  Avoid division by zero
        lr = (lr === 0) ? lr : 1 / lr;
        bt = (bt === 0) ? bt : 1 / bt;
        nf = (nf === 0) ? nf : 1 / nf;

        out[0] = -2 * lr;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;

        out[4] = 0;
        out[5] = -2 * bt;
        out[6] = 0;
        out[7] = 0;

        out[8] = 0;
        out[9] = 0;
        out[10] = 2 * nf;
        out[11] = 0;

        out[12] = (left + right) * lr;
        out[13] = (top + bottom) * bt;
        out[14] = (far + near) * nf;
        out[15] = 1;

        return this;
    },

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {Vector3} eye Position of the viewer
     * @param {Vector3} center Point the viewer is looking at
     * @param {Vector3} up vec3 pointing up
     * @returns {Matrix4} this for chaining
     */
    lookAt: function (eye, center, up)
    {
        var out = this.val;

        var eyex = eye.x;
        var eyey = eye.y;
        var eyez = eye.z;

        var upx = up.x;
        var upy = up.y;
        var upz = up.z;

        var centerx = center.x;
        var centery = center.y;
        var centerz = center.z;

        if (Math.abs(eyex - centerx) < EPSILON &&
            Math.abs(eyey - centery) < EPSILON &&
            Math.abs(eyez - centerz) < EPSILON)
        {
            return this.identity();
        }

        var z0 = eyex - centerx;
        var z1 = eyey - centery;
        var z2 = eyez - centerz;

        var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);

        z0 *= len;
        z1 *= len;
        z2 *= len;

        var x0 = upy * z2 - upz * z1;
        var x1 = upz * z0 - upx * z2;
        var x2 = upx * z1 - upy * z0;

        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

        if (!len)
        {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        }
        else
        {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        var y0 = z1 * x2 - z2 * x1;
        var y1 = z2 * x0 - z0 * x2;
        var y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);

        if (!len)
        {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        }
        else
        {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        out[0] = x0;
        out[1] = y0;
        out[2] = z0;
        out[3] = 0;

        out[4] = x1;
        out[5] = y1;
        out[6] = z1;
        out[7] = 0;

        out[8] = x2;
        out[9] = y2;
        out[10] = z2;
        out[11] = 0;

        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        out[15] = 1;

        return this;
    }

});

Matrix4.prototype.mul = Matrix4.prototype.multiply;
Matrix4.prototype.idt = Matrix4.prototype.identity;
Matrix4.prototype.reset = Matrix4.prototype.idt;

module.exports = Matrix4;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

// A Set is a collection of unique elements.
var Set = new Class({

    initialize:

    function Set (elements)
    {
        this.entries = [];

        if (Array.isArray(elements))
        {
            for (var i = 0; i < elements.length; i++)
            {
                this.set(elements[i]);
            }
        }
    },

    set: function (value)
    {
        if (this.entries.indexOf(value) === -1)
        {
            this.entries.push(value);
        }

        return this;
    },

    get: function (property, value)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];

            if (entry[property] === value)
            {
                return entry;
            }
        }
    },

    getArray: function ()
    {
        return this.entries.slice(0);
    },

    delete: function (value)
    {
        var index = this.entries.indexOf(value);

        if (index > -1)
        {
            this.entries.splice(index, 1);
        }

        return this;
    },

    dump: function ()
    {
        console.group('Set');

        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];
            console.log(entry);
        }

        console.groupEnd();
    },


    //  For when you know this Set will be modified during the iteration
    each: function (callback)
    {
        var temp = this.entries.slice();

        for (var i = 0; i < temp.length; i++)
        {
            if (callback(temp[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    //  For when you absolutely know this Set won't be modified during the iteration
    iterate: function (callback)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            if (callback(this.entries[i], i) === false)
            {
                break;
            }
        }

        return this;
    },

    clear: function ()
    {
        this.entries.length = 0;

        return this;
    },

    contains: function (value)
    {
        return (this.entries.indexOf(value) > -1);
    },

    union: function (set)
    {
        var newSet = new Set();

        set.values.forEach(function (value)
        {
            newSet.add(value);
        });

        this.entries.forEach(function (value)
        {
            newSet.add(value);
        });

        return newSet;
    },

    intersect: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    },

    difference: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (!set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    },

    size: {

        get: function ()
        {
            return this.entries.length;
        },

        set: function (value)
        {
            return this.entries.length = value;
        }

    }

});

module.exports = Set;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var OS = __webpack_require__(50);

var Browser = {

    //  @property {boolean} arora - Set to true if running in Arora.
    arora: false,

    //  @property {boolean} chrome - Set to true if running in Chrome.
    chrome: false,

    //  @property {number} chromeVersion - If running in Chrome this will contain the major version number.
    chromeVersion: 0,

    //  @property {boolean} epiphany - Set to true if running in Epiphany.
    epiphany: false,

    //  @property {boolean} firefox - Set to true if running in Firefox.
    firefox: false,

    //  @property {number} firefoxVersion - If running in Firefox this will contain the major version number.
    firefoxVersion: 0,

    //  @property {boolean} mobileSafari - Set to true if running in Mobile Safari.
    mobileSafari: false,

    //  @property {boolean} ie - Set to true if running in Internet Explorer.
    ie: false,

    //  @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.
    ieVersion: 0,

    //  @property {boolean} midori - Set to true if running in Midori.
    midori: false,

    //  @property {boolean} opera - Set to true if running in Opera.
    opera: false,

    //  @property {boolean} safari - Set to true if running in Safari.
    safari: false,

    //  @property {number} safariVersion - If running in Safari this will contain the major version number.
    safariVersion: 0,

    //  @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)
    trident: false,

    //  @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}
    tridentVersion: 0,

    //  @property {boolean} edge - Set to true if running in Microsoft Edge browser.
    edge: false,

    //  @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)
    silk: false

};

function init ()
{
    var ua = navigator.userAgent;

    if ((/Arora/).test(ua))
    {
        Browser.arora = true;
    }
    else if (/Edge\/\d+/.test(ua))
    {
        Browser.edge = true;
    }
    else if ((/Chrome\/(\d+)/).test(ua) && !OS.windowsPhone)
    {
        Browser.chrome = true;
        Browser.chromeVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Epiphany/).test(ua))
    {
        Browser.epiphany = true;
    }
    else if ((/Firefox\D+(\d+)/).test(ua))
    {
        Browser.firefox = true;
        Browser.firefoxVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/AppleWebKit/).test(ua) && OS.iOS)
    {
        Browser.mobileSafari = true;
    }
    else if ((/MSIE (\d+\.\d+);/).test(ua))
    {
        Browser.ie = true;
        Browser.ieVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Midori/).test(ua))
    {
        Browser.midori = true;
    }
    else if ((/Opera/).test(ua))
    {
        Browser.opera = true;
    }
    else if ((/Safari/).test(ua) && !OS.windowsPhone)
    {
        Browser.safari = true;
    }
    else if ((/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/).test(ua))
    {
        Browser.ie = true;
        Browser.trident = true;
        Browser.tridentVersion = parseInt(RegExp.$1, 10);
        Browser.ieVersion = parseInt(RegExp.$3, 10);
    }

    //  Silk gets its own if clause because its ua also contains 'Safari'
    if ((/Silk/).test(ua))
    {
        Browser.silk = true;
    }

    return Browser;
}

module.exports = init();


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var GameObject = __webpack_require__(1);
var Components = __webpack_require__(8);
var ImageRender = __webpack_require__(502);

var Image = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.ScrollFactor,
        Components.Size,
        Components.Texture,
        Components.Tint,
        Components.Transform,
        Components.Visible,
        ImageRender
    ],

    initialize:

    function Image (scene, x, y, texture, frame)
    {
        GameObject.call(this, scene, 'Image');

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
    }

});

module.exports = Image;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var GameObject = __webpack_require__(1);
var Components = __webpack_require__(8);
var MeshRender = __webpack_require__(516);

var Mesh = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        MeshRender
    ],

    initialize:

    function Mesh (scene, x, y, vertices, uv, indices, colors, alphas, texture, frame)
    {
        GameObject.call(this, scene, 'Mesh');

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();

        if (vertices.length !== uv.length)
        {
            throw new Error('Phaser: Vertex count must match UV count');
        }

        var verticesUB = (vertices.length / 2) | 0;

        if (colors.length > 0 && colors.length < verticesUB)
        {
            throw new Error('Phaser: Color count must match Vertex count');
        }

        if (alphas.length > 0 && alphas.length < verticesUB)
        {
            throw new Error('Phaser: Alpha count must match Vertex count');
        }

        var i;

        if (colors.length === 0)
        {
            for (i = 0; i < verticesUB; ++i)
            {
                colors[i] = 0xFFFFFF;
            }
        }

        if (alphas.length === 0)
        {
            for (i = 0; i < verticesUB; ++i)
            {
                alphas[i] = 1.0;
            }
        }

        this.vertices = new Float32Array(vertices);
        this.uv = new Float32Array(uv);
        this.indices = new Uint16Array(indices);
        this.colors = new Uint32Array(colors);
        this.alphas = new Float32Array(alphas);
    }

});

module.exports = Mesh;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GameObject = __webpack_require__(1);
var Sprite = __webpack_require__(31);
var Vector2 = __webpack_require__(20);
var Vector4 = __webpack_require__(66);

var Sprite3D = new Class({

    Extends: GameObject,

    initialize:

    function Sprite3D (scene, x, y, z, texture, frame)
    {
        GameObject.call(this, scene, 'Sprite3D');

        this.gameObject = new Sprite(scene, 0, 0, texture, frame);

        this.position = new Vector4(x, y, z);

        this.size = new Vector2(this.gameObject.width, this.gameObject.height);

        this.scale = new Vector2(1, 1);

        this.adjustScaleX = true;
        this.adjustScaleY = true;

        this._visible = true;
    },

    project: function (camera)
    {
        var pos = this.position;

        var gameObject = this.gameObject;

        camera.project(pos, gameObject);

        camera.getPointSize(pos, this.size, this.scale);

        if (this.scale.x <= 0 || this.scale.y <= 0)
        {
            gameObject.setVisible(false);
        }
        else
        {
            if (!gameObject.visible)
            {
                gameObject.setVisible(true);
            }

            if (this.adjustScaleX)
            {
                gameObject.scaleX = this.scale.x;
            }

            if (this.adjustScaleY)
            {
                gameObject.scaleY = this.scale.y;
            }

            gameObject.setDepth(gameObject.z * -1);
        }
    },

    visible: {

        get: function ()
        {
            return this._visible;
        },

        set: function (value)
        {
            this._visible = value;
            this.gameObject.visible = value;
        }

    },

    setVisible: function (value)
    {
        this.visible = value;

        return this;
    },

    x: {

        get: function ()
        {
            return this.position.x;
        },

        set: function (value)
        {
            this.position.x = value;
        }

    },

    y: {

        get: function ()
        {
            return this.position.y;
        },

        set: function (value)
        {
            this.position.y = value;
        }

    },

    z: {

        get: function ()
        {
            return this.position.z;
        },

        set: function (value)
        {
            this.position.z = value;
        }

    }

});

module.exports = Sprite3D;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {


var BlendModes = __webpack_require__(42);
var Circle = __webpack_require__(60);
var CircleContains = __webpack_require__(38);
var Class = __webpack_require__(0);
var Components = __webpack_require__(8);
var GameObject = __webpack_require__(1);
var Rectangle = __webpack_require__(18);
var RectangleContains = __webpack_require__(32);

//  A Zone is a non-rendering Game Object that has a position and size.
//  It has no texture and never renders, but does live on the display list and
//  can be moved, scaled and rotated like any other Game Object.
//  The default origin is 0.5, the center of the Zone, the same as with Game Objects.
//  It's useful for linking to drop zones and input hit areas and has a couple of helper methods specifically for this.
//  Also useful for object overlap checks, or as a base for your own non-displaying objects.

var Zone = new Class({

    Extends: GameObject,

    Mixins: [
        Components.GetBounds,
        Components.Origin,
        Components.ScaleMode,
        Components.Size,
        Components.Transform,
        Components.ScrollFactor,
        Components.Visible
    ],

    initialize:

    function Zone (scene, x, y, width, height)
    {
        if (width === undefined) { width = 1; }
        if (height === undefined) { height = width; }

        GameObject.call(this, scene, 'Zone');

        this.setPosition(x, y);
        this.setSize(width, height);

        this.blendMode = BlendModes.NORMAL;
    },

    //  Centered on the Zones x/y
    setCircleDropZone: function (radius)
    {
        return this.setDropZone(new Circle(0, 0, radius), CircleContains);
    },

    //  Centered on the Zones x/y position
    setRectangleDropZone: function (width, height)
    {
        var x = -(width / 2);
        var y = -(height / 2);

        return this.setDropZone(new Rectangle(x, y, width, height), RectangleContains);
    },

    //  Define your own shape as the drop zone
    setDropZone: function (shape, callback)
    {
        if (shape === undefined)
        {
            this.setRectangleDropZone(this.width, this.height);
        }
        else
        {
            if (!this.input)
            {
                this.setInteractive(shape, callback);
            }

            this.input.dropZone = true;
        }

        return this;
    },

    renderCanvas: function ()
    {
        return;
    },

    renderWebGL: function ()
    {
        return;
    }

});

module.exports = Zone;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var Circle = new Class({

    initialize:

    function Circle (x, y, radius)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (radius === undefined) { radius = 0; }

        this.x = x;

        this.y = y;

        this._radius = radius;
        this._diameter = radius * 2;
    },

    setTo: function (x, y, radius)
    {
        this.x = x;
        this.y = y;
        this._radius = radius;
        this._diameter = radius * 2;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    isEmpty: function ()
    {
        return (this._radius <= 0);
    },

    radius: {

        get: function ()
        {
            return this._radius;
        },

        set: function (value)
        {
            this._radius = value;
            this._diameter = value * 2;
        }

    },

    diameter: {

        get: function ()
        {
            return this._diameter;
        },

        set: function (value)
        {
            this._diameter = value;
            this._radius = value * 0.5;
        }

    },

    left: {

        get: function ()
        {
            return this.x - this._radius;
        },

        set: function (value)
        {
            this.x = value + this._radius;
        }

    },

    right: {

        get: function ()
        {
            return this.x + this._radius;
        },

        set: function (value)
        {
            this.x = value - this._radius;
        }

    },

    top: {

        get: function ()
        {
            return this.y - this._radius;
        },

        set: function (value)
        {
            this.y = value + this._radius;
        }

    },

    bottom: {

        get: function ()
        {
            return this.y + this._radius;
        },

        set: function (value)
        {
            this.y = value - this._radius;
        }

    }

});

module.exports = Circle;


/***/ }),
/* 61 */
/***/ (function(module, exports) {

var Contains = function (ellipse, x, y)
{
    if (ellipse.width <= 0 || ellipse.height <= 0)
    {
        return false;
    }
 
    //  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5
    var normx = ((x - ellipse.x) / ellipse.width) - 0.5;
    var normy = ((y - ellipse.y) / ellipse.height) - 0.5;
 
    normx *= normx;
    normy *= normy;
 
    return (normx + normy < 0.25);
};

module.exports = Contains;


/***/ }),
/* 62 */
/***/ (function(module, exports) {

//  This is based off an explanation and expanded math presented by Paul Bourke:
//  See http:'local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/

var LineToLine = function (line1, line2, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var x1 = line1.x1;
    var y1 = line1.y1;
    var x2 = line1.x2;
    var y2 = line1.y2;

    var x3 = line2.x1;
    var y3 = line2.y1;
    var x4 = line2.x2;
    var y4 = line2.y2;

    var numA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var numB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    var deNom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

    //  Make sure there is not a division by zero - this also indicates that the lines are parallel.
    //  If numA and numB were both equal to zero the lines would be on top of each other (coincidental).
    //  This check is not done because it is not necessary for this implementation (the parallel check accounts for this).

    if (deNom === 0)
    {
        return false;
    }

    //  Calculate the intermediate fractional point that the lines potentially intersect.

    var uA = numA / deNom;
    var uB = numB / deNom;

    //  The fractional point will be between 0 and 1 inclusive if the lines intersect.
    //  If the fractional calculation is larger than 1 or smaller than 0 the lines would need to be longer to intersect.

    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1)
    {
        out.x = x1 + (uA * (x2 - x1));
        out.y = y1 + (uA * (y2 - y1));

        return true;
    }

    return false;
};

module.exports = LineToLine;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var RGBStringToColor = __webpack_require__(183);
var HexStringToColor = __webpack_require__(179);
var IntegerToColor = __webpack_require__(181);

var ValueToColor = function (input)
{
    if (typeof input === 'string')
    {
        if (input.substr(0, 3).toLowerCase() === 'rgb')
        {
            return RGBStringToColor(input);
        }
        else
        {
            return HexStringToColor(input);
        }
    }
    else if (typeof input === 'number')
    {
        return IntegerToColor(input);
    }
};

module.exports = ValueToColor;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Gamepad.Events

module.exports = {
    CONNECTED: __webpack_require__(705),
    DISCONNECTED: __webpack_require__(706),
    DOWN: __webpack_require__(707),
    UP: __webpack_require__(708)
};


/***/ }),
/* 65 */
/***/ (function(module, exports) {

var Between = function (min, max)
{
    return Math.floor(Math.random() * (max - min + 1) + min);
};

module.exports = Between;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji 
//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl

var Class = __webpack_require__(0);

var Vector4 = new Class({

    initialize:

    function Vector4 (x, y, z, w)
    {
        if (typeof x === 'object')
        {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
            this.w = x.w || 0;
        }
        else
        {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
        }
    },

    clone: function ()
    {
        return new Vector4(this.x, this.y, this.z, this.w);
    },

    copy: function (src)
    {
        this.x = src.x;
        this.y = src.y;
        this.z = src.z || 0;
        this.w = src.w || 0;

        return this;
    },

    equals: function (v)
    {
        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z) && (this.w === v.w));
    },

    set: function (x, y, z, w)
    {
        if (typeof x === 'object')
        {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
            this.w = x.w || 0;
        }
        else
        {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
        }

        return this;
    },

    add: function (v)
    {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z || 0;
        this.w += v.w || 0;

        return this;
    },

    subtract: function (v)
    {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z || 0;
        this.w -= v.w || 0;

        return this;
    },

    scale: function (scale)
    {
        this.x *= scale;
        this.y *= scale;
        this.z *= scale;
        this.w *= scale;

        return this;
    },

    length: function ()
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;

        return Math.sqrt(x * x + y * y + z * z + w * w);
    },

    lengthSq: function ()
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;

        return x * x + y * y + z * z + w * w;
    },

    normalize: function ()
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;
        var len = x * x + y * y + z * z + w * w;

        if (len > 0)
        {
            len = 1 / Math.sqrt(len);

            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
            this.w = w * len;
        }

        return this;
    },

    dot: function (v)
    {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },

    lerp: function (v, t)
    {
        if (t === undefined) { t = 0; }

        var ax = this.x;
        var ay = this.y;
        var az = this.z;
        var aw = this.w;

        this.x = ax + t * (v.x - ax);
        this.y = ay + t * (v.y - ay);
        this.z = az + t * (v.z - az);
        this.w = aw + t * (v.w - aw);

        return this;
    },

    multiply: function (v)
    {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z || 1;
        this.w *= v.w || 1;

        return this;
    },

    divide: function (v)
    {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z || 1;
        this.w /= v.w || 1;

        return this;
    },

    distance: function (v)
    {
        var dx = v.x - this.x;
        var dy = v.y - this.y;
        var dz = v.z - this.z || 0;
        var dw = v.w - this.w || 0;

        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
    },

    distanceSq: function (v)
    {
        var dx = v.x - this.x;
        var dy = v.y - this.y;
        var dz = v.z - this.z || 0;
        var dw = v.w - this.w || 0;

        return dx * dx + dy * dy + dz * dz + dw * dw;
    },

    negate: function ()
    {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;

        return this;
    },

    transformMat4: function (mat)
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;
        var m = mat.val;

        this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
        this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
        this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
        this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;

        return this;
    },

    //  TODO: is this really the same as Vector3?
    //  Also, what about this: http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/
    transformQuat: function (q)
    {
        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;

        // calculate quat * vec
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return this;
    },

    reset: function ()
    {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;

        return this;
    }

});

Vector4.prototype.sub = Vector4.prototype.subtract;
Vector4.prototype.mul = Vector4.prototype.multiply;
Vector4.prototype.div = Vector4.prototype.divide;
Vector4.prototype.dist = Vector4.prototype.distance;
Vector4.prototype.distSq = Vector4.prototype.distanceSq;
Vector4.prototype.len = Vector4.prototype.length;
Vector4.prototype.lenSq = Vector4.prototype.lengthSq;

module.exports = Vector4;


/***/ }),
/* 67 */
/***/ (function(module, exports) {

var Wrap = function (value, min, max)
{
    var range = max - min;

    return (min + ((((value - min) % range) + range) % range));
};

module.exports = Wrap;


/***/ }),
/* 68 */
/***/ (function(module, exports) {

var DistanceBetween = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return Math.sqrt(dx * dx + dy * dy);
};

module.exports = DistanceBetween;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)

var Clamp = __webpack_require__(52);
var Vector2 = __webpack_require__(20);
var Vector3 = __webpack_require__(34);
var Matrix4 = __webpack_require__(53);
var Class = __webpack_require__(0);

//  Local cache vars

var tmpVec2A = new Vector2();
var tmpVec2B = new Vector2();

//  Our Base Curve which all other curves extend

var Curve = new Class({

    initialize:

    function Curve ()
    {
        this.defaultDivisions = 5;

        this.arcLengthDivisions = 100;

        this.cacheArcLengths = [];

        this.needsUpdate = true;
    },

    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]

    getPointAt: function (u, out)
    {
        var t = this.getUtoTmapping(u);

        return this.getPoint(t, out);
    },

    // Get sequence of points using getPoint( t )

    getPoints: function (divisions)
    {
        if (divisions === undefined) { divisions = this.defaultDivisions; }

        var points = [];

        for (var d = 0; d <= divisions; d++)
        {
            points.push(this.getPoint(d / divisions));
        }

        return points;
    },

    // Get sequence of points using getPointAt( u )

    getSpacedPoints: function (divisions)
    {
        if (divisions === undefined) { divisions = this.defaultDivisions; }

        var points = [];

        for (var d = 0; d <= divisions; d++)
        {
            var t = this.getUtoTmapping(d / divisions, null, divisions);

            points.push(this.getPoint(t));
        }

        return points;
    },

    // Get total curve arc length

    getLength: function ()
    {
        var lengths = this.getLengths();

        return lengths[lengths.length - 1];
    },

    // Get list of cumulative segment lengths

    getLengths: function (divisions)
    {
        if (divisions === undefined) { divisions = this.arcLengthDivisions; }

        if ((this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate)
        {
            return this.cacheArcLengths;
        }

        this.needsUpdate = false;

        var cache = [];
        var current;
        var last = this.getPoint(0, tmpVec2A);
        var sum = 0;

        cache.push(0);

        for (var p = 1; p <= divisions; p++)
        {
            current = this.getPoint(p / divisions, tmpVec2B);

            sum += current.distance(last);

            cache.push(sum);

            last.copy(current);
        }

        this.cacheArcLengths = cache;

        return cache; // { sums: cache, sum:sum }; Sum is in the last element.
    },

    updateArcLengths: function ()
    {
        this.needsUpdate = true;

        this.getLengths();
    },

    //  Given a distance in pixels, get a t to find p.
    getTFromDistance: function (distance, divisions)
    {
        return this.getUtoTmapping(0, distance, divisions);
    },

    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

    getUtoTmapping: function (u, distance, divisions)
    {
        var arcLengths = this.getLengths(divisions);

        var i = 0;
        var il = arcLengths.length;

        var targetArcLength; // The targeted u distance value to get

        if (distance)
        {
            //  Cannot overshoot the curve
            targetArcLength = Math.min(distance, arcLengths[il - 1]);
        }
        else
        {
            targetArcLength = u * arcLengths[il - 1];
        }

        // binary search for the index with largest value smaller than target u distance

        var low = 0;
        var high = il - 1;
        var comparison;

        while (low <= high)
        {
            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

            comparison = arcLengths[i] - targetArcLength;

            if (comparison < 0)
            {
                low = i + 1;
            }
            else if (comparison > 0)
            {
                high = i - 1;
            }
            else
            {
                high = i;
                break;
            }
        }

        i = high;

        if (arcLengths[i] === targetArcLength)
        {
            return i / (il - 1);
        }

        // we could get finer grain at lengths, or use simple interpolation between two points

        var lengthBefore = arcLengths[i];
        var lengthAfter = arcLengths[i + 1];

        var segmentLength = lengthAfter - lengthBefore;

        // determine where we are between the 'before' and 'after' points

        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

        // add that fractional amount to t

        return (i + segmentFraction) / (il - 1);
    },

    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation

    getTangent: function (t, out)
    {
        if (out === undefined) { out = new Vector2(); }

        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;

        // Capping in case of danger

        if (t1 < 0)
        {
            t1 = 0;
        }

        if (t2 > 1)
        {
            t2 = 1;
        }

        this.getPoint(t1, tmpVec2A);
        this.getPoint(t2, out);

        return out.sub(tmpVec2A).normalize();
    },

    getTangentAt: function (u, out)
    {
        var t = this.getUtoTmapping(u);

        return this.getTangent(t, out);
    }

});

module.exports = Curve;


/***/ }),
/* 70 */
/***/ (function(module, exports) {

// Collision Types - Determine if and how entities collide with each other

// In ACTIVE vs. LITE or FIXED vs. ANY collisions, only the "weak" entity moves,
// while the other one stays fixed. In ACTIVE vs. ACTIVE and ACTIVE vs. PASSIVE
// collisions, both entities are moved. LITE or PASSIVE entities don't collide
// with other LITE or PASSIVE entities at all. The behaiviour for FIXED vs.
// FIXED collisions is undefined.

module.exports = {

    NEVER: 0,
    LITE: 1,
    PASSIVE: 2,
    ACTIVE: 4,
    FIXED: 8

};


/***/ }),
/* 71 */
/***/ (function(module, exports) {

// Collision Types - Determine if and how entities collide with each other

// In ACTIVE vs. LITE or FIXED vs. ANY collisions, only the "weak" entity moves,
// while the other one stays fixed. In ACTIVE vs. ACTIVE and ACTIVE vs. PASSIVE
// collisions, both entities are moved. LITE or PASSIVE entities don't collide
// with other LITE or PASSIVE entities at all. The behavior for FIXED vs.
// FIXED collisions is undefined.

module.exports = {

    NONE: 0,
    A: 1,
    B: 2,
    BOTH: 3

};


/***/ }),
/* 72 */
/***/ (function(module, exports) {

//  Shallow Object Clone. Will not clone nested objects.

var Clone = function (obj)
{
    var clone = {};

    for (var key in obj)
    {
        if (Array.isArray(obj[key]))
        {
            clone[key] = obj[key].slice(0);
        }
        else
        {
            clone[key] = obj[key];
        }
    }

    return clone;
};

module.exports = Clone;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var IsPlainObject = __webpack_require__(258);

/**
* This is a slightly modified version of http://api.jquery.com/jQuery.extend/
* 
* @method Phaser.Utils.extend
* @param {boolean} deep - Perform a deep copy?
* @param {object} target - The target object to copy to.
* @return {object} The extended object.
*/
var Extend = function ()
{
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean")
    {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // extend Phaser if only one argument is passed
    if (length === i)
    {
        target = this;
        --i;
    }

    for (; i < length; i++)
    {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null)
        {
            // Extend the base object
            for (name in options)
            {
                src = target[name];
                copy = options[name];

                // Prevent never-ending loop
                if (target === copy)
                {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))
                {
                    if (copyIsArray)
                    {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    }
                    else
                    {
                        clone = src && IsPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[name] = Extend(deep, clone, copy);

                // Don't bring in undefined values
                }
                else if (copy !== undefined)
                {
                    target[name] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

module.exports = Extend;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Rectangle = __webpack_require__(18);
var TransformMatrix = __webpack_require__(17);
var ValueToColor = __webpack_require__(63);

var Camera = new Class({

    initialize:

    function Camera (x, y, width, height)
    {
        this.scene;

        this.name = '';

        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        this.roundPixels = false;

        //  Bounds
        this.useBounds = false;
        this._bounds = new Rectangle();

        this.inputEnabled = true;

        this.scrollX = 0.0;
        this.scrollY = 0.0;
        this.zoom = 1.0;
        this.rotation = 0.0;
        this.matrix = new TransformMatrix(1, 0, 0, 1, 0, 0);

        this.transparent = true;
        this.clearBeforeRender = true;
        this.backgroundColor = ValueToColor('rgba(0,0,0,0)');

        this.disableCull = false;
        this.culledObjects = [];

        //  Shake
        this._shakeDuration = 0;
        this._shakeIntensity = 0;
        this._shakeOffsetX = 0;
        this._shakeOffsetY = 0;

        //  Fade
        this._fadeDuration = 0;
        this._fadeRed = 0;
        this._fadeGreen = 0;
        this._fadeBlue = 0;
        this._fadeAlpha = 0;

        //  Flash
        this._flashDuration = 0;
        this._flashRed = 1;
        this._flashGreen = 1;
        this._flashBlue = 1;
        this._flashAlpha = 0;

        //  Follow
        this._follow = null;

        this._id = 0;
    },

    cameraToScreen: __webpack_require__(366),
    centerToBounds: __webpack_require__(367),
    centerToSize: __webpack_require__(368),
    cull: __webpack_require__(369),
    cullHitTest: __webpack_require__(370),
    cullTilemap: __webpack_require__(371),
    destroy: __webpack_require__(372),
    fade: __webpack_require__(373),
    flash: __webpack_require__(374),
    ignore: __webpack_require__(375),
    preRender: __webpack_require__(376),
    removeBounds: __webpack_require__(377),
    setBackgroundColor: __webpack_require__(378),
    setBounds: __webpack_require__(379),
    setName: __webpack_require__(380),
    setPosition: __webpack_require__(381),
    setRotation: __webpack_require__(382),
    setRoundPixels: __webpack_require__(383),
    setScene: __webpack_require__(384),
    setScroll: __webpack_require__(385),
    setSize: __webpack_require__(386),
    setViewport: __webpack_require__(387),
    setZoom: __webpack_require__(388),
    shake: __webpack_require__(389),
    startFollow: __webpack_require__(390),
    stopFollow: __webpack_require__(391),
    toJSON: __webpack_require__(392),
    update: __webpack_require__(393)

});

module.exports = Camera;


/***/ }),
/* 75 */
/***/ (function(module, exports) {

var CanvasInterpolation = {

    //  Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).
    //  Note that if this doesn't given the desired result then see the setSmoothingEnabled.
    setCrisp: function (canvas)
    {
        var types = [ 'optimizeSpeed', 'crisp-edges', '-moz-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'pixelated' ];

        types.forEach(function (type)
        {
            canvas.style['image-rendering'] = type;
        });

        canvas.style.msInterpolationMode = 'nearest-neighbor';

        return canvas;
    },

    //  Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').
    //  Note that if this doesn't given the desired result then see the CanvasUtils.setSmoothingEnabled method.
    setBicubic: function (canvas)
    {
        canvas.style['image-rendering'] = 'auto';
        canvas.style.msInterpolationMode = 'bicubic';

        return canvas;
    }

};

module.exports = CanvasInterpolation;


/***/ }),
/* 76 */
/***/ (function(module, exports) {


//  Browser specific prefix, so not going to change between contexts, only between browsers
var prefix = '';

var Smoothing = function ()
{
    // Gets the Smoothing Enabled vendor prefix being used on the given context, or null if not set.
    var getPrefix = function (context)
    {
        var vendors = [ 'i', 'webkitI', 'msI', 'mozI', 'oI' ];

        for (var i = 0; i < vendors.length; i++)
        {
            var s = vendors[i] + 'mageSmoothingEnabled';

            if (s in context)
            {
                return s;
            }
        }

        return null;
    };

    /**
    * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.
    * By default browsers have image smoothing enabled, which isn't always what you visually want, especially
    * when using pixel art in a game. Note that this sets the property on the context itself, so that any image
    * drawn to the context will be affected. This sets the property across all current browsers but support is
    * patchy on earlier browsers, especially on mobile.
    */
    var enable = function (context)
    {
        if (prefix === '')
        {
            prefix = getPrefix(context);
        }

        if (prefix)
        {
            context[prefix] = true;
        }

        return context;
    };

    /**
    * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.
    * By default browsers have image smoothing enabled, which isn't always what you visually want, especially
    * when using pixel art in a game. Note that this sets the property on the context itself, so that any image
    * drawn to the context will be affected. This sets the property across all current browsers but support is
    * patchy on earlier browsers, especially on mobile.
    */
    var disable = function (context)
    {
        if (prefix === '')
        {
            prefix = getPrefix(context);
        }

        if (prefix)
        {
            context[prefix] = false;
        }

        return context;
    };

    /**
     * Returns `true` if the given context has image smoothing enabled, otherwise returns `false`.
     * Returns null if no smoothing prefix is available.
     */
    var isEnabled = function (context)
    {
        return (prefix !== null) ? context[prefix] : null;
    };

    return {
        disable: disable,
        enable: enable,
        getPrefix: getPrefix,
        isEnabled: isEnabled
    };
};

module.exports = Smoothing();


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GameObject = __webpack_require__(1);
var Components = __webpack_require__(8);
var Render = __webpack_require__(431);
var GetBitmapTextSize = __webpack_require__(136);

var DynamicBitmapText = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Origin,
        Components.RenderTarget,
        Components.Texture,
        Components.Tint,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        Render
    ],

    initialize:

    function DynamicBitmapText (scene, x, y, font, text, size)
    {
        if (text === undefined) { text = ''; }

        GameObject.call(this, scene, 'DynamicBitmapText');

        this.font = font;

        var entry = this.scene.sys.cache.bitmapFont.get(font);

        this.fontData = entry.data;

        this.text = (Array.isArray(text)) ? text.join('\n') : text;

        this.fontSize = size || this.fontData.size;

        this.setTexture(entry.texture, entry.frame);
        this.setPosition(x, y);
        this.setOrigin(0, 0);

        this._bounds = this.getTextBounds();

        this.scrollX = 0;
        this.scrollY = 0;

        this.cropWidth = 0;
        this.cropHeight = 0;

        this.displayCallback;
    },

    setSize: function (width, height)
    {
        this.cropWidth = width;
        this.cropHeight = height;

        return this;
    },

    setDisplayCallback: function (callback)
    {
        this.displayCallback = callback;

        return this;
    },

    setFontSize: function (size)
    {
        this.fontSize = size;

        return this;
    },

    setText: function (text)
    {
        this.text = text;

        return this;
    },

    setScrollX: function (value)
    {
        this.scrollX = value;

        return this;
    },

    setScrollY: function (value)
    {
        this.scrollY = value;

        return this;
    },

    // {
    //     local: {
    //         x,
    //         y,
    //         width,
    //         height
    //     },
    //     global: {
    //         x,
    //         y,
    //         width,
    //         height
    //     }
    // }

    getTextBounds: function (round)
    {
        //  local = the BitmapText based on fontSize and 0x0 coords
        //  global = the BitmapText, taking into account scale and world position

        this._bounds = GetBitmapTextSize(this, round);

        return this._bounds;
    },

    width: {

        get: function ()
        {
            this.getTextBounds(false);
            return this._bounds.global.width;
        }

    },

    height: {

        get: function ()
        {
            this.getTextBounds(false);
            return this._bounds.global.height;
        }

    },

    toJSON: function ()
    {
        var out = Components.ToJSON(this);

        //  Extra data is added here

        var data = {
            font: this.font,
            text: this.text,
            fontSize: this.fontSize
        };

        out.data = data;

        return out;
    }

});

module.exports = DynamicBitmapText;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Components = __webpack_require__(8);
var GameObject = __webpack_require__(1);
var GetBitmapTextSize = __webpack_require__(136);
var ParseFromAtlas = __webpack_require__(426);
var ParseRetroFont = __webpack_require__(427);
var Render = __webpack_require__(436);

var BitmapText = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Texture,
        Components.Tint,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        Render
    ],

    initialize:

    function BitmapText (scene, x, y, font, text, size)
    {
        if (text === undefined) { text = ''; }

        GameObject.call(this, scene, 'BitmapText');

        this.font = font;

        var entry = this.scene.sys.cache.bitmapFont.get(font);

        this.fontData = entry.data;

        this.text = (Array.isArray(text)) ? text.join('\n') : text;

        this.fontSize = size || this.fontData.size;

        this.setTexture(entry.texture, entry.frame);
        this.setPosition(x, y);
        this.setOrigin(0, 0);

        this._bounds = this.getTextBounds();
    },

    setFontSize: function (size)
    {
        this.fontSize = size;

        return this;
    },

    setText: function (text)
    {
        this.text = text;

        return this;
    },

    // {
    //     local: {
    //         x,
    //         y,
    //         width,
    //         height
    //     },
    //     global: {
    //         x,
    //         y,
    //         width,
    //         height
    //     }
    // }

    getTextBounds: function (round)
    {
        //  local = the BitmapText based on fontSize and 0x0 coords
        //  global = the BitmapText, taking into account scale and world position

        this._bounds = GetBitmapTextSize(this, round);

        return this._bounds;
    },

    width: {

        get: function ()
        {
            this.getTextBounds(false);
            return this._bounds.global.width;
        }

    },

    height: {

        get: function ()
        {
            this.getTextBounds(false);
            return this._bounds.global.height;
        }

    },

    toJSON: function ()
    {
        var out = Components.ToJSON(this);

        //  Extra data is added here

        var data = {
            font: this.font,
            text: this.text,
            fontSize: this.fontSize
        };

        out.data = data;

        return out;
    }

});

BitmapText.ParseRetroFont = ParseRetroFont;
BitmapText.ParseFromAtlas = ParseFromAtlas;

module.exports = BitmapText;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var BlitterRender = __webpack_require__(441);
var Bob = __webpack_require__(443);
var Class = __webpack_require__(0);
var Components = __webpack_require__(8);
var DisplayList = __webpack_require__(233);
var GameObject = __webpack_require__(1);

/**
* A Blitter Game Object.
*
* The Blitter Game Object is a special type of Container, that contains Blitter.Bob objects.
* These objects can be thought of as just texture frames with a position and nothing more.
* Bobs don't have any update methods, or the ability to have children, or any kind of special effects.
* They are essentially just super-fast texture frame renderers, and the Blitter object creates and manages them.
*/

var Blitter = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        BlitterRender
    ],

    initialize:

    function Blitter (scene, x, y, texture, frame)
    {
        GameObject.call(this, scene, 'Blitter');

        this.setTexture(texture, frame);
        this.setPosition(x, y);

        this.children = new DisplayList(this);

        this.renderList = [];

        this.dirty = false;
    },

    //  frame MUST be part of the Blitter texture
    create: function (x, y, frame, visible, index)
    {
        if (visible === undefined) { visible = true; }
        if (index === undefined) { index = this.children.length; }

        if (frame === undefined)
        {
            frame = this.frame;
        }
        else
        {
            frame = this.texture.get(frame);
        }

        var bob = new Bob(x, y, frame, visible);

        this.children.addAt(bob, index, false);

        this.dirty = true;

        return bob;
    },

    //  frame MUST be part of the Blitter texture
    createFromCallback: function (callback, quantity, frame, visible)
    {
        var bobs = this.createMultiple(quantity, frame, visible);

        for (var i = 0; i < bobs.length; i++)
        {
            var bob = bobs[i];

            callback.call(this, bob, i);
        }

        return bobs;
    },

    //  frame MUST be part of the Blitter texture
    createMultiple: function (quantity, frame, visible)
    {
        if (frame === undefined) { frame = this.frame; }
        if (visible === undefined) { visible = true; }

        if (!Array.isArray(frame))
        {
            frame = [ frame ];
        }

        var bobs = [];
        var _this = this;

        frame.forEach(function (singleFrame)
        {
            for (var i = 0; i < quantity; i++)
            {
                bobs.push(_this.create(0, 0, singleFrame, visible));
            }
        });

        return bobs;
    },

    childCanRender: function (child)
    {
        return (child.visible && child.alpha > 0);
    },

    getRenderList: function ()
    {
        if (this.dirty)
        {
            this.renderList = this.children.list.filter(this.childCanRender, this);
            this.dirty = false;
        }

        return this.renderList;
    },

    clear: function ()
    {
        this.children.removeAll();
        this.dirty = true;
    }

});

module.exports = Blitter;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GameObject = __webpack_require__(1);
var Components = __webpack_require__(8);
var Render = __webpack_require__(485);
var TexturedAndNormalizedTintedShader = __webpack_require__(43);

//  EffectLayer renders all elements on the layer to an offscreen render target
//  and then when rendering the color buffer of that render target to the main screen
//  it applies the effect layer shader.

var EffectLayer = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        Render
    ],

    initialize:

    function EffectLayer (scene, x, y, width, height, effectName, fragmentShader)
    {
        GameObject.call(this, scene, 'EffectLayer');
       
        var pot = ((width & (width - 1)) == 0 && (height & (height - 1)) == 0);
        var resourceManager = scene.sys.game.renderer.resourceManager;
        var wrap;
        var gl;

        this.dstRenderTarget = null;
        this.renderTexture = null;
        this.dstShader = null;
        this.uniforms = {};

        if (resourceManager !== undefined)
        {
            gl = scene.sys.game.renderer.gl;
            wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;
            this.dstShader = resourceManager.createShader(effectName, {
                vert: TexturedAndNormalizedTintedShader.vert,
                frag: fragmentShader
            });

            this.renderTexture = resourceManager.createTexture(
                0,
                gl.LINEAR, gl.LINEAR,
                wrap, wrap,
                gl.RGBA,
                null, width, height
            );

            this.dstRenderTarget = resourceManager.createRenderTarget(width, height, this.renderTexture, null);
            scene.sys.game.renderer.currentTexture[0] = null; // force rebinding of prev texture
        }

        this.flipY = true;
        this.setPosition(x, y);
        this.setSize(width, height);
        this.setOrigin(0, 0);

        var _this = this;
        scene.sys.game.renderer.addContextRestoredCallback(function (renderer) {
            var resourceManager = renderer.resourceManager;
            var gl = renderer.gl;
            var wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;
            _this.dstShader = resourceManager.createShader(effectName, {
                vert: TexturedAndNormalizedTintedShader.vert,
                frag: fragmentShader
            });

            _this.renderTexture = resourceManager.createTexture(
                0,
                gl.LINEAR, gl.LINEAR,
                wrap, wrap,
                gl.RGBA,
                null, _this.width, _this.height
            );

            _this.dstRenderTarget = resourceManager.createRenderTarget(_this.width, _this.height, _this.renderTexture, null);
            _this.uniforms = {};
            scene.sys.game.renderer.currentTexture[0] = null; // force rebinding of prev texture

        });
    },

    setClearAlpha: function (alpha)
    {
        if (this.dstRenderTarget)
        {
            this.dstRenderTarget.clearAlpha = alpha;
        }
    },

    renderOffScreen: function ()
    {
        this.renderTarget = this.dstRenderTarget;
    },

    renderOnScreen: function ()
    {
        this.renderTarget = null;
    },

    add: function (gameObject)
    {
        if (gameObject.renderTarget !== undefined)
        {
            gameObject.renderTarget = this.dstRenderTarget;
        }
    },

    remove: function (gameObject)
    {
        if (gameObject.renderTarget !== undefined)
        {
            gameObject.renderTarget = null;
        }
    },

    getUniformLocation: function (uniformName)
    {
        var dstShader = this.dstShader;
        var uniforms = this.uniforms;
        var location;

        if (uniformName in uniforms)
        {
            location = uniforms[uniformName];
        }
        else
        {
            location = dstShader.getUniformLocation(uniformName);
            uniforms[uniformName] = location;
        }

        return location;
    },

    setFloat: function (uniformName, x)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantFloat1(this.getUniformLocation(uniformName), x);
    },

    setFloat2: function (uniformName, x, y)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantFloat2(this.getUniformLocation(uniformName), x, y);
    },

    setFloat3: function (uniformName, x, y, z)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantFloat3(this.getUniformLocation(uniformName), x, y, z);
    },

    setFloat4: function (uniformName, x, y, z, w)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantFloat4(this.getUniformLocation(uniformName), x, y, z, w);
    },

    setInt: function (uniformName, x)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantInt1(this.getUniformLocation(uniformName), x);
    },

    setInt2: function (uniformName, x, y)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantInt2(this.getUniformLocation(uniformName), x, y);
    },

    setInt3: function (uniformName, x, y, z)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantInt3(this.getUniformLocation(uniformName), x, y, z);
    },

    setInt4: function (uniformName, x, y, z, w)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantInt4(this.getUniformLocation(uniformName), x, y, z, w);
    },

    setMatrix2x2: function (uniformName, matrix)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantMatrix2x2(this.getUniformLocation(uniformName), matrix);
    },

    setMatrix3x3: function (uniformName, matrix)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantMatrix3x3(this.getUniformLocation(uniformName), matrix);
    },

    setMatrix4x4: function (uniformName, matrix)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantMatrix4x4(this.getUniformLocation(uniformName), matrix);
    }

});

module.exports = EffectLayer;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var Between = __webpack_require__(65);
var Class = __webpack_require__(0);
var Components = __webpack_require__(8);
var DegToRad = __webpack_require__(106);
var Easing = __webpack_require__(223);
var GameObject = __webpack_require__(1);
var GetEaseFunction = __webpack_require__(113);
var Particle = __webpack_require__(487);
var Render = __webpack_require__(491);
var StableSort = __webpack_require__(256);

var ParticleEmitter = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.RenderTarget,
        Components.ScrollFactor,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Render
    ],

    initialize:

    function ParticleEmitter (scene, x, y, texture, frame)
    {

        GameObject.call(this, scene, 'ParticleEmitter');

        this.dead = [];
        this.alive = [];
        this.minSpeed = 0;
        this.maxSpeed = 0;
        this.startScale = 1.0;
        this.endScale = 1.0;
        this.startAlpha = 1.0;
        this.endAlpha = 1.0;
        this.minEmitAngle = 0;
        this.maxEmitAngle = 360;
        this.startAngle = 0;
        this.endAngle = 0;
        this.gravityX = 0;
        this.gravityY = 0;
        this.life = 1.0;
        this.delay = 0.0;
        this.delayCounter = 0.0;
        this.deathCallback = null;
        this.emitCount = 1;
        this.enabled = true;
        this.allowCreation = true;
        this.easingFunctionAlpha = Easing.Linear;
        this.easingFunctionScale = Easing.Linear;
        this.easingFunctionRotation = Easing.Linear;
        this.setTexture(texture, frame);
        this.setPosition(x, y);
    },

    setEase: function (easeName, easeParam)
    {
        var ease = GetEaseFunction(easeName, easeParam);

        this.easingFunctionAlpha = ease;
        this.easingFunctionScale = ease;
        this.easingFunctionRotation = ease;

        return this;
    },

    setAlphaEase: function (easeName, easeParam)
    {
        this.easingFunctionAlpha = GetEaseFunction(easeName, easeParam);

        return this;
    },

    setScaleEase: function (easeName, easeParam)
    {
        this.easingFunctionScale = GetEaseFunction(easeName, easeParam);

        return this;
    },

    setRotationEase: function (easeName, easeParam)
    {
        this.easingFunctionRotation = GetEaseFunction(easeName, easeParam);

        return this;
    },

    setSpeed: function (min, max)
    {
        if (max === undefined) { max = min; }

        this.minSpeed = min;
        this.maxSpeed = max;

        return this;
    },

    setEmitAngle: function (min, max)
    {
        if (max === undefined) { max = min; }

        this.minEmitAngle = min;
        this.maxEmitAngle = max;

        return this;
    },

    setScale: function (start, end)
    {
        if (end === undefined) { end = start; }

        this.startScale = start;
        this.endScale = end;

        return this;
    },

    setAlpha: function (start, end)
    {
        if (end === undefined) { end = start; }

        this.startAlpha = start;
        this.endAlpha = end;

        return this;
    },

    setAngle: function (start, end)
    {
        if (end === undefined) { end = start; }

        this.startAngle = start;
        this.endAngle = end;

        return this;
    },

    setGravity: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.gravityX = x;
        this.gravityY = y;

        return this;
    },

    setEmitterDelay: function (delay)
    {
        this.delay = delay;
    },

    reserve: function (particleCount)
    {
        var dead = this.dead;

        for (var count = 0; count < particleCount; ++count)
        {
            dead.push(new Particle(this.x, this.y));
        }

        return this;
    },

    getAliveParticleCount: function ()
    {
        return this.alive.length;
    },

    getDeadParticleCount: function ()
    {
        return this.dead.length;
    },

    getParticleCount: function ()
    {
        return this.getAliveParticleCount() + this.getDeadParticleCount();
    },

    onParticleDeath: function (callback)
    {
        if (typeof callback === 'function')
        {
            this.deathCallback = callback;
        }

        return this;
    },

    killAll: function ()
    {
        var dead = this.dead;
        var alive = this.alive;

        while (alive.length > 0)
        {
            dead.push(alive.pop());
        }

        return this;
    },

    forEachAlive: function (callback, thisArg)
    {
        var alive = this.alive;
        var length = alive.length;

        for (var index = 0; index < length; ++index)
        {
            callback.call(thisArg, alive[index]);
        }

        return this;
    },

    forEachDead: function (callback, thisArg)
    {
        var dead = this.dead;
        var length = dead.length;

        for (var index = 0; index < length; ++index)
        {
            callback.call(thisArg, dead[index]);
        }

        return this;
    },

    pause: function ()
    {
        this.active = false;
    },

    resume: function ()
    {
        this.active = true;
    },

    explode: function (count)
    {
        if (!count) count = 100;
        this.emitParticle(100);
    },

    emitParticle: function(count)
    {
        count = count || 1;

        var particle = null;

        for (var index = 0; index < count; ++index)
        {
            var rad = DegToRad(Between(this.minEmitAngle, this.maxEmitAngle));
            var speed = Between(this.minSpeed, this.maxSpeed);
            var vx = Math.cos(rad) * speed;
            var vy = Math.sin(rad) * speed;
            
            if (this.dead.length > 0)
            {
                particle = this.dead.pop();
                particle.reset(this.x, this.y);
            }
            else if (this.allowCreation)
            {
                particle = new Particle(this.x, this.y);
            }
            else
            {
                return null;
            }

            particle.velocityX = vx;
            particle.velocityY = vy;
            particle.life = Math.max(this.life, Number.MIN_VALUE);
            particle.lifeStep = particle.life;
            particle.start.scale = this.startScale;
            particle.end.scale = this.endScale;
            particle.scaleX = this.startScale;
            particle.scaleY = this.startScale;
            particle.start.alpha = this.startAlpha;
            particle.end.alpha = this.endAlpha;
            particle.start.rotation = this.startAngle * Math.PI / 180;
            particle.end.rotation = this.endAngle * Math.PI / 180;
            particle.color = (particle.color & 0x00FFFFFF) | (((this.startAlpha * 0xFF)|0) << 24);
            particle.index = this.alive.length;
                    
            this.alive.push(particle);
        }
        return particle;
    },

    preUpdate: function (time, delta)
    {
        var dead = this.dead;
        var particles = this.alive;
        var length = particles.length;
        var emitterStep = (delta / 1000);
        var gravityX = this.gravityX * emitterStep;
        var gravityY = this.gravityY * emitterStep;
        var deathCallback = this.deathCallback;

        /* Simulation */
        for (var index = 0; index < length; ++index)
        {
            var particle = particles[index];

            particle.velocityX += gravityX;
            particle.velocityY += gravityY;
            particle.x += particle.velocityX * emitterStep;
            particle.y += particle.velocityY * emitterStep;
            particle.normLifeStep = particle.lifeStep / particle.life;

            var norm = 1.0 - particle.normLifeStep;
            var alphaEase = this.easingFunctionAlpha(norm);
            var scaleEase = this.easingFunctionScale(norm);
            var rotationEase = this.easingFunctionRotation(norm);
            var alphaf = (particle.end.alpha - particle.start.alpha) * alphaEase + particle.start.alpha;
            var scale = (particle.end.scale - particle.start.scale) * scaleEase + particle.start.scale;
            var rotation = (particle.end.rotation - particle.start.rotation) * rotationEase + particle.start.rotation;

            particle.scaleX = particle.scaleY = scale;
            particle.color = (particle.color & 0x00FFFFFF) | (((alphaf * 0xFF)|0) << 24);
            particle.rotation = rotation;

            if (particle.lifeStep <= 0)
            {
                var last = particles[length - 1];
                particles[length - 1] = particle;
                particles[index] = last;
                index -= 1;
                length -= 1;

                if (deathCallback)
                {
                    deathCallback(particle);
                }
            }

            particle.lifeStep -= emitterStep;
        }

        /* Cleanup */
        var deadLength = particles.length - length;

        if (deadLength > 0)
        {
            dead.push.apply(dead, particles.splice(particles.length - deadLength, deadLength));
            StableSort(particles, function (a, b) { return a.index - b.index; });
        }

        this.delayCounter -= emitterStep;

        if (this.delayCounter <= 0 && this.enabled)
        {
            this.emitParticle(this.emitCount);
            this.delayCounter = this.delay;
        }
    }

});

module.exports = ParticleEmitter;


/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = {
    ARC: 0,
    BEGIN_PATH: 1,
    CLOSE_PATH: 2,
    FILL_RECT: 3,
    LINE_TO: 4,
    MOVE_TO: 5,
    LINE_STYLE: 6,
    FILL_STYLE: 7,
    FILL_PATH: 8,
    STROKE_PATH: 9,
    FILL_TRIANGLE: 10,
    STROKE_TRIANGLE: 11,
    LINE_FX_TO: 12,
    MOVE_FX_TO: 13,
    SAVE: 14,
    RESTORE: 15,
    TRANSLATE: 16,
    SCALE: 17,
    ROTATE: 18
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var Camera = __webpack_require__(74);
var CanvasPool = __webpack_require__(15);
var Class = __webpack_require__(0);
var Commands = __webpack_require__(82);
var Components = __webpack_require__(8);
var GameObject = __webpack_require__(1);
var GetValue = __webpack_require__(4);
var MATH_CONST = __webpack_require__(13);
var Render = __webpack_require__(495);

var Graphics = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Transform,
        Components.RenderTarget,
        Components.Visible,
        Components.ScrollFactor,
        Render
    ],

    initialize:

    function Graphics (scene, options)
    {
        var x = GetValue(options, 'x', 0);
        var y = GetValue(options, 'y', 0);

        GameObject.call(this, scene, 'Graphics');

        this.setPosition(x, y);

        this.displayOriginX = 0;
        this.displayOriginY = 0;

        this.commandBuffer = [];

        this.defaultFillColor = -1;
        this.defaultFillAlpha = 1;

        this.defaultStrokeWidth = 1;
        this.defaultStrokeColor = -1;
        this.defaultStrokeAlpha = 1;

        this.setDefaultStyles(options);

        var resourceManager = scene.sys.game.renderer.resourceManager;

        if (resourceManager !== undefined)
        {
            this.resourceManager = resourceManager;
            this.gl = scene.sys.game.renderer.gl;
        }
    },

    //  STYLES

    setDefaultStyles: function (options)
    {
        if (GetValue(options, 'lineStyle', null))
        {
            this.defaultStrokeWidth = GetValue(options, 'lineStyle.width', 1);
            this.defaultStrokeColor = GetValue(options, 'lineStyle.color', 0xffffff);
            this.defaultStrokeAlpha = GetValue(options, 'lineStyle.alpha', 1);

            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
        }

        if (GetValue(options, 'fillStyle', null))
        {
            this.defaultFillColor = GetValue(options, 'fillStyle.color', 0xffffff);
            this.defaultFillAlpha = GetValue(options, 'fillStyle.alpha', 1);

            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
        }

        return this;
    },

    lineStyle: function (lineWidth, color, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.commandBuffer.push(
            Commands.LINE_STYLE,
            lineWidth, color, alpha
        );

        return this;
    },

    fillStyle: function (color, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.commandBuffer.push(
            Commands.FILL_STYLE,
            color, alpha
        );

        return this;
    },

    //  PATH

    beginPath: function ()
    {
        this.commandBuffer.push(
            Commands.BEGIN_PATH
        );

        return this;
    },

    closePath: function ()
    {
        this.commandBuffer.push(
            Commands.CLOSE_PATH
        );

        return this;
    },

    fillPath: function ()
    {
        this.commandBuffer.push(
            Commands.FILL_PATH
        );

        return this;
    },

    strokePath: function ()
    {
        this.commandBuffer.push(
            Commands.STROKE_PATH
        );

        return this;
    },

    //  CIRCLE

    fillCircleShape: function (circle)
    {
        return this.fillCircle(circle.x, circle.y, circle.radius);
    },

    strokeCircleShape: function (circle)
    {
        return this.strokeCircle(circle.x, circle.y, circle.radius);
    },

    fillCircle: function (x, y, radius)
    {
        this.beginPath();
        this.arc(x, y, radius, 0, MATH_CONST.PI2);
        this.fillPath();
        this.closePath();

        return this;
    },

    strokeCircle: function (x, y, radius)
    {
        this.beginPath();
        this.arc(x, y, radius, 0, MATH_CONST.PI2);
        this.closePath();
        this.strokePath();

        return this;
    },

    //  RECTANGLE

    fillRectShape: function (rect)
    {
        return this.fillRect(rect.x, rect.y, rect.width, rect.height);
    },

    strokeRectShape: function (rect)
    {
        return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
    },

    fillRect: function (x, y, width, height)
    {
        this.commandBuffer.push(
            Commands.FILL_RECT,
            x, y, width, height
        );

        return this;
    },

    strokeRect: function (x, y, width, height)
    {
        this.beginPath();
        this.moveTo(x, y);
        this.lineTo(x + width, y);
        this.lineTo(x + width, y + height);
        this.lineTo(x, y + height);
        this.lineTo(x, y);
        this.strokePath();
        this.closePath();

        return this;
    },

    //  POINT

    fillPointShape: function (point, size)
    {
        return this.fillPoint(point.x, point.y, size);
    },

    fillPoint: function (x, y, size)
    {
        this.commandBuffer.push(
            Commands.FILL_RECT,
            x, y, size, size
        );

        return this;
    },

    //  TRIANGLE

    fillTriangleShape: function (triangle)
    {
        return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
    },

    strokeTriangleShape: function (triangle)
    {
        return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
    },

    fillTriangle: function (x0, y0, x1, y1, x2, y2)
    {
        this.commandBuffer.push(
            Commands.FILL_TRIANGLE,
            x0, y0, x1, y1, x2, y2
        );

        return this;
    },

    strokeTriangle: function (x0, y0, x1, y1, x2, y2)
    {
        this.commandBuffer.push(
            Commands.STROKE_TRIANGLE,
            x0, y0, x1, y1, x2, y2
        );

        return this;
    },

    //  LINE

    strokeLineShape: function (line)
    {
        return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
    },

    lineBetween: function (x1, y1, x2, y2)
    {
        this.beginPath();
        this.moveTo(x1, y1);
        this.lineTo(x2, y2);
        this.strokePath();
        this.closePath();

        return this;
    },

    lineTo: function (x, y)
    {
        this.commandBuffer.push(
            Commands.LINE_TO,
            x, y
        );

        return this;
    },

    moveTo: function (x, y)
    {
        this.commandBuffer.push(
            Commands.MOVE_TO,
            x, y
        );

        return this;
    },

    lineFxTo: function (x, y, width, rgb)
    {
        this.commandBuffer.push(
            Commands.LINE_FX_TO,
            x, y, width, rgb, 1
        );

        return this;
    },

    moveFxTo: function (x, y, width, rgb)
    {
        this.commandBuffer.push(
            Commands.MOVE_FX_TO,
            x, y, width, rgb, 1
        );

        return this;
    },

    //  ARC

    arc: function (x, y, radius, startAngle, endAngle, anticlockwise)
    {
        this.commandBuffer.push(
            Commands.ARC,
            x, y, radius, startAngle, endAngle, anticlockwise
        );

        return this;
    },

    save: function ()
    {
        this.commandBuffer.push(
            Commands.SAVE
        );

        return this;
    },

    restore: function ()
    {
        this.commandBuffer.push(
            Commands.RESTORE
        );

        return this;
    },

    translate: function (x, y)
    {
        this.commandBuffer.push(
            Commands.TRANSLATE,
            x, y
        );

        return this;
    },

    scale: function (x, y)
    {
        this.commandBuffer.push(
            Commands.SCALE,
            x, y
        );

        return this;
    },

    rotate: function (radian)
    {
        this.commandBuffer.push(
            Commands.ROTATE,
            radian
        );

        return this;
    },

    clear: function ()
    {
        this.commandBuffer.length = 0;

        if (this.defaultFillColor > -1)
        {
            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
        }

        if (this.defaultStrokeColor > -1)
        {
            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
        }

        return this;
    },

    //  If key is a string it'll generate a new texture using it and add it into the 
    //  Texture Manager (assuming no key conflict happens).
    //  
    //  If key is a Canvas it will draw the texture to that canvas context. Note that it will NOT
    //  automatically upload it to the GPU in WebGL mode.

    generateTexture: function (key, width, height)
    {
        var sys = this.scene.sys;

        if (width === undefined) { width = sys.game.config.width; }
        if (height === undefined) { height = sys.game.config.height; }
        
        Graphics.TargetCamera.setViewport(0, 0, width, height);
        Graphics.TargetCamera.scrollX = this.x;
        Graphics.TargetCamera.scrollY = this.y;

        var texture;
        var ctx;

        if (typeof key === 'string')
        {
            if (sys.textures.exists(key))
            {
                //  Key is a string, it DOES exist in the Texture Manager AND is a canvas, so draw to it

                texture = sys.textures.get(key);

                var src = texture.getSourceImage();

                if (src instanceof HTMLCanvasElement)
                {
                    ctx = src.getContext('2d');
                }
            }
            else
            {
                //  Key is a string and doesn't exist in the Texture Manager, so generate and save it

                texture = sys.textures.createCanvas(key, width, height);

                ctx = texture.getSourceImage().getContext('2d');
            }
        }
        else if (key instanceof HTMLCanvasElement)
        {
            //  Key is a Canvas, so draw to it

            ctx = key.getContext('2d');
        }

        if (ctx)
        {
            this.renderCanvas(sys.game.renderer, this, 0, Graphics.TargetCamera, ctx);

            if (this.gl && texture)
            {
                sys.game.renderer.uploadCanvasToGPU(ctx.canvas, texture.source[0].glTexture, true);
            }
        }

        return this;
    }

});

Graphics.TargetCamera = new Camera(0, 0, 0, 0);

module.exports = Graphics;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var Set = __webpack_require__(54);
var GetValue = __webpack_require__(4);
var Range = __webpack_require__(251);
var Actions = __webpack_require__(117);
var Sprite = __webpack_require__(31);

var Group = new Class({

    initialize:

    function Group (scene, children, config)
    {
        this.scene = scene;

        this.children = new Set(children);

        this.classType = Sprite;

        if (config)
        {
            this.createMultiple(config);
        }
    },

    update: function (time, delta)
    {
        //  Because a Group child may mess with the length of the Group during its update
        var temp = this.children.entries.slice();

        for (var i = 0; i < temp.length; i++)
        {
            if (temp[i].update(time, delta) === false)
            {
                break;
            }
        }
    },

    //  Group management methods:

    add: function (child)
    {
        this.children.set(child);

        return this;
    },

    addMultiple: function (children)
    {
        if (Array.isArray(children))
        {
            for (var i = 0; i < children.length; i++)
            {
                this.children.set(children[i]);
            }
        }

        return this;
    },

    create: function (x, y, key, frame, visible)
    {
        if (visible === undefined) { visible = true; }

        var child = new this.classType(this.scene, x, y, key, frame);

        this.scene.sys.displayList.add(child);

        if (child.preUpdate)
        {
            this.scene.sys.updateList.add(child);
        }

        child.visible = visible;

        this.children.set(child);

        return child;
    },

    createFromConfig: function (options)
    {
        this.classType = GetValue(options, 'classType', this.classType);

        var key = GetValue(options, 'key', undefined);
        var frame = GetValue(options, 'frame', null);
        var visible = GetValue(options, 'visible', true);

        var entries = [];

        //  Can't do anything without at least a key
        if (key === undefined)
        {
            return entries;
        }
        else
        {
            if (!Array.isArray(key))
            {
                key = [ key ];
            }

            if (!Array.isArray(frame))
            {
                frame = [ frame ];
            }
        }

        //  Build an array of key frame pairs to loop through

        var repeat = GetValue(options, 'repeat', 0);
        var randomKey = GetValue(options, 'randomKey', false);
        var randomFrame = GetValue(options, 'randomFrame', false);
        var yoyo = GetValue(options, 'yoyo', false);
        var quantity = GetValue(options, 'frameQuantity', 1);
        var max = GetValue(options, 'max', 0);

        var range = Range(key, frame, {
            max: max,
            qty: quantity,
            random: randomKey,
            randomB: randomFrame,
            repeat: repeat,
            yoyo: yoyo
        });

        for (var c = 0; c < range.length; c++)
        {
            entries.push(this.create(0, 0, range[c].a, range[c].b, visible));
        }

        //  Post-creation options (applied only to those items created in this call):

        var x = GetValue(options, 'setXY.x', 0);
        var y = GetValue(options, 'setXY.y', 0);
        var stepX = GetValue(options, 'setXY.stepX', 0);
        var stepY = GetValue(options, 'setXY.stepY', 0);

        Actions.SetXY(entries, x, y, stepX, stepY);

        var rotation = GetValue(options, 'setRotation.value', 0);
        var stepRotation = GetValue(options, 'setRotation.step', 0);

        Actions.SetRotation(entries, rotation, stepRotation);

        var scaleX = GetValue(options, 'setScale.x', 1);
        var scaleY = GetValue(options, 'setScale.y', scaleX);
        var stepScaleX = GetValue(options, 'setScale.stepX', 0);
        var stepScaleY = GetValue(options, 'setScale.stepY', 0);

        Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);

        var alpha = GetValue(options, 'setAlpha.value', 1);
        var stepAlpha = GetValue(options, 'setAlpha.step', 0);

        Actions.SetAlpha(entries, alpha, stepAlpha);

        var hitArea = GetValue(options, 'hitArea', null);
        var hitAreaCallback = GetValue(options, 'hitAreaCallback', null);

        if (hitArea)
        {
            Actions.SetHitArea(entries, hitArea, hitAreaCallback);
        }

        var grid = GetValue(options, 'gridAlign', false);

        if (grid)
        {
            Actions.GridAlign(entries, grid);
        }

        return entries;
    },

    createMultiple: function (config)
    {
        if (!Array.isArray(config))
        {
            config = [ config ];
        }

        var output = [];

        for (var i = 0; i < config.length; i++)
        {
            var entries = this.createFromConfig(config[i]);

            output = output.concat(entries);
        }

        return output;
    },

    remove: function (child)
    {
        this.children.delete(child);

        return this;
    },

    clear: function ()
    {
        this.children.clear();

        return this;
    },

    getChildren: function ()
    {
        return this.children.entries;
    },

    getLength: function ()
    {
        return this.children.size;
    },

    getFirst: function (compare, index)
    {
        if (index === undefined) { index = 0; }

        return Actions.GetFirst(this.children.entries, compare, index);
    },

    destroy: function ()
    {
        this.children.clear();

        this.scene = undefined;
        this.children = undefined;
    },

    //  Child related methods

    angle: function (value)
    {
        Actions.Angle(this.children.entries, value);

        return this;
    },

    gridAlign: function (options)
    {
        Actions.GridAlign(this.children.entries, options);

        return this;
    },

    incAlpha: function (value, step)
    {
        Actions.IncAlpha(this.children.entries, value, step);

        return this;
    },

    incX: function (value)
    {
        Actions.IncX(this.children.entries, value);

        return this;
    },

    incXY: function (x, y)
    {
        Actions.IncXY(this.children.entries, x, y);

        return this;
    },

    incY: function (value)
    {
        Actions.IncY(this.children.entries, value);

        return this;
    },

    placeOnCircle: function (circle, startAngle, endAngle)
    {
        Actions.PlaceOnCircle(this.children.entries, circle, startAngle, endAngle);

        return this;
    },

    placeOnEllipse: function (ellipse, startAngle, endAngle)
    {
        Actions.PlaceOnEllipse(this.children.entries, ellipse, startAngle, endAngle);

        return this;
    },

    placeOnLine: function (line)
    {
        Actions.PlaceOnLine(this.children.entries, line);

        return this;
    },

    placeOnRectangle: function (rect, shift)
    {
        Actions.PlaceOnRectangle(this.children.entries, rect, shift);

        return this;
    },

    placeOnTriangle: function (triangle, stepRate)
    {
        Actions.PlaceOnTriangle(this.children.entries, triangle, stepRate);

        return this;
    },

    playAnimation: function (key, startFrame)
    {
        Actions.PlayAnimation(this.children.entries, key, startFrame);

        return this;
    },

    randomCircle: function (circle)
    {
        Actions.RandomCircle(this.children.entries, circle);

        return this;
    },

    randomEllipse: function (ellipse)
    {
        Actions.RandomEllipse(this.children.entries, ellipse);

        return this;
    },

    randomLine: function (line)
    {
        Actions.RandomLine(this.children.entries, line);

        return this;
    },

    randomRectangle: function (rect)
    {
        Actions.RandomRectangle(this.children.entries, rect);

        return this;
    },

    randomTriangle: function (triangle)
    {
        Actions.RandomTriangle(this.children.entries, triangle);

        return this;
    },

    rotate: function (value, step)
    {
        Actions.Rotate(this.children.entries, value, step);

        return this;
    },

    rotateAround: function (point, angle)
    {
        Actions.RotateAround(this.children.entries, point, angle);

        return this;
    },

    rotateAroundDistance: function (point, angle, distance)
    {
        Actions.RotateAroundDistance(this.children.entries, point, angle, distance);

        return this;
    },

    setAlpha: function (value, step)
    {
        Actions.SetAlpha(this.children.entries, value, step);

        return this;
    },

    setOrigin: function (x, y)
    {
        Actions.SetOrigin(this.children.entries, x, y);

        return this;
    },

    scaleX: function (value)
    {
        Actions.ScaleX(this.children.entries, value);

        return this;
    },

    scaleXY: function (x, y)
    {
        Actions.ScaleXY(this.children.entries, x, y);

        return this;
    },

    scaleY: function (value)
    {
        Actions.ScaleY(this.children.entries, value);

        return this;
    },

    setRotation: function (value, step)
    {
        Actions.SetRotation(this.children.entries, value, step);

        return this;
    },

    setScale: function (x, y, stepX, stepY)
    {
        Actions.SetScale(this.children.entries, x, y, stepX, stepY);

        return this;
    },

    setScaleX: function (value, step)
    {
        Actions.SetScaleX(this.children.entries, value, step);

        return this;
    },

    setScaleY: function (value, step)
    {
        Actions.SetScaleY(this.children.entries, value, step);

        return this;
    },

    setVisible: function (value)
    {
        Actions.SetVisible(this.children.entries, value);

        return this;
    },

    setX: function (value, step)
    {
        Actions.SetX(this.children.entries, value, step);

        return this;
    },

    setXY: function (x, y, stepX, stepY)
    {
        Actions.SetXY(this.children.entries, x, y, stepX, stepY);

        return this;
    },

    setY: function (value, step)
    {
        Actions.SetY(this.children.entries, value, step);

        return this;
    },

    setDepth: function (value, step)
    {
        Actions.SetDepth(this.children.entries, value, step);

        return this;
    },

    shiftPosition: function (x, y, direction, output)
    {
        Actions.ShiftPosition(this.children.entries, x, y, direction, output);

        return this;
    },

    smootherStep: function (property, min, max, inc)
    {
        Actions.SmootherStep(this.children.entries, property, min, max, inc);

        return this;
    },

    smoothStep: function (property, min, max, inc)
    {
        Actions.SmoothStep(this.children.entries, property, min, max, inc);

        return this;
    },

    spread: function (property, min, max, inc)
    {
        Actions.Spread(this.children.entries, property, min, max, inc);

        return this;
    },

    toggleVisible: function ()
    {
        Actions.ToggleVisible(this.children.entries);

        return this;
    }

});

module.exports = Group;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var Components = __webpack_require__(8);
var Const = __webpack_require__(504);
var GameObject = __webpack_require__(1);
var GBufferShader = __webpack_require__(916);
var Light = __webpack_require__(506);
var LightFragmentShader = __webpack_require__(917);
var Phong2DShaderDeferred = __webpack_require__(919);
var Render = __webpack_require__(510);
var SpriteNormalPair = __webpack_require__(512);
var TexturedAndNormalizedTintedShader = __webpack_require__(43);
var VertexBuffer = __webpack_require__(110);
var WebGLSupportedExtensions = __webpack_require__(229);

// http://cpetry.github.io/NormalMap-Online/

var LightLayer = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Origin,
        Components.RenderTarget,
        Components.ScrollFactor,
        Components.Visible,
        Render
    ],

    initialize:

    function LightLayer (scene)
    {
        var _this = this;

        GameObject.call(this, scene, 'LightLayer');

        this.passShader = null;
        this.gl = null;
        this.ambientLightColorR = 0.0;
        this.ambientLightColorG = 0.0;
        this.ambientLightColorB = 0.0;
        this.lightPool = [];
        this.spritePool = [];
        this.lights = [];
        this.sprites = [];
        this._z = 0;
        this.setOrigin(0, 0);

        scene.sys.game.renderer.addContextRestoredCallback(function (renderer) {
            _this.onContextRestored(renderer);
        });

        this.init(scene.sys.game.renderer, WebGLSupportedExtensions.has('WEBGL_draw_buffers'));
    },

    onContextRestored: function (renderer)
    {
        /* It won't allow the use of drawBuffers on restored context */
        this.init(renderer, false); 
        this.renderWebGL = __webpack_require__(139);
        this.lights.length = Math.min(this.lights.length, Const.MAX_LIGHTS);
    },

    init: function (renderer, deferred)
    {
        var resourceManager = renderer.resourceManager;
        
        this._isDeferred = deferred;
        this.renderer = renderer;
        this.lightsLocations = [];

        if (resourceManager !== undefined && !this._isDeferred)
        {
            this.gl = renderer.gl;

            this.passShader = resourceManager.createShader('Phong2DShaderForward', {
                vert: TexturedAndNormalizedTintedShader.vert,
                frag: LightFragmentShader(Const.MAX_LIGHTS)
            });

            this.ambientLightColorLoc = this.passShader.getUniformLocation('uAmbientLightColor');
            this.uMainTextureLoc = this.passShader.getUniformLocation('uMainTexture');
            this.uNormTextureLoc = this.passShader.getUniformLocation('uNormTexture');
            this.uResolutionLoc = this.passShader.getUniformLocation('uResolution');
            this.uCameraLoc = this.passShader.getUniformLocation('uCamera');

            this.passShader.setConstantInt1(this.uMainTextureLoc, 0);
            this.passShader.setConstantInt1(this.uNormTextureLoc, 1);

            for (var index = 0; index < Const.MAX_LIGHTS; ++index)
            {
                this.lightsLocations[index] = {
                    position: this.passShader.getUniformLocation('uLights[' + index + '].position'),
                    color: this.passShader.getUniformLocation('uLights[' + index + '].color'),
                    attenuation: this.passShader.getUniformLocation('uLights[' + index + '].attenuation'),
                    radius: this.passShader.getUniformLocation('uLights[' + index + '].radius')
                };
            }
        }
        else
        {
            var gl = this.gl = renderer.gl;

            this.ext = renderer.getExtension('WEBGL_draw_buffers');

            this.gBufferShaderPass = resourceManager.createShader('GBufferShader', {
                vert: TexturedAndNormalizedTintedShader.vert,
                frag: GBufferShader()
            });

            var phongShader = Phong2DShaderDeferred(Const.DEFERRED_MAX_LIGHTS);

            this.lightPassShader = resourceManager.createShader('Phong2DShaderDeferred', {
                vert: phongShader.vert,
                frag: phongShader.frag
            });

            this.lightPassVBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.lightPassVBO);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1, 7, -1, -1, 7, -1 ]), gl.STATIC_DRAW);
            
            this.uMainTextureLoc = this.gBufferShaderPass.getUniformLocation('uMainTexture');
            this.uNormTextureLoc = this.gBufferShaderPass.getUniformLocation('uNormTexture');

            this.gBufferShaderPass.setConstantInt1(this.uMainTextureLoc, 0);
            this.gBufferShaderPass.setConstantInt1(this.uNormTextureLoc, 1);

            this.ambientLightColorLoc = this.lightPassShader.getUniformLocation('uAmbientLightColor');
            this.uResolutionLoc = this.lightPassShader.getUniformLocation('uResolution');
            this.uGbufferColorLoc = this.lightPassShader.getUniformLocation('uGbufferColor');
            this.uGbufferNormalLoc = this.lightPassShader.getUniformLocation('uGbufferNormal');
            this.uCameraLoc = this.lightPassShader.getUniformLocation('uCamera');

            this.lightPassShader.setConstantInt1(this.uGbufferColorLoc, 0);
            this.lightPassShader.setConstantInt1(this.uGbufferNormalLoc, 1);

            this.gBufferShaderPass.bindAttribLocation(0, 'v_tex_coord');
            this.gBufferShaderPass.bindAttribLocation(1, 'v_color');
            this.gBufferShaderPass.bindAttribLocation(2, 'v_alpha');
            this.lightPassShader.bindAttribLocation(0, 'vertexPosition');

            for (var index = 0; index < Const.DEFERRED_MAX_LIGHTS; ++index)
            {
                this.lightsLocations[index] = {
                    position: this.lightPassShader.getUniformLocation('uLights[' + index + '].position'),
                    color: this.lightPassShader.getUniformLocation('uLights[' + index + '].color'),
                    attenuation: this.lightPassShader.getUniformLocation('uLights[' + index + '].attenuation'),
                    radius: this.lightPassShader.getUniformLocation('uLights[' + index + '].radius')
                };
            }

            /* Setup render targets */
            this.gBufferFbo = gl.createFramebuffer();
            this.gBufferColorTex = gl.createTexture();
            this.gBufferNormalTex = gl.createTexture();

            gl.bindFramebuffer(gl.FRAMEBUFFER, this.gBufferFbo);
            gl.bindTexture(gl.TEXTURE_2D, this.gBufferColorTex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, renderer.width, renderer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.bindTexture(gl.TEXTURE_2D, this.gBufferNormalTex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, renderer.width, renderer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, this.ext.COLOR_ATTACHMENT0_WEBGL, gl.TEXTURE_2D, this.gBufferColorTex, 0);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, this.ext.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, this.gBufferNormalTex, 0);

            this.ext.drawBuffersWEBGL([ this.ext.COLOR_ATTACHMENT0_WEBGL, this.ext.COLOR_ATTACHMENT1_WEBGL ]);

            var complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

            if (complete !== gl.FRAMEBUFFER_COMPLETE)
            {
                var errors = {
                    36054: 'Incomplete Attachment',
                    36055: 'Missing Attachment',
                    36057: 'Incomplete Dimensions',
                    36061: 'Framebuffer Unsupported'
                };
                throw new Error('Framebuffer incomplete. Framebuffer status: ' + errors[complete]);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            VertexBuffer.SetDirty();
        }
    },

    forEachLight: function (callback)
    {
        if (!callback)
        {
            return;
        }

        var lights = this.lights;
        var length = lights.length;
        
        for (var index = 0; index < length; ++index)
        {
            callback(lights[index]);
        }
    },

    get z ()
    {
        return this._z;
    },

    set z (newZ)
    {
        this._z = newZ;
    },

    setAmbientLightColor: function (r, g, b)
    {
        this.ambientLightColorR = r;
        this.ambientLightColorG = g;
        this.ambientLightColorB = b;
    },

    getMaxLights: function ()
    {
        return (this._isDeferred) ? Const.DEFERRED_MAX_LIGHTS : Const.MAX_LIGHTS;
    },

    getLightCount: function ()
    {
        return this.lights.length;
    },

    isDeferred: function ()
    {
        return this._isDeferred;
    },

    /* This will probably be removed later */ 
    addSprite: function (sprite, normalTexture)
    {
        var spriteNormalPair;

        if (this.spritePool.length > 0)
        {
            spriteNormalPair = this.spritePool.pop();
            spriteNormalPair.set(sprite, normalTexture);
        }
        else
        {
            spriteNormalPair = new SpriteNormalPair(sprite, normalTexture);
        }
        this.scene.sys.displayList.remove(sprite);
        this.sprites.push(spriteNormalPair);
    },

    removeSprite: function (sprite)
    {
        var length = this.sprites.length;
        for (var index = 0; index < length; ++index)
        {
            if (this.sprites[index].spriteRef === sprite)
            {
                this.spritePool.push(this.sprites[index]);
                this.sprites.splice(index, 1);
                break;
            }
        }
        return sprite;
    },

    addLight: function (x, y, z, radius, r, g, b, attenuation)
    {
        if (this.lights.length < this.getMaxLights())
        {
            var light = null;
            if (this.lightPool.length > 0)
            {
                light = this.lightPool.pop();
                light.set(x, y, z, radius, r, g, b, attenuation);
            }
            else
            {
                light = new Light(x, y, z, radius, r, g, b, attenuation);
            }
            this.lights.push(light);
            return light;
        }
        return null;
    },

    removeLight: function (light)
    {
        var index = this.lights.indexOf(light);

        if (index >= 0)
        {
            this.lightPool.push(light);
            this.lights.splice(index, 1);
        }
    },

    updateLights: function (renderer, camera, shader)
    {
        if (this.gl !== null)
        {
            var locations = this.lightsLocations;
            var lights = this.lights;
            var length = lights.length;
            var point = {x: 0, y: 0};
            var height = renderer.height;
            var cameraMatrix = camera.matrix;
            var gl = this.gl;

            shader.bind();

            gl.uniform2f(this.uResolutionLoc, renderer.width, renderer.height);
            gl.uniform3f(this.ambientLightColorLoc, this.ambientLightColorR, this.ambientLightColorG, this.ambientLightColorB);
            gl.uniform4f(this.uCameraLoc, camera.x, camera.y, camera.rotation, camera.zoom);

            for (var index = 0; index < length; ++index)
            {
                var light = lights[index];
                cameraMatrix.transformPoint(light.x, light.y, point);
                gl.uniform1f(locations[index].attenuation, light.attenuation);
                gl.uniform1f(locations[index].radius, light.radius);
                gl.uniform3f(locations[index].position, point.x - (camera.scrollX * light.scrollFactorX * camera.zoom), height - (point.y - (camera.scrollY * light.scrollFactorY) * camera.zoom), light.z);
                gl.uniform3f(locations[index].color, light.r, light.g, light.b);
            }
        }
    }

});

module.exports = LightLayer;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.GameObjects.ObjectPool

var Class = __webpack_require__(0);

//  An Object Pool

var ObjectPool = new Class({

    initialize:

    function ObjectPool (manager, classType, maxSize, createCallback, callbackScope)
    {
        if (maxSize === undefined) { maxSize = -1; }
        if (createCallback === undefined) { createCallback = this.makeGameObject; }
        if (callbackScope === undefined) { callbackScope = this; }

        this.manager = manager;
        this.scene = manager.scene;

        this.displayList = this.scene.sys.displayList;
        this.updateList = this.scene.sys.updateList;

        this.createCallback = createCallback;
        this.callbackScope = callbackScope;

        this.maxSize = maxSize;

        this.classType = classType;

        this._list = [];
    },

    makeGameObject: function ()
    {
        var gameObject = new this.classType(this.scene);

        this.displayList.add(gameObject);

        gameObject.setActive(false);
        gameObject.setVisible(false);

        return gameObject;
    },

    //  Add an existing GameObject, or Array or Group of GameObjects into this Pool
    add: function (child)
    {
        var children;

        if (Array.isArray(child))
        {
            children = child;
        }
        else if (child.hasOwnProperty('children'))
        {
            children = child.children.getArray();
        }
        else
        {
            children = [ child ];
        }

        var len = children.length;

        if (this.maxSize > -1)
        {
            var free = this.maxSize - this._list.length;

            if (len > free)
            {
                len = free;
            }
        }

        for (var i = 0; i < len; i++)
        {
            this._list.push(children[i]);
        }

        return this;
    },

    //  Create X new GameObjects in this Pool if there is capacity to do so
    create: function (quantity)
    {
        for (var i = 0; i < quantity; i++)
        {
            if (!this.isFull())
            {
                this._list.push(this.createCallback.call(this.callbackScope));
            }
        }

        return this;
    },

    //  Proxy method for sub-classes to override
    get: function ()
    {
        return this.getFreeGameObject();
    },

    getFreeGameObject: function ()
    {
        var gameObject;

        for (var i = 0; i < this._list.length; i++)
        {
            gameObject = this._list[i];

            if (!gameObject.active)
            {
                gameObject.setActive(true);
                gameObject.setVisible(true);

                return gameObject;
            }
        }

        if (!this.isFull())
        {
            gameObject = this.createCallback.call(this.callbackScope);

            gameObject.setActive(true);
            gameObject.setVisible(true);

            this._list.push(gameObject);

            return gameObject;
        }

        return null;
    },

    kill: function (gameObject)
    {
        if (this._list.indexOf(gameObject) > -1)
        {
            gameObject.setActive(false);
        }
    },

    killAndHide: function (gameObject)
    {
        if (this._list.indexOf(gameObject) > -1)
        {
            gameObject.setActive(false);
            gameObject.setVisible(false);
        }
    },

    purge: function (destroyChildren)
    {
        if (destroyChildren === undefined) { destroyChildren = true; }

        if (destroyChildren)
        {
            for (var i = 0; i < this._list.length; i++)
            {
                this._list[i].destroy();
            }
        }
        
        this._list.length = 0;
    },

    isFull: function ()
    {
        if (this.maxSize === -1)
        {
            return false;
        }
        else
        {
            return (this._list.length === this.maxSize);
        }
    },

    update: function (time, delta)
    {
        for (var i = 0; i < this._list.length; i++)
        {
            var gameObject = this._list[i];

            if (gameObject.active)
            {
                gameObject.update(time, delta);
            }
        }
    },

    getTotalUsed: function ()
    {
        var total = 0;

        for (var i = 0; i < this._list.length; i++)
        {
            if (this._list[i].active)
            {
                total++;
            }
        }

        return total;
    },

    getTotalFree: function ()
    {
        var used = this.getTotalUsed();
        var capacity = (this.maxSize === -1) ? 999999999999 : this.maxSize;

        return (capacity - used);
    },

    destroy: function ()
    {
        this.manager = undefined;
        this.scene = undefined;

        this.displayList = undefined;
        this.updateList = undefined;

        this.createCallback = undefined;
        this.callbackScope = undefined;

        this._list.length = 0;
    }

});

module.exports = ObjectPool;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var Mesh = __webpack_require__(57);

var Quad = new Class({

    Extends: Mesh,

    initialize:

    function Quad (scene, x, y, texture, frame)
    {
        //  0----3
        //  |\  B|
        //  | \  |
        //  |  \ |
        //  | A \|
        //  |    \
        //  1----2

        //  Array sequence: tl, bl, br, tr
        var vertices = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
        var uv = [ 0, 0, 0, 1, 1, 1, 1, 0 ];
        var indices = [ 0, 1, 2, 0, 2, 3 ];
        var colors = [ 0xffffff, 0xffffff, 0xffffff, 0xffffff ];
        var alphas = [ 1, 1, 1, 1 ];

        Mesh.call(this, scene, x, y, vertices, uv, indices, colors, alphas, texture, frame);

        this.resetPosition();
    },

    topLeftX: {

        get: function ()
        {
            return this.x + this.vertices[0];
        },

        set: function (value)
        {
            this.vertices[0] = value - this.x;
        }

    },

    topLeftY: {

        get: function ()
        {
            return this.y + this.vertices[1];
        },

        set: function (value)
        {
            this.vertices[1] = value - this.y;
        }

    },

    topRightX: {

        get: function ()
        {
            return this.x + this.vertices[6];
        },

        set: function (value)
        {
            this.vertices[6] = value - this.x;
        }

    },

    topRightY: {

        get: function ()
        {
            return this.y + this.vertices[7];
        },

        set: function (value)
        {
            this.vertices[7] = value - this.y;
        }

    },

    bottomLeftX: {

        get: function ()
        {
            return this.x + this.vertices[2];
        },

        set: function (value)
        {
            this.vertices[2] = value - this.x;
        }

    },

    bottomLeftY: {

        get: function ()
        {
            return this.y + this.vertices[3];
        },

        set: function (value)
        {
            this.vertices[3] = value - this.y;
        }

    },

    bottomRightX: {

        get: function ()
        {
            return this.x + this.vertices[4];
        },

        set: function (value)
        {
            this.vertices[4] = value - this.x;
        }

    },

    bottomRightY: {

        get: function ()
        {
            return this.y + this.vertices[5];
        },

        set: function (value)
        {
            this.vertices[5] = value - this.y;
        }

    },

        //  tl, bl, br, tr

    topLeftAlpha: {

        get: function ()
        {
            return this.alphas[0];
        },

        set: function (value)
        {
            this.alphas[0] = value;
        }

    },

    topRightAlpha: {

        get: function ()
        {
            return this.alphas[3];
        },

        set: function (value)
        {
            this.alphas[3] = value;
        }

    },

    bottomLeftAlpha: {

        get: function ()
        {
            return this.alphas[1];
        },

        set: function (value)
        {
            this.alphas[1] = value;
        }

    },

    bottomRightAlpha: {

        get: function ()
        {
            return this.alphas[2];
        },

        set: function (value)
        {
            this.alphas[2] = value;
        }

    },

    topLeftColor: {

        get: function ()
        {
            return this.colors[0];
        },

        set: function (value)
        {
            this.colors[0] = value;
        }

    },

    topRightColor: {

        get: function ()
        {
            return this.colors[3];
        },

        set: function (value)
        {
            this.colors[3] = value;
        }

    },

    bottomLeftColor: {

        get: function ()
        {
            return this.colors[1];
        },

        set: function (value)
        {
            this.colors[1] = value;
        }

    },

    bottomRightColor: {

        get: function ()
        {
            return this.colors[2];
        },

        set: function (value)
        {
            this.colors[2] = value;
        }

    },

    setTopLeft: function (x, y)
    {
        this.topLeftX = x;
        this.topLeftY = y;

        return this;
    },

    setTopRight: function (x, y)
    {
        this.topRightX = x;
        this.topRightY = y;

        return this;
    },

    setBottomLeft: function (x, y)
    {
        this.bottomLeftX = x;
        this.bottomLeftY = y;

        return this;
    },

    setBottomRight: function (x, y)
    {
        this.bottomRightX = x;
        this.bottomRightY = y;

        return this;
    },

    resetPosition: function ()
    {
        var x = this.x;
        var y = this.y;
        var halfWidth = Math.floor(this.width / 2);
        var halfHeight = Math.floor(this.height / 2);

        this.setTopLeft(x - halfWidth, y - halfHeight);
        this.setTopRight(x + halfWidth, y - halfHeight);
        this.setBottomLeft(x - halfWidth, y + halfHeight);
        this.setBottomRight(x + halfWidth, y + halfHeight);

        return this;
    },

    resetAlpha: function ()
    {
        var alphas = this.alphas;

        alphas[0] = 1;
        alphas[1] = 1;
        alphas[2] = 1;
        alphas[3] = 1;

        return this;
    },

    resetColors: function ()
    {
        var colors = this.colors;

        colors[0] = 0xffffff;
        colors[1] = 0xffffff;
        colors[2] = 0xffffff;
        colors[3] = 0xffffff;

        return this;
    },

    reset: function ()
    {
        this.resetPosition();
        this.resetAlpha();
        this.resetColors();
    }

});

module.exports = Quad;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

// RenderPass Will only work with Sprite and Image GameObjects.

var Class = __webpack_require__(0);
var GameObject = __webpack_require__(1);
var Components = __webpack_require__(8);
var Render = __webpack_require__(524);
var TexturedAndNormalizedTintedShader = __webpack_require__(43);

//   RenderPass - the user has a higher control on the rendering since you explicitly
//   indicate what is rendered. RenderPass also has a render target but the difference
//   is that when explicitly rendering an object to the render pass the shader from that
//   render pass is applied. This is useful for additive passes and specific object effects.

var RenderPass = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.ScrollFactor,
        Components.Size,
        Components.Tint,
        Components.Transform,
        Components.Visible,
        Render
    ],

    initialize:

    function RenderPass (scene, x, y, width, height, shaderName, fragmentShader)
    {
        GameObject.call(this, scene, 'RenderPass');
       
        var resourceManager = scene.sys.game.renderer.resourceManager;
        var pot = ((width & (width - 1)) == 0 && (height & (height - 1)) == 0);
        var gl;
        var wrap;
        
        this.renderer = scene.sys.game.renderer;
        this.passRenderTarget = null;
        this.renderTexture = null;
        this.passShader = null;
        this.uniforms = {};
        this.textures = {};

        if (resourceManager !== undefined)
        {
            gl = scene.sys.game.renderer.gl;
            wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;
            this.passShader = resourceManager.createShader(shaderName, {vert: TexturedAndNormalizedTintedShader.vert, frag: fragmentShader});
            this.renderTexture = resourceManager.createTexture(0, gl.LINEAR, gl.LINEAR, wrap, wrap, gl.RGBA, null, width, height);
            this.passRenderTarget = resourceManager.createRenderTarget(width, height, this.renderTexture, null);
            scene.sys.game.renderer.currentTexture[0] = null; // force rebinding of prev texture
        }

        this.flipY = true;
        this.setPosition(x, y);
        this.setSize(width, height);
        this.setOrigin(0, 0);

        var _this = this;
        scene.sys.game.renderer.addContextRestoredCallback(function (renderer) {
            var gl = renderer.gl;
            var wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;
            _this.passShader = resourceManager.createShader(shaderName, {vert: TexturedAndNormalizedTintedShader.vert, frag: fragmentShader});
            _this.renderTexture = resourceManager.createTexture(0, gl.LINEAR, gl.LINEAR, wrap, wrap, gl.RGBA, null, _this.width, _this.height);
            _this.passRenderTarget = resourceManager.createRenderTarget(_this.width, _this.height, _this.renderTexture, null);
            _this.uniforms = {};
            _this.textures = {};
            scene.sys.game.renderer.currentTexture[0] = null; // force rebinding of prev texture
        });
    },

    clearColorBuffer: function (r, g, b, a)
    {
        var gl = this.renderer.gl;

        if (gl)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.passRenderTarget.framebufferObject);
            gl.clearColor(r, g, b, a);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    clearDepthStencilBuffers: function (depth, stencil)
    {
        var gl = this.renderer.gl;

        if (gl)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.passRenderTarget.framebufferObject);
            gl.clearDepth(depth);
            gl.clearStencil(stencil);
            gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    clearAllBuffers: function (r, g, b, a, depth, stencil)
    {
        var gl = this.renderer.gl;

        if (gl)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.passRenderTarget.framebufferObject);
            gl.clearColor(r, g, b, a);
            gl.clearDepth(depth);
            gl.clearStencil(stencil);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    render: function (gameObject, camera)
    {
        var renderer = this.renderer;
        var gl = renderer.gl;

        if (gl && !renderer.contextLost)
        {
            renderer.setRenderer(this.renderer.spriteBatch, null, null);
            renderer.spriteBatch.addSprite(gameObject, camera);
            for (var key in this.textures)
            {
                var textureData = this.textures[key];
                this.setInt(key, textureData.unit);
                gl.activeTexture(gl.TEXTURE0 + textureData.unit);
                gl.bindTexture(gl.TEXTURE_2D, textureData.texture);
                gl.activeTexture(gl.TEXTURE0);
            }
            renderer.spriteBatch.flush(this.passShader, this.passRenderTarget.framebufferObject);
        }
    },

    renderRect: function (x, y, width, height, camera)
    {
        var renderer = this.renderer;
        var gl = renderer.gl;

        if (gl && !renderer.contextLost)
        {
            renderer.setRenderer(this.renderer.spriteBatch, null, null);
            renderer.spriteBatch.addTileTextureRect(
                null, x, y, width, height, 1.0, 0xFFFFFFFF, this.scrollFactorX, this.scrollFactorY,
                width, height, 0, 0, width, height, camera, null
            );
            for (var key in this.textures)
            {
                var textureData = this.textures[key];
                this.setInt(key, textureData.unit);
                gl.activeTexture(gl.TEXTURE0 + textureData.unit);
                gl.bindTexture(gl.TEXTURE_2D, textureData.texture);
                gl.activeTexture(gl.TEXTURE0);
            }
            renderer.spriteBatch.flush(this.passShader, this.passRenderTarget.framebufferObject);
        }
    },

    setRenderTextureAt: function (renderTexture, samplerName, unit)
    {
        var renderer = this.renderer;
        var gl = renderer.gl;

        if (gl && !renderer.contextLost)
        {
            /* Texture 1 is reserved for Phasers Main Renderer */
            unit = (unit > 0) ? unit : 1;
            this.textures[samplerName] = { texture: renderTexture.texture, unit: unit };
            //this.setInt(samplerName, unit);
            //gl.activeTexture(gl.TEXTURE0 + unit);
            //gl.bindTexture(gl.TEXTURE_2D, renderTexture.texture);
            //gl.activeTexture(gl.TEXTURE0);
        }
    },

    getUniformLocation: function (uniformName)
    {
        var passShader = this.passShader;
        var uniforms = this.uniforms;
        var location;

        if (uniformName in uniforms)
        {
            location = uniforms[uniformName];
        }
        else
        {
            location = passShader.getUniformLocation(uniformName);
            uniforms[uniformName] = location;
        }

        return location;
    },

    setFloat: function (uniformName, x)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantFloat1(this.getUniformLocation(uniformName), x);
    },

    setFloat2: function (uniformName, x, y)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantFloat2(this.getUniformLocation(uniformName), x, y);
    },

    setFloat3: function (uniformName, x, y, z)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantFloat3(this.getUniformLocation(uniformName), x, y, z);
    },

    setFloat4: function (uniformName, x, y, z, w)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantFloat4(this.getUniformLocation(uniformName), x, y, z, w);
    },

    setInt: function (uniformName, x)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantInt1(this.getUniformLocation(uniformName), x);
    },

    setInt2: function (uniformName, x, y)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantInt2(this.getUniformLocation(uniformName), x, y);
    },

    setInt3: function (uniformName, x, y, z)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantInt3(this.getUniformLocation(uniformName), x, y, z);
    },

    setInt4: function (uniformName, x, y, z, w)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantInt4(this.getUniformLocation(uniformName), x, y, z, w);
    },

    setMatrix2x2: function (uniformName, matrix)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantMatrix2x2(this.getUniformLocation(uniformName), matrix);
    },

    setMatrix3x3: function (uniformName, matrix)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantMatrix3x3(this.getUniformLocation(uniformName), matrix);
    },

    setMatrix4x4: function (uniformName, matrix)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantMatrix4x4(this.getUniformLocation(uniformName), matrix);
    }

});

module.exports = RenderPass;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var GameObject = __webpack_require__(1);
var Components = __webpack_require__(8);
var CanvasPool = __webpack_require__(15);
var TextRender = __webpack_require__(539);
var TextStyle = __webpack_require__(535);
var GetTextSize = __webpack_require__(533);

var Text = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.ScrollFactor,
        Components.Tint,
        Components.Transform,
        Components.Visible,
        TextRender
    ],

    initialize:

    function Text (scene, x, y, text, style)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (text === undefined) { text = ' '; }

        GameObject.call(this, scene, 'Text');

        this.setPosition(x, y);
        this.setOrigin(0, 0);

        /**
         * @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
         */
        this.canvas = CanvasPool.create(this);

        /**
         * @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
         */
        this.context = this.canvas.getContext('2d');

        this.style = new TextStyle(this, style);

        this.autoRound = true;

        /**
         * The Regular Expression that is used to split the text up into lines, in
         * multi-line text. By default this is `/(?:\r\n|\r|\n)/`.
         * You can change this RegExp to be anything else that you may need.
         * @property {Object} splitRegExp
         */
        this.splitRegExp = /(?:\r\n|\r|\n)/;

        this.text = (Array.isArray(text)) ? text.join('\n') : text;

        this.resolution = 1;

        /**
        * Specify a padding value which is added to the line width and height when calculating the Text size.
        * Allows you to add extra spacing if Phaser is unable to accurately determine the true font dimensions.
        * @property {Phaser.Point} padding
        */
        this.padding = { x: 0, y: 0 };

        this.width = 1;
        this.height = 1;

        this.canvasTexture = null;
        this.dirty = false;

        if (text !== '')
        {
            this.updateText();
        }

        var _this = this;
        scene.sys.game.renderer.addContextRestoredCallback(function (renderer) {
            _this.canvasTexture = null;
            _this.dirty = true;
        });
    },

    setText: function (value)
    {
        if (Array.isArray(value))
        {
            value = value.join('\n');
        }

        if (value !== this.text)
        {
            this.text = value.toString();

            this.updateText();
        }

        return this;
    },

    setStyle: function (style)
    {
        return this.style.setStyle(style);
    },

    setFont: function (font)
    {
        return this.style.setFont(font);
    },

    setFixedSize: function (width, height)
    {
        return this.style.setFixedSize(width, height);
    },

    setBackgroundColor: function (color)
    {
        return this.style.setBackgroundColor(color);
    },

    setFill: function (color)
    {
        return this.style.setFill(color);
    },

    setStroke: function (color, thickness)
    {
        return this.style.setStroke(color, thickness);
    },

    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)
    {
        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
    },

    setShadowOffset: function (x, y)
    {
        return this.style.setShadowOffset(x, y);
    },

    setShadowColor: function (color)
    {
        return this.style.setShadowColor(color);
    },

    setShadowBlur: function (blur)
    {
        return this.style.setShadowBlur(blur);
    },

    setShadowStroke: function (enabled)
    {
        return this.style.setShadowStroke(enabled);
    },

    setShadowFill: function (enabled)
    {
        return this.style.setShadowFill(enabled);
    },

    setAlign: function (align)
    {
        return this.style.setAlign(align);
    },

    setMaxLines: function (max)
    {
        return this.style.setMaxLines(max);
    },

    updateText: function ()
    {
        var canvas = this.canvas;
        var context = this.context;
        var style = this.style;
        var size = style.metrics;

        var outputText = this.text;

        // if (style.wordWrap)
        // {
        //     outputText = this.runWordWrap(this.text);
        // }

        //  Split text into lines
        var lines = outputText.split(this.splitRegExp);

        var textSize = GetTextSize(this, size, lines);

        if (!style.fixedWidth)
        {
            this.width = textSize.width;
        }

        if (!style.fixedHeight)
        {
            this.height = textSize.height;
        }

        this.updateOrigin();

        var padding = this.padding;

        var w = (textSize.width + (padding.x * 2)) * this.resolution;
        var h = (textSize.height + (padding.y * 2)) * this.resolution;

        if (canvas.width !== w || canvas.height !== h)
        {
            canvas.width = w;
            canvas.height = h;
        }
        else
        {
            context.clearRect(0, 0, w, h);
        }

        if (style.backgroundColor)
        {
            context.fillStyle = style.backgroundColor;
            context.fillRect(0, 0, w, h);
        }

        style.syncFont(canvas, context);

        context.textBaseline = 'alphabetic';

        //  Apply padding
        context.translate(padding.x, padding.y);

        var linePositionX;
        var linePositionY;

        //  Draw text line by line
        for (var i = 0; i < textSize.lines; i++)
        {
            linePositionX = style.strokeThickness / 2;
            linePositionY = (style.strokeThickness / 2 + i * textSize.lineHeight) + size.ascent;

            if (i > 0)
            {
                linePositionY += (textSize.lineSpacing * i);
            }

            if (style.align === 'right')
            {
                linePositionX += textSize.width - textSize.lineWidths[i];
            }
            else if (style.align === 'center')
            {
                linePositionX += (textSize.width - textSize.lineWidths[i]) / 2;
            }

            if (this.autoRound)
            {
                linePositionX = Math.round(linePositionX);
                linePositionY = Math.round(linePositionY);
            }

            if (style.strokeThickness)
            {
                this.style.syncShadow(context, style.shadowStroke);

                context.strokeText(lines[i], linePositionX, linePositionY);
            }

            if (style.fill)
            {
                this.style.syncShadow(context, style.shadowFill);

                context.fillText(lines[i], linePositionX, linePositionY);
            }
        }

        this.dirty = true;

        return this;
    },

    getTextMetrics: function ()
    {
        return this.style.getTextMetrics();
    },

    toJSON: function ()
    {
        var out = Components.ToJSON(this);

        //  Extra Text data is added here

        var data = {
            autoRound: this.autoRound,
            text: this.text,
            style: this.style.toJSON(),
            resolution: this.resolution,
            padding: {
                x: this.padding.x,
                y: this.padding.y
            }
        };

        out.data = data;

        return out;
    }
});

module.exports = Text;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GameObject = __webpack_require__(1);
var Components = __webpack_require__(8);
var TilemapRender = __webpack_require__(545);
var Tile = __webpack_require__(541);

var Tilemap = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        TilemapRender
    ],

    initialize:

    function Tilemap (scene, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, tileBorder, texture, frame)
    {
        GameObject.call(this, scene, 'Tilemap');

        this.mapData = (mapData !== null) ? new Uint32Array(mapData) : new Uint32Array(mapWidth * mapHeight);
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.mapWidth = mapWidth;
        this.mapHeight = mapHeight;
        this.tileArray = [];
        this.culledTiles = [];
        this.tileBorder = tileBorder;
        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
        this.setSize(tileWidth * mapWidth, tileHeight * mapHeight);
        this.buildTilemap(!!scene.sys.game.renderer.gl);
    },

    getTotalTileCount: function ()
    {
        return this.tileArray.length;
    },

    getVisibleTileCount: function (camera)
    {
        return this.cull(camera).length;
    },

    buildTilemap: function (center)
    {
        var tileArray = this.tileArray;
        var mapData = this.mapData;
        var border = this.tileBorder;
        var tileWidth = this.tileWidth;
        var tileHeight = this.tileHeight;
        var tileWidthBorder = tileWidth + border * 2;
        var tileHeightBorder = tileHeight + border * 2;
        var width = this.texture.source[0].width;
        var height = this.texture.source[0].height;
        var mapWidth = this.mapWidth;
        var mapHeight = this.mapHeight;
        var setWidth = width / tileWidth;
        var tileWidthBorderHalf = tileWidthBorder * 0.5;
        var tileHeightBorderHalf = tileHeightBorder * 0.5;

        if (!center)
        {
            tileWidthBorderHalf = 0;
            tileHeightBorderHalf = 0;
        }

        tileArray.length = 0;

        for (var y = 0; y < mapHeight; ++y)
        {
            for (var x = 0; x < mapWidth; ++x)
            {
                var tileId = mapData[y * mapWidth + x];
                var rectx = (((tileId % setWidth)|0) * tileWidthBorder) + tileWidthBorderHalf;
                var recty = (((tileId / setWidth)|0) * tileHeightBorder) + tileHeightBorderHalf;
                var tx = x * tileWidth;
                var ty = y * tileHeight;

                tileArray.push(new Tile({
                    index: x + y,
                    id: tileId,
                    x: tx,
                    y: ty,
                    width: tileWidth,
                    height: tileHeight,
                    frameX: rectx,
                    frameY: recty,
                    frameWidth: tileWidth,
                    frameHeight: tileHeight,
                    textureWidth: width,
                    textureHeight: height,
                    border: border,
                    center: center
                }));
            }
        }
    },

    cull: function (camera)
    {
        var culledTiles = this.culledTiles;
        var tiles = this.tileArray;
        var length = tiles.length;
        var scrollX = camera.scrollX * this.scrollFactorX;
        var scrollY = camera.scrollY * this.scrollFactorY;
        var cameraW = camera.width;
        var cameraH = camera.height;

        culledTiles.length = 0;

        for (var index = 0; index < length; ++index)
        {
            var tile = tiles[index];
            var tileX = tile.x - scrollX;
            var tileY = tile.y - scrollY;
            var tileW = tile.width;
            var tileH = tile.height;
            var cullW = cameraW + tileW;
            var cullH = cameraH + tileH;

            if (tile.visible &&
                tileX > -tileW && tileY > -tileH &&
                tileX < cullW && tileY < cullH)
            {
                culledTiles.push(tile);
            }
        }

        return culledTiles;
    },

    forEach: function (callback)
    {
        this.tileArray.forEach(callback);
    },

    //  Returns Object containing:
    //  {
    //      alpha
    //      frameWidth,
    //      frameHeight,
    //      frameX
    //      frameY
    //      id
    //      index = the tile in the tilset to render
    //      textureWidth = tileset texture size
    //      textureHeight
    //      tint
    //      visible
    //      width
    //      x
    //      y
    //  }

    getTileAt: function (x, y)
    {
        var ix = (x|0);
        var iy = (y|0);
        var tiles = this.tileArray;
        var index = iy * this.mapWidth + ix;

        if (index < tiles.length)
        {
            return tiles[index];
        }

        return null;
    },

    getTileAtIndex: function (index)
    {
        var tiles = this.tileArray;

        if (index < tiles.length)
        {
            return tiles[index];
        }

        return null;
    }

});

module.exports = Tilemap;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GameObject = __webpack_require__(1);
var Components = __webpack_require__(8);
var StaticTilemapRender = __webpack_require__(550);
var CONST = __webpack_require__(230);

var StaticTilemap = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        StaticTilemapRender
    ],

    initialize:

    function StaticTilemap (scene, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, tileBorder, texture, frame)
    {
        GameObject.call(this, scene, 'StaticTilemap');

        this.vbo = null;
        this.gl = scene.sys.game.renderer.gl ? scene.sys.game.renderer.gl : null;
        this.tilemapRenderer = scene.sys.game.renderer.tilemapRenderer ? scene.sys.game.renderer.tilemapRenderer : null;
        this.resourceManager = this.gl ? scene.sys.game.renderer.resourceManager : null;
        this.bufferData = null;
        this.mapData = mapData;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.mapWidth = mapWidth;
        this.mapHeight = mapHeight;
        this.dirty = true;
        this.vertexCount = 0;
        this.cullStart = 0;
        this.cullEnd = 0;
        this.tileBorder = tileBorder;
        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
        this.setSize(tileWidth * mapWidth, tileHeight * mapHeight);
        
        var _this = this;
        scene.sys.game.renderer.addContextRestoredCallback(function (renderer) {
            _this.tileTexture = null;
            _this.dirty = true;
            _this.vbo = null;
            _this.gl = renderer.gl;
            _this.tilemapRenderer = renderer.tilemapRenderer;
        });
    },

    upload: function (camera) 
    {
        if (this.gl)
        {
            if (this.dirty)
            {
                var gl = this.gl;
                var vbo = this.vbo;
                var mapWidth = this.mapWidth;
                var mapHeight = this.mapHeight;
                var border = this.tileBorder;
                var tileWidth = this.tileWidth;
                var tileHeight = this.tileHeight;
                var tileWidthBorder = tileWidth + border * 2;
                var tileHeightBorder = tileHeight + border * 2;
                var bufferData = this.bufferData;
                var bufferF32, bufferU32;
                var voffset = 0;
                var vertexCount = 0;
                var width = this.texture.source[0].width;
                var height = this.texture.source[0].height;
                var setWidth = width / tileWidth;
                var mapData = this.mapData;

                if (this.vbo === null)
                {
                    vbo = this.resourceManager.createBuffer(gl.ARRAY_BUFFER, (4 * 6 * (mapWidth * mapHeight)) * 4, gl.STATIC_DRAW);
                    vbo.addAttribute(this.tilemapRenderer.shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
                    vbo.addAttribute(this.tilemapRenderer.shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
                    bufferData = this.bufferData = new ArrayBuffer((4 * 6 * (mapWidth * mapHeight)) * 4);
                    this.vbo = vbo;
                    vbo.bind();
                }

                bufferF32 = new Float32Array(bufferData);

                for (var y = 0; y < mapHeight; ++y)
                {
                    for (var x = 0; x < mapWidth; ++x)
                    {
                        var tileId = mapData[y * mapWidth + x];
                        var halfTileWidth = (tileWidthBorder) * 0.5;
                        var halfTileHeight = (tileHeightBorder) * 0.5;
                        var rectx = (((tileId % setWidth)|0) * tileWidthBorder) + halfTileWidth;
                        var recty = (((tileId / setWidth)|0) * tileHeightBorder) + halfTileHeight;
                        var tx = x * tileWidth;
                        var ty = y * tileHeight;
                        var txw = tx + tileWidth;
                        var tyh = ty + tileHeight;
                        var u0 = (rectx - (halfTileWidth - 0.5)) / width;
                        var v0 = (recty - (halfTileHeight - 0.5)) / height;
                        var u1 = (rectx + (halfTileWidth - 0.5)) / width;
                        var v1 = (recty + (halfTileHeight - 0.5)) / height;
                        var tx0 = tx;
                        var ty0 = ty;
                        var tx1 = tx;
                        var ty1 = tyh;
                        var tx2 = txw;
                        var ty2 = tyh;
                        var tx3 = txw;
                        var ty3 = ty;

                        bufferF32[voffset + 0] = tx0;
                        bufferF32[voffset + 1] = ty0;
                        bufferF32[voffset + 2] = u0;
                        bufferF32[voffset + 3] = v0;

                        bufferF32[voffset + 4] = tx1;
                        bufferF32[voffset + 5] = ty1;
                        bufferF32[voffset + 6] = u0;
                        bufferF32[voffset + 7] = v1;

                        bufferF32[voffset + 8] = tx2;
                        bufferF32[voffset + 9] = ty2;
                        bufferF32[voffset + 10] = u1;
                        bufferF32[voffset + 11] = v1;

                        bufferF32[voffset + 12] = tx0;
                        bufferF32[voffset + 13] = ty0;
                        bufferF32[voffset + 14] = u0;
                        bufferF32[voffset + 15] = v0;

                        bufferF32[voffset + 16] = tx2;
                        bufferF32[voffset + 17] = ty2;
                        bufferF32[voffset + 18] = u1;
                        bufferF32[voffset + 19] = v1;

                        bufferF32[voffset + 20] = tx3;
                        bufferF32[voffset + 21] = ty3;
                        bufferF32[voffset + 22] = u1;
                        bufferF32[voffset + 23] = v0;
                        
                        voffset += 24;
                        vertexCount += 6;
                    }
                }
                this.vertexCount = vertexCount;
                vbo.updateResource(bufferData, 0);

                this.dirty = false;
            }
            this.tilemapRenderer.shader.setConstantFloat2(this.tilemapRenderer.scrollLocation, -camera.scrollX, -camera.scrollY);
            this.tilemapRenderer.shader.setConstantFloat2(this.tilemapRenderer.scrollFactorLocation, this.scrollFactorX, this.scrollFactorY);
            this.tilemapRenderer.shader.setConstantFloat2(this.tilemapRenderer.tilemapPositionLocation, this.x, this.y);
        }
        else if (this.dirty && !this.gl)
        {
            var mapWidth = this.mapWidth;
            var mapHeight = this.mapHeight;
            var border = this.tileBorder;
            var tileWidth = this.tileWidth;
            var tileHeight = this.tileHeight;
            var tileWidthBorder = tileWidth + border * 2;
            var tileHeightBorder = tileHeight + border * 2;
            var width = this.texture.source[0].width;
            var height = this.texture.source[0].height;
            var setWidth = width / tileWidth;
            var mapData = this.mapData;

            this.tiles = [];

            for (var y = 0; y < mapHeight; ++y)
            {
                for (var x = 0; x < mapWidth; ++x)
                {
                    var tileId = mapData[y * mapWidth + x];
                    var frameX = (((tileId % setWidth)|0) * tileWidthBorder);
                    var frameY = (((tileId / setWidth)|0) * tileHeightBorder);
                    var tx = x * tileWidth;
                    var ty = y * tileHeight;

                    this.tiles.push({
                        x: tx,
                        y: ty,
                        frameX: frameX,
                        frameY: frameY
                    });

                }
            }

            this.dirty = false;
        }
    },

    getTotalTileCount: function ()
    {
        return this.mapData.length;
    },

    getVisibleTileCount: function (camera)
    {
        this.cull(camera);
        return (this.cullEnd - this.cullStart) / 6;
    },

    cull: function (camera)
    {
        this.cullStart = 0;
        this.cullEnd = 0;
        var tileWidth = this.tileWidth;
        var tileHeight = this.tileHeight;
        var pixelX = this.x - (camera.scrollX * this.scrollFactorX);
        var pixelY = this.y - (camera.scrollY * this.scrollFactorY);
        var pixelWidth = this.mapWidth * tileWidth;
        var pixelHeight = this.mapHeight * tileHeight;

        if (pixelX < camera.x + camera.width + (tileWidth * 2) &&
            pixelX + pixelWidth > camera.x + -(tileWidth * 2) &&
            pixelY < camera.y + camera.height + (tileHeight * 2) &&
            pixelY + pixelHeight > camera.y + -(tileHeight * 2))
        {
            var interX = Math.max(pixelX, camera.x + -(tileWidth * 2));
            var interY = Math.max(pixelY, camera.y + -(tileHeight * 2));
            var interWidth = Math.min(pixelX + pixelWidth, camera.x + camera.width + (tileWidth * 2)) - interX;
            var interHeight = Math.min(pixelY + pixelHeight, camera.y + camera.height + (tileHeight * 2)) - interY;

            interX = ((interX + (camera.scrollX * this.scrollFactorX)) / tileWidth)|0;
            interY = ((interY + (camera.scrollY * this.scrollFactorY)) / tileHeight)|0;
            interWidth = (interWidth / tileWidth)|0;
            interHeight = (interHeight / tileHeight)|0;

            this.cullStart = (interY * this.mapWidth + interX) * 6;
            this.cullEnd = ((interY + interHeight) * this.mapWidth + interX) * 6;
        }
    }

});

module.exports = StaticTilemap;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(15);
var Class = __webpack_require__(0);
var Components = __webpack_require__(8);
var GameObject = __webpack_require__(1);
var GetPowerOfTwo = __webpack_require__(226);
var TileSpriteRender = __webpack_require__(555);

var TileSprite = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.ScrollFactor,
        Components.Size,
        Components.Texture,
        Components.Tint,
        Components.Transform,
        Components.Visible,
        TileSpriteRender
    ],

    initialize:

    function TileSprite (scene, x, y, width, height, texture, frame)
    {
        var resourceManager = scene.sys.game.renderer.resourceManager;

        GameObject.call(this, scene, 'TileSprite');

        this.tilePositionX = 0;
        this.tilePositionY = 0;
        this.dirty = true;
        this.tileTexture = null;
        this.renderer = null;

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSize(width, height);
        this.setOrigin();

        this.potWidth = GetPowerOfTwo(this.frame.width);
        this.potHeight = GetPowerOfTwo(this.frame.height);
        this.canvasPattern = null;

        if (resourceManager)
        {
            this.renderer = scene.sys.game.renderer;
            var gl = scene.sys.game.renderer.gl;

            this.tileTexture = resourceManager.createTexture(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.canvasBuffer, this.potWidth, this.potHeight);
        }

        this.canvasBuffer = CanvasPool.create2D(null, this.potWidth, this.potHeight);
        this.canvasBufferCtx = this.canvasBuffer.getContext('2d');

        this.updateTileTexture();

        var _this = this;
        scene.sys.game.renderer.addContextRestoredCallback(function (renderer) {
            _this.tileTexture = null;
            _this.dirty = true;
            _this.tileTexture = resourceManager.createTexture(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, _this.canvasBuffer, _this.potWidth, _this.potHeight);
        });
    },

    updateTileTexture: function ()
    {
        if (!this.dirty)
        {
            return;
        }

        this.canvasBufferCtx.drawImage(
            this.frame.source.image,
            this.frame.cutX, this.frame.cutY,
            this.frame.cutWidth, this.frame.cutHeight,
            0, 0,
            this.potWidth, this.potHeight
        );

        if (this.renderer)
        {
            this.renderer.uploadCanvasToGPU(this.canvasBuffer, this.tileTexture, false);
        }
        else
        {
            this.canvasPattern = this.canvasBufferCtx.createPattern(this.canvasBuffer, 'repeat');
        }

        this.dirty = false;
    },

    destroy: function ()
    {
        if (this.renderer)
        {
            this.renderer.gl.deleteTexture(this.tileTexture);
        }

        CanvasPool.remove(this.canvasBuffer);

        this.canvasPattern = null;
        this.canvasBufferCtx = null;
        this.canvasBuffer = null;

        this.renderer = null;
        this.visible = false;
    }

});

module.exports = TileSprite;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var Ellipse = new Class({

    initialize:

    function Ellipse (x, y, width, height)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (width === undefined) { width = 0; }
        if (height === undefined) { height = 0; }

        this.x = x;

        this.y = y;

        this.width = width;

        this.height = height;
    },

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    },

    //  AKA Semi Minor Axis
    getMinorRadius: function ()
    {
        return Math.min(this.width, this.height) / 2;
    },

    //  AKA Semi Major Axis
    getMajorRadius: function ()
    {
        return Math.max(this.width, this.height) / 2;
    },

    left: {

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Ellipse;


/***/ }),
/* 94 */
/***/ (function(module, exports) {

/**
* Using Bresenham's line algorithm this will return an array of all coordinates on this line.
* The start and end points are rounded before this runs as the algorithm works on integers.
*/
var GetPointsOnLine = function (line, stepRate, results)
{
    if (stepRate === undefined) { stepRate = 1; }
    if (results === undefined) { results = []; }

    var x1 = Math.round(line.x1);
    var y1 = Math.round(line.y1);
    var x2 = Math.round(line.x2);
    var y2 = Math.round(line.y2);

    var dx = Math.abs(x2 - x1);
    var dy = Math.abs(y2 - y1);
    var sx = (x1 < x2) ? 1 : -1;
    var sy = (y1 < y2) ? 1 : -1;
    var err = dx - dy;

    results.push([ x1, y1 ]);

    var i = 1;

    while (!((x1 === x2) && (y1 === y2)))
    {
        var e2 = err << 1;

        if (e2 > -dy)
        {
            err -= dy;
            x1 += sx;
        }

        if (e2 < dx)
        {
            err += dx;
            y1 += sy;
        }

        if (i % stepRate === 0)
        {
            results.push([ x1, y1 ]);
        }

        i++;
    }

    return results;
};

module.exports = GetPointsOnLine;


/***/ }),
/* 95 */
/***/ (function(module, exports) {


var RotateAroundXY = function (line, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = line.x1 - x;
    var ty = line.y1 - y;

    line.x1 = tx * c - ty * s + x;
    line.y1 = tx * s + ty * c + y;

    tx = line.x2 - x;
    ty = line.y2 - y;

    line.x2 = tx * c - ty * s + x;
    line.y2 = tx * s + ty * c + y;

    return line;
};

module.exports = RotateAroundXY;


/***/ }),
/* 96 */
/***/ (function(module, exports) {

var Dot = function (pointA, pointB)
{
    return ((pointA.x * pointB.x) + (pointA.y * pointB.y));
};

module.exports = Dot;


/***/ }),
/* 97 */
/***/ (function(module, exports) {

var GetAspectRatio = function (rect)
{
    return (rect.height === 0) ? NaN : rect.width / rect.height;
};

module.exports = GetAspectRatio;


/***/ }),
/* 98 */
/***/ (function(module, exports) {

//  http://www.blackpawn.com/texts/pointinpoly/

//  points is an array of Point-like objects with public x/y properties
//  returns an array containing all points that are within the triangle, or an empty array if none
//  if 'returnFirst' is true it will return after the first point within the triangle is found

var ContainsArray = function (triangle, points, returnFirst, out)
{
    if (returnFirst === undefined) { returnFirst = false; }
    if (out === undefined) { out = []; }

    var v0x = triangle.x3 - triangle.x1;
    var v0y = triangle.y3 - triangle.y1;

    var v1x = triangle.x2 - triangle.x1;
    var v1y = triangle.y2 - triangle.y1;

    var dot00 = (v0x * v0x) + (v0y * v0y);
    var dot01 = (v0x * v1x) + (v0y * v1y);
    var dot11 = (v1x * v1x) + (v1y * v1y);

    // Compute barycentric coordinates
    var b = ((dot00 * dot11) - (dot01 * dot01));
    var inv = (b === 0) ? 0 : (1 / b);

    var u;
    var v;
    var v2x;
    var v2y;
    var dot02;
    var dot12;

    var x1 = triangle.x1;
    var y1 = triangle.y1;

    for (var i = 0; i < points.length; i++)
    {
        v2x = points[i].x - x1;
        v2y = points[i].y - y1;

        dot02 = (v0x * v2x) + (v0y * v2y);
        dot12 = (v1x * v2x) + (v1y * v2y);

        u = ((dot11 * dot02) - (dot01 * dot12)) * inv;
        v = ((dot00 * dot12) - (dot01 * dot02)) * inv;
    
        if (u >= 0 && v >= 0 && (u + v < 1))
        {
            out.push({ x: points[i].x, y: points[i].y });

            if (returnFirst)
            {
                break;
            }
        }
    }

    return out;
};

module.exports = ContainsArray;


/***/ }),
/* 99 */
/***/ (function(module, exports) {


var RotateAroundXY = function (triangle, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = triangle.x1 - x;
    var ty = triangle.y1 - y;

    triangle.x1 = tx * c - ty * s + x;
    triangle.y1 = tx * s + ty * c + y;

    tx = triangle.x2 - x;
    ty = triangle.y2 - y;

    triangle.x2 = tx * c - ty * s + x;
    triangle.y2 = tx * s + ty * c + y;

    tx = triangle.x3 - x;
    ty = triangle.y3 - y;

    triangle.x3 = tx * c - ty * s + x;
    triangle.y3 = tx * s + ty * c + y;

    return triangle;
};

module.exports = RotateAroundXY;


/***/ }),
/* 100 */
/***/ (function(module, exports) {

/**
 * Given 3 color values this will return an integer representation of it.
 */
var GetColor = function (red, green, blue)
{
    return red << 16 | green << 8 | blue;
};

module.exports = GetColor;


/***/ }),
/* 101 */
/***/ (function(module, exports) {

/**
* This will return the local coordinates of the specified displayObject based on the given Pointer.
*/
var GetTransformedPoint = function (matrix, gameObject, x, y, output)
{
    if (output === undefined) { output = { x: 0, y: 0 }; }

    matrix.applyITRS(gameObject.x, gameObject.y, -gameObject.rotation, gameObject.scaleX, gameObject.scaleY);

    matrix.invert();

    return matrix.transformPoint(x, y, output);
};

module.exports = GetTransformedPoint;


/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,

    SHIFT: 16,
    CTRL: 17,
    ALT: 18,

    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,

    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,

    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,

    PRINT_SCREEN: 42,
    INSERT: 45,
    DELETE: 46,

    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,

    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,

    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,

    SEMICOLON: 186,
    PLUS: 187,
    COMMA: 188,
    MINUS: 189,
    PERIOD: 190,
    FORWAD_SLASH: 191,
    BACK_SLASH: 220,
    QUOTES: 222
};


/***/ }),
/* 103 */
/***/ (function(module, exports) {

//  Creates an XHRSettings Object with default values

var XHRSettings = function (responseType, async, user, password, timeout)
{
    if (responseType === undefined) { responseType = ''; }
    if (async === undefined) { async = true; }
    if (user === undefined) { user = ''; }
    if (password === undefined) { password = ''; }
    if (timeout === undefined) { timeout = 0; }

    // Before sending a request, set the xhr.responseType to "text", 
    // "arraybuffer", "blob", or "document", depending on your data needs. 
    // Note, setting xhr.responseType = '' (or omitting) will default the response to "text".

    return {

        //  Ignored by the Loader, only used by File.
        responseType: responseType,

        async: async,

        //  credentials
        user: user,
        password: password,

        //  timeout in ms (0 = no timeout)
        timeout: timeout,

        //  setRequestHeader
        header: undefined,
        headerValue: undefined,

        //  overrideMimeType
        overrideMimeType: undefined

    };
    
};

module.exports = XHRSettings;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(16);
var File = __webpack_require__(19);
var GetFastValue = __webpack_require__(11);

//  Phaser.Loader.FileTypes.JSONFile

var JSONFile = new Class({

    Extends: File,

    initialize:

    function JSONFile (key, url, path, xhrSettings)
    {
        var fileKey = (typeof key === 'string') ? key : GetFastValue(key, 'key', '');

        var fileConfig = {
            type: 'json',
            extension: GetFastValue(key, 'extension', 'json'),
            responseType: 'text',
            key: fileKey,
            url: GetFastValue(key, 'file', url),
            path: path,
            xhrSettings: GetFastValue(key, 'xhr', xhrSettings)
        };

        File.call(this, fileConfig);
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.data = JSON.parse(this.xhrLoader.responseText);

        this.onComplete();

        callback(this);
    }

});

JSONFile.create = function (loader, key, url, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new JSONFile(key[i], url, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new JSONFile(key, url, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = JSONFile;


/***/ }),
/* 105 */
/***/ (function(module, exports) {

var CatmullRom = function (t, p0, p1, p2, p3)
{
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;

    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
};

module.exports = CatmullRom;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(13);

var DegToRad = function (degrees)
{
    return degrees * CONST.DEG_TO_RAD;
};

module.exports = DegToRad;


/***/ }),
/* 107 */
/***/ (function(module, exports) {

//  p = Point or any object with public x/y properties, the item to be rotated
//  x/y = the coordinate to rotate around
//  angle = radians
//  distance = in px

var RotateAroundDistance = function (point, x, y, angle, distance)
{
    var t = angle + Math.atan2(point.y - y, point.x - x);

    point.x = x + (distance * Math.cos(t));
    point.y = y + (distance * Math.sin(t));

    return point;
};

module.exports = RotateAroundDistance;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

/**
* Checks if the given dimensions make a power of two texture.
* 
* @param {number} width - The width to check.
* @param {number} height - The height to check.
* @return {boolean} True if the width and height are a power of two.
*/
var IsSizePowerOfTwo = function (width, height)
{
    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
};

module.exports = IsSizePowerOfTwo;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Physics.Impact.Body.Components

module.exports = {

    Acceleration: __webpack_require__(866),
    BodyScale: __webpack_require__(867),
    BodyType: __webpack_require__(868),
    Bounce: __webpack_require__(869),
    CheckAgainst: __webpack_require__(870),
    Collides: __webpack_require__(871),
    Debug: __webpack_require__(872),
    Friction: __webpack_require__(873),
    Gravity: __webpack_require__(874),
    Offset: __webpack_require__(875),
    SetGameObject: __webpack_require__(876),
    Velocity: __webpack_require__(877)

};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CurrentVertexBuffer = null;
var VertexBuffer = new Class({

    initialize:

    function VertexBuffer (gl, bufferObject)
    {
        this.gl = gl;
        this.bufferTarget = gl.ARRAY_BUFFER;
        this.bufferObject = bufferObject;
        this.attributes = [];
    },

    addAttribute: function (index, size, type, normalized, stride, offset)
    {
        this.attributes.push({
            index: index,
            size: size,
            type: type,
            normalized: normalized,
            stride: stride,
            offset: offset
        });

        return this;
    },

    updateResource: function (bufferData, offset)
    {
        var gl = this.gl;

        if (CurrentVertexBuffer !== this)
        {
            CurrentVertexBuffer = this;
            gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferObject);
        }
        gl.bufferSubData(gl.ARRAY_BUFFER, offset, bufferData);

        return this;
    },

    bind: function ()
    {
        var gl = this.gl;
        var bufferObject = this.bufferObject;
        var attributes = this.attributes;
        var attributesLength = attributes.length;

        if (CurrentVertexBuffer !== this)
        {
            CurrentVertexBuffer = this;
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferObject);
    
            for (var index = 0; index < attributesLength; ++index)
            {
                var element = attributes[index];
    
                if (element !== undefined && element !== null)
                {
                    gl.enableVertexAttribArray(element.index);
                    gl.vertexAttribPointer(
                        element.index,
                        element.size,
                        element.type,
                        element.normalized,
                        element.stride,
                        element.offset
                    );
                }
            }
        }

        return this;
    }
    
});

VertexBuffer.SetDirty = function () 
{
    CurrentVertexBuffer = null;
};

module.exports = VertexBuffer;


/***/ }),
/* 111 */
/***/ (function(module, exports) {

var SortScenes = function (sceneA, sceneB)
{
    //  Sort descending
    if (sceneA.index < sceneB.index)
    {
        return -1;
    }
    else if (sceneA.index > sceneB.index)
    {
        return 1;
    }
    else
    {
        return 0;
    }
};

module.exports = SortScenes;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);
var EventDispatcher = __webpack_require__(30);

/**
* The Data Component features a means to store pieces of data specific to a Game Object,
* search it, query it, and retrieve it.
*/
var Data = new Class({

    initialize:

    function Data (parent, eventDispatcher)
    {
        this.parent = parent;

        this.events = (eventDispatcher) ? eventDispatcher : new EventDispatcher();

        this.list = {};

        this._beforeCallbacks = {};
        this._afterCallbacks = {};

        this._frozen = false;
    },

    //  Retrieves the value for the given key, or undefined if it doesn't exist.
    get: function (key)
    {
        return this.list[key];
    },

    getAll: function ()
    {
        var results = {};

        for (var key in this.list)
        {
            results[key] = this.list[key];
        }

        return results;
    },

    query: function (search)
    {
        var results = {};

        for (var key in this.list)
        {
            if (key.match(search))
            {
                results[key] = this.list[key];
            }
        }

        return results;
    },

    set: function (key, data)
    {
        if (this._frozen)
        {
            return this;
        }

        var listener;
        var result;

        //  If there is a 'before' callback, then check it for a result
        //  This means a property can only ever have 1 callback, which isn't right - we may need more
        //  Dispatch event instead?
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            listener = this._beforeCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                data = result;
            }
        }

        // this.events.dispatch(new Event.LOADER_START_EVENT(this));

        this.list[key] = data;

        //  If there is a 'after' callback, then check it for a result
        if (this._afterCallbacks.hasOwnProperty(key))
        {
            listener = this._afterCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                this.list[key] = result;
            }
        }

        return this;
    },

    before: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._beforeCallbacks[key];
        }
        else
        {
            this._beforeCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    after: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._afterCallbacks[key];
        }
        else
        {
            this._afterCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    /**
    * Passes all data entries to the given callback. Stores the result of the callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [scope] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the game object, key, and data.
    */
    each: function (callback, scope)
    {
        var args = [ this.parent, null, undefined ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var key in this.list)
        {
            args[1] = key;
            args[2] = this.list[key];

            callback.apply(scope, args);
        }
    },

    merge: function (data, overwrite)
    {
        if (overwrite === undefined) { overwrite = true; }

        //  Merge data from another component into this one
        for (var key in data)
        {
            if (overwrite || (!overwrite && !this.has(key)))
            {
                this.list[key] = data;
            }
        }
    },

    remove: function (key)
    {
        if (!this._frozen && this.has(key))
        {
            delete this.list[key];

            this.removeListeners(key);
        }
    },

    removeListeners: function (key)
    {
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            delete this._beforeCallbacks[key];
        }

        if (this._afterCallbacks.hasOwnProperty(key))
        {
            delete this._afterCallbacks[key];
        }
    },

    //  Gets the data associated with the given 'key', deletes it from this Data store, then returns it.
    pop: function (key)
    {
        var data = undefined;

        if (!this._frozen && this.has(key))
        {
            data = this.list[key];

            delete this.list[key];

            this.removeListeners(key);
        }

        return data;
    },

    has: function (key)
    {
        return this.list.hasOwnProperty(key);
    },

    reset: function ()
    {
        for (var key in this.list)
        {
            delete this.list[key];
        }

        for (key in this._beforeCallbacks)
        {
            delete this._beforeCallbacks[key];
        }

        for (key in this._afterCallbacks)
        {
            delete this._afterCallbacks[key];
        }

        this._frozen = false;
    },

    destroy: function ()
    {
        this.reset();

        this.parent = null;

        this.events = null;
    },

    /**
    * Freeze this Data component, so no changes can be written to it.
    *
    * @name freeze
    * @property {boolean} freeze
    */
    freeze: {

        get: function ()
        {
            return this._frozen;
        },

        set: function (value)
        {
            this._frozen = (value) ? true : false;
        }

    },

    count: {

        get: function ()
        {
            var i = 0;

            for (var key in this.list)
            {
                if (this.list[key] !== undefined)
                {
                    i++;
                }
            }

            return i;
        }

    }

});

module.exports = Data;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var EaseMap = __webpack_require__(831);

var GetEaseFunction = function (ease, easeParams)
{
    if (typeof ease === 'string' && EaseMap.hasOwnProperty(ease))
    {
        if (easeParams)
        {
            var cloneParams = easeParams.slice(0);

            cloneParams.unshift(0);

            return function (v)
            {
                cloneParams[0] = v;

                return EaseMap[ease].apply(this, cloneParams);
            };
        }
        else
        {
            //  String based look-up
            return EaseMap[ease];
        }
    }
    else if (typeof ease === 'function')
    {
        //  Custom function
        return ease;
    }
    else if (Array.isArray(ease) && ease.length === 4)
    {
        //  Bezier function (TODO)
    }

    return EaseMap.Power0;
};

module.exports = GetEaseFunction;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var Defaults = __webpack_require__(238);
var GetAdvancedValue = __webpack_require__(7);
var GetBoolean = __webpack_require__(235);
var GetEaseFunction = __webpack_require__(113);
var GetNewValue = __webpack_require__(236);
var GetProps = __webpack_require__(987);
var GetTargets = __webpack_require__(237);
var GetValue = __webpack_require__(4);
var GetValueOp = __webpack_require__(989);
var Tween = __webpack_require__(1006);
var TweenData = __webpack_require__(1007);

var TweenBuilder = function (parent, config, defaults)
{
    if (defaults === undefined)
    {
        defaults = Defaults;
    }

    //  Create arrays of the Targets and the Properties
    var targets = (defaults.targets) ? defaults.targets : GetTargets(config);

    // var props = (defaults.props) ? defaults.props : GetProps(config);
    var props = GetProps(config);

    //  Default Tween values
    var delay = GetNewValue(config, 'delay', defaults.delay);
    var duration = GetNewValue(config, 'duration', defaults.duration);
    var easeParams = GetValue(config, 'easeParams', defaults.easeParams);
    var ease = GetEaseFunction(GetValue(config, 'ease', defaults.ease), easeParams);
    var hold = GetNewValue(config, 'hold', defaults.hold);
    var repeat = GetNewValue(config, 'repeat', defaults.repeat);
    var repeatDelay = GetNewValue(config, 'repeatDelay', defaults.repeatDelay);
    var yoyo = GetBoolean(config, 'yoyo', defaults.yoyo);
    var flipX = GetBoolean(config, 'flipX', defaults.flipX);
    var flipY = GetBoolean(config, 'flipY', defaults.flipY);

    var data = [];

    //  Loop through every property defined in the Tween, i.e.: props { x, y, alpha }
    for (var p = 0; p < props.length; p++)
    {
        var key = props[p].key;
        var value = props[p].value;

        //  Create 1 TweenData per target, per property
        for (var t = 0; t < targets.length; t++)
        {
            var ops = GetValueOp(key, value);

            var tweenData = TweenData(
                targets[t],
                key,
                ops.getEnd,
                ops.getStart,
                GetEaseFunction(GetValue(value, 'ease', ease), easeParams),
                GetNewValue(value, 'delay', delay),
                GetNewValue(value, 'duration', duration),
                GetBoolean(value, 'yoyo', yoyo),
                GetNewValue(value, 'hold', hold),
                GetNewValue(value, 'repeat', repeat),
                GetNewValue(value, 'repeatDelay', repeatDelay),
                GetBoolean(value, 'flipX', flipX),
                GetBoolean(value, 'flipY', flipY)
            );

            data.push(tweenData);
        }
    }

    var tween = new Tween(parent, data, targets);

    tween.offset = GetAdvancedValue(config, 'offset', null);
    tween.completeDelay = GetAdvancedValue(config, 'completeDelay', 0);
    tween.loop = Math.round(GetAdvancedValue(config, 'loop', 0));
    tween.loopDelay = Math.round(GetAdvancedValue(config, 'loopDelay', 0));
    tween.paused = GetBoolean(config, 'paused', false);
    tween.useFrames = GetBoolean(config, 'useFrames', false);

    //  Set the Callbacks
    var scope = GetValue(config, 'callbackScope', tween);

    //  Callback parameters: 0 = a reference to the Tween itself, 1 = the target/s of the Tween, ... your own params
    var tweenArray = [ tween, null ];

    var callbacks = Tween.TYPES;

    for (var i = 0; i < callbacks.length; i++)
    {
        var type = callbacks[i];

        var callback = GetValue(config, type, false);

        if (callback)
        {
            var callbackScope = GetValue(config, type + 'Scope', scope);
            var callbackParams = GetValue(config, type + 'Params', []);

            //  The null is reset to be the Tween target
            tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope);
        }
    }

    return tween;
};

module.exports = TweenBuilder;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

//  Creates a new Object using all values from obj1 and obj2.
//  If a value exists in both obj1 and obj2, the value in obj1 is used.

var Clone = __webpack_require__(72);

var Merge = function (obj1, obj2)
{
    var clone = Clone(obj1);

    for (var key in obj2)
    {
        if (!clone.hasOwnProperty(key))
        {
            clone[key] = obj2[key];
        }
    }

    return clone;
};

module.exports = Merge;


/***/ }),
/* 116 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Actions

module.exports = {

    Angle: __webpack_require__(277),
    Call: __webpack_require__(278),
    GetFirst: __webpack_require__(279),
    GridAlign: __webpack_require__(280),
    IncAlpha: __webpack_require__(281),
    IncX: __webpack_require__(282),
    IncXY: __webpack_require__(283),
    IncY: __webpack_require__(284),
    PlaceOnCircle: __webpack_require__(285),
    PlaceOnEllipse: __webpack_require__(286),
    PlaceOnLine: __webpack_require__(287),
    PlaceOnRectangle: __webpack_require__(288),
    PlaceOnTriangle: __webpack_require__(289),
    PlayAnimation: __webpack_require__(290),
    RandomCircle: __webpack_require__(291),
    RandomEllipse: __webpack_require__(292),
    RandomLine: __webpack_require__(293),
    RandomRectangle: __webpack_require__(294),
    RandomTriangle: __webpack_require__(295),
    Rotate: __webpack_require__(296),
    RotateAround: __webpack_require__(297),
    RotateAroundDistance: __webpack_require__(298),
    ScaleX: __webpack_require__(299),
    ScaleXY: __webpack_require__(300),
    ScaleY: __webpack_require__(301),
    SetAlpha: __webpack_require__(302),
    SetBlendMode: __webpack_require__(303),
    SetDepth: __webpack_require__(304),
    SetHitArea: __webpack_require__(305),
    SetOrigin: __webpack_require__(306),
    SetRotation: __webpack_require__(307),
    SetScale: __webpack_require__(308),
    SetScaleX: __webpack_require__(309),
    SetScaleY: __webpack_require__(310),
    SetVisible: __webpack_require__(311),
    SetX: __webpack_require__(312),
    SetXY: __webpack_require__(313),
    SetY: __webpack_require__(314),
    ShiftPosition: __webpack_require__(315),
    SmootherStep: __webpack_require__(317),
    SmoothStep: __webpack_require__(316),
    Spread: __webpack_require__(318),
    ToggleVisible: __webpack_require__(319)

};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var Frame = __webpack_require__(325);
var GetValue = __webpack_require__(4);

var GetFrames = function (textureManager, frames)
{
    //      frames: [
    //          { key: textureKey, frame: textureFrame },
    //          { key: textureKey, frame: textureFrame, duration: float },
    //          { key: textureKey, frame: textureFrame, onUpdate: function }
    //          { key: textureKey, frame: textureFrame, visible: boolean }
    //      ],

    var out = [];
    var prev;
    var animationFrame;
    var index = 1;
    var i;
    var textureKey;

    //  if frames is a string, we'll get all the frames from the texture manager as if it's a sprite sheet
    if (typeof frames === 'string')
    {
        textureKey = frames;

        var texture = textureManager.get(textureKey);
        var frameKeys = texture.getFrameNames();

        frames = [];

        frameKeys.forEach(function (idx, value) {
            frames.push({ key: textureKey, frame: value });
        });
    }

    // console.table(frames);

    if (!Array.isArray(frames) || frames.length === 0)
    {
        return out;
    }

    for (i = 0; i < frames.length; i++)
    {
        var item = frames[i];

        var key = GetValue(item, 'key', null);

        if (!key)
        {
            continue;
        }

        var frame = GetValue(item, 'frame', 0);

        var textureFrame = textureManager.getFrame(key, frame);

        animationFrame = new Frame(key, frame, index, textureFrame);

        animationFrame.duration = GetValue(item, 'duration', 0);
        animationFrame.onUpdate = GetValue(item, 'onUpdate', null);

        var visible = GetValue(item, 'visible', null);

        if (visible !== null)
        {
            animationFrame.setVisible = true;
            animationFrame.visible = visible;
        }

        animationFrame.isFirst = (!prev);

        //  The previously created animationFrame
        if (prev)
        {
            prev.nextFrame = animationFrame;

            animationFrame.prevFrame = prev;
        }

        out.push(animationFrame);

        prev = animationFrame;

        index++;
    }

    if (out.length > 0)
    {
        animationFrame.isLast = true;

        //  Link them end-to-end, so they loop
        animationFrame.nextFrame = out[0];

        out[0].prevFrame = animationFrame;

        //  Generate the progress data

        var slice = 1 / (out.length - 1);

        for (i = 0; i < out.length; i++)
        {
            out[i].progress = i * slice;
        }
    }

    return out;
};

module.exports = GetFrames;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Matrix4 = __webpack_require__(53);
var RandomXYZ = __webpack_require__(203);
var RandomXYZW = __webpack_require__(204);
var RotateVec3 = __webpack_require__(205);
var Set = __webpack_require__(54);
var Sprite3D = __webpack_require__(58);
var Vector2 = __webpack_require__(20);
var Vector3 = __webpack_require__(34);
var Vector4 = __webpack_require__(66);

//  Local cache vars
var tmpVec3 = new Vector3();
var tmpVec4 = new Vector4();
var dirvec = new Vector3();
var rightvec = new Vector3();
var billboardMatrix = new Matrix4();

var Camera3D = new Class({

    initialize: function (scene)
    {
        this.scene = scene;

        this.displayList = scene.sys.displayList;
        this.updateList = scene.sys.updateList;

        this.name = '';

        this.direction = new Vector3(0, 0, -1);
        this.up = new Vector3(0, 1, 0);
        this.position = new Vector3();

        //  The mapping from 3D size units to pixels.
        //  In the default case 1 3D unit = 128 pixels. So a sprite that is
        //  256 x 128 px in size will be 2 x 1 units.
        //  Change to whatever best fits your game assets.
        this.pixelScale = 128;

        this.projection = new Matrix4();
        this.view = new Matrix4();
        this.combined = new Matrix4();
        this.invProjectionView = new Matrix4();

        this.near = 1;
        this.far = 100;

        this.ray = {
            origin: new Vector3(),
            direction: new Vector3()
        };

        this.viewportWidth = 0;
        this.viewportHeight = 0;

        this.billboardMatrixDirty = true;

        this.children = new Set();
    },

    setPosition: function (x, y, z)
    {
        this.position.set(x, y, z);

        return this.update();
    },

    setScene: function (scene)
    {
        this.scene = scene;

        return this;
    },

    setPixelScale: function (value)
    {
        this.pixelScale = value;

        return this.update();
    },

    add: function (sprite3D)
    {
        this.children.set(sprite3D);

        this.updateChildren();

        return sprite3D;
    },

    remove: function (child)
    {
        this.displayList.remove(child.gameObject);
        this.updateList.remove(child.gameObject);

        this.children.delete(child);

        return this;
    },

    clear: function ()
    {
        var children = this.getChildren();

        for (var i = 0; i < children.length; i++)
        {
            this.remove(children[i]);
        }

        return this;
    },

    getChildren: function ()
    {
        return this.children.entries;
    },

    create: function (x, y, z, key, frame, visible)
    {
        if (visible === undefined) { visible = true; }

        var child = new Sprite3D(this.scene, x, y, z, key, frame);

        this.displayList.add(child.gameObject);
        this.updateList.add(child.gameObject);

        child.visible = visible;

        this.children.set(child);

        this.updateChildren();

        return child;
    },

    createMultiple: function (quantity, key, frame, visible)
    {
        if (visible === undefined) { visible = true; }

        var output = [];

        for (var i = 0; i < quantity; i++)
        {
            var child = new Sprite3D(this.scene, 0, 0, 0, key, frame);

            this.displayList.add(child.gameObject);
            this.updateList.add(child.gameObject);

            child.visible = visible;

            this.children.set(child);

            output.push(child);
        }

        return output;
    },

    //  Create a bunch of Sprite3D objects in a rectangle
    //  size and spacing are Vec3s (or if integers are converted to vec3s)
    createRect: function (size, spacing, key, frame)
    {
        if (typeof size === 'number') { size = { x: size, y: size, z: size }; }
        if (typeof spacing === 'number') { spacing = { x: spacing, y: spacing, z: spacing }; }

        var quantity = size.x * size.y * size.z;

        var sprites = this.createMultiple(quantity, key, frame);

        var i = 0;

        for (var z = 0.5 - (size.z / 2); z < (size.z / 2); z++)
        {
            for (var y = 0.5 - (size.y / 2); y < (size.y / 2); y++)
            {
                for (var x = 0.5 - (size.x / 2); x < (size.x / 2); x++)
                {
                    var bx = (x * spacing.x);
                    var by = (y * spacing.y);
                    var bz = (z * spacing.z);

                    sprites[i].position.set(bx, by, bz);

                    i++;
                }
            }
        }

        this.update();

        return sprites;
    },

    randomSphere: function (radius, sprites)
    {
        if (sprites === undefined) { sprites = this.getChildren(); }

        for (var i = 0; i < sprites.length; i++)
        {
            RandomXYZ(sprites[i].position, radius);
        }

        return this.update();
    },

    randomCube: function (scale, sprites)
    {
        if (sprites === undefined) { sprites = this.getChildren(); }

        for (var i = 0; i < sprites.length; i++)
        {
            RandomXYZW(sprites[i].position, scale);
        }

        return this.update();
    },

    translateChildren: function (vec3, sprites)
    {
        if (sprites === undefined) { sprites = this.getChildren(); }

        for (var i = 0; i < sprites.length; i++)
        {
            sprites[i].position.add(vec3);
        }

        return this.update();
    },

    transformChildren: function (mat4, sprites)
    {
        if (sprites === undefined) { sprites = this.getChildren(); }

        for (var i = 0; i < sprites.length; i++)
        {
            sprites[i].position.transformMat4(mat4);
        }

        return this.update();
    },

    /**
     * Sets the width and height of the viewport. Does not
     * update any matrices.
     * 
     * @method  setViewport
     * @param {Number} width  the viewport width
     * @param {Number} height the viewport height
     */
    setViewport: function (width, height)
    {
        this.viewportWidth = width;
        this.viewportHeight = height;

        return this.update();
    },

    /**
     * Translates this camera by a specified Vector3 object
     * or x, y, z parameters. Any undefined x y z values will
     * default to zero, leaving that component unaffected.
     * If you wish to set the camera position directly call setPosition instead.
     *
     * @param  {[type]} vec [description]
     * @return {[type]}     [description]
     */
    translate: function (x, y, z)
    {
        if (typeof x === 'object')
        {
            this.position.x += x.x || 0;
            this.position.y += x.y || 0;
            this.position.z += x.z || 0;
        }
        else
        {
            this.position.x += x || 0;
            this.position.y += y || 0;
            this.position.z += z || 0;
        }

        return this.update();
    },

    lookAt: function (x, y, z)
    {
        var dir = this.direction;
        var up = this.up;

        if (typeof x === 'object')
        {
            dir.copy(x);
        }
        else
        {
            dir.set(x, y, z);
        }

        dir.sub(this.position).normalize();

        //  Calculate right vector
        tmpVec3.copy(dir).cross(up).normalize();

        //  Calculate up vector
        up.copy(tmpVec3).cross(dir).normalize();

        return this.update();
    },

    rotate: function (radians, axis)
    {
        RotateVec3(this.direction, axis, radians);
        RotateVec3(this.up, axis, radians);

        return this.update();
    },

    rotateAround: function (point, radians, axis)
    {
        tmpVec3.copy(point).sub(this.position);

        this.translate(tmpVec3);
        this.rotate(radians, axis);
        this.translate(tmpVec3.negate());

        return this.update();
    },

    project: function (vec, out)
    {
        if (out === undefined) { out = new Vector4(); }

        //  TODO: support viewport XY
        var viewportWidth = this.viewportWidth;
        var viewportHeight = this.viewportHeight;
        var n = Camera3D.NEAR_RANGE;
        var f = Camera3D.FAR_RANGE;

        //  For useful Z and W values we should do the usual steps: clip space -> NDC -> window coords

        //  Implicit 1.0 for w component
        tmpVec4.set(vec.x, vec.y, vec.z, 1.0);

        //  Transform into clip space
        tmpVec4.transformMat4(this.combined);

        //  Avoid divide by zero when 0x0x0 camera projects to a 0x0x0 vec3
        if (tmpVec4.w === 0)
        {
            tmpVec4.w = 1;
        }

        //  Now into NDC
        tmpVec4.x = tmpVec4.x / tmpVec4.w;
        tmpVec4.y = tmpVec4.y / tmpVec4.w;
        tmpVec4.z = tmpVec4.z / tmpVec4.w;

        //  And finally into window coordinates
        out.x = viewportWidth / 2 * tmpVec4.x + (0 + viewportWidth / 2);
        out.y = viewportHeight / 2 * tmpVec4.y + (0 + viewportHeight / 2);
        out.z = (f - n) / 2 * tmpVec4.z + (f + n) / 2;

        //  If the out vector has a fourth component, we also store (1/clip.w), same idea as gl_FragCoord.w
        if (out.w === 0 || out.w)
        {
            out.w = 1 / tmpVec4.w;
        }

        return out;
    },

    unproject: function (vec, out)
    {
        if (out === undefined) { out = new Vector3(); }

        var viewport = tmpVec4.set(0, 0, this.viewportWidth, this.viewportHeight);

        return out.copy(vec).unproject(viewport, this.invProjectionView);
    },

    getPickRay: function (x, y)
    {
        var origin = this.ray.origin.set(x, y, 0);
        var direction = this.ray.direction.set(x, y, 1);
        var viewport = tmpVec4.set(0, 0, this.viewportWidth, this.viewportHeight);
        var mtx = this.invProjectionView;

        origin.unproject(viewport, mtx);

        direction.unproject(viewport, mtx);

        direction.sub(origin).normalize();

        return this.ray;
    },

    updateChildren: function ()
    {
        var children = this.children.entries;

        for (var i = 0; i < children.length; i++)
        {
            children[i].project(this);
        }

        return this;
    },

    //  Overriden by subclasses
    update: function ()
    {
        return this.updateChildren();
    },

    updateBillboardMatrix: function ()
    {
        var dir = dirvec.set(this.direction).negate();

        // Better view-aligned billboards might use this:
        // var dir = tmp.set(camera.position).sub(p).normalize();
        
        var right = rightvec.set(this.up).cross(dir).normalize();
        var up = tmpVec3.set(dir).cross(right).normalize();

        var out = billboardMatrix.val;

        out[0] = right.x;
        out[1] = right.y;
        out[2] = right.z;
        out[3] = 0;

        out[4] = up.x;
        out[5] = up.y;
        out[6] = up.z;
        out[7] = 0;

        out[8] = dir.x;
        out[9] = dir.y;
        out[10] = dir.z;
        out[11] = 0;

        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;

        this.billboardMatrixDirty = false;
    },
    
    /**
     * This is a utility function for canvas 3D rendering, 
     * which determines the "point size" of a camera-facing
     * sprite billboard given its 3D world position 
     * (origin at center of sprite) and its world width
     * and height in x/y. 
     *
     * We place into the output Vector2 the scaled width
     * and height. If no `out` is specified, a new Vector2
     * will be created for convenience (this should be avoided 
     * in tight loops).
     * 
     * @param  {Vector3} vec the position of the 3D sprite
     * @param  {Vector2} size the x and y dimensions of the sprite
     * @param  {Vector2} out the result, scaled x and y dimensions in 3D space
     * @return {Vector2} returns the out parameter, or a new Vector2 if none was given
     */
    getPointSize: function (vec, size, out)
    {
        if (out === undefined) { out = new Vector2(); }

        //TODO: optimize this with a simple distance calculation:
        //https://developer.valvesoftware.com/wiki/Field_of_View

        if (this.billboardMatrixDirty)
        {
            this.updateBillboardMatrix();
        }

        var tmp = tmpVec3;

        var dx = (size.x / this.pixelScale) / 2;
        var dy = (size.y / this.pixelScale) / 2;

        tmp.set(-dx, -dy, 0).transformMat4(billboardMatrix).add(vec);

        this.project(tmp, tmp);

        var tlx = tmp.x;
        var tly = tmp.y;

        tmp.set(dx, dy, 0).transformMat4(billboardMatrix).add(vec);

        this.project(tmp, tmp);

        var brx = tmp.x;
        var bry = tmp.y;

        // var w = Math.abs(brx - tlx);
        // var h = Math.abs(bry - tly);

        //  Allow the projection to get negative ...
        var w = brx - tlx;
        var h = bry - tly;

        return out.set(w, h);
    },

    destroy: function ()
    {
        this.children.clear();

        this.scene = undefined;
        this.children = undefined;
    },

    setX: function (value)
    {
        this.position.x = value;

        return this.update();
    },

    setY: function (value)
    {
        this.position.y = value;

        return this.update();
    },

    setZ: function (value)
    {
        this.position.z = value;

        return this.update();
    },

    x: {
        get: function ()
        {
            return this.position.x;
        },

        set: function (value)
        {
            this.position.x = value;
            this.update();
        }
    },

    y: {
        get: function ()
        {
            return this.position.y;
        },

        set: function (value)
        {
            this.position.y = value;
            this.update();
        }
    },

    z: {
        get: function ()
        {
            return this.position.z;
        },

        set: function (value)
        {
            this.position.z = value;
            this.update();
        }
    }

});

Camera3D.FAR_RANGE = 1.0;
Camera3D.NEAR_RANGE = 0.0;

module.exports = Camera3D;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var Camera3D = __webpack_require__(119);
var Class = __webpack_require__(0);
var Matrix4 = __webpack_require__(53);
var Vector3 = __webpack_require__(34);
var Vector4 = __webpack_require__(66);

//  Local cache vars
var tmpVec3 = new Vector3();

var OrthographicCamera = new Class({

    Extends: Camera3D,

    initialize: function (scene, viewportWidth, viewportHeight)
    {
        if (viewportWidth === undefined) { viewportWidth = 0; }
        if (viewportHeight === undefined) { viewportHeight = 0; }

        Camera3D.call(this, scene);

        this.viewportWidth = viewportWidth;
        this.viewportHeight = viewportHeight;

        this._zoom = 1.0;

        this.near = 0;

        this.update();
    },

    setToOrtho: function (yDown, viewportWidth, viewportHeight)
    {
        if (viewportWidth === undefined) { viewportWidth = this.viewportWidth; }
        if (viewportHeight === undefined) { viewportHeight = this.viewportHeight; }

        var zoom = this.zoom;

        this.up.set(0, (yDown) ? -1 : 1, 0);
        this.direction.set(0, 0, (yDown) ? 1 : -1);
        this.position.set(zoom * viewportWidth / 2, zoom * viewportHeight / 2, 0);

        this.viewportWidth = viewportWidth;
        this.viewportHeight = viewportHeight;

        return this.update();
    },

    update: function ()
    {
        //TODO: support x/y offset
        var w = this.viewportWidth;
        var h = this.viewportHeight;
        var near = Math.abs(this.near);
        var far = Math.abs(this.far);
        var zoom = this.zoom;

        if (w === 0 || h === 0)
        {
            //  What to do here... hmm?
            return this;
        }

        this.projection.ortho(
            zoom * -w / 2, zoom * w / 2,
            zoom * -h / 2, zoom * h / 2,
            near,
            far
        );

        //  Build the view matrix 
        tmpVec3.copy(this.position).add(this.direction);

        this.view.lookAt(this.position, tmpVec3, this.up);

        //  Projection * view matrix
        this.combined.copy(this.projection).mul(this.view);

        //  Invert combined matrix, used for unproject
        this.invProjectionView.copy(this.combined).invert();

        this.billboardMatrixDirty = true;

        this.updateChildren();

        return this;
    },

    zoom: {

        get: function ()
        {
            return this._zoom;
        },

        set: function (value)
        {
            this._zoom = value;
            this.update();
        }
    }

});

module.exports = OrthographicCamera;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var Camera3D = __webpack_require__(119);
var Class = __webpack_require__(0);
var Vector3 = __webpack_require__(34);

//  Local cache vars
var tmpVec3 = new Vector3();

var PerspectiveCamera = new Class({

    Extends: Camera3D,

    //  FOV is converted to radians automatically
    initialize: function (scene, fieldOfView, viewportWidth, viewportHeight)
    {
        if (fieldOfView === undefined) { fieldOfView = 80; }
        if (viewportWidth === undefined) { viewportWidth = 0; }
        if (viewportHeight === undefined) { viewportHeight = 0; }

        Camera3D.call(this, scene);

        this.viewportWidth = viewportWidth;
        this.viewportHeight = viewportHeight;
        this.fieldOfView = fieldOfView * Math.PI / 180;

        this.update();
    },

    setFOV: function (value)
    {
        this.fieldOfView = value * Math.PI / 180;

        return this;
    },

    update: function ()
    {
        var aspect = this.viewportWidth / this.viewportHeight;

        //  Create a perspective matrix for our camera
        this.projection.perspective(
            this.fieldOfView,
            aspect,
            Math.abs(this.near),
            Math.abs(this.far)
        );

        //  Build the view matrix 
        tmpVec3.copy(this.position).add(this.direction);

        this.view.lookAt(this.position, tmpVec3, this.up);

        //  Projection * view matrix
        this.combined.copy(this.projection).mul(this.view);

        //  Invert combined matrix, used for unproject
        this.invProjectionView.copy(this.combined).invert();

        this.billboardMatrixDirty = true;

        this.updateChildren();

        return this;
    }

});

module.exports = PerspectiveCamera;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GetValue = __webpack_require__(4);

//  var camControl = new CameraControl({
//      camera: this.cameras.main,
//      left: cursors.left,
//      right: cursors.right,
//      speed: float OR { x: 0, y: 0 }
//  })

var KeyControl = new Class({

    initialize:

    function KeyControl (config)
    {
        this.camera = GetValue(config, 'camera', null);

        this.left = GetValue(config, 'left', null);
        this.right = GetValue(config, 'right', null);
        this.up = GetValue(config, 'up', null);
        this.down = GetValue(config, 'down', null);

        this.zoomIn = GetValue(config, 'zoomIn', null);
        this.zoomOut = GetValue(config, 'zoomOut', null);
        this.zoomSpeed = GetValue(config, 'zoomSpeed', 0.01);

        var speed = GetValue(config, 'speed', null);

        if (typeof speed === 'number')
        {
            this.speedX = speed;
            this.speedY = speed;
        }
        else
        {
            this.speedX = GetValue(config, 'speed.x', 0);
            this.speedY = GetValue(config, 'speed.y', 0);
        }

        this._zoom = 0;

        this.active = (this.camera !== null);
    },

    start: function ()
    {
        this.active = (this.camera !== null);
    },

    stop: function ()
    {
        this.active = false;
    },

    update: function (delta)
    {
        if (!this.active)
        {
            return;
        }

        if (delta === undefined) { delta = 1; }

        var cam = this.camera;

        if (this.up && this.up.isDown)
        {
            cam.scrollY -= ((this.speedY * delta) | 0);
        }
        else if (this.down && this.down.isDown)
        {
            cam.scrollY += ((this.speedY * delta) | 0);
        }

        if (this.left && this.left.isDown)
        {
            cam.scrollX -= ((this.speedX * delta) | 0);
        }
        else if (this.right && this.right.isDown)
        {
            cam.scrollX += ((this.speedX * delta) | 0);
        }

        //  Camera zoom

        if (this.zoomIn && this.zoomIn.isDown)
        {
            cam.zoom -= this.zoomSpeed;

            if (cam.zoom < 0.1)
            {
                cam.zoom = 0.1;
            }
        }
        else if (this.zoomOut && this.zoomOut.isDown)
        {
            cam.zoom += this.zoomSpeed;
        }
    },

    destroy: function ()
    {
        this.camera = null;

        this.left = null;
        this.right = null;
        this.up = null;
        this.down = null;

        this.zoomIn = null;
        this.zoomOut = null;
    }

});

module.exports = KeyControl;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GetValue = __webpack_require__(4);

// var controlConfig = {
//     camera: this.cameras.main,
//     left: cursors.left,
//     right: cursors.right,
//     up: cursors.up,
//     down: cursors.down,
//     zoomIn: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),
//     zoomOut: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E),
//     zoomSpeed: 0.02,
//     acceleration: 0.06,
//     drag: 0.0005,
//     maxSpeed: 1.0
// };

var SmoothedKeyControl = new Class({

    initialize:

    function SmoothedKeyControl (config)
    {
        this.camera = GetValue(config, 'camera', null);

        this.left = GetValue(config, 'left', null);
        this.right = GetValue(config, 'right', null);
        this.up = GetValue(config, 'up', null);
        this.down = GetValue(config, 'down', null);

        this.zoomIn = GetValue(config, 'zoomIn', null);
        this.zoomOut = GetValue(config, 'zoomOut', null);
        this.zoomSpeed = GetValue(config, 'zoomSpeed', 0.01);

        var accel = GetValue(config, 'acceleration', null);

        if (typeof accel === 'number')
        {
            this.accelX = accel;
            this.accelY = accel;
        }
        else
        {
            this.accelX = GetValue(config, 'acceleration.x', 0);
            this.accelY = GetValue(config, 'acceleration.y', 0);
        }

        var drag = GetValue(config, 'drag', null);

        if (typeof drag === 'number')
        {
            this.dragX = drag;
            this.dragY = drag;
        }
        else
        {
            this.dragX = GetValue(config, 'drag.x', 0);
            this.dragY = GetValue(config, 'drag.y', 0);
        }

        var maxSpeed = GetValue(config, 'maxSpeed', null);

        if (typeof maxSpeed === 'number')
        {
            this.maxSpeedX = maxSpeed;
            this.maxSpeedY = maxSpeed;
        }
        else
        {
            this.maxSpeedX = GetValue(config, 'maxSpeed.x', 0);
            this.maxSpeedY = GetValue(config, 'maxSpeed.y', 0);
        }

        this._speedX = 0;
        this._speedY = 0;
        this._zoom = 0;

        this.active = (this.camera !== null);
    },

    start: function ()
    {
        this.active = (this.camera !== null);
    },

    stop: function ()
    {
        this.active = false;
    },

    update: function (delta)
    {
        if (!this.active)
        {
            return;
        }

        if (delta === undefined) { delta = 1; }

        var cam = this.camera;

        //  Apply Deceleration

        if (this._speedX > 0)
        {
            this._speedX -= this.dragX * delta;

            if (this._speedX < 0)
            {
                this._speedX = 0;
            }
        }
        else if (this._speedX < 0)
        {
            this._speedX += this.dragX * delta;

            if (this._speedX > 0)
            {
                this._speedX = 0;
            }
        }

        if (this._speedY > 0)
        {
            this._speedY -= this.dragY * delta;

            if (this._speedY < 0)
            {
                this._speedY = 0;
            }
        }
        else if (this._speedY < 0)
        {
            this._speedY += this.dragY * delta;

            if (this._speedY > 0)
            {
                this._speedY = 0;
            }
        }

        //  Check for keys

        if (this.up && this.up.isDown)
        {
            this._speedY += this.accelY;

            if (this._speedY > this.maxSpeedY)
            {
                this._speedY = this.maxSpeedY;
            }
        }
        else if (this.down && this.down.isDown)
        {
            this._speedY -= this.accelY;

            if (this._speedY < -this.maxSpeedY)
            {
                this._speedY = -this.maxSpeedY;
            }
        }

        if (this.left && this.left.isDown)
        {
            this._speedX += this.accelX;

            if (this._speedX > this.maxSpeedX)
            {
                this._speedX = this.maxSpeedX;
            }
        }
        else if (this.right && this.right.isDown)
        {
            this._speedX -= this.accelX;

            if (this._speedX < -this.maxSpeedX)
            {
                this._speedX = -this.maxSpeedX;
            }
        }

        //  Camera zoom

        if (this.zoomIn && this.zoomIn.isDown)
        {
            this._zoom = -this.zoomSpeed;
        }
        else if (this.zoomOut && this.zoomOut.isDown)
        {
            this._zoom = this.zoomSpeed;
        }
        else
        {
            this._zoom = 0;
        }

        //  Apply to Camera

        if (this._speedX !== 0)
        {
            cam.scrollX -= ((this._speedX * delta) | 0);
        }

        if (this._speedY !== 0)
        {
            cam.scrollY -= ((this._speedY * delta) | 0);
        }

        if (this._zoom !== 0)
        {
            cam.zoom += this._zoom;

            if (cam.zoom < 0.1)
            {
                cam.zoom = 0.1;
            }
        }
    },

    destroy: function ()
    {
        this.camera = null;

        this.left = null;
        this.right = null;
        this.up = null;
        this.down = null;

        this.zoomIn = null;
        this.zoomOut = null;
    }

});

module.exports = SmoothedKeyControl;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var PerspectiveCamera = __webpack_require__(121);

var AddPerspectiveCamera = function (fieldOfView, width, height)
{
    var config = this.scene.sys.game.config;

    if (fieldOfView === undefined) { fieldOfView = 80; }
    if (width === undefined) { width = config.width; }
    if (height === undefined) { height = config.height; }

    var camera = new PerspectiveCamera(this.scene, fieldOfView, width, height);

    return camera;
};

module.exports = AddPerspectiveCamera;


/***/ }),
/* 125 */
/***/ (function(module, exports) {

var GetContext = function (canvas, options)
{
    return (
        canvas.getContext('2d', options) || 
        null
    );
};

module.exports = GetContext;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(4);
var Arne16 = __webpack_require__(127);
var CanvasPool = __webpack_require__(15);

var GenerateTexture = function (config)
{
    var data = GetValue(config, 'data', []);
    var canvas = GetValue(config, 'canvas', null);
    var palette = GetValue(config, 'palette', Arne16);
    var pixelWidth = GetValue(config, 'pixelWidth', 1);
    var pixelHeight = GetValue(config, 'pixelHeight', pixelWidth);
    var resizeCanvas = GetValue(config, 'resizeCanvas', true);
    var clearCanvas = GetValue(config, 'clearCanvas', true);
    var preRender = GetValue(config, 'preRender', null);
    var postRender = GetValue(config, 'postRender', null);

    var width = Math.floor(Math.abs(data[0].length * pixelWidth));
    var height = Math.floor(Math.abs(data.length * pixelHeight));

    if (!canvas)
    {
        canvas = CanvasPool.create2D(this, width, height);
        resizeCanvas = false;
        clearCanvas = false;
    }

    if (resizeCanvas)
    {
        canvas.width = width;
        canvas.height = height;
    }

    var ctx = canvas.getContext('2d');

    if (clearCanvas)
    {
        ctx.clearRect(0, 0, width, height);
    }

    //  preRender Callback?
    if (preRender)
    {
        preRender(canvas, ctx);
    }

    //  Draw it
    for (var y = 0; y < data.length; y++)
    {
        var row = data[y];

        for (var x = 0; x < row.length; x++)
        {
            var d = row[x];

            if (d !== '.' && d !== ' ')
            {
                ctx.fillStyle = palette[d];
                ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);
            }
        }
    }

    //  postRender Callback?
    if (postRender)
    {
        postRender(canvas, ctx);
    }

    return canvas;
};

module.exports = GenerateTexture;


/***/ }),
/* 127 */
/***/ (function(module, exports) {

// A 16 color palette by [Arne](http://androidarts.com/palette/16pal.htm)

module.exports = {
    0: '#000',
    1: '#9D9D9D',
    2: '#FFF',
    3: '#BE2633',
    4: '#E06F8B',
    5: '#493C2B',
    6: '#A46422',
    7: '#EB8931',
    8: '#F7E26B',
    9: '#2F484E',
    A: '#44891A',
    B: '#A3CE27',
    C: '#1B2632',
    D: '#005784',
    E: '#31A2F2',
    F: '#B2DCEF'
};


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(15);

var CanvasFeatures = {

    supportNewBlendModes: false,

    supportInverseAlpha: false

};

function checkBlendMode ()
{
    var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
    var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';

    var magenta = new Image();

    magenta.onload = function ()
    {
        var yellow = new Image();

        yellow.onload = function ()
        {
            var canvas = CanvasPool.create(yellow, 6, 1);
            var context = canvas.getContext('2d');

            context.globalCompositeOperation = 'multiply';

            context.drawImage(magenta, 0, 0);
            context.drawImage(yellow, 2, 0);

            if (!context.getImageData(2, 0, 1, 1))
            {
                return false;
            }

            var data = context.getImageData(2, 0, 1, 1).data;

            CanvasPool.remove(yellow);

            CanvasFeatures.supportNewBlendModes = (data[0] === 255 && data[1] === 0 && data[2] === 0);
        };

        yellow.src = pngHead + '/wCKxvRF' + pngEnd;
    };

    magenta.src = pngHead + 'AP804Oa6' + pngEnd;

    return false;
}

function checkInverseAlpha ()
{
    var canvas = CanvasPool.create(this, 2, 1);
    var context = canvas.getContext('2d');

    context.fillStyle = 'rgba(10, 20, 30, 0.5)';

    //  Draw a single pixel
    context.fillRect(0, 0, 1, 1);

    //  Get the color values
    var s1 = context.getImageData(0, 0, 1, 1);

    if (s1 === null)
    {
        return false;
    }

    //  Plot them to x2
    context.putImageData(s1, 1, 0);

    //  Get those values
    var s2 = context.getImageData(1, 0, 1, 1);

    //  Compare and return
    return (s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]);
}

function init ()
{
    if (document !== undefined)
    {
        CanvasFeatures.supportNewBlendModes = checkBlendMode();
        CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
    }

    return CanvasFeatures;
}

module.exports = init();


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var OS = __webpack_require__(50);
var Browser = __webpack_require__(55);
var CanvasPool = __webpack_require__(15);

var Features = {

    //  @property {boolean} canvas - Is canvas available?
    canvas: false,

    //  @property {?boolean} canvasBitBltShift - True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.
    canvasBitBltShift: null,

    //  @property {boolean} webGL - Is webGL available?
    webGL: false,

    //  @property {boolean} file - Is file available?
    file: false,

    //  @property {boolean} fileSystem - Is fileSystem available?
    fileSystem: false,

    //  @property {boolean} localStorage - Is localStorage available?
    localStorage: false,

    //  @property {boolean} worker - Is worker available?
    worker: false,

    //  @property {boolean} pointerLock - Is Pointer Lock available?
    pointerLock: false,

    //  @property {boolean} vibration - Does the device support the Vibration API?
    vibration: false,

    //  @property {boolean} getUserMedia - Does the device support the getUserMedia API?
    getUserMedia: true,

    //  @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)
    littleEndian: false,

    //  @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?
    support32bit: false

};

// Check Little or Big Endian system.
// @author Matt DesLauriers (@mattdesl)
function checkIsLittleEndian ()
{
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);

    b[0] = 0xa1;
    b[1] = 0xb2;
    b[2] = 0xc3;
    b[3] = 0xd4;

    if (c[0] === 0xd4c3b2a1)
    {
        return true;
    }

    if (c[0] === 0xa1b2c3d4)
    {
        return false;
    }
    else
    {
        //  Could not determine endianness
        return null;
    }
}

function init ()
{
    Features.canvas = !!window['CanvasRenderingContext2D'] || OS.cocoonJS;

    try
    {
        Features.localStorage = !!localStorage.getItem;
    }
    catch (error)
    {
        Features.localStorage = false;
    }

    Features.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];
    Features.fileSystem = !!window['requestFileSystem'];

    var isUint8 = false;

    var testWebGL = function ()
    {
        if (window['WebGLRenderingContext'])
        {
            try
            {
                var canvas = CanvasPool.createWebGL(this);

                if (OS.cocoonJS)
                {
                    canvas.screencanvas = false;
                }

                var ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                var canvas2D = CanvasPool.create2D(this);

                var ctx2D = canvas2D.getContext('2d');

                //  Can't be done on a webgl context
                var image = ctx2D.createImageData(1, 1);
    
                /**
                * Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.
                *
                * @author Matt DesLauriers (@mattdesl)
                */
                isUint8 = image.data instanceof Uint8ClampedArray;

                CanvasPool.remove(canvas);
                CanvasPool.remove(canvas2D);

                return (ctx !== null);
            }
            catch (e)
            {
                return false;
            }
        }
        
        return false;
    };

    Features.webGL = true;//testWebGL();

    Features.worker = !!window['Worker'];

    Features.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

    window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;

    // Older versions of firefox (< 21) apparently claim support but user media does not actually work
    if (Browser.firefox && Browser.firefoxVersion < 21)
    {
        Features.getUserMedia = false;
    }

    // Excludes iOS versions as they generally wrap UIWebView (eg. Safari WebKit) and it
    // is safer to not try and use the fast copy-over method.
    if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome))
    {
        Features.canvasBitBltShift = true;
    }

    // Known not to work
    if (Browser.safari || Browser.mobileSafari)
    {
        Features.canvasBitBltShift = false;
    }

    navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;

    if (navigator.vibrate)
    {
        Features.vibration = true;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined')
    {
        Features.littleEndian = checkIsLittleEndian();
    }

    Features.support32bit = (
        typeof ArrayBuffer !== 'undefined' &&
        typeof Uint8ClampedArray !== 'undefined' &&
        typeof Int32Array !== 'undefined' &&
        Features.littleEndian !== null &&
        isUint8
    );

    return Features;
}

module.exports = init();


/***/ }),
/* 130 */
/***/ (function(module, exports) {

var AddToDOM = function (element, parent, overflowHidden)
{
    if (overflowHidden === undefined) { overflowHidden = true; }

    var target;

    if (parent)
    {
        if (typeof parent === 'string')
        {
            //  Hopefully an element ID
            target = document.getElementById(parent);
        }
        else if (typeof parent === 'object' && parent.nodeType === 1)
        {
            //  Quick test for a HTMLelement
            target = parent;
        }
    }

    //  Fallback, covers an invalid ID and a non HTMLelement object
    if (!target)
    {
        target = document.body;
    }

    if (overflowHidden && target.style)
    {
        target.style.overflow = 'hidden';
    }

    target.appendChild(element);

    return element;
};

module.exports = AddToDOM;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var OS = __webpack_require__(50);

var isBooted = false;

var DOMContentLoaded = function (callback)
{
    if (isBooted)
    {
        return;
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive')
    {
        isBooted = true;
        
        callback();

        return;
    }

    var check = function ()
    {
        isBooted = true;

        document.removeEventListener('deviceready', check, true);
        document.removeEventListener('DOMContentLoaded', check, true);
        window.removeEventListener('load', check, true);

        callback();
    };

    if (!document.body)
    {
        window.setTimeout(check, 20);
    }
    else if (OS.cordova && !OS.cocoonJS)
    {
        //  Ref. http://docs.phonegap.com/en/3.5.0/cordova_events_events.md.html#deviceready
        document.addEventListener('deviceready', check, false);
    }
    else
    {
        document.addEventListener('DOMContentLoaded', check, true);
        window.addEventListener('load', check, true);
    }
};

module.exports = DOMContentLoaded;


/***/ }),
/* 132 */
/***/ (function(module, exports) {

var ParseXML = function (data)
{
    var xml = '';

    try
    {
        if (window['DOMParser'])
        {
            var domparser = new DOMParser();
            xml = domparser.parseFromString(data, 'text/xml');
        }
        else
        {
            xml = new ActiveXObject('Microsoft.XMLDOM');
            xml.loadXML(data);
        }
    }
    catch (e)
    {
        xml = null;
    }

    if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length)
    {
        return null;
    }
    else
    {
        return xml;
    }
};

module.exports = ParseXML;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var NOOP = __webpack_require__(3);

// Abstracts away the use of RAF or setTimeOut for the core game update loop.
var RequestAnimationFrame = function ()
{
    // @property {boolean} isRunning - true if RequestAnimationFrame is running, otherwise false.
    this.isRunning = false;

    this.callback = NOOP;

    this.tick = 0;

    // @property {boolean} isSetTimeOut  - True if the browser is using setTimeout instead of rAf.
    this.isSetTimeOut = false;

    // @property {number} timeOutID - The callback setTimeout or rAf callback ID used when calling cancel.
    this.timeOutID = null;

    var _this = this;

    //  timestamp = DOMHighResTimeStamp
    var step = function (timestamp)
    {
        _this.tick = timestamp;

        _this.callback(timestamp);

        _this.timeOutID = window.requestAnimationFrame(step);
    };

    var stepTimeout = function ()
    {
        var d = Date.now();

        _this.tick = d;

        _this.callback(d);

        _this.timeOutID = window.setTimeout(stepTimeout, _this.timeToCall);
    };

    this.step = step;
    this.stepTimeout = stepTimeout;
};

RequestAnimationFrame.prototype.constructor = RequestAnimationFrame;

RequestAnimationFrame.prototype = {

    // Starts the requestAnimationFrame running or setTimeout if unavailable in browser
    start: function (callback, forceSetTimeOut)
    {
        this.callback = callback;

        this.isSetTimeOut = forceSetTimeOut;

        this.isRunning = true;

        var _this = this;

        this.timeOutID = (forceSetTimeOut) ? window.setTimeout(_this.stepTimeout, 0) : window.requestAnimationFrame(_this.step);
    },

    // Stops the requestAnimationFrame from running.
    stop: function ()
    {
        this.isRunning = false;

        if (this.isSetTimeOut)
        {
            clearTimeout(this.timeOutID);
        }
        else
        {
            window.cancelAnimationFrame(this.timeOutID);
        }
    },

    destroy: function ()
    {
        this.stop();

        this.callback = NOOP;
    }

};

module.exports = RequestAnimationFrame;


/***/ }),
/* 134 */
/***/ (function(module, exports) {

var EVENT_CONST = {

    DISPATCHER_IDLE: 0,
    DISPATCHER_DISPATCHING: 1,
    DISPATCHER_REMOVING: 2,
    DISPATCHER_DESTROYED: 3,

    LISTENER_PENDING: 4,
    LISTENER_ACTIVE: 5,
    LISTENER_REMOVING: 6

};

module.exports = EVENT_CONST;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var GetAdvancedValue = __webpack_require__(7);

var BuildGameObjectAnimation = function (sprite, config)
{
    var animConfig = GetAdvancedValue(config, 'anims', null);

    if (animConfig === null)
    {
        return sprite;
    }

    if (typeof animConfig === 'string')
    {
        //  { anims: 'key' }
        sprite.anims.play(animConfig);
    }
    else if (typeof animConfig === 'object')
    {
        //  { anims: {
        //              key: string
        //              startFrame: [string|integer]
        //              delay: [float]
        //              repeat: [integer]
        //              repeatDelay: [float]
        //              yoyo: [boolean]
        //              play: [boolean]
        //              delayedPlay: [boolean]
        //           }
        //  }

        var anims = sprite.anims;

        var key = GetAdvancedValue(animConfig, 'key', undefined);
        var startFrame = GetAdvancedValue(animConfig, 'startFrame', undefined);

        var delay = GetAdvancedValue(animConfig, 'delay', 0);
        var repeat = GetAdvancedValue(animConfig, 'repeat', 0);
        var repeatDelay = GetAdvancedValue(animConfig, 'repeatDelay', 0);
        var yoyo = GetAdvancedValue(animConfig, 'yoyo', false);
        
        var play = GetAdvancedValue(animConfig, 'play', false);
        var delayedPlay = GetAdvancedValue(animConfig, 'delayedPlay', 0);

        anims.delay(delay);
        anims.repeat(repeat);
        anims.repeatDelay(repeatDelay);
        anims.yoyo(yoyo);

        if (play)
        {
            anims.play(key, startFrame);
        }
        else if (delayedPlay > 0)
        {
            anims.delayedPlay(delayedPlay, key, startFrame);
        }
        else
        {
            anims.load(key);
        }
    }

    return sprite;
};

module.exports = BuildGameObjectAnimation;


/***/ }),
/* 136 */
/***/ (function(module, exports) {


var GetBitmapTextSize = function (src, round)
{
    var text = src.text;
    var textLength = text.length;

    var bx = Number.MAX_VALUE;
    var by = Number.MAX_VALUE;
    var bw = 0;
    var bh = 0;
    
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = indexCount + glyph.xOffset + xAdvance;
        y = glyph.yOffset + yAdvance;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (bx > x)
        {
            bx = x;
        }

        if (by > y)
        {
            by = y;
        }

        var gw = x + glyphW - bx;
        var gh = y + glyphH - by;

        if (bw < gw)
        {
            bw = gw;
        }
        
        if (bh < gh)
        {
            bh = gh;
        }

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    var scale = (src.fontSize / src.fontData.size);
    var sx = scale * src.scaleX;
    var sy = scale * src.scaleY;

    var out = {
        local: {
            x: bx * scale,
            y: by * scale,
            width: bw * scale,
            height: bh * scale
        },
        global: {
            x: src.x + (bx * sx),
            y: src.y + (by * sy),
            width: bw * sx,
            height: bh * sy
        }
    };

    if (round)
    {
        out.local.x = Math.round(out.local.x);
        out.local.y = Math.round(out.local.y);
        out.local.width = Math.round(out.local.width);
        out.local.height = Math.round(out.local.height);

        out.global.x = Math.round(out.global.x);
        out.global.y = Math.round(out.global.y);
        out.global.width = Math.round(out.global.width);
        out.global.height = Math.round(out.global.height);
    }

    return out;
};

module.exports = GetBitmapTextSize;


/***/ }),
/* 137 */
/***/ (function(module, exports) {

function getValue (node, attribute)
{
    return parseInt(node.getAttribute(attribute), 10);
}

var ParseXMLBitmapFont = function (xml, xSpacing, ySpacing, frame)
{
    if (xSpacing === undefined) { xSpacing = 0; }
    if (ySpacing === undefined) { ySpacing = 0; }

    var data = {};
    var info = xml.getElementsByTagName('info')[0];
    var common = xml.getElementsByTagName('common')[0];

    data.font = info.getAttribute('face');
    data.size = getValue(info, 'size');
    data.lineHeight = getValue(common, 'lineHeight') + ySpacing;
    data.chars = {};

    var letters = xml.getElementsByTagName('char');

    var x = 0;
    var y = 0;
    var cx = 0;
    var cy = 0;
    var adjustForTrim = (frame !== undefined && frame.trimmed);

    if (adjustForTrim)
    {
        var top = frame.height;
        var left = frame.width;
    }

    var diff = 0;

    for (var i = 0; i < letters.length; i++)
    {
        var node = letters[i];

        var charCode = getValue(node, 'id');
        var gx = getValue(node, 'x');
        var gy = getValue(node, 'y');
        var gw = getValue(node, 'width');
        var gh = getValue(node, 'height');

        //  Handle frame trim issues

        if (adjustForTrim)
        {
            // if (gx + gw > frame.width)
            // {
            //     diff = frame.width - (gx + gw);
                // gw -= diff;
            // }

            // if (gy + gh > frame.height)
            // {
            //     diff = frame.height - (gy + gh);
                // gh -= diff;
            // }

            if (gx < left)
            {
                left = gx;
            }

            if (gy < top)
            {
                top = gy;
            }
        }

        data.chars[charCode] =
        {
            x: gx,
            y: gy,
            width: gw,
            height: gh,
            centerX: Math.floor(gw / 2),
            centerY: Math.floor(gh / 2),
            xOffset: getValue(node, 'xoffset'),
            yOffset: getValue(node, 'yoffset'),
            xAdvance: getValue(node, 'xadvance') + xSpacing,
            data: {},
            kerning: {}
        };
    }

    if (adjustForTrim && top !== 0 && left !== 0)
    {
        // console.log('top and left', top, left, frame.x, frame.y);

        //  Now we know the top and left coordinates of the glyphs in the original data
        //  so we can work out how much to adjust the glyphs by

        for (var code in data.chars)
        {
            var glyph = data.chars[code];

            glyph.x -= frame.x;
            glyph.y -= frame.y;
        }
    }

    var kernings = xml.getElementsByTagName('kerning');

    for (i = 0; i < kernings.length; i++)
    {
        var kern = kernings[i];

        var first = getValue(kern, 'first');
        var second = getValue(kern, 'second');
        var amount = getValue(kern, 'amount');

        data.chars[second].kerning[first] = amount;
    }

    return data;
};

module.exports = ParseXMLBitmapFont;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var Commands = __webpack_require__(82);
var MATH_CONST = __webpack_require__(13);
var GameObject = __webpack_require__(1);

var GraphicsCanvasRenderer = function (renderer, src, interpolationPercentage, camera, renderTargetCtx)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    var cameraScrollX = camera.scrollX * src.scrollFactorX;
    var cameraScrollY = camera.scrollY * src.scrollFactorY;
    var srcX = src.x;
    var srcY = src.y;
    var srcScaleX = src.scaleX;
    var srcScaleY = src.scaleY;
    var srcRotation = src.rotation;
    var commandBuffer = src.commandBuffer;
    var ctx = renderTargetCtx || renderer.currentContext;
    var value;
    var lineAlpha = 1.0;
    var fillAlpha = 1.0;
    var lineColor = 0;
    var fillColor = 0;
    var lineWidth = 1.0;
    var red = 0;
    var green = 0;
    var blue = 0;

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(srcX - cameraScrollX, srcY - cameraScrollY);
    ctx.rotate(srcRotation);
    ctx.scale(srcScaleX, srcScaleY);
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = src.alpha;

    for (var index = 0, length = commandBuffer.length; index < length; ++index)
    {
        var commandID = commandBuffer[index];

        switch (commandID)
        {
            case Commands.ARC:
                ctx.arc(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2],
                    commandBuffer[index + 3],
                    commandBuffer[index + 4],
                    commandBuffer[index + 5],
                    commandBuffer[index + 6]
                );
                index += 6;
                break;

            case Commands.LINE_STYLE:
                lineWidth = commandBuffer[index + 1];
                lineColor = commandBuffer[index + 2];
                lineAlpha = commandBuffer[index + 3];
                red = ((lineColor & 0xFF0000) >>> 16);
                green = ((lineColor & 0xFF00) >>> 8);
                blue = (lineColor & 0xFF);
                ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + lineAlpha + ')';
                ctx.lineWidth = lineWidth;
                index += 3;
                break;

            case Commands.FILL_STYLE:
                fillColor = commandBuffer[index + 1];
                fillAlpha = commandBuffer[index + 2];
                red = ((fillColor & 0xFF0000) >>> 16);
                green = ((fillColor & 0xFF00) >>> 8);
                blue = (fillColor & 0xFF);
                ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
                index += 2;
                break;

            case Commands.BEGIN_PATH:
                ctx.beginPath();
                break;

            case Commands.CLOSE_PATH:
                ctx.closePath();
                break;

            case Commands.FILL_PATH:
                ctx.fill();
                break;

            case Commands.STROKE_PATH:
                ctx.stroke();
                break;

            case Commands.FILL_RECT:
                ctx.fillRect(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2],
                    commandBuffer[index + 3],
                    commandBuffer[index + 4]
                );
                index += 4;
                break;

            case Commands.FILL_TRIANGLE:
                ctx.beginPath();
                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.closePath();
                ctx.fill();
                index += 6;
                break;

            case Commands.STROKE_TRIANGLE:
                ctx.beginPath();
                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.closePath();
                ctx.stroke();
                index += 6;
                break;

            case Commands.LINE_TO:
                ctx.lineTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.MOVE_TO:
                ctx.moveTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.LINE_FX_TO:
                ctx.lineTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 5;
                break;

            case Commands.MOVE_FX_TO:
                ctx.moveTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 5;
                break;

            case Commands.SAVE:
                ctx.save();
                break;

            case Commands.RESTORE:
                ctx.restore();
                break;

            case Commands.TRANSLATE:
                ctx.translate(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.SCALE:
                ctx.scale(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.ROTATE:
                ctx.rotate(
                    commandBuffer[index + 1]
                );
                index += 1;
                break;

            default:
                console.error('Phaser: Invalid Graphics Command ID ' + commandID);
                break;
        }
    }

    ctx.restore();
};

module.exports = GraphicsCanvasRenderer;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var ForwardRenderer = function (renderer, lightLayer, interpolationPercentage, camera)
{
    var spriteList = lightLayer.sprites;
    var length = spriteList.length;
    var batch = renderer.spriteBatch;

    if (GameObject.RENDER_MASK !== lightLayer.renderFlags || length === 0  || (lightLayer.cameraFilter > 0 && (lightLayer.cameraFilter & camera._id)))
    {
        return;
    }

    if (renderer.currentRenderer !== null)
    {
        renderer.currentRenderer.flush();
    }

    batch.bind(lightLayer.passShader);
    batch.indexBufferObject.bind();
    lightLayer.updateLights(renderer, camera, lightLayer.passShader);

    for (var index = 0; index < length; ++index)
    {
        var spriteNormalPair = spriteList[index];
        var gameObject = spriteNormalPair.spriteRef;
        
        /* Inlined function of add sprite modified. */
        {
            var tempMatrix = batch.tempMatrix;
            var frame = gameObject.frame;
            var forceFlipY = (frame.texture.source[frame.sourceIndex].glTexture.isRenderTexture ? true : false);
            var flipX = gameObject.flipX;
            var flipY = gameObject.flipY ^ forceFlipY;
            var vertexDataBuffer = batch.vertexDataBuffer;
            var vertexBufferObjectF32 = vertexDataBuffer.floatView;
            var vertexBufferObjectU32 = vertexDataBuffer.uintView;
            var vertexOffset = 0;
            var uvs = frame.uvs;
            var width = frame.width * (flipX ? -1 : 1);
            var height = frame.height * (flipY ? -1 : 1);
            var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
            var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
            var scaleX = gameObject.scaleX;
            var scaleY = gameObject.scaleY;
            var rotation = -gameObject.rotation;
            var tempMatrixMatrix = tempMatrix.matrix;
            var x = -gameObject.displayOriginX + frame.x + ((frame.width) * (flipX ? 1 : 0.0));
            var y = -gameObject.displayOriginY + frame.y + ((frame.height) * (flipY ? 1 : 0.0));
            var xw = x + width;
            var yh = y + height;
            var cameraMatrix = camera.matrix.matrix;
            var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
            var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
            var alphaTL = gameObject._alphaTL;
            var alphaTR = gameObject._alphaTR;
            var alphaBL = gameObject._alphaBL;
            var alphaBR = gameObject._alphaBR;
            var tintTL = gameObject._tintTL;
            var tintTR = gameObject._tintTR;
            var tintBL = gameObject._tintBL;
            var tintBR = gameObject._tintBR;

            tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

            sra = tempMatrixMatrix[0];
            srb = tempMatrixMatrix[1];
            src = tempMatrixMatrix[2];
            srd = tempMatrixMatrix[3];
            sre = tempMatrixMatrix[4];
            srf = tempMatrixMatrix[5];

            cma = cameraMatrix[0];
            cmb = cameraMatrix[1];
            cmc = cameraMatrix[2];
            cmd = cameraMatrix[3];
            cme = cameraMatrix[4];
            cmf = cameraMatrix[5];

            mva = sra * cma + srb * cmc;
            mvb = sra * cmb + srb * cmd;
            mvc = src * cma + srd * cmc;
            mvd = src * cmb + srd * cmd;
            mve = sre * cma + srf * cmc + cme;
            mvf = sre * cmb + srf * cmd + cmf;
            
            tx0 = x * mva + y * mvc + mve;
            ty0 = x * mvb + y * mvd + mvf;
            tx1 = x * mva + yh * mvc + mve;
            ty1 = x * mvb + yh * mvd + mvf;
            tx2 = xw * mva + yh * mvc + mve;
            ty2 = xw * mvb + yh * mvd + mvf;
            tx3 = xw * mva + y * mvc + mve;
            ty3 = xw * mvb + y * mvd + mvf;

    
            if (renderer.currentTexture[0] !== frame.texture.source[frame.sourceIndex].glTexture ||
                renderer.currentTexture[1] !== spriteNormalPair.normalTextureRef.source[spriteNormalPair.spriteRef.frame.sourceIndex].glTexture ||
                batch.shouldFlush())
            {
                batch.flush(lightLayer.passShader, lightLayer.renderTarget);
                renderer.setTexture(frame.texture.source[frame.sourceIndex].glTexture, 0);
                renderer.setTexture(spriteNormalPair.normalTextureRef.source[spriteNormalPair.spriteRef.frame.sourceIndex].glTexture, 1);
            }

            batch.drawIndexed = true;
            batch.drawingMesh = false;
            vertexOffset = vertexDataBuffer.allocate(24);
            batch.elementCount += 6;
            
            //  Top Left
            vertexBufferObjectF32[vertexOffset++] = tx0;
            vertexBufferObjectF32[vertexOffset++] = ty0;
            vertexBufferObjectF32[vertexOffset++] = uvs.x0;
            vertexBufferObjectF32[vertexOffset++] = uvs.y0;
            vertexBufferObjectU32[vertexOffset++] = tintTL;
            vertexBufferObjectF32[vertexOffset++] = alphaTL;

            //  Bottom Left
            vertexBufferObjectF32[vertexOffset++] = tx1;
            vertexBufferObjectF32[vertexOffset++] = ty1;
            vertexBufferObjectF32[vertexOffset++] = uvs.x1;
            vertexBufferObjectF32[vertexOffset++] = uvs.y1;
            vertexBufferObjectU32[vertexOffset++] = tintBL;
            vertexBufferObjectF32[vertexOffset++] = alphaBL;

            //  Bottom Right
            vertexBufferObjectF32[vertexOffset++] = tx2;
            vertexBufferObjectF32[vertexOffset++] = ty2;
            vertexBufferObjectF32[vertexOffset++] = uvs.x2;
            vertexBufferObjectF32[vertexOffset++] = uvs.y2;
            vertexBufferObjectU32[vertexOffset++] = tintBR;
            vertexBufferObjectF32[vertexOffset++] = alphaBR;

            //  Top Right
            vertexBufferObjectF32[vertexOffset++] = tx3;
            vertexBufferObjectF32[vertexOffset++] = ty3;
            vertexBufferObjectF32[vertexOffset++] = uvs.x3;
            vertexBufferObjectF32[vertexOffset++] = uvs.y3;
            vertexBufferObjectU32[vertexOffset++] = tintTR;
            vertexBufferObjectF32[vertexOffset++] = alphaTR;
        }
    }

    batch.flush(lightLayer.passShader, lightLayer.renderTarget);

};

module.exports = ForwardRenderer;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(12);

/**
* Returns a uniformly distributed random point from anywhere within this Circle.
*/
var Random = function (circle, out)
{
    if (out === undefined) { out = new Point(); }

    var t = 2 * Math.PI * Math.random();
    var u = Math.random() + Math.random();
    var r = (u > 1) ? 2 - u : u;
    var x = r * Math.cos(t);
    var y = r * Math.sin(t);

    out.x = circle.x + (x * circle.radius);
    out.y = circle.y + (y * circle.radius);

    return out;
};

module.exports = Random;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(12);

var Random = function (ellipse, out)
{
    if (out === undefined) { out = new Point(); }

    var p = Math.random() * Math.PI * 2;
    var s = Math.sqrt(Math.random());

    out.x = ellipse.x + ((s * Math.cos(p)) * ellipse.width / 2);
    out.y = ellipse.y + ((s * Math.sin(p)) * ellipse.height / 2);

    return out;
};

module.exports = Random;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

//  Based on code by Matt DesLauriers
//  https://github.com/mattdesl/line-circle-collision/blob/master/LICENSE.md

var Contains = __webpack_require__(38);

var tmp = { x: 0, y: 0 };

var LineToCircle = function (line, circle, nearest)
{
    if (nearest === undefined) { nearest = tmp; }

    if (Contains(circle, line.x1, line.y1))
    {
        nearest.x = line.x1;
        nearest.y = line.y1;

        return true;
    }

    if (Contains(circle, line.x2, line.y2))
    {
        nearest.x = line.x2;
        nearest.y = line.y2;

        return true;
    }

    var dx = line.x2 - line.x1;
    var dy = line.y2 - line.y1;

    var lcx = circle.x - line.x1;
    var lcy = circle.y - line.y1;

    //  project lc onto d, resulting in vector p
    var dLen2 = (dx * dx) + (dy * dy);
    var px = dx;
    var py = dy;

    if (dLen2 > 0)
    {
        var dp = ((lcx * dx) + (lcy * dy)) / dLen2;

        px *= dp;
        py *= dp;
    }

    nearest.x = line.x1 + px;
    nearest.y = line.y1 + py;
    
    //  len2 of p
    var pLen2 = (px * px) + (py * py);
    
    return (
        pLen2 <= dLen2 &&
        ((px * dx) + (py * dy)) >= 0 &&
        Contains(circle, nearest.x, nearest.y)
    );
};

module.exports = LineToCircle;


/***/ }),
/* 143 */
/***/ (function(module, exports) {

var PointToLine = function (point, line)
{
    return ((point.x - line.x1) * (line.y2 - line.y1) === (line.x2 - line.x1) * (point.y - line.y1));
};

module.exports = PointToLine;


/***/ }),
/* 144 */
/***/ (function(module, exports) {

var RectangleToRectangle = function (rectA, rectB)
{
    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0)
    {
        return false;
    }

    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
};

module.exports = RectangleToRectangle;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

//  Defines a Line segment, a part of a line between two endpoints

var Line = new Class({

    initialize:

    function Line (x1, y1, x2, y2)
    {
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;

        this.setTo(x1, y1, x2, y2);
    },

    setTo: function (x1, y1, x2, y2)
    {
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }

        this.x1 = x1;
        this.y1 = y1;

        this.x2 = x2;
        this.y2 = y2;

        return this;
    },

    getPointA: function ()
    {
        return { x1: this.x1, y1: this.y1 };
    },

    getPointB: function ()
    {
        return { x1: this.x2, y1: this.y2 };
    },

    left: {

        get: function ()
        {
            return Math.min(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 <= this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    right: {

        get: function ()
        {
            return Math.max(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 > this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    top: {

        get: function ()
        {
            return Math.min(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 <= this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    },

    bottom: {

        get: function ()
        {
            return Math.max(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 > this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    }

});

module.exports = Line;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(13);
var Wrap = __webpack_require__(67);
var Angle = __webpack_require__(39);

var NormalAngle = function (line)
{
    var angle = Angle(line) - MATH_CONST.TAU;

    return Wrap(angle, -Math.PI, Math.PI);
};

module.exports = NormalAngle;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(12);

var Random = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var t = Math.random();

    out.x = line.x1 + t * (line.x2 - line.x1);
    out.y = line.y1 + t * (line.y2 - line.y1);

    return out;
};

module.exports = Random;


/***/ }),
/* 148 */
/***/ (function(module, exports) {

var GetMagnitude = function (point)
{
    return Math.sqrt((point.x * point.x) + (point.y * point.y));
};

module.exports = GetMagnitude;


/***/ }),
/* 149 */
/***/ (function(module, exports) {

var GetMagnitudeSq = function (point)
{
    return (point.x * point.x) + (point.y * point.y);
};

module.exports = GetMagnitudeSq;


/***/ }),
/* 150 */
/***/ (function(module, exports) {

var Multiply = function (point, x, y)
{
    point.x *= x;
    point.y *= y;

    return point;
};

module.exports = Multiply;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var GetMagnitude = __webpack_require__(148);

var Normalize = function (point)
{
    if (point.x !== 0 && point.y !== 0)
    {
        var m = GetMagnitude(point);

        point.x /= m;
        point.y /= m;
    }

    return point;
};

module.exports = Normalize;


/***/ }),
/* 152 */
/***/ (function(module, exports) {

/**
* Checks whether the x and y coordinates are contained within this polygon.
*/
var Contains = function (polygon, x, y)
{
    //  Adapted from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html by Jonas Raoni Soares Silva

    var inside = false;

    for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i)
    {
        var ix = polygon.points[i].x;
        var iy = polygon.points[i].y;

        var jx = polygon.points[j].x;
        var jy = polygon.points[j].y;

        if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))
        {
            inside = !inside;
        }
    }

    return inside;
};

module.exports = Contains;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
//  2.1.1 (Mar 17, 2016)

/*
ISC License

Copyright (c) 2016, Mapbox

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
 */



module.exports = earcut;

/*
vertices is a flat array of vertice coordinates like [x0,y0, x1,y1, x2,y2, ...].
holes is an array of hole indices if any (e.g. [5, 8] for a 12-vertice input would mean one hole with vertices 57 and another with 811).
dimensions is the number of coordinates per vertice in the input array (2 by default).
Each group of three vertice indices in the resulting array forms a triangle.
 */

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var Polygon = new Class({

    initialize:

    function Polygon (points)
    {
        // @property {number} area - The area of this Polygon.
        this.area = 0;

        // @property {array} points - An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]
        this.points = [];

        if (points)
        {
            this.setTo(points);
        }
    },

    /**
     * Sets this Polygon to the given points.
     *
     * The points can be set from a variety of formats:
     *
     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
     *
     * `setTo` may also be called without any arguments to remove all points.
     */
    setTo: function (points)
    {
        this.area = 0;
        this.points = [];

        if (!Array.isArray(points))
        {
            return this;
        }

        var entry;
        var y0 = Number.MAX_VALUE;
        var p;

        //  The points argument is an array, so iterate through it
        for (var i = 0; i < points.length; i++)
        {
            p = { x: 0, y: 0 };

            if (typeof points[i] === 'number')
            {
                p.x = points[i];
                p.y = points[i + 1];
                i++;
            }
            else if (Array.isArray(entry))
            {
                //  An array of arrays?
                p.x = points[i][0];
                p.y = points[i][1];
            }
            else
            {
                p.x = points[i].x;
                p.y = points[i].y;
            }

            this.points.push(p);

            //  Lowest boundary
            if (p.y < y0)
            {
                y0 = p.y;
            }
        }

        this.calculateArea(y0);

        return this;
    },

    /**
     * Calculates the area of the Polygon. This is available in the property Polygon.area
     */
    calculateArea: function (y0)
    {
        if (this.points.length < 3)
        {
            this.area = 0;

            return this.area;
        }

        var sum = 0;
        var p1;
        var p2;

        for (var i = 0; i < this.points.length - 1; i++)
        {
            p1 = this.points[i];
            p2 = this.points[i + 1];

            sum += (p2.x - p1.x) * (p1.y + p2.y);
        }

        p1 = this.points[0];
        p2 = this.points[this.points.length - 1];

        sum += (p1.x - p2.x) * (p2.y + p1.y);

        this.area = -sum * 0.5;

        // var p1;
        // var p2;
        // var avgHeight;
        // var width;

        // for (var i = 0, len = this.points.length; i < len; i++)
        // {
        //     p1 = this.points[i];

        //     if (i === len - 1)
        //     {
        //         p2 = this.points[0];
        //     }
        //     else
        //     {
        //         p2 = this.points[i + 1];
        //     }

        //     avgHeight = ((p1.y - y0) + (p2.y - y0)) / 2;
        //     width = p1.x - p2.x;
        //     this.area += avgHeight * width;
        // }

        return this.area;
    }

});

module.exports = Polygon;


/***/ }),
/* 155 */
/***/ (function(module, exports) {

/**
* Centers this Rectangle so that the center coordinates match the given x and y values.
*/
var CenterOn = function (rect, x, y)
{
    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = CenterOn;


/***/ }),
/* 156 */
/***/ (function(module, exports) {

var Decompose = function (rect, out)
{
    if (out === undefined) { out = []; }

    out.push({ x: rect.x, y: rect.y });
    out.push({ x: rect.right, y: rect.y });
    out.push({ x: rect.right, y: rect.bottom });
    out.push({ x: rect.x, y: rect.bottom });

    return out;
};

module.exports = Decompose;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var Perimeter = __webpack_require__(158);

//  Return an array of points from the perimeter of the rectangle
//  each spaced out based on the quantity or step required

var MarchingAnts = function (rect, step, quantity, out)
{
    if (out === undefined) { out = []; }

    if (!step && !quantity)
    {
        //  Bail out
        return out;
    }

    //  If step is a falsey value (false, null, 0, undefined, etc) then we calculate
    //  it based on the quantity instead, otherwise we always use the step value
    if (!step)
    {
        step = Perimeter(rect) / quantity;
    }
    else
    {
        quantity = Math.round(Perimeter(rect) / step);
    }

    var x = rect.x;
    var y = rect.y;
    var face = 0;

    //  Loop across each face of the rectangle

    for (var i = 0; i < quantity; i++)
    {
        out.push({ x: x, y: y });

        switch (face)
        {
            //  Top face
            case 0:
                x += step;

                if (x >= rect.right)
                {
                    face = 1;
                    y += (x - rect.right);
                    x = rect.right;
                }
                break;

            //  Right face
            case 1:
                y += step;

                if (y >= rect.bottom)
                {
                    face = 2;
                    x -= (y - rect.bottom);
                    y = rect.bottom;
                }
                break;

            //  Bottom face
            case 2:
                x -= step;

                if (x <= rect.left)
                {
                    face = 3;
                    y -= (rect.left - x);
                    x = rect.left;
                }
                break;

            //  Left face
            case 3:
                y -= step;

                if (y <= rect.top)
                {
                    face = 0;
                    y = rect.top;
                }
                break;
        }
    }

    return out;
};

module.exports = MarchingAnts;


/***/ }),
/* 158 */
/***/ (function(module, exports) {

var Perimeter = function (rect)
{
    return 2 * (rect.width + rect.height);
};

module.exports = Perimeter;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(12);

var Random = function (rect, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = rect.x + (Math.random() * rect.width);
    out.y = rect.y + (Math.random() * rect.height);

    return out;
};

module.exports = Random;


/***/ }),
/* 160 */
/***/ (function(module, exports) {

//  The three medians (the lines drawn from the vertices to the bisectors of the opposite sides)
//  meet in the centroid or center of mass (center of gravity).
//  The centroid divides each median in a ratio of 2:1

var Centroid = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = (triangle.x1 + triangle.x2 + triangle.x3) / 3;
    out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3;

    return out;
};

module.exports = Centroid;


/***/ }),
/* 161 */
/***/ (function(module, exports) {

var Decompose = function (triangle, out)
{
    if (out === undefined) { out = []; }

    out.push({ x: triangle.x1, y: triangle.y1 });
    out.push({ x: triangle.x2, y: triangle.y2 });
    out.push({ x: triangle.x3, y: triangle.y3 });

    return out;
};

module.exports = Decompose;


/***/ }),
/* 162 */
/***/ (function(module, exports) {

// The three angle bisectors of a triangle meet in one point called the incenter.
// It is the center of the incircle, the circle inscribed in the triangle.

function getLength (x1, y1, x2, y2)
{
    var x = x1 - x2;
    var y = y1 - y2;
    var magnitude = (x * x) + (y * y);

    return Math.sqrt(magnitude);
}

var InCenter = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var x1 = triangle.x1;
    var y1 = triangle.y1;

    var x2 = triangle.x2;
    var y2 = triangle.y2;

    var x3 = triangle.x3;
    var y3 = triangle.y3;

    var d1 = getLength(x3, y3, x2, y2);
    var d2 = getLength(x1, y1, x3, y3);
    var d3 = getLength(x2, y2, x1, y1);

    var p = d1 + d2 + d3;

    out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p;
    out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p;

    return out;
};

module.exports = InCenter;


/***/ }),
/* 163 */
/***/ (function(module, exports) {

var Offset = function (triangle, x, y)
{
    triangle.x1 += x;
    triangle.y1 += y;

    triangle.x2 += x;
    triangle.y2 += y;

    triangle.x3 += x;
    triangle.y3 += y;

    return triangle;
};

module.exports = Offset;


/***/ }),
/* 164 */
/***/ (function(module, exports) {


var Random = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    //  Basis vectors
    var ux = triangle.x2 - triangle.x1;
    var uy = triangle.y2 - triangle.y1;

    var vx = triangle.x3 - triangle.x1;
    var vy = triangle.y3 - triangle.y1;

    //  Random point within the unit square
    var r = Math.random();
    var s = Math.random();

    //  Point outside the triangle? Remap it.
    if (r + s >= 1)
    {
        r = 1 - r;
        s = 1 - s;
    }

    out.x = triangle.x1 + ((ux * r) + (vx * s));
    out.y = triangle.y1 + ((uy * r) + (vy * s));

    return out;
};

module.exports = Random;


/***/ }),
/* 165 */
/***/ (function(module, exports) {

/**
* Adds the source and backdrop colors together and returns the value, up to a maximum of 255.
*/
var Add = function (a, b)
{
    return Math.min(255, a + b);
};

module.exports = Add;


/***/ }),
/* 166 */
/***/ (function(module, exports) {

/**
* Darkens the backdrop color to reflect the source color.
* Painting with white produces no change. 
*/
var ColorBurn = function (a, b)
{
    return (b === 0) ? b : Math.max(0, (255 - ((255 - a) << 8) / b));
};

module.exports = ColorBurn;


/***/ }),
/* 167 */
/***/ (function(module, exports) {

/**
* Brightens the backdrop color to reflect the source color. 
* Painting with black produces no change.
*/
var ColorDodge = function (a, b)
{
    return (b === 255) ? b : Math.min(255, ((a << 8) / (255 - b)));
};

module.exports = ColorDodge;


/***/ }),
/* 168 */
/***/ (function(module, exports) {

/**
* Selects the darker of the backdrop and source colors.
*/
var Darken = function (a, b)
{
    return (b > a) ? a : b;
};

module.exports = Darken;


/***/ }),
/* 169 */
/***/ (function(module, exports) {

/**
* Selects the lighter of the backdrop and source colors.
*/
var Lighten = function (a, b)
{
    return (b > a) ? b : a;
};

module.exports = Lighten;


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var Subtract = __webpack_require__(174);

/**
* An alias for blendSubtract, it simply sums the values of the two colors and subtracts 255.
*/
var LinearBurn = function (a, b)
{
    return Subtract(a, b);
};

module.exports = LinearBurn;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var Add = __webpack_require__(165);

/**
* An alias for blendAdd, it simply sums the values of the two colors.
*/
var LinearDodge = function (a, b)
{
    return Add(a, b);
};

module.exports = LinearDodge;


/***/ }),
/* 172 */
/***/ (function(module, exports) {

/**
* Multiplies or screens the colors, depending on the backdrop color.
* Source colors overlay the backdrop while preserving its highlights and shadows. 
* The backdrop color is not replaced, but is mixed with the source color to reflect the lightness or darkness of the backdrop.
*/
var Overlay = function (a, b)
{
    return (b < 128) ? (2 * a * b / 255) : (255 - 2 * (255 - a) * (255 - b) / 255);
};

module.exports = Overlay;


/***/ }),
/* 173 */
/***/ (function(module, exports) {

/**
* Reflect blend mode. This mode is useful when adding shining objects or light zones to images. 
*/
var Reflect = function (a, b)
{
    return (b === 255) ? b : Math.min(255, (a * a / (255 - b)));
};

module.exports = Reflect;


/***/ }),
/* 174 */
/***/ (function(module, exports) {

/**
* Combines the source and backdrop colors and returns their value minus 255.
*/
var Subtract = function (a, b)
{
    return Math.max(0, a + b - 255);
};

module.exports = Subtract;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var ColorBurn = __webpack_require__(166);
var ColorDodge = __webpack_require__(167);

/**
* This blend mode combines Color Dodge and Color Burn (rescaled so that neutral colors become middle gray).
* Dodge applies when values in the top layer are lighter than middle gray, and burn to darker values.
* The middle gray is the neutral color. When color is lighter than this, this effectively moves the white point of the bottom 
* layer down by twice the difference; when it is darker, the black point is moved up by twice the difference. The perceived contrast increases.
*/
var VividLight = function (a, b)
{
    return (b < 128) ? ColorBurn(a, 2 * b) : ColorDodge(a, (2 * (b - 128)));
};

module.exports = VividLight;


/***/ }),
/* 176 */
/***/ (function(module, exports) {

//  Return a string containing a hex representation of the given color component.
//  @param {integer} color - The color channel to get the hex value for, must be a value between 0 and 255.
//  @return {string} A string of length 2 characters, i.e. 255 = ff, 100 = 64.
var ComponentToHex = function (color)
{
    var hex = color.toString(16);

    return (hex.length === 1) ? '0' + hex : hex;
};

module.exports = ComponentToHex;


/***/ }),
/* 177 */
/***/ (function(module, exports) {

/**
 * Given an alpha and 3 color values this will return an integer representation of it.
 */
var GetColor32 = function (red, green, blue, alpha)
{
    return alpha << 24 | red << 16 | green << 8 | blue;
};

module.exports = GetColor32;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var GetColor = __webpack_require__(100);

/**
 * Converts an HSV (hue, saturation and value) color value to RGB.
 * Conversion formula from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes HSV values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].
 * Based on code by Michael Jackson (https://github.com/mjijackson)
 */
var HSVToRGB = function (h, s, v)
{
    if (s === undefined) { s = 1; }
    if (v === undefined) { v = 1; }

    var i = Math.floor(h * 6);
    var f = h * 6 - i;

    var p = Math.floor((v * (1 - s)) * 255);
    var q = Math.floor((v * (1 - f * s)) * 255);
    var t = Math.floor((v * (1 - (1 - f) * s)) * 255);

    v = Math.floor(v *= 255);

    var output = { r: v, g: v, b: v, color: 0 };

    var r = i % 6;

    if (r === 0)
    {
        output.g = t;
        output.b = p;
    }
    else if (r === 1)
    {
        output.r = q;
        output.b = p;
    }
    else if (r === 2)
    {
        output.r = p;
        output.b = t;
    }
    else if (r === 3)
    {
        output.r = p;
        output.g = q;
    }
    else if (r === 4)
    {
        output.r = t;
        output.g = p;
    }
    else if (r === 5)
    {
        output.g = p;
        output.b = q;
    }

    output.color = GetColor(output.r, output.g, output.b);

    return output;
};

module.exports = HSVToRGB;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var Color = __webpack_require__(33);

/**
* Converts a hex string into a Phaser Color object.
*
* The hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional "#" or "0x", or be unprefixed.    
*
* An alpha channel is _not_ supported.
*/
var HexStringToColor = function (hex)
{
    var color = new Color();

    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });

    var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

    if (result)
    {
        var r = parseInt(result[1], 16);
        var g = parseInt(result[2], 16);
        var b = parseInt(result[3], 16);

        color.setTo(r, g, b);
    }

    return color;
};

module.exports = HexStringToColor;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {/**
* Converts a hue to an RGB color.
* Based on code by Michael Jackson (https://github.com/mjijackson)
*/
var HueToComponent = function (p, q, t)
{
    if (t < 0)
    {
        t += 1;
    }

    if (t > 1)
    {
        t -= 1;
    }

    if (t < 1 / 6)
    {
        return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2)
    {
        return q;
    }

    if (t < 2 / 3)
    {
        return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
};

module.export = HueToComponent;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(276)(module)))

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var Color = __webpack_require__(33);
var IntegerToRGB = __webpack_require__(182);

var IntegerToColor = function (input)
{
    var rgb = IntegerToRGB(input);

    return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
};

module.exports = IntegerToColor;


/***/ }),
/* 182 */
/***/ (function(module, exports) {

/**
* Return the component parts of a color as an Object with the properties alpha, red, green, blue.
*
* Alpha will only be set if it exists in the given color (0xAARRGGBB)
*/
var IntegerToRGB = function (color)
{
    if (color > 16777215)
    {
        //  The color value has an alpha component
        return {
            a: color >>> 24,
            r: color >> 16 & 0xFF,
            g: color >> 8 & 0xFF,
            b: color & 0xFF
        };
    }
    else
    {
        return {
            a: 255,
            r: color >> 16 & 0xFF,
            g: color >> 8 & 0xFF,
            b: color & 0xFF
        };
    }
};

module.exports = IntegerToRGB;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var Color = __webpack_require__(33);

/**
* Converts a CSS 'web' string into a Phaser Color object.
*
* The web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].
*/
var RGBStringToColor = function (rgb)
{
    var color = new Color();

    var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(rgb.toLowerCase());

    if (result)
    {
        var r = parseInt(result[1], 10);
        var g = parseInt(result[2], 10);
        var b = parseInt(result[3], 10);
        var a = (result[4] !== undefined) ? parseFloat(result[4]) : 1;

        color.setTo(r, g, b, a * 255);
    }

    return color;
};

module.exports = RGBStringToColor;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var NOOP = __webpack_require__(3);

//  Phaser.Input.InteractiveObject

var InteractiveObject = function (gameObject, hitArea, hitAreaCallback)
{
    return {

        gameObject: gameObject,

        enabled: true,
        draggable: false,
        dropZone: false,

        target: null,

        camera: null,

        hitArea: hitArea,
        hitAreaCallback: hitAreaCallback,

        localX: 0,
        localY: 0,

        //  0 = Not being dragged
        //  1 = Being checked for dragging
        //  2 = Being dragged
        dragState: 0,

        dragStartX: 0,
        dragStartY: 0,

        dragX: 0,
        dragY: 0,

        //  Callbacks

        callbackContext: gameObject,

        //  gameObject, pointer, x, y
        onUp: NOOP,

        //  gameObject, pointer, x, y
        onDown: NOOP,

        //  gameObject, pointer, x, y
        onOver: NOOP,

        //  gameObject, pointer
        onOut: NOOP,

        //  gameObject, pointer, x, y
        onMove: NOOP,

        onDragStart: NOOP,
        onDrag: NOOP,
        onDragEnd: NOOP

    };
};

module.exports = InteractiveObject;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Gamepad.Axis

var Class = __webpack_require__(0);
var GamepadEvent = __webpack_require__(64);

var Axis = new Class({

    initialize:

    function Axis (pad, index)
    {
        this.pad = pad;

        this.events = pad.events;

        this.index = index;

        //  Between -1 and 1 with 0 being dead center
        this.value = 0;

        this.threshold = 0.05;
    },

    update: function (value)
    {
        this.value = value;
    },

    //  Applies threshold to the value and returns it
    getValue: function ()
    {
        var percentage = (Math.abs(this.value) - this.threshold) / (1 - this.threshold);

        if (percentage < 0)
        {
            percentage = 0;
        }

       return percentage * (this.value > 0 ? 1 : -1);
    }

});

module.exports = Axis;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Gamepad.Button

var Class = __webpack_require__(0);
var GamepadEvent = __webpack_require__(64);

var Button = new Class({

    initialize:

    function Button (pad, index)
    {
        this.pad = pad;

        this.events = pad.events;

        this.index = index;

        //  Between 0 and 1
        this.value = 0;

        //  Can be set for Analogue buttons to enable a 'pressure' threshold before considered as 'pressed'
        this.threshold = 0;

        this.pressed = false;
    },

    update: function (data)
    {
        this.value = data.value;

        if (this.value >= this.threshold)
        {
            if (!this.pressed)
            {
                this.pressed = true;
                this.events.dispatch(new GamepadEvent.DOWN(this.pad, this, this.value, data));
            }
        }
        else
        {
            if (this.pressed)
            {
                this.pressed = false;
                this.events.dispatch(new GamepadEvent.UP(this.pad, this, this.value, data));
            }
        }
    }

});

module.exports = Button;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Gamepad.Gamepad

var Axis = __webpack_require__(185);
var Button = __webpack_require__(186);
var Class = __webpack_require__(0);
var GamepadEvent = __webpack_require__(64);

var Gamepad = new Class({

    initialize:

    function Gamepad (manager, id, index)
    {
        this.manager = manager;

        this.events = manager.events;

        this.id = id;

        this.index = index;

        this.connected = true;

        this.timestamp = 0;

        this.buttons = [];
        this.axes = [];
    },

    update: function (data)
    {
        this.timestamp = data.timestamp;
        this.connected = data.connected;

        //  Buttons

        for (var i = 0; i < data.buttons.length; i++)
        {
            var buttonData = data.buttons[i];

            if (this.buttons[i] === undefined)
            {
                this.buttons[i] = new Button(this, i);
            }

            this.buttons[i].update(buttonData);
        }

        //  Axes
        for (var i = 0; i < data.axes.length; i++)
        {
            var axisData = data.axes[i];

            if (this.axes[i] === undefined)
            {
                this.axes[i] = new Axis(this, i);
            }

            this.axes[i].update(axisData);
        }
    }

});

module.exports = Gamepad;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Gamepad.GamepadManager

var Class = __webpack_require__(0);
var Gamepad = __webpack_require__(187);
var GamepadEvent = __webpack_require__(64);

// https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API
// https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API
// https://www.smashingmagazine.com/2015/11/gamepad-api-in-web-games/
// http://html5gamepad.com/

var GamepadManager = new Class({

    initialize:

    function GamepadManager (inputManager)
    {
        this.manager = inputManager;

        this.events = inputManager.events;

        this.enabled = false;

        this.target;

        this.handler;

        this.gamepads = [];

        //   Standard FIFO queue
        this.queue = [];
    },

    boot: function ()
    {
        var config = this.manager.config;

        this.enabled = config.inputGamepad && this.manager.game.device.Input.gamepads;

        this.target = window;

        if (this.enabled)
        {
            this.startListeners();
        }
    },

    startListeners: function ()
    {
        var queue = this.queue;

        var handler = function (event)
        {
            if (event.preventDefaulted)
            {
                // Do nothing if event already handled
                return;
            }

            queue.push(event);
        };

        this.handler = handler;

        this.target.addEventListener('gamepadconnected', handler, false);
        this.target.addEventListener('gamepaddisconnected', handler, false);

        //  FF only for now:
        this.target.addEventListener('gamepadbuttondown', handler, false);
        this.target.addEventListener('gamepadbuttonup', handler, false);
        this.target.addEventListener('gamepadaxismove', handler, false);
    },

    stopListeners: function ()
    {
        this.target.removeEventListener('gamepadconnected', this.handler);
        this.target.removeEventListener('gamepaddisconnected', this.handler);

        this.target.removeEventListener('gamepadbuttondown', this.handler);
        this.target.removeEventListener('gamepadbuttonup', this.handler);
        this.target.removeEventListener('gamepadaxismove', this.handler);
    },

    disconnectAll: function ()
    {
        for (var i = 0; i < this.gamepads.length; i++)
        {
            this.gamepads.connected = false;
        }
    },

    addPad: function (pad)
    {
        var gamepad = new Gamepad(this, pad.id, pad.index);

        this.gamepads[pad.index] = gamepad;

        return gamepad;
    },

    removePad: function (index, pad)
    {
    },

    refreshPads: function (pads)
    {
        if (!pads)
        {
            this.disconnectAll();
        }
        else
        {
            for (var i = 0; i < pads.length; i++)
            {
                var pad = pads[i];

                if (!pad)
                {
                    //  removePad?
                    continue;
                }

                if (this.gamepads[pad.index] === undefined)
                {
                    this.addPad(pad);
                }

                this.gamepads[pad.index].update(pad);
            }
        }
    },

    getAll: function ()
    {
        var out = [];

        for (var i = 0; i < this.gamepads.length; i++)
        {
            if (this.gamepads[i])
            {
                out.push(this.gamepads[i]);
            }
        }

        return out;
    },

    getPad: function (index)
    {
        for (var i = 0; i < this.gamepads.length; i++)
        {
            if (this.gamepads[i].index === index)
            {
                return this.gamepads[i];
            }
        }
    },

    update: function ()
    {
        if (!this.enabled)
        {
            return;
        }

        this.refreshPads(navigator.getGamepads());

        var len = this.queue.length;

        if (len === 0)
        {
            return;
        }

        var queue = this.queue.splice(0, len);

        //  Process the event queue, dispatching all of the events that have stored up
        for (var i = 0; i < len; i++)
        {
            var event = queue[i];
            var pad;

            switch (event.type)
            {
                case 'gamepadconnected':

                    pad = this.getPad(event.gamepad.index);

                    this.events.dispatch(new GamepadEvent.CONNECTED(pad, event));

                    break;

                case 'gamepaddisconnected':

                    pad = this.getPad(event.gamepad.index);

                    this.events.dispatch(new GamepadEvent.DISCONNECTED(pad, event));

                    break;
            }
        }
    },

    total: {

        get: function ()
        {
            return this.gamepads.length;
        }

    }

});

module.exports = GamepadManager;


/***/ }),
/* 189 */
/***/ (function(module, exports) {

//  x/y MUST be translated before being passed to this function, unless the gameObject is guarnateed to
//  be not rotated or scaled in any way

var PointWithinGameObject = function (gameObject, x, y)
{
    if (!gameObject.hitArea)
    {
        return false;
    }

    //  Normalize the origin
    x += gameObject.displayOriginX;
    y += gameObject.displayOriginY;

    return gameObject.hitAreaCallback(gameObject.hitArea, x, y);
};

module.exports = PointWithinGameObject;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(719);
var Key = __webpack_require__(193);
var KeyCodes = __webpack_require__(102);
var KeyCombo = __webpack_require__(191);
var ProcessKeyCombo = __webpack_require__(192);
var ProcessKeyDown = __webpack_require__(724);
var ProcessKeyUp = __webpack_require__(725);

/**
* The Keyboard class monitors keyboard input and dispatches keyboard events.
*
* _Note_: many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
* See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.
*
* Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.
* For example the Chrome extension vimium is known to disable Phaser from using the D key. And there are others.
* So please check your extensions before opening Phaser issues.
*/

var KeyboardManager = new Class({

    initialize:

    function KeyboardManager (inputManager)
    {
        this.manager = inputManager;

        this.enabled = false;

        this.target;

        this.keys = [];

        this.combos = [];

        this.captures = [];

        //   Standard FIFO queue
        this.queue = [];

        this.handler;
    },

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    */
    boot: function ()
    {
        var config = this.manager.config;

        this.enabled = config.inputKeyboard;
        this.target = config.inputKeyboardEventTarget;

        if (this.enabled)
        {
            this.startListeners();
        }
    },

    startListeners: function ()
    {
        var queue = this.queue;
        var captures = this.captures;

        var handler = function (event)
        {
            if (event.preventDefaulted)
            {
                // Do nothing if event already handled
                return;
            }

            queue.push(event);

            if (captures[event.keyCode])
            {
                event.preventDefault();
            }
        };

        this.handler = handler;

        this.target.addEventListener('keydown', handler, false);
        this.target.addEventListener('keyup', handler, false);
    },

    stopListeners: function ()
    {
        this.target.removeEventListener('keydown', this.handler);
        this.target.removeEventListener('keyup', this.handler);
    },

    /**
    * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right and also space and shift.
    */
    createCursorKeys: function ()
    {
        return this.addKeys({
            up: KeyCodes.UP,
            down: KeyCodes.DOWN,
            left: KeyCodes.LEFT,
            right: KeyCodes.RIGHT,
            space: KeyCodes.SPACE,
            shift: KeyCodes.SHIFT
        });
    },

    /**
    * A practical way to create an object containing user selected hotkeys.
    *
    * For example,
    *
    *     addKeys( { 'up': Phaser.KeyCode.W, 'down': Phaser.KeyCode.S, 'left': Phaser.KeyCode.A, 'right': Phaser.KeyCode.D } );
    *
    * would return an object containing properties (`up`, `down`, `left` and `right`) referring to {@link Phaser.Key} object.
    */
    addKeys: function (keys)
    {
        var output = {};

        for (var key in keys)
        {
            output[key] = this.addKey(keys[key]);
        }

        return output;
    },

    /**
    * If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.
    * The Key object can then be polled, have events attached to it, etc.
    */
    addKey: function (keyCode)
    {
        var keys = this.keys;

        if (!keys[keyCode])
        {
            keys[keyCode] = new Key(keyCode);
            this.captures[keyCode] = true;
        }

        return keys[keyCode];
    },

    /**
    * Removes a Key object from the Keyboard manager.
    */
    removeKey: function (keyCode)
    {
        if (this.keys[keyCode])
        {
            this.keys[keyCode] = undefined;
            this.captures[keyCode] = false;
        }
    },

    addKeyCapture: function (keyCodes)
    {
        if (!Array.isArray(keyCodes))
        {
            keyCodes = [ keyCodes ];
        }

        for (var i = 0; i < keyCodes.length; i++)
        {
            this.captures[keyCodes[i]] = true;
        }
    },

    removeKeyCapture: function (keyCodes)
    {
        if (!Array.isArray(keyCodes))
        {
            keyCodes = [ keyCodes ];
        }

        for (var i = 0; i < keyCodes.length; i++)
        {
            this.captures[keyCodes[i]] = false;
        }
    },

    createCombo: function (keys, config)
    {
        return new KeyCombo(this, keys, config);
    },

    //  https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent
    //  type = 'keydown', 'keyup'
    //  keyCode = integer

    update: function ()
    {
        var len = this.queue.length;

        if (!this.enabled || len === 0)
        {
            return;
        }

        //  Clears the queue array, and also means we don't work on array data that could potentially
        //  be modified during the processing phase
        var queue = this.queue.splice(0, len);

        var keys = this.keys;
        var singleKey;

        //  Process the event queue, dispatching all of the events that have stored up
        for (var i = 0; i < len; i++)
        {
            var event = queue[i];

            if (event.type === 'keydown')
            {
                this.manager.events.dispatch(new Event.KEY_DOWN_EVENT(event));

                singleKey = Event._DOWN[event.keyCode];

                if (singleKey)
                {
                    this.manager.events.dispatch(new singleKey(event));
                }

                if (keys[event.keyCode])
                {
                    ProcessKeyDown(keys[event.keyCode], event);
                }
            }
            else
            {
                this.manager.events.dispatch(new Event.KEY_UP_EVENT(event));

                singleKey = Event._UP[event.keyCode];

                if (singleKey)
                {
                    this.manager.events.dispatch(new singleKey(event));
                }

                if (keys[event.keyCode])
                {
                    ProcessKeyUp(keys[event.keyCode], event);
                }
            }
        }
    }

});

module.exports = KeyboardManager;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GetFastValue = __webpack_require__(11);
var KeyComboMatchEvent = __webpack_require__(715);
var ProcessKeyCombo = __webpack_require__(192);
var ResetKeyCombo = __webpack_require__(716);

//  Keys can be either:
//
//  A string (ATARI)
//  An array of either integers (key codes) or strings, or a mixture of both
//  An array of objects (such as Key objects) with a public 'keyCode' property

var KeyCombo = new Class({

    initialize:

    function KeyCombo (keyboardManager, keys, config)
    {
        if (config === undefined) { config = {}; }

        //  Can't have a zero or single length combo (string or array based)
        if (keys.length < 2)
        {
            return false;
        }

        this.manager = keyboardManager;

        this.enabled = true;

        this.keyCodes = [];

        //  if 'keys' is a string we need to get the keycode of each character in it

        for (var i = 0; i < keys.length; i++)
        {
            var char = keys[i];

            if (typeof char === 'string')
            {
                this.keyCodes.push(char.toUpperCase().charCodeAt(0));
            }
            else if (typeof char === 'number')
            {
                this.keyCodes.push(char);
            }
            else if (char.hasOwnProperty('keyCode'))
            {
                this.keyCodes.push(char.keyCode);
            }
        }

        //  The current keyCode the combo is waiting for
        this.current = this.keyCodes[0];

        //  The current index of the key being waited for in the 'keys' string
        this.index = 0;

        //  The length of this combo (in keycodes)
        this.size = this.keyCodes.length;

        //  The time the previous key in the combo was matched
        this.timeLastMatched = 0;

        //  Has this Key Combo been matched yet?
        this.matched = false;

        //  The time the entire combo was matched
        this.timeMatched = 0;

        //  Custom options ...

        //  If they press the wrong key do we reset the combo?
        this.resetOnWrongKey = GetFastValue(config, 'resetOnWrongKey', true);

        //  The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.
        this.maxKeyDelay = GetFastValue(config, 'maxKeyDelay', 0);

        //  If previously matched and they press Key 1 again, will it reset?
        this.resetOnMatch = GetFastValue(config, 'resetOnMatch', false);

        //  If the combo matches, will it delete itself?
        this.deleteOnMatch = GetFastValue(config, 'deleteOnMatch', false);

        var _this = this;

        var onKeyDownHandler = function (event)
        {
            if (_this.matched || !_this.enabled)
            {
                return;
            }

            var matched = ProcessKeyCombo(event.data, _this);

            if (matched)
            {
                _this.manager.events.dispatch(new KeyComboMatchEvent(_this, event));

                if (_this.resetOnMatch)
                {
                    ResetKeyCombo(_this);
                }
                else if (_this.deleteOnMatch)
                {
                    _this.destroy();
                }
            }
        };

        this.onKeyDown = onKeyDownHandler;

        this.manager.events.on('KEY_DOWN_EVENT', onKeyDownHandler);
    },

    progress: {

        //  How far complete is this combo? A value between 0 and 1.
        get: function ()
        {
            return this.index / this.size;
        }

    },

    destroy: function ()
    {
        this.enabled = false;
        this.keyCodes = [];

        this.manager.events.off('KEY_DOWN', this.onKeyDown);
        this.manager = undefined;
    }

});

module.exports = KeyCombo;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var AdvanceKeyCombo = __webpack_require__(714);

var ProcessKeyCombo = function (event, combo)
{
    if (combo.matched)
    {
        return true;
    }

    var comboMatched = false;
    var keyMatched = false;

    if (event.keyCode === combo.current)
    {
        //  Key was correct

        if (combo.index > 0 && combo.maxKeyDelay > 0)
        {
            //  We have to check to see if the delay between
            //  the new key and the old one was too long (if enabled)

            var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;

            //  Check if they pressed it in time or not
            if (event.timeStamp <= timeLimit)
            {
                keyMatched = true;
                comboMatched = AdvanceKeyCombo(event, combo);
            }
        }
        else
        {
            keyMatched = true;

            //  We don't check the time for the first key pressed, so just advance it
            comboMatched = AdvanceKeyCombo(event, combo);
        }
    }

    if (!keyMatched && combo.resetOnWrongKey)
    {
        //  Wrong key was pressed
        combo.index = 0;
        combo.current = combo.keyCodes[0];
    }

    if (comboMatched)
    {
        combo.timeLastMatched = event.timeStamp;
        combo.matched = true;
        combo.timeMatched = event.timeStamp;
    }

    return comboMatched;
};

module.exports = ProcessKeyCombo;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

//  Phaser.Input.Keyboard.Key

//  A generic Key object which can be passed to the Process functions (and so on)
//  keycode must be an integer

var Key = new Class({

    initialize:

    function Key (keyCode)
    {
        //  @property {integer} keyCode - The keycode of this key.
        this.keyCode = keyCode;

        //  @property {KeyboardEvent} originalEvent - The original DOM event.
        this.originalEvent = undefined;

        //  @property {boolean} preventDefault - Should this Key prevent event propagation?
        //  @default
        this.preventDefault = true;

        //  @property {boolean} enabled - Can this Key be processed?
        //  @default
        this.enabled = true;

        //  @property {boolean} isDown - The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
        //  @default
        this.isDown = false;

        //  @property {boolean} isUp - The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
        //  @default
        this.isUp = true;

        //  @property {boolean} altKey - The down state of the ALT key, if pressed at the same time as this key.
        //  @default
        this.altKey = false;

        //  @property {boolean} ctrlKey - The down state of the CTRL key, if pressed at the same time as this key.
        //  @default
        this.ctrlKey = false;

        //  @property {boolean} shiftKey - The down state of the SHIFT key, if pressed at the same time as this key.
        //  @default
        this.shiftKey = false;

        //  @property {integer} location - The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.
        //  @default
        this.location = 0;

        //  @property {number} timeDown - The timestamp when the key was last pressed down. This is based on Game.time.now.
        this.timeDown = 0;

        //  If the key is down this value holds the duration of that key press and is constantly updated.
        //  If the key is up it holds the duration of the previous down session.
        //  @property {number} duration - The number of milliseconds this key has been held down for.
        //  @default
        this.duration = 0;

        //  @property {number} timeUp - The timestamp when the key was last released. This is based on Game.time.now.
        //  @default
        this.timeUp = 0;

        //  @property {number} repeats - If a key is held down this holds down the number of times the key has 'repeated'.
        //  @default
        this.repeats = 0;

         // @property {boolean} _justDown - True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
         // @private
         this._justDown = false;

         // @property {boolean} _justUp - True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
         // @private
         this._justUp = false;
    }

});

module.exports = Key;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

//  https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
//  https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md

var MouseManager = new Class({

    initialize:

    function MouseManager (inputManager)
    {
        this.manager = inputManager;

        // @property {boolean} capture - If true the DOM mouse events will have event.preventDefault applied to them, if false they will propagate fully.
        this.capture = false;

        this.enabled = false;

        this.target;

        this.handler;
    },

    boot: function ()
    {
        var config = this.manager.config;

        this.enabled = config.inputMouse;
        this.target = config.inputMouseEventTarget;

        if (!this.target)
        {
            this.target = this.manager.game.canvas;
        }

        if (config.disableContextMenu)
        {
            this.disableContextMenu();
        }

        if (this.enabled)
        {
            this.startListeners();
        }
    },

    disableContextMenu: function ()
    {
        document.body.addEventListener('contextmenu', function (event)
        {
            event.preventDefault();
            return false;
        });

        return this;
    },

    startListeners: function ()
    {
        var queue = this.manager.queue;

        var _this = this;

        var handler = function (event)
        {
            if (event.preventDefaulted)
            {
                // Do nothing if event already handled
                return;
            }

            queue.push(event);

            if (_this.capture)
            {
                event.preventDefault();
            }
        };

        this.handler = handler;

        this.target.addEventListener('mousemove', handler, false);
        this.target.addEventListener('mousedown', handler, false);
        this.target.addEventListener('mouseup', handler, false);
    },

    stopListeners: function ()
    {
        this.target.removeEventListener('mousemove', this.handler);
        this.target.removeEventListener('mousedown', this.handler);
        this.target.removeEventListener('mouseup', this.handler);
    }

});

module.exports = MouseManager;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var XHRSettings = __webpack_require__(103);

//  Takes two XHR Objects and creates a new object

//  The new object is based on global initially, but any setting in
//  local overrides the global value.

var MergeXHRSettings = function (global, local)
{
    var output = (global === undefined) ? XHRSettings() : Object.assign(global);

    if (local)
    {
        for (var setting in local)
        {
            if (local[setting] !== undefined)
            {
                output[setting] = local[setting];
            }
        }
    }

    return output;
};

module.exports = MergeXHRSettings;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(16);
var File = __webpack_require__(19);

//  Phaser.Loader.FileTypes.TextFile

var TextFile = new Class({

    Extends: File,

    initialize:

    function TextFile (key, url, path, xhrSettings)
    {
        var fileConfig = {
            type: 'text',
            extension: 'txt',
            responseType: 'text',
            key: key,
            url: url,
            path: path,
            xhrSettings: xhrSettings
        };

        File.call(this, fileConfig);
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.data = this.xhrLoader.responseText;

        this.onComplete();

        callback(this);
    }

});

TextFile.create = function (loader, key, url, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new TextFile(key[i], url, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new TextFile(key, url, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = TextFile;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(16);
var File = __webpack_require__(19);
var GetFastValue = __webpack_require__(11);
var ParseXML = __webpack_require__(132);

//  Phaser.Loader.FileTypes.XMLFile

var XMLFile = new Class({

    Extends: File,

    initialize:

    function XMLFile (key, url, path, xhrSettings)
    {
        var fileKey = (typeof key === 'string') ? key : GetFastValue(key, 'key', '');

        var fileConfig = {
            type: 'xml',
            extension: GetFastValue(key, 'extension', 'xml'),
            responseType: 'text',
            key: fileKey,
            url: GetFastValue(key, 'file', url),
            path: path,
            xhrSettings: GetFastValue(key, 'xhr', xhrSettings)
        };

        File.call(this, fileConfig);
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.data = ParseXML(this.xhrLoader.responseText);

        if (this.data === null)
        {
            throw new Error('XMLFile: Invalid XML');
        }

        this.onComplete();

        callback(this);
    }

});

XMLFile.create = function (loader, key, url, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new XMLFile(key[i], url, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new XMLFile(key, url, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = XMLFile;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var Factorial = __webpack_require__(199);

var Bernstein = function (n, i)
{
    return Factorial(n) / Factorial(i) / Factorial(n - i);
};

module.exports = Bernstein;


/***/ }),
/* 199 */
/***/ (function(module, exports) {

var Factorial = function (value)
{
    if (value === 0)
    {
        return 1;
    }

    var res = value;

    while (--value)
    {
        res *= value;
    }

    return res;
};

module.exports = Factorial;


/***/ }),
/* 200 */
/***/ (function(module, exports) {

var Linear = function (p0, p1, t)
{
    return (p1 - p0) * t + p0;
};

module.exports = Linear;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji 
//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl

var Class = __webpack_require__(0);

var Matrix3 = new Class({

    initialize:

    function Matrix3 (m)
    {
        this.val = new Float32Array(9);

        if (m)
        {
            //  Assume Matrix3 with val:
            this.copy(m);
        }
        else
        {
            //  Default to identity
            this.identity();
        }
    },

    clone: function ()
    {
        return new Matrix3(this);
    },

    set: function (src)
    {
        return this.copy(src);
    },

    copy: function (src)
    {
        var out = this.val;
        var a = src.val;

        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];

        return this;
    },

    fromMat4: function (m)
    {
        var a = m.val;
        var out = this.val;

        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[4];
        out[4] = a[5];
        out[5] = a[6];
        out[6] = a[8];
        out[7] = a[9];
        out[8] = a[10];

        return this;
    },

    fromArray: function (a)
    {
        var out = this.val;

        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];

        return this;
    },

    identity: function ()
    {
        var out = this.val;

        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 1;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;

        return this;
    },

    transpose: function ()
    {
        var a = this.val;
        var a01 = a[1];
        var a02 = a[2];
        var a12 = a[5];

        a[1] = a[3];
        a[2] = a[6];
        a[3] = a01;
        a[5] = a[7];
        a[6] = a02;
        a[7] = a12;

        return this;
    },

    invert: function ()
    {
        var a = this.val;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a10 = a[3];
        var a11 = a[4];
        var a12 = a[5];
        var a20 = a[6];
        var a21 = a[7];
        var a22 = a[8];

        var b01 = a22 * a11 - a12 * a21;
        var b11 = -a22 * a10 + a12 * a20;
        var b21 = a21 * a10 - a11 * a20;

        // Calculate the determinant
        var det = a00 * b01 + a01 * b11 + a02 * b21;

        if (!det)
        {
            return null;
        }

        det = 1 / det;

        a[0] = b01 * det;
        a[1] = (-a22 * a01 + a02 * a21) * det;
        a[2] = (a12 * a01 - a02 * a11) * det;
        a[3] = b11 * det;
        a[4] = (a22 * a00 - a02 * a20) * det;
        a[5] = (-a12 * a00 + a02 * a10) * det;
        a[6] = b21 * det;
        a[7] = (-a21 * a00 + a01 * a20) * det;
        a[8] = (a11 * a00 - a01 * a10) * det;

        return this;
    },

    adjoint: function ()
    {
        var a = this.val;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a10 = a[3];
        var a11 = a[4];
        var a12 = a[5];
        var a20 = a[6];
        var a21 = a[7];
        var a22 = a[8];

        a[0] = (a11 * a22 - a12 * a21);
        a[1] = (a02 * a21 - a01 * a22);
        a[2] = (a01 * a12 - a02 * a11);
        a[3] = (a12 * a20 - a10 * a22);
        a[4] = (a00 * a22 - a02 * a20);
        a[5] = (a02 * a10 - a00 * a12);
        a[6] = (a10 * a21 - a11 * a20);
        a[7] = (a01 * a20 - a00 * a21);
        a[8] = (a00 * a11 - a01 * a10);

        return this;
    },

    determinant: function ()
    {
        var a = this.val;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a10 = a[3];
        var a11 = a[4];
        var a12 = a[5];
        var a20 = a[6];
        var a21 = a[7];
        var a22 = a[8];

        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
    },

    multiply: function (src)
    {
        var a = this.val;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a10 = a[3];
        var a11 = a[4];
        var a12 = a[5];
        var a20 = a[6];
        var a21 = a[7];
        var a22 = a[8];

        var b = src.val;

        var b00 = b[0];
        var b01 = b[1];
        var b02 = b[2];
        var b10 = b[3];
        var b11 = b[4];
        var b12 = b[5];
        var b20 = b[6];
        var b21 = b[7];
        var b22 = b[8];

        a[0] = b00 * a00 + b01 * a10 + b02 * a20;
        a[1] = b00 * a01 + b01 * a11 + b02 * a21;
        a[2] = b00 * a02 + b01 * a12 + b02 * a22;

        a[3] = b10 * a00 + b11 * a10 + b12 * a20;
        a[4] = b10 * a01 + b11 * a11 + b12 * a21;
        a[5] = b10 * a02 + b11 * a12 + b12 * a22;

        a[6] = b20 * a00 + b21 * a10 + b22 * a20;
        a[7] = b20 * a01 + b21 * a11 + b22 * a21;
        a[8] = b20 * a02 + b21 * a12 + b22 * a22;

        return this;
    },

    translate: function (v)
    {
        var a = this.val;
        var x = v.x;
        var y = v.y;

        a[6] = x * a[0] + y * a[3] + a[6];
        a[7] = x * a[1] + y * a[4] + a[7];
        a[8] = x * a[2] + y * a[5] + a[8];

        return this;
    },

    rotate: function (rad)
    {
        var a = this.val;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a10 = a[3];
        var a11 = a[4];
        var a12 = a[5];

        var s = Math.sin(rad);
        var c = Math.cos(rad);

        a[0] = c * a00 + s * a10;
        a[1] = c * a01 + s * a11;
        a[2] = c * a02 + s * a12;

        a[3] = c * a10 - s * a00;
        a[4] = c * a11 - s * a01;
        a[5] = c * a12 - s * a02;

        return this;
    },

    scale: function (v)
    {
        var a = this.val;
        var x = v.x;
        var y = v.y;

        a[0] = x * a[0];
        a[1] = x * a[1];
        a[2] = x * a[2];

        a[3] = y * a[3];
        a[4] = y * a[4];
        a[5] = y * a[5];

        return this;
    },

    fromQuat: function (q)
    {
        var x = q.x;
        var y = q.y;
        var z = q.z;
        var w = q.w;

        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;

        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;

        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;

        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;

        var out = this.val;

        out[0] = 1 - (yy + zz);
        out[3] = xy + wz;
        out[6] = xz - wy;

        out[1] = xy - wz;
        out[4] = 1 - (xx + zz);
        out[7] = yz + wx;

        out[2] = xz + wy;
        out[5] = yz - wx;
        out[8] = 1 - (xx + yy);

        return this;
    },

    normalFromMat4: function (m)
    {
        var a = m.val;
        var out = this.val;

        var a00 = a[0];
        var a01 = a[1];
        var a02 = a[2];
        var a03 = a[3];

        var a10 = a[4];
        var a11 = a[5];
        var a12 = a[6];
        var a13 = a[7];

        var a20 = a[8];
        var a21 = a[9];
        var a22 = a[10];
        var a23 = a[11];

        var a30 = a[12];
        var a31 = a[13];
        var a32 = a[14];
        var a33 = a[15];

        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;

        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;

        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;

        // Calculate the determinant
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det)
        {
            return null;
        }

        det = 1 / det;

        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

        return this;
    }

});

Matrix3.prototype.mul = Matrix3.prototype.multiply;
Matrix3.prototype.idt = Matrix3.prototype.identity;
Matrix3.prototype.reset = Matrix3.prototype.identity;

module.exports = Matrix3;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji 
//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl

var Class = __webpack_require__(0);
var Vector3 = __webpack_require__(34);
var Matrix3 = __webpack_require__(201);

var EPSILON = 0.000001;

//  Some shared 'private' arrays
var siNext = new Int8Array([ 1, 2, 0 ]);
var tmp = new Float32Array([ 0, 0, 0 ]);

var xUnitVec3 = new Vector3(1, 0, 0);
var yUnitVec3 = new Vector3(0, 1, 0);

var tmpvec = new Vector3();
var tmpMat3 = new Matrix3();

var Quaternion = new Class({

    initialize:

    function Quaternion (x, y, z, w)
    {
        if (typeof x === 'object')
        {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
            this.w = x.w || 0;
        }
        else
        {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
        }
    },

    copy: function (src)
    {
        this.x = src.x;
        this.y = src.y;
        this.z = src.z;
        this.w = src.w;

        return this;
    },

    set: function (x, y, z, w)
    {
        if (typeof x === 'object')
        {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
            this.w = x.w || 0;
        }
        else
        {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
        }

        return this;
    },

    add: function (v)
    {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;

        return this;
    },

    subtract: function (v)
    {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;

        return this;
    },

    scale: function (scale)
    {
        this.x *= scale;
        this.y *= scale;
        this.z *= scale;
        this.w *= scale;

        return this;
    },

    length: function ()
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;

        return Math.sqrt(x * x + y * y + z * z + w * w);
    },

    lengthSq: function ()
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;

        return x * x + y * y + z * z + w * w;
    },

    normalize: function ()
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;
        var len = x * x + y * y + z * z + w * w;

        if (len > 0)
        {
            len = 1 / Math.sqrt(len);

            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
            this.w = w * len;
        }

        return this;
    },

    dot: function (v)
    {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },

    lerp: function (v, t)
    {
        if (t === undefined) { t = 0; }

        var ax = this.x;
        var ay = this.y;
        var az = this.z;
        var aw = this.w;

        this.x = ax + t * (v.x - ax);
        this.y = ay + t * (v.y - ay);
        this.z = az + t * (v.z - az);
        this.w = aw + t * (v.w - aw);

        return this;
    },

    rotationTo: function (a, b)
    {
        var dot = a.x * b.x + a.y * b.y + a.z * b.z;

        if (dot < -0.999999)
        {
            if (tmpvec.copy(xUnitVec3).cross(a).len() < EPSILON)
            {
                tmpvec.copy(yUnitVec3).cross(a);
            }
            
            tmpvec.normalize();

            return this.setAxisAngle(tmpvec, Math.PI);

        }
        else if (dot > 0.999999)
        {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;

            return this;
        }
        else
        {
            tmpvec.copy(a).cross(b);

            this.x = tmpvec.x;
            this.y = tmpvec.y;
            this.z = tmpvec.z;
            this.w = 1 + dot;

            return this.normalize();
        }
    },

    setAxes: function (view, right, up)
    {
        var m = tmpMat3.val;

        m[0] = right.x;
        m[3] = right.y;
        m[6] = right.z;

        m[1] = up.x;
        m[4] = up.y;
        m[7] = up.z;

        m[2] = -view.x;
        m[5] = -view.y;
        m[8] = -view.z;

        return this.fromMat3(tmpMat3).normalize();
    },

    identity: function ()
    {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 1;

        return this;
    },

    setAxisAngle: function (axis, rad)
    {
        rad = rad * 0.5;

        var s = Math.sin(rad);

        this.x = s * axis.x;
        this.y = s * axis.y;
        this.z = s * axis.z;
        this.w = Math.cos(rad);

        return this;
    },

    multiply: function (b)
    {
        var ax = this.x;
        var ay = this.y;
        var az = this.z;
        var aw = this.w;

        var bx = b.x;
        var by = b.y;
        var bz = b.z;
        var bw = b.w;

        this.x = ax * bw + aw * bx + ay * bz - az * by;
        this.y = ay * bw + aw * by + az * bx - ax * bz;
        this.z = az * bw + aw * bz + ax * by - ay * bx;
        this.w = aw * bw - ax * bx - ay * by - az * bz;

        return this;
    },

    slerp: function (b, t)
    {
        // benchmarks: http://jsperf.com/quaternion-slerp-implementations

        var ax = this.x;
        var ay = this.y;
        var az = this.z;
        var aw = this.w;

        var bx = b.x;
        var by = b.y;
        var bz = b.z;
        var bw = b.w;

        // calc cosine
        var cosom = ax * bx + ay * by + az * bz + aw * bw;

        // adjust signs (if necessary)
        if (cosom < 0)
        {
            cosom = -cosom;
            bx = - bx;
            by = - by;
            bz = - bz;
            bw = - bw;
        }

        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        var scale0 = 1 - t;
        var scale1 = t;

        // calculate coefficients
        if ((1 - cosom) > EPSILON)
        {
            // standard case (slerp)
            var omega = Math.acos(cosom);
            var sinom = Math.sin(omega);

            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
        }

        // calculate final values
        this.x = scale0 * ax + scale1 * bx;
        this.y = scale0 * ay + scale1 * by;
        this.z = scale0 * az + scale1 * bz;
        this.w = scale0 * aw + scale1 * bw;

        return this;
    },

    invert: function ()
    {
        var a0 = this.x;
        var a1 = this.y;
        var a2 = this.z;
        var a3 = this.w;

        var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
        var invDot = (dot) ? 1 / dot : 0;
        
        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

        this.x = -a0 * invDot;
        this.y = -a1 * invDot;
        this.z = -a2 * invDot;
        this.w = a3 * invDot;

        return this;
    },

    conjugate: function ()
    {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;

        return this;
    },

    rotateX: function (rad)
    {
        rad *= 0.5;

        var ax = this.x;
        var ay = this.y;
        var az = this.z;
        var aw = this.w;

        var bx = Math.sin(rad);
        var bw = Math.cos(rad);

        this.x = ax * bw + aw * bx;
        this.y = ay * bw + az * bx;
        this.z = az * bw - ay * bx;
        this.w = aw * bw - ax * bx;

        return this;
    },

    rotateY: function (rad)
    {
        rad *= 0.5;

        var ax = this.x;
        var ay = this.y;
        var az = this.z;
        var aw = this.w;

        var by = Math.sin(rad);
        var bw = Math.cos(rad);

        this.x = ax * bw - az * by;
        this.y = ay * bw + aw * by;
        this.z = az * bw + ax * by;
        this.w = aw * bw - ay * by;

        return this;
    },

    rotateZ: function (rad)
    {
        rad *= 0.5;

        var ax = this.x;
        var ay = this.y;
        var az = this.z;
        var aw = this.w;

        var bz = Math.sin(rad);
        var bw = Math.cos(rad);

        this.x = ax * bw + ay * bz;
        this.y = ay * bw - ax * bz;
        this.z = az * bw + aw * bz;
        this.w = aw * bw - az * bz;

        return this;
    },

    calculateW: function ()
    {
        var x = this.x;
        var y = this.y;
        var z = this.z;

        this.w = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));

        return this;
    },

    fromMat3: function (mat)
    {
        // benchmarks:
        //    http://jsperf.com/typed-array-access-speed
        //    http://jsperf.com/conversion-of-3x3-matrix-to-quaternion

        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".
        var m = mat.val;
        var fTrace = m[0] + m[4] + m[8];
        var fRoot;

        if (fTrace > 0)
        {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0); // 2w

            this.w = 0.5 * fRoot;

            fRoot = 0.5 / fRoot; // 1/(4w)

            this.x = (m[7] - m[5]) * fRoot;
            this.y = (m[2] - m[6]) * fRoot;
            this.z = (m[3] - m[1]) * fRoot;
        }
        else
        {
            // |w| <= 1/2
            var i = 0;

            if (m[4] > m[0])
            {
                i = 1;
            }

            if (m[8] > m[i * 3 + i])
            {
                i = 2;
            }

            var j = siNext[i];
            var k = siNext[j];
                
            //  This isn't quite as clean without array access
            fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
            tmp[i] = 0.5 * fRoot;

            fRoot = 0.5 / fRoot;

            tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
            tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;

            this.x = tmp[0];
            this.y = tmp[1];
            this.z = tmp[2];
            this.w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
        }
        
        return this;
    }

});

Quaternion.prototype.idt = Quaternion.prototype.identity;
Quaternion.prototype.sub = Quaternion.prototype.subtract;
Quaternion.prototype.mul = Quaternion.prototype.multiply;
Quaternion.prototype.len = Quaternion.prototype.length;
Quaternion.prototype.lenSq = Quaternion.prototype.lengthSq;
Quaternion.prototype.reset = Quaternion.prototype.idt;

module.exports = Quaternion;


/***/ }),
/* 203 */
/***/ (function(module, exports) {

//  Position Vector randomly in a spherical area defined by the given radius
var RandomXYZ = function (vector, radius)
{
    if (radius === undefined) { radius = 1; }

    var r = Math.random() * 2 * Math.PI;
    var z = (Math.random() * 2) - 1;
    var zScale = Math.sqrt(1 - z * z) * radius;
    
    vector.x = Math.cos(r) * zScale;
    vector.y = Math.sin(r) * zScale;
    vector.z = z * radius;

    return vector;
};

module.exports = RandomXYZ;


/***/ }),
/* 204 */
/***/ (function(module, exports) {

var RandomXYZW = function (vector, scale)
{
    if (scale === undefined) { scale = 1; }

    // Not spherical; should fix this for more uniform distribution
    vector.x = (Math.random() * 2 - 1) * scale;
    vector.y = (Math.random() * 2 - 1) * scale;
    vector.z = (Math.random() * 2 - 1) * scale;
    vector.w = (Math.random() * 2 - 1) * scale;

    return vector;
};

module.exports = RandomXYZW;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var Vector3 = __webpack_require__(34);
var Matrix4 = __webpack_require__(53);
var Quaternion = __webpack_require__(202);

var tmpMat4 = new Matrix4();
var tmpQuat = new Quaternion();
var tmpVec3 = new Vector3();

/**
 * Rotates a vector in place by axis angle.
 *
 * This is the same as transforming a point by an 
 * axis-angle quaternion, but it has higher precision.
 * 
 * @param  {Vector3} vec     [description]
 * @param  {Vector3} axis    [description]
 * @param  {float} radians [description]
 * @return {Vector3}         [description]
 */
var RotateVec3 = function(vec, axis, radians)
{
    //  Set the quaternion to our axis angle
    tmpQuat.setAxisAngle(axis, radians);

    //  Create a rotation matrix from the axis angle
    tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));

    //  Multiply our vector by the rotation matrix
    return vec.transformMat4(tmpMat4);
};

module.exports = RotateVec3;


/***/ }),
/* 206 */
/***/ (function(module, exports) {

var RoundAwayFromZero = function (value)
{
    // "Opposite" of truncate.
    return (value > 0) ? Math.ceil(value) : Math.floor(value);
};

module.exports = RoundAwayFromZero;


/***/ }),
/* 207 */
/***/ (function(module, exports) {

var SmoothStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * (3 - 2 * x);
};

module.exports = SmoothStep;


/***/ }),
/* 208 */
/***/ (function(module, exports) {

var SmootherStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * x * (x * (x * 6 - 15) + 10);
};

module.exports = SmootherStep;


/***/ }),
/* 209 */
/***/ (function(module, exports) {

var Normalize = function (angle)
{
    angle = angle % (2 * Math.PI);

    if (angle >= 0)
    {
        return angle;
    }
    else
    {
        return angle + 2 * Math.PI;
    }
};

module.exports = Normalize;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var MathWrap = __webpack_require__(67);

var Wrap = function (angle)
{
    return MathWrap(angle, -Math.PI, Math.PI);
};

module.exports = Wrap;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var Wrap = __webpack_require__(67);

var WrapDegrees = function (angle)
{
    return Wrap(angle, -180, 180);
};

module.exports = WrapDegrees;


/***/ }),
/* 212 */
/***/ (function(module, exports) {

function In (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return v * v * ((overshoot + 1) * v - overshoot);
}

function Out (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return --v * v * ((overshoot + 1) * v + overshoot) + 1;
}

function InOut (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    var s = overshoot * 1.525;

    if ((v *= 2) < 1)
    {
        return 0.5 * (v * v * ((s + 1) * v - s));
    }
    else
    {
        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 213 */
/***/ (function(module, exports) {

function In (v)
{
    v = 1 - v;

    if (v < 1 / 2.75)
    {
        return 1 - (7.5625 * v * v);
    }
    else if (v < 2 / 2.75)
    {
        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
    }
    else if (v < 2.5 / 2.75)
    {
        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
    }
    else
    {
        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
    }
}

function Out (v)
{
    if (v < 1 / 2.75)
    {
        return 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }
}

function InOut (v)
{
    var reverse = false;

    if (v < 0.5)
    {
        v = 1 - (v * 2);
        reverse = true;
    }
    else
    {
        v = (v * 2) - 1;
    }

    if (v < 1 / 2.75)
    {
        v = 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }

    if (reverse)
    {
        return (1 - v) * 0.5;
    }
    else
    {
        return v * 0.5 + 0.5;
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 214 */
/***/ (function(module, exports) {

function In (v)
{
    return 1 - Math.sqrt(1 - v * v);
}

function Out (v)
{
    return Math.sqrt(1 - (--v * v));
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return -0.5 * (Math.sqrt(1 - v * v) - 1);
    }
    else
    {
        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 215 */
/***/ (function(module, exports) {

function In (v)
{
    return v * v * v;
}

function Out (v)
{
    return --v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 216 */
/***/ (function(module, exports) {

function In (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
    }
}

function Out (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);
    }
}

function InOut (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        if ((v *= 2) < 1)
        {
            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
        }
        else
        {
            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
        }
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 217 */
/***/ (function(module, exports) {

function In (v)
{
    return Math.pow(2, 10 * (v - 1)) - 0.001;
}

function Out (v)
{
    return 1 - Math.pow(2, -10 * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * Math.pow(2, 10 * (v - 1));
    }
    else
    {
        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 218 */
/***/ (function(module, exports) {

/**
* Linear Easing (no variation).
*
* @method Lazer.Easing.Linear#None
* @param {number} v - The value to be tweened.
* @returns {number} v.
*/
var Linear = function (v)
{
    return v;
};

module.exports = Linear;


/***/ }),
/* 219 */
/***/ (function(module, exports) {

function In (v)
{
    return v * v;
}

function Out (v)
{
    return v * (2 - v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v;
    }
    else
    {
        return -0.5 * (--v * (v - 2) - 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 220 */
/***/ (function(module, exports) {

function In (v)
{
    return v * v * v * v;
}

function Out (v)
{
    return 1 - (--v * v * v * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v;
    }
    else
    {
        return -0.5 * ((v -= 2) * v * v * v - 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 221 */
/***/ (function(module, exports) {

function In (v)
{
    return v * v * v * v * v;
}

function Out (v)
{
    return --v * v * v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 222 */
/***/ (function(module, exports) {

function In (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 1 - Math.cos(v * Math.PI / 2);
    }
}

function Out (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return Math.sin(v * Math.PI / 2);
    }
}

function InOut (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 0.5 * (1 - Math.cos(Math.PI * v));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Back: __webpack_require__(212),
    Bounce: __webpack_require__(213),
    Circular: __webpack_require__(214),
    Cubic: __webpack_require__(215),
    Elastic: __webpack_require__(216),
    Expo: __webpack_require__(217),
    Linear: __webpack_require__(218),
    Quadratic: __webpack_require__(219),
    Quartic: __webpack_require__(220),
    Quintic: __webpack_require__(221),
    Sine: __webpack_require__(222)

};


/***/ }),
/* 224 */
/***/ (function(module, exports) {

function P0 (t, p)
{
    var k = 1 - t;

    return k * k * k * p;
}

function P1 (t, p)
{
    var k = 1 - t;

    return 3 * k * k * t * p;
}

function P2 (t, p)
{
    return 3 * ( 1 - t ) * t * t * p;
}

function P3 (t, p)
{
    return t * t * t * p;
}

//  p0 = start point
//  p1 = control point 1
//  p2 = control point 2
//  p3 = end point

// https://medium.com/@adrian_cooney/bezier-interpolation-13b68563313a

var CubicBezierInterpolation = function (t, p0, p1, p2, p3)
{
    return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);
};

module.exports = CubicBezierInterpolation;


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(200);

var LinearInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (k < 0)
    {
        return Linear(v[0], v[1], f);
    }

    if (k > 1)
    {
        return Linear(v[m], v[m - 1], m - f);
    }

    return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);
};

module.exports = LinearInterpolation;


/***/ }),
/* 226 */
/***/ (function(module, exports) {

//  Takes value and returns the nearest power of 2

var GetPowerOfTwo = function (value)
{
    //  Math.log(2)
    var index = Math.log(value) / 0.6931471805599453;

    return (1 << Math.ceil(index));
};

module.exports = GetPowerOfTwo;


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var RandomDataGenerator = new Class({

    initialize:

    function RandomDataGenerator (seeds)
    {
        /**
        * @property {number} c - Internal var.
        * @private
        */
        this.c = 1;

        /**
        * @property {number} s0 - Internal var.
        * @private
        */
        this.s0 = 0;

        /**
        * @property {number} s1 - Internal var.
        * @private
        */
        this.s1 = 0;

        /**
        * @property {number} s2 - Internal var.
        * @private
        */
        this.s2 = 0;

        /**
        * @property {Array} sign - Internal var.
        * @private
        */
        this.sign = [ -1, 1 ];

        if (seeds)
        {
            this.init(seeds);
        }
    },

    /**
    * Private random helper.
    *
    * @method Phaser.RandomDataGenerator#rnd
    * @private
    * @return {number}
    */
    rnd: function ()
    {
        var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32

        this.c = t | 0;
        this.s0 = this.s1;
        this.s1 = this.s2;
        this.s2 = t - this.c;

        return this.s2;
    },

    /**
    * Internal method that creates a seed hash.
    *
    * @method Phaser.RandomDataGenerator#hash
    * @private
    * @param {any} data
    * @return {number} hashed value.
    */
    hash: function (data)
    {
        var h;
        var n = 0xefc8249d;

        data = data.toString();

        for (var i = 0; i < data.length; i++)
        {
            n += data.charCodeAt(i);
            h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 0x100000000;// 2^32
        }

        return (n >>> 0) * 2.3283064365386963e-10;// 2^-32
    },

    init: function (seeds)
    {
        if (typeof seeds === 'string')
        {
            this.state(seeds);
        }
        else
        {
            this.sow(seeds);
        }
    },

    /**
    * Reset the seed of the random data generator.
    *
    * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
    *
    * @method Phaser.RandomDataGenerator#sow
    * @param {any[]} seeds - The array of seeds: the `toString()` of each value is used.
    */
    sow: function (seeds)
    {
        // Always reset to default seed
        this.s0 = this.hash(' ');
        this.s1 = this.hash(this.s0);
        this.s2 = this.hash(this.s1);
        this.c = 1;

        if (!seeds)
        {
            return;
        }

        // Apply any seeds
        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)
        {
            var seed = seeds[i];

            this.s0 -= this.hash(seed);
            this.s0 += ~~(this.s0 < 0);
            this.s1 -= this.hash(seed);
            this.s1 += ~~(this.s1 < 0);
            this.s2 -= this.hash(seed);
            this.s2 += ~~(this.s2 < 0);
        }
    },

    /**
    * Returns a random integer between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#integer
    * @return {number} A random integer between 0 and 2^32.
    */
    integer: function ()
    {
        // 2^32
        return this.rnd() * 0x100000000;
    },

    /**
    * Returns a random real number between 0 and 1.
    *
    * @method Phaser.RandomDataGenerator#frac
    * @return {number} A random real number between 0 and 1.
    */
    frac: function ()
    {
        // 2^-53
        return this.rnd() + (this.rnd() * 0x200000 | 0) * 1.1102230246251565e-16;
    },

    /**
    * Returns a random real number between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#real
    * @return {number} A random real number between 0 and 2^32.
    */
    real: function ()
    {
        return this.integer() + this.frac();
    },

    /**
    * Returns a random integer between and including min and max.
    *
    * @method Phaser.RandomDataGenerator#integerInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    integerInRange: function (min, max)
    {
        return Math.floor(this.realInRange(0, max - min + 1) + min);
    },

    /**
    * Returns a random integer between and including min and max.
    * This method is an alias for RandomDataGenerator.integerInRange.
    *
    * @method Phaser.RandomDataGenerator#between
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    between: function (min, max)
    {
        return this.integerInRange(min, max);
    },

    /**
    * Returns a random real number between min and max.
    *
    * @method Phaser.RandomDataGenerator#realInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    realInRange: function (min, max)
    {
        return this.frac() * (max - min) + min;
    },

    /**
    * Returns a random real number between -1 and 1.
    *
    * @method Phaser.RandomDataGenerator#normal
    * @return {number} A random real number between -1 and 1.
    */
    normal: function ()
    {
        return 1 - (2 * this.frac());
    },

    /**
    * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
    *
    * @method Phaser.RandomDataGenerator#uuid
    * @return {string} A valid RFC4122 version4 ID hex string
    */
    uuid: function ()
    {
        var a = '';
        var b = '';

        for (b = a = ''; a++ < 36; b +=~a % 5 | a*3 & 4 ? (a^15 ? 8 ^ this.frac()*(a^20 ? 16 : 4) : 4).toString(16) : '-')
        {
        }

        return b;
    },

    /**
    * Returns a random member of `array`.
    *
    * @method Phaser.RandomDataGenerator#pick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    pick: function (array)
    {
        return array[this.integerInRange(0, array.length - 1)];
    },

    /**
    * Returns a sign to be used with multiplication operator.
    *
    * @method Phaser.RandomDataGenerator#sign
    * @return {number} -1 or +1.
    */
    sign: function ()
    {
        return this.pick(this.sign);
    },

    /**
    * Returns a random member of `array`, favoring the earlier entries.
    *
    * @method Phaser.RandomDataGenerator#weightedPick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    weightedPick: function (array)
    {
        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
    },

    /**
    * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
    *
    * @method Phaser.RandomDataGenerator#timestamp
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random timestamp between min and max.
    */
    timestamp: function (min, max)
    {
        return this.realInRange(min || 946684800000, max || 1577862000000);
    },

    /**
    * Returns a random angle between -180 and 180.
    *
    * @method Phaser.RandomDataGenerator#angle
    * @return {number} A random number between -180 and 180.
    */
    angle: function ()
    {
        return this.integerInRange(-180, 180);
    },

    /**
    * Returns a random rotation in radians, between -3.141 and 3.141
    *
    * @method Phaser.RandomDataGenerator#rotation
    * @return {number} A random number between -3.141 and 3.141
    */
    rotation: function ()
    {
        return this.realInRange(-3.141592653589793, 3.141592653589793);
    },

    /**
    * Gets or Sets the state of the generator. This allows you to retain the values
    * that the generator is using between games, i.e. in a game save file.
    *
    * To seed this generator with a previously saved state you can pass it as the
    * `seed` value in your game config, or call this method directly after Phaser has booted.
    *
    * Call this method with no parameters to return the current state.
    *
    * If providing a state it should match the same format that this method
    * returns, which is a string with a header `!rnd` followed by the `c`,
    * `s0`, `s1` and `s2` values respectively, each comma-delimited.
    *
    * @method Phaser.RandomDataGenerator#state
    * @param {string} [state] - Generator state to be set.
    * @return {string} The current state of the generator.
    */
    state: function (state)
    {
        if (typeof state === 'string' && state.match(/^!rnd/))
        {
            state = state.split(',');

            this.c = parseFloat(state[1]);
            this.s0 = parseFloat(state[2]);
            this.s1 = parseFloat(state[3]);
            this.s2 = parseFloat(state[4]);
        }

        return [ '!rnd', this.c, this.s0, this.s1, this.s2 ].join(',');
    }

});

module.exports = RandomDataGenerator;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)

var Class = __webpack_require__(0);
var Curve = __webpack_require__(69);
var Vector2 = __webpack_require__(20);

//  Phaser.Curves.Line

var tmpVec2 = new Vector2();

var LineCurve = new Class({

    Extends: Curve,

    initialize:

    //  vec2s
    function LineCurve (v1, v2)
    {
        if (Array.isArray(v1))
        {
            v2 = new Vector2(v1[2], v1[3]);
            v1 = new Vector2(v1[0], v1[1]);
        }

        Curve.call(this);

        this.v1 = v1;
        this.v2 = v2;
    },

    getResolution: function (divisions)
    {
        return 1;
    },

    getPoint: function (t, out)
    {
        if (out === undefined) { out = new Vector2(); }

        if (t === 1)
        {
            return out.copy(this.v2);
        }

        out.copy(this.v2).sub(this.v1).scale(t).add(this.v1);

        return out;
    },

    // Line curve is linear, so we can overwrite default getPointAt
    getPointAt: function (u, out)
    {
        return this.getPoint(u, out);
    },

    getTangent: function ()
    {
        var tangent = tmpVec2.copy(this.v2).sub(this.v1);

        return tangent.normalize();
    }

});

module.exports = LineCurve;


/***/ }),
/* 229 */
/***/ (function(module, exports) {

var WebGLSupportedExtensions = (function () {
    
    var gl = document.createElement('canvas').getContext('webgl');
    var extensionList = gl ? gl.getSupportedExtensions() : [];

    return {

        has: function (name)
        {
            return extensionList.indexOf(name) >= 0;
        }
        
    };
}());

module.exports = WebGLSupportedExtensions;


/***/ }),
/* 230 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec2)
    VERTEX_SIZE: 16,
    INDEX_SIZE: 2,
    TILEMAP_VERTEX_COUNT: 4,
    TILEMAP_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    TILEMAP_VERTEX_COMPONENT_COUNT: 4,
    MAX_TILEMAP: 2000,

};

module.exports = CONST;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    IndexBuffer: __webpack_require__(912),
    RenderTarget: __webpack_require__(913),
    Shader: __webpack_require__(914),
    Texture: __webpack_require__(915),
    VertexBuffer: __webpack_require__(110)

};


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var CameraManager = __webpack_require__(394);
var Class = __webpack_require__(0);
var Clock = __webpack_require__(985);
var Data = __webpack_require__(112);
var DataStore = __webpack_require__(961);
var DisplayList = __webpack_require__(233);
var EventDispatcher = __webpack_require__(30);
var GameObjectCreator = __webpack_require__(5);
var GameObjectFactory = __webpack_require__(6);
var InputManager = __webpack_require__(962);
var Loader = __webpack_require__(963);
var PhysicsManager = __webpack_require__(964);
var PoolManager = __webpack_require__(965);
var SceneManager = __webpack_require__(966);
var Settings = __webpack_require__(960);
var StableSort = __webpack_require__(256);
var TweenManager = __webpack_require__(991);
var UpdateList = __webpack_require__(967);

var Systems = new Class({

    initialize:

    function Systems (scene, config)
    {
        this.scene = scene;

        this.config = config;
        this.settings = Settings.create(config);

        this.sortChildrenFlag = false;

        //  Set by the GlobalSceneManager
        this.canvas;
        this.context;

        //  CORE (GLOBAL) SYSTEMS / PROPERTIES

        this.game;

        this.anims;
        this.cache;
        this.registry;
        this.textures;

        //  Reference to Scene specific managers (Factory, Tweens, Loader, Physics, etc)
        this.add;
        this.cameras;
        this.data;
        this.dataStore;
        this.displayList;
        this.events;
        this.inputManager;
        this.load;
        this.make;
        this.physicsManager;
        this.pool;
        this.sceneManager;
        this.time;
        this.tweens;
        this.updateList;
    },

    init: function (game)
    {
        var scene = this.scene;

        this.game = game;

        //  Game (Global) level managers

        this.anims = game.anims;
        this.cache = game.cache;
        this.registry = game.registry;
        this.textures = game.textures;

        //  Scene specific managers (Factory, Tweens, Loader, Physics, etc)

        this.add = new GameObjectFactory(scene);
        this.cameras = new CameraManager(scene);
        this.data = new Data(scene);
        this.dataStore = new DataStore(scene);
        this.displayList = new DisplayList(scene);
        this.events = new EventDispatcher();
        this.inputManager = new InputManager(scene);
        this.load = new Loader(scene);
        this.make = new GameObjectCreator(scene);
        this.physicsManager = new PhysicsManager(scene);
        this.pool = new PoolManager(scene);
        this.sceneManager = new SceneManager(scene);
        this.time = new Clock(scene);
        this.tweens = new TweenManager(scene);
        this.updateList = new UpdateList(scene);

        //  Sometimes the managers need access to a system created after them
        this.add.boot(this);
        this.inputManager.boot();
        this.physicsManager.boot();

        this.inject();
    },

    inject: function ()
    {
        var map = this.settings.map;

        for (var key in map)
        {
            if (key === 'sys')
            {
                continue;
            }

            this.scene[map[key]] = this[key];
        }
    },

    step: function (time, delta)
    {
        //  Are there any pending SceneManager actions?
        this.sceneManager.update();

        if (!this.settings.active)
        {
            return;
        }

        this.pool.begin(time);
        this.updateList.begin(time);
        this.time.begin(time);
        this.tweens.begin(time);
        this.inputManager.begin(time);

        this.physicsManager.update(time, delta);

        this.pool.update(time, delta);
        this.updateList.update(time, delta);
        this.time.update(time, delta);
        this.tweens.update(time, delta);
        this.cameras.update(time, delta);
        this.inputManager.update(time, delta);

        this.scene.update.call(this.scene, time, delta);
    },

    render: function (interpolation, renderer)
    {
        if (!this.settings.visible)
        {
            return;
        }

        this.depthSort();

        this.cameras.render(renderer, this.displayList, interpolation);
    },

    //  Force a sort of the display list on the next render
    queueDepthSort: function ()
    {
        this.sortChildrenFlag = true;
    },

    //  Immediately sorts the display list if the flag is set
    depthSort: function ()
    {
        if (this.sortChildrenFlag)
        {
            StableSort.inplace(this.displayList.list, this.sortZ);

            this.sortChildrenFlag = false;
        }
    },

    sortZ: function (childA, childB)
    {
        return childA._depth - childB._depth;
    },

    //  A paused Scene still renders, it just doesn't run ANY of its update handlers or systems
    pause: function ()
    {
        //  Was paused by the GlobalSceneManager

        this.settings.active = false;

        if (this.scene.pause)
        {
            this.scene.pause.call(this.scene);
        }
    },

    resume: function ()
    {
        //  Was resumed by the GlobalSceneManager

        this.settings.active = true;

        if (this.scene.resume)
        {
            this.scene.resume.call(this.scene);
        }
    },

    sleep: function ()
    {
        //  Was sent to sleep by the GlobalSceneManager

        this.settings.active = false;
        this.settings.visible = false;

        if (this.scene.sleep)
        {
            this.scene.sleep.call(this.scene);
        }
    },

    wake: function ()
    {
        //  Was woken up by the GlobalSceneManager

        this.settings.active = true;
        this.settings.visible = true;

        if (this.scene.wake)
        {
            this.scene.wake.call(this.scene);
        }
    },

    start: function (data)
    {
        //  Was started by the GlobalSceneManager

        this.settings.data = data;

        this.settings.active = true;
        this.settings.visible = true;
    },

    shutdown: function ()
    {
        //  Was stopped by the GlobalSceneManager

        this.settings.active = false;
        this.settings.visible = false;

        this.pool.shutdown();
        this.displayList.shutdown();
        this.updateList.shutdown();
        this.time.shutdown();
        this.tweens.shutdown();

        if (this.scene.shutdown)
        {
            this.scene.shutdown.call(this.scene);
        }
    },

    //  Game level nuke
    destroy: function ()
    {
        //  TODO

        this.add.destroy();
        this.pool.destroy();
        this.time.destroy();
        this.tweens.destroy();

        //  etc
        if (this.scene.destroy)
        {
            this.scene.destroy.call(this.scene);
        }
    }

});

module.exports = Systems;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var DisplayList = new Class({

    initialize:

    function DisplayList (scene)
    {
        //  The Scene that owns this plugin
        this.scene = scene;

        //  The objects that belong to this collection.
        //  The equivalent of the old `Sprite.children` array.
        this.list = [];

        this.position = 0;
    },

    add: function (child)
    {
        //  Is child already in this display list?

        if (this.getIndex(child) === -1)
        {
            this.list.push(child);
        }

        return child;
    },

    addAt: function (child, index)
    {
        if (index === undefined) { index = 0; }

        if (this.list.length === 0)
        {
            return this.add(child);
        }

        if (index >= 0 && index <= this.list.length)
        {
            if (this.getIndex(child) === -1)
            {
                this.list.splice(index, 0, child);
            }
        }

        return child;
    },

    addMultiple: function (children)
    {
        if (Array.isArray(children))
        {
            for (var i = 0; i < children.length; i++)
            {
                this.add(children[i]);
            }
        }

        return children;
    },

    getAt: function (index)
    {
        return this.list[index];
    },

    getIndex: function (child)
    {
        //  Return -1 if given child isn't a child of this display list
        return this.list.indexOf(child);
    },

    //  Given an array of Game Objects, sort the array and return it,
    //  so that the objects are in index order with the lowest at the bottom.
    sortGameObjects: function (gameObjects)
    {
        if (gameObjects === undefined) { gameObjects = this.list; }

        this.scene.sys.depthSort();

        return gameObjects.sort(this.sortIndexHandler.bind(this));
    },

    //  Note that the given array is sorted in place, even though it isn't returned directly it will still be updated.
    getTopGameObject: function (gameObjects)
    {
        this.sortGameObjects(gameObjects);

        return gameObjects[gameObjects.length - 1];
    },

    //  Return the child lowest down the display list (with the smallest index)
    sortIndexHandler: function (childA, childB)
    {
        //  The lower the index, the lower down the display list they are
        var indexA = this.getIndex(childA);
        var indexB = this.getIndex(childB);

        if (indexA < indexB)
        {
            return -1;
        }
        else if (indexA > indexB)
        {
            return 1;
        }

        //  Technically this shouldn't happen, but if the GO wasn't part of this display list then it'll
        //  have an index of -1, so in some cases it can
        return 0;
    },

    /**
    * Gets the first item from the set based on the property strictly equaling the value given.
    * Returns null if not found.
    *
    * @method Phaser.ArraySet#getByKey
    * @param {string} property - The property to check against the value.
    * @param {any} value - The value to check if the property strictly equals.
    * @return {any} The item that was found, or null if nothing matched.
    */
    getByKey: function (property, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i][property] === value)
            {
                return this.list[i];
            }
        }

        return null;
    },

    /**
    * Searches the Group for the first instance of a child with the `name`
    * property matching the given argument. Should more than one child have
    * the same name only the first instance is returned.
    *
    * @method Phaser.Group#getByName
    * @param {string} name - The name to search for.
    * @return {any} The first child with a matching name, or null if none were found.
    */
    getByName: function (name)
    {
        return this.getByKey('name', name);
    },

    /**
    * Returns a random child from the group.
    *
    * @method Phaser.Group#getRandom
    * @param {integer} [startIndex=0] - Offset from the front of the group (lowest child).
    * @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.
    * @return {any} A random child of this Group.
    */
    getRandom: function (startIndex, length)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (length === undefined) { length = this.list.length; }

        if (length === 0 || length > this.list.length)
        {
            return null;
        }

        var randomIndex = startIndex + Math.floor(Math.random() * length);

        return this.list[randomIndex];
    },

    getFirst: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (child[property] === value)
            {
                return child;
            }
        }

        return null;
    },

    /**
    * Returns all children in this Group.
    *
    * You can optionally specify a matching criteria using the `property` and `value` arguments.
    *
    * For example: `getAll('exists', true)` would return only children that have their exists property set.
    *
    * Optionally you can specify a start and end index. For example if this Group had 100 children,
    * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
    * the first 50 children in the Group.
    *
    * @method Phaser.Group#getAll
    * @param {string} [property] - An optional property to test against the value argument.
    * @param {any} [value] - If property is set then Child.property must strictly equal this value to be included in the results.
    * @param {integer} [startIndex=0] - The first child index to start the search from.
    * @param {integer} [endIndex] - The last child index to search up until.
    * @return {any} A random existing child of this Group.
    */
    getAll: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var output = [];

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (property)
            {
                if (child[property] === value)
                {
                    output.push(child);
                }
            }
            else
            {
                output.push(child);
            }
        }

        return output;
    },

    swap: function (child1, child2)
    {
        if (child1 === child2)
        {
            return;
        }

        var index1 = this.getIndex(child1);
        var index2 = this.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('DisplayList.swap: Supplied objects must be children of the same list');
        }

        this.list[index1] = child2;
        this.list[index2] = child1;
    },

    //   was setIndex
    moveTo: function (child, index)
    {
        var currentIndex = this.getIndex(child);

        if (currentIndex === -1 || index < 0 || index >= this.list.length)
        {
            throw new Error('DisplayList.moveTo: The supplied index is out of bounds');
        }

        //  Remove
        this.list.splice(currentIndex, 1);

        //  Add in new location
        this.list.splice(index, 0, child);

        return child;
    },

    remove: function (child)
    {
        var index = this.list.indexOf(child);

        if (index !== -1)
        {
            this.list.splice(index, 1);
        }
        
        return child;
    },

    removeAt: function (index)
    {
        var child = this.list[index];

        if (child)
        {
            this.children.splice(index, 1);
        }

        return child;
    },

    removeBetween: function (beginIndex, endIndex)
    {
        if (beginIndex === undefined) { beginIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var range = endIndex - beginIndex;

        if (range > 0 && range <= endIndex)
        {
            var removed = this.list.splice(beginIndex, range);

            return removed;
        }
        else if (range === 0 && this.list.length === 0)
        {
            return [];
        }
        else
        {
            throw new Error('DisplayList.removeBetween: Range Error, numeric values are outside the acceptable range');
        }
    },

    /**
    * Removes all the items.
    *
    * @method Phaser.ArraySet#removeAll
    */
    removeAll: function ()
    {
        var i = this.list.length;

        while (i--)
        {
            this.remove(this.list[i]);
        }

        return this;
    },

    shutdown: function ()
    {
        this.removeAll();
    },

    /**
    * Brings the given child to the top of this group so it renders above all other children.
    *
    * @method Phaser.Group#bringToTop
    * @param {any} child - The child to bring to the top of this group.
    * @return {any} The child that was moved.
    */
    bringToTop: function (child)
    {
        if (this.getIndex(child) < this.list.length)
        {
            this.remove(child);
            this.add(child);
        }

        return child;
    },

    /**
    * Sends the given child to the bottom of this group so it renders below all other children.
    *
    * @method Phaser.Group#sendToBack
    * @param {any} child - The child to send to the bottom of this group.
    * @return {any} The child that was moved.
    */
    sendToBack: function (child)
    {
        if (this.getIndex(child) > 0)
        {
            this.remove(child);
            this.addAt(child, 0);
        }

        return child;
    },

    /**
    * Moves the given child up one place in this group unless it's already at the top.
    *
    * @method Phaser.Group#moveUp
    * @param {any} child - The child to move up in the group.
    * @return {any} The child that was moved.
    */
    moveUp: function (child)
    {
        var a = this.getIndex(child);

        if (a !== -1 && a < this.list.length - 1)
        {
            var b = this.getAt(a + 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Moves the given child down one place in this group unless it's already at the bottom.
    *
    * @method Phaser.Group#moveDown
    * @param {any} child - The child to move down in the group.
    * @return {any} The child that was moved.
    */
    moveDown: function (child)
    {
        var a = this.getIndex(child);

        if (a > 0)
        {
            var b = this.getAt(a - 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Reverses all children in this group.
    *
    * This operation applies only to immediate children and does not propagate to subgroups.
    *
    * @method Phaser.Group#reverse
    */
    reverse: function ()
    {
        this.list.reverse();

        return this;
    },

    shuffle: function ()
    {
        for (var i = this.list.length - 1; i > 0; i--)
        {
            var j = Math.floor(Math.random() * (i + 1));
            var temp = this.list[i];
            this.list[i] = this.list[j];
            this.list[j] = temp;
        }

        return this;
    },

    /**
    * Replaces a child of this Group with the given newChild. The newChild cannot be a member of this Group.
    *
    * If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
    *
    * If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
    *
    * @method Phaser.Group#replace
    * @param {any} oldChild - The child in this group that will be replaced.
    * @param {any} newChild - The child to be inserted into this group.
    * @return {any} Returns the oldChild that was replaced within this group.
    */
    replace: function (oldChild, newChild)
    {
        var index = this.getIndex(oldChild);

        if (index !== -1)
        {
            newChild.scene.sys.displayList.remove(newChild);

            this.remove(oldChild);

            this.addAt(newChild, index);

            return oldChild;
        }
    },

    //  Swaps a child from another parent, with one from this parent.
    //  child1 = the child of THIS parent
    //  child2 = the child of the OTHER parent
    exchange: function (child1, child2)
    {
        if (child1 === child2 || child1.scene === child2.scene)
        {
            return;
        }

        var child2Parent = child2.scene.sys.displayList;

        var index1 = this.getIndex(child1);
        var index2 = child2Parent.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of parents');
        }

        this.remove(child1);

        child2Parent.remove(child2);

        this.addAt(child2, index1);

        child2Parent.addAt(child1, index2);
    },

    /**
    * Checks for the item within this list.
    *
    * @method Phaser.ArraySet#exists
    * @param {any} item - The element to get the list index for.
    * @return {boolean} True if the item is found in the list, otherwise false.
    */
    exists: function (child)
    {
        return (this.list.indexOf(child) > -1);
    },

    /**
    * Sets the property `key` to the given value on all members of this list.
    *
    * @method Phaser.ArraySet#setAll
    * @param {any} key - The property of the item to set.
    * @param {any} value - The value to set the property to.
    */
    setAll: function (key, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i])
            {
                this.list[i][key] = value;
            }
        }
    },

    /**
    * Passes all children to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (i = 0; i < this.list.length; i++)
        {
            args[0] = this.list[i];
            callback.apply(thisArg, args);
        }
    },

    /**
    * Moves all children from this Group to the Group given.
    *
    * @method Phaser.Group#moveAll
    * @param {Phaser.Group} group - The new Group to which the children will be moved to.
    * @param {boolean} [silent=false] - If true the children will not dispatch the `onAddedToGroup` event for the new Group.
    * @return {Phaser.Group} The Group to which all the children were moved.
    */
    reparent: function (newParent)
    {
        if (newParent !== this.scene)
        {
            for (var i = 0; i < this.list.length; i++)
            {
                var child = this.remove(this.list[i]);

                newParent.sys.displayList.add(child);
            }
        }

        return newParent;
    },

    length: {

        get: function ()
        {
            return this.list.length;
        }

    },

    first: {

        get: function ()
        {
            this.position = 0;

            if (this.list.length > 0)
            {
                return this.list[0];
            }
            else
            {
                return null;
            }
        }

    },

    last: {

        get: function ()
        {
            if (this.list.length > 0)
            {
                this.position = this.list.length - 1;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    next: {

        get: function ()
        {
            if (this.position < this.list.length)
            {
                this.position++;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    previous: {

        get: function ()
        {
            if (this.position > 0)
            {
                this.position--;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    }

});

module.exports = DisplayList;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

// The keys of a Map can be arbitrary values.

/*
var map = new Map([
    [ 1, 'one' ],
    [ 2, 'two' ],
    [ 3, 'three' ]
]);
*/

var Map = new Class({

    initialize:

    function Map (elements)
    {
        this.entries = {};

        this.size = 0;

        if (Array.isArray(elements))
        {
            for (var i = 0; i < elements.length; i++)
            {
                this.set(elements[i][0], elements[i][1]);
            }
        }
    },

    set: function (key, value)
    {
        if (!this.has(key))
        {
            this.entries[key] = value;
            this.size++;
        }

        return this;
    },

    get: function (key)
    {
        if (this.has(key))
        {
            return this.entries[key];
        }
    },

    getArray: function ()
    {
        var output = [];
        var entries = this.entries;

        for (var key in entries)
        {
            output.push(entries[key]);
        }

        return output;
    },

    has: function (key)
    {
        return (this.entries.hasOwnProperty(key));
    },

    delete: function (key)
    {
        if (this.has(key))
        {
            delete this.entries[key];
            this.size--;
        }

        return this;
    },

    clear: function ()
    {
        Object.keys(this.entries).forEach(function (prop)
        {
            delete this.entries[prop];
        });

        this.size = 0;

        return this;
    },

    keys: function ()
    {
        return Object.keys(this.entries);
    },

    values: function ()
    {
        var output = [];
        var entries = this.entries;

        for (var key in entries)
        {
            output.push(entries[key]);
        }

        return output;
    },

    dump: function ()
    {
        var entries = this.entries;

        console.group('Map');

        for (var key in entries)
        {
            console.log(key, entries[key]);
        }

        console.groupEnd();
    },


    each: function (callback)
    {
        var entries = this.entries;

        for (var key in entries)
        {
            if (callback(key, entries[key]) === false)
            {
                break;
            }
        }

        return this;
    },

    contains: function (value)
    {
        var entries = this.entries;

        for (var key in entries)
        {
            if (entries[key] === value)
            {
                return true;
            }
        }

        return false;
    },

    //  Merges all new keys from the given Map into this one
    //  If it encounters a key that already exists it will be skipped
    //  unless override = true
    merge: function (map, override)
    {
        if (override === undefined) { override = false; }

        var local = this.entries;
        var source = map.entries;

        for (var key in source)
        {
            if (local.hasOwnProperty(key) && override)
            {
                local[key] = source[key];
            }
            else
            {
                this.set(key, source[key]);
            }
        }

        return this;
    }

});

module.exports = Map;


/***/ }),
/* 235 */
/***/ (function(module, exports) {

var GetBoolean = function (source, key, defaultValue)
{
    if (!source)
    {
        return defaultValue;
    }
    else if (source.hasOwnProperty(key))
    {
        return source[key];
    }
    else
    {
        return defaultValue;
    }
};

module.exports = GetBoolean;


/***/ }),
/* 236 */
/***/ (function(module, exports) {

var GetNewValue = function (source, key, defaultValue)
{
    var valueCallback;

    if (source.hasOwnProperty(key))
    {
        var t = typeof(source[key]);

        if (t === 'function')
        {
            valueCallback = function (index, totalTargets, target)
            {
                return source[key](index, totalTargets, target);
            };
        }
        else
        {
            valueCallback = function ()
            {
                return source[key];
            };
        }
    }
    else if (typeof defaultValue === 'function')
    {
        valueCallback = defaultValue;
    }
    else
    {
        valueCallback = function ()
        {
            return defaultValue;
        };
    }

    return valueCallback;
};

module.exports = GetNewValue;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(4);

var GetTargets = function (config)
{
    var targets = GetValue(config, 'targets', null);

    if (targets === null)
    {
        return targets;
    }

    if (typeof targets === 'function')
    {
        targets = targets.call();
    }

    if (!Array.isArray(targets))
    {
        targets = [ targets ];
    }

    return targets;
};

module.exports = GetTargets;


/***/ }),
/* 238 */
/***/ (function(module, exports) {

var TWEEN_DEFAULTS = {
    targets: null,
    delay: 0,
    duration: 1000,
    ease: 'Power0',
    easeParams: null,
    hold: 0,
    repeat: 0,
    repeatDelay: 0,
    yoyo: false,
    flipX: false,
    flipY: false
};

module.exports = TWEEN_DEFAULTS;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(44);
var GetBottom = __webpack_require__(21);
var SetCenterX = __webpack_require__(46);
var SetBottom = __webpack_require__(25);

var InBottomCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(container) + offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomCenter;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(22);
var GetBottom = __webpack_require__(21);
var SetLeft = __webpack_require__(26);
var SetBottom = __webpack_require__(25);

var InBottomLeft = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomLeft;


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(23);
var GetBottom = __webpack_require__(21);
var SetRight = __webpack_require__(27);
var SetBottom = __webpack_require__(25);

var InBottomRight = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomRight;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(44);
var GetCenterY = __webpack_require__(45);
var CenterOn = __webpack_require__(257);

var InCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    CenterOn(gameObject, GetCenterX(container) + offsetX, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InCenter;


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(22);
var GetCenterY = __webpack_require__(45);
var SetLeft = __webpack_require__(26);
var SetCenterY = __webpack_require__(47);

var InLeftCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetCenterY(gameObject, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InLeftCenter;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(23);
var GetCenterY = __webpack_require__(45);
var SetRight = __webpack_require__(27);
var SetCenterY = __webpack_require__(47);

var InRightCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetCenterY(gameObject, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InRightCenter;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(44);
var GetTop = __webpack_require__(24);
var SetCenterX = __webpack_require__(46);
var SetTop = __webpack_require__(28);

var InTopCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(container) + offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopCenter;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(22);
var GetTop = __webpack_require__(24);
var SetLeft = __webpack_require__(26);
var SetTop = __webpack_require__(28);

var InTopLeft = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopLeft;


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(23);
var GetTop = __webpack_require__(24);
var SetRight = __webpack_require__(27);
var SetTop = __webpack_require__(28);

var InTopRight = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopRight;


/***/ }),
/* 248 */
/***/ (function(module, exports) {

var CONST = {

    /**
    * A constant representing a top-left alignment or position.
    * @constant
    * @type {integer}
    */
    TOP_LEFT: 0,

    /**
    * A constant representing a top-center alignment or position.
    * @constant
    * @type {integer}
    */
    TOP_CENTER: 1,

    /**
    * A constant representing a top-right alignment or position.
    * @constant
    * @type {integer}
    */
    TOP_RIGHT: 2,

    /**
    * A constant representing a left-top alignment or position.
    * @constant
    * @type {integer}
    */
    LEFT_TOP: 3,

    /**
    * A constant representing a left-center alignment or position.
    * @constant
    * @type {integer}
    */
    LEFT_CENTER: 4,

    /**
    * A constant representing a left-bottom alignment or position.
    * @constant
    * @type {integer}
    */
    LEFT_BOTTOM: 5,

    /**
    * A constant representing a center alignment or position.
    * @constant
    * @type {integer}
    */
    CENTER: 6,

    /**
    * A constant representing a right-top alignment or position.
    * @constant
    * @type {integer}
    */
    RIGHT_TOP: 7,

    /**
    * A constant representing a right-center alignment or position.
    * @constant
    * @type {integer}
    */
    RIGHT_CENTER: 8,

    /**
    * A constant representing a right-bottom alignment or position.
    * @constant
    * @type {integer}
    */
    RIGHT_BOTTOM: 9,

    /**
    * A constant representing a bottom-left alignment or position.
    * @constant
    * @type {integer}
    */
    BOTTOM_LEFT: 10,

    /**
    * A constant representing a bottom-center alignment or position.
    * @constant
    * @type {integer}
    */
    BOTTOM_CENTER: 11,

    /**
    * A constant representing a bottom-right alignment or position.
    * @constant
    * @type {integer}
    */
    BOTTOM_RIGHT: 12

};

module.exports = CONST;


/***/ }),
/* 249 */
/***/ (function(module, exports) {

/**
* Create an array representing the range of numbers (usually integers), between, and inclusive of,
* the given `start` and `end` arguments. For example:
*
* `var array = numberArray(2, 4); // array = [2, 3, 4]`
* `var array = numberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
* 
* This is equivalent to `numberArrayStep(start, end, 1)`.
* 
* You can optionally provide a prefix and / or suffix string. If given the array will contain
* strings, not integers. For example:
* 
* `var array = numberArray(1, 4, 'Level '); // array = ["Level 1", "Level 2", "Level 3", "Level 4"]`
* `var array = numberArray(5, 7, 'HD-', '.png'); // array = ["HD-5.png", "HD-6.png", "HD-7.png"]`
*
* @method Phaser.ArrayUtils#numberArray
* @param {number} start - The minimum value the array starts with.
* @param {number} end - The maximum value the array contains.
* @param {string} [prefix] - Optional prefix to place before the number. If provided the array will contain strings, not integers.
* @param {string} [suffix] - Optional suffix to place after the number. If provided the array will contain strings, not integers.
* @return {number[]|string[]} The array of number values, or strings if a prefix or suffix was provided.
*/
var NumberArray = function (start, end, prefix, suffix)
{
    var result = [];

    for (var i = start; i <= end; i++)
    {
        if (prefix || suffix)
        {
            var key = (prefix) ? prefix + i.toString() : i.toString();

            if (suffix)
            {
                key = key.concat(suffix);
            }

            result.push(key);
        }
        else
        {
            result.push(i);
        }
    }

    return result;
};

module.exports = NumberArray;


/***/ }),
/* 250 */
/***/ (function(module, exports) {

//  This is from the quickselect npm package: https://www.npmjs.com/package/quickselect
//  Coded by https://www.npmjs.com/~mourner (Vladimir Agafonkin)

// https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

var QuickSelect = function (arr, k, left, right, compare)
{
    left = left || 0;
    right = right || (arr.length - 1);
    compare = compare || defaultCompare;

    while (right > left)
    {
        if (right - left > 600)
        {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));

            QuickSelect(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);

        if (compare(arr[right], t) > 0)
        {
            swap(arr, left, right);
        }

        while (i < j)
        {
            swap(arr, i, j);

            i++;
            j--;

            while (compare(arr[i], t) < 0)
            {
                i++;
            }

            while (compare(arr[j], t) > 0)
            {
                j--;
            }
        }

        if (compare(arr[left], t) === 0)
        {
            swap(arr, left, j);
        }
        else
        {
            j++;
            swap(arr, j, right);
        }

        if (j <= k)
        {
            left = j + 1;
        }

        if (k <= j)
        {
            right = j - 1;
        }
    }
};

function swap (arr, i, j)
{
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare (a, b)
{
    return a < b ? -1 : a > b ? 1 : 0;
}

module.exports = QuickSelect;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var Shuffle = __webpack_require__(254);
var GetValue = __webpack_require__(4);

var BuildChunk = function (a, b, qty)
{
    var out = [];

    for (var aIndex = 0; aIndex < a.length; aIndex++)
    {
        for (var bIndex = 0; bIndex < b.length; bIndex++)
        {
            for (var i = 0; i < qty; i++)
            {
                out.push({ a: a[aIndex], b: b[bIndex] });
            }
        }
    }

    return out;
};

//  options = repeat, random, randomB, yoyo, max, qty

//  Range ([a,b,c], [1,2,3]) =
//  a1, a2, a3, b1, b2, b3, c1, c2, c3

//  Range ([a,b], [1,2,3], qty = 3) =
//  a1, a1, a1, a2, a2, a2, a3, a3, a3, b1, b1, b1, b2, b2, b2, b3, b3, b3

//  Range ([a,b,c], [1,2,3], repeat x1) =
//  a1, a2, a3, b1, b2, b3, c1, c2, c3, a1, a2, a3, b1, b2, b3, c1, c2, c3

//  Range ([a,b], [1,2], repeat -1 = endless, max = 14) =
//  Maybe if max is set then repeat goes to -1 automatically?
//  a1, a2, b1, b2, a1, a2, b1, b2, a1, a2, b1, b2, a1, a2 (capped at 14 elements)

//  Range ([a], [1,2,3,4,5], random = true) =
//  a4, a1, a5, a2, a3

//  Range ([a, b], [1,2,3], random = true) =
//  b3, a2, a1, b1, a3, b2

//  Range ([a, b, c], [1,2,3], randomB = true) =
//  a3, a1, a2, b2, b3, b1, c1, c3, c2

//  Range ([a], [1,2,3,4,5], yoyo = true) =
//  a1, a2, a3, a4, a5, a5, a4, a3, a2, a1

//  Range ([a, b], [1,2,3], yoyo = true) =
//  a1, a2, a3, b1, b2, b3, b3, b2, b1, a3, a2, a1

var Range = function (a, b, options)
{
    var max = GetValue(options, 'max', 0);
    var qty = GetValue(options, 'qty', 1);
    var random = GetValue(options, 'random', false);
    var randomB = GetValue(options, 'randomB', false);
    var repeat = GetValue(options, 'repeat', 0);
    var yoyo = GetValue(options, 'yoyo', false);

    var out = [];

    if (randomB)
    {
        Shuffle(b);
    }

    //  Endless repeat, so limit by max
    if (repeat === -1)
    {
        if (max === 0)
        {
            repeat = 0;
        }
        else
        {
            //  Work out how many repeats we need
            var total = (a.length * b.length) * qty;

            if (yoyo)
            {
                total *= 2;
            }

            repeat = Math.ceil(max / total);
        }
    }

    for (var i = 0; i <= repeat; i++)
    {
        var chunk = BuildChunk(a, b, qty);

        if (random)
        {
            Shuffle(chunk);
        }

        out = out.concat(chunk);

        if (yoyo)
        {
            chunk.reverse();

            out = out.concat(chunk);
        }
    }

    if (max)
    {
        out.splice(max);
    }

    return out;
};

module.exports = Range;


/***/ }),
/* 252 */
/***/ (function(module, exports) {

/**
* Moves the element at the start of the array to the end, shifting all items in the process.
* The "rotation" happens to the left.
*
* @method Phaser.ArrayUtils.rotate
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateLeft = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.shift();
        array.push(element);
    }

    return element;
};

module.exports = RotateLeft;


/***/ }),
/* 253 */
/***/ (function(module, exports) {

/**
* Moves the element at the end of the array to the start, shifting all items in the process.
* The "rotation" happens to the right.
*
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateRight = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.pop();
        array.unshift(element);
    }

    return element;
};

module.exports = RotateRight;


/***/ }),
/* 254 */
/***/ (function(module, exports) {

/**
* A standard Fisher-Yates Array shuffle implementation which modifies the array in place.
*
* @method
* @param {any[]} array - The array to shuffle.
* @return {any[]} The original array, now shuffled.
*/
var Shuffle = function (array)
{
    for (var i = array.length - 1; i > 0; i--)
    {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    return array;
};

module.exports = Shuffle;


/***/ }),
/* 255 */
/***/ (function(module, exports) {

//  Removes a single item from an array and returns it
//  without creating gc (like the native splice does)
//  Based on code by Mike Reinstein

var SpliceOne = function (array, index)
{
    if (index >= array.length)
    {
        return;
    }

    var len = array.length - 1;

    var item = array[index];

    for (var i = index; i < len; i++)
    {
        array[i] = array[i + 1];
    }

    array.length = len;

    return item;
};

module.exports = SpliceOne;


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

//! stable.js 0.1.6, https://github.com/Two-Screen/stable
//!  2017 Angry Bytes and contributors. MIT licensed.

(function() {

// A stable array sort, because `Array#sort()` is not guaranteed stable.
// This is an implementation of merge sort, without recursion.

var stable = function(arr, comp) {
    return exec(arr.slice(), comp);
};

stable.inplace = function(arr, comp) {
    var result = exec(arr, comp);

    // This simply copies back if the result isn't in the original array,
    // which happens on an odd number of passes.
    if (result !== arr) {
        pass(result, null, arr.length, arr);
    }

    return arr;
};

// Execute the sort using the input array and a second buffer as work space.
// Returns one of those two, containing the final result.
function exec(arr, comp) {
    if (typeof(comp) !== 'function') {
        comp = function(a, b) {
            return String(a).localeCompare(b);
        };
    }

    // Short-circuit when there's nothing to sort.
    var len = arr.length;
    if (len <= 1) {
        return arr;
    }

    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
    // Chunks are the size of the left or right hand in merge sort.
    // Stop when the left-hand covers all of the array.
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
        pass(arr, comp, chk, buffer);

        var tmp = arr;
        arr = buffer;
        buffer = tmp;
    }

    return arr;
}

// Run a single pass with the given chunk size.
var pass = function(arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
        r = l + chk;
        e = r + chk;
        if (r > len) r = len;
        if (e > len) e = len;

        // Iterate both chunks in parallel.
        li = l;
        ri = r;
        while (true) {
            // Compare the chunks.
            if (li < r && ri < e) {
                // This works for a regular `sort()` compatible comparator,
                // but also for a simple comparator like: `a > b`
                if (comp(arr[li], arr[ri]) <= 0) {
                    result[i++] = arr[li++];
                }
                else {
                    result[i++] = arr[ri++];
                }
            }
            // Nothing to compare, just flush what's left.
            else if (li < r) {
                result[i++] = arr[li++];
            }
            else if (ri < e) {
                result[i++] = arr[ri++];
            }
            // Both iterators are at the chunk ends.
            else {
                break;
            }
        }
    }
};

// Export using CommonJS or to the window.
if (true) {
    module.exports = stable;
}
else {
    window.stable = stable;
}

})();

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var SetCenterX = __webpack_require__(46);
var SetCenterY = __webpack_require__(47);

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var CenterOn = function (gameObject, x, y)
{
    SetCenterX(gameObject, x);

    return SetCenterY(gameObject, y);
};

module.exports = CenterOn;


/***/ }),
/* 258 */
/***/ (function(module, exports) {

/**
* This is a slightly modified version of jQuery.isPlainObject.
* A plain object is an object whose internal class property is [object Object].
* @method Phaser.Utils.isPlainObject
* @param {object} obj - The object to inspect.
* @return {boolean} - true if the object is plain, otherwise false.
*/
var IsPlainObject = function (obj)
{
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (typeof(obj) !== 'object' || obj.nodeType || obj === obj.window)
    {
        return false;
    }

    // Support: Firefox <20
    // The try/catch suppresses exceptions thrown when attempting to access
    // the "constructor" property of certain host objects, ie. |window.location|
    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
    try
    {
        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf'))
        {
            return false;
        }
    }
    catch (e)
    {
        return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
};

module.exports = IsPlainObject;


/***/ }),
/* 259 */
/***/ (function(module, exports) {

/**
* Takes the given string and pads it out, to the length required, using the character
* specified. For example if you need a string to be 6 characters long, you can call:
*
* `pad('bob', 6, '-', 2)`
*
* This would return: `bob---` as it has padded it out to 6 characters, using the `-` on the right.
*
* You can also use it to pad numbers (they are always returned as strings):
* 
* `pad(512, 6, '0', 1)`
*
* Would return: `000512` with the string padded to the left.
*
* If you don't specify a direction it'll pad to both sides:
* 
* `pad('c64', 7, '*')`
*
* Would return: `**c64**`
*
* @method Phaser.Utils.pad
* @param {string} str - The target string. `toString()` will be called on the string, which means you can also pass in common data types like numbers.
* @param {integer} [len=0] - The number of characters to be added.
* @param {string} [pad=" "] - The string to pad it out with (defaults to a space).
* @param {integer} [dir=3] - The direction dir = 1 (left), 2 (right), 3 (both).
* @return {string} The padded string.
*/
var Pad = function (str, len, pad, dir)
{
    if (len === undefined) { len = 0; }
    if (pad === undefined) { pad = ' '; }
    if (dir === undefined) { dir = 3; }

    str = str.toString();

    var padlen = 0;

    if (len + 1 >= str.length)
    {
        switch (dir)
        {
            case 1:
                str = new Array(len + 1 - str.length).join(pad) + str;
                break;

            case 3:
                var right = Math.ceil((padlen = len - str.length) / 2);
                var left = padlen - right;
                str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
                break;

            default:
                str = str + new Array(len + 1 - str.length).join(pad);
                break;
        }
    }

    return str;
};

module.exports = Pad;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Config = __webpack_require__(356);
var DebugHeader = __webpack_require__(358);
var Device = __webpack_require__(418);
var NOOP = __webpack_require__(3);

var AddToDOM = __webpack_require__(130);
var DOMContentLoaded = __webpack_require__(131);
var EventDispatcher = __webpack_require__(30);
var VisibilityHandler = __webpack_require__(360);

var AnimationManager = __webpack_require__(338);
var CreateRenderer = __webpack_require__(357);
var Data = __webpack_require__(112);
var GlobalCache = __webpack_require__(362);
var GlobalInputManager = __webpack_require__(710);
var GlobalSceneManager = __webpack_require__(925);
var TextureManager = __webpack_require__(973);
var TimeStep = __webpack_require__(359);

var Game = new Class({

    initialize:

    function Game (config)
    {
        this.config = new Config(config);

        this.renderer = null;
        this.canvas = null;
        this.context = null;

        this.isBooted = false;
        this.isRunning = false;

        this.events = new EventDispatcher();

        this.anims = new AnimationManager(this);

        this.textures = new TextureManager(this);

        this.cache = new GlobalCache(this);

        this.registry = new Data(this);

        this.input = new GlobalInputManager(this, this.config);

        this.scene = new GlobalSceneManager(this, this.config.sceneConfig);

        this.device = Device;

        this.loop = new TimeStep(this, this.config.fps);

        this.onStepCallback = NOOP;

        //  Wait for the DOM Ready event, then call boot.
        DOMContentLoaded(this.boot.bind(this));

        //  For debugging only
        window.game = this;
    },

    boot: function ()
    {
        this.isBooted = true;

        this.config.preBoot();

        CreateRenderer(this);

        DebugHeader(this);

        AddToDOM(this.canvas, this.config.parent);

        this.textures.boot();

        this.anims.boot(this.textures);

        this.scene.boot();

        this.input.boot();

        this.isRunning = true;

        this.config.postBoot();

        this.loop.start(this.step.bind(this));

        VisibilityHandler(this.events);

        this.events.on('HIDDEN', this.onHidden.bind(this));
        this.events.on('VISIBLE', this.onVisible.bind(this));
        this.events.on('ON_BLUR', this.onBlur.bind(this));
        this.events.on('ON_FOCUS', this.onFocus.bind(this));
    },

    step: function (time, delta)
    {
        var active = this.scene.active;
        var renderer = this.renderer;

        //  Global Managers (Time, Input, etc)

        this.input.update(time, delta);

        //  Scenes

        this.onStepCallback();

        for (var i = 0; i < active.length; i++)
        {
            active[i].scene.sys.step(time, delta);
        }

        //  Render

        // var interpolation = this.frameDelta / this.timestep;

        renderer.preRender();

        //  This uses active.length, in case scene.update removed the scene from the active list
        for (i = 0; i < active.length; i++)
        {
            active[i].scene.sys.render(0, renderer);
        }

        renderer.postRender();
    },

    onHidden: function ()
    {
        this.loop.pause();

        // var active = this.scene.active;

        // for (var i = 0; i < active.length; i++)
        // {
        //     active[i].scene.sys.pause();
        // }
    },

    onVisible: function ()
    {
        this.loop.resume();

        // var active = this.scene.active;

        // for (var i = 0; i < active.length; i++)
        // {
        //     active[i].scene.sys.resume();
        // }
    },

    onBlur: function ()
    {
        this.loop.blur();
    },

    onFocus: function ()
    {
        this.loop.focus();
    }

});

module.exports = Game;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Cameras

module.exports = {

    Camera: __webpack_require__(74),
    PerspectiveCamera: __webpack_require__(121),
    OrthographicCamera: __webpack_require__(120),

    KeyControl: __webpack_require__(122),
    SmoothedKeyControl: __webpack_require__(123)

};


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Create

module.exports = {
  
    GenerateTexture: __webpack_require__(126),
    Grid: __webpack_require__(408),
    Palettes: __webpack_require__(413)

};


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.DOM

module.exports = {

    AddEventListener: __webpack_require__(419),
    AddToDOM: __webpack_require__(130),
    CanvasInterpolation: __webpack_require__(75),
    CanvasPool: __webpack_require__(15),
    DOMContentLoaded: __webpack_require__(131),
    ParseXML: __webpack_require__(132),
    RemoveEventListener: __webpack_require__(420),
    RemoveFromDOM: __webpack_require__(421),
    RequestAnimationFrame: __webpack_require__(133),
    Smoothing: __webpack_require__(76),
    TouchAction: __webpack_require__(422),
    UserSelect: __webpack_require__(423)

};


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.GameObjects

var GameObjects = {

    Components: __webpack_require__(8),

    BitmapText: __webpack_require__(78),
    Blitter: __webpack_require__(79),
    DynamicBitmapText: __webpack_require__(77),
    Graphics: __webpack_require__(83),
    Group: __webpack_require__(84),
    Image: __webpack_require__(56),
    ObjectPool: __webpack_require__(86),
    ParticleEmitter: __webpack_require__(81),
    Sprite: __webpack_require__(31),
    Sprite3D: __webpack_require__(58),
    StaticTilemap: __webpack_require__(91),
    Text: __webpack_require__(89),
    Tilemap: __webpack_require__(90),
    TileSprite: __webpack_require__(92),
    Zone: __webpack_require__(59),

    //  Game Object Factories

    Factories: {
        Blitter: __webpack_require__(440),
        DynamicBitmapText: __webpack_require__(430),
        DynamicTilemap: __webpack_require__(544),
        Graphics: __webpack_require__(494),
        Group: __webpack_require__(498),
        Image: __webpack_require__(501),
        ParticleEmitter: __webpack_require__(490),
        Sprite: __webpack_require__(530),
        Sprite3D: __webpack_require__(527),
        StaticBitmapText: __webpack_require__(435),
        StaticTilemap: __webpack_require__(549),
        Text: __webpack_require__(538),
        TileSprite: __webpack_require__(554),
        Zone: __webpack_require__(558),
    },

    Creators: {
        Blitter: __webpack_require__(439),
        DynamicBitmapText: __webpack_require__(429),
        DynamicTilemap: __webpack_require__(543),
        Graphics: __webpack_require__(493),
        Group: __webpack_require__(497),
        Image: __webpack_require__(500),
        ParticleEmitter: __webpack_require__(489),
        Sprite: __webpack_require__(529),
        Sprite3D: __webpack_require__(526),
        StaticBitmapText: __webpack_require__(434),
        StaticTilemap: __webpack_require__(548),
        Text: __webpack_require__(537),
        TileSprite: __webpack_require__(553),
        Zone: __webpack_require__(557),
    }

};

if (true)
{
    //  WebGL only Game Objects
    GameObjects.EffectLayer = __webpack_require__(80);
    GameObjects.LightLayer = __webpack_require__(85);
    GameObjects.Mesh = __webpack_require__(57);
    GameObjects.Quad = __webpack_require__(87);
    GameObjects.RenderPass = __webpack_require__(88);

    GameObjects.Factories.EffectLayer = __webpack_require__(484);
    GameObjects.Factories.LightLayer = __webpack_require__(509);
    GameObjects.Factories.Mesh = __webpack_require__(515);
    GameObjects.Factories.Quad = __webpack_require__(520);
    GameObjects.Factories.RenderPass = __webpack_require__(523);

    GameObjects.Creators.EffectLayer = __webpack_require__(483);
    GameObjects.Creators.LightLayer = __webpack_require__(508);
    GameObjects.Creators.Mesh = __webpack_require__(514);
    GameObjects.Creators.Quad = __webpack_require__(519);
    GameObjects.Creators.RenderPass = __webpack_require__(522);
}

module.exports = GameObjects;


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom

module.exports = {
    
    Circle: __webpack_require__(570),
    Ellipse: __webpack_require__(581),
    Intersects: __webpack_require__(592),
    Line: __webpack_require__(612),
    Point: __webpack_require__(632),
    Polygon: __webpack_require__(637),
    Rectangle: __webpack_require__(662),
    Triangle: __webpack_require__(676)

};


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Graphics

module.exports = {

    BlendModes: __webpack_require__(691),
    Color: __webpack_require__(700)
  
};


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input

module.exports = {

    Gamepad: __webpack_require__(709),
    Keyboard: __webpack_require__(720),
    Mouse: __webpack_require__(784)

};


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

var RND = __webpack_require__(227);

module.exports = {

    //  Consts
    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,

    //  Random Data Generator
    RND: new RND(),

    //  Collections of functions
    Angle: __webpack_require__(827),
    Distance: __webpack_require__(830),
    Easing: __webpack_require__(223),
    Fuzzy: __webpack_require__(837),
    Interpolation: __webpack_require__(840),
    Pow2: __webpack_require__(842),
    Snap: __webpack_require__(846),

    //  Single functions
    Average: __webpack_require__(802),
    Bernstein: __webpack_require__(198),
    Between: __webpack_require__(65),
    CatmullRom: __webpack_require__(105),
    CeilTo: __webpack_require__(803),
    Clamp: __webpack_require__(52),
    DegToRad: __webpack_require__(106),
    Difference: __webpack_require__(804),
    Factorial: __webpack_require__(199),
    FloatBetween: __webpack_require__(805),
    FloorTo: __webpack_require__(806),
    GetSpeed: __webpack_require__(807),
    IsEven: __webpack_require__(808),
    IsEvenStrict: __webpack_require__(809),
    Linear: __webpack_require__(200),
    MaxAdd: __webpack_require__(810),
    MinSub: __webpack_require__(811),
    Percent: __webpack_require__(812),
    RadToDeg: __webpack_require__(813),
    RandomXY: __webpack_require__(814),
    RandomXYZ: __webpack_require__(203),
    RandomXYZW: __webpack_require__(204),
    Rotate: __webpack_require__(815),
    RotateAround: __webpack_require__(816),
    RotateAroundDistance: __webpack_require__(107),
    RoundAwayFromZero: __webpack_require__(206),
    RoundTo: __webpack_require__(817),
    SinCosTableGenerator: __webpack_require__(818),
    SmootherStep: __webpack_require__(208),
    SmoothStep: __webpack_require__(207),
    Within: __webpack_require__(819),
    Wrap: __webpack_require__(67),

    //  Vector classes
    Vector2: __webpack_require__(20),
    Vector3: __webpack_require__(34),
    Vector4: __webpack_require__(66),
    Matrix3: __webpack_require__(201),
    Matrix4: __webpack_require__(53),
    Quaternion: __webpack_require__(202),
    RotateVec3: __webpack_require__(205)

};


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Curves

module.exports = {
    
    CubicBezier: __webpack_require__(848),
    Ellipse: __webpack_require__(849),
    Line: __webpack_require__(228),
    Spline: __webpack_require__(850)

};

//     Hermite: require('./curves/hermite')


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Paths

//  Phaser.Curves.Path ? or ...
//  Phaser.Paths.Path ?

module.exports = {

    Path: __webpack_require__(847)

};


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(880);
__webpack_require__(881);
__webpack_require__(882);
__webpack_require__(886);
__webpack_require__(883);
__webpack_require__(884);
__webpack_require__(887);
__webpack_require__(888);
__webpack_require__(885);


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Sound

module.exports = {

    Dynamic: __webpack_require__(969)

};


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Structs

module.exports = {

    Map: __webpack_require__(234),
    RTree: __webpack_require__(970),
    Set: __webpack_require__(54)

};


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Utils

module.exports = {

    Align: __webpack_require__(1033),
    Array: __webpack_require__(1038),
    Bounds: __webpack_require__(1041),
    Objects: __webpack_require__(1044),
    String: __webpack_require__(1047)

};


/***/ }),
/* 275 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 276 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 277 */
/***/ (function(module, exports) {

var Angle = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].angle += value;
    }

    return items;
};

module.exports = Angle;


/***/ }),
/* 278 */
/***/ (function(module, exports) {

var Call = function (items, callback, thisArg)
{
    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];

        callback.call(thisArg, item);
    }

    return items;
};

module.exports = Call;


/***/ }),
/* 279 */
/***/ (function(module, exports) {

//  compare = Object:
//  {
//      scaleX: 0.5,
//      scaleY: 1
//  }

var GetFirst = function (items, compare, index)
{
    for (var i = index; i < items.length; i++)
    {
        var item = items[i];

        var match = true;

        for (var property in compare)
        {
            if (item[property] !== compare[property])
            {
                match = false;
            }
        }

        if (match)
        {
            return item;
        }
    }

    return null;
};

module.exports = GetFirst;


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(248);
var AlignIn = __webpack_require__(1020);
var Zone = __webpack_require__(59);
var GetValue = __webpack_require__(4);

var tempZone = new Zone({ sys: { sortChildrenFlag: false }}, 0, 0, 1, 1);

var GridAlign = function (items, options)
{
    var width = GetValue(options, 'width', -1);
    var height = GetValue(options, 'height', -1);
    var cellWidth = GetValue(options, 'cellWidth', 1);
    var cellHeight = GetValue(options, 'cellHeight', cellWidth);
    var position = GetValue(options, 'position', CONST.TOP_LEFT);
    var x = GetValue(options, 'x', 0);
    var y = GetValue(options, 'y', 0);
    // var centerX = GetValue(options, 'centerX', null);
    // var centerY = GetValue(options, 'centerY', null);

    var cx = 0;
    var cy = 0;
    var w = (width * cellWidth);
    var h = (height * cellHeight);

    //  If the Grid is centered on a position then we need to calculate it now
    // if (centerX !== null && centerY !== null)
    // {
        // 
    // }

    tempZone.setPosition(x, y);
    tempZone.setSize(cellWidth, cellHeight);

    for (var i = 0; i < items.length; i++)
    {
        AlignIn(items[i], tempZone, position);

        if (width === -1)
        {
            //  We keep laying them out horizontally until we've done them all
            cy += cellHeight;
            tempZone.y += cellHeight;

            if (cy === h)
            {
                cy = 0;
                tempZone.x += cellWidth;
                tempZone.y = y;
            }
        }
        else if (height === -1)
        {
            //  We keep laying them out vertically until we've done them all
            cx += cellWidth;
            tempZone.x += cellWidth;

            if (cx === w)
            {
                cx = 0;
                tempZone.x = x;
                tempZone.y += cellHeight;
            }
        }
        else
        {
            //  We keep laying them out until we hit the column limit
            cx += cellWidth;
            tempZone.x += cellWidth;

            if (cx === w)
            {
                cx = 0;
                cy += cellHeight;
                tempZone.x = x;
                tempZone.y += cellHeight;

                if (cy === h)
                {
                    //  We've hit the column limit, so return, even if there are items left
                    break;
                }
            }
        }
    }

    return items;
};

module.exports = GridAlign;


/***/ }),
/* 281 */
/***/ (function(module, exports) {

var IncAlpha = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].alpha += value;
    }

    return items;
};

module.exports = IncAlpha;


/***/ }),
/* 282 */
/***/ (function(module, exports) {

var IncX = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].x += value;
    }

    return items;
};

module.exports = IncX;


/***/ }),
/* 283 */
/***/ (function(module, exports) {

var IncXY = function (items, x, y)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].x += x;
        items[i].y += y;
    }

    return items;
};

module.exports = IncXY;


/***/ }),
/* 284 */
/***/ (function(module, exports) {

var IncY = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].y += value;
    }

    return items;
};

module.exports = IncY;


/***/ }),
/* 285 */
/***/ (function(module, exports) {

var PlaceOnCircle = function (items, circle, startAngle, endAngle)
{
    if (startAngle === undefined) { startAngle = 0; }
    if (endAngle === undefined) { endAngle = 6.28; }

    var angle = startAngle;
    var angleStep = (endAngle - startAngle) / items.length;

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = circle.x + (circle.radius * Math.cos(angle));
        items[i].y = circle.y + (circle.radius * Math.sin(angle));

        angle += angleStep;
    }

    return items;
};

module.exports = PlaceOnCircle;


/***/ }),
/* 286 */
/***/ (function(module, exports) {

var PlaceOnEllipse = function (items, ellipse, startAngle, endAngle)
{
    if (startAngle === undefined) { startAngle = 0; }
    if (endAngle === undefined) { endAngle = 6.28; }

    var angle = startAngle;
    var angleStep = (endAngle - startAngle) / items.length;

    var a = ellipse.width / 2;
    var b = ellipse.height / 2;

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = ellipse.x + a * Math.cos(angle);
        items[i].y = ellipse.y + b * Math.sin(angle);

        angle += angleStep;
    }

    return items;
};

module.exports = PlaceOnEllipse;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

var GetPointsOnLine = __webpack_require__(94);

var PlaceOnLine = function (items, line)
{
    var points = GetPointsOnLine(line);
    var step = points.length / items.length;
    var p = 0;

    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];
        var point = points[Math.floor(p)];

        item.x = point[0];
        item.y = point[1];

        p += step;
    }

    return items;
};

module.exports = PlaceOnLine;


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var MarchingAnts = __webpack_require__(157);
var RotateLeft = __webpack_require__(252);
var RotateRight = __webpack_require__(253);

//  Place the items in the array around the perimeter of the given rectangle.

//  Placement starts from the top-left of the rectangle, and proceeds in a
//  clockwise direction. If the shift parameter is given you can offset where
//  placement begins.

var PlaceOnRectangle = function (items, rect, shift)
{
    if (shift === undefined) { shift = 0; }

    var points = MarchingAnts(rect, false, items.length);

    if (shift > 0)
    {
        RotateLeft(points, shift);
    }
    else if (shift < 0)
    {
        RotateRight(points, Math.abs(shift));
    }

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = points[i].x;
        items[i].y = points[i].y;
    }

    return items;
};

module.exports = PlaceOnRectangle;


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var GetPointsOnLine = __webpack_require__(94);

var PlaceOnTriangle = function (items, triangle, stepRate)
{
    var p1 = GetPointsOnLine({ x1: triangle.x1, y1: triangle.y1, x2: triangle.x2, y2: triangle.y2 }, stepRate);
    var p2 = GetPointsOnLine({ x1: triangle.x2, y1: triangle.y2, x2: triangle.x3, y2: triangle.y3 }, stepRate);
    var p3 = GetPointsOnLine({ x1: triangle.x3, y1: triangle.y3, x2: triangle.x1, y2: triangle.y1 }, stepRate);

    //  Remove overlaps
    p1.pop();
    p2.pop();
    p3.pop();

    p1 = p1.concat(p2, p3);

    var step = p1.length / items.length;
    var p = 0;

    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];
        var point = p1[Math.floor(p)];

        item.x = point[0];
        item.y = point[1];

        p += step;
    }

    return items;
};

module.exports = PlaceOnTriangle;


/***/ }),
/* 290 */
/***/ (function(module, exports) {

var PlayAnimation = function (items, key, startFrame)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].anims.play(key, startFrame);
    }

    return items;
};

module.exports = PlayAnimation;


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var Random = __webpack_require__(140);

var RandomCircle = function (items, circle)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(circle, items[i]);
    }

    return items;
};

module.exports = RandomCircle;


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

var Random = __webpack_require__(141);

var RandomEllipse = function (items, ellipse)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(ellipse, items[i]);
    }

    return items;
};

module.exports = RandomEllipse;


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

var Random = __webpack_require__(147);

var RandomLine = function (items, line)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(line, items[i]);
    }

    return items;
};

module.exports = RandomLine;


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var Random = __webpack_require__(159);

var RandomRectangle = function (items, rect)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(rect, items[i]);
    }

    return items;
};

module.exports = RandomRectangle;


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var Random = __webpack_require__(164);

var RandomTriangle = function (items, triangle)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(triangle, items[i]);
    }

    return items;
};

module.exports = RandomTriangle;


/***/ }),
/* 296 */
/***/ (function(module, exports) {

var Rotate = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].rotation += value + (i * step);
    }

    return items;
};

module.exports = Rotate;


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var RotateAroundDistance = __webpack_require__(107);
var DistanceBetween = __webpack_require__(68);

//  point = any object with public x/y properties

var RotateAround = function (items, point, angle)
{
    var x = point.x;
    var y = point.y;

    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];

        RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));
    }

    return items;
};

module.exports = RotateAround;


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

var MathRotateAroundDistance = __webpack_require__(107);

//  point = any object with public x/y properties
//  angle = radians
//  distance = px

var RotateAroundDistance = function (items, point, angle, distance)
{
    var x = point.x;
    var y = point.y;

    for (var i = 0; i < items.length; i++)
    {
        MathRotateAroundDistance(items[i], x, y, angle, distance);
    }

    return items;
};

module.exports = RotateAroundDistance;


/***/ }),
/* 299 */
/***/ (function(module, exports) {

var ScaleX = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleX += value;
    }

    return items;
};

module.exports = ScaleX;


/***/ }),
/* 300 */
/***/ (function(module, exports) {

var ScaleXY = function (items, x, y)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleX += x;
        items[i].scaleY += y;
    }

    return items;
};

module.exports = ScaleXY;


/***/ }),
/* 301 */
/***/ (function(module, exports) {

var ScaleY = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleY += value;
    }

    return items;
};

module.exports = ScaleY;


/***/ }),
/* 302 */
/***/ (function(module, exports) {

var SetAlpha = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].alpha = value + (i * step);
    }

    return items;
};

module.exports = SetAlpha;


/***/ }),
/* 303 */
/***/ (function(module, exports) {

var SetBlendMode = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].setBlendMode(value);
    }

    return items;
};

module.exports = SetBlendMode;


/***/ }),
/* 304 */
/***/ (function(module, exports) {

var SetDepth = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].depth = value + (i * step);
    }

    return items;
};

module.exports = SetDepth;


/***/ }),
/* 305 */
/***/ (function(module, exports) {

var SetHitArea = function (items, hitArea, hitAreaCallback)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].setHitArea(hitArea, hitAreaCallback);
    }

    return items;
};

module.exports = SetHitArea;


/***/ }),
/* 306 */
/***/ (function(module, exports) {

var SetOrigin = function (items, x, y)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].setOrigin(x, y);
    }

    return items;
};

module.exports = SetOrigin;


/***/ }),
/* 307 */
/***/ (function(module, exports) {

var SetRotation = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].rotation = value + (i * step);
    }

    return items;
};

module.exports = SetRotation;


/***/ }),
/* 308 */
/***/ (function(module, exports) {

var SetScale = function (items, x, y, stepX, stepY)
{
    if (stepX === undefined) { stepX = 0; }
    if (stepY === undefined) { stepY = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].setScale(
            x + (i * stepX),
            y + (i * stepY)
        );
    }

    return items;
};

module.exports = SetScale;


/***/ }),
/* 309 */
/***/ (function(module, exports) {

var SetScaleX = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleX = value + (i * step);
    }

    return items;
};

module.exports = SetScaleX;


/***/ }),
/* 310 */
/***/ (function(module, exports) {

var SetScaleY = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleY = value + (i * step);
    }

    return items;
};

module.exports = SetScaleY;


/***/ }),
/* 311 */
/***/ (function(module, exports) {

var SetVisible = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].visible = value;
    }

    return items;
};

module.exports = SetVisible;


/***/ }),
/* 312 */
/***/ (function(module, exports) {

var SetX = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = value + (i * step);
    }

    return items;
};

module.exports = SetX;


/***/ }),
/* 313 */
/***/ (function(module, exports) {

var SetXY = function (items, x, y, stepX, stepY)
{
    if (stepX === undefined) { stepX = 0; }
    if (stepY === undefined) { stepY = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = x + (i * stepX);
        items[i].y = y + (i * stepY);
    }

    return items;
};

module.exports = SetXY;


/***/ }),
/* 314 */
/***/ (function(module, exports) {

var SetY = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].y = value + (i * step);
    }

    return items;
};

module.exports = SetY;


/***/ }),
/* 315 */
/***/ (function(module, exports) {

//  Iterate through items changing the position of each element to
//  be that of the element that came before it in the array (or after it if direction = 1)
//  The first items position is set to x/y.
//  The final x/y coords are returned

var ShiftPosition = function (items, x, y, direction, output)
{
    if (direction === undefined) { direction = 0; }
    if (output === undefined) { output = { x: 0, y: 0 }; }

    var px;
    var py;

    if (items.length > 1)
    {
        var i;
        var cx;
        var cy;
        var cur;

        if (direction === 0)
        {
            //  Bottom to Top

            var len = items.length - 1;

            px = items[len].x;
            py = items[len].y;

            for (i = len - 1; i >= 0; i--)
            {
                //  Current item
                cur = items[i];

                //  Get current item x/y, to be passed to the next item in the list
                cx = cur.x;
                cy = cur.y;

                //  Set current item to the previous items x/y
                cur.x = px;
                cur.y = py;

                //  Set current as previous
                px = cx;
                py = cy;
            }

            //  Update the head item to the new x/y coordinates
            items[len].x = x;
            items[len].y = y;
        }
        else
        {
            //  Top to Bottom

            px = items[0].x;
            py = items[0].y;

            for (i = 1; i < items.length; i++)
            {
                //  Current item
                cur = items[i];

                //  Get current item x/y, to be passed to the next item in the list
                cx = cur.x;
                cy = cur.y;

                //  Set current item to the previous items x/y
                cur.x = px;
                cur.y = py;

                //  Set current as previous
                px = cx;
                py = cy;
            }

            //  Update the head item to the new x/y coordinates
            items[0].x = x;
            items[0].y = y;
        }
    }
    else
    {
        px = items[0].x;
        py = items[0].y;

        items[0].x = x;
        items[0].y = y;
    }

    //  Return the final set of coordinates as they're effectively lost from the shift and may be needed

    output.x = px;
    output.y = py;

    return output;
};

module.exports = ShiftPosition;


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var MathSmoothStep = __webpack_require__(207);

var SmoothStep = function (items, property, min, max, inc)
{
    if (inc === undefined) { inc = false; }

    var step = Math.abs(max - min) / items.length;
    var i;

    if (inc)
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] += MathSmoothStep(i * step, min, max);
        }
    }
    else
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] = MathSmoothStep(i * step, min, max);
        }
    }

    return items;
};

module.exports = SmoothStep;


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var MathSmootherStep = __webpack_require__(208);

var SmootherStep = function (items, property, min, max, inc)
{
    if (inc === undefined) { inc = false; }

    var step = Math.abs(max - min) / items.length;
    var i;

    if (inc)
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] += MathSmootherStep(i * step, min, max);
        }
    }
    else
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] = MathSmootherStep(i * step, min, max);
        }
    }

    return items;
};

module.exports = SmootherStep;


/***/ }),
/* 318 */
/***/ (function(module, exports) {

var Spread = function (items, property, min, max, inc)
{
    if (inc === undefined) { inc = false; }

    var step = Math.abs(max - min) / items.length;
    var i;

    if (inc)
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] += i * step;
        }
    }
    else
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] = i * step;
        }
    }

    return items;
};

module.exports = Spread;


/***/ }),
/* 319 */
/***/ (function(module, exports) {

var ToggleVisible = function (items)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].visible = !items[i].visible;
    }

    return items;
};

module.exports = ToggleVisible;


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GetValue = __webpack_require__(4);
var GetFrames = __webpack_require__(118);

//  A Frame based Animation
//  This consists of a key, some default values (like the frame rate) and a bunch of Frame objects.
//  The Animation Manager creates these
//  Game Objects don't own an instance of these directly
//  Game Objects have the Animation Component, which are like playheads to global Animations (these objects)
//  So multiple Game Objects can have playheads all pointing to this one Animation instance

var Animation = new Class({

    initialize:

    function Animation (manager, key, config)
    {
        this.manager = manager;

        this.key = key;

        //  A frame based animation (as opposed to a bone based animation)
        this.type = 'frame';

        //  Extract all the frame data into the frames array
        this.frames = GetFrames(manager.textureManager, GetValue(config, 'frames', []));

        //  The frame rate of playback in frames per second (default 24 if duration is null)
        this.frameRate = GetValue(config, 'frameRate', null);

        //  How long the animation should play for. If frameRate is set it overrides this value
        //  otherwise frameRate is derived from duration
        this.duration = GetValue(config, 'duration', null);

        if (this.duration === null && this.frameRate === null)
        {
            //  No duration or frameRate given, use default frameRate of 24fps
            this.frameRate = 24;
            this.duration = this.frameRate / this.frames.length;
        }
        else if (this.duration && this.frameRate === null)
        {
            //  Duration given but no frameRate, so set the frameRate based on duration
            //  I.e. 12 frames in the animation, duration = 4 (4000 ms)
            //  So frameRate is 12 / 4 = 3 fps
            this.frameRate = this.frames.length / this.duration;
        }
        else
        {
            //  frameRate given, derive duration from it (even if duration also specified)
            //  I.e. 15 frames in the animation, frameRate = 30 fps
            //  So duration is 15 / 30 = 0.5 (half a second)
            this.duration = this.frames.length / this.frameRate;
        }

        //  ms per frame (without including frame specific modifiers)
        this.msPerFrame = 1000 / this.frameRate;

        //  Skip frames if the time lags, or always advanced anyway?
        this.skipMissedFrames = GetValue(config, 'skipMissedFrames', true);

        //  Delay before starting playback (in seconds)
        this.delay = GetValue(config, 'delay', 0);

        //  Number of times to repeat the animation (-1 for infinity)
        this.repeat = GetValue(config, 'repeat', 0);

        //  Delay before the repeat starts (in seconds)
        this.repeatDelay = GetValue(config, 'repeatDelay', 0);

        //  Should the animation yoyo? (reverse back down to the start) before repeating?
        this.yoyo = GetValue(config, 'yoyo', false);

        //  Should sprite.visible = true when the animation starts to play?
        this.showOnStart = GetValue(config, 'showOnStart', false);

        //  Should sprite.visible = false when the animation finishes?
        this.hideOnComplete = GetValue(config, 'hideOnComplete', false);

        //  Callbacks
        this.callbackScope = GetValue(config, 'callbackScope', this);

        this.onStart = GetValue(config, 'onStart', false);
        this.onStartParams = GetValue(config, 'onStartParams', []);

        this.onRepeat = GetValue(config, 'onRepeat', false);
        this.onRepeatParams = GetValue(config, 'onRepeatParams', []);

        //  Called for EVERY frame of the animation.
        //  See AnimationFrame.onUpdate for a frame specific callback.
        this.onUpdate = GetValue(config, 'onUpdate', false);
        this.onUpdateParams = GetValue(config, 'onUpdateParams', []);

        this.onComplete = GetValue(config, 'onComplete', false);
        this.onCompleteParams = GetValue(config, 'onCompleteParams', []);

        //  Global pause, effects all Game Objects using this Animation instance
        this.paused = false;

        this.manager.events.on('PAUSE_ALL_ANIMATION_EVENT', this.pause.bind(this));
        this.manager.events.on('RESUME_ALL_ANIMATION_EVENT', this.resume.bind(this));
    },

    addFrame: __webpack_require__(321),
    addFrameAt: __webpack_require__(322),
    checkFrame: __webpack_require__(323),
    completeAnimation: __webpack_require__(324),
    getFirstTick: __webpack_require__(326),
    getFrameAt: __webpack_require__(327),
    getNextTick: __webpack_require__(328),
    load: __webpack_require__(329),
    nextFrame: __webpack_require__(330),
    previousFrame: __webpack_require__(331),
    removeFrame: __webpack_require__(332),
    removeFrameAt: __webpack_require__(333),
    repeatAnimation: __webpack_require__(334),
    setFrame: __webpack_require__(335),
    toJSON: __webpack_require__(336),
    updateFrameSequence: __webpack_require__(337),

    pause: function ()
    {
        this.paused = true;
    },

    resume: function ()
    {
        this.paused = false;
    },

    destroy: function ()
    {

    }

});

module.exports = Animation;


/***/ }),
/* 321 */
/***/ (function(module, exports) {

//  config = Array of Animation config objects, like:
//  [
//      { key: 'gems', frame: 'diamond0001', [duration], [visible], [onUpdate] }
//  ]

//  Add frames to the end of the animation
var AddFrame = function (config)
{
    return this.addFrameAt(this.frames.length, config);
};

module.exports = AddFrame;


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

var GetFrames = __webpack_require__(118);

//  config = Array of Animation config objects, like:
//  [
//      { key: 'gems', frame: 'diamond0001', [duration], [visible], [onUpdate] }
//  ]

//  Add frame/s into the animation
var AddFrameAt = function (index, config)
{
    if (index === undefined) { index = 0; }

    var newFrames = GetFrames(this.manager.textureManager, config);

    if (newFrames.length > 0)
    {
        if (index === 0)
        {
            this.frames = newFrames.concat(this.frames);
        }
        else if (index === this.frames.length)
        {
            this.frames = this.frames.concat(newFrames);
        }
        else
        {
            var pre = this.frames.slice(0, index);
            var post = this.frames.slice(index);

            this.frames = pre.concat(newFrames, post);
        }

        this.updateFrameSequence();
    }

    return this;
};

module.exports = AddFrameAt;


/***/ }),
/* 323 */
/***/ (function(module, exports) {

var CheckFrame = function (index)
{
    return (index < this.frames.length);
};

module.exports = CheckFrame;


/***/ }),
/* 324 */
/***/ (function(module, exports) {

var CompleteAnimation = function (component)
{
    if (this.hideOnComplete)
    {
        component.parent.visible = false;
    }

    component.stop(true);
};

module.exports = CompleteAnimation;


/***/ }),
/* 325 */
/***/ (function(module, exports) {

var Frame = function (textureKey, textureFrame, index, frame)
{
    //  The keys into the Texture Manager of the texture + frame this uses
    this.textureKey = textureKey;
    this.textureFrame = textureFrame;

    //  The index of this frame within the Animation.frames array
    this.index = index;

    //  Texture Frame
    this.frame = frame;

    //  Read-only
    this.isFirst = false;

    //  Read-only
    this.isLast = false;

    //  The frame that comes before this one in the animation (if any)
    //  Read-only
    this.prevFrame = null;

    //  The frame that comes after this one in the animation (if any)
    //  Read-only
    this.nextFrame = null;

    //   Additional time (in ms) this frame should appear for - added onto the msPerFrame
    this.duration = 0;

    //   What % through the animation progress is this frame?
    //  Read-only
    this.progress = 0;

    //  Callback if this frame gets displayed
    this.onUpdate = null;

    //  When this frame hits, set sprite.visible to this
    this.setVisible = false;

    this.visible = false;
};

Frame.prototype.constructor = Frame;

Frame.prototype = {

    toJSON: function ()
    {
        return {
            key: this.textureKey,
            frame: this.textureFrame,
            duration: this.duration,
            visible: this.visible
        };
    },

    destroy: function ()
    {
        this.frame = undefined;
        this.onUpdate = undefined;
    }

};

module.exports = Frame;


/***/ }),
/* 326 */
/***/ (function(module, exports) {

var GetFirstTick = function (component, includeDelay)
{
    if (includeDelay === undefined) { includeDelay = true; }

    //  When is the first update due?
    component.accumulator = 0;
    component.nextTick = component.msPerFrame + component.currentFrame.duration;

    if (includeDelay)
    {
        component.nextTick += (component._delay * 1000);
    }
};

module.exports = GetFirstTick;


/***/ }),
/* 327 */
/***/ (function(module, exports) {

var GetFrameAt = function (index)
{
    return this.frames[index];
};

module.exports = GetFrameAt;


/***/ }),
/* 328 */
/***/ (function(module, exports) {

var GetNextTick = function (component)
{
    // accumulator += delta * _timeScale
    // after a large delta surge (perf issue for example) we need to adjust for it here

    //  When is the next update due?
    component.accumulator -= component.nextTick;

    component.nextTick = component.msPerFrame + component.currentFrame.duration;
};

module.exports = GetNextTick;


/***/ }),
/* 329 */
/***/ (function(module, exports) {

var Load = function (component, startFrame)
{
    if (startFrame >= this.frames.length)
    {
        startFrame = 0;
    }

    if (component.currentAnim !== this)
    {
        component.currentAnim = this;

        component._timeScale = 1;
        component.frameRate = this.frameRate;
        component.duration = this.duration;
        component.msPerFrame = this.msPerFrame;
        component.skipMissedFrames = this.skipMissedFrames;
        component._delay = this.delay;
        component._repeat = this.repeat;
        component._repeatDelay = this.repeatDelay;
        component._yoyo = this.yoyo;
        component._callbackArgs[1] = this;
        component._updateParams = component._callbackArgs.concat(this.onUpdateParams);
    }

    component.updateFrame(this.frames[startFrame]);
};

module.exports = Load;


/***/ }),
/* 330 */
/***/ (function(module, exports) {

var NextFrame = function (component)
{
    var frame = component.currentFrame;

    //  TODO: Add frame skip support

    if (frame.isLast)
    {
        //  We're at the end of the animation

        //  Yoyo? (happens before repeat)
        if (this.yoyo)
        {
            component.forward = false;

            component.updateFrame(frame.prevFrame);

            //  Delay for the current frame
            this.getNextTick(component);
        }
        else if (component.repeatCounter > 0)
        {
            //  Repeat (happens before complete)
            this.repeatAnimation(component);
        }
        else
        {
            this.completeAnimation(component);
        }
    }
    else
    {
        component.updateFrame(frame.nextFrame);

        this.getNextTick(component);
    }
};

module.exports = NextFrame;


/***/ }),
/* 331 */
/***/ (function(module, exports) {

var PreviousFrame = function (component)
{
    var frame = component.currentFrame;

    //  TODO: Add frame skip support

    if (frame.isFirst)
    {
        //  We're at the start of the animation

        if (component.repeatCounter > 0)
        {
            //  Repeat (happens before complete)
            this.repeatAnimation(component);
        }
        else
        {
            this.completeAnimation(component);
        }
    }
    else
    {
        component.updateFrame(frame.prevFrame);

        this.getNextTick(component);
    }
};

module.exports = PreviousFrame;


/***/ }),
/* 332 */
/***/ (function(module, exports) {

//  Remove frame if it matches the given frame
var RemoveFrame = function (frame)
{
    var index = this.frames.indexOf(frame);

    if (index !== -1)
    {
        this.removeFrameAt(index);
    }

    return this;
};

module.exports = RemoveFrame;


/***/ }),
/* 333 */
/***/ (function(module, exports) {

var RemoveFrameAt = function (index)
{
    this.frames.splice(index, 1);

    this.updateFrameSequence();

    return this;
};

module.exports = RemoveFrameAt;


/***/ }),
/* 334 */
/***/ (function(module, exports) {

var RepeatAnimation = function (component)
{
    if (component._repeatDelay > 0 && component.pendingRepeat === false)
    {
        component.pendingRepeat = true;
        component.accumulator -= component.nextTick;
        component.nextTick += (component._repeatDelay * 1000);
    }
    else
    {
        component.repeatCounter--;

        component.forward = true;

        component.updateFrame(component.currentFrame.nextFrame);

        this.getNextTick(component);

        component.pendingRepeat = false;

        if (this.onRepeat)
        {
            this.onRepeat.apply(this.callbackScope, component._callbackArgs.concat(this.onRepeatParams));
        }
    }
};

module.exports = RepeatAnimation;


/***/ }),
/* 335 */
/***/ (function(module, exports) {

var SetFrame = function (component)
{
    //  Work out which frame should be set next on the child, and set it
    if (component.forward)
    {
        this.nextFrame(component);
    }
    else
    {
        this.previousFrame(component);
    }
};

module.exports = SetFrame;


/***/ }),
/* 336 */
/***/ (function(module, exports) {

var ToJSON = function ()
{
    var output = {
        key: this.key,
        type: this.type,
        frames: [],
        frameRate: this.frameRate,
        duration: this.duration,
        skipMissedFrames: this.skipMissedFrames,
        delay: this.delay,
        repeat: this.repeat,
        repeatDelay: this.repeatDelay,
        yoyo: this.yoyo,
        showOnStart: this.showOnStart,
        hideOnComplete: this.hideOnComplete
    };

    this.frames.forEach(function (frame)
    {
        output.frames.push(frame.toJSON());
    });

    return output;
};

module.exports = ToJSON;


/***/ }),
/* 337 */
/***/ (function(module, exports) {

var UpdateFrameSequence = function ()
{
    var len = this.frames.length;
    var slice = 1 / (len - 1);

    for (var i = 0; i < len; i++)
    {
        var frame = this.frames[i];

        frame.index = i + 1;
        frame.isFirst = false;
        frame.isLast = false;
        frame.progress = i * slice;

        if (i === 0)
        {
            frame.isFirst = true;
            frame.isLast = (len === 1);
            frame.prevFrame = this.frames[len - 1];
            frame.nextFrame = this.frames[i + 1];
        }
        else if (i === len - 1)
        {
            frame.isLast = true;
            frame.prevFrame = this.frames[len - 2];
            frame.nextFrame = this.frames[0];
        }
        else if (len > 1)
        {
            frame.prevFrame = this.frames[i - 1];
            frame.nextFrame = this.frames[i + 1];
        }
    }

    return this;
};

module.exports = UpdateFrameSequence;


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var EventDispatcher = __webpack_require__(30);
var Map = __webpack_require__(234);

// Animations are managed by the global AnimationManager. This is a singleton class that is
// responsible for creating and delivering animations and their corresponding data to Game Objects.
// Sprites and other Game Objects get the data they need from the AnimationManager.
// Access it via `scene.anims`.

var AnimationManager = new Class({

    initialize:

    function AnimationManager (game)
    {
        this.game = game;

        this.textureManager = null;

        this.events = new EventDispatcher();

        this.globalTimeScale = 1;

        this.anims = new Map();

        this.paused = false;
    },

    boot: function (textureManager)
    {
        this.textureManager = textureManager;
    },

    add: __webpack_require__(343),
    create: __webpack_require__(344),
    fromJSON: __webpack_require__(345),
    generateFrameNames: __webpack_require__(346),
    generateFrameNumbers: __webpack_require__(347),
    get: __webpack_require__(348),
    load: __webpack_require__(349),
    pauseAll: __webpack_require__(350),
    play: __webpack_require__(351),
    remove: __webpack_require__(352),
    resumeAll: __webpack_require__(353),
    staggerPlay: __webpack_require__(354),
    toJSON: __webpack_require__(355),

    destroy: function ()
    {
        //  TODO
    }

});

module.exports = AnimationManager;


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var AddAnimationEvent = new Class({

    Extends: Event,

    initialize:

    function AddAnimationEvent (key, animation)
    {
        Event.call(this, 'ADD_ANIMATION_EVENT');

        this.key = key;
        this.animation = animation;
    }

});

module.exports = AddAnimationEvent;


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var PauseAllAnimationEvent = new Class({

    Extends: Event,

    initialize:

    function PauseAllAnimationEvent ()
    {
        Event.call(this, 'PAUSE_ALL_ANIMATION_EVENT');
    }

});

module.exports = PauseAllAnimationEvent;


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var RemoveAnimationEvent = new Class({

    Extends: Event,

    initialize:

    function RemoveAnimationEvent (key, animation)
    {
        Event.call(this, 'REMOVE_ANIMATION_EVENT');

        this.key = key;
        this.animation = animation;
    }

});

module.exports = RemoveAnimationEvent;


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var ResumeAllAnimationEvent = new Class({

    Extends: Event,

    initialize:

    function ResumeAllAnimationEvent ()
    {
        Event.call(this, 'RESUME_ALL_ANIMATION_EVENT');
    }

});

module.exports = ResumeAllAnimationEvent;


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(49);

var AddAnimation = function (key, animation)
{
    if (this.anims.has(key))
    {
        console.error('Animation with key', key, 'already exists');
        return;
    }

    animation.key = key;

    this.anims.set(key, animation);

    this.events.dispatch(new Event.ADD_ANIMATION_EVENT(key, animation));

    return this;
};

module.exports = AddAnimation;


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(49);
var Animation = __webpack_require__(320);

var CreateFrameAnimation = function (config)
{
    var key = config.key;

    if (!key || this.anims.has(key))
    {
        console.warn('Invalid Animation Key, or Key already in use: ' + key);
        return;
    }

    var anim = new Animation(this, key, config);

    this.anims.set(key, anim);

    this.events.dispatch(new Event.ADD_ANIMATION_EVENT(key, anim));

    return anim;
};

module.exports = CreateFrameAnimation;


/***/ }),
/* 345 */
/***/ (function(module, exports) {

var FromJSON = function (data, clearCurrentAnimations)
{
    if (clearCurrentAnimations === undefined) { clearCurrentAnimations = false; }

    if (clearCurrentAnimations)
    {
        this.anims.clear();
    }

    //  Do we have a String (i.e. from JSON, or an Object?)
    if (typeof data === 'string')
    {
        data = JSON.parse(data);
    }

    var output = [];

    //  Array of animations, or a single animation?
    if (data.hasOwnProperty('anims') && Array.isArray(data.anims))
    {
        for (var i = 0; i < data.anims.length; i++)
        {
            output.push(this.create(data.anims[i]));
        }

        if (data.hasOwnProperty('globalTimeScale'))
        {
            this.globalTimeScale = data.globalTimeScale;
        }
    }
    else if (data.hasOwnProperty('key') && data.type === 'frame')
    {
        output.push(this.create(data));
    }

    return output;
};

module.exports = FromJSON;


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(4);
var Pad = __webpack_require__(259);

var GenerateFrameNames = function (key, config)
{
    var prefix = GetValue(config, 'prefix', '');
    var start = GetValue(config, 'start', 0);
    var end = GetValue(config, 'end', 0);
    var suffix = GetValue(config, 'suffix', '');
    var zeroPad = GetValue(config, 'zeroPad', 0);
    var out = GetValue(config, 'outputArray', []);
    var frames = GetValue(config, 'frames', false);

    var texture = this.textureManager.get(key);

    if (!texture)
    {
        return out;
    }

    var diff = (start < end) ? 1 : -1;

    //  Adjust because we use i !== end in the for loop
    end += diff;

    var i;
    var frame;

    //  Have they provided their own custom frame sequence array?
    if (Array.isArray(frames))
    {
        for (i = 0; i < frames.length; i++)
        {
            frame = prefix + Pad(frames[i], zeroPad, '0', 1) + suffix;

            if (texture.has(frame))
            {
                out.push({ key: key, frame: frame });
            }
        }
    }
    else
    {
        for (i = start; i !== end; i += diff)
        {
            frame = prefix + Pad(i, zeroPad, '0', 1) + suffix;

            if (texture.has(frame))
            {
                out.push({ key: key, frame: frame });
            }
        }
    }

    return out;
};

module.exports = GenerateFrameNames;


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(4);

var GenerateFrameNumbers = function (key, config)
{
    var startFrame = GetValue(config, 'start', 0);
    var endFrame = GetValue(config, 'end', -1);
    var firstFrame = GetValue(config, 'first', false);
    var out = GetValue(config, 'outputArray', []);
    var frames = GetValue(config, 'frames', false);

    var texture = this.textureManager.get(key);

    if (!texture)
    {
        return out;
    }

    if (firstFrame && texture.has(firstFrame))
    {
        out.push({ key: key, frame: firstFrame });
    }

    var i;

    //  Have they provided their own custom frame sequence array?
    if (Array.isArray(frames))
    {
        for (i = 0; i < frames.length; i++)
        {
            if (texture.has(frames[i]))
            {
                out.push({ key: key, frame: frames[i] });
            }
        }
    }
    else
    {
        //  No endFrame then see if we can get it

        if (endFrame === -1)
        {
            endFrame = texture.frameTotal;
        }

        for (i = startFrame; i <= endFrame; i++)
        {
            if (texture.has(i))
            {
                out.push({ key: key, frame: i });
            }
        }
    }

    return out;
};

module.exports = GenerateFrameNumbers;


/***/ }),
/* 348 */
/***/ (function(module, exports) {

var GetAnimation = function (key)
{
    return this.anims.get(key);
};

module.exports = GetAnimation;


/***/ }),
/* 349 */
/***/ (function(module, exports) {

//  Load an Animation into a Game Objects Animation Component
var LoadAnimationToGameObject = function (child, key, startFrame)
{
    var anim = this.get(key);

    if (anim)
    {
        anim.load(child, startFrame);
    }

    return child;
};

module.exports = LoadAnimationToGameObject;


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(49);

var PauseAll = function ()
{
    if (!this.paused)
    {
        this.paused = true;

        this.events.dispatch(new Event.PAUSE_ALL_ANIMATION_EVENT());
    }

    return this;
};

module.exports = PauseAll;


/***/ }),
/* 351 */
/***/ (function(module, exports) {

var PlayAnimation = function (key, child)
{
    if (!Array.isArray(child))
    {
        child = [ child ];
    }

    var anim = this.get(key);

    if (!anim)
    {
        return;
    }

    for (var i = 0; i < child.length; i++)
    {
        child[i].anims.play(key);
    }

    return this;
};

module.exports = PlayAnimation;


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(49);

var RemoveAnimation = function (key)
{
    var anim = this.get(key);

    if (anim)
    {
        this.events.dispatch(new Event.REMOVE_ANIMATION_EVENT(key, anim));

        this.anims.delete(key);
    }

    return anim;
};

module.exports = RemoveAnimation;


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(49);

var ResumeAll = function ()
{
    if (this.paused)
    {
        this.paused = false;

        this.events.dispatch(new Event.RESUME_ALL_ANIMATION_EVENT());
    }

    return this;
};

module.exports = ResumeAll;


/***/ }),
/* 354 */
/***/ (function(module, exports) {

var StaggerPlayAnimation = function (key, child, stagger)
{
    if (stagger === undefined) { stagger = 0; }

    if (!Array.isArray(child))
    {
        child = [ child ];
    }

    var anim = this.get(key);

    if (!anim)
    {
        return;
    }

    for (var i = 0; i < child.length; i++)
    {
        child[i].anims.delayedPlay(stagger * i, key);
    }

    return this;
};

module.exports = StaggerPlayAnimation;


/***/ }),
/* 355 */
/***/ (function(module, exports) {

var ToJSON = function (key)
{
    if (key !== undefined && key !== '')
    {
        return this.anims.get(key).toJSON();
    }
    else
    {
        var output = {
            anims: [],
            globalTimeScale: this.globalTimeScale
        };

        this.anims.each(function (animationKey, animation)
        {
            output.anims.push(animation.toJSON());
        });

        return output;
    }
};

module.exports = ToJSON;


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(9);
var GetValue = __webpack_require__(4);
var MATH = __webpack_require__(13);
var NOOP = __webpack_require__(3);
var ValueToColor = __webpack_require__(63);

var Config = new Class({

    initialize:

    function Config (config)
    {
        if (config === undefined) { config = {}; }

        var defaultBannerColor = [
            '#ff0000',
            '#ffff00',
            '#00ff00',
            '#00ffff',
            '#000000'
        ];

        var defaultBannerTextColor = '#ffffff';

        this.width = GetValue(config, 'width', 1024);
        this.height = GetValue(config, 'height', 768);
        this.zoom = GetValue(config, 'zoom', 1);

        this.resolution = GetValue(config, 'resolution', 1);

        this.renderType = GetValue(config, 'type', CONST.AUTO);

        this.parent = GetValue(config, 'parent', null);
        this.canvas = GetValue(config, 'canvas', null);
        this.canvasStyle = GetValue(config, 'canvasStyle', null);

        this.sceneConfig = GetValue(config, 'scene', null);

        this.seed = GetValue(config, 'seed', [ (Date.now() * Math.random()).toString() ]);

        MATH.RND.init(this.seed);

        this.gameTitle = GetValue(config, 'title', '');
        this.gameURL = GetValue(config, 'url', 'http://phaser.io');
        this.gameVersion = GetValue(config, 'version', '');

        //  Input
        this.inputKeyboard = GetValue(config, 'input.keyboard', true);
        this.inputKeyboardEventTarget = GetValue(config, 'input.keyboard.target', window);

        this.inputMouse = GetValue(config, 'input.mouse', true);
        this.inputMouseEventTarget = GetValue(config, 'input.mouse.target', null);

        this.inputTouch = GetValue(config, 'input.touch', true);
        this.inputTouchEventTarget = GetValue(config, 'input.touch.target', null);

        this.inputGamepad = GetValue(config, 'input.gamepad', false);

        this.disableContextMenu = GetValue(config, 'disableContextMenu', false);

        //  If you do: { banner: false } it won't display any banner at all
        this.hideBanner = (GetValue(config, 'banner', null) === false);

        this.hidePhaser = GetValue(config, 'banner.hidePhaser', false);
        this.bannerTextColor = GetValue(config, 'banner.text', defaultBannerTextColor);
        this.bannerBackgroundColor = GetValue(config, 'banner.background', defaultBannerColor);
       
        //  Frame Rate config
        //      fps: {
        //          min: 10,
        //          target: 60,
        //          forceSetTimeOut: false,
        //          deltaHistory: 10
        //     }

        this.fps = GetValue(config, 'fps', null);

        this.pixelArt = GetValue(config, 'pixelArt', false);
        this.transparent = GetValue(config, 'transparent', false);
        this.clearBeforeRender = GetValue(config, 'clearBeforeRender', true);
        this.backgroundColor = ValueToColor(GetValue(config, 'backgroundColor', 0));
        this.preserveDrawingBuffer = ValueToColor(GetValue(config, 'preserveDrawingBuffer', false));

        //  Callbacks
        this.preBoot = GetValue(config, 'callbacks.preBoot', NOOP);
        this.postBoot = GetValue(config, 'callbacks.postBoot', NOOP);

        this.useTicker = GetValue(config, 'useTicker', false);

        //  Physics
        //  physics: {
        //      system: 'impact',
        //      setBounds: true,
        //      gravity: 0,
        //      cellSize: 64
        //  }
        this.physics = GetValue(config, 'physics', {});
        this.defaultPhysicsSystem = GetValue(this.physics, 'default', false);

        //  Default / Missing Images
        var pngPrefix = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg';

        this.defaultImage = GetValue(config, 'images.default', pngPrefix + 'AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==');
        this.missingImage = GetValue(config, 'images.missing', pngPrefix + 'CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==');
    }

});

module.exports = Config;


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(9);
var CanvasPool = __webpack_require__(15);
var Features = __webpack_require__(129);
var CanvasInterpolation = __webpack_require__(75);

var CreateRenderer = function (game)
{
    var config = game.config;

    //  Game either requested Canvas,
    //  or requested AUTO or WEBGL but the browser doesn't support it, so fall back to Canvas
    if (config.renderType === CONST.CANVAS || (config.renderType !== CONST.CANVAS && !Features.webGL))
    {
        if (Features.canvas)
        {
            //  They requested Canvas and their browser supports it
            config.renderType = CONST.CANVAS;
        }
        else
        {
            throw new Error('Cannot create Canvas or WebGL context, aborting.');
        }
    }
    else
    {
        //  Game requested WebGL and browser says it supports it
        config.renderType = CONST.WEBGL;
    }

    //  Pixel Art mode?
    if (config.pixelArt)
    {
        CanvasPool.disableSmoothing();
    }

    //  Does the game config provide its own canvas element to use?
    if (config.canvas)
    {
        game.canvas = config.canvas;
    }
    else
    {
        game.canvas = CanvasPool.create(game, config.width, config.height, config.renderType);
    }

    //  Does the game config provide some canvas css styles to use?
    if (config.canvasStyle)
    {
        game.canvas.style = config.canvasStyle;
    }

    //  Pixel Art mode?
    if (config.pixelArt)
    {
        CanvasInterpolation.setCrisp(game.canvas);
    }

    //  Zoomed?
    if (config.zoom !== 1)
    {
        game.canvas.style.width = (config.width * config.zoom).toString() + 'px';
        game.canvas.style.height = (config.height * config.zoom).toString() + 'px';
    }

    var CanvasRenderer;
    var WebGLRenderer;

    if (true)
    {
        CanvasRenderer = __webpack_require__(889);
        WebGLRenderer = __webpack_require__(896);

        //  Let the config pick the renderer type, both are included
        if (config.renderType === CONST.WEBGL)
        {
            game.renderer = new WebGLRenderer(game);
            game.context = null;
        }
        else
        {
            game.renderer = new CanvasRenderer(game);
            game.context = game.renderer.gameContext;
        }
    }

    if (false)
    {
        WebGLRenderer = require('../renderer/webgl/WebGLRenderer');

        //  Force the type to WebGL, regardless what was requested
        config.renderType = CONST.WEBGL;
        game.renderer = new WebGLRenderer(game);
        game.context = null;
    }

    if (false)
    {
        CanvasRenderer = require('../renderer/canvas/CanvasRenderer');

        //  Force the type to Canvas, regardless what was requested
        config.renderType = CONST.CANVAS;
        game.renderer = new CanvasRenderer(game);
        game.context = game.renderer.gameContext;
    }
};

module.exports = CreateRenderer;


/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(9);
var CHECKSUM = __webpack_require__(407);

var DebugHeader = function (game)
{
    var config = game.config;

    if (config.hideBanner)
    {
        return;
    }

    var renderType = (config.renderType === CONST.CANVAS) ? 'Canvas' : 'WebGL';

    var ie = false;

    if (!ie)
    {
        var c = '';
        var args = [ c ];

        if (Array.isArray(config.bannerBackgroundColor))
        {
            var lastColor;

            config.bannerBackgroundColor.forEach(function (color)
            {
                c = c.concat('%c ');

                args.push('background: ' + color);

                lastColor = color;

            });

            //  inject the text color
            args[args.length - 1] = 'color: ' + config.bannerTextColor + '; background: ' + lastColor;
        }
        else
        {
            c = c.concat('%c ');

            args.push('color: ' + config.bannerTextColor + '; background: ' + config.bannerBackgroundColor);
        }

        //  URL link background color (always white)
        args.push('background: #fff');

        if (config.gameTitle)
        {
            c = c.concat(config.gameTitle);

            if (config.gameVersion)
            {
                c = c.concat(' v' + config.gameVersion);
            }

            if (!config.hidePhaser)
            {
                c = c.concat(' / ');
            }
        }

        if (!config.hidePhaser)
        {
            c = c.concat('Phaser v' + CONST.VERSION + ' (' + renderType + ')');
        }

        c = c.concat(' %c ' + config.gameURL);

        //  Inject the new string back into the args array
        args[0] = c;

        console.log.apply(console, args);
    }
    else if (window['console'])
    {
        console.log('Phaser v' + CONST.VERSION + ' / http://phaser.io');
    }

    // Keep this during dev build only
    console.log(CHECKSUM.build);
};

module.exports = DebugHeader;


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GetValue = __webpack_require__(4);
var NOOP = __webpack_require__(3);
var RequestAnimationFrame = __webpack_require__(133);

//  Frame Rate config
//      fps: {
//          min: 10,
//          target: 60,
//          forceSetTimeOut: false,
//          deltaHistory: 10,
//          panicMax: 120
//     }

// http://www.testufo.com/#test=animation-time-graph

var TimeStep = new Class({

    initialize:

    function TimeStep (game, config)
    {
        this.game = game;

        this.raf = new RequestAnimationFrame();

        this.started = false;
        this.running = false;
        
        this.minFps = GetValue(config, 'min', 5);
        this.targetFps = GetValue(config, 'target', 60);

        this._min = 1000 / this.minFps;         //  200ms between frames (i.e. super slow!)
        this._target = 1000 / this.targetFps;   //  16.666ms between frames (i.e. normal)

        //  200 / 1000 = 0.2 (5fps)
        //  8.333 / 1000 = 0.008333 (120fps)
        //  16.666 / 1000 = 0.01666 (60fps)

        /**
        * @property {number} fps - An exponential moving average of the frames per second.
        * @readOnly
        */
        this.actualFps = this.targetFps;

        this.nextFpsUpdate = 0;
        this.framesThisSecond = 0;

        this.callback = NOOP;

        this.forceSetTimeOut = GetValue(config, 'forceSetTimeOut', false);

        this.time = 0;
        this.startTime = 0;
        this.lastTime = 0;
        this.frame = 0;

        this.inFocus = true;

        this._pauseTime = 0;
        this._coolDown = 0;

        this.delta = 0;
        this.deltaIndex = 0;
        this.deltaHistory = [];
        this.deltaSmoothingMax = GetValue(config, 'deltaHistory', 10);
        this.panicMax = GetValue(config, 'panicMax', 120);

        //  The actual elapsed time in ms between one update and the next.
        //  No smoothing, no capping, no averaging. So please be aware of this when using the contents of this property.
        this.rawDelta = 0;
    },

    //  Called when the DOM window.onBlur event triggers
    blur: function ()
    {
        this.inFocus = false;

        // console.log('TimeStep.blur');
    },

    //  Called when the DOM window.onFocus event triggers
    focus: function ()
    {
        this.inFocus = true;

        // console.log('TimeStep.focus');

        this.resetDelta();
    },

    //  Called when the visibility API says the game is 'hidden' (tab switch, etc)
    pause: function ()
    {
        // console.log('TimeStep.pause');

        this._pauseTime = window.performance.now();
    },

    //  Called when the visibility API says the game is 'visible' again (tab switch, etc)
    resume: function ()
    {
        this.resetDelta();

        this.startTime += this.time - this._pauseTime;

        // console.log('TimeStep.resume - paused for', (this.time - this._pauseTime));
    },

    resetDelta: function ()
    {
        var now = window.performance.now();

        this.time = now;
        this.lastTime = now;
        this.nextFpsUpdate = now + 1000;
        this.framesThisSecond = 0;
        this.frame = 0;

        //  Pre-populate smoothing array

        for (var i = 0; i < this.deltaSmoothingMax; i++)
        {
            this.deltaHistory[i] = Math.min(this._target, this.deltaHistory[i]);
        }

        this.delta = 0;
        this.deltaIndex = 0;

        this._coolDown = this.panicMax;
    },

    start: function (callback)
    {
        if (this.started)
        {
            return this;
        }

        this.started = true;
        this.running = true;

        for (var i = 0; i < this.deltaSmoothingMax; i++)
        {
            this.deltaHistory[i] = this._target;
        }

        this.resetDelta();

        this.startTime = window.performance.now();

        this.callback = callback;

        this.raf.start(this.step.bind(this), this.forceSetTimeOut);
    },

    //  time comes from requestAnimationFrame and is either a high res time value,
    //  or Date.now if using setTimeout
    step: function (time)
    {
        //  Debug only
        // var debug = 0;
        // var dump = [];

        this.frame++;

        this.rawDelta = time - this.lastTime;

        var idx = this.deltaIndex;
        var history = this.deltaHistory;
        var max = this.deltaSmoothingMax;

        //  delta time (time is in ms)
        var dt = (time - this.lastTime);

        //  When a browser switches tab, then comes back again, it takes around 10 frames before
        //  the delta time settles down so we employ a 'cooling down' period before we start
        //  trusting the delta values again, to avoid spikes flooding through our delta average

        if (this._coolDown > 0 || !this.inFocus)
        {
            this._coolDown--;

            dt = Math.min(dt, this._target);

            // debug = (time - this.lastTime);
        }

        if (dt > this._min)
        {
            //  Probably super bad start time or browser tab context loss,
            //  so use the last 'sane' dt value

            // debug = dt;

            dt = history[idx];

            //  Clamp delta to min (in case history has become corrupted somehow)
            dt = Math.min(dt, this._min);
        }

        //  Smooth out the delta over the previous X frames

        //  add the delta to the smoothing array
        history[idx] = dt;

        //  adjusts the delta history array index based on the smoothing count
        //  this stops the array growing beyond the size of deltaSmoothingMax
        this.deltaIndex++;

        if (this.deltaIndex > max)
        {
            this.deltaIndex = 0;
        }

        //  Delta Average
        var avg = 0;

        //  Loop the history array, adding the delta values together

        for (var i = 0; i < max; i++)
        {
            //   Debug
            // if (history[i] < 16 || history[i] > 17)
            // {
            //     dump.push({ i: i, dt: history[i] });
            // }

            avg += history[i];
        }

        //  Then divide by the array length to get the average delta
        avg /= max;

        //  Set as the world delta value
        this.delta = avg;

        //  Real-world timer advance
        // this.time += avg;
        this.time += this.rawDelta;

        // Update the estimate of the frame rate, `fps`. Every second, the number
        // of frames that occurred in that second are included in an exponential
        // moving average of all frames per second, with an alpha of 0.25. This
        // means that more recent seconds affect the estimated frame rate more than
        // older seconds.
        //
        // When a browser window is NOT minimized, but is covered up (i.e. you're using
        // another app which has spawned a window over the top of the browser), then it
        // will start to throttle the raf callback time. It waits for a while, and then
        // starts to drop the frame rate at 1 frame per second until it's down to just over 1fps.
        // So if the game was running at 60fps, and the player opens a new window, then
        // after 60 seconds (+ the 'buffer time') it'll be down to 1fps, so rafin'g at 1Hz.
        //
        // When they make the game visible again, the frame rate is increased at a rate of
        // approx. 8fps, back up to 60fps (or the max it can obtain)
        //
        // There is no easy way to determine if this drop in frame rate is because the
        // browser is throttling raf, or because the game is struggling with performance
        // because you're asking it to do too much on the device.

        if (time > this.nextFpsUpdate)
        {
            //  Compute the new exponential moving average with an alpha of 0.25.
            this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps;
            this.nextFpsUpdate = time + 1000;
            this.framesThisSecond = 0;

            // if (this.actualFps < 56)
            // {
            //     console.log(this.actualFps);
            //     console.log('F', this.frame, 'Avg', avg, 'Dt', debug, 'Panic', this._coolDown);
            // }
        }

        this.framesThisSecond++;

        //  Interpolation - how far between what is expected and where we are?
        var interpolation = avg / this._target;

        this.callback(time, avg, interpolation);

        //  Shift time value over
        this.lastTime = time;

        // if (debug !== 0)
        // {
        //     console.log('F', this.frame, 'Avg', avg, 'Dt', debug, 'Panic', this._coolDown);
        // }

        /*
        if (debug !== 0 || dump.length)
        {
            console.group('Frame ' + this.frame);
            console.log('Interpolation', interpolation, '%');

            if (debug)
            {
                console.log('Elapsed', debug, 'ms');
            }

            // console.log('Frame', this.frame, 'Delta', avg, '(average)', debug, '(now)');

            console.log('Delta', avg, '(average)');

            if (dump.length)
            {
                console.table(dump);
            }

            console.groupEnd();
        }
        */
    },

    tick: function ()
    {
        this.step(window.performance.now());
    },

    sleep: function ()
    {
        if (this.running)
        {
            this.raf.stop();
            
            this.running = false;
        }
    },

    wake: function (seamless)
    {
        if (this.running)
        {
            this.sleep();
        }
        else if (seamless)
        {
            this.startTime += -this.lastTime + (this.lastTime = window.performance.now());
        }

        this.raf.start(this.step.bind(this), this.useRAF);

        this.running = true;

        this.step(window.performance.now());
    },

    setFps: function (value)
    {
        this.fps = value;

        this.wake();
    },

    getFps: function ()
    {
        return this.fps;
    },

    stop: function ()
    {
        this.running = false;
        this.started = false;

        this.raf.stop();

        return this;
    },

    destroy: function ()
    {

    }

});

module.exports = TimeStep;


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(2);

var VisibilityHandler = function (eventDispatcher)
{
    var hiddenVar;

    if (document.hidden !== undefined)
    {
        hiddenVar = 'visibilitychange';
    }
    else
    {
        var vendors = [ 'webkit', 'moz', 'ms' ];

        vendors.forEach(function (prefix)
        {
            if (document[prefix + 'Hidden'] !== undefined)
            {
                document.hidden = function ()
                {
                    return document[prefix + 'Hidden'];
                };

                hiddenVar = prefix + 'visibilitychange';
            }

        });
    }

    var onChange = function (event)
    {
        if (document.hidden || event.type === 'pause')
        {
            eventDispatcher.dispatch(new Event('HIDDEN'));
        }
        else
        {
            eventDispatcher.dispatch(new Event('VISIBLE'));
        }
    };

    //  Does browser support it?
    //  If not (like in IE9 or old Android) we need to fall back to blur / focus
    if (hiddenVar)
    {
        document.addEventListener(hiddenVar, onChange, false);
    }
    else
    {
        console.log('Fallback TODO');
    }

    window.onblur = function ()
    {
        eventDispatcher.dispatch(new Event('ON_BLUR'));
    };

    window.onfocus = function ()
    {
        eventDispatcher.dispatch(new Event('ON_FOCUS'));
    };

};

module.exports = VisibilityHandler;


/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var EventDispatcher = __webpack_require__(30);
var Events = __webpack_require__(365);

//  Phaser.Cache.BaseCache

var BaseCache = new Class({

    initialize:

    function BaseCache ()
    {
        this.entries = new Map();

        this.events = new EventDispatcher();
    },

    add: function (key, data)
    {
        this.entries.set(key, data);

        this.events.dispatch(new Events.CACHE_ADD_EVENT(this, key, data));
    },

    has: function (key)
    {
        return this.entries.has(key);
    },

    get: function (key)
    {
        return this.entries.get(key);
    },

    remove: function (key)
    {
        var entry = this.get(key);

        if (entry)
        {
            this.entries.delete(key);

            this.events.dispatch(new Events.CACHE_REMOVE_EVENT(this, key, entry.data));
        }
    },

    destroy: function ()
    {
        this.entries.clear();
    }

});

module.exports = BaseCache;


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

var BaseCache = __webpack_require__(361);
var Class = __webpack_require__(0);

//  Phaser.Cache.GlobalCache

var GlobalCache = new Class({

    initialize:

    function GlobalCache (game)
    {
        this.game = game;

        this.binary = new BaseCache();
        this.bitmapFont = new BaseCache();
        this.json = new BaseCache();
        this.physics = new BaseCache();
        this.shader = new BaseCache();
        this.sound = new BaseCache();
        this.text = new BaseCache();
        this.tilemap = new BaseCache();
        this.video = new BaseCache();
        this.xml = new BaseCache();

        this.custom = {};
    },

    //  Add your own custom Cache entry, available under Cache.custom.key
    addCustom: function (key)
    {
        if (!this.custom.hasOwnProperty(key))
        {
            this.custom[key] = new BaseCache();

            return this.custom[key];
        }
    }

});

module.exports = GlobalCache;


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var CacheAddEvent = new Class({

    Extends: Event,

    initialize:

    function CacheAddEvent (cache, key, data)
    {
        Event.call(this, 'CACHE_ADD_EVENT');

        this.cache = cache;
        this.key = key;
        this.data = data;
    }

});

module.exports = CacheAddEvent;


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var CacheRemoveEvent = new Class({

    Extends: Event,

    initialize:

    function CacheRemoveEvent (cache, key, data)
    {
        Event.call(this, 'CACHE_REMOVE_EVENT');

        this.cache = cache;
        this.key = key;
        this.data = data;
    }

});

module.exports = CacheRemoveEvent;


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    CACHE_ADD_EVENT: __webpack_require__(363),
    CACHE_REMOVE_EVENT: __webpack_require__(364)

};


/***/ }),
/* 366 */
/***/ (function(module, exports) {

var CameraToScreen = function (pointIn, pointOut)
{
    var cameraMatrix = this.matrix.matrix;
    var mva = cameraMatrix[0];
    var mvb = cameraMatrix[1];
    var mvc = cameraMatrix[2];
    var mvd = cameraMatrix[3];
    var mve = cameraMatrix[4];
    var mvf = cameraMatrix[5];
    
    /* First Invert Matrix */
    var determinant = (mva * mvd) - (mvb * mvc);

    if (!determinant)
    {
        return pointIn;
    }

    determinant = 1 / determinant;

    var ima = mvd * determinant;
    var imb = -mvb * determinant;
    var imc = -mvc * determinant;
    var imd = mva * determinant;
    var ime = (mvc * mvf - mvd * mve) * determinant;
    var imf = (mvb * mve - mva * mvf) * determinant;

    var x = pointIn.x;
    var y = pointIn.y;

    if (!pointOut)
    {
        pointOut = { x: 0, y: 0 };
    }

    /* Apply transform to point */
    pointOut.x = (x * ima + y * imc + ime);
    pointOut.y = (x * imb + y * imd + imf);
    
    return pointOut;
};

module.exports = CameraToScreen;


/***/ }),
/* 367 */
/***/ (function(module, exports) {

var CenterToBounds = function ()
{
    this.scrollX = (this._bounds.width * 0.5) - (this.width * 0.5);
    this.scrollY = (this._bounds.height * 0.5) - (this.height * 0.5);
    
    return this;
};

module.exports = CenterToBounds;


/***/ }),
/* 368 */
/***/ (function(module, exports) {

var CenterToSize = function ()
{
    this.scrollX = this.width * 0.5;
    this.scrollY = this.height * 0.5;
    
    return this;
};

module.exports = CenterToSize;


/***/ }),
/* 369 */
/***/ (function(module, exports) {

var Cull = function (renderableObjects)
{
    if (this.disableCull)
    {
        return renderableObjects;
    }

    var cameraMatrix = this.matrix.matrix;

    var mva = cameraMatrix[0];
    var mvb = cameraMatrix[1];
    var mvc = cameraMatrix[2];
    var mvd = cameraMatrix[3];
    
    /* First Invert Matrix */
    var determinant = (mva * mvd) - (mvb * mvc);

    if (!determinant)
    {
        return renderableObjects;
    }

    var mve = cameraMatrix[4];
    var mvf = cameraMatrix[5];

    var scrollX = this.scrollX;
    var scrollY = this.scrollY;
    var cameraW = this.width;
    var cameraH = this.height;
    var culledObjects = this.culledObjects;
    var length = renderableObjects.length;

    determinant = 1 / determinant;

    culledObjects.length = 0;

    for (var index = 0; index < length; ++index)
    {
        var object = renderableObjects[index];

        if (!object.hasOwnProperty('width'))
        {
            culledObjects.push(object);
            continue;
        }

        var objectW = object.width;
        var objectH = object.height;
        var objectX = (object.x - (scrollX * object.scrollFactorX)) - (objectW * object.originX);
        var objectY = (object.y - (scrollY * object.scrollFactorY)) - (objectH * object.originY);
        var tx = (objectX * mva + objectY * mvc + mve);
        var ty = (objectX * mvb + objectY * mvd + mvf);
        var tw = ((objectX + objectW) * mva + (objectY + objectH) * mvc + mve);
        var th = ((objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf);
        var cullW = cameraW + objectW;
        var cullH = cameraH + objectH;

        if (tx > -objectW || ty > -objectH || tx < cullW || ty < cullH ||
            tw > -objectW || th > -objectH || tw < cullW || th < cullH)
        {
            culledObjects.push(object);
        }
    }

    return culledObjects;
};

module.exports = Cull;


/***/ }),
/* 370 */
/***/ (function(module, exports) {

var CullHitTest = function (interactiveObjects)
{
    if (this.disableCull)
    {
        return interactiveObjects;
    }

    var cameraMatrix = this.matrix.matrix;

    var mva = cameraMatrix[0];
    var mvb = cameraMatrix[1];
    var mvc = cameraMatrix[2];
    var mvd = cameraMatrix[3];
    
    /* First Invert Matrix */
    var determinant = (mva * mvd) - (mvb * mvc);

    if (!determinant)
    {
        return interactiveObjects;
    }

    var mve = cameraMatrix[4];
    var mvf = cameraMatrix[5];

    var scrollX = this.scrollX;
    var scrollY = this.scrollY;
    var cameraW = this.width;
    var cameraH = this.height;
    var length = interactiveObjects.length;

    determinant = 1 / determinant;

    var culledObjects = [];

    for (var index = 0; index < length; ++index)
    {
        var object = interactiveObjects[index].gameObject;

        if (!object.hasOwnProperty('width'))
        {
            culledObjects.push(interactiveObjects[index]);
            continue;
        }

        var objectW = object.width;
        var objectH = object.height;
        var objectX = (object.x - (scrollX * object.scrollFactorX)) - (objectW * object.originX);
        var objectY = (object.y - (scrollY * object.scrollFactorY)) - (objectH * object.originY);
        var tx = (objectX * mva + objectY * mvc + mve);
        var ty = (objectX * mvb + objectY * mvd + mvf);
        var tw = ((objectX + objectW) * mva + (objectY + objectH) * mvc + mve);
        var th = ((objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf);
        var cullW = cameraW + objectW;
        var cullH = cameraH + objectH;

        if (tx > -objectW || ty > -objectH || tx < cullW || ty < cullH ||
            tw > -objectW || th > -objectH || tw < cullW || th < cullH)
        {
            culledObjects.push(interactiveObjects[index]);
        }
    }

    return culledObjects;
};

module.exports = CullHitTest;


/***/ }),
/* 371 */
/***/ (function(module, exports) {

var CullTilemap = function (tilemap)
{
    var cameraMatrix = this.matrix.matrix;

    var mva = cameraMatrix[0];
    var mvb = cameraMatrix[1];
    var mvc = cameraMatrix[2];
    var mvd = cameraMatrix[3];
    
    /* First Invert Matrix */
    var determinant = (mva * mvd) - (mvb * mvc);

    if (!determinant)
    {
        return tiles;
    }

    var mve = cameraMatrix[4];
    var mvf = cameraMatrix[5];
    var tiles = tilemap.tiles;
    var scrollX = this.scrollX;
    var scrollY = this.scrollY;
    var cameraW = this.width;
    var cameraH = this.height;
    var culledObjects = this.culledObjects;
    var length = tiles.length;
    var tileW = tilemap.tileWidth;
    var tileH = tilemap.tileHeight;
    var cullW = cameraW + tileW;
    var cullH = cameraH + tileH;
    var scrollFactorX = tilemap.scrollFactorX;
    var scrollFactorY = tilemap.scrollFactorY;

    determinant = 1 / determinant;

    culledObjects.length = 0;

    for (var index = 0; index < length; ++index)
    {
        var tile = tiles[index];
        var tileX = (tile.x - (scrollX * scrollFactorX));
        var tileY = (tile.y - (scrollY * scrollFactorY));
        var tx = (tileX * mva + tileY * mvc + mve);
        var ty = (tileX * mvb + tileY * mvd + mvf);
        var tw = ((tileX + tileW) * mva + (tileY + tileH) * mvc + mve);
        var th = ((tileX + tileW) * mvb + (tileY + tileH) * mvd + mvf);

        if (tx > -tileW && ty > -tileH && tw < cullW && th < cullH)
        {
            culledObjects.push(tile);
        }
    }

    return culledObjects;
};

module.exports = CullTilemap;


/***/ }),
/* 372 */
/***/ (function(module, exports) {

var Destroy = function ()
{
    this._bounds = undefined;
    this.matrix = undefined;
    this.culledObjects = [];
    this.scene = undefined;
};

module.exports = Destroy;


/***/ }),
/* 373 */
/***/ (function(module, exports) {

var Fade = function (duration, red, green, blue, force)
{
    if (red === undefined) { red = 0.0; }
    if (green === undefined) { green = 0.0; }
    if (blue === undefined) { blue = 0.0; }

    if (!force && this._fadeAlpha > 0.0)
    {
        return;
    }

    this._fadeRed = red;
    this._fadeGreen = green;
    this._fadeBlue = blue;

    if (duration <= 0)
    {
        duration = Number.MIN_VALUE;
    }

    this._fadeDuration = duration;
    this._fadeAlpha = Number.MIN_VALUE;
};

module.exports = Fade;


/***/ }),
/* 374 */
/***/ (function(module, exports) {

var Flash = function (duration, red, green, blue, force)
{
    if (!force && this._flashAlpha > 0.0)
    {
        return;
    }

    if (red === undefined) { red = 1.0; }
    if (green === undefined) { green = 1.0; }
    if (blue === undefined) { blue = 1.0; }

    this._flashRed = red;
    this._flashGreen = green;
    this._flashBlue = blue;

    if (duration <= 0)
    {
        duration = Number.MIN_VALUE;
    }

    this._flashDuration = duration;
    this._flashAlpha = 1.0;
};

module.exports = Flash;


/***/ }),
/* 375 */
/***/ (function(module, exports) {

var Ignore = function (gameObjectOrArray)
{
    if (gameObjectOrArray instanceof Array)
    {
        for (var index = 0; index < gameObjectOrArray.length; ++index)
        {
            gameObjectOrArray[index].cameraFilter |= this._id;
        }
    }
    else
    {
        gameObjectOrArray.cameraFilter |= this._id;
    }
};

module.exports = Ignore;


/***/ }),
/* 376 */
/***/ (function(module, exports) {

var PreRender = function ()
{
    var width = this.width;
    var height = this.height;
    var zoom = this.zoom;
    var matrix = this.matrix;
    var originX = width / 2;
    var originY = height / 2;
    var follow = this._follow;

    if (follow !== null)
    {
        originX = follow.x;
        originY = follow.y;
        
        this.scrollX = originX - width * 0.5;
        this.scrollY = originY - height * 0.5;
    }

    if (this.useBounds)
    {
        var bounds = this._bounds;
        var boundsX = bounds.x;
        var boundsY = bounds.y;
        var boundsR = Math.max(bounds.right - width, width);
        var boundsB = Math.max(bounds.bottom - height, height);

        if (this.scrollX < boundsX)
        {
            this.scrollX = boundsX;
        }
        if (this.scrollX > boundsR)
        {
            this.scrollX = boundsR;
        }

        if (this.scrollY < boundsY)
        {
            this.scrollY = boundsY;
        }
        if (this.scrollY > boundsB)
        {
            this.scrollY = boundsB;
        }
    }

    if (this.roundPixels)
    {
        this.scrollX = Math.round(this.scrollX);
        this.scrollY = Math.round(this.scrollY);
    }

    matrix.loadIdentity();
    matrix.translate(this.x + originX, this.y + originY);
    matrix.rotate(this.rotation);
    matrix.scale(zoom, zoom);
    matrix.translate(-originX, -originY);
    matrix.translate(this._shakeOffsetX, this._shakeOffsetY);
};

module.exports = PreRender;


/***/ }),
/* 377 */
/***/ (function(module, exports) {

var RemoveBounds = function ()
{
    this.useBounds = false;

    this._bounds.setEmpty();

    return this;
};

module.exports = RemoveBounds;


/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

var ValueToColor = __webpack_require__(63);

var SetBackgroundColor = function (color)
{
    if (color === undefined) { color = 'rgba(0,0,0,0)'; }

    this.backgroundColor = ValueToColor(color);

    this.transparent = (this.backgroundColor.alpha === 0);

    return this;
};

module.exports = SetBackgroundColor;


/***/ }),
/* 379 */
/***/ (function(module, exports) {

var SetBounds = function (x, y, width, height)
{
    this._bounds.setTo(x, y, width, height);

    this.useBounds = true;

    return this;
};

module.exports = SetBounds;


/***/ }),
/* 380 */
/***/ (function(module, exports) {

var SetName = function (value)
{
    if (value === undefined) { value = ''; }

    this.name = value;

    return this;
};

module.exports = SetName;


/***/ }),
/* 381 */
/***/ (function(module, exports) {

var SetPosition = function (x, y)
{
    if (y === undefined) { y = x; }

    this.x = x;
    this.y = y;

    return this;
};

module.exports = SetPosition;


/***/ }),
/* 382 */
/***/ (function(module, exports) {

var SetRotation = function (value)
{
    if (value === undefined) { value = 0; }

    this.rotation = value;

    return this;
};

module.exports = SetRotation;


/***/ }),
/* 383 */
/***/ (function(module, exports) {

var SetRoundPixels = function (value)
{
    this.roundPixels = value;

    return this;
};

module.exports = SetRoundPixels;


/***/ }),
/* 384 */
/***/ (function(module, exports) {

var SetScene = function (scene)
{
    this.scene = scene;

    return this;
};

module.exports = SetScene;


/***/ }),
/* 385 */
/***/ (function(module, exports) {

var SetScroll = function (x, y)
{
    if (y === undefined) { y = x; }

    this.scrollX = x;
    this.scrollY = y;

    return this;
};

module.exports = SetScroll;


/***/ }),
/* 386 */
/***/ (function(module, exports) {

var SetSize = function (width, height)
{
    if (height === undefined) { height = width; }

    this.width = width;
    this.height = height;

    return this;
};

module.exports = SetSize;


/***/ }),
/* 387 */
/***/ (function(module, exports) {

var SetViewport = function (x, y, width, height)
{
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    return this;
};

module.exports = SetViewport;


/***/ }),
/* 388 */
/***/ (function(module, exports) {

var SetZoom = function (value)
{
    if (value === undefined) { value = 1; }

    this.zoom = value;

    return this;
};

module.exports = SetZoom;


/***/ }),
/* 389 */
/***/ (function(module, exports) {

var Shake = function (duration, intensity, force)
{
    if (intensity === undefined) { intensity = 0.05; }

    if (!force && (this._shakeOffsetX !== 0.0 || this._shakeOffsetY !== 0.0))
    {
        return;
    }

    this._shakeDuration = duration;
    this._shakeIntensity = intensity;
    this._shakeOffsetX = 0;
    this._shakeOffsetY = 0;
};

module.exports = Shake;


/***/ }),
/* 390 */
/***/ (function(module, exports) {

var StartFollow = function (gameObjectOrPoint, roundPx)
{
    if (this._follow !== null)
    {
        this.stopFollow();
    }

    this._follow = gameObjectOrPoint;

    if (roundPx !== undefined)
    {
        this.roundPixels = roundPx;
    }

    return this;
};

module.exports = StartFollow;


/***/ }),
/* 391 */
/***/ (function(module, exports) {

var StopFollow = function ()
{
    /* do unfollow work here */
    this._follow = null;
};

module.exports = StopFollow;


/***/ }),
/* 392 */
/***/ (function(module, exports) {

/*
    camera: {
        x: int
        y: int
        width: int
        height: int
        zoom: float
        rotation: float
        roundPixels: bool
        scrollX: float
        scrollY: float
        backgroundColor: string
        bounds: {
            x: int
            y: int
            width: int
            height: int
        }
    }
*/
var ToJSON = function ()
{
    var output = {
        name: this.name,
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height,
        zoom: this.zoom,
        rotation: this.rotation,
        roundPixels: this.roundPixels,
        scrollX: this.scrollX,
        scrollY: this.scrollY,
        backgroundColor: this.backgroundColor.rgba
    };

    if (this.useBounds)
    {
        output['bounds'] = {
            x: this._bounds.x,
            y: this._bounds.y,
            width: this._bounds.width,
            height: this._bounds.height
        };
    }

    return output;
};

module.exports = ToJSON;


/***/ }),
/* 393 */
/***/ (function(module, exports) {

var Update = function (timestep, delta)
{
    if (this._flashAlpha > 0.0)
    {
        this._flashAlpha -= delta / this._flashDuration;

        if (this._flashAlpha < 0.0)
        {
            this._flashAlpha = 0.0;
        }
    }

    if (this._fadeAlpha > 0.0 && this._fadeAlpha < 1.0)
    {
        this._fadeAlpha += delta / this._fadeDuration;

        if (this._fadeAlpha >= 1.0)
        {
            this._fadeAlpha = 1.0;
        }
    }

    if (this._shakeDuration > 0.0)
    {
        var intensity = this._shakeIntensity;

        this._shakeDuration -= delta;

        if (this._shakeDuration <= 0.0)
        {
            this._shakeOffsetX = 0.0;
            this._shakeOffsetY = 0.0;
        }
        else
        {
            this._shakeOffsetX = (Math.random() * intensity * this.width * 2 - intensity * this.width) * this.zoom;
            this._shakeOffsetY = (Math.random() * intensity * this.height * 2 - intensity * this.height) * this.zoom;
        }
    }
};

module.exports = Update;


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var CameraManager = new Class({

    initialize:

    function CameraManager (scene)
    {
        //  The Scene that owns this plugin
        this.currentCameraId = 1;
        this.scene = scene;

        this.cameras = [];
        this.cameraPool = [];

        if (scene.sys.settings.cameras)
        {
            //  We have cameras to create
            this.fromJSON(scene.sys.settings.cameras);
        }
        else
        {
            //  Make one
            this.add();
        }

        //  Set the default camera
        this.main = this.cameras[0];
    },

    add: __webpack_require__(395),
    add3D: __webpack_require__(124),
    addPerspectiveCamera: __webpack_require__(124),
    addOrthographicCamera: __webpack_require__(398),
    addExisting: __webpack_require__(396),
    addKeyControl: __webpack_require__(397),
    addSmoothedKeyControl: __webpack_require__(399),
    destroy: __webpack_require__(400),
    fromJSON: __webpack_require__(401),
    getCameraBelowPointer: __webpack_require__(402),
    remove: __webpack_require__(403),
    render: __webpack_require__(404),
    resetAll: __webpack_require__(405),
    update: __webpack_require__(406)

});

module.exports = CameraManager;


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

var Camera = __webpack_require__(74);

var Add2DCamera = function (x, y, width, height, makeMain)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = this.scene.sys.game.config.width; }
    if (height === undefined) { height = this.scene.sys.game.config.height; }
    if (makeMain === undefined) { makeMain = false; }

    var camera = null;

    if (this.cameraPool.length > 0)
    {
        camera = this.cameraPool.pop();

        camera.setViewport(x, y, width, height);
    }
    else
    {
        camera = new Camera(x, y, width, height);
    }

    camera.setScene(this.scene);

    this.cameras.push(camera);

    if (makeMain)
    {
        this.main = camera;
    }

    camera._id = this.currentCameraId;

    this.currentCameraId = this.currentCameraId << 1;

    return camera;
};

module.exports = Add2DCamera;


/***/ }),
/* 396 */
/***/ (function(module, exports) {

var AddExisting = function (camera)
{
    var index = this.cameras.indexOf(camera);
    var poolIndex = this.cameraPool.indexOf(camera);

    if (index < 0 && poolIndex >= 0)
    {
        this.cameras.push(camera);
        this.cameraPool.slice(poolIndex, 1);
        return camera;
    }
    
    return null;
};

module.exports = AddExisting;


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

var KeyControl = __webpack_require__(122);

var AddKeyControl = function (config)
{
    return new KeyControl(config);
};

module.exports = AddKeyControl;


/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

var OrthographicCamera = __webpack_require__(120);

var AddOrthographicCamera = function (width, height)
{
    var config = this.scene.sys.game.config;

    if (width === undefined) { width = config.width; }
    if (height === undefined) { height = config.height; }

    var camra = new OrthographicCamera(this.scene, width, height);

    return camera;
};

module.exports = AddOrthographicCamera;


/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

var SmoothedKeyControl = __webpack_require__(123);

var AddSmoothedKeyControl = function (config)
{
    return new SmoothedKeyControl(config);
};

module.exports = AddSmoothedKeyControl;


/***/ }),
/* 400 */
/***/ (function(module, exports) {

var Destroy = function ()
{
    this.main = undefined;

    for (var i = 0; i < this.cameras.length; i++)
    {
        this.cameras[i].destroy();
    }

    for (i = 0; i < this.cameraPool.length; i++)
    {
        this.cameraPool[i].destroy();
    }

    this.cameras = [];
    this.cameraPool = [];
    this.scene = undefined;
};

module.exports = Destroy;


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

var GetFastValue = __webpack_require__(11);

/*
{
    cameras: [
        {
            name: string
            x: int
            y: int
            width: int
            height: int
            zoom: float
            rotation: float
            roundPixels: bool
            scrollX: float
            scrollY: float
            backgroundColor: string
            bounds: {
                x: int
                y: int
                width: int
                height: int
            }
        }
    ]
}
*/

var FromJSON = function (config)
{
    if (!Array.isArray(config))
    {
        config = [ config ];
    }

    var gameWidth = this.scene.sys.game.config.width;
    var gameHeight = this.scene.sys.game.config.height;

    for (var i = 0; i < config.length; i++)
    {
        var cameraConfig = config[i];

        var x = GetFastValue(cameraConfig, 'x', 0);
        var y = GetFastValue(cameraConfig, 'y', 0);
        var width = GetFastValue(cameraConfig, 'width', gameWidth);
        var height = GetFastValue(cameraConfig, 'height', gameHeight);

        var camera = this.add(x, y, width, height);

        //  Direct properties
        camera.name = GetFastValue(cameraConfig, 'name', '');
        camera.zoom = GetFastValue(cameraConfig, 'zoom', 1);
        camera.rotation = GetFastValue(cameraConfig, 'rotation', 0);
        camera.scrollX = GetFastValue(cameraConfig, 'scrollX', 0);
        camera.scrollY = GetFastValue(cameraConfig, 'scrollY', 0);
        camera.roundPixels = GetFastValue(cameraConfig, 'roundPixels', false);

        // Background Color

        var backgroundColor = GetFastValue(cameraConfig, 'backgroundColor', false);

        if (backgroundColor)
        {
            camera.setBackgroundColor(backgroundColor);
        }

        //  Bounds

        var boundsConfig = GetFastValue(cameraConfig, 'bounds', null);

        if (boundsConfig)
        {
            var bx = GetFastValue(boundsConfig, 'x', 0);
            var by = GetFastValue(boundsConfig, 'y', 0);
            var bwidth = GetFastValue(boundsConfig, 'width', gameWidth);
            var bheight = GetFastValue(boundsConfig, 'height', gameHeight);

            camera.setBounds(bx, by, bwidth, bheight);
        }
    }

    return this;
};

module.exports = FromJSON;


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

var RectangleContains = __webpack_require__(32);

var GetCameraBelowPointer = function (pointer)
{
    var cameras = this.cameras;

    //  Start from the most recently added camera (the 'top' camera)
    for (var i = cameras.length - 1; i >= 0; i--)
    {
        var camera = cameras[i];

        if (camera.inputEnabled && RectangleContains(camera, pointer.x, pointer.y))
        {
            return camera;
        }
    }
};

module.exports = GetCameraBelowPointer;


/***/ }),
/* 403 */
/***/ (function(module, exports) {

var RemoveCamera = function (camera)
{
    var cameraIndex = this.cameras.indexOf(camera);

    if (cameraIndex >= 0 && this.cameras.length > 1)
    {
        this.cameraPool.push(this.cameras[cameraIndex]);
        this.cameras.splice(cameraIndex, 1);

        if (this.main === camera)
        {
            this.main = this.cameras[0];
        }
    }
};

module.exports = RemoveCamera;


/***/ }),
/* 404 */
/***/ (function(module, exports) {

var Render = function (renderer, children, interpolation)
{
    var cameras = this.cameras;

    for (var i = 0, l = cameras.length; i < l; ++i)
    {
        var camera = cameras[i];

        camera.preRender();

        renderer.render(this.scene, children, interpolation, camera);
    }
};

module.exports = Render;


/***/ }),
/* 405 */
/***/ (function(module, exports) {

var ResetAll = function ()
{
    while (this.cameras.length > 0)
    {
        this.cameraPool.push(this.cameras.pop());
    }

    this.main = this.add();

    return this.main;
};

module.exports = ResetAll;


/***/ }),
/* 406 */
/***/ (function(module, exports) {

var Update = function (timestep, delta)
{
    for (var i = 0, l = this.cameras.length; i < l; ++i)
    {
        this.cameras[i].update(timestep, delta);
    }
};

module.exports = Update;


/***/ }),
/* 407 */
/***/ (function(module, exports) {

var CHECKSUM = {
    build: '12f52850-9fab-11e7-8936-491a9f7cd9ff'
};
module.exports = CHECKSUM;

/***/ }),
/* 408 */
/***/ (function(module, exports) {

/*
import Canvas from 'canvas/Canvas.js';
import GetContext from 'canvas/GetContext.js';

export default function Grid  (
        {
            canvas = undefined,
            width = 256,
            height = width,
            cellWidth = 32,
            cellHeight = cellWidth,
            color1 = '#fff',
            color2 = '#000',
            drawLines = false,
            lineColor = '#ff0000',
            alternate = true,
            resizeCanvas = true,
            clear = true,
            preRender = undefined,
            postRender = undefined
        } = {}
    ) {

    if (!canvas)
    {
        canvas = Canvas(width, height);
        resizeCanvas = false;
        clear = false;
    }
    else
    {
        //  They provided own canvas, so we use its dimensions
        if (!resizeCanvas)
        {
            width = canvas.width;
            height = canvas.height;
        }
    }

    let ctx = GetContext(canvas);

    if (resizeCanvas)
    {
        Resize(canvas, width, height);
    }

    if (clear)
    {
        ctx.clearRect(0, 0, width, height);
    }

    if (drawLines)
    {
        ctx.lineWidth = 1;
        ctx.strokeStyle = lineColor;
    }

    //  preRender Callback?
    if (preRender)
    {
        preRender(canvas, ctx);
    }

    //  Draw the grid cells first (the lines go on top)

    let cx = Math.ceil(width / cellWidth);
    let cy = Math.ceil(height / cellHeight);
    let c = 0;
    let color = color1;

    for (let y = 0; y < cy; y++)
    {
        for (let x = 0; x < cx; x++)
        {
            if (c === 0)
            {
                color = color1;
                c = 1;
            }
            else
            {
                color = color2;
                c = 0;
            }

            if (color)
            {
                ctx.fillStyle = color;
                ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
            }

            if (drawLines)
            {
                //  +- 0.5 because we're using stroke, and will get anti-aliased line strokes without
                let ox = 0.5;
                let oy = 0.5;

                if (x === cx - 1)
                {
                    ox = -0.5;
                }

                if (y === cy - 1)
                {
                    oy = -0.5;
                }

                ctx.strokeRect((x * cellWidth) + ox, (y * cellHeight) + oy, cellWidth, cellHeight);
            }
        }

        if (alternate)
        {
            if (c === 0)
            {
                c = 1;
            }
            else
            {
                c = 0;
            }
        }

    }

    //  postRender Callback?
    if (postRender)
    {
        postRender(canvas, ctx);
    }

    return canvas;

}
*/


/***/ }),
/* 409 */
/***/ (function(module, exports) {

// A 16 color C64 inspired palette.

module.exports = {
    0: '#000',
    1: '#fff',
    2: '#8b4131',
    3: '#7bbdc5',
    4: '#8b41ac',
    5: '#6aac41',
    6: '#3931a4',
    7: '#d5de73',
    8: '#945a20',
    9: '#5a4100',
    A: '#bd736a',
    B: '#525252',
    C: '#838383',
    D: '#acee8b',
    E: '#7b73de',
    F: '#acacac'
};


/***/ }),
/* 410 */
/***/ (function(module, exports) {

// A 16 color CGA inspired palette by [Arne](http://androidarts.com/palette/16pal.htm)

module.exports = {
    0: '#000',
    1: '#2234d1',
    2: '#0c7e45',
    3: '#44aacc',
    4: '#8a3622',
    5: '#5c2e78',
    6: '#aa5c3d',
    7: '#b5b5b5',
    8: '#5e606e',
    9: '#4c81fb',
    A: '#6cd947',
    B: '#7be2f9',
    C: '#eb8a60',
    D: '#e23d69',
    E: '#ffd93f',
    F: '#fff'
};


/***/ }),
/* 411 */
/***/ (function(module, exports) {

// A 16 color JMP palette by [Arne](http://androidarts.com/palette/16pal.htm)

module.exports = {
    0: '#000',
    1: '#191028',
    2: '#46af45',
    3: '#a1d685',
    4: '#453e78',
    5: '#7664fe',
    6: '#833129',
    7: '#9ec2e8',
    8: '#dc534b',
    9: '#e18d79',
    A: '#d6b97b',
    B: '#e9d8a1',
    C: '#216c4b',
    D: '#d365c8',
    E: '#afaab9',
    F: '#f5f4eb'
};


/***/ }),
/* 412 */
/***/ (function(module, exports) {

// A 16 color palette inspired by Japanese computers like the MSX.

module.exports = {
    0: '#000',
    1: '#191028',
    2: '#46af45',
    3: '#a1d685',
    4: '#453e78',
    5: '#7664fe',
    6: '#833129',
    7: '#9ec2e8',
    8: '#dc534b',
    9: '#e18d79',
    A: '#d6b97b',
    B: '#e9d8a1',
    C: '#216c4b',
    D: '#d365c8',
    E: '#afaab9',
    F: '#fff'
};


/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    ARNE16: __webpack_require__(127),
    C64: __webpack_require__(409),
    CGA: __webpack_require__(410),
    JMP: __webpack_require__(411),
    MSX: __webpack_require__(412)
    
};


/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

var Browser = __webpack_require__(55);

var Audio = {

    // @property {boolean} audioData - Are Audio tags available?
    audioData: false,

    // @property {boolean} webAudio - Is the WebAudio API available?
    webAudio: false,

    // @property {boolean} ogg - Can this device play ogg files?
    ogg: false,

    // @property {boolean} opus - Can this device play opus files?
    opus: false,

    // @property {boolean} mp3 - Can this device play mp3 files?
    mp3: false,

    // @property {boolean} wav - Can this device play wav files?
    wav: false,

    // Can this device play m4a files?
    // @property {boolean} m4a - True if this device can play m4a files.
    m4a: false,

    // @property {boolean} webm - Can this device play webm files?
    webm: false,

    // @property {boolean} dolby - Can this device play EC-3 Dolby Digital Plus files?
    dolby: false

};

function init ()
{
    Audio.audioData = !!(window['Audio']);
    Audio.webAudio = !!(window['AudioContext'] || window['webkitAudioContext']);

    var audioElement = document.createElement('audio');

    var result = !!audioElement.canPlayType;

    try
    {
        if (result)
        {
            if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.ogg = true;
            }

            if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || audioElement.canPlayType('audio/opus;').replace(/^no$/, ''))
            {
                Audio.opus = true;
            }

            if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, ''))
            {
                Audio.mp3 = true;
            }

            //  Mimetypes accepted:
            //  developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
            //  bit.ly/iphoneoscodecs
            if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''))
            {
                Audio.wav = true;
            }

            if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, ''))
            {
                Audio.m4a = true;
            }

            if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.webm = true;
            }

            if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== '')
            {
                if (Browser.edge)
                {
                    Audio.dolby = true;
                }
                else if (Browser.safari && Browser.safariVersion >= 9)
                {
                    if ((/Mac OS X (\d+)_(\d+)/).test(navigator.userAgent))
                    {
                        var major = parseInt(RegExp.$1, 10);
                        var minor = parseInt(RegExp.$2, 10);

                        if ((major === 10 && minor >= 11) || major > 10)
                        {
                            Audio.dolby = true;
                        }
                    }
                }
            }
        }
    }
    catch (e)
    {
        //  Nothing to do here
    }

    return Audio;
}

module.exports = init();


/***/ }),
/* 415 */
/***/ (function(module, exports) {

var Fullscreen = {

    //  @property {boolean} available - Does the browser support the Full Screen API?
    available: false,

    //  @property {string} request - If the browser supports the Full Screen API this holds the call you need to use to activate it.
    request: '',

    //  @property {string} cancel - If the browser supports the Full Screen API this holds the call you need to use to cancel it.
    cancel: '',

    //  @property {boolean} keyboard - Does the browser support access to the Keyboard during Full Screen mode?
    keyboard: false

};

/**
* Checks for support of the Full Screen API.
*/
function init ()
{
    var i;

    var fs = [
        'requestFullscreen',
        'requestFullScreen',
        'webkitRequestFullscreen',
        'webkitRequestFullScreen',
        'msRequestFullscreen',
        'msRequestFullScreen',
        'mozRequestFullScreen',
        'mozRequestFullscreen'
    ];

    var element = document.createElement('div');

    for (i = 0; i < fs.length; i++)
    {
        if (element[fs[i]])
        {
            Fullscreen.available = true;
            Fullscreen.request = fs[i];
            break;
        }
    }

    var cfs = [
        'cancelFullScreen',
        'exitFullscreen',
        'webkitCancelFullScreen',
        'webkitExitFullscreen',
        'msCancelFullScreen',
        'msExitFullscreen',
        'mozCancelFullScreen',
        'mozExitFullscreen'
    ];

    if (Fullscreen.available)
    {
        for (i = 0; i < cfs.length; i++)
        {
            if (document[cfs[i]])
            {
                Fullscreen.cancel = cfs[i];
                break;
            }
        }
    }

    //  Keyboard Input?
    if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT'])
    {
        Fullscreen.keyboard = true;
    }

    return Fullscreen;
}

module.exports = init();


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

var OS = __webpack_require__(50);
var Browser = __webpack_require__(55);

var Input = {

    // @property {boolean} touch - Is touch available?
    touch: false,

    // @property {boolean} mspointer - Is mspointer available?
    mspointer: false,

    // @property {?string} wheelType - The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'
    wheelEvent: null,

    // @property {boolean} gamepads - Is navigator.getGamepads available?
    gamepads: false
    
};

function init ()
{
    if ('ontouchstart' in document.documentElement || (navigator.maxTouchPoints && navigator.maxTouchPoints >= 1))
    {
        Input.touch = true;
    }

    if (navigator.msPointerEnabled || navigator.pointerEnabled)
    {
        Input.mspointer = true;
    }

    if (navigator.getGamepads)
    {
        Input.gamepads = true;
    }

    if (!OS.cocoonJS)
    {
        // See https://developer.mozilla.org/en-US/docs/Web/Events/wheel
        if ('onwheel' in window || (Browser.ie && 'WheelEvent' in window))
        {
            // DOM3 Wheel Event: FF 17+, IE 9+, Chrome 31+, Safari 7+
            Input.wheelEvent = 'wheel';
        }
        else if ('onmousewheel' in window)
        {
            // Non-FF legacy: IE 6-9, Chrome 1-31, Safari 5-7.
            Input.wheelEvent = 'mousewheel';
        }
        else if (Browser.firefox && 'MouseScrollEvent' in window)
        {
            // FF prior to 17. This should probably be scrubbed.
            Input.wheelEvent = 'DOMMouseScroll';
        }
    }

    return Input;
}

module.exports = init();


/***/ }),
/* 417 */
/***/ (function(module, exports) {


var Video = {

    //  @property {boolean} oggVideo - Can this device play ogg video files?
    oggVideo: false,

    //  @property {boolean} h264Video - Can this device play h264 mp4 video files?
    h264Video: false,

    //  @property {boolean} mp4Video - Can this device play h264 mp4 video files?
    mp4Video: false,

    //  @property {boolean} webmVideo - Can this device play webm video files?
    webmVideo: false,

    //  @property {boolean} vp9Video - Can this device play vp9 video files?
    vp9Video: false,

    //  @property {boolean} hlsVideo - Can this device play hls video files?
    hlsVideo: false

};

function init ()
{
    var videoElement = document.createElement('video');
    var result = !!videoElement.canPlayType;

    try
    {
        if (result)
        {
            if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ''))
            {
                Video.oggVideo = true;
            }

            if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
                Video.h264Video = true;
                Video.mp4Video = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ''))
            {
                Video.webmVideo = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, ''))
            {
                Video.vp9Video = true;
            }

            if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                Video.hlsVideo = true;
            }
        }
    }
    catch (e)
    {
        //  Nothing to do
    }

    return Video;
}

module.exports = init();


/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games can share it,
//  without having to re-poll the device all over again

var OS = __webpack_require__(50);
var Browser = __webpack_require__(55);
var Features = __webpack_require__(129);
var Input = __webpack_require__(416);
var Audio = __webpack_require__(414);
var Video = __webpack_require__(417);
var Fullscreen = __webpack_require__(415);
var CanvasFeatures = __webpack_require__(128);

//  Phaser.Device

module.exports = {

    OS: OS,
    Browser: Browser,
    Features: Features,
    Input: Input,
    Audio: Audio,
    Video: Video,
    Fullscreen: Fullscreen,
    CanvasFeatures: CanvasFeatures

};


/***/ }),
/* 419 */
/***/ (function(module, exports) {

var AddEventListener = function (target, event, listener, useCapture)
{
    if (useCapture === undefined) { useCapture = false; }

    target.addEventListener(event, listener, useCapture);
};

module.exports = AddEventListener;


/***/ }),
/* 420 */
/***/ (function(module, exports) {

var RemoveEventListener = function (target, event, listener)
{
    target.removeEventListener(event, listener);
};

module.exports = RemoveEventListener;


/***/ }),
/* 421 */
/***/ (function(module, exports) {

var RemoveFromDOM = function (element)
{
    if (element.parentNode)
    {
        element.parentNode.removeChild(element);
    }
};

module.exports = RemoveFromDOM;


/***/ }),
/* 422 */
/***/ (function(module, exports) {

/**
* Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.
*/
var TouchAction = function (canvas, value)
{
    if (value === undefined) { value = 'none'; }

    canvas.style['msTouchAction'] = value;
    canvas.style['ms-touch-action'] = value;
    canvas.style['touch-action'] = value;

    return canvas;
};

module.exports = TouchAction;


/***/ }),
/* 423 */
/***/ (function(module, exports) {

/**
* Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.
*/
var UserSelect = function (canvas, value)
{
    if (value === undefined) { value = 'none'; }

    var vendors = [
        '-webkit-',
        '-khtml-',
        '-moz-',
        '-ms-',
        ''
    ];

    vendors.forEach(function (vendor)
    {
        canvas.style[vendor + 'user-select'] = value;
    });

    canvas.style['-webkit-touch-callout'] = value;
    canvas.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)';

    return canvas;
};

module.exports = UserSelect;


/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(134);
var EventListener = __webpack_require__(425);

var EventBinding = new Class({

    initialize:

    function EventBinding (dispatcher, type)
    {
        this.dispatcher = dispatcher;
        this.type = type;
        this.state = CONST.DISPATCHER_IDLE;
        this.active = [];
    },

    total: function ()
    {
        var total = 0;

        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state !== CONST.LISTENER_REMOVING)
            {
                total++;
            }
        }

        return total;
    },

    get: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return this.active[i];
            }
        }
    },

    getIndex: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return i;
            }
        }

        return null;
    },

    has: function (callback)
    {
        return (this.get(callback));
    },

    add: function (callback, priority, once)
    {
        var listener = this.get(callback);

        if (!listener)
        {
            //  The listener doesn't exist, so create one
            listener = EventListener(this.type, callback, priority, once);
        }
        else
        {
            //  Listener already exists, abort
            return;
        }

        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we don't need a pending state
            listener.state = CONST.LISTENER_ACTIVE;

            this.active.push(listener);

            this.active.sort(this.sortHandler);
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  Add it to the list, but keep the state as pending.
            //  The call to 'tidy' will sort it out at the end of the dispatch.
            this.active.push(listener);
        }
    },

    sortHandler: function (listenerA, listenerB)
    {
        if (listenerB.priority < listenerA.priority)
        {
            return -1;
        }
        else if (listenerB.priority > listenerA.priority)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    },

    remove: function (callback)
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we can remove right away
            var i = this.getIndex(callback);

            if (i !== null)
            {
                this.active.splice(i, 1);
            }
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  The Dispatcher is working, so we flag the listener for removal at the end
            var listener = this.get(callback);

            if (listener)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }
        }
    },

    dispatch: function (event)
    {
        if (this.state !== CONST.DISPATCHER_IDLE)
        {
            throw new Error('Error: Failed to execute \'EventDispatcher.dispatch\' on \'' + this.type + '\': The event is already being dispatched.');
        }
        else if (this.active.length === 0)
        {
            //  This was a valid dispatch call, we just had nothing to do ...
            return;
        }

        this.state = CONST.DISPATCHER_DISPATCHING;

        var listener;

        for (var i = 0; i < this.active.length; i++)
        {
            listener = this.active[i];

            if (listener.state !== CONST.LISTENER_ACTIVE)
            {
                continue;
            }

            listener.callback.call(this.dispatcher, event);

            //  Has the callback changed the state of this binding?
            if (this.state !== CONST.DISPATCHER_DISPATCHING)
            {
                //  Yup! Let's break out
                break;
            }

            //  Was it a 'once' listener?
            if (listener.once)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }

            //  Has the event been halted by the callback?
            if (!event._propagate)
            {
                //  Break out, a listener has called Event.stopPropagation
                break;
            }
        }

        //  Dispatch over, or aborted
        if (this.state === CONST.DISPATCHER_REMOVING)
        {
            this.removeAll();

            //  All done, tidy the list in case there were any pending events added
            this.tidy();
        }
        else if (this.state === CONST.DISPATCHER_DESTROYED)
        {
            this.dispatcher.delete(this.type);
        }
        else
        {
            //  All done, just purge the list
            this.tidy();

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    //  Removes all listeners
    //  If this is currently being dispatched then don't remove 'pending' listeners
    //  (i.e. ones that were added during the dispatch), only active ones
    removeAll: function ()
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            this.active.length = 0;
        }
        else
        {
            for (var i = this.active.length - 1; i >= 0; i--)
            {
                if (this.active[i].state !== CONST.LISTENER_PENDING)
                {
                    this.active.pop();
                }
            }

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    tidy: function ()
    {
        //  Nothing to do ...
        if (this.active.length === 0)
        {
            return;
        }

        var added = 0;

        var i = this.active.length - 1;

        do
        {
            if (this.active[i].state === CONST.LISTENER_REMOVING)
            {
                this.active.splice(i, 1);
            }
            else if (this.active[i].state === CONST.LISTENER_PENDING)
            {
                this.active[i].state === CONST.LISTENER_ACTIVE;
                added++;
            }

            i--;
        }
        while (i >= 0);

        if (added > 0)
        {
            this.active.sort(this.sortHandler);
        }
    },

    destroy: function ()
    {
        this.active.length = 0;
        this.dispatcher = undefined;
        this.type = '';
        this.state = CONST.DISPATCHER_DESTROYED;
    }

});

module.exports = EventBinding;


/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(134);

var EventListener = function (type, callback, priority, once)
{
    return {
        type: type,
        callback: callback,
        priority: priority,
        once: once,
        state: CONST.LISTENER_PENDING
    };
};

module.exports = EventListener;


/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

var ParseXMLBitmapFont = __webpack_require__(137);

var ParseFromAtlas = function (scene, fontName, textureKey, frameKey, xmlKey, xSpacing, ySpacing)
{
    var frame = scene.sys.textures.getFrame(textureKey, frameKey);
    var xml = scene.sys.cache.xml.get(xmlKey);

    if (frame && xml)
    {
        var data = ParseXMLBitmapFont(xml, xSpacing, ySpacing, frame);

        scene.sys.cache.bitmapFont.add(fontName, { data: data, texture: textureKey, frame: frameKey });

        return true;
    }
    else
    {
        return false;
    }
};

module.exports = ParseFromAtlas;


/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(4);

// * @param {number} characterWidth - The width of each character in the font set.
// * @param {number} characterHeight - The height of each character in the font set.
// * @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.
// * @param {number} [charsPerRow] - The number of characters per row in the font set. If not given charsPerRow will be the image width / characterWidth.
// * @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.
// * @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.
// * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
// * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.
// Phaser.GameObject.RetroFont = function (game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset)

// {
//      image: key,
//      width: 32,
//      height: 32,
//      chars: 'string',
//      charsPerRow: null,
//      spacing: { x: 0, y: 0 },
//      offset: { x: 0, y: 0 }
// }

var ParseRetroFont = function (scene, config)
{
    var w = config.width;
    var h = config.height;
    var cx = Math.floor(w / 2);
    var cy = Math.floor(h / 2);
    var letters = config.chars;

    var key = GetValue(config, 'image', '');
    var offsetX = GetValue(config, 'offset.x', 0);
    var offsetY = GetValue(config, 'offset.y', 0);
    var spacingX = GetValue(config, 'spacing.x', 0);
    var spacingY = GetValue(config, 'spacing.y', 0);

    var charsPerRow = GetValue(config, 'charsPerRow', null);

    if (charsPerRow === null)
    {
        charsPerRow = scene.sys.textures.getFrame(key).width / w;

        if (charsPerRow > letters.length)
        {
            charsPerRow = letters.length;
        }
    }

    var x = offsetX;
    var y = offsetY;

    var data = {
        retroFont: true,
        font: key,
        size: w,
        lineHeight: h,
        chars: {}
    };

    var r = 0;

    for (var i = 0; i < letters.length; i++)
    {
        // var node = letters[i];

        var charCode = letters.charCodeAt(i);

        data.chars[charCode] =
        {
            x: x,
            y: y,
            width: w,
            height: h,
            centerX: cx,
            centerY: cy,
            xOffset: 0,
            yOffset: 0,
            xAdvance: w,
            data: {},
            kerning: {}
        };

        r++;

        if (r === charsPerRow)
        {
            r = 0;
            x = offsetX;
            y += h + spacingY;
        }
        else
        {
            x += w + spacingX;
        }
    }

    var entry = {
        data: data,
        frame: null,
        texture: key
    };

    return entry;
};

/**
* Text Set 1 =  !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";

/**
* Text Set 2 =  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ";

/**
* Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";

/**
* Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789";

/**
* Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789";

/**
* Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.' 
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ";

/**
* Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39";

/**
* Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ";

/**
* Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!";

/**
* Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

/**
* Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789";

module.exports = ParseRetroFont;


/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var DynamicBitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    var text = src.text;
    var textLength = text.length;

    if (GameObject.RENDER_MASK !== src.renderFlags || textLength === 0 || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }
    
    var textureFrame = src.frame;

    var displayCallback = src.displayCallback;

    var cameraScrollX = camera.scrollX * src.scrollFactorX;
    var cameraScrollY = camera.scrollY * src.scrollFactorY;

    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    var ctx = renderer.currentContext;
    var image = src.frame.source.image;

    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;

    var rotation = 0;
    var scale = (src.fontSize / src.fontData.size);

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(src.x, src.y);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);

    if (src.cropWidth > 0 && src.cropHeight > 0)
    {
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, src.cropWidth, src.cropHeight);
        ctx.clip();
        ctx.closePath();
    }

    for (var index = 0; index < textLength; ++index)
    {
        //  Reset the scale (in case the callback changed it)
        scale = (src.fontSize / src.fontData.size);
        rotation = 0;

        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = (indexCount + glyph.xOffset + xAdvance) - src.scrollX;
        y = (glyph.yOffset + yAdvance) - src.scrollY;

        //  This could be optimized so that it doesn't even bother drawing it if the x/y is out of range

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (displayCallback)
        {
            var output = displayCallback({ tint: { topLeft: 0, topRight: 0, bottomLeft: 0, bottomRight: 0 }, index: index, charCode: charCode, x: x, y: y, scale: scale, rotation: 0, data: glyph.data });

            x = output.x;
            y = output.y;
            scale = output.scale;
            rotation = output.rotation;
        }

        x *= scale;
        y *= scale;

        x -= cameraScrollX;
        y -= cameraScrollY;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.scale(scale, scale);

        // ctx.fillStyle = 'rgba(0,255,0,0.2)';
        // ctx.fillRect(0, 0, glyphW, glyphH);

        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);

        ctx.restore();
        
        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    if (src.cropWidth > 0 && src.cropHeight > 0)
    {
        ctx.restore();
    }

    ctx.restore();
};

module.exports = DynamicBitmapTextCanvasRenderer;


/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

var BitmapText = __webpack_require__(77);
var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('dynamicBitmapText', function (config)
{
    var font = GetAdvancedValue(config, 'font', '');
    var text = GetAdvancedValue(config, 'text', '');
    var size = GetAdvancedValue(config, 'size', false);
    var align = GetAdvancedValue(config, 'align', 'left');

    var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, align);

    BuildGameObject(this.scene, bitmapText, config);

    return bitmapText;
});


/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

var DynamicBitmapText = __webpack_require__(77);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('dynamicBitmapText', function (x, y, font, text, size)
{
    return this.displayList.add(new DynamicBitmapText(this.scene, x, y, font, text, size));
});


/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(432);
}

if (true)
{
    renderCanvas = __webpack_require__(428);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);
var TransformMatrix = __webpack_require__(17);
var tempMatrix = new TransformMatrix();
var tempMatrixChar = new TransformMatrix();

var DynamicBitmapTextWebGLRenderer = function (renderer, gameObject, interpolationPercentage, camera)
{
    var text = gameObject.text;
    var textLength = text.length;

    if (GameObject.RENDER_MASK !== gameObject.renderFlags || textLength === 0 || (gameObject.cameraFilter > 0 && (gameObject.cameraFilter & camera._id)))
    {
        return;
    }

    var displayCallback = gameObject.displayCallback;
    var textureFrame = gameObject.frame;
    var cameraScrollX = camera.scrollX * gameObject.scrollFactorX;
    var cameraScrollY = camera.scrollY * gameObject.scrollFactorY;
    var chars = gameObject.fontData.chars;
    var lineHeight = gameObject.fontData.lineHeight;
    var spriteBatch = renderer.spriteBatch;
    var alpha = gameObject.alpha;
    var tintTL = gameObject._tintTL;
    var tintTR = gameObject._tintTR;
    var tintBL = gameObject._tintBL;
    var tintBR = gameObject._tintBR;
    var vertexDataBuffer = spriteBatch.vertexDataBuffer;
    var vertexBuffer = vertexDataBuffer.floatView;
    var vertexBufferU32 = vertexDataBuffer.uintView;
    var vertexOffset = 0;
    var textureData = gameObject.texture.source[textureFrame.sourceIndex];
    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;
    var textureWidth = textureData.width;
    var textureHeight = textureData.height;
    var texture = textureData.glTexture;
    var xAdvance = 0;
    var yAdvance = 0;
    var indexCount = 0;
    var charCode = 0;
    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;
    var x = 0;
    var y = 0;
    var rotation = 0;
    var xw = 0;
    var yh = 0;
    var umin = 0;
    var umax = 0;
    var vmin = 0;
    var vmax = 0;
    var lastGlyph = null;
    var lastCharCode = 0;
    var tempMatrixMatrix = tempMatrix.matrix;
    var cameraMatrix = camera.matrix.matrix;
    var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var scale = (gameObject.fontSize / gameObject.fontData.size);
    var uta, utb, utc, utd, ute, utf;
    var tempMatrixCharMatrix = tempMatrixChar.matrix;
    var renderTarget = gameObject.renderTarget;

    tempMatrix.applyITRS(
        gameObject.x - cameraScrollX, gameObject.y - cameraScrollY,
        -gameObject.rotation,
        gameObject.scaleX, gameObject.scaleY
    );

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    var gl = renderer.gl;

    if (gameObject.cropWidth > 0 && gameObject.cropHeight > 0)
    {
        if (renderer.currentRenderer !== null)
        {
            renderer.currentRenderer.flush();
        }

        if (!renderer.scissor.enabled)
        {
            gl.enable(gl.SCISSOR_TEST);
        }

        var sw = gameObject.cropWidth * gameObject.scaleX;
        var sh = gameObject.cropHeight * gameObject.scaleY;

        gl.scissor(gameObject.x, gl.drawingBufferHeight - gameObject.y - sh, sw, sh);
    }

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = (indexCount + glyph.xOffset + xAdvance) * scale;
        y = (glyph.yOffset + yAdvance) * scale;

        rotation = 0;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (displayCallback)
        {
            var output = displayCallback({ color: 0, tint: { topLeft: tintTL, topRight: tintTR, bottomLeft: tintBL, bottomRight: tintBR }, index: index, charCode: charCode, x: x, y: y, scale: scale, rotation: 0, data: glyph.data });

            x = output.x;
            y = output.y;
            scale = output.scale;
            rotation = output.rotation;

            if (output.color)
            {
                tintTL = output.color;
                tintTR = output.color;
                tintBL = output.color;
                tintBR = output.color;
            }
            else
            {
                tintTL = output.tint.topLeft;
                tintTR = output.tint.topRight;
                tintBL = output.tint.bottomLeft;
                tintBR = output.tint.bottomRight;
            }
        }

        x -= gameObject.scrollX | 0;
        y -= gameObject.scrollY | 0;

        tempMatrixChar.applyITRS(
            x, y,
            -rotation,
            scale, scale
        );

        uta = tempMatrixCharMatrix[0];
        utb = tempMatrixCharMatrix[1];
        utc = tempMatrixCharMatrix[2];
        utd = tempMatrixCharMatrix[3];
        ute = tempMatrixCharMatrix[4];
        utf = tempMatrixCharMatrix[5];

        sra = uta * mva + utb * mvc;
        srb = uta * mvb + utb * mvd;
        src = utc * mva + utd * mvc;
        srd = utc * mvb + utd * mvd;
        sre = ute * mva + utf * mvc + mve;
        srf = ute * mvb + utf * mvd + mvf;

        xw = glyphW;
        yh = glyphH;
        tx0 = sre;
        ty0 = srf;
        tx1 = yh * src + sre;
        ty1 = yh * srd + srf;
        tx2 = xw * sra + yh * src + sre;
        ty2 = xw * srb + yh * srd + srf;
        tx3 = xw * sra + sre;
        ty3 = xw * srb + srf;
        umin = glyphX / textureWidth;
        umax = (glyphX + glyphW) / textureWidth;
        vmin = glyphY / textureHeight;
        vmax = (glyphY + glyphH) / textureHeight;

        if (spriteBatch.elementCount >= spriteBatch.maxParticles)
        {
            spriteBatch.flush();
        }

        renderer.setRenderer(spriteBatch, texture, renderTarget);
        vertexOffset = vertexDataBuffer.allocate(24);
        spriteBatch.elementCount += 6;

        vertexBuffer[vertexOffset++] = tx0;
        vertexBuffer[vertexOffset++] = ty0;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBufferU32[vertexOffset++] = tintTL;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = tx1;
        vertexBuffer[vertexOffset++] = ty1;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBufferU32[vertexOffset++] = tintBL;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = tx2;
        vertexBuffer[vertexOffset++] = ty2;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBufferU32[vertexOffset++] = tintBR;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = tx3;
        vertexBuffer[vertexOffset++] = ty3;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBufferU32[vertexOffset++] = tintTR;
        vertexBuffer[vertexOffset++] = alpha;

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    if (gameObject.cropWidth > 0 && gameObject.cropHeight > 0)
    {
        spriteBatch.flush();

        if (renderer.scissor.enabled)
        {
            gl.scissor(renderer.scissor.x, renderer.scissor.y, renderer.scissor.width, renderer.scissor.height);
        }
        else
        {
            gl.scissor(camera.x, gl.drawingBufferHeight - camera.y - camera.height, camera.width, camera.height);
            gl.disable(gl.SCISSOR_TEST);
        }
    }
};

module.exports = DynamicBitmapTextWebGLRenderer;


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var BitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    var text = src.text;
    var textLength = text.length;

    if (GameObject.RENDER_MASK !== src.renderFlags || textLength === 0 || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }
    
    var textureFrame = src.frame;

    var cameraScrollX = camera.scrollX * src.scrollFactorX;
    var cameraScrollY = camera.scrollY * src.scrollFactorY;

    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    var ctx = renderer.currentContext;
    var image = src.frame.source.image;

    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;

    var rotation = 0;
    var scale = (src.fontSize / src.fontData.size);

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate((src.x - cameraScrollX) + src.frame.x, (src.y - cameraScrollY) + src.frame.y);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);

    // ctx.fillStyle = 'rgba(255,0,255,0.5)';

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = indexCount + glyph.xOffset + xAdvance;
        y = glyph.yOffset + yAdvance;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        x *= scale;
        y *= scale;

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;

        //  Nothing to render or a space? Then skip to the next glyph
        if (glyphW === 0 || glyphH === 0 || charCode === 32)
        {
            continue;
        }

        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        // ctx.fillRect(0, 0, glyphW, glyphH);
        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
        ctx.restore();
    }

    ctx.restore();
};

module.exports = BitmapTextCanvasRenderer;


/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

var BitmapText = __webpack_require__(78);
var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var GetValue = __webpack_require__(4);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('bitmapText', function (config)
{
    var font = GetValue(config, 'font', '');
    var text = GetAdvancedValue(config, 'text', '');
    var size = GetAdvancedValue(config, 'size', false);
    // var align = GetValue(config, 'align', 'left');

    var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size);

    BuildGameObject(this.scene, bitmapText, config);

    return bitmapText;
});


/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

var BitmapText = __webpack_require__(78);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('bitmapText', function (x, y, font, text, size)
{
    return this.displayList.add(new BitmapText(this.scene, x, y, font, text, size));
});


/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(437);
}

if (true)
{
    renderCanvas = __webpack_require__(433);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);
var TransformMatrix = __webpack_require__(17);
var tempMatrix = new TransformMatrix();

var BitmapTextWebGLRenderer = function (renderer, gameObject, interpolationPercentage, camera)
{
    var text = gameObject.text;
    var textLength = text.length;

    if (GameObject.RENDER_MASK !== gameObject.renderFlags || textLength === 0 || (gameObject.cameraFilter > 0 && (gameObject.cameraFilter & camera._id)))
    {
        return;
    }

    var textureFrame = gameObject.frame;
    var cameraScrollX = camera.scrollX * gameObject.scrollFactorX;
    var cameraScrollY = camera.scrollY * gameObject.scrollFactorY;
    var chars = gameObject.fontData.chars;
    var lineHeight = gameObject.fontData.lineHeight;
    var spriteBatch = renderer.spriteBatch;
    var alpha = gameObject.alpha;
    var tintTL = gameObject._tintTL;
    var tintTR = gameObject._tintTR;
    var tintBL = gameObject._tintBL;
    var tintBR = gameObject._tintBR;
    var vertexDataBuffer = spriteBatch.vertexDataBuffer;
    var vertexBuffer = vertexDataBuffer.floatView;
    var vertexBufferU32 = vertexDataBuffer.uintView;
    var vertexOffset = 0;
    var srcX = gameObject.x;
    var srcY = gameObject.y;
    var textureData = gameObject.texture.source[textureFrame.sourceIndex];
    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;
    var textureWidth = textureData.width;
    var textureHeight = textureData.height;
    var texture = textureData.glTexture;
    var xAdvance = 0;
    var yAdvance = 0;
    var indexCount = 0;
    var charCode = 0;
    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;
    var x = 0;
    var y = 0;
    var xw = 0;
    var yh = 0;
    var umin = 0;
    var umax = 0;
    var vmin = 0;
    var vmax = 0;
    var lastGlyph = null;
    var lastCharCode = 0;
    var tempMatrixMatrix = tempMatrix.matrix;
    var cameraMatrix = camera.matrix.matrix;
    var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var scale = (gameObject.fontSize / gameObject.fontData.size);
    var renderTarget = gameObject.renderTarget;

    tempMatrix.applyITRS(
        (srcX - cameraScrollX) + textureFrame.x, (srcY - cameraScrollY) + textureFrame.y,
        -gameObject.rotation,
        gameObject.scaleX, gameObject.scaleY
    );

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;
        glyphW = glyph.width;
        glyphH = glyph.height;
        x = (indexCount + glyph.xOffset + xAdvance) * scale;
        y = (glyph.yOffset + yAdvance) * scale;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;

        //  Nothing to render or a space? Then skip to the next glyph
        if (glyphW === 0 || glyphH === 0 || charCode === 32)
        {
            continue;
        }

        xw = x + glyphW * scale;
        yh = y + glyphH * scale;
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;
        umin = glyphX / textureWidth;
        umax = (glyphX + glyphW) / textureWidth;
        vmin = glyphY / textureHeight;
        vmax = (glyphY + glyphH) / textureHeight;

        if (spriteBatch.elementCount >= spriteBatch.maxParticles)
        {
            spriteBatch.flush();
        }

        renderer.setRenderer(spriteBatch, texture, renderTarget);
        vertexOffset = vertexDataBuffer.allocate(24);
        spriteBatch.elementCount += 6;

        vertexBuffer[vertexOffset++] = tx0;
        vertexBuffer[vertexOffset++] = ty0;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBufferU32[vertexOffset++] = tintTL;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = tx1;
        vertexBuffer[vertexOffset++] = ty1;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBufferU32[vertexOffset++] = tintBL;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = tx2;
        vertexBuffer[vertexOffset++] = ty2;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBufferU32[vertexOffset++] = tintTR;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = tx3;
        vertexBuffer[vertexOffset++] = ty3;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBufferU32[vertexOffset++] = tintBR;
        vertexBuffer[vertexOffset++] = alpha;
    }
};

module.exports = BitmapTextWebGLRenderer;


/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var BlitterCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    var list = src.getRenderList();

    renderer.setBlendMode(src.blendMode);

    var ca = renderer.currentAlpha;

    //  Render bobs
    for (var i = 0; i < list.length; i++)
    {
        var bob = list[i];

        if (ca !== bob.alpha)
        {
            ca = renderer.setAlpha(bob.alpha);
        }

        renderer.blitImage(bob.x, bob.y, bob.frame, camera);
    }
};

module.exports = BlitterCanvasRenderer;


/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

var Blitter = __webpack_require__(79);
var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('blitter', function (config)
{
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);

    var blitter = new Blitter(this.scene, 0, 0, key, frame);

    BuildGameObject(this.scene, blitter, config);

    return blitter;
});


/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

var Blitter = __webpack_require__(79);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('blitter', function (x, y, key, frame)
{
    return this.displayList.add(new Blitter(this.scene, x, y, key, frame));
});


/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(442);
}

if (true)
{
    renderCanvas = __webpack_require__(438);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var BlitterWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    var list = src.getRenderList();
    var blitterBatch = renderer.blitterBatch;
    var cameraMatrix = camera.matrix.matrix;
    var a = cameraMatrix[0];
    var b = cameraMatrix[1];
    var c = cameraMatrix[2];
    var d = cameraMatrix[3];
    var e = cameraMatrix[4];
    var f = cameraMatrix[5];
    var cameraScrollX = camera.scrollX * src.scrollFactorX;
    var cameraScrollY = camera.scrollY * src.scrollFactorY;
    var renderTarget = src.renderTarget;

    //  Render bobs

    for (var i = 0, l = list.length; i < l; i++)
    {
        var bob = list[i];
        var frame = bob.frame;
        var alpha = bob.alpha;
        var vertexDataBuffer = blitterBatch.vertexDataBuffer;
        var vertexBuffer = vertexDataBuffer.floatView;
        var vertexOffset = 0;
        var uvs = frame.uvs;
        var width = frame.width * (bob.flipX ? -1 : 1);
        var height = frame.height * (bob.flipY ? -1 : 1);
        var x = bob.x + frame.x - cameraScrollX + ((frame.width) * (bob.flipX ? 1 : 0.0));
        var y = bob.y + frame.y - cameraScrollY + ((frame.height) * (bob.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var tx = x * a + y * c + e;
        var ty = x * b + y * d + f;
        var txw = xw * a + yh * c + e;
        var tyh = xw * b + yh * d + f;

        if (blitterBatch.elementCount >= blitterBatch.maxParticles)
        {
            blitterBatch.flush();
        }

        renderer.setRenderer(blitterBatch, frame.texture.source[frame.sourceIndex].glTexture, camera, renderTarget);
        vertexOffset = vertexDataBuffer.allocate(20);
        blitterBatch.elementCount += 6;
        x += frame.x;
        y += frame.y;

        vertexBuffer[vertexOffset++] = tx;
        vertexBuffer[vertexOffset++] = ty;
        vertexBuffer[vertexOffset++] = uvs.x0;
        vertexBuffer[vertexOffset++] = uvs.y0;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = tx;
        vertexBuffer[vertexOffset++] = tyh;
        vertexBuffer[vertexOffset++] = uvs.x1;
        vertexBuffer[vertexOffset++] = uvs.y1;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = txw;
        vertexBuffer[vertexOffset++] = tyh;
        vertexBuffer[vertexOffset++] = uvs.x2;
        vertexBuffer[vertexOffset++] = uvs.y2;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = txw;
        vertexBuffer[vertexOffset++] = ty;
        vertexBuffer[vertexOffset++] = uvs.x3;
        vertexBuffer[vertexOffset++] = uvs.y3;
        vertexBuffer[vertexOffset++] = alpha;
    }
};

module.exports = BlitterWebGLRenderer;


/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var Bob = new Class({

    initialize:

    function Bob (x, y, frame, visible)
    {
        //  Set by the DisplayList class
        this.parent;

        this.x = x;
        this.y = y;
        this.frame = frame;
        this.data = {};

        this._visible = visible;
        this._alpha = 1;

        this.flipX - false;
        this.flipY = false;

    },

    resetFlip: function ()
    {
        this.flipX = false;
        this.flipY = false;
    },

    reset: function (x, y, frame)
    {
        this.x = x;
        this.y = y;
        this.frame = frame;
    },

    destroy: function ()
    {
        this.parent.dirty = true;

        this.parent.children.remove(this);

        this.parent = undefined;
        this.frame = undefined;
        this.data = undefined;
    },

    visible: {

        get: function ()
        {
            return this._visible;
        },

        set: function (value)
        {
            this._visible = value;
            this.parent.dirty = true;
        }

    },

    alpha: {

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            this._alpha = value;
            this.parent.dirty = true;
        }

    }

});

module.exports = Bob;


/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

var Clamp = __webpack_require__(52);

//  Alpha Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 2; // 0010

var Alpha = {

    _alpha: 1,

    _alphaTL: 1,
    _alphaTR: 1,
    _alphaBL: 1,
    _alphaBR: 1,

    clearAlpha: function ()
    {
        return this.setAlpha(1);
    },

    setAlpha: function (topLeft, topRight, bottomLeft, bottomRight)
    {
        if (topLeft === undefined) { topLeft = 1; }

        //  Treat as if there is only one alpha value for the whole Game Object
        if (topRight === undefined)
        {
            this.alpha = topLeft;
        }
        else
        {
            this._alphaTL = Clamp(topLeft, 0, 1);
            this._alphaTR = Clamp(topRight, 0, 1);
            this._alphaBL = Clamp(bottomLeft, 0, 1);
            this._alphaBR = Clamp(bottomRight, 0, 1);
        }

        return this;
    },

    //  Global Alpha value. If changed this adjusts all alpha properties (topLeft, topRight, etc)
    alpha: {

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            var v = Clamp(value, 0, 1);

            this._alpha = v;
            this._alphaTL = v;
            this._alphaTR = v;
            this._alphaBL = v;
            this._alphaBR = v;

            if (v === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    //  Adjusts the alpha value of the top-left vertex (WebGL only)
    alphaTopLeft: {

        get: function ()
        {
            return this._alphaTL;
        },

        set: function (value)
        {
            var v = Clamp(value, 0, 1);

            this._alphaTL = v

            if (v !== 0)
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    alphaTopRight: {

        get: function ()
        {
            return this._alphaTR;
        },

        set: function (value)
        {
            var v = Clamp(value, 0, 1);

            this._alphaTR = v

            if (v !== 0)
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    alphaBottomLeft: {

        get: function ()
        {
            return this._alphaBL;
        },

        set: function (value)
        {
            var v = Clamp(value, 0, 1);

            this._alphaBL = v

            if (v !== 0)
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    alphaBottomRight: {

        get: function ()
        {
            return this._alphaBR;
        },

        set: function (value)
        {
            var v = Clamp(value, 0, 1);

            this._alphaBR = v

            if (v !== 0)
            {
                this.renderFlags |= _FLAG;
            }
        }

    }

};

module.exports = Alpha;


/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var Components = __webpack_require__(481);

//  Game Object Animation Controller

var Animation = new Class({

    initialize:

    function Animation (parent)
    {
        //  Sprite / Game Object
        this.parent = parent;

        this.animationManager = parent.scene.sys.anims;

        this.animationManager.events.once('REMOVE_ANIMATION_EVENT', this.remove.bind(this));

        this.isPlaying = false;

        //  Reference to the Phaser.Animation object
        this.currentAnim = null;

        //  Reference to the Phaser.AnimationFrame object
        this.currentFrame = null;

        //  Animation specific values
        //  -------------------------

        //  Scale the time (make it go faster / slower)
        //  Factor that's used to scale time where 1 = normal speed (the default), 0.5 = half speed, 2 = double speed, etc.
        this._timeScale = 1;

        //  The frame rate of playback in frames per second (default 24 if duration is null)
        this.frameRate = 0;

        //  How long the animation should play for. If frameRate is set it overrides this value
        //  otherwise frameRate is derived from duration
        this.duration = 0;

        //  ms per frame (without including frame specific modifiers)
        this.msPerFrame = 0;

        //  Skip frames if the time lags, or always advanced anyway?
        this.skipMissedFrames = true;

        //  Delay before starting playback (in seconds)
        this._delay = 0;

        //  Number of times to repeat the animation (-1 for infinity)
        this._repeat = 0;

        //  Delay before the repeat starts (in seconds)
        this._repeatDelay = 0;

        //  Should the animation yoyo? (reverse back down to the start) before repeating?
        this._yoyo = false;

        //  Playhead values
        //  ---------------

        //  Move the playhead forward (true) or in reverse (false)
        this.forward = true;

        this.accumulator = 0;
        this.nextTick = 0;

        this.repeatCounter = 0;

        this.pendingRepeat = false;

        this._paused = false;
        this._wasPlaying = false;

        this._callbackArgs = [ parent, null ];
        this._updateParams = [];
    },


    destroy: function ()
    {

    },

    delay: Components.Delay,
    delayedPlay: Components.DelayedPlay,
    getCurrentKey: Components.GetCurrentKey,
    load: Components.Load,
    pause: Components.Pause,
    paused: Components.Paused,
    play: Components.Play,
    progress: Components.Progress,
    remove: Components.Remove,
    repeat: Components.Repeat,
    repeatDelay: Components.RepeatDelay,
    restart: Components.Restart,
    resume: Components.Resume,
    stop: Components.Stop,
    timeScale: Components.TimeScale,
    totalFrames: Components.TotalFrames,
    totalProgress: Components.TotalProgress,
    update: Components.Update,
    updateFrame: Components.UpdateFrame,
    yoyo: Components.Yoyo

});

module.exports = Animation;


/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

var BlendModes = __webpack_require__(42);

//  BlendMode Component

var BlendMode = {

    _blendMode: BlendModes.NORMAL,

    blendMode: {

        get: function ()
        {
            return this._blendMode;
        },

        set: function (value)
        {
            value | 0;

            if (value >= 0)
            {
                this._blendMode = value;
            }
        }

    },

    setBlendMode: function (value)
    {
        this.blendMode = value;

        return this;
    }

};

module.exports = BlendMode;


/***/ }),
/* 447 */
/***/ (function(module, exports) {

var ComputedSize = {

    width: 0,
    height: 0,

    displayWidth: {

        get: function ()
        {
            return this.scaleX * this.width;
        },

        set: function (value)
        {
            this.scaleX = value / this.width;
        }

    },

    displayHeight: {

        get: function ()
        {
            return this.scaleY * this.height;
        },

        set: function (value)
        {
            this.scaleY = value / this.height;
        }

    }

};

module.exports = ComputedSize;


/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var DataProxy = new Class({

    initialize:

    function DataProxy (scene, gameObject)
    {
        this.manager = scene.sys.dataStore;

        this.gameObject = gameObject;
    },

    set: function (key, value)
    {
        return this.manager.set(this.gameObject, key, value);
    },

    get: function (key)
    {
        return this.manager.get(this.gameObject, key);
    },

    getAll: function ()
    {
        return this.manager.getAll(this.gameObject);
    },

    query: function (search)
    {
        return this.manager.query(this.gameObject, search);
    },

    before: function (key, callback, scope)
    {
        return this.manager.before(this.gameObject, key, callback, scope);
    },

    after: function (key, callback, scope)
    {
        return this.manager.after(this.gameObject, key, callback, scope);
    },

    each: function (callback, scope)
    {
        var args = [ this.gameObject, null, undefined ];

        for (var i = 2; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        return this.manager.each(this.gameObject, callback, scope, args);
    },

    merge: function (data, overwrite)
    {
        return this.manager.merge(this.gameObject, data, overwrite);
    },

    remove: function (key)
    {
        return this.manager.remove(this.gameObject, key);
    },

    removeListeners: function (key)
    {
        return this.manager.removeListeners(this.gameObject, key);
    },

    pop: function (key)
    {
        return this.manager.pop(this.gameObject, key);
    },

    has: function (key)
    {
        return this.manager.has(this.gameObject, key);
    },

    reset: function ()
    {
        return this.manager.reset(this.gameObject);
    },

    freeze: function ()
    {
        this.manager.freeze(this.gameObject);
    },

    unfreeze: function ()
    {
        this.manager.unfreeze(this.gameObject);
    },

    destroy: function ()
    {
        this.manager.kill(this.gameObject);

        this.manager = null;
        this.gameObject = null;
    }

});

module.exports = DataProxy;


/***/ }),
/* 449 */
/***/ (function(module, exports) {

var Flip = {

    flipX: false,
    flipY: false,

    toggleFlipX: function ()
    {
        this.flipX = !this.flipX;

        return this;
    },

    toggleFlipY: function ()
    {
        this.flipY = !this.flipY;

        return this;
    },

    setFlipX: function (value)
    {
        this.flipX = value;

        return this;
    },

    setFlipY: function (value)
    {
        this.flipY = value;

        return this;
    },

    setFlip: function (x, y)
    {
        this.flipX = x;
        this.flipY = y;

        return this;
    },

    resetFlip: function ()
    {
        this.flipX = false;
        this.flipY = false;
    }

};

module.exports = Flip;


/***/ }),
/* 450 */
/***/ (function(module, exports) {

var GetBounds = {

    getBounds: function (output)
    {
        if (output === undefined) { output = { x: 0, y: 0, width: 0, height: 0 }; }

        var x = this.x;
        var y = this.y;

        var w = this.displayWidth;
        var h = this.displayHeight;

        var r = this.rotation;

        var wct = w * Math.cos(r);
        var hct = h * Math.cos(r);

        var wst = w * Math.sin(r);
        var hst = h * Math.sin(r);

        var xMin = x;
        var xMax = x;
        var yMin = y;
        var yMax = y;

        if (r > 0)
        {
            if (r < 1.5707963267948966)
            {
                // 0 < theta < 90
                yMax = y + hct + wst;
                xMin = x - hst;
                xMax = x + wct;
            }
            else
            {
                // 90 <= theta <= 180
                yMin = y + hct;
                yMax = y + wst;
                xMin = x - hst + wct;
            }
        }
        else if (r > -1.5707963267948966)
        {
            // -90 < theta <= 0
            yMin = y + wst;
            yMax = y + hct;
            xMax = x + wct - hst;
        }
        else
        {
            // -180 <= theta <= -90
            yMin = y + wst + hct;
            xMin = x + wct;
            xMax = x - hst;
        }

        output.x = xMin;
        output.y = yMin;
        output.width = xMax - xMin;
        output.height = yMax - yMin;

        return output;
    }
};

module.exports = GetBounds;


/***/ }),
/* 451 */
/***/ (function(module, exports) {

//  Origin Component
//  Values are normalized, given in the range 0 to 1.
//  Display values contain the calculated pixel values.

var Origin = {

    originX: 0.5,
    originY: 0.5,

    //  READ ONLY
    displayOriginX: 0,
    displayOriginY: 0,

    setOrigin: function (x, y)
    {
        if (x === undefined) { x = 0.5; }
        if (y === undefined) { y = x; }

        this.originX = x;
        this.originY = y;

        return this.updateOrigin();
    },

    setDisplayOrigin: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.displayOriginX = x;
        this.displayOriginY = y;

        this.originX = this.width / x;
        this.originY = this.height / y;

        return this;
    },

    updateOrigin: function ()
    {
        this.displayOriginX = Math.round(this.originX * this.width);
        this.displayOriginY = Math.round(this.originY * this.height);

        return this;
    }

};

module.exports = Origin;


/***/ }),
/* 452 */
/***/ (function(module, exports) {

var RenderTarget = {

    renderTarget: null
    
};

module.exports = RenderTarget;

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(35);

//  ScaleMode Component

var ScaleMode = {

    _scaleMode: ScaleModes.DEFAULT,

    scaleMode: {

        get: function ()
        {
            return this._scaleMode;
        },

        set: function (value)
        {
            if (value === ScaleModes.LINEAR || value === ScaleModes.NEAREST)
            {
                this._scaleMode = value;
            }
        }

    },

    setScaleMode: function (value)
    {
        this.scaleMode = value;

        return this;
    }

};

module.exports = ScaleMode;


/***/ }),
/* 454 */
/***/ (function(module, exports) {

var ScrollFactor = {

    scrollFactorX: 1.0,
    scrollFactorY: 1.0,

    setScrollFactor: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.scrollFactorX = x;
        this.scrollFactorY = y;

        return this;
    }

};

module.exports = ScrollFactor;


/***/ }),
/* 455 */
/***/ (function(module, exports) {

var Size = {

    width: 0,
    height: 0,

    displayWidth: {

        get: function ()
        {
            return this.scaleX * this.frame.realWidth;
        },

        set: function (value)
        {
            this.scaleX = value / this.frame.realWidth;
        }

    },

    displayHeight: {

        get: function ()
        {
            return this.scaleY * this.frame.realHeight;
        },

        set: function (value)
        {
            this.scaleY = value / this.frame.realHeight;
        }

    },

    setSizeToFrame: function (frame)
    {
        if (frame === undefined) { frame = this.frame; }

        this.width = frame.realWidth;
        this.height = frame.realHeight;

        return this;
    },

    setSize: function (width, height)
    {
        this.width = width;
        this.height = height;

        return this;
    },

    setDisplaySize: function (width, height)
    {
        this.displayWidth = width;
        this.displayHeight = height;

        return this;
    }

};

module.exports = Size;


/***/ }),
/* 456 */
/***/ (function(module, exports) {

//  Texture Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 8; // 1000

var Texture = {

    texture: null,
    frame: null,

    setTexture: function (key, frame)
    {
        this.texture = this.scene.sys.textures.get(key);

        return this.setFrame(frame);
    },

    setFrame: function (frame)
    {
        this.frame = this.texture.get(frame);

        if (!this.frame.cutWidth || !this.frame.cutHeight)
        {
            this.renderFlags &= ~_FLAG;
        }
        else
        {
            this.renderFlags |= _FLAG;
        }

        return this;
    }

};

module.exports = Texture;


/***/ }),
/* 457 */
/***/ (function(module, exports) {


var GetColor = function (value)
{
    return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
};

var Tint = {

    //  0: topLeft, 1: topRight, 2: bottomLeft, 3: bottomRight
    _tintTL: 16777215,
    _tintTR: 16777215,
    _tintBL: 16777215,
    _tintBR: 16777215,

    clearTint: function ()
    {
        this.setTint(0xffffff);

        return this;
    },

    setTint: function (topLeft, topRight, bottomLeft, bottomRight)
    {
        if (topLeft === undefined) { topLeft = 0xffffff; }

        if (topRight === undefined)
        {
            topRight = topLeft;
            bottomLeft = topLeft;
            bottomRight = topLeft;
        }

        this._tintTL = GetColor(topLeft);
        this._tintTR = GetColor(topRight);
        this._tintBL = GetColor(bottomLeft);
        this._tintBR = GetColor(bottomRight);

        return this;
    },

    tintTopLeft: {

        get: function ()
        {
            return this._tintTL;
        },

        set: function (value)
        {
            this._tintTL = GetColor(value);
        }

    },

    tintTopRight: {

        get: function ()
        {
            return this._tintTR;
        },

        set: function (value)
        {
            this._tintTR = GetColor(value);
        }

    },

    tintBottomLeft: {

        get: function ()
        {
            return this._tintBL;
        },

        set: function (value)
        {
            this._tintBL = GetColor(value);
        }

    },

    tintBottomRight: {

        get: function ()
        {
            return this._tintBR;
        },

        set: function (value)
        {
            this._tintBR = GetColor(value);
        }

    },

    tint: {

        set: function (value)
        {
            this.setTint(value, value, value, value);
        }
    }

};

module.exports = Tint;


/***/ }),
/* 458 */
/***/ (function(module, exports) {

//  Default Game Object JSON export
//  Is extended further by Game Object specific implementations

var ToJSON = function (gameObject)
{
    var out = {
        name: gameObject.name,
        type: gameObject.type,
        x: gameObject.x,
        y: gameObject.y,
        depth: gameObject.depth,
        scale: {
            x: gameObject.scaleX,
            y: gameObject.scaleY
        },
        origin: {
            x: gameObject.originX,
            y: gameObject.originY
        },
        flipX: gameObject.flipX,
        flipY: gameObject.flipY,
        rotation: gameObject.rotation,
        alpha: gameObject.alpha,
        visible: gameObject.visible,
        scaleMode: gameObject.scaleMode,
        blendMode: gameObject.blendMode,
        textureKey: '',
        frameKey: '',
        data: {}
    };

    if (gameObject.texture)
    {
        out.textureKey = gameObject.texture.key;
        out.frameKey = gameObject.frame.name;
    }

    return out;
};

module.exports = ToJSON;


/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(13);
var WrapAngle = __webpack_require__(210);
var WrapAngleDegrees = __webpack_require__(211);

//  global bitmask flag for GameObject.renderMask (used by Scale)
var _FLAG = 4; // 0100

//  Transform Component

var Transform = {

    //  "private" properties
    _scaleX: 1,
    _scaleY: 1,
    _rotation: 0,
    _depth: 0,

    //  public properties / methods

    x: 0,
    y: 0,
    z: 0,
    w: 0,

    depth: {

        get: function ()
        {
            return this._depth;
        },

        set: function (value)
        {
            this.scene.sys.sortChildrenFlag = true;
            this._depth = value;
        }

    },

    scaleX: {

        get: function ()
        {
            return this._scaleX;
        },

        set: function (value)
        {
            this._scaleX = value;

            if (this._scaleX === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    scaleY: {

        get: function ()
        {
            return this._scaleY;
        },

        set: function (value)
        {
            this._scaleY = value;

            if (this._scaleY === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    angle: {

        get: function ()
        {
            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            //  value is in degrees
            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
        }
    },

    rotation: {

        get: function ()
        {
            return this._rotation;
        },

        set: function (value)
        {
            //  value is in radians
            this._rotation = WrapAngle(value);
        }
    },

    setPosition: function (x, y, z, w)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }
        if (z === undefined) { z = 0; }
        if (w === undefined) { w = 0; }

        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;

        return this;
    },

    setRotation: function (radians)
    {
        if (radians === undefined) { radians = 0; }

        this.rotation = radians;

        return this;
    },

    setAngle: function (degrees)
    {
        if (degrees === undefined) { degrees = 0; }

        this.angle = degrees;

        return this;
    },

    setScale: function (x, y)
    {
        if (x === undefined) { x = 1; }
        if (y === undefined) { y = x; }

        this.scaleX = x;
        this.scaleY = y;

        return this;
    },

    setZ: function (value)
    {
        if (value === undefined) { value = 0; }

        this.z = value;

        return this;
    },

    setW: function (value)
    {
        if (value === undefined) { value = 0; }

        this.w = value;

        return this;
    },

    setDepth: function (value)
    {
        if (value === undefined) { value = 0; }

        this.depth = value;

        return this;
    }

};

module.exports = Transform;


/***/ }),
/* 460 */
/***/ (function(module, exports) {


//  Visible Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 1; // 0001

var Visible = {

    _visible: true,

    visible: {

        get: function ()
        {
            return this._visible;
        },

        set: function (value)
        {
            if (value)
            {
                this._visible = true;
                this.renderFlags |= _FLAG;
            }
            else
            {
                this._visible = false;
                this.renderFlags &= ~_FLAG;
            }
        }

    },

    setVisible: function (value)
    {
        this.visible = value;

        return this;
    }
};

module.exports = Visible;


/***/ }),
/* 461 */
/***/ (function(module, exports) {

//  Gets or sets the amount of time in seconds between repeats.
//  For example, if repeat is 2 and repeatDelay is 1, the animation will play initially,
//  then wait for 1 second before it repeats, then play again, then wait 1 second again
//  before doing its final repeat.

var Delay = function (value)
{
    if (value === undefined)
    {
        return this._delay;
    }
    else
    {
        this._delay = value;

        return this;
    }
};

module.exports = Delay;


/***/ }),
/* 462 */
/***/ (function(module, exports) {

var DelayedPlay = function (delay, key, startFrame)
{
    this.play(key, startFrame);

    this.nextTick += (delay * 1000);

    return this;
};

module.exports = DelayedPlay;


/***/ }),
/* 463 */
/***/ (function(module, exports) {

var GetCurrentKey = function ()
{
    if (this.currentAnim)
    {
        return this.currentAnim.key;
    }
};

module.exports = GetCurrentKey;


/***/ }),
/* 464 */
/***/ (function(module, exports) {

var Load = function (key, startFrame)
{
    if (startFrame === undefined) { startFrame = 0; }

    if (this.isPlaying)
    {
        this.stop();
    }

    //  Load the new animation in
    this.animationManager.load(this, key, startFrame);

    return this;
};

module.exports = Load;


/***/ }),
/* 465 */
/***/ (function(module, exports) {

var Pause = function (atFrame)
{
    if (!this._paused)
    {
        this._paused = true;
        this._wasPlaying = this.isPlaying;
        this.isPlaying = false;
    }

    if (atFrame !== undefined)
    {
        this.updateFrame(atFrame);
    }
    
    return this;
};

module.exports = Pause;


/***/ }),
/* 466 */
/***/ (function(module, exports) {

var Paused = function (value)
{
    if (value !== undefined)
    {
        //  Setter
        if (value)
        {
            return this.pause();
        }
        else
        {
            return this.resume();
        }
    }
    else
    {
        return this._paused;
    }
};

module.exports = Paused;


/***/ }),
/* 467 */
/***/ (function(module, exports) {

var Play = function (key, ignoreIfPlaying, startFrame)
{
    if (ignoreIfPlaying === undefined) { ignoreIfPlaying = false; }
    if (startFrame === undefined) { startFrame = 0; }

    if (ignoreIfPlaying && this.isPlaying && this.currentAnim.key === key)
    {
        return this;
    }

    this.load(key, startFrame);

    var anim = this.currentAnim;

    //  Should give us 9,007,199,254,740,991 safe repeats
    this.repeatCounter = (this._repeat === -1) ? Number.MAX_SAFE_INTEGER : this._repeat;

    anim.getFirstTick(this);

    this.forward = true;
    this.isPlaying = true;
    this.pendingRepeat = false;

    if (anim.showOnStart)
    {
        this.parent.visible = true;
    }

    if (anim.onStart)
    {
        anim.onStart.apply(anim.callbackScope, this._callbackArgs.concat(anim.onStartParams));
    }

    return this;
};

module.exports = Play;


/***/ }),
/* 468 */
/***/ (function(module, exports) {

//  Value between 0 and 1. How far this animation is through, ignoring repeats and yoyos.
//  If the animation has a non-zero repeat defined, progress and totalProgress will be different
//  because progress doesn't include any repeats or repeatDelays whereas totalProgress does.
var Progress = function (value)
{
    if (value === undefined)
    {
        var p = this.currentFrame.progress;

        if (!this.forward)
        {
            p = 1 - p;
        }

        return p;
    }
    else
    {
        //  TODO: Set progress

        return this;
    }
};

module.exports = Progress;


/***/ }),
/* 469 */
/***/ (function(module, exports) {

var Remove = function (event)
{
    if (event === undefined) { event = this.currentAnim; }

    if (this.isPlaying && event.key === this.currentAnim.key)
    {
        this.stop();

        var sprite = this.parent;
        var frame = this.currentAnim.frames[0];

        this.currentFrame = frame;

        sprite.texture = frame.frame.texture;
        sprite.frame = frame.frame;
    }
};

module.exports = Remove;


/***/ }),
/* 470 */
/***/ (function(module, exports) {

//  Gets or sets the number of times that the animation should repeat
//  after its first iteration. For example, if repeat is 1, the animation will
//  play a total of twice (the initial play plus 1 repeat).
//  To repeat indefinitely, use -1. repeat should always be an integer.

var Repeat = function (value)
{
    if (value === undefined)
    {
        return this._repeat;
    }
    else
    {
        this._repeat = value;
        this.repeatCounter = 0;

        return this;
    }
};

module.exports = Repeat;


/***/ }),
/* 471 */
/***/ (function(module, exports) {

//  Gets or sets the amount of time in seconds between repeats.
//  For example, if repeat is 2 and repeatDelay is 1, the animation will play initially,
//  then wait for 1 second before it repeats, then play again, then wait 1 second again
//  before doing its final repeat.

var RepeatDelay = function (value)
{
    if (value === undefined)
    {
        return this._repeatDelay;
    }
    else
    {
        this._repeatDelay = value;

        return this;
    }
};

module.exports = RepeatDelay;


/***/ }),
/* 472 */
/***/ (function(module, exports) {

var Restart = function (includeDelay)
{
    if (includeDelay === undefined) { includeDelay = false; }

    this.currentAnim.getFirstTick(this, includeDelay);

    this.forward = true;
    this.isPlaying = true;
    this.pendingRepeat = false;
    this._paused = false;

    //  Set frame
    this.updateFrame(this.currentAnim.frames[0]);

    return this;
};

module.exports = Restart;


/***/ }),
/* 473 */
/***/ (function(module, exports) {

var Resume = function (fromFrame)
{
    if (this._paused)
    {
        this._paused = false;
        this.isPlaying = this._wasPlaying;
    }

    if (fromFrame !== undefined)
    {
        this.updateFrame(fromFrame);
    }
    
    return this;
};

module.exports = Resume;


/***/ }),
/* 474 */
/***/ (function(module, exports) {

var Stop = function (dispatchCallbacks)
{
    if (dispatchCallbacks === undefined) { dispatchCallbacks = false; }

    this.isPlaying = false;

    var anim = this.currentAnim;

    if (dispatchCallbacks && anim.onComplete)
    {
        anim.onComplete.apply(anim.callbackScope, this._callbackArgs.concat(anim.onCompleteParams));
    }

    return this;
};

module.exports = Stop;


/***/ }),
/* 475 */
/***/ (function(module, exports) {

var TimeScale = function (value)
{
    if (value === undefined)
    {
        return this._timeScale;
    }
    else
    {
        this._timeScale = value;

        return this;
    }
};

module.exports = TimeScale;


/***/ }),
/* 476 */
/***/ (function(module, exports) {

var TotalFrames = function ()
{
    return this.currentAnim.frames.length;
};

module.exports = TotalFrames;


/***/ }),
/* 477 */
/***/ (function(module, exports) {

//  Value between 0 and 1. How far this animation is through, including things like delays
//  repeats, custom frame durations, etc. If the animation is set to repeat -1 it can never
//  have a duration, therefore this will return -1.
var TotalProgres = function ()
{

};

module.exports = TotalProgres;


/***/ }),
/* 478 */
/***/ (function(module, exports) {

var Update = function (timestamp, delta)
{
    if (!this.isPlaying || this.currentAnim.paused)
    {
        return;
    }

    this.accumulator += delta * this._timeScale;

    if (this.accumulator >= this.nextTick)
    {
        this.currentAnim.setFrame(this);
    }
};

module.exports = Update;


/***/ }),
/* 479 */
/***/ (function(module, exports) {

var UpdateFrame = function (animationFrame)
{
    var sprite = this.parent;

    this.currentFrame = animationFrame;

    sprite.texture = animationFrame.frame.texture;
    sprite.frame = animationFrame.frame;

    if (this.isPlaying)
    {
        if (animationFrame.setAlpha)
        {
            sprite.alpha = animationFrame.alpha;
        }

        var anim = this.currentAnim;

        if (anim.onUpdate)
        {
            anim.onUpdate.apply(anim.callbackScope, this._updateParams);
        }

        if (animationFrame.onUpdate)
        {
            animationFrame.onUpdate(sprite, animationFrame);
        }
    }
};

module.exports = UpdateFrame;


/***/ }),
/* 480 */
/***/ (function(module, exports) {

var Yoyo = function (value)
{
    if (value === undefined)
    {
        return this._yoyo;
    }
    else
    {
        this._yoyo = value;

        return this;
    }
};

module.exports = Yoyo;


/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Animation.Frame.Components

//  Used by the GameObject Animation Controller, not the Animation itself

module.exports = {

    Delay: __webpack_require__(461),
    DelayedPlay: __webpack_require__(462),
    GetCurrentKey: __webpack_require__(463),
    Load: __webpack_require__(464),
    Pause: __webpack_require__(465),
    Paused: __webpack_require__(466),
    Play: __webpack_require__(467),
    Progress: __webpack_require__(468),
    Remove: __webpack_require__(469),
    Repeat: __webpack_require__(470),
    RepeatDelay: __webpack_require__(471),
    Restart: __webpack_require__(472),
    Resume: __webpack_require__(473),
    Stop: __webpack_require__(474),
    TimeScale: __webpack_require__(475),
    TotalFrames: __webpack_require__(476),
    TotalProgress: __webpack_require__(477),
    Update: __webpack_require__(478),
    UpdateFrame: __webpack_require__(479),
    Yoyo: __webpack_require__(480)
    
};


/***/ }),
/* 482 */
/***/ (function(module, exports) {

var EffectLayerCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{

};

module.exports = EffectLayerCanvasRenderer;
 

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var EffectLayer = __webpack_require__(80);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('effectLayer', function (config)
{
    var x = GetAdvancedValue(config, 'x', 0);
    var y = GetAdvancedValue(config, 'y', 0);
    var width = GetAdvancedValue(config, 'width', 512);
    var height = GetAdvancedValue(config, 'height', 512);
    var key = GetAdvancedValue(config, 'key', null);
    var fragmentShader = GetAdvancedValue(config, 'fragmentShader', '');

    var layer = new EffectLayer(this.scene, x, y, width, height, effectName, fragmentShader);

    BuildGameObject(this.scene, layer, config);

    return layer;
});


/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

var EffectLayer = __webpack_require__(80);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

if (true)
{
    GameObjectFactory.register('effectLayer', function (x, y, width, height, effectName, fragmentShader)
    {
        return this.displayList.add(new EffectLayer(this.scene, x, y, width, height, effectName, fragmentShader));
    });
}


/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(486);
}

if (true)
{
    renderCanvas = __webpack_require__(482);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var EffectLayerWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    renderer.effectRenderer.renderEffect(src, camera, src.renderTexture, src.width, src.height);
};

module.exports = EffectLayerWebGLRenderer;


/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var Particle = new Class({

    initialize:

    function Particle (x, y)
    {
        this.index = 0;
        this.x = x;
        this.y = y;
        this.velocityX = 0.0;
        this.velocityY = 0.0;
        this.rotation = 0.0;
        this.scaleX = 1.0;
        this.scaleY = 1.0;
        this.life = 1.0;
        this.color = 0xFFFFFFFF;
        this.lifeStep = 1.0;
        this.normLifeStep = 1.0;

        this.start = {
            tint: 0xFFFFFF,
            alpha: 1.0,
            scale: 1.0,
            angle: 0.0
        };

        this.end = {
            tint: 0xFFFFFF,
            alpha: 1.0,
            scale: 1.0,
            angle: 0.0
        };
    },

    reset: function (x, y)
    {
        this.index = 0;
        this.x = x;
        this.y = y;
        this.velocityX = 0.0;
        this.velocityY = 0.0;
        this.rotation = 0.0;
        this.scaleX = 1.0;
        this.scaleY = 1.0;
        this.life = 1.0;
        this.color = 0xFFFFFFFF;
        this.lifeStep = 1.0;
        this.normLifeStep = 1.0;

        this.start = {
            tint: 0xFFFFFF,
            alpha: 1.0,
            scale: 1.0,
            angle: 0.0
        };

        this.end = {
            tint: 0xFFFFFF,
            alpha: 1.0,
            scale: 1.0,
            angle: 0.0
        };
        return this;
    },

    isAlive: function ()
    {
        return this.lifeStep > 0;
    }

});

module.exports = Particle;


/***/ }),
/* 488 */
/***/ (function(module, exports) {

var ParticleEmitterCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{

};

module.exports = ParticleEmitterCanvasRenderer;


/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var ParticleEmitter = __webpack_require__(81);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('emitter', function (config)
{
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);

    var emitter = new ParticleEmitter(this.scene, 0, 0, key, frame);

    BuildGameObject(this.scene, emitter, config);

    return emitter;
});


/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

var ParticleEmitter = __webpack_require__(81);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('emitter', function (x, y, key, frame)
{
    var emitter = new ParticleEmitter(this.scene, x, y, key, frame);
    
    this.displayList.add(emitter);
    this.updateList.add(emitter);
    
    return emitter;
});


/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(492);
}

if (true)
{
    renderCanvas = __webpack_require__(488);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var ParticleEmitterWebGLRenderer = function (renderer, emitter, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== emitter.renderFlags || (emitter.cameraFilter > 0 && (emitter.cameraFilter & camera._id)))
    {
        return;
    }

    renderer.particleRenderer.renderEmitter(emitter, camera);
};

module.exports = ParticleEmitterWebGLRenderer;


/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

var GameObjectCreator = __webpack_require__(5);
var Graphics = __webpack_require__(83);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('graphics', function (config)
{
    return new Graphics(this.scene, config);
});


/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

var Graphics = __webpack_require__(83);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('graphics', function (config)
{
    return this.displayList.add(new Graphics(this.scene, config));
});


/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(496);

    //  Needed for Graphics.generateTexture
    renderCanvas = __webpack_require__(138);
}

if (true)
{
    renderCanvas = __webpack_require__(138);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);
var Commands = __webpack_require__(82);
var TransformMatrix = __webpack_require__(17);
var pathArray = [];
var cos = Math.cos;
var sin = Math.sin;
var sqrt = Math.sqrt;
var tempMatrix = new TransformMatrix();
var matrixStack = new Float32Array(6 * 1000);
var matrixStackLength = 0;
var currentMatrix = new TransformMatrix();

var Point = function (x, y, width, rgb, alpha)
{
    this.x = x;
    this.y = y;
    this.width = width;
    this.rgb = rgb;
    this.alpha = alpha;
};

var Path = function (x, y, width, rgb, alpha)
{
    this.points = [];
    this.pointsLength = 1;
    this.points[0] = new Point(x, y, width, rgb, alpha);
};

var GraphicsWebGLRenderer = function (renderer, gameObject, interpolationPercentage, camera, forceRenderTarget)
{
    if (GameObject.RENDER_MASK !== gameObject.renderFlags || (gameObject.cameraFilter > 0 && (gameObject.cameraFilter & camera._id)))
    {
        return;
    }

    var renderTarget = forceRenderTarget || gameObject.renderTarget;
    var shapeBatch = renderer.shapeBatch;
    var vertexDataBuffer = shapeBatch.vertexDataBuffer;
    var vertexBufferF32 = vertexDataBuffer.floatView;
    var vertexBufferU32 = vertexDataBuffer.uintView;
    var vertexOffset = 0;
    var cameraScrollX = camera.scrollX * gameObject.scrollFactorX;
    var cameraScrollY = camera.scrollY * gameObject.scrollFactorY;
    const srcX = gameObject.x - cameraScrollX;
    const srcY = gameObject.y - cameraScrollY;
    const srcScaleX = gameObject.scaleX;
    const srcScaleY = gameObject.scaleY;
    const srcRotation = -gameObject.rotation;
    var commandBuffer = gameObject.commandBuffer;
    var value;
    var lineAlpha = 1.0;
    var fillAlpha = 1.0;
    var lineColor = 0;
    var fillColor = 0;
    var lineWidth = 1.0;
    var cameraMatrix = camera.matrix.matrix;
    var lastPath = null;
    var iteration = 0;
    var iterStep = 0.01;
    var tx = 0;
    var ty = 0;
    var ta = 0;
    var x, y, radius, startAngle, endAngle, anticlockwise;
    var width, height, txw, tyh;
    var vertexCount = shapeBatch.vertexCount;
    var polygon = [];
    var x0, y0, x1, y1, x2, y2;
    var tx0, ty0, tx1, ty1, tx2, ty2;
    var v0, v1, v2;
    var polygonIndex;
    var path;
    var pathLength;
    var point;
    var maxVertices = shapeBatch.maxVertices;
    var translateX, translateY;
    var tempMatrixMatrix = tempMatrix.matrix;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var mva, mvb, mvc, mvd, mve, mvf;

    tempMatrix.applyITRS(srcX, srcY, srcRotation, srcScaleX, srcScaleY);

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    renderer.setRenderer(shapeBatch, null, renderTarget);

    for (var cmdIndex = 0, cmdLength = commandBuffer.length; cmdIndex < cmdLength; ++cmdIndex)
    {
        var cmd = commandBuffer[cmdIndex];

        switch(cmd)
        {
            case Commands.ARC:
                iteration = 0;
                x = commandBuffer[cmdIndex + 1];
                y = commandBuffer[cmdIndex + 2];
                radius = commandBuffer[cmdIndex + 3];
                startAngle = commandBuffer[cmdIndex + 4];
                endAngle = commandBuffer[cmdIndex + 5];
                anticlockwise = commandBuffer[cmdIndex + 6];
                
                while (iteration < 1)
                {
                    ta = (endAngle - startAngle) * iteration + startAngle;
                    tx = x + cos(ta) * radius;
                    ty = y + sin(ta) * radius;

                    if (iteration === 0)
                    {
                        lastPath = new Path(tx, ty, lineWidth, lineColor, lineAlpha);
                        pathArray.push(lastPath);
                    }
                    else
                    {
                        lastPath.points.push(new Point(tx, ty, lineWidth, lineColor, lineAlpha));
                    }

                    iteration += iterStep;
                }
                cmdIndex += 6;
                break;

            case Commands.LINE_STYLE:
                lineWidth = commandBuffer[cmdIndex + 1];
                lineColor = commandBuffer[cmdIndex + 2];
                lineAlpha = commandBuffer[cmdIndex + 3];
                cmdIndex += 3;
                break;

            case Commands.FILL_STYLE:
                fillColor = commandBuffer[cmdIndex + 1];
                fillAlpha = commandBuffer[cmdIndex + 2];
                cmdIndex += 2;
                break;

            case Commands.BEGIN_PATH:
                pathArray.length = 0;
                break;

            case Commands.CLOSE_PATH:
                if (lastPath !== null && lastPath.points.length > 0)
                {
                    var firstPoint = lastPath.points[0];
                    var lastPoint = lastPath.points[lastPath.points.length - 1];
                    lastPath.points.push(firstPoint);
                    lastPath = new Path(lastPoint.x, lastPoint.y, lastPoint.width, lastPoint.rgb, lastPoint.alpha);
                    pathArray.push(lastPath);
                }
                break;

            case Commands.FILL_PATH:
                for (var pathArrayIndex = 0, pathArrayLength = pathArray.length;
                    pathArrayIndex < pathArrayLength;
                    ++pathArrayIndex)
                {
                    shapeBatch.addFillPath(
                        /* Graphics Game Object Properties */
                        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                        /* Rectangle properties */ 
                        pathArray[pathArrayIndex].points,
                        fillColor,
                        fillAlpha,
                        /* Transform */
                        mva, mvb, mvc, mvd, mve, mvf,
                        currentMatrix
                    );
                }
                break;

            case Commands.STROKE_PATH:
                for (var pathArrayIndex = 0, pathArrayLength = pathArray.length;
                    pathArrayIndex < pathArrayLength;
                    ++pathArrayIndex)
                {
                    var path = pathArray[pathArrayIndex];
                    shapeBatch.addStrokePath(
                        /* Graphics Game Object Properties */
                        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                        /* Rectangle properties */ 
                        path.points,
                        lineWidth,
                        lineColor,
                        lineAlpha,
                        /* Transform */
                        mva, mvb, mvc, mvd, mve, mvf,
                        path === this._lastPath,
                        currentMatrix

                    );
                }
                break;
                
            case Commands.FILL_RECT:
                shapeBatch.addFillRect(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Rectangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3],
                    commandBuffer[cmdIndex + 4],
                    fillColor,
                    fillAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf,
                    currentMatrix

                );
             
                cmdIndex += 4;
                break;

            case Commands.FILL_TRIANGLE:
                shapeBatch.addFillTriangle(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Triangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3] - cameraScrollX,
                    commandBuffer[cmdIndex + 4] - cameraScrollY,
                    commandBuffer[cmdIndex + 5] - cameraScrollX,
                    commandBuffer[cmdIndex + 6] - cameraScrollY,
                    fillColor,
                    fillAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf,
                    currentMatrix

                );
                
                cmdIndex += 6;
                break;

            case Commands.STROKE_TRIANGLE:
                shapeBatch.addStrokeTriangle(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Triangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3] - cameraScrollX,
                    commandBuffer[cmdIndex + 4] - cameraScrollY,
                    commandBuffer[cmdIndex + 5] - cameraScrollX,
                    commandBuffer[cmdIndex + 6] - cameraScrollY,
                    lineWidth,
                    lineColor,
                    lineAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf,
                    currentMatrix

                );
                
                cmdIndex += 6;
                break

            case Commands.LINE_TO:
                if (lastPath !== null)
                {
                    lastPath.points.push(new Point(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2], lineWidth, lineColor, lineAlpha));
                }
                else
                {
                    lastPath = new Path(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2], lineWidth, lineColor, lineAlpha);
                    pathArray.push(lastPath);
                }
                cmdIndex += 2;
                break;

            case Commands.MOVE_TO:
                lastPath = new Path(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2], lineWidth, lineColor, lineAlpha);
                pathArray.push(lastPath);
                cmdIndex += 2;
                break;

            case Commands.LINE_FX_TO:
                if (lastPath !== null)
                {
                    lastPath.points.push(new Point(
                        commandBuffer[cmdIndex + 1], 
                        commandBuffer[cmdIndex + 2], 
                        commandBuffer[cmdIndex + 3],
                        commandBuffer[cmdIndex + 4],
                        commandBuffer[cmdIndex + 5]
                    ));
                }
                else
                {
                    lastPath = new Path(
                        commandBuffer[cmdIndex + 1], 
                        commandBuffer[cmdIndex + 2], 
                        commandBuffer[cmdIndex + 3],
                        commandBuffer[cmdIndex + 4],
                        commandBuffer[cmdIndex + 5]
                    );
                    pathArray.push(lastPath);
                }
                cmdIndex += 5;
                break;

            case Commands.MOVE_FX_TO:
                lastPath = new Path(
                    commandBuffer[cmdIndex + 1], 
                    commandBuffer[cmdIndex + 2], 
                    commandBuffer[cmdIndex + 3],
                    commandBuffer[cmdIndex + 4],
                    commandBuffer[cmdIndex + 5]
                );
                pathArray.push(lastPath);
                cmdIndex += 5;
                break;

            case Commands.SAVE:
                matrixStack[matrixStackLength + 0] = currentMatrix.matrix[0];
                matrixStack[matrixStackLength + 1] = currentMatrix.matrix[1];
                matrixStack[matrixStackLength + 2] = currentMatrix.matrix[2];
                matrixStack[matrixStackLength + 3] = currentMatrix.matrix[3];
                matrixStack[matrixStackLength + 4] = currentMatrix.matrix[4];
                matrixStack[matrixStackLength + 5] = currentMatrix.matrix[5];
                matrixStackLength += 6;
                break;

            case Commands.RESTORE:
                matrixStackLength -= 6;
                currentMatrix.matrix[0] = matrixStack[matrixStackLength + 0];
                currentMatrix.matrix[1] = matrixStack[matrixStackLength + 1];
                currentMatrix.matrix[2] = matrixStack[matrixStackLength + 2];
                currentMatrix.matrix[3] = matrixStack[matrixStackLength + 3];
                currentMatrix.matrix[4] = matrixStack[matrixStackLength + 4];
                currentMatrix.matrix[5] = matrixStack[matrixStackLength + 5];
                break;

            case Commands.TRANSLATE:
                currentMatrix.translate(
                    commandBuffer[cmdIndex + 1],
                    commandBuffer[cmdIndex + 2]
                );
                cmdIndex += 2;
                break;

            case Commands.SCALE:
                currentMatrix.scale(
                    commandBuffer[cmdIndex + 1],
                    commandBuffer[cmdIndex + 2]
                );
                cmdIndex += 2;
                break;

            case Commands.ROTATE:
                currentMatrix.rotate(
                    -commandBuffer[cmdIndex + 1]
                );
                cmdIndex += 1;
                break;

            default:
                console.error('Phaser: Invalid Graphics Command ID ' + cmd);
                break;
        }
    }
    currentMatrix.loadIdentity();
    pathArray.length = 0;
};

module.exports = GraphicsWebGLRenderer;


/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

var GameObjectCreator = __webpack_require__(5);
var Group = __webpack_require__(84);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('group', function (config)
{
    return new Group(this.scene, null, config);
});


/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

var Group = __webpack_require__(84);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('group', function (children, config)
{
    if (typeof children === 'object' && config === undefined)
    {
        config = children;
        children = [];
    }

    return new Group(this.scene, children, config);
});


/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var ImageCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    renderer.drawImage(src, camera);
};

module.exports = ImageCanvasRenderer;


/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var Image = __webpack_require__(56);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('image', function (config)
{
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);

    var image = new Image(this.scene, 0, 0, key, frame);

    BuildGameObject(this.scene, image, config);

    return image;
});


/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

var Image = __webpack_require__(56);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('image', function (x, y, key, frame)
{
    return this.displayList.add(new Image(this.scene, x, y, key, frame));
});


/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(503);
}

if (true)
{
    renderCanvas = __webpack_require__(499);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var ImageWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }
    
    renderer.spriteBatch.addSprite(src, camera);
};

module.exports = ImageWebGLRenderer;


/***/ }),
/* 504 */
/***/ (function(module, exports) {

module.exports = {

    MAX_LIGHTS: 10,
    DEFERRED_MAX_LIGHTS: 100

};


/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

var VertexBuffer = __webpack_require__(110);
var GameObject = __webpack_require__(1);

var DeferredRenderer = function (renderer, lightLayer, interpolationPercentage, camera)
{
    var spriteList = lightLayer.sprites;
    var length = spriteList.length;
    var batch = renderer.spriteBatch;
    var gl = renderer.gl;

    if (GameObject.RENDER_MASK !== lightLayer.renderFlags || length === 0 || (lightLayer.cameraFilter > 0 && (lightLayer.cameraFilter & camera._id)))
    {
        return;
    }

    if (renderer.currentRenderer !== null)
    {
        renderer.currentRenderer.flush();
    }

    batch.bind(lightLayer.gBufferShaderPass);
    batch.indexBufferObject.bind();
    lightLayer.updateLights(renderer, camera, lightLayer.lightPassShader);

    gl.bindFramebuffer(gl.FRAMEBUFFER, lightLayer.gBufferFbo);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    for (var index = 0; index < length; ++index)
    {
        var spriteNormalPair = spriteList[index];
        var gameObject = spriteNormalPair.spriteRef;
        
        /* Inlined function of add sprite modified. */
        {
            var tempMatrix = batch.tempMatrix;
            var frame = gameObject.frame;
            var forceFlipY = (frame.texture.source[frame.sourceIndex].glTexture.isRenderTexture ? true : false);
            var flipX = gameObject.flipX;
            var flipY = gameObject.flipY ^ forceFlipY;
            var vertexDataBuffer = batch.vertexDataBuffer;
            var vertexBufferObjectF32 = vertexDataBuffer.floatView;
            var vertexBufferObjectU32 = vertexDataBuffer.uintView;
            var vertexOffset = 0;
            var uvs = frame.uvs;
            var width = frame.width * (flipX ? -1 : 1);
            var height = frame.height * (flipY ? -1 : 1);
            var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
            var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
            var scaleX = gameObject.scaleX;
            var scaleY = gameObject.scaleY;
            var rotation = -gameObject.rotation;
            var tempMatrixMatrix = tempMatrix.matrix;
            var x = -gameObject.displayOriginX + frame.x + ((frame.width) * (flipX ? 1 : 0.0));
            var y = -gameObject.displayOriginY + frame.y + ((frame.height) * (flipY ? 1 : 0.0));
            var xw = x + width;
            var yh = y + height;
            var cameraMatrix = camera.matrix.matrix;
            var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
            var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
            var alphaTL = gameObject._alphaTL;
            var alphaTR = gameObject._alphaTR;
            var alphaBL = gameObject._alphaBL;
            var alphaBR = gameObject._alphaBR;
            var tintTL = gameObject._tintTL;
            var tintTR = gameObject._tintTR;
            var tintBL = gameObject._tintBL;
            var tintBR = gameObject._tintBR;

            tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

            sra = tempMatrixMatrix[0];
            srb = tempMatrixMatrix[1];
            src = tempMatrixMatrix[2];
            srd = tempMatrixMatrix[3];
            sre = tempMatrixMatrix[4];
            srf = tempMatrixMatrix[5];

            cma = cameraMatrix[0];
            cmb = cameraMatrix[1];
            cmc = cameraMatrix[2];
            cmd = cameraMatrix[3];
            cme = cameraMatrix[4];
            cmf = cameraMatrix[5];

            mva = sra * cma + srb * cmc;
            mvb = sra * cmb + srb * cmd;
            mvc = src * cma + srd * cmc;
            mvd = src * cmb + srd * cmd;
            mve = sre * cma + srf * cmc + cme;
            mvf = sre * cmb + srf * cmd + cmf;
            
            tx0 = x * mva + y * mvc + mve;
            ty0 = x * mvb + y * mvd + mvf;
            tx1 = x * mva + yh * mvc + mve;
            ty1 = x * mvb + yh * mvd + mvf;
            tx2 = xw * mva + yh * mvc + mve;
            ty2 = xw * mvb + yh * mvd + mvf;
            tx3 = xw * mva + y * mvc + mve;
            ty3 = xw * mvb + y * mvd + mvf;

    
            if (renderer.currentTexture[0] !== frame.texture.source[frame.sourceIndex].glTexture ||
                renderer.currentTexture[1] !== spriteNormalPair.normalTextureRef.source[spriteNormalPair.spriteRef.frame.sourceIndex].glTexture ||
                batch.shouldFlush())
            {
                batch.flush(lightLayer.gBufferShaderPass, lightLayer.renderTarget);
                renderer.setTexture(frame.texture.source[frame.sourceIndex].glTexture, 0);
                renderer.setTexture(spriteNormalPair.normalTextureRef.source[spriteNormalPair.spriteRef.frame.sourceIndex].glTexture, 1);
            }

            batch.drawIndexed = true;
            batch.drawingMesh = false;
            vertexOffset = vertexDataBuffer.allocate(24);
            batch.elementCount += 6;
            
            //  Top Left
            vertexBufferObjectF32[vertexOffset++] = tx0;
            vertexBufferObjectF32[vertexOffset++] = ty0;
            vertexBufferObjectF32[vertexOffset++] = uvs.x0;
            vertexBufferObjectF32[vertexOffset++] = uvs.y0;
            vertexBufferObjectU32[vertexOffset++] = tintTL;
            vertexBufferObjectF32[vertexOffset++] = alphaTL;

            //  Bottom Left
            vertexBufferObjectF32[vertexOffset++] = tx1;
            vertexBufferObjectF32[vertexOffset++] = ty1;
            vertexBufferObjectF32[vertexOffset++] = uvs.x1;
            vertexBufferObjectF32[vertexOffset++] = uvs.y1;
            vertexBufferObjectU32[vertexOffset++] = tintBL;
            vertexBufferObjectF32[vertexOffset++] = alphaBL;

            //  Bottom Right
            vertexBufferObjectF32[vertexOffset++] = tx2;
            vertexBufferObjectF32[vertexOffset++] = ty2;
            vertexBufferObjectF32[vertexOffset++] = uvs.x2;
            vertexBufferObjectF32[vertexOffset++] = uvs.y2;
            vertexBufferObjectU32[vertexOffset++] = tintBR;
            vertexBufferObjectF32[vertexOffset++] = alphaBR;

            //  Top Right
            vertexBufferObjectF32[vertexOffset++] = tx3;
            vertexBufferObjectF32[vertexOffset++] = ty3;
            vertexBufferObjectF32[vertexOffset++] = uvs.x3;
            vertexBufferObjectF32[vertexOffset++] = uvs.y3;
            vertexBufferObjectU32[vertexOffset++] = tintTR;
            vertexBufferObjectF32[vertexOffset++] = alphaTR;
        }
    }

    batch.flush(lightLayer.gBufferShaderPass, lightLayer.renderTarget);
    renderer.setTexture({texture: lightLayer.gBufferColorTex}, 0);
    renderer.setTexture({texture: lightLayer.gBufferNormalTex}, 1);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    lightLayer.lightPassShader.bind();
    gl.bindBuffer(gl.ARRAY_BUFFER, lightLayer.lightPassVBO);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, Float32Array.BYTES_PER_ELEMENT, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    VertexBuffer.SetDirty();
    batch.bind();
};

module.exports = DeferredRenderer;


/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var Light = new Class({

    initialize:

    function Light (x, y, z, radius, r, g, b, attenuation)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.radius = radius;
        this.r = r;
        this.g = g;
        this.b = b;
        this.attenuation = attenuation;
        this.scrollFactorX = 1.0;
        this.scrollFactorY = 1.0;
    },

    set: function (x, y, z, radius, r, g, b, attenuation)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.radius = radius;
        this.r = r;
        this.g = g;
        this.b = b;
        this.attenuation = attenuation;
        this.scrollFactorX = 1.0;
        this.scrollFactorY = 1.0;
    }

});

module.exports = Light;


/***/ }),
/* 507 */
/***/ (function(module, exports) {

var LightLayerCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{

};

module.exports = LightLayerCanvasRenderer;
 

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var LightLayer = __webpack_require__(85);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('lightLayer', function (config)
{
    var pass = new LightLayer(this.scene);

    BuildGameObject(this.scene, pass, config);

    return pass;
});


/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

var LightLayer = __webpack_require__(85);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

if (true)
{
    GameObjectFactory.register('lightLayer', function ()
    {
        return this.displayList.add(new LightLayer(this.scene));
    });
}


/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(511);
}

if (true)
{
    renderCanvas = __webpack_require__(507);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

var WebGLSupportedExtensions = __webpack_require__(229);

module.exports = (function () {
    if (WebGLSupportedExtensions.has('WEBGL_draw_buffers'))
    {
        return __webpack_require__(505);
    }
    else
    {
        return __webpack_require__(139);
    }
})();

 

/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var SpriteNormalPair = new Class({

    initialize:

    function SpriteNormalPair (sprite, normalTexture)
    {
        this.spriteRef = sprite;
        this.normalTextureRef = normalTexture;
    },

    set: function (sprite, normalTexture)
    {
        this.spriteRef = sprite;
        this.normalTextureRef = normalTexture;
    }

});

module.exports = SpriteNormalPair;


/***/ }),
/* 513 */
/***/ (function(module, exports) {

var MeshCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
};

module.exports = MeshCanvasRenderer;


/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var GetValue = __webpack_require__(4);
var Mesh = __webpack_require__(57);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('mesh', function (config)
{
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);
    var vertices = GetValue(config, 'vertices', []);
    var indices = GetValue(config, 'indices', []);
    var colors = GetValue(config, 'colors', []);
    var alphas = GetValue(config, 'alphas', []);
    var uv = GetValue(config, 'uv', []);

    var mesh = new Mesh(this.scene, 0, 0, vertices, uv, indices, colors, alphas, key, frame);

    BuildGameObject(this.scene, mesh, config);

    return mesh;
});


/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

var Mesh = __webpack_require__(57);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

if (true)
{
    GameObjectFactory.register('mesh', function (x, y, vertices, uv, key, frame)
    {
        return this.displayList.add(new Mesh(this.scene, x, y, vertices, uv, key, frame));
    });
}


/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(517);
}

if (true)
{
    renderCanvas = __webpack_require__(513);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var MeshWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    if (src.indices.length > 0)
    {
        renderer.spriteBatch.addMeshIndexed(src, camera);
    }
    else
    {
        renderer.spriteBatch.addMesh(src, camera);
    }
};

module.exports = MeshWebGLRenderer;


/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.GameObjects.SpritePool

var Class = __webpack_require__(0);
var Sprite = __webpack_require__(31);
var ObjectPool = __webpack_require__(86);

//  An Object Pool

var SpritePool = new Class({

    Extends: ObjectPool,

    initialize:

    function SpritePool (manager, maxSize, quantity, key, frame)
    {
        ObjectPool.call(this, manager, Sprite, maxSize, this.makeSprite, this);

        this.defaultKey = key;

        this.defaultFrame = frame;
    },

    makeSprite: function ()
    {
        var gameObject = new this.classType(this.scene, 0, 0, this.defaultKey, this.defaultFrame);

        this.displayList.add(gameObject);
        this.updateList.add(gameObject);

        gameObject.setActive(false);
        gameObject.setVisible(false);

        return gameObject;
    },

    get: function (x, y)
    {
        var gameObject = this.getFreeGameObject();

        gameObject.setPosition(x, y);

        return gameObject;
    }

});

module.exports = SpritePool;


/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var Quad = __webpack_require__(87);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('quad', function (config)
{
    var x = GetAdvancedValue(config, 'x', 0);
    var y = GetAdvancedValue(config, 'y', 0);
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);

    var quad = new Quad(this.scene, x, y, key, frame);

    BuildGameObject(this.scene, quad, config);

    return quad;
});


/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

var Quad = __webpack_require__(87);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

if (true)
{
    GameObjectFactory.register('quad', function (x, y, key, frame)
    {
        return this.displayList.add(new Quad(this.scene, x, y, key, frame));
    });
}


/***/ }),
/* 521 */
/***/ (function(module, exports) {

var RenderPassCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{

};

module.exports = RenderPassCanvasRenderer;
 

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var RenderPass = __webpack_require__(88);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('renderPass', function (config)
{
    var x = GetAdvancedValue(config, 'x', 0);
    var y = GetAdvancedValue(config, 'y', 0);
    var width = GetAdvancedValue(config, 'width', 512);
    var height = GetAdvancedValue(config, 'height', 512);
    var shaderName = GetAdvancedValue(config, 'shaderName', '');
    var fragmentShader = GetAdvancedValue(config, 'fragmentShader', '');

    var pass = new RenderPass(this.scene, x, y, width, height, shaderName, fragmentShader);

    BuildGameObject(this.scene, pass, config);

    return pass;
});


/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

var RenderPass = __webpack_require__(88);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

if (true)
{
    GameObjectFactory.register('renderPass', function (x, y, width, height, shaderName, fragmentShader)
    {
        return this.displayList.add(new RenderPass(this.scene, x, y, width, height, shaderName, fragmentShader));
    });
}


/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(525);
}

if (true)
{
    renderCanvas = __webpack_require__(521);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var RenderPassWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    renderer.spriteBatch.addSpriteTexture(src, camera, src.renderTexture, src.width, src.height);
};

module.exports = RenderPassWebGLRenderer;


/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var BuildGameObjectAnimation = __webpack_require__(135);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var Sprite3D = __webpack_require__(58);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('sprite3D', function (config)
{
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);

    var sprite = new Sprite3D(this.scene, 0, 0, key, frame);

    BuildGameObject(this.scene, sprite, config);

    //  Sprite specific config options:

    BuildGameObjectAnimation(sprite, config);

    //  Physics, Input, etc to follow ...

    return sprite;
});


/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

var Sprite3D = __webpack_require__(58);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('sprite3D', function (x, y, z, key, frame)
{
    var sprite = new Sprite3D(this.scene, x, y, z, key, frame);

    this.displayList.add(sprite.gameObject);
    this.updateList.add(sprite.gameObject);

    return sprite;
});


/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var SpriteCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    renderer.drawImage(src, camera);
};

module.exports = SpriteCanvasRenderer;


/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var BuildGameObjectAnimation = __webpack_require__(135);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var Sprite = __webpack_require__(31);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('sprite', function (config)
{
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);

    var sprite = new Sprite(this.scene, 0, 0, key, frame);

    BuildGameObject(this.scene, sprite, config);

    //  Sprite specific config options:

    BuildGameObjectAnimation(sprite, config);

    //  Physics, Input, etc to follow ...

    return sprite;
});


/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

var Sprite = __webpack_require__(31);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('sprite', function (x, y, key, frame)
{
    var sprite = new Sprite(this.scene, x, y, key, frame);

    this.displayList.add(sprite);
    this.updateList.add(sprite);

    return sprite;
});


/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(532);
}

if (true)
{
    renderCanvas = __webpack_require__(528);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var SpriteWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    renderer.spriteBatch.addSprite(src, camera);
};

module.exports = SpriteWebGLRenderer;


/***/ }),
/* 533 */
/***/ (function(module, exports) {


var GetTextSize = function (text, size, lines)
{
    var canvas = text.canvas;
    var context = text.context;
    var style = text.style;

    var lineWidths = [];
    var maxLineWidth = 0;
    var drawnLines = lines.length;
    
    if (style.maxLines > 0 && style.maxLines < lines.length)
    {
        drawnLines = style.maxLines;
    }

    style.syncFont(canvas, context);

    //  Text Width

    for (var i = 0; i < drawnLines; i++)
    {
        var lineWidth = style.strokeThickness;

        lineWidth += context.measureText(lines[i]).width;

        // Adjust for wrapped text
        if (style.wordWrap)
        {
            lineWidth -= context.measureText(' ').width;
        }

        lineWidths[i] = Math.ceil(lineWidth);
        maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
    }

    //  Text Height

    var lineHeight = size.fontSize + style.strokeThickness;
    var height = lineHeight * drawnLines;
    var lineSpacing = text._lineSpacing || 0;

    if (lineSpacing < 0 && Math.abs(lineSpacing) > lineHeight)
    {
        lineSpacing = -lineHeight;
    }

    //  Adjust for line spacing
    if (lineSpacing !== 0)
    {
        height += (lineSpacing > 0) ? lineSpacing * lines.length : lineSpacing * (lines.length - 1);
    }

    return {
        width: maxLineWidth,
        height: height,
        lines: drawnLines,
        lineWidths: lineWidths,
        lineSpacing: lineSpacing,
        lineHeight: lineHeight
    };
};

module.exports = GetTextSize;


/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(15);

/**
* Calculates the ascent, descent and fontSize of a given font style.
*/
var MeasureText = function (textStyle, testString)
{
    if (testString === undefined) { testString = '|Mqgy'; }

    // @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
    var canvas = CanvasPool.create(this);

    // @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
    var context = canvas.getContext('2d');

    textStyle.syncFont(canvas, context);

    var width = Math.ceil(context.measureText(testString).width * 1.2);
    var baseline = width;
    var height = 2 * baseline;

    baseline = baseline * 1.4 | 0;

    canvas.width = width;
    canvas.height = height;

    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);

    context.font = textStyle.font;

    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(testString, 0, baseline);

    var output = {
        ascent: 0,
        descent: 0,
        fontSize: 0
    };

    if (!context.getImageData(0, 0, width, height))
    {
        output.ascent = baseline;
        output.descent = baseline + 6;
        output.fontSize = output.ascent + output.descent;

        CanvasPool.remove(canvas);

        return output;
    }

    var imagedata = context.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i;
    var j;
    var idx = 0;
    var stop = false;

    // ascent. scan from top to bottom until we find a non red pixel
    for (i = 0; i < baseline; i++)
    {
        for (j = 0; j < line; j += 4)
        {
            if (imagedata[idx + j] !== 255)
            {
                stop = true;
                break;
            }
        }

        if (!stop)
        {
            idx += line;
        }
        else
        {
            break;
        }
    }

    output.ascent = baseline - i;

    idx = pixels - line;
    stop = false;

    // descent. scan from bottom to top until we find a non red pixel
    for (i = height; i > baseline; i--)
    {
        for (j = 0; j < line; j += 4)
        {
            if (imagedata[idx + j] !== 255)
            {
                stop = true;
                break;
            }
        }

        if (!stop)
        {
            idx -= line;
        }
        else
        {
            break;
        }
    }

    output.descent = (i - baseline);
    output.fontSize = output.ascent + output.descent;

    CanvasPool.remove(canvas);

    return output;
};

module.exports = MeasureText;


/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GetValue = __webpack_require__(4);
var GetAdvancedValue = __webpack_require__(7);
var MeasureText = __webpack_require__(534);

//  Key: [ Object Key, Default Value ]

var propertyMap = {
    font: [ 'font', '16px Courier' ],
    backgroundColor: [ 'backgroundColor', null ],
    fill: [ 'fill', '#fff' ],
    stroke: [ 'stroke', '#fff' ],
    strokeThickness: [ 'strokeThickness', 0 ],
    shadowOffsetX: [ 'shadow.offsetX', 0 ],
    shadowOffsetY: [ 'shadow.offsetY', 0 ],
    shadowColor: [ 'shadow.color', '#000' ],
    shadowBlur: [ 'shadow.blur', 0 ],
    shadowStroke: [ 'shadow.stroke', false ],
    shadowFill: [ 'shadow.fill', false ],
    align: [ 'align', 'left' ],
    maxLines: [ 'maxLines', 0 ],
    fixedWidth: [ 'fixedWidth', false ],
    fixedHeight: [ 'fixedHeight', false ],
    rtl: [ 'rtl', false ]
};

var TextStyle = new Class({

    initialize:

    function TextStyle (text, style)
    {
        this.parent = text;

        this.font;
        this.backgroundColor;
        this.fill;
        this.stroke;
        this.strokeThickness;
        this.shadowOffsetX;
        this.shadowOffsetY;
        this.shadowColor;
        this.shadowBlur;
        this.shadowStroke;
        this.shadowFill;
        this.align;
        this.maxLines;
        this.fixedWidth;
        this.fixedHeight;
        this.rtl;

        //  Set to defaults
        this.reset();

        if (style)
        {
            for (var key in propertyMap)
            {
                this[key] = GetAdvancedValue(style, propertyMap[key][0], this[key]);
            }
        }

        var metrics = GetValue(style, 'metrics', false);

        //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning
        //  Doing this is un-done if you then change the font of this TextStyle after creation
        if (metrics)
        {
            this.metrics = {
                ascent: GetValue(metrics, 'ascent', 0),
                descent: GetValue(metrics, 'descent', 0),
                fontSize: GetValue(metrics, 'fontSize', 0)
            };
        }
        else
        {
            this.metrics = MeasureText(this);
        }
    },

    reset: function ()
    {
        for (var key in propertyMap)
        {
            this[key] = propertyMap[key][1];
        }

        return this;
    },

    syncFont: function (canvas, context)
    {
        if (this.rtl)
        {
            canvas.dir = 'rtl';
        }

        context.font = this.font;
        context.textBaseline = 'alphabetic';

        context.fillStyle = this.fill;
        context.strokeStyle = this.stroke;

        context.lineWidth = this.strokeThickness;
        context.lineCap = 'round';
        context.lineJoin = 'round';
    },

    syncShadow: function (context, enabled)
    {
        if (enabled)
        {
            context.shadowOffsetX = this.shadowOffsetX;
            context.shadowOffsetY = this.shadowOffsetY;
            context.shadowColor = this.shadowColor;
            context.shadowBlur = this.shadowBlur;
        }
        else
        {
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
            context.shadowColor = 0;
            context.shadowBlur = 0;
        }
    },

    update: function (recalculateMetrics)
    {
        if (recalculateMetrics)
        {
            this.metrics = MeasureText(this);
        }

        return this.parent.updateText();
    },

    setStyle: function (style)
    {
        for (var key in propertyMap)
        {
            this[key] = GetAdvancedValue(style, propertyMap[key][0], this[key]);
        }

        return this.update(true);
    },

    setFont: function (font)
    {
        this.font = font;

        return this.update(true);
    },

    setFixedSize: function (width, height)
    {
        this.fixedWidth = width;
        this.fixedHeight = height;

        if (width)
        {
            this.text.width = width;
        }

        if (height)
        {
            this.text.height = height;
        }

        return this.update(false);
    },

    setBackgroundColor: function (color)
    {
        this.backgroundColor = color;

        return this.update(false);
    },

    setFill: function (color)
    {
        this.fill = color;

        return this.update(false);
    },

    setStroke: function (color, thickness)
    {
        if (color === undefined)
        {
            //  Reset the stroke to zero (disabling it)
            this.strokeThickness = 0;
        }
        else
        {
            if (thickness === undefined) { thickness = this.strokeThickness; }

            this.stroke = color;
            this.strokeThickness = thickness;
        }

        return this.update(true);
    },

    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (color === undefined) { color = '#000'; }
        if (blur === undefined) { blur = 0; }
        if (shadowStroke === undefined) { shadowStroke = false; }
        if (shadowFill === undefined) { shadowFill = true; }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;
        this.shadowColor = color;
        this.shadowBlur = blur;
        this.shadowStroke = shadowStroke;
        this.shadowFill = shadowFill;

        return this.update(false);
    },

    setShadowOffset: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;

        return this.update(false);
    },

    setShadowColor: function (color)
    {
        if (color === undefined) { color = '#000'; }

        this.shadowColor = color;

        return this.update(false);
    },

    setShadowBlur: function (blur)
    {
        if (blur === undefined) { blur = 0; }

        this.shadowBlur = blur;

        return this.update(false);
    },

    setShadowStroke: function (enabled)
    {
        this.shadowStroke = enabled;

        return this.update(false);
    },

    setShadowFill: function (enabled)
    {
        this.shadowFill = enabled;

        return this.update(false);
    },

    setAlign: function (align)
    {
        if (align === undefined) { align = 'left'; }

        this.align = align;

        return this.update(false);
    },

    setMaxLines: function (max)
    {
        if (max === undefined) { max = 0; }

        this.maxLines = max;

        return this.update(false);
    },

    getTextMetrics: function ()
    {
        var metrics = this.metrics;

        return {
            ascent: metrics.ascent,
            descent: metrics.descent,
            fontSize: metrics.fontSize
        };
    },

    toJSON: function ()
    {
        var output = {};

        for (var key in propertyMap)
        {
            output[key] = this[key];
        }

        output.metrics = this.getTextMetrics();

        return output;
    },

    destroy: function ()
    {
        this.parent = undefined;
    }

});

module.exports = TextStyle;


/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var TextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }
    
    var ctx = renderer.currentContext;

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    var canvas = src.canvas;

    ctx.save();
    ctx.translate(src.x - camera.scrollX * src.scrollFactorX, src.y - camera.scrollY * src.scrollFactorY);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);
    ctx.translate(canvas.width * (src.flipX ? 1 : 0), canvas.height * (src.flipY ? 1 : 0));
    ctx.scale(src.flipX ? -1 : 1, src.flipY ? -1 : 1);
    ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, -src.displayOriginX, -src.displayOriginY, canvas.width, canvas.height);
    ctx.restore();
};

module.exports = TextCanvasRenderer;


/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var Text = __webpack_require__(89);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('text', function (config)
{
    // style Object = {
    //     font: [ 'font', '16px Courier' ],
    //     backgroundColor: [ 'backgroundColor', null ],
    //     fill: [ 'fill', '#fff' ],
    //     stroke: [ 'stroke', '#fff' ],
    //     strokeThickness: [ 'strokeThickness', 0 ],
    //     shadowOffsetX: [ 'shadow.offsetX', 0 ],
    //     shadowOffsetY: [ 'shadow.offsetY', 0 ],
    //     shadowColor: [ 'shadow.color', '#000' ],
    //     shadowBlur: [ 'shadow.blur', 0 ],
    //     shadowStroke: [ 'shadow.stroke', false ],
    //     shadowFill: [ 'shadow.fill', false ],
    //     align: [ 'align', 'left' ],
    //     maxLines: [ 'maxLines', 0 ],
    //     fixedWidth: [ 'fixedWidth', false ],
    //     fixedHeight: [ 'fixedHeight', false ],
    //     rtl: [ 'rtl', false ]
    // }

    var content = GetAdvancedValue(config, 'text', '');
    var style = GetAdvancedValue(config, 'style', null);

    var text = new Text(this.scene, 0, 0, content, style);

    BuildGameObject(this.scene, text, config);

    //  Text specific config options:

    text.autoRound = GetAdvancedValue(config, 'autoRound', true);
    text.resolution = GetAdvancedValue(config, 'resolution', 1);

    //  Padding
    //  Either: { padding: 2 } or { padding: { x: 2, y: 2 }}

    var padding = GetAdvancedValue(config, 'padding', null);

    if (typeof padding === 'number')
    {
        text.padding.x = padding;
        text.padding.y = padding;
    }
    else if (padding !== null)
    {
        text.padding.x = GetAdvancedValue(padding, 'x', 1);
        text.padding.y = GetAdvancedValue(padding, 'y', 1);
    }

    text.updateText();

    return text;
});


/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

var Text = __webpack_require__(89);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('text', function (x, y, text, style)
{
    return this.displayList.add(new Text(this.scene, x, y, text, style));
});


/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(540);
}

if (true)
{
    renderCanvas = __webpack_require__(536);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var TextWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)) || src.text === '')
    {
        return;
    }
    
    if (src.dirty)
    {
        src.canvasTexture = renderer.uploadCanvasToGPU(src.canvas, src.canvasTexture, true);
        src.dirty = false;
    }
    
    renderer.spriteBatch.addSpriteTexture(src, camera, src.canvasTexture, src.canvas.width, src.canvas.height);
};

module.exports = TextWebGLRenderer;


/***/ }),
/* 541 */
/***/ (function(module, exports) {

function Tile (properties)
{
    this.index = properties.index;
    this.id = properties.id;
    this.x = properties.x;
    this.y = properties.y;
    this.width = properties.width;
    this.height = properties.height;
    this.frameX = properties.frameX;
    this.frameY = properties.frameY;
    this.frameWidth = properties.frameWidth;
    this.frameHeight = properties.frameHeight;
    this.alpha = 1.0;
    this.tint = 0xFFFFFF;
    this.visible = true;
    this.textureWidth = properties.textureWidth;
    this.textureHeight = properties.textureHeight;
    this.border = properties.border;
    this.center = properties.center; 
}

Tile.prototype.setId = function (id)
{
    var tileId = this.id = id;
    var tileWidth = this.width;
    var tileHeight = this.height;
    var setWidth = this.textureWidth / tileWidth;
    var tileWidthBorder = (tileWidth + this.border * 2);
    var tileHeightBorder = (tileHeight + this.border * 2);
    var halfTileWidth = tileWidthBorder * 0.5;
    var halfTileHeight = tileHeightBorder * 0.5;
    if (!this.center)
    {
        halfTileWidth = 0;
        halfTileHeight = 0;
    }
    var rectx = (((tileId % setWidth)|0) * tileWidthBorder) + halfTileWidth;
    var recty = (((tileId / setWidth)|0) * tileHeightBorder) + halfTileHeight;

    this.frameX = rectx;
    this.frameY = recty;
};

module.exports = Tile;


/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var TilemapCanvasRenderer = function (renderer, gameObject, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== gameObject.renderFlags || (gameObject.cameraFilter > 0 && (gameObject.cameraFilter & camera._id)))
    {
        return;
    }

    gameObject.cull(camera);

    var tiles = gameObject.culledTiles;
    var tileCount = tiles.length;
    var image = gameObject.frame.source.image;
    var scrollFactorX = gameObject.scrollFactorX;
    var scrollFactorY = gameObject.scrollFactorY;
    var alpha = gameObject.alpha;
    var tx = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
    var ty = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
    var ctx = renderer.gameContext;

    ctx.save();
    ctx.translate(tx, ty);
    ctx.rotate(gameObject.rotation);
    ctx.scale(gameObject.scaleX, gameObject.scaleY);
    ctx.scale(gameObject.flipX ? -1 : 1, gameObject.flipY ? -1 : 1);

    for (var index = 0; index < tileCount; ++index)
    {
        var tile = tiles[index];

        ctx.drawImage(
            image, 
            tile.frameX, tile.frameY, 
            tile.frameWidth, tile.frameHeight, 
            tile.x, tile.y, 
            tile.frameWidth, tile.frameHeight
        );
    }

    ctx.restore();
};

module.exports = TilemapCanvasRenderer;


/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetValue = __webpack_require__(4);
var Tilemap = __webpack_require__(90);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('tilemap', function (config)
{
    var mapData = GetValue(config, 'map.data', null);
    var mapWidth = GetValue(config, 'map.width', 1);
    var mapHeight = GetValue(config, 'map.height', 1);

    var x = GetValue(config, 'x', 0);
    var y = GetValue(config, 'y', 0);

    var tileWidth = GetValue(config, 'tile.width', 16);
    var tileHeight = GetValue(config, 'tile.height', 16);
    var tileTexture = GetValue(config, 'tile.texture', null);
    var tileFrame = GetValue(config, 'tile.frame', null);
    var tileBorder = GetValue(config, 'tile.border', 0);

    var map = new Tilemap(this.scene, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, tileBorder, tileTexture, tileFrame);

    BuildGameObject(this.scene, map, config);

    return map;
});


/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

var Tilemap = __webpack_require__(90);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('tilemap', function (mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, tileBorder, texture, frame)
{
    return this.displayList.add(new Tilemap(this.scene, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, tileBorder, texture, frame));
});


/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(546);
}

if (true)
{
    renderCanvas = __webpack_require__(542);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var TilemapWebGLRenderer = function (renderer, gameObject, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== gameObject.renderFlags || (gameObject.cameraFilter > 0 && (gameObject.cameraFilter & camera._id)))
    {
        return;
    }

    gameObject.cull(camera);

    var renderTiles = gameObject.culledTiles;
    var length = renderTiles.length;
    var batch = renderer.spriteBatch;
    var texture = gameObject.texture.source[0].glTexture;
    var textureWidth = texture.width;
    var textureHeight = texture.height;
    var renderTarget = gameObject.renderTarget;
    var scrollFactorX = gameObject.scrollFactorX;
    var scrollFactorY = gameObject.scrollFactorY;
    var alpha = gameObject.alpha;
    var x = gameObject.x;
    var y = gameObject.y;

    for (var index = 0; index < length; ++index)
    {
        var tile = renderTiles[index];
        batch.addTileTextureRect(
            texture,
            x + tile.x, y + tile.y, tile.width, tile.height, alpha * tile.alpha, tile.tint,
            scrollFactorX, scrollFactorY,
            textureWidth, textureHeight,
            tile.frameX, tile.frameY, tile.frameWidth, tile.frameHeight,
            camera,
            renderTarget
        );
    }
};

module.exports = TilemapWebGLRenderer;


/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var StaticTilemapCanvasRenderer = function (renderer, gameObject, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== gameObject.renderFlags || (gameObject.cameraFilter > 0 && (gameObject.cameraFilter & camera._id)))
    {
        return;
    }

    gameObject.upload(camera);

    var tiles = camera.cullTilemap(gameObject);
    var tileWidth = gameObject.tileWidth;
    var tileHeight = gameObject.tileHeight;
    var frame = gameObject.frame;
    var ctx = renderer.gameContext;
    var tileCount = tiles.length;
    var image = frame.source.image;
    var tx = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
    var ty = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
    var boundsX = camera.scrollX;

    ctx.save();
    ctx.translate(tx, ty);
    ctx.rotate(gameObject.rotation);
    ctx.scale(gameObject.scaleX, gameObject.scaleY);
    ctx.scale(gameObject.flipX ? -1 : 1, gameObject.flipY ? -1 : 1);

    for (var index = 0; index < tileCount; ++index)
    {
        var tile = tiles[index];
        ctx.drawImage(image, tile.frameX, tile.frameY, tileWidth, tileHeight, tile.x, tile.y, tileWidth, tileHeight);
    }

    ctx.restore();
};

module.exports = StaticTilemapCanvasRenderer;


/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetValue = __webpack_require__(4);
var StaticTilemap = __webpack_require__(91);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('staticTilemap', function (config)
{
    var mapData = GetValue(config, 'map.data', null);
    var mapWidth = GetValue(config, 'map.width', 1);
    var mapHeight = GetValue(config, 'map.height', 1);

    var x = GetValue(config, 'x', 0);
    var y = GetValue(config, 'y', 0);

    var tileWidth = GetValue(config, 'tile.width', 16);
    var tileHeight = GetValue(config, 'tile.height', 16);
    var tileTexture = GetValue(config, 'tile.texture', null);
    var tileFrame = GetValue(config, 'tile.frame', null);
    var tileBorder = GetValue(config, 'tile.border', 0);

    var map = new StaticTilemap(this.scene, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, tileBorder, tileTexture, tileFrame);

    BuildGameObject(this.scene, map, config);

    return map;
});


/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

var StaticTilemap = __webpack_require__(91);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('staticTilemap', function (mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, tileBorder, texture, frame)
{
    return this.displayList.add(new StaticTilemap(this.scene, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, tileBorder, texture, frame));
});


/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(551);
}

if (true)
{
    renderCanvas = __webpack_require__(547);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var StaticTilemapWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    var gameObject = src;
    var frame = gameObject.frame;
    var gl = gameObject.gl;

    renderer.setRenderer(gameObject.tilemapRenderer, frame.texture.source[frame.sourceIndex].glTexture, gameObject.renderTarget);
    gameObject.tilemapRenderer.bind();
    gameObject.upload(camera);
    gameObject.vbo.bind();

    gl.drawArrays(gl.TRIANGLES, 0, gameObject.vertexCount);
};

module.exports = StaticTilemapWebGLRenderer;


/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var TileSpriteCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    var ctx = renderer.currentContext;
    var frame = src.frame;

    //  Blend Mode

    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha

    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing

    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    var dx = frame.x - (src.originX * src.width);
    var dy = frame.y - (src.originY * src.height);

    ctx.save();
    ctx.translate(dx, dy);
    ctx.translate(src.x - camera.scrollX * src.scrollFactorX, src.y - camera.scrollY * src.scrollFactorY);
    ctx.fillStyle = src.canvasPattern;
    ctx.translate(-this.tilePositionX, -this.tilePositionY);
    ctx.fillRect(this.tilePositionX, this.tilePositionY, src.width, src.height);
    ctx.restore();
};

module.exports = TileSpriteCanvasRenderer;


/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

var BuildGameObject = __webpack_require__(10);
var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var TileSprite = __webpack_require__(92);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('tileSprite', function (config)
{
    var x = GetAdvancedValue(config, 'x', 0);
    var y = GetAdvancedValue(config, 'y', 0);
    var width = GetAdvancedValue(config, 'width', 512);
    var height = GetAdvancedValue(config, 'height', 512);
    var key = GetAdvancedValue(config, 'key', '');
    var frame = GetAdvancedValue(config, 'frame', '');

    var tile = new TileSprite(this.scene, x, y, width, height, key, frame);

    BuildGameObject(this.scene, tile, config);

    return tile;
});


/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

var TileSprite = __webpack_require__(92);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('tileSprite', function (x, y, width, height, key, frame)
{
    return this.displayList.add(new TileSprite(this.scene, x, y, width, height, key, frame));
});


/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

var renderWebGL = __webpack_require__(3);
var renderCanvas = __webpack_require__(3);

if (true)
{
    renderWebGL = __webpack_require__(556);
}

if (true)
{
    renderCanvas = __webpack_require__(552);
}

module.exports = {

    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

};


/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(1);

var TileSpriteWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter > 0 && (src.cameraFilter & camera._id)))
    {
        return;
    }

    src.updateTileTexture();

    renderer.tileBatch.addTileSprite(src, camera);
};

module.exports = TileSpriteWebGLRenderer;


/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

var GameObjectCreator = __webpack_require__(5);
var GetAdvancedValue = __webpack_require__(7);
var Zone = __webpack_require__(59);

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('zone', function (config)
{
    var x = GetAdvancedValue(config, 'x', 0);
    var y = GetAdvancedValue(config, 'y', 0);
    var width = GetAdvancedValue(config, 'width', 1);
    var height = GetAdvancedValue(config, 'height', width);

    return new Zone(this.scene, x, y, width, height);
});


/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

var Zone = __webpack_require__(59);
var GameObjectFactory = __webpack_require__(6);

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('zone', function (x, y, width, height)
{
    return this.displayList.add(new Zone(this.scene, x, y, width, height));
});


/***/ }),
/* 559 */
/***/ (function(module, exports) {

var Area = function (circle)
{
    return (circle.radius > 0) ? Math.PI * circle.radius * circle.radius : 0;
};

module.exports = Area;


/***/ }),
/* 560 */
/***/ (function(module, exports) {

var Circumference = function (circle)
{
    return 2 * (Math.PI * circle.radius);
};

module.exports = Circumference;


/***/ }),
/* 561 */
/***/ (function(module, exports) {

/**
* Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
*/
var CircumferencePoint = function (circle, angle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = circle.x + (circle.radius * Math.cos(angle));
    out.y = circle.y + (circle.radius * Math.sin(angle));

    return out;
};

module.exports = CircumferencePoint;


/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

var Circle = __webpack_require__(60);

var Clone = function (source)
{
    return new Circle(source.x, source.y, source.radius);
};

module.exports = Clone;


/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(38);

var ContainsPoint = function (circle, point)
{
    return Contains(circle, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(38);

var ContainsRect = function (circle, rect)
{
    return (
        Contains(circle, rect.x, rect.y) &&
        Contains(circle, rect.right, rect.y) &&
        Contains(circle, rect.x, rect.bottom) &&
        Contains(circle, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ }),
/* 565 */
/***/ (function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.radius);
};

module.exports = CopyFrom;


/***/ }),
/* 566 */
/***/ (function(module, exports) {

var Equals = function (circle, toCompare)
{
    return (
        circle.x === toCompare.x &&
        circle.y === toCompare.y &&
        circle.radius === toCompare.radius
    );
};

module.exports = Equals;


/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(18);

var GetBounds = function (circle, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = circle.left;
    out.y = circle.top;
    out.width = circle.diameter;
    out.height = circle.diameter;

    return out;
};

module.exports = GetBounds;


/***/ }),
/* 568 */
/***/ (function(module, exports) {

var Offset = function (circle, x, y)
{
    circle.x += x;
    circle.y += y;

    return circle;
};

module.exports = Offset;


/***/ }),
/* 569 */
/***/ (function(module, exports) {

var OffsetPoint = function (circle, point)
{
    circle.x += point.x;
    circle.y += point.y;

    return circle;
};

module.exports = OffsetPoint;


/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Circle

var Circle = __webpack_require__(60);

Circle.Area = __webpack_require__(559);
Circle.Circumference = __webpack_require__(560);
Circle.CircumferencePoint = __webpack_require__(561);
Circle.Clone = __webpack_require__(562);
Circle.Contains = __webpack_require__(38);
Circle.ContainsPoint = __webpack_require__(563);
Circle.ContainsRect = __webpack_require__(564);
Circle.CopyFrom = __webpack_require__(565);
Circle.Equals = __webpack_require__(566);
Circle.GetBounds = __webpack_require__(567);
Circle.Offset = __webpack_require__(568);
Circle.OffsetPoint = __webpack_require__(569);
Circle.Random = __webpack_require__(140);

module.exports = Circle;


/***/ }),
/* 571 */
/***/ (function(module, exports) {

var Area = function (ellipse)
{
    if (ellipse.isEmpty())
    {
        return 0;
    }

    //  units squared
    return (ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI);
};

module.exports = Area;


/***/ }),
/* 572 */
/***/ (function(module, exports) {

/**
* Returns a Point object containing the coordinates of a point on the circumference of the Ellipse based on the given angle.
*/
var CircumferencePoint = function (ellipse, angle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var a = ellipse.width / 2;
    var b = ellipse.height / 2;

    out.x = ellipse.x + a * Math.cos(angle);
    out.y = ellipse.y + b * Math.sin(angle);

    return out;
};

module.exports = CircumferencePoint;


/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

var Ellipse = __webpack_require__(93);

var Clone = function (source)
{
    return new Ellipse(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(61);

var ContainsPoint = function (ellipse, point)
{
    return Contains(ellipse, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(61);

var ContainsRect = function (ellipse, rect)
{
    return (
        Contains(ellipse, rect.x, rect.y) &&
        Contains(ellipse, rect.right, rect.y) &&
        Contains(ellipse, rect.x, rect.bottom) &&
        Contains(ellipse, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ }),
/* 576 */
/***/ (function(module, exports) {

var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ }),
/* 577 */
/***/ (function(module, exports) {

var Equals = function (ellipse, toCompare)
{
    return (
        ellipse.x === toCompare.x &&
        ellipse.y === toCompare.y &&
        ellipse.width === toCompare.width &&
        ellipse.height === toCompare.height
    );
};

module.exports = Equals;


/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(18);

var GetBounds = function (ellipse, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = ellipse.x - ellipse.width;
    out.y = ellipse.y - ellipse.height;
    out.width = ellipse.width;
    out.height = ellipse.height;

    return out;
};

module.exports = GetBounds;


/***/ }),
/* 579 */
/***/ (function(module, exports) {

var Offset = function (ellipse, x, y)
{
    ellipse.x += x;
    ellipse.y += y;

    return ellipse;
};

module.exports = Offset;


/***/ }),
/* 580 */
/***/ (function(module, exports) {

var OffsetPoint = function (ellipse, point)
{
    ellipse.x += point.x;
    ellipse.y += point.y;

    return ellipse;
};

module.exports = OffsetPoint;


/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Ellipse

var Ellipse = __webpack_require__(93);

Ellipse.Area = __webpack_require__(571);
Ellipse.CircumferencePoint = __webpack_require__(572);
Ellipse.Clone = __webpack_require__(573);
Ellipse.Contains = __webpack_require__(61);
Ellipse.ContainsPoint = __webpack_require__(574);
Ellipse.ContainsRect = __webpack_require__(575);
Ellipse.CopyFrom = __webpack_require__(576);
Ellipse.Equals = __webpack_require__(577);
Ellipse.GetBounds = __webpack_require__(578);
Ellipse.Offset = __webpack_require__(579);
Ellipse.OffsetPoint = __webpack_require__(580);
Ellipse.Random = __webpack_require__(141);

module.exports = Ellipse;


/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

var DistanceBetween = __webpack_require__(68);

var CircleToCircle = function (circleA, circleB)
{
    return (DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= (circleA.radius + circleB.radius));
};

module.exports = CircleToCircle;


/***/ }),
/* 583 */
/***/ (function(module, exports) {

var CircleToRectangle = function (circle, rect)
{
    var halfWidth = rect.width / 2;
    var halfHeight = rect.height / 2;

    var cx = Math.abs(circle.x - rect.x - halfWidth);
    var xDist = halfWidth + circle.radius;

    if (cx <= halfWidth || cx > xDist)
    {
        return false;
    }

    var cy = Math.abs(circle.y - rect.y - halfHeight);
    var yDist = halfHeight + circle.radius;

    if (cy <= halfHeight || cy > yDist)
    {
        return false;
    }

    var xCornerDist = cx - halfWidth;
    var yCornerDist = cy - halfHeight;
    var xCornerDistSq = xCornerDist * xCornerDist;
    var yCornerDistSq = yCornerDist * yCornerDist;
    var maxCornerDistSq = circle.radius * circle.radius;

    return (xCornerDistSq + yCornerDistSq <= maxCornerDistSq);
};

module.exports = CircleToRectangle;


/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(18);
var RectangleToRectangle = __webpack_require__(144);

var GetRectangleIntersection = function (rectA, rectB, output)
{
    if (output === undefined) { output = new Rectangle(); }

    if (RectangleToRectangle(rectA, rectB))
    {
        output.x = Math.max(rectA.x, rectB.x);
        output.y = Math.max(rectA.y, rectB.y);
        output.width = Math.min(rectA.right, rectB.right) - output.x;
        output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
    }

    return output;
};

module.exports = GetRectangleIntersection;


/***/ }),
/* 585 */
/***/ (function(module, exports) {

/**
* Checks for intersection between the Line and a Rectangle shape, or a rectangle-like
* object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.
*
* An intersection is considered valid if:
*
* The line starts within, or ends within, the Rectangle.
* The line segment intersects one of the 4 rectangle edges.
*
* The for the purposes of this function rectangles are considered 'solid'.
*/
var LineToRectangle = function (line, rect)
{
    var x1 = line.x1;
    var y1 = line.y2;

    var x2 = line.x2;
    var y2 = line.y2;

    var bx1 = rect.x;
    var by1 = rect.y;
    var bx2 = rect.right;
    var by2 = rect.bottom;

    var t = 0;

    //  If the start or end of the line is inside the rect then we assume
    //  collision, as rects are solid for our use-case.

    if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) ||
        (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2))
    {
        return true;
    }

    if (x1 < bx1 && x2 >= bx1)
    {
        //  Left edge
        t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);

        if (t > by1 && t <= by2)
        {
            return true;
        }
    }
    else if (x1 > bx2 && x2 <= bx2)
    {
        //  Right edge
        t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);

        if (t >= by1 && t <= by2)
        {
            return true;
        }
    }

    if (y1 < by1 && y2 >= by1)
    {
        //  Top edge
        t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }
    else if (y1 > by2 && y2 <= by2)
    {
        //  Bottom edge
        t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }

    return false;
};

module.exports = LineToRectangle;


/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

var PointToLine = __webpack_require__(143);

var PointToLineSegment = function (point, line)
{
    if (!PointToLine(point, line))
    {
        return false;
    }

    var xMin = Math.min(line.x1, line.x2);
    var xMax = Math.max(line.x1, line.x2);
    var yMin = Math.min(line.y1, line.y2);
    var yMax = Math.max(line.y1, line.y2);

    return ((point.x >= xMin && point.x <= xMax) && (point.y >= yMin && point.y <= yMax));
};

module.exports = PointToLineSegment;


/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {


var LineToLine = __webpack_require__(62);
var Contains = __webpack_require__(32);
var ContainsArray = __webpack_require__(98);
var Decompose = __webpack_require__(156);

var RectangleToTriangle = function (rect, triangle)
{
    //  First the cheapest ones:

    if (
        triangle.left > rect.right ||
        triangle.right < rect.left ||
        triangle.top > rect.bottom ||
        triangle.bottom < rect.top)
    {
        return false;
    }

    var triA = triangle.getLineA();
    var triB = triangle.getLineB();
    var triC = triangle.getLineC();

    //  Are any of the triangle points within the rectangle?

    if (Contains(rect, triA.x1, triA.y1) || Contains(rect, triA.x2, triA.y2))
    {
        return true;
    }

    if (Contains(rect, triB.x1, triB.y1) || Contains(rect, triB.x2, triB.y2))
    {
        return true;
    }

    if (Contains(rect, triC.x1, triC.y1) || Contains(rect, triC.x2, triC.y2))
    {
        return true;
    }

    //  Cheap tests over, now to see if any of the lines intersect ...

    var rectA = rect.getLineA();
    var rectB = rect.getLineB();
    var rectC = rect.getLineC();
    var rectD = rect.getLineD();

    if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD))
    {
        return true;
    }

    if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD))
    {
        return true;
    }

    if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD))
    {
        return true;
    }

    //  None of the lines intersect, so are any rectangle points within the triangle?

    var points = Decompose(rect);
    var within = ContainsArray(triangle, points, true);

    return (within.length > 0);
};

module.exports = RectangleToTriangle;


/***/ }),
/* 588 */
/***/ (function(module, exports) {

var RectangleToValues = function (rect, left, right, top, bottom, tolerance)
{
    if (tolerance === undefined) { tolerance = 0; }

    return !(
        left > rect.right + tolerance ||
        right < rect.left - tolerance ||
        top > rect.bottom + tolerance ||
        bottom < rect.top - tolerance
    );
};

module.exports = RectangleToValues;


/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {


var LineToCircle = __webpack_require__(142);
var Contains = __webpack_require__(51);

var TriangleToCircle = function (triangle, circle)
{
     //  First the cheapest ones:

    if (
        triangle.left > circle.right ||
        triangle.right < circle.left ||
        triangle.top > circle.bottom ||
        triangle.bottom < circle.top)
    {
        return false;
    }

    if (Contains(triangle, circle.x, circle.y))
    {
        return true;
    }

    if (LineToCircle(triangle.getLineA(), circle))
    {
        return true;
    }

    if (LineToCircle(triangle.getLineB(), circle))
    {
        return true;
    }

    if (LineToCircle(triangle.getLineC(), circle))
    {
        return true;
    }

    return false;
};

module.exports = TriangleToCircle;


/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {


var LineToLine = __webpack_require__(62);
var Contains = __webpack_require__(51);

var TriangleToLine = function (triangle, line)
{
    //  If the Triangle contains either the start or end point of the line, it intersects
    if (Contains(triangle, line.getPointA()) || Contains(triangle, line.getPointB()))
    {
        return true;
    }

    //  Now check the line against each line of the Triangle
    if (LineToLine(triangle.getLineA(), line))
    {
        return true;
    }

    if (LineToLine(triangle.getLineB(), line))
    {
        return true;
    }

    if (LineToLine(triangle.getLineC(), line))
    {
        return true;
    }

    return false;
};

module.exports = TriangleToLine;


/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {


var LineToLine = __webpack_require__(62);
var ContainsArray = __webpack_require__(98);
var Decompose = __webpack_require__(161);

var TriangleToTriangle = function (triangleA, triangleB)
{
    //  First the cheapest ones:

    if (
        triangleA.left > triangleB.right ||
        triangleA.right < triangleB.left ||
        triangleA.top > triangleB.bottom ||
        triangleA.bottom < triangleB.top)
    {
        return false;
    }

    var lineAA = triangleA.getLineA();
    var lineAB = triangleA.getLineB();
    var lineAC = triangleA.getLineC();

    var lineBA = triangleB.getLineA();
    var lineBB = triangleB.getLineB();
    var lineBC = triangleB.getLineC();

    //  Now check the lines against each line of TriangleB
    if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC))
    {
        return true;
    }

    if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC))
    {
        return true;
    }

    if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC))
    {
        return true;
    }

    //  Nope, so check to see if any of the points of triangleA are within triangleB

    var points = Decompose(triangleA);
    var within = ContainsArray(triangleB, points, true);

    if (within.length > 0)
    {
        return true;
    }

    //  Finally check to see if any of the points of triangleB are within triangleA

    points = Decompose(triangleB);
    within = ContainsArray(triangleA, points, true);

    if (within.length > 0)
    {
        return true;
    }

    return false;
};

module.exports = TriangleToTriangle;


/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Intersects

module.exports = {

    CircleToCircle: __webpack_require__(582),
    CircleToRectangle: __webpack_require__(583),
    GetRectangleIntersection: __webpack_require__(584),
    LineToCircle: __webpack_require__(142),
    LineToLine: __webpack_require__(62),
    LineToRectangle: __webpack_require__(585),
    PointToLine: __webpack_require__(143),
    PointToLineSegment: __webpack_require__(586),
    RectangleToRectangle: __webpack_require__(144),
    RectangleToTriangle: __webpack_require__(587),
    RectangleToValues: __webpack_require__(588),
    TriangleToCircle: __webpack_require__(589),
    TriangleToLine: __webpack_require__(590),
    TriangleToTriangle: __webpack_require__(591)

};


/***/ }),
/* 593 */
/***/ (function(module, exports) {


var CenterOn = function (line, x, y)
{
    var tx = x - ((line.x1 + line.x2) / 2);
    var ty = y - ((line.y1 + line.y2) / 2);

    line.x1 += tx;
    line.y1 += ty;

    line.x2 += tx;
    line.y2 += ty;

    return line;
};

module.exports = CenterOn;


/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

var Line = __webpack_require__(145);

var Clone = function (source)
{
    return new Line(source.x1, source.y1, source.x2, source.y2);
};

module.exports = Clone;


/***/ }),
/* 595 */
/***/ (function(module, exports) {

var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x1, source.y1, source.x2, source.y2);
};

module.exports = CopyFrom;


/***/ }),
/* 596 */
/***/ (function(module, exports) {

var Equals = function (line, toCompare)
{
    return (
        line.x1 === toCompare.x1 &&
        line.y1 === toCompare.y1 &&
        line.x2 === toCompare.x2 &&
        line.y2 === toCompare.y2
    );
};

module.exports = Equals;


/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(12);

var GetMidPoint = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = (line.x1 + line.x2) / 2;
    out.y = (line.y1 + line.y2) / 2;

    return out;
};

module.exports = GetMidPoint;


/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(13);
var Angle = __webpack_require__(39);
var Point = __webpack_require__(12);

var GetNormal = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var a = Angle(line) - MATH_CONST.TAU;

    out.x = Math.cos(a);
    out.y = Math.sin(a);

    return out;
};

module.exports = GetNormal;


/***/ }),
/* 599 */
/***/ (function(module, exports) {

//  Get a point on the given line 'progress' percentage along its length.
//  progress is a value between 0 and 1.

var GetPoint = function (line, progress)
{
    var x = line.x1 + (line.x2 - line.x1) * progress;
    var y = line.y1 + (line.y2 - line.y1) * progress;

    return { x: x, y: y };
};

module.exports = GetPoint;


/***/ }),
/* 600 */
/***/ (function(module, exports) {

var Height = function (line)
{
    return Math.abs(line.y1 - line.y2);
};

module.exports = Height;


/***/ }),
/* 601 */
/***/ (function(module, exports) {

var Length = function (line)
{
    return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
};

module.exports = Length;


/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(13);
var Angle = __webpack_require__(39);

var NormalX = function (line)
{
    return Math.cos(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalX;


/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(13);
var Angle = __webpack_require__(39);

var NormalY = function (line)
{
    return Math.sin(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalY;


/***/ }),
/* 604 */
/***/ (function(module, exports) {

var Offset = function (line, x, y)
{
    line.x1 += x;
    line.y1 += y;

    line.x2 += x;
    line.y2 += y;

    return line;
};

module.exports = Offset;


/***/ }),
/* 605 */
/***/ (function(module, exports) {

var PerpSlope = function (line)
{
    return -((line.x2 - line.x1) / (line.y2 - line.y1));
};

module.exports = PerpSlope;


/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

var Angle = __webpack_require__(39);
var NormalAngle = __webpack_require__(146);

/**
* Returns the reflected angle between two lines.
* This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.
*/
var ReflectAngle = function (lineA, lineB)
{
    return (2 * NormalAngle(lineB) - Math.PI - Angle(lineA));
};

module.exports = ReflectAngle;


/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(95);

var Rotate = function (line, angle)
{
    var x = (line.x1 + line.x2) / 2;
    var y = (line.y1 + line.y2) / 2;

    return RotateAroundXY(line, x, y, angle);
};

module.exports = Rotate;


/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(95);

var RotateAroundPoint = function (line, point, angle)
{
    return RotateAroundXY(line, point.x, point.y, angle);
};

module.exports = RotateAroundPoint;


/***/ }),
/* 609 */
/***/ (function(module, exports) {

var SetToAngle = function (line, x, y, angle, length)
{
    line.x1 = x;
    line.y1 = y;

    line.x2 = x + (Math.cos(angle) * length);
    line.y2 = y + (Math.sin(angle) * length);

    return line;
};

module.exports = SetToAngle;


/***/ }),
/* 610 */
/***/ (function(module, exports) {

var Slope = function (line)
{
    return (line.y2 - line.y1) / (line.x2 - line.x1);
};

module.exports = Slope;


/***/ }),
/* 611 */
/***/ (function(module, exports) {

var Width = function (line)
{
    return Math.abs(line.x1 - line.x2);
};

module.exports = Width;


/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Line

var Line = __webpack_require__(145);

Line.Angle = __webpack_require__(39);
Line.CenterOn = __webpack_require__(593);
Line.Clone = __webpack_require__(594);
Line.CopyFrom = __webpack_require__(595);
Line.Equals = __webpack_require__(596);
Line.GetMidPoint = __webpack_require__(597);
Line.GetNormal = __webpack_require__(598);
Line.GetPoint = __webpack_require__(599);
Line.GetPointsOnLine = __webpack_require__(94);
Line.Height = __webpack_require__(600);
Line.Length = __webpack_require__(601);
Line.NormalAngle = __webpack_require__(146);
Line.NormalX = __webpack_require__(602);
Line.NormalY = __webpack_require__(603);
Line.Offset = __webpack_require__(604);
Line.PerpSlope = __webpack_require__(605);
Line.Random = __webpack_require__(147);
Line.ReflectAngle = __webpack_require__(606);
Line.Rotate = __webpack_require__(607);
Line.RotateAroundPoint = __webpack_require__(608);
Line.RotateAroundXY = __webpack_require__(95);
Line.SetToAngle = __webpack_require__(609);
Line.Slope = __webpack_require__(610);
Line.Width = __webpack_require__(611);

module.exports = Line;


/***/ }),
/* 613 */
/***/ (function(module, exports) {

var Add = function (point, x, y)
{
    point.x += x;
    point.y += y;

    return point;
};

module.exports = Add;


/***/ }),
/* 614 */
/***/ (function(module, exports) {

var Ceil = function (point)
{
    return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
};

module.exports = Ceil;


/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(12);

var Clone = function (source)
{
    return new Point(source.x, source.y);
};

module.exports = Clone;


/***/ }),
/* 616 */
/***/ (function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y);
};

module.exports = CopyFrom;


/***/ }),
/* 617 */
/***/ (function(module, exports) {

var Cross = function (pointA, pointB)
{
    return ((pointA.x * pointB.y) - (pointA.y * pointB.x));
};

module.exports = Cross;


/***/ }),
/* 618 */
/***/ (function(module, exports) {

var Divide = function (point, x, y)
{
    point.x /= x;
    point.y /= y;

    return point;
};

module.exports = Divide;


/***/ }),
/* 619 */
/***/ (function(module, exports) {

var Equals = function (point, toCompare)
{
    return (point.x === toCompare.x && point.y === toCompare.y);
};

module.exports = Equals;


/***/ }),
/* 620 */
/***/ (function(module, exports) {

var Floor = function (point)
{
    return point.setTo(Math.floor(point.x), Math.floor(point.y));
};

module.exports = Floor;


/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(12);

var GetCentroid = function (points, out)
{
    if (out === undefined) { out = new Point(); }

    if (!Array.isArray(points))
    {
        throw new Error('GetCentroid points argument must be an array');
    }

    var len = points.length;

    if (len < 1)
    {
        throw new Error('GetCentroid points array must not be empty');
    }
    else if (len === 1)
    {
        out.x = points[0].x;
        out.y = points[0].y;
    }
    else
    {
        for (var i = 0; i < len; i++)
        {
            out.x += points[i].x;
            out.y += points[i].y;
        }

        out.x /= len;
        out.y /= len;
    }

    return out;
};

module.exports = GetCentroid;


/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(12);

var Interpolate = function (pointA, pointB, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    out.x = pointA.x + ((pointB.x - pointA.x) * t);
    out.y = pointA.y + ((pointB.y - pointA.y) * t);

    return out;
};

module.exports = Interpolate;


/***/ }),
/* 623 */
/***/ (function(module, exports) {

var Invert = function (point)
{
    return point.setTo(point.y, point.x);
};

module.exports = Invert;


/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(12);

var Negative = function (point, out)
{
    if (out === undefined) { out = new Point(); }

    return out.setTo(-point.x, -point.y);
};

module.exports = Negative;


/***/ }),
/* 625 */
/***/ (function(module, exports) {

var NormalizeRightHand = function (point)
{
    return point.setTo(point.y * -1, point.x);
};

module.exports = NormalizeRightHand;


/***/ }),
/* 626 */
/***/ (function(module, exports) {

var Perp = function (point)
{
    return point.setTo(-point.y, point.x);
};

module.exports = Perp;


/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(96);
var Point = __webpack_require__(12);
var GetMagnitudeSq = __webpack_require__(149);

var Project = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB) / GetMagnitudeSq(pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = Project;


/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(96);
var Point = __webpack_require__(12);

var ProjectUnit = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = ProjectUnit;


/***/ }),
/* 629 */
/***/ (function(module, exports) {

var RPerp = function (point)
{
    return point.setTo(point.y, -point.x);
};

module.exports = RPerp;


/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(151);
var Multiply = __webpack_require__(150);

var SetMagnitude = function (point, magnitude)
{
    Normalize(point);

    return Multiply(point, magnitude, magnitude);
};

module.exports = SetMagnitude;


/***/ }),
/* 631 */
/***/ (function(module, exports) {

var Subtract = function (point, x, y)
{
    point.x -= x;
    point.y -= y;

    return point;
};

module.exports = Subtract;


/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Point

var Point = __webpack_require__(12);

Point.Add = __webpack_require__(613);
Point.Ceil = __webpack_require__(614);
Point.Clone = __webpack_require__(615);
Point.CopyFrom = __webpack_require__(616);
Point.Cross = __webpack_require__(617);
Point.Divide = __webpack_require__(618);
Point.Dot = __webpack_require__(96);
Point.Equals = __webpack_require__(619);
Point.Floor = __webpack_require__(620);
Point.GetCentroid = __webpack_require__(621);
Point.GetMagnitude = __webpack_require__(148);
Point.GetMagnitudeSq = __webpack_require__(149);
Point.Interpolate = __webpack_require__(622);
Point.Invert = __webpack_require__(623);
Point.Multiply = __webpack_require__(150);
Point.Negative = __webpack_require__(624);
Point.Normalize = __webpack_require__(151);
Point.NormalizeRightHand = __webpack_require__(625);
Point.Perp = __webpack_require__(626);
Point.Project = __webpack_require__(627);
Point.ProjectUnit = __webpack_require__(628);
Point.RPerp = __webpack_require__(629);
Point.SetMagnitude = __webpack_require__(630);
Point.Subtract = __webpack_require__(631);

module.exports = Point;


/***/ }),
/* 633 */
/***/ (function(module, exports, __webpack_require__) {

var Polygon = __webpack_require__(154);

var Clone = function (polygon)
{
    return new Polygon(polygon.points);
};

module.exports = Clone;


/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(152);

var ContainsPoint = function (polygon, point)
{
    return Contains(polygon, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ }),
/* 635 */
/***/ (function(module, exports) {


var GetAABB = function (polygon)
{
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -minX;
    var maxY = -minY;
    var p;

    for (var i = 0; i < polygon.points.length; i++)
    {
        p = polygon.points[i];

        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
    }

    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
};

module.exports = GetAABB;


/***/ }),
/* 636 */
/***/ (function(module, exports) {

/**
 * Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]
 */
var GetNumberArray = function (polygon, output)
{
    if (output === undefined) { output = []; }

    for (var i = 0; i < polygon.points.length; i++)
    {
        output.push(polygon.points[i].x);
        output.push(polygon.points[i].y);
    }

    return output;
};

module.exports = GetNumberArray;


/***/ }),
/* 637 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Polygon

var Polygon = __webpack_require__(154);

Polygon.Clone = __webpack_require__(633);
Polygon.Contains = __webpack_require__(152);
Polygon.ContainsPoint = __webpack_require__(634);
Polygon.GetAABB = __webpack_require__(635);
Polygon.GetNumberArray = __webpack_require__(636);

module.exports = Polygon;


/***/ }),
/* 638 */
/***/ (function(module, exports) {

var Area = function (rect)
{
    return rect.width * rect.height;
};

module.exports = Area;


/***/ }),
/* 639 */
/***/ (function(module, exports) {

var Ceil = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);

    return rect;
};

module.exports = Ceil;


/***/ }),
/* 640 */
/***/ (function(module, exports) {

var CeilAll = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);
    rect.width = Math.ceil(rect.width);
    rect.height = Math.ceil(rect.height);

    return rect;
};

module.exports = CeilAll;


/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(18);

var Clone = function (source)
{
    return new Rectangle(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(32);

var ContainsPoint = function (rect, point)
{
    return Contains(rect, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ }),
/* 643 */
/***/ (function(module, exports) {

//  Checks if rectB is fully contained within rectA

var ContainsRect = function (rectA, rectB)
{
    //  Volume check (if rectB volume > rectA then rectA cannot contain it)
    if ((rectB.width * rectB.height) > (rectA.width * rectA.height))
    {
        return false;
    }

    return (
        (rectB.x > rectA.x && rectB.x < rectA.right) &&
        (rectB.right > rectA.x && rectB.right < rectA.right) &&
        (rectB.y > rectA.y && rectB.y < rectA.bottom) && 
        (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom)
    );
};

module.exports = ContainsRect;


/***/ }),
/* 644 */
/***/ (function(module, exports) {

var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ }),
/* 645 */
/***/ (function(module, exports) {

var Equals = function (rect, toCompare)
{
    return (
        rect.x === toCompare.x &&
        rect.y === toCompare.y &&
        rect.width === toCompare.width &&
        rect.height === toCompare.height
    );
};

module.exports = Equals;


/***/ }),
/* 646 */
/***/ (function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(97);

//  Fits the target rectangle into the source rectangle.
//  Preserves aspect ratio.
//  Scales and centers the target rectangle to the source rectangle

var FitInside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio < GetAspectRatio(source))
    {
        //  Taller than Wide
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Wider than Tall
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - (target.width / 2),
        (source.bottom / 2) - (target.height / 2)
    );
};

module.exports = FitInside;


/***/ }),
/* 647 */
/***/ (function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(97);

//  Fits the target rectangle around the source rectangle.
//  Preserves aspect ration.
//  Scales and centers the target rectangle to the source rectangle

var FitOutside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio > GetAspectRatio(source))
    {
        //  Wider than Tall
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Taller than Wide
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - target.width / 2,
        (source.bottom / 2) - target.height / 2
    );
};

module.exports = FitOutside;


/***/ }),
/* 648 */
/***/ (function(module, exports) {

var Floor = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);

    return rect;
};

module.exports = Floor;


/***/ }),
/* 649 */
/***/ (function(module, exports) {

var FloorAll = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);
    rect.width = Math.floor(rect.width);
    rect.height = Math.floor(rect.height);

    return rect;
};

module.exports = FloorAll;


/***/ }),
/* 650 */
/***/ (function(module, exports) {

//  The center of the Rectangle object, expressed as a Point object 

var GetCenter = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.right / 2;
    out.y = rect.bottom / 2;

    return out;
};

module.exports = GetCenter;


/***/ }),
/* 651 */
/***/ (function(module, exports) {

//  The size of the Rectangle object, expressed as a Point object 
//  with the values of the width and height properties.

var GetSize = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.width;
    out.y = rect.height;

    return out;
};

module.exports = GetSize;


/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

var CenterOn = __webpack_require__(155);

//  Increases the size of the Rectangle object by the specified amounts.
//  The center point of the Rectangle object stays the same, and its size increases 
//  to the left and right by the x value, and to the top and the bottom by the y value.

var Inflate = function (rect, x, y)
{
    var cx = rect.centerX;
    var cy = rect.centerY;

    rect.setSize(rect.width + (x * 2), rect.height + (y * 2));

    return CenterOn(rect, cx, cy);
};

module.exports = Inflate;


/***/ }),
/* 653 */
/***/ (function(module, exports) {

//  Merges the target Rectangle with a list of points.
//  The points is an array of objects with public x/y properties.

var MergePoints = function (target, points)
{
    var minX = target.x;
    var maxX = target.right;
    var minY = target.y;
    var maxY = target.bottom;

    for (var i = 0; i < points.length; i++)
    {
        minX = Math.min(minX, points[i].x);
        maxX = Math.max(maxX, points[i].x);
        minY = Math.min(minY, points[i].y);
        maxY = Math.max(maxY, points[i].y);
    }

    target.x = minX;
    target.y = minY;
    target.width = maxX - minX;
    target.height = maxY - minY;

    return target;
};

module.exports = MergePoints;


/***/ }),
/* 654 */
/***/ (function(module, exports) {

//  Merges source rectangle into target rectangle and returns target
//  Neither rect should have negative widths or heights

var MergeRect = function (target, source)
{
    var minX = Math.min(target.x, source.x);
    var maxX = Math.max(target.right, source.right);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, source.y);
    var maxY = Math.max(target.bottom, source.bottom);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeRect;


/***/ }),
/* 655 */
/***/ (function(module, exports) {


var MergeXY = function (target, x, y)
{
    var minX = Math.min(target.x, x);
    var maxX = Math.max(target.right, x);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, y);
    var maxY = Math.max(target.bottom, y);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeXY;


/***/ }),
/* 656 */
/***/ (function(module, exports) {

var Offset = function (rect, x, y)
{
    rect.x += x;
    rect.y += y;

    return rect;
};

module.exports = Offset;


/***/ }),
/* 657 */
/***/ (function(module, exports) {

var OffsetPoint = function (rect, point)
{
    rect.x += point.x;
    rect.y += point.y;

    return rect;
};

module.exports = OffsetPoint;


/***/ }),
/* 658 */
/***/ (function(module, exports) {

var Overlaps = function (rectA, rectB)
{
    return (
        rectA.x < rectB.right && 
        rectA.right > rectB.x && 
        rectA.y < rectB.bottom && 
        rectA.bottom > rectB.y
    );
};

module.exports = Overlaps;


/***/ }),
/* 659 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(13);

//  deg = degrees (0-360)

var PerimeterPoint = function (rect, deg, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var theta = deg * MATH_CONST.DEG_TO_RAD;

    while (theta < -Math.PI)
    {
        theta += MATH_CONST.PI2;
    }

    while (theta > Math.PI)
    {
        theta -= MATH_CONST.PI2;
    }

    var rectAtan = Math.atan2(rect.height, rect.width);
    var tanTheta = Math.tan(theta);
    var thetaBounds = Math.PI - rectAtan;
    var region;
    var xFactor = 1;
    var yFactor = 1;

    if (theta > -rectAtan && theta <= rectAtan)
    {
        region = 1;
        yFactor = -1;
    }
    else if (theta > rectAtan && theta <= thetaBounds)
    {
        region = 2;
        yFactor = -1;
    }
    else if (theta > thetaBounds || theta <= -thetaBounds)
    {
        region = 3;
        xFactor = -1;
    }
    else
    {
        region = 4;
        xFactor = -1;
    }

    out.x = rect.x + (rect.width / 2);
    out.y = rect.y + (rect.height / 2);

    if (region === 1 || region === 3)
    {
        out.x += xFactor * (rect.width / 2);                                     // "Z0"
        out.y += yFactor * (rect.width / 2) * tanTheta;
    }
    else
    {
        out.x += xFactor * (rect.height / (2 * tanTheta));                        // "Z1"
        out.y += yFactor * (rect.height / 2);
    }

    return out;
};

module.exports = PerimeterPoint;


/***/ }),
/* 660 */
/***/ (function(module, exports) {

/**
* Scales the width and height of this Rectangle by the given amounts.
*/
var Scale = function (rect, x, y)
{
    if (y === undefined) { y = x; }

    rect.width *= x;
    rect.height *= y;

    return rect;
};

module.exports = Scale;


/***/ }),
/* 661 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(18);

var Union = function (rectA, rectB, output)
{
    if (output === undefined) { output = Rectangle(); }

    var x = Math.min(rectA.x, rectB.x);
    var y = Math.min(rectA.y, rectB.y);

    return output.set(
        x,
        y,
        Math.max(rectA.right, rectB.right) - x,
        Math.max(rectA.bottom, rectB.bottom) - y
    );
    
};

module.exports = Union;


/***/ }),
/* 662 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Rectangle

var Rectangle = __webpack_require__(18);

Rectangle.Area = __webpack_require__(638);
Rectangle.Ceil = __webpack_require__(639);
Rectangle.CeilAll = __webpack_require__(640);
Rectangle.CenterOn = __webpack_require__(155);
Rectangle.Clone = __webpack_require__(641);
Rectangle.Contains = __webpack_require__(32);
Rectangle.ContainsPoint = __webpack_require__(642);
Rectangle.ContainsRect = __webpack_require__(643);
Rectangle.CopyFrom = __webpack_require__(644);
Rectangle.Decompose = __webpack_require__(156);
Rectangle.Equals = __webpack_require__(645);
Rectangle.FitInside = __webpack_require__(646);
Rectangle.FitOutside = __webpack_require__(647);
Rectangle.Floor = __webpack_require__(648);
Rectangle.FloorAll = __webpack_require__(649);
Rectangle.GetAspectRatio = __webpack_require__(97);
Rectangle.GetCenter = __webpack_require__(650);
Rectangle.GetSize = __webpack_require__(651);
Rectangle.Inflate = __webpack_require__(652);
Rectangle.MarchingAnts = __webpack_require__(157);
Rectangle.MergePoints = __webpack_require__(653);
Rectangle.MergeRect = __webpack_require__(654);
Rectangle.MergeXY = __webpack_require__(655);
Rectangle.Offset = __webpack_require__(656);
Rectangle.OffsetPoint = __webpack_require__(657);
Rectangle.Overlaps = __webpack_require__(658);
Rectangle.Perimeter = __webpack_require__(158);
Rectangle.PerimeterPoint = __webpack_require__(659);
Rectangle.Random = __webpack_require__(159);
Rectangle.Scale = __webpack_require__(660);
Rectangle.Union = __webpack_require__(661);

module.exports = Rectangle;


/***/ }),
/* 663 */
/***/ (function(module, exports) {

// The 2D area of a triangle. The area value is always non-negative.

var Area = function (triangle)
{
    var x1 = triangle.x1;
    var y1 = triangle.y1;

    var x2 = triangle.x2;
    var y2 = triangle.y2;

    var x3 = triangle.x3;
    var y3 = triangle.y3;

    return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);
};

module.exports = Area;


/***/ }),
/* 664 */
/***/ (function(module, exports, __webpack_require__) {

var Triangle = __webpack_require__(40);

// Builds an equilateral triangle.
// In the equilateral triangle, all the sides are the same length (congruent)
// and all the angles are the same size (congruent).

//  The x/y specifies the top-middle of the triangle (x1/y1) and length
//  is the length of each side

var BuildEquilateral = function (x, y, length)
{
    var height = length * (Math.sqrt(3) / 2);

    var x1 = x;
    var y1 = y;

    var x2 = x + (length / 2);
    var y2 = y + height;

    var x3 = x - (length / 2);
    var y3 = y + height;

    return new Triangle(x1, y1, x2, y2, x3, y3);
};

module.exports = BuildEquilateral;


/***/ }),
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

var EarCut = __webpack_require__(153);
var Triangle = __webpack_require__(40);

var BuildFromPolygon = function (data, holes, scaleX, scaleY, out)
{
    if (holes === undefined) { holes = null; }
    if (scaleX === undefined) { scaleX = 1; }
    if (scaleY === undefined) { scaleY = 1; }
    if (out === undefined) { out = []; }

    var tris = EarCut(data, holes);

    var a;
    var b;
    var c;

    var x1;
    var y1;

    var x2;
    var y2;

    var x3;
    var y3;

    for (var i = 0; i < tris.length; i += 3)
    {
        a = tris[i];
        b = tris[i + 1];
        c = tris[i + 2];

        x1 = data[a * 2] * scaleX;
        y1 = data[(a * 2) + 1] * scaleY;

        x2 = data[b * 2] * scaleX;
        y2 = data[(b * 2) + 1] * scaleY;

        x3 = data[c * 2] * scaleX;
        y3 = data[(c * 2) + 1] * scaleY;

        out.push(new Triangle(x1, y1, x2, y2, x3, y3));
    }

    return out;
};

module.exports = BuildFromPolygon;


/***/ }),
/* 666 */
/***/ (function(module, exports, __webpack_require__) {

var Triangle = __webpack_require__(40);

//  Builds a right triangle, with one 90 degree angle and two acute angles
//  The x/y is the coordinate of the 90 degree angle (and will map to x1/y1 in the resulting Triangle)
//  w/h can be positive or negative and represent the length of each side

var BuildRight = function (x, y, width, height)
{
    if (height === undefined) {  height = width; }

    //  90 degree angle
    var x1 = x;
    var y1 = y;

    var x2 = x;
    var y2 = y - height;

    var x3 = x + width;
    var y3 = y;

    return new Triangle(x1, y1, x2, y2, x3, y3);
};

module.exports = BuildRight;


/***/ }),
/* 667 */
/***/ (function(module, exports, __webpack_require__) {

var Centroid = __webpack_require__(160);
var Offset = __webpack_require__(163);

var CenterOn = function (triangle, x, y, centerFunc)
{
    if (centerFunc === undefined) { centerFunc = Centroid; }

    //  Get the center of the triangle
    var center = centerFunc(triangle);

    //  Difference
    var diffX = x - center.x;
    var diffY = y - center.y;

    return Offset(triangle, diffX, diffY);
};

module.exports = CenterOn;


/***/ }),
/* 668 */
/***/ (function(module, exports) {

//  Adapted from http://bjornharrtell.github.io/jsts/doc/api/jsts_geom_Triangle.js.html

/**
 * Computes the determinant of a 2x2 matrix. Uses standard double-precision
 * arithmetic, so is susceptible to round-off error.
 *
 * @param {Number}
 *          m00 the [0,0] entry of the matrix.
 * @param {Number}
 *          m01 the [0,1] entry of the matrix.
 * @param {Number}
 *          m10 the [1,0] entry of the matrix.
 * @param {Number}
 *          m11 the [1,1] entry of the matrix.
 * @return {Number} the determinant.
 */
function det (m00, m01, m10, m11)
{
    return (m00 * m11) - (m01 * m10);
}

/**
 * Computes the circumcentre of a triangle. The circumcentre is the centre of
 * the circumcircle, the smallest circle which encloses the triangle. It is also
 * the common intersection point of the perpendicular bisectors of the sides of
 * the triangle, and is the only point which has equal distance to all three
 * vertices of the triangle.
 * <p>
 * This method uses an algorithm due to J.R.Shewchuk which uses normalization to
 * the origin to improve the accuracy of computation. (See <i>Lecture Notes on
 * Geometric Robustness</i>, Jonathan Richard Shewchuk, 1999).
 */
var CircumCenter = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var cx = triangle.x3;
    var cy = triangle.y3;

    var ax = triangle.x1 - cx;
    var ay = triangle.y1 - cy;

    var bx = triangle.x2 - cx;
    var by = triangle.y2 - cy;

    var denom = 2 * det(ax, ay, bx, by);
    var numx = det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
    var numy = det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);

    out.x = cx - numx / denom;
    out.y = cy + numy / denom;

    return out;
};

module.exports = CircumCenter;


/***/ }),
/* 669 */
/***/ (function(module, exports) {

//  Adapted from https://gist.github.com/mutoo/5617691

var CircumCircle = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0, radius: 0 }; }

    //  A
    var x1 = triangle.x1;
    var y1 = triangle.y1;

    //  B
    var x2 = triangle.x2;
    var y2 = triangle.y2;

    //  C
    var x3 = triangle.x3;
    var y3 = triangle.y3;

    var A = x2 - x1;
    var B = y2 - y1;
    var C = x3 - x1;
    var D = y3 - y1;
    var E = A * (x1 + x2) + B * (y1 + y2);
    var F = C * (x1 + x3) + D * (y1 + y3);
    var G = 2 * (A * (y3 - y2) - B * (x3 - x2));

    var dx;
    var dy;

    //  If the points of the triangle are collinear, then just find the
    //  extremes and use the midpoint as the center of the circumcircle.

    if (Math.abs(G) < 0.000001)
    {
        var minX = Math.min(x1, x2, x3);
        var minY = Math.min(y1, y2, y3);
        dx = (Math.max(x1, x2, x3) - minX) * 0.5;
        dy = (Math.max(y1, y2, y3) - minY) * 0.5;

        out.x = minX + dx;
        out.y = minY + dy;
        out.radius = Math.sqrt(dx * dx + dy * dy);
    }
    else
    {
        out.x = (D * E - B * F) / G;
        out.y = (A * F - C * E) / G;
        dx = out.x - x1;
        dy = out.y - y1;
        out.radius = Math.sqrt(dx * dx + dy * dy);
    }

    return out;
};

module.exports = CircumCircle;


/***/ }),
/* 670 */
/***/ (function(module, exports, __webpack_require__) {

var Triangle = __webpack_require__(40);

var Clone = function (source)
{
    return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
};

module.exports = Clone;


/***/ }),
/* 671 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(51);

var ContainsPoint = function (triangle, point)
{
    return Contains(triangle, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ }),
/* 672 */
/***/ (function(module, exports) {

var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
};

module.exports = CopyFrom;


/***/ }),
/* 673 */
/***/ (function(module, exports) {

var Equals = function (triangle, toCompare)
{
    return (
        triangle.x1 === toCompare.x1 &&
        triangle.y1 === toCompare.y1 &&
        triangle.x2 === toCompare.x2 &&
        triangle.y2 === toCompare.y2 &&
        triangle.x3 === toCompare.x3 &&
        triangle.y3 === toCompare.y3
    );
};

module.exports = Equals;


/***/ }),
/* 674 */
/***/ (function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(99);
var InCenter = __webpack_require__(162);

var Rotate = function (triangle, angle)
{
    var point = InCenter(triangle);

    return RotateAroundXY(triangle, point.x, point.y, angle);
};

module.exports = Rotate;


/***/ }),
/* 675 */
/***/ (function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(99);

var RotateAroundPoint = function (triangle, point, angle)
{
    return RotateAroundXY(triangle, point.x, point.y, angle);
};

module.exports = RotateAroundPoint;


/***/ }),
/* 676 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Triangle

var Triangle = __webpack_require__(40);

Triangle.Area = __webpack_require__(663);
Triangle.BuildEquilateral = __webpack_require__(664);
Triangle.BuildFromPolygon = __webpack_require__(665);
Triangle.BuildRight = __webpack_require__(666);
Triangle.CenterOn = __webpack_require__(667);
Triangle.Centroid = __webpack_require__(160);
Triangle.CircumCenter = __webpack_require__(668);
Triangle.CircumCircle = __webpack_require__(669);
Triangle.Clone = __webpack_require__(670);
Triangle.Contains = __webpack_require__(51);
Triangle.ContainsArray = __webpack_require__(98);
Triangle.ContainsPoint = __webpack_require__(671);
Triangle.CopyFrom = __webpack_require__(672);
Triangle.Decompose = __webpack_require__(161);
Triangle.Equals = __webpack_require__(673);
Triangle.InCenter = __webpack_require__(162);
Triangle.Offset = __webpack_require__(163);
Triangle.Random = __webpack_require__(164);
Triangle.Rotate = __webpack_require__(674);
Triangle.RotateAroundPoint = __webpack_require__(675);
Triangle.RotateAroundXY = __webpack_require__(99);

module.exports = Triangle;


/***/ }),
/* 677 */
/***/ (function(module, exports) {

/**
* Takes the average of the source and backdrop colors.
*/
var Average = function (a, b)
{
    return (a + b) / 2;
};

module.exports = Average;


/***/ }),
/* 678 */
/***/ (function(module, exports) {

/**
* Subtracts the darker of the two constituent colors from the lighter.
* 
* Painting with white inverts the backdrop color; painting with black produces no change. 
*/
var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ }),
/* 679 */
/***/ (function(module, exports) {

/**
* Produces an effect similar to that of the Difference mode, but lower in contrast. 
* Painting with white inverts the backdrop color; painting with black produces no change. 
*/
var Exclusion =  function (a, b)
{
    return a + b - 2 * a * b / 255;
};

module.exports = Exclusion;


/***/ }),
/* 680 */
/***/ (function(module, exports, __webpack_require__) {

var Reflect = __webpack_require__(173);

/**
* Glow blend mode. This mode is a variation of reflect mode with the source and backdrop colors swapped.
*/
var Glow = function (a, b)
{
    return Reflect(b, a);
};

module.exports = Glow;


/***/ }),
/* 681 */
/***/ (function(module, exports, __webpack_require__) {

var Overlay = __webpack_require__(172);

/**
* Multiplies or screens the colors, depending on the source color value. 
* 
* If the source color is lighter than 0.5, the backdrop is lightened, as if it were screened; 
* this is useful for adding highlights to a scene. 
* 
* If the source color is darker than 0.5, the backdrop is darkened, as if it were multiplied; 
* this is useful for adding shadows to a scene. 
* 
* The degree of lightening or darkening is proportional to the difference between the source color and 0.5; 
* if it is equal to 0.5, the backdrop is unchanged.
* 
* Painting with pure black or white produces pure black or white. The effect is similar to shining a harsh spotlight on the backdrop. 
*/
var HardLight = function (a, b)
{
    return Overlay(b, a);
};

module.exports = HardLight;


/***/ }),
/* 682 */
/***/ (function(module, exports, __webpack_require__) {

var VividLight = __webpack_require__(175);

/**
* Runs blendVividLight on the source and backdrop colors.
* If the resulting color is 128 or more, it receives a value of 255; if less than 128, a value of 0.
* Therefore, all blended pixels have red, green, and blue channel values of either 0 or 255.
* This changes all pixels to primary additive colors (red, green, or blue), white, or black.
*/
var HardMix = function (a, b)
{
    return (VividLight(a, b) < 128) ? 0 : 255;
};

module.exports = HardMix;


/***/ }),
/* 683 */
/***/ (function(module, exports, __webpack_require__) {

var LinearBurn = __webpack_require__(170);
var LinearDodge = __webpack_require__(171);

/**
* This blend mode combines Linear Dodge and Linear Burn (rescaled so that neutral colors become middle gray).
* Dodge applies to values of top layer lighter than middle gray, and burn to darker values.
* The calculation simplifies to the sum of bottom layer and twice the top layer, subtract 128. The contrast decreases.
*/
var LinearLight = function (a, b)
{
    return (b < 128) ? LinearBurn(a, 2 * b) : LinearDodge(a, (2 * (b - 128)));
};

module.exports = LinearLight;


/***/ }),
/* 684 */
/***/ (function(module, exports) {

/**
* Multiplies the backdrop and source color values.
* The result color is always at least as dark as either of the two constituent
* colors. Multiplying any color with black produces black;
* multiplying with white leaves the original color unchanged.
*/
var Multiply = function (a, b)
{
    return (a * b) / 255;
};

module.exports = Multiply;


/***/ }),
/* 685 */
/***/ (function(module, exports) {

/**
* Negation blend mode.
*/
var Negation = function (a, b)
{
    return 255 - Math.abs(255 - a - b);
};

module.exports = Negation;


/***/ }),
/* 686 */
/***/ (function(module, exports) {

/**
* Blends the source color, ignoring the backdrop.
*/
var Normal = function (a)
{
    return a;
};

module.exports = Normal;


/***/ }),
/* 687 */
/***/ (function(module, exports) {

/**
* Phoenix blend mode. This subtracts the lighter color from the darker color, and adds 255, giving a bright result.
*/
var Phoenix = function (a, b)
{
    return Math.min(a, b) - Math.max(a, b) + 255;
};

module.exports = Phoenix;


/***/ }),
/* 688 */
/***/ (function(module, exports, __webpack_require__) {

var Darken = __webpack_require__(168);
var Lighten = __webpack_require__(169);

/**
* If the backdrop color (light source) is lighter than 50%, the blendDarken mode is used, and colors lighter than the backdrop color do not change.
* If the backdrop color is darker than 50% gray, colors lighter than the blend color are replaced, and colors darker than the blend color do not change.
*/
var PinLight = function (a, b)
{
    return (b < 128) ? Darken(a, 2 * b) : Lighten(a, (2 * (b - 128)));
};

module.exports = PinLight;


/***/ }),
/* 689 */
/***/ (function(module, exports) {

/**
* Multiplies the complements of the backdrop and source color values, then complements the result.
* The result color is always at least as light as either of the two constituent colors. 
* Screening any color with white produces white; screening with black leaves the original color unchanged. 
*/
var Screen = function (a, b)
{
    return 255 - (((255 - a) * (255 - b)) >> 8);
};

module.exports = Screen;


/***/ }),
/* 690 */
/***/ (function(module, exports) {

/**
* Darkens or lightens the colors, depending on the source color value. 
* 
* If the source color is lighter than 0.5, the backdrop is lightened, as if it were dodged; 
* this is useful for adding highlights to a scene. 
* 
* If the source color is darker than 0.5, the backdrop is darkened, as if it were burned in. 
* The degree of lightening or darkening is proportional to the difference between the source color and 0.5; 
* if it is equal to 0.5, the backdrop is unchanged.
* 
* Painting with pure black or white produces a distinctly darker or lighter area, but does not result in pure black or white. 
* The effect is similar to shining a diffused spotlight on the backdrop. 
*/
var SoftLight = function (a, b)
{
    return (b < 128) ? (2 * ((a >> 1) + 64)) * (b / 255) : 255 - (2 * (255 - ((a >> 1) + 64)) * (255 - b) / 255);
};

module.exports = SoftLight;


/***/ }),
/* 691 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Graphics.BlendModes

module.exports = {

    Add: __webpack_require__(165),
    Average: __webpack_require__(677),
    ColorBurn: __webpack_require__(166),
    ColorDodge: __webpack_require__(167),
    Darken: __webpack_require__(168),
    Difference: __webpack_require__(678),
    Exclusion: __webpack_require__(679),
    Glow: __webpack_require__(680),
    HardLight: __webpack_require__(681),
    HardMix: __webpack_require__(682),
    Lighten: __webpack_require__(169),
    LinearBurn: __webpack_require__(170),
    LinearDodge: __webpack_require__(171),
    LinearLight: __webpack_require__(683),
    Multiply: __webpack_require__(684),
    Negation: __webpack_require__(685),
    Normal: __webpack_require__(686),
    Overlay: __webpack_require__(172),
    Phoenix: __webpack_require__(687),
    PinLight: __webpack_require__(688),
    Reflect: __webpack_require__(173),
    Screen: __webpack_require__(689),
    SoftLight: __webpack_require__(690),
    Subtract: __webpack_require__(174),
    VividLight: __webpack_require__(175)
    
};


/***/ }),
/* 692 */
/***/ (function(module, exports, __webpack_require__) {

var Color = __webpack_require__(33);

var CSSMap = {
    aliceblue: [ 240, 248, 245 ],
    antiquewhite: [ 250, 235, 215 ],
    aqua: [ 0, 255, 255 ],
    aquamarine: [ 127, 255, 212 ],
    azure: [ 240, 255, 255 ],
    beige: [ 245, 245, 220 ],
    bisque: [ 255, 228, 196 ],
    black: [ 0, 0, 0 ],
    blanchedalmond: [ 255, 235, 205 ],
    blue: [ 0, 0, 255 ],
    blueviolet: [ 138, 43, 226 ],
    brown: [ 165, 42, 42 ],
    burlywood: [ 222, 184, 35 ],
    cadetblue: [ 95, 158, 160 ],
    chartreuse: [ 127, 255, 0 ],
    chocolate: [ 210, 105, 30 ],
    coral: [ 255, 127, 80 ],
    cornflowerblue: [ 100, 149, 237 ],
    cornsilk: [ 255, 248, 220 ],
    crimson: [ 220, 20, 60 ],
    darkblue: [ 0, 0, 139 ],
    darkcyan: [ 0, 139, 139 ],
    darkgoldenrod: [ 184, 134, 11 ],
    darkgray: [ 169, 169, 169 ],
    darkgreen: [ 0, 100, 0 ],
    darkgrey: [ 169, 169, 169 ],
    darkkhaki: [ 189, 183, 107 ],
    darkmagenta: [ 139, 0, 139 ],
    darkolivegreen: [ 85, 107, 47 ],
    darkorange: [ 255, 140, 0 ],
    darkorchid: [ 153, 50, 204 ],
    darkred: [ 139, 0, 0 ],
    darksalmon: [ 233, 150, 122 ],
    darkseagreen: [ 143, 188, 143 ],
    darkslateblue: [ 72, 61, 139 ],
    darkslategray: [ 47, 79, 79 ],
    darkslategrey: [ 47, 79, 79 ],
    darkturquoise: [ 0, 206, 209 ],
    darkviolet: [ 148, 0, 211 ],
    deeppink: [ 255, 20, 147 ],
    deepskyblue: [ 0, 191, 255 ],
    dimgray: [ 105, 105, 105 ],
    dimgrey: [ 105, 105, 105 ],
    dodgerblue: [ 30, 144, 255 ],
    firebrick: [ 178, 34, 34 ],
    floralwhite: [ 255, 250, 240 ],
    forestgreen: [ 34, 139, 34 ],
    fuchsia: [ 255, 0, 255 ],
    gainsboro: [ 220, 220, 220 ],
    ghostwhite: [ 248, 248, 255 ],
    gold: [ 255, 215, 0 ],
    goldenrod: [ 218, 165, 32 ],
    gray: [ 128, 128, 128 ],
    green: [ 0, 128, 0 ],
    greenyellow: [ 173, 255, 47 ],
    grey: [ 128, 128, 128 ],
    honeydew: [ 240, 255, 240 ],
    hotpink: [ 255, 105, 180 ],
    indianred: [ 205, 92, 92 ],
    indigo: [ 75, 0, 130 ],
    ivory: [ 255, 255, 240 ],
    khaki: [ 240, 230, 140 ],
    lavender: [ 230, 230, 250 ],
    lavenderblush: [ 255, 240, 245 ],
    lawngreen: [ 124, 252, 0 ],
    lemonchiffon: [ 255, 250, 205 ],
    lightblue: [ 173, 216, 230 ],
    lightcoral: [ 240, 128, 128 ],
    lightcyan: [ 224, 255, 255 ],
    lightgoldenrodyellow: [ 250, 250, 210 ],
    lightgray: [ 211, 211, 211 ],
    lightgreen: [ 144, 238, 144 ],
    lightgrey: [ 211, 211, 211 ],
    lightpink: [ 255, 182, 193 ],
    lightsalmon: [ 255, 160, 122 ],
    lightseagreen: [ 32, 178, 170 ],
    lightskyblue: [ 135, 206, 250 ],
    lightslategray: [ 119, 136, 153 ],
    lightslategrey: [ 119, 136, 153 ],
    lightsteelblue: [ 176, 196, 222 ],
    lightyellow: [ 255, 255, 224 ],
    lime: [ 0, 255, 0 ],
    limegreen: [ 50, 205, 50 ],
    linen: [ 250, 240, 230 ],
    maroon: [ 128, 0, 0 ],
    mediumaquamarine: [ 102, 205, 170 ],
    mediumblue: [ 0, 0, 205 ],
    mediumorchid: [ 186, 85, 211 ],
    mediumpurple: [ 147, 112, 219 ],
    mediumseagreen: [ 60, 179, 113 ],
    mediumslateblue: [ 123, 104, 238 ],
    mediumspringgreen: [ 0, 250, 154 ],
    mediumturquoise: [ 72, 209, 204 ],
    mediumvioletred: [ 199, 21, 133 ],
    midnightblue: [ 25, 25, 112 ],
    mintcream: [ 245, 255, 250 ],
    mistyrose: [ 255, 228, 225 ],
    moccasin: [ 255, 228, 181 ],
    navajowhite: [ 255, 222, 173 ],
    navy: [ 0, 0, 128 ],
    oldlace: [ 253, 245, 230 ],
    olive: [ 128, 128, 0 ],
    olivedrab: [ 107, 142, 35 ],
    orange: [ 255, 165, 0 ],
    orangered: [ 255, 69, 0 ],
    orchid: [ 218, 112, 214 ],
    palegoldenrod: [ 238, 232, 170 ],
    palegreen: [ 152, 251, 152 ],
    paleturquoise: [ 175, 238, 238 ],
    palevioletred: [ 219, 112, 147 ],
    papayawhip: [ 255, 239, 213 ],
    peachpuff: [ 255, 218, 185 ],
    peru: [ 205, 133, 63 ],
    pink: [ 255, 192, 203 ],
    plum: [ 221, 160, 221 ],
    powderblue: [ 176, 224, 230 ],
    purple: [ 128, 0, 128 ],
    rebeccapurple: [ 102, 51, 153 ],
    red: [ 255, 0, 0 ],
    rosybrown: [ 188, 143, 143 ],
    royalblue: [ 65, 105, 225 ],
    saddlebrown: [ 139, 69, 19 ],
    salmon: [ 250, 128, 114 ],
    sandybrown: [ 244, 164, 96 ],
    seagreen: [ 46, 139, 87 ],
    seashell: [ 255, 245, 238 ],
    sienna: [ 160, 82, 45 ],
    silver: [ 192, 192, 129 ],
    skyblue: [ 135, 206, 235 ],
    slateblue: [ 106, 90, 205 ],
    slategray: [ 112, 128, 144 ],
    slategrey: [ 112, 128, 144 ],
    snow: [ 255, 250, 250 ],
    springgreen: [ 0, 255, 127 ],
    steelblue: [ 70, 130, 180 ],
    tan: [ 210, 180, 140 ],
    teal: [ 0, 128, 128 ],
    thistle: [ 216, 191, 216 ],
    tomato: [ 255, 99, 71 ],
    turquoise: [ 64, 224, 208 ],
    violet: [ 238, 130, 238 ],
    wheat: [ 245, 222, 179 ],
    white: [ 255, 255, 255 ],
    whitesmoke: [ 245, 245, 245 ],
    yellow: [ 255, 255, 0 ],
    yellowgreen: [ 154, 205, 50 ]
};

var CSSToColor = function (name)
{
    name = name.toLowerCase();

    var color = new Color();
    var entry = CSSMap[name];

    if (entry)
    {
        color.setTo(entry[0], entry[1], entry[2], 255);
    }

    return color;
};

module.exports = CSSToColor;


/***/ }),
/* 693 */
/***/ (function(module, exports) {

var ColorToRGBA = function (color)
{
    var output = {
        r: color >> 16 & 0xFF,
        g: color >> 8 & 0xFF,
        b: color & 0xFF,
        a: 255
    };

    if (color > 16777215)
    {
        output.a = color >>> 24;
    }

    return output;
};

module.exports = ColorToRGBA;


/***/ }),
/* 694 */
/***/ (function(module, exports, __webpack_require__) {

var Color = __webpack_require__(33);
var HueToComponent = __webpack_require__(180);

var HSLToColor = function (h, s, l)
{
    // achromatic by default
    var r = l;
    var g = l;
    var b = l;

    if (s !== 0)
    {
        var q = (l < 0.5) ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = HueToComponent(p, q, h + 1 / 3);
        g = HueToComponent(p, q, h);
        b = HueToComponent(p, q, h - 1 / 3);
    }

    var color = new Color();

    return color.setGLTo(r, g, b, 1);
};

module.exports = HSLToColor;


/***/ }),
/* 695 */
/***/ (function(module, exports, __webpack_require__) {

var HSVToRGB = __webpack_require__(178);

/**
* Get HSV color wheel values in an array which will be 360 elements in size.
*/
var HSVColorWheel = function (s, v)
{
    if (s === undefined) { s = 1; }
    if (v === undefined) { v = 1; }

    var colors = [];

    for (var c = 0; c <= 359; c++)
    {
        colors.push(HSVToRGB(c / 359, s, v));
    }

    return colors;
};

module.exports = HSVColorWheel;


/***/ }),
/* 696 */
/***/ (function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(225);

var RGBWithRGB = function (r1, g1, b1, r2, g2, b2, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    var t = index / length;

    return {
        r: Linear(r1, r2, t),
        g: Linear(g1, g2, t),
        b: Linear(b1, b2, t)
    };
};

var ColorWithColor = function (color1, color2, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index);
};

var ColorWithRGB = function (color, r, g, b, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    return RGBWithRGB(color.r, color.g, color.b, r, g, b, length, index);
};

module.exports = {

    RGBWithRGB: RGBWithRGB,
    ColorWithRGB: ColorWithRGB,
    ColorWithColor: ColorWithColor

};


/***/ }),
/* 697 */
/***/ (function(module, exports) {

/**
* Converts an RGB color value to HSV (hue, saturation and value).
* Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
* Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].
* Based on code by Michael Jackson (https://github.com/mjijackson)
*/
var RGBToHSV = function (r, g, b)
{
    r /= 255;
    g /= 255;
    b /= 255;

    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var d = max - min;

    // achromatic by default
    var h = 0;
    var s = (max === 0) ? 0 : d / max;
    var v = max;

    if (max !== min)
    {
        if (max === r)
        {
            h = (g - b) / d + ((g < b) ? 6 : 0);
        }
        else if (max === g)
        {
            h = (b - r) / d + 2;
        }
        else if (max === b)
        {
            h = (r - g) / d + 4;
        }

        h /= 6;
    }

    return { h: h, s: s, v: v };
};

module.exports = RGBToHSV;


/***/ }),
/* 698 */
/***/ (function(module, exports, __webpack_require__) {

var ComponentToHex = __webpack_require__(176);

var RGBToString = function (r, g, b, a, prefix)
{
    if (a === undefined) { a = 255; }
    if (prefix === undefined) { prefix = '#'; }

    if (prefix === '#')
    {
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    else
    {
        return '0x' + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
    }
};

module.exports = RGBToString;


/***/ }),
/* 699 */
/***/ (function(module, exports, __webpack_require__) {

var Between = __webpack_require__(65);

var RandomRGB = function (min, max)
{
    if (min === undefined) { min = 0; }
    if (max === undefined) { max = 255; }

    return {
        r: Between(min, max),
        g: Between(min, max),
        b: Between(min, max)
    };
};

module.exports = RandomRGB;


/***/ }),
/* 700 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Graphics.Color

var Color = __webpack_require__(33);

Color.ColorToRGBA = __webpack_require__(693);
Color.ComponentToHex = __webpack_require__(176);
Color.CSSToColor = __webpack_require__(692);
Color.GetColor = __webpack_require__(100);
Color.GetColor32 = __webpack_require__(177);
Color.HexStringToColor = __webpack_require__(179);
Color.HSLToColor = __webpack_require__(694);
Color.HSVColorWheel = __webpack_require__(695);
Color.HSVToRGB = __webpack_require__(178);
Color.HueToComponent = __webpack_require__(180);
Color.IntegerToColor = __webpack_require__(181);
Color.IntegerToRGB = __webpack_require__(182);
Color.Interpolate = __webpack_require__(696);
Color.RandomRGB = __webpack_require__(699);
Color.RGBStringToColor = __webpack_require__(183);
Color.RGBToHSV = __webpack_require__(697);
Color.RGBToString = __webpack_require__(698);
Color.ValueToColor = __webpack_require__(63);

module.exports = Color;


/***/ }),
/* 701 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Pointer

var Class = __webpack_require__(0);

//  DOM event button value:
// A number representing a given button:
// 0: Main button pressed, usually the left button or the un-initialized state
// 1: Auxiliary button pressed, usually the wheel button or the middle button (if present)
// 2: Secondary button pressed, usually the right button
// 3: Fourth button, typically the Browser Back button
// 4: Fifth button, typically the Browser Forward button
// For a mouse configured for left-handed use, the button actions are reversed. In this case, the values are read from right to left.

var Pointer = new Class({

    initialize:

    function Pointer (manager, id)
    {
        this.manager = manager;

        this.id = id;

        this.event;

        //  The camera the Pointer interacted with during its last update
        //  A Pointer can only ever interact with 1 camera at once, which will be the top-most camera
        //  in the list should multiple cameras be positioned on-top of each other.
        this.camera = null;

        // 0  : No button or un-initialized
        // 1  : Left button
        // 2  : Right button
        // 4  : Wheel button or middle button
        // 8  : 4th button (typically the "Browser Back" button)
        // 16 : 5th button (typically the "Browser Forward" button)
        this.buttons = 0;

        this.x = 0;
        this.y = 0;

        //  Coordinates and time of the pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects
        this.downX = 0;
        this.downY = 0;
        this.downTime = 0;

        //  Coordinates and time of the pointer when Button 1 (left button), or Touch, was released, used for dragging objects
        this.upX = 0;
        this.upY = 0;
        this.upTime = 0;

        //  Is the primary button down? (usually button 0, the left mouse button)
        this.primaryDown = false;

        //  0 = Not dragging anything
        //  1 = Being checked if dragging
        //  2 = Dragging something
        this.dragState = 0;

        //  Is *any* button on this pointer considered as being down?
        this.isDown = false;

        this.dirty = false;

        this.justDown = false;
        this.justUp = false;
        this.justMoved = false;
    },

    reset: function ()
    {
        this.buttons = 0;

        this.dirty = false;
        this.isDown = false;
        this.justDown = false;
        this.justUp = false;
        this.justMoved = false;
    },

    touchmove: function (event, time)
    {
        this.event = event;

        this.x = this.manager.transformX(event.changedTouches[0].pageX);
        this.y = this.manager.transformY(event.changedTouches[0].pageY);

        this.justMoved = true;

        this.dirty = true;
    },

    move: function (event, time)
    {
        if (event.buttons)
        {
            this.buttons = event.buttons;
        }

        this.event = event;

        this.x = this.manager.transformX(event.pageX);
        this.y = this.manager.transformY(event.pageY);

        this.justMoved = true;

        this.dirty = true;
    },

    down: function (event, time)
    {
        if (event.buttons)
        {
            this.buttons = event.buttons;
        }

        this.event = event;

        this.x = this.manager.transformX(event.pageX);
        this.y = this.manager.transformY(event.pageY);

        //  0: Main button pressed, usually the left button or the un-initialized state
        if (event.button === 0)
        {
            this.primaryDown = true;
            this.downX = this.x;
            this.downY = this.y;
            this.downTime = time;
        }

        this.justDown = true;
        this.isDown = true;

        this.dirty = true;
    },

    touchstart: function (event, time)
    {
        this.buttons = 1;

        this.event = event;

        this.x = this.manager.transformX(event.changedTouches[0].pageX);
        this.y = this.manager.transformY(event.changedTouches[0].pageY);

        this.primaryDown = true;
        this.downX = this.x;
        this.downY = this.y;
        this.downTime = time;

        this.justDown = true;
        this.isDown = true;

        this.dirty = true;
    },

    up: function (event, time)
    {
        if (event.buttons)
        {
            this.buttons = event.buttons;
        }

        this.event = event;

        this.x = this.manager.transformX(event.pageX);
        this.y = this.manager.transformY(event.pageY);

        //  0: Main button pressed, usually the left button or the un-initialized state
        if (event.button === 0)
        {
            this.primaryDown = false;
            this.upX = this.x;
            this.upY = this.y;
            this.upTime = time;
        }

        this.justUp = true;
        this.isDown = false;

        this.dirty = true;
    },

    touchend: function (event, time)
    {
        this.buttons = 0;

        this.event = event;

        this.x = this.manager.transformX(event.changedTouches[0].pageX);
        this.y = this.manager.transformY(event.changedTouches[0].pageY);

        this.primaryDown = false;
        this.upX = this.x;
        this.upY = this.y;
        this.upTime = time;

        this.justUp = true;
        this.isDown = false;

        this.dirty = true;
    },

    noButtonDown: function ()
    {
        return (this.buttons === 0);
    },

    leftButtonDown: function ()
    {
        return (this.buttons & 1);
    },

    rightButtonDown: function ()
    {
        return (this.buttons & 2);
    },

    middleButtonDown: function ()
    {
        return (this.buttons & 4);
    },

    backButtonDown: function ()
    {
        return (this.buttons & 8);
    },

    forwardButtonDown: function ()
    {
        return (this.buttons & 16);
    }

});

module.exports = Pointer;


/***/ }),
/* 702 */
/***/ (function(module, exports) {

//  Tatar SNES USB Controller
//  USB Gamepad  (STANDARD GAMEPAD Vendor: 0079 Product: 0011)

module.exports = {

    UP: 12,
    DOWN: 13,
    LEFT: 14,
    RIGHT: 15,

    SELECT: 8,
    START: 9,

    B: 0,
    A: 1,
    Y: 2,
    X: 3,

    LEFT_SHOULDER: 4,
    RIGHT_SHOULDER: 5

};


/***/ }),
/* 703 */
/***/ (function(module, exports) {

//  Sony PlayStation DualShock 4 (v2) wireless controller

module.exports = {

    UP: 12,
    DOWN: 13,
    LEFT: 14,
    RIGHT: 15,

    SHARE: 8,
    OPTIONS: 9,
    PS: 16,
    TOUCHBAR: 17,

    X: 0,
    CIRCLE: 1,
    SQUARE: 2,
    TRIANGLE: 3,

    L1: 4,
    R1: 5,
    L2: 6,
    R2: 7,
    L3: 10,
    R3: 11,

    LEFT_STICK_H: 0,
    LEFT_STICK_V: 1,
    RIGHT_STICK_H: 2,
    RIGHT_STICK_V: 3

};


/***/ }),
/* 704 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Gamepad.Configs

module.exports = {

    DUALSHOCK_4: __webpack_require__(703),
    SNES_USB: __webpack_require__(702)

};


/***/ }),
/* 705 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var GamepadConnectedEvent = new Class({

    Extends: Event,

    initialize:

    function GamepadConnectedEvent (gamepad, nativeEvent)
    {
        Event.call(this, 'GAMEPAD_CONNECTED_EVENT');

        this.data = nativeEvent;

        this.gamepad = gamepad;
    }

});

module.exports = GamepadConnectedEvent;


/***/ }),
/* 706 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var GamepadDisconnectedEvent = new Class({

    Extends: Event,

    initialize:

    function GamepadDisconnectedEvent (gamepad, nativeEvent)
    {
        Event.call(this, 'GAMEPAD_DISCONNECTED_EVENT');

        this.data = nativeEvent;

        this.gamepad = gamepad;
    }

});

module.exports = GamepadDisconnectedEvent;


/***/ }),
/* 707 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var GamepadDownEvent = new Class({

    Extends: Event,

    initialize:

    function GamepadDownEvent (gamepad, button, value, nativeEvent)
    {
        Event.call(this, 'GAMEPAD_DOWN_EVENT');

        this.data = nativeEvent;

        this.gamepad = gamepad;
        this.button = button;
        this.value = value;
    }

});

module.exports = GamepadDownEvent;


/***/ }),
/* 708 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var GamepadUpEvent = new Class({

    Extends: Event,

    initialize:

    function GamepadUpEvent (gamepad, button, value, nativeEvent)
    {
        Event.call(this, 'GAMEPAD_UP_EVENT');

        this.data = nativeEvent;

        this.gamepad = gamepad;
        this.button = button;
        this.value = value;
    }

});

module.exports = GamepadUpEvent;


/***/ }),
/* 709 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Gamepad

module.exports = {

    Axis: __webpack_require__(185),
    Button: __webpack_require__(186),
    Gamepad: __webpack_require__(187),
    GamepadManager: __webpack_require__(188),
    
    Configs: __webpack_require__(704)
};


/***/ }),
/* 710 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.GlobalInputManager

var Class = __webpack_require__(0);
var EventDispatcher = __webpack_require__(30);
var Gamepad = __webpack_require__(188);
var GetTransformedPoint = __webpack_require__(101);
var HitTest = __webpack_require__(711);
var Keyboard = __webpack_require__(190);
var Mouse = __webpack_require__(194);
var MouseEvent = __webpack_require__(783);
var Pointer = __webpack_require__(701);
var PointScreenToWorldHitTest = __webpack_require__(712);
var PointWithinGameObject = __webpack_require__(189);
var Touch = __webpack_require__(785);
var TransformMatrix = __webpack_require__(17);

var GlobalInputManager = new Class({

    initialize:

    function GlobalInputManager (game, config)
    {
        this.game = game;

        this.canvas;

        this.config = config;

        this.enabled = true;

        this.events = new EventDispatcher();

        //   Standard FIFO queue
        this.queue = [];

        //  Listeners (will be based on config)
        this.keyboard = new Keyboard(this);
        this.mouse = new Mouse(this);
        this.touch = new Touch(this);
        this.gamepad = new Gamepad(this);

        this.activePointer = new Pointer(this, 0);

        this.scale = { x: 1, y: 1 };

        this._tempMatrix = new TransformMatrix();
        this._tempPoint = { x: 0, y: 0 };
        this._tempHitTest = [];
    },

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    */
    boot: function ()
    {
        this.canvas = this.game.canvas;

        this.keyboard.boot();
        this.mouse.boot();
        this.touch.boot();
        this.gamepad.boot();
    },

    update: function (time, delta)
    {
        this.keyboard.update();
        this.gamepad.update();

        var len = this.queue.length;

        //  Currently just 1 pointer supported
        var pointer = this.activePointer;

        pointer.reset();

        if (!this.enabled || len === 0)
        {
            return;
        }

        this.scale.x = this.game.config.width / this.canvas.offsetWidth;
        this.scale.y = this.game.config.height / this.canvas.offsetHeight;

        //  Clears the queue array, and also means we don't work on array data that could potentially
        //  be modified during the processing phase
        var queue = this.queue.splice(0, len);

        //  Process the event queue, dispatching all of the events that have stored up
        for (var i = 0; i < len; i++)
        {
            var event = queue[i];

            //  TODO: Move to CONSTs so we can do integer comparisons instead of strings.
            //  TODO: Remove the MouseEvent events. Devs should use Pointer events instead.
            switch (event.type)
            {
                case 'mousemove':

                    pointer.move(event, time);
                    this.events.dispatch(new MouseEvent.MOVE(event));
                    break;

                case 'mousedown':

                    pointer.down(event, time);
                    this.events.dispatch(new MouseEvent.DOWN(event));
                    break;

                case 'mouseup':

                    pointer.up(event, time);
                    this.events.dispatch(new MouseEvent.UP(event));
                    break;

                case 'touchmove':

                    pointer.touchmove(event, time);
                    break;

                case 'touchstart':

                    pointer.touchstart(event, time);
                    break;

                case 'touchend':

                    pointer.touchend(event, time);
                    break;
            }
        }
    },

    getTransformedPoint: function (gameObject, x, y)
    {
        return GetTransformedPoint(this._tempMatrix, gameObject, x, y, this._tempPoint);
    },

    pointWithinGameObject: function (gameObject, x, y)
    {
        return PointWithinGameObject(gameObject, x, y);
    },

    hitTest: function (gameObjects, x, y, camera)
    {
        return HitTest(this._tempMatrix, x, y, gameObjects, camera, this._tempHitTest);
    },

    pointScreenToWorldHitTest: function (gameObjects, x, y, camera)
    {
        return PointScreenToWorldHitTest(this._tempMatrix, x, y, gameObjects, camera, this._tempHitTest);
    },

    transformX: function (pageX)
    {
        return (pageX - this.canvas.offsetLeft) * this.scale.x;
    },

    transformY: function (pageY)
    {
        return (pageY - this.canvas.offsetTop) * this.scale.y;
    },

    getOffsetX: function ()
    {
        return this.canvas.offsetLeft;
    },

    getOffsetY: function ()
    {
        return this.canvas.offsetTop;
    },

    getScaleX: function ()
    {
        return this.game.config.width / this.canvas.offsetWidth;
    },

    getScaleY: function ()
    {
        return this.game.config.height / this.canvas.offsetHeight;
    }

});

module.exports = GlobalInputManager;


/***/ }),
/* 711 */
/***/ (function(module, exports, __webpack_require__) {

var GetTransformedPoint = __webpack_require__(101);
var PointWithinHitArea = __webpack_require__(713);

//  Will always return an array.
//  Array contains matching Interactive Objects.
//  Array will be empty if no objects were matched.

var HitTest = function (tempMatrix, x, y, gameObjects, camera, output)
{
    var cameraW = camera.width;
    var cameraH = camera.height;

    output.length = 0;

    if (!(x >= camera.x && y >= camera.y && x <= camera.x + cameraW && y <= camera.y + cameraH))
    {
        return output;
    }

    var screenPoint = camera.cameraToScreen({ x: x, y: y });
    var culledGameObjects = camera.cull(gameObjects);

    for (var i = 0; i < culledGameObjects.length; i++)
    {
        var gameObject = culledGameObjects[i];

        if (!gameObject.input.enabled || !gameObject.willRender())
        {
            continue;
        }

        var point = GetTransformedPoint(
            tempMatrix,
            gameObject,
            screenPoint.x + camera.scrollX * gameObject.scrollFactorX,
            screenPoint.y + camera.scrollY * gameObject.scrollFactorY
        );
   
        if (PointWithinHitArea(gameObject, point.x, point.y, camera))
        {
            output.push(gameObject);
        }
    }

    return output;
};

module.exports = HitTest;


/***/ }),
/* 712 */
/***/ (function(module, exports, __webpack_require__) {

var GetTransformedPoint = __webpack_require__(101);
var PointWithinGameObject = __webpack_require__(189);

//  Will always return an array.
//  Array contains matching Game Objects.
//  Array will be empty if no objects were matched.

var PointScreenToWorldHitTest = function (tempMatrix, x, y, gameObjectArray, camera, output) 
{
    var length = gameObjectArray.length;
    var scrollX = camera.scrollX;
    var scrollY = camera.scrollY;
    var cameraW = camera.width;
    var cameraH = camera.height;

    output.length = 0;

    if (!(x >= camera.x && y >= camera.y &&
        x <= camera.x + cameraW && y <= camera.y + cameraH))
    {
        return output;
    }

    var screenPoint = camera.cameraToScreen({x: x, y: y});

    if (Array.isArray(gameObjectArray))
    {
        var culled = camera.cull(gameObjectArray);
        var culledLength = culled.length;

        for (var index = 0; index < culledLength; ++index)
        {
            var object = culled[index];
            var tpoint = GetTransformedPoint(tempMatrix, object, screenPoint.x + scrollX * object.scrollFactorX, screenPoint.y + scrollY * object.scrollFactorY);

            if (PointWithinGameObject(object, tpoint.x, tpoint.y))
            {
                output.push(object);
            }
        }
    }
    else
    {
        var object = gameObjectArray;

        var tpoint = GetTransformedPoint(tempMatrix, object, screenPoint.x + scrollX * object.scrollFactorX, screenPoint.y + scrollY * object.scrollFactorY);
        
        if (PointWithinGameObject(object, tpoint.x, tpoint.y))
        {
            output.push(object);
        }
    }

    return output;
};

module.exports = PointScreenToWorldHitTest;


/***/ }),
/* 713 */
/***/ (function(module, exports) {

//  x/y MUST be translated before being passed to this function,
//  unless the gameObject is guaranteed to not be rotated or scaled in any way

var PointWithinHitArea = function (gameObject, x, y, camera)
{
    var input = gameObject.input;

    // if (!input)
    // {
    //     return false;
    // }

    //  Normalize the origin
    x += gameObject.displayOriginX;
    y += gameObject.displayOriginY;

    if (input.hitAreaCallback(input.hitArea, x, y, gameObject))
    {
        input.localX = x;
        input.localY = y;

        return true;
    }
    else
    {
        return false;
    }
};

module.exports = PointWithinHitArea;


/***/ }),
/* 714 */
/***/ (function(module, exports) {

//  Return boolean (true if it reached the end of the combo, false if not)

var AdvanceKeyCombo = function (event, combo)
{
    combo.timeLastMatched = event.timeStamp;
    combo.index++;

    if (combo.index === combo.size)
    {
        return true;
    }
    else
    {
        combo.current = combo.keyCodes[combo.index];
        return false;
    }
};

module.exports = AdvanceKeyCombo;


/***/ }),
/* 715 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var KeyComboMatchEvent = new Class({

    Extends: Event,

    initialize:

    function KeyComboMatchEvent (keyCombo, keyboardEvent)
    {
        Event.call(this, 'KEY_COMBO_MATCH_EVENT');

        this.target = keyCombo;

        this.data = keyboardEvent;
    }

});

module.exports = KeyComboMatchEvent;


/***/ }),
/* 716 */
/***/ (function(module, exports) {

var ResetKeyCombo = function (combo)
{
    combo.current = combo.keyCodes[0];
    combo.index = 0;
    combo.timeLastMatched = 0;
    combo.matched = false;
    combo.timeMatched = 0;

    return combo;
};

module.exports = ResetKeyCombo;


/***/ }),
/* 717 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var KeyDownEvent = new Class({

    Extends: Event,

    initialize:

    function KeyDownEvent (keyboardEvent)
    {
        Event.call(this, 'KEY_DOWN_EVENT');

        this.data = keyboardEvent;
    }

});

module.exports = KeyDownEvent;


/***/ }),
/* 718 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var KeyUpEvent = new Class({

    Extends: Event,

    initialize:

    function KeyUpEvent (keyboardEvent)
    {
        Event.call(this, 'KEY_UP_EVENT');

        this.data = keyboardEvent;
    }

});

module.exports = KeyUpEvent;


/***/ }),
/* 719 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(2);
var KeyCodes = __webpack_require__(102);

var events = {
    KEY_DOWN_EVENT: __webpack_require__(717),
    KEY_UP_EVENT: __webpack_require__(718),
    _UP: [],
    _DOWN: []
};

function createKeyEvent (type)
{
    var KeyEvent = function (keyboardEvent)
    {
        Event.call(this, type);

        this.data = keyboardEvent;
    };

    KeyEvent.prototype = Object.create(Event.prototype);
    KeyEvent.prototype.constructor = KeyEvent;

    return KeyEvent;
}

//  Inject the KeyCode events

for (var code in KeyCodes)
{
    //  The Key Down Event Types

    var downType = 'KEY_DOWN_' + code;
    var upType = 'KEY_UP_' + code;

    events._DOWN[KeyCodes[code]] = createKeyEvent(downType);
    events._UP[KeyCodes[code]] = createKeyEvent(upType);

    //  More friendly aliases to the main events
    events[downType] = events._DOWN[KeyCodes[code]];
    events[upType] = events._UP[KeyCodes[code]];
}

module.exports = events;


/***/ }),
/* 720 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Keyboard

module.exports = {

    KeyboardManager: __webpack_require__(190),

    Key: __webpack_require__(193),
    KeyCodes: __webpack_require__(102),

    KeyCombo: __webpack_require__(191),

    JustDown: __webpack_require__(722),
    JustUp: __webpack_require__(723),
    DownDuration: __webpack_require__(721),
    UpDuration: __webpack_require__(726)
    
};


/***/ }),
/* 721 */
/***/ (function(module, exports) {

/**
* Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
* or was pressed down longer ago than then given duration.
*/
var DownDuration = function (key, duration)
{
    if (duration === undefined) { duration = 50; }

    return (key.isDown && key.duration < duration);
};

module.exports = DownDuration;


/***/ }),
/* 722 */
/***/ (function(module, exports) {

/**
* The justDown value allows you to test if this Key has just been pressed down or not.
* When you check this value it will return `true` if the Key is down, otherwise `false`.
* You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.
* This allows you to use it in situations where you want to check if this key is down without using a Signal, such as in a core game loop.
*/
var JustDown = function (key)
{
    var current = false;

    if (key.isDown)
    {
        current = key._justDown;
        key._justDown = false;
    }

    return current;
};

module.exports = JustDown;


/***/ }),
/* 723 */
/***/ (function(module, exports) {

/**
* The justUp value allows you to test if this Key has just been released or not.
* When you check this value it will return `true` if the Key is up, otherwise `false`.
* You can only call justUp once per key release. It will only return `true` once, until the Key is pressed down and released again.
* This allows you to use it in situations where you want to check if this key is up without using a Signal, such as in a core game loop.
*/
var JustUp = function (key)
{
    var current = false;

    if (key.isDown)
    {
        current = key._justUp;
        key._justUp = false;
    }

    return current;
};

module.exports = JustUp;


/***/ }),
/* 724 */
/***/ (function(module, exports) {


var ProcessKeyDown = function (key, event)
{
    key.originalEvent = event;

    if (key.preventDefault)
    {
        event.preventDefault();
    }

    if (!key.enabled)
    {
        return;
    }

    key.altKey = event.altKey;
    key.ctrlKey = event.ctrlKey;
    key.shiftKey = event.shiftKey;
    key.location = event.location;

    key.isDown = true;
    key.isUp = false;
    key.timeDown = event.timeStamp;
    key.duration = 0;
    key.repeats++;

    key._justDown = true;
    key._justUp = false;

    return key;
};

module.exports = ProcessKeyDown;


/***/ }),
/* 725 */
/***/ (function(module, exports) {


var ProcessKeyUp = function (key, event)
{
    key.originalEvent = event;

    if (key.preventDefault)
    {
        event.preventDefault();
    }

    if (!key.enabled)
    {
        return;
    }

    key.isDown = false;
    key.isUp = true;
    key.timeUp = event.timeStamp;
    key.duration = key.timeUp - key.timeDown;
    key.repeats = 0;

    key._justDown = false;
    key._justUp = true;

    return key;
};

module.exports = ProcessKeyUp;


/***/ }),
/* 726 */
/***/ (function(module, exports) {

/**
* Returns `true` if the Key was released within the `duration` value given, or `false` if it either isn't up,
* or was released longer ago than then given duration.
*/
var UpDuration = function (key, duration)
{
    if (duration === undefined) { duration = 50; }

    return (key.isUp && key.duration < duration);
};

module.exports = UpDuration;


/***/ }),
/* 727 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

//  Drag Events
//  https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API
//  Mouse Events
//  https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent

var SceneInputManager = new Class({

    initialize:

    function SceneInputManager (scene)
    {
        //  The Scene that owns this plugin
        this.scene = scene;

        //  GlobalInputManager
        this.manager = scene.sys.game.input;

        //  A reference to this.scene.sys.displayList (set in boot)
        this.displayList;

        //  A reference to the this.scene.sys.cameras (set in boot)
        this.cameras;

        //  Should use Scene event dispatcher?
        this.events = this.manager.events;

        //  Proxy references available via the Scene
        this.keyboard = this.manager.keyboard;
        this.mouse = this.manager.mouse;
        this.gamepad = this.manager.gamepad;

        //  Only fire callbacks and events on the top-most Game Object in the display list (emulating DOM behavior)
        //  and ignore any GOs below it, or call them all?
        this.topOnly = true;

        //  How often should the pointer input be checked?
        //  Time given in ms
        //  Pointer will *always* be checked if it has been moved by the user.
        //  This controls how often it will be polled if it hasn't been moved.
        //  Set to 0 to poll constantly. Set to -1 to only poll on user movement.
        this.pollRate = -1;

        //  Internal counter
        this._pollTimer = 0;

        //  The distance, in pixels, the pointer has to move while being held down, before it thinks it is being dragged.
        this.dragDistanceThreshold = 0;

        //  The amount of time, in ms, the pointer has to be held down before it thinks it is dragging.
        this.dragTimeThreshold = 0;

        //  Used to temporarily store the results of the Hit Test
        this._temp = [];

        //  list: A list of all Game Objects that have been set to be interactive
        this._list = [];

        //  pendingInsertion: Objects waiting to be inserted to the list on the next call to 'begin'
        this._pendingInsertion = [];

        //  pendingRemoval: Objects waiting to be removed from the list on the next call to 'begin'
        this._pendingRemoval = [];

        //  draggable: A list of all Game Objects that have been enabled for dragging
        this._draggable = [];

        //  drag: A list of all Interactive Objects currently considered as being 'draggable' by any pointer, indexed by pointer ID
        this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [] };

        //  over: A list of all Interactive Objects currently considered as being 'over' by any pointer, indexed by pointer ID
        this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [] };

        this._validTypes = [ 'onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop' ];
    },

    //  Add option to get all IOs within a Rect or Circle

    boot: __webpack_require__(746),
    begin: __webpack_require__(745),
    clear: __webpack_require__(747),
    update: __webpack_require__(779),
    hitTestPointer: __webpack_require__(750),
    disable: __webpack_require__(748),
    enable: __webpack_require__(749),
    queueForInsertion: __webpack_require__(756),
    queueForRemoval: __webpack_require__(757),

    setpollRate: __webpack_require__(774),
    setpollAlways: __webpack_require__(772),
    setpollOnMove: __webpack_require__(773),

    setHitArea: __webpack_require__(761),
    setHitAreaCircle: __webpack_require__(762),
    setHitAreaEllipse: __webpack_require__(763),
    setHitAreaFromTexture: __webpack_require__(764),
    setHitAreaRectangle: __webpack_require__(765),
    setHitAreaTriangle: __webpack_require__(766),

    setDraggable: __webpack_require__(760),

    setCallback: __webpack_require__(758),
    setCallbacks: __webpack_require__(759),
    setOnDownCallback: __webpack_require__(767),
    setOnOutCallback: __webpack_require__(769),
    setOnOverCallback: __webpack_require__(770),
    setOnUpCallback: __webpack_require__(771),
    setOnMoveCallback: __webpack_require__(768),

    processOverOutEvents: __webpack_require__(754),
    processDownEvents: __webpack_require__(751),
    processDragEvents: __webpack_require__(752),
    processUpEvents: __webpack_require__(755),
    processMoveEvents: __webpack_require__(753),
    sortGameObjects: __webpack_require__(775),
    sortInteractiveObjects: __webpack_require__(778),
    sortHandlerGO: __webpack_require__(776),
    sortHandlerIO: __webpack_require__(777),

    //  The x/y coordinates of the ActivePointer based on the first camera in the camera list.
    //  This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.
    x: {

        get: function ()
        {
            return this.manager.activePointer.x;
        }

    },

    y: {

        get: function ()
        {
            return this.manager.activePointer.y;
        }

    },

    //  Scene that owns this is shutting down
    shutdown: function ()
    {
        this._temp.length = 0;
        this._list.length = 0;
        this._draggable.length = 0;
        this._pendingRemoval.length = 0;
        this._pendingInsertion.length = 0;

        for (var i = 0; i < 10; i++)
        {
            this._drag[i] = [];
            this._over[i] = [];
        }
    },

    //  Game level nuke
    destroy: function ()
    {
        this.shutdown();

        this.scene = undefined;
        this.cameras = undefined;
        this.manager = undefined;
        this.events = undefined;
        this.keyboard = undefined;
        this.mouse = undefined;
        this.gamepad = undefined;
    }

});

module.exports = SceneInputManager;


/***/ }),
/* 728 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var DragEndEvent = new Class({

    Extends: Event,

    initialize:

    function DragEndEvent (pointer, gameObject, dropped)
    {
        Event.call(this, 'DRAG_END_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The local x/y coordinates of the event within the Game Object
        this.x = pointer.x;
        this.y = pointer.y;

        //  When the drag ended did it fire a successful DROP event first?
        this.dropped = dropped;

        this.dragX = gameObject.input.dragX;
        this.dragY = gameObject.input.dragY;
    }

});

module.exports = DragEndEvent;


/***/ }),
/* 729 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var DragEnterEvent = new Class({

    Extends: Event,

    initialize:

    function DragEnterEvent (pointer, gameObject, dropZone)
    {
        Event.call(this, 'DRAG_ENTER_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The drop zone the game object was dropped on
        this.dropZone = dropZone;
    }

});

module.exports = DragEnterEvent;


/***/ }),
/* 730 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var DragEvent = new Class({

    Extends: Event,

    initialize:

    function DragEvent (pointer, gameObject)
    {
        Event.call(this, 'DRAG_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The local x/y coordinates of the event within the Game Object
        this.x = pointer.x;
        this.y = pointer.y;

        //  The local x/y coordinates of the event within the Game Object
        this.dragX = pointer.x - gameObject.input.dragX;
        this.dragY = pointer.y - gameObject.input.dragY;
    }

});

module.exports = DragEvent;


/***/ }),
/* 731 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var DragLeaveEvent = new Class({

    Extends: Event,

    initialize:

    function DragLeaveEvent (pointer, gameObject, dropZone)
    {
        Event.call(this, 'DRAG_LEAVE_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The drop zone the game object was dropped on
        this.dropZone = dropZone;
    }

});

module.exports = DragLeaveEvent;


/***/ }),
/* 732 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var DragOverEvent = new Class({

    Extends: Event,

    initialize:

    function DragOverEvent (pointer, gameObject, dropZone)
    {
        Event.call(this, 'DRAG_OVER_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The drop zone the game object was dropped on
        this.dropZone = dropZone;
    }

});

module.exports = DragOverEvent;


/***/ }),
/* 733 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var DragStartEvent = new Class({

    Extends: Event,

    initialize:

    function DragStartEvent (pointer, gameObject)
    {
        Event.call(this, 'DRAG_START_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The local x/y coordinates of the event within the Game Object
        this.x = pointer.x;
        this.y = pointer.y;

        this.dragX = gameObject.input.dragX;
        this.dragY = gameObject.input.dragY;
    }

});

module.exports = DragStartEvent;


/***/ }),
/* 734 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var DropEvent = new Class({

    Extends: Event,

    initialize:

    function DropEvent (pointer, gameObject, dropZone)
    {
        Event.call(this, 'DROP_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The drop zone the game object was dropped on
        this.dropZone = dropZone;
    }

});

module.exports = DropEvent;


/***/ }),
/* 735 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var GameObjectDownEvent = new Class({

    Extends: Event,

    initialize:

    function GameObjectDownEvent (pointer, gameObject)
    {
        Event.call(this, 'GAME_OBJECT_DOWN_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The local x/y coordinates of the event within the Game Object
        this.x = gameObject.input.localX;
        this.y = gameObject.input.localY;
    }

});

module.exports = GameObjectDownEvent;


/***/ }),
/* 736 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var GameObjectMoveEvent = new Class({

    Extends: Event,

    initialize:

    function GameObjectMoveEvent (pointer, gameObject)
    {
        Event.call(this, 'GAME_OBJECT_MOVE_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The local x/y coordinates of the event within the Game Object
        this.x = gameObject.input.localX;
        this.y = gameObject.input.localY;
    }

});

module.exports = GameObjectMoveEvent;


/***/ }),
/* 737 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var GameObjectOutEvent = new Class({

    Extends: Event,

    initialize:

    function GameObjectOutEvent (pointer, gameObject)
    {
        Event.call(this, 'GAME_OBJECT_OUT_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;
    }

});

module.exports = GameObjectOutEvent;


/***/ }),
/* 738 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var GameObjectOverEvent = new Class({

    Extends: Event,

    initialize:

    function GameObjectOverEvent (pointer, gameObject)
    {
        Event.call(this, 'GAME_OBJECT_OVER_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The local x/y coordinates of the event within the Game Object
        this.x = gameObject.input.localX;
        this.y = gameObject.input.localY;
    }

});

module.exports = GameObjectOverEvent;


/***/ }),
/* 739 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var GameObjectUpEvent = new Class({

    Extends: Event,

    initialize:

    function GameObjectUpEvent (pointer, gameObject)
    {
        Event.call(this, 'GAME_OBJECT_UP_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The Game Object the event occurred on
        this.gameObject = gameObject;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The local x/y coordinates of the event within the Game Object
        this.x = gameObject.input.localX;
        this.y = gameObject.input.localY;
    }

});

module.exports = GameObjectUpEvent;


/***/ }),
/* 740 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var PointerDownEvent = new Class({

    Extends: Event,

    initialize:

    function PointerDownEvent (pointer, gameObjects)
    {
        Event.call(this, 'POINTER_DOWN_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The x/y coordinates of the event
        this.x = pointer.x;
        this.y = pointer.y;

        //  An array of all the game objects the pointer event occurred on in display list order.
        //  Will be empty if no objects were interacted with.
        //  If populated, the bottom element (list[0]) is the highest object on the display list.
        //  If InputManager.topOnly is true this array will only contain one element.
        this.list = gameObjects;

        //  A reference to the top-most object on the display list (same as event.list[0])
        this.gameObject = gameObjects[0];
    }

});

module.exports = PointerDownEvent;


/***/ }),
/* 741 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var PointerMoveEvent = new Class({

    Extends: Event,

    initialize:

    function PointerMoveEvent (pointer, gameObjects)
    {
        Event.call(this, 'POINTER_MOVE_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The x/y coordinates of the event
        this.x = pointer.x;
        this.y = pointer.y;

        //  An array of all the game objects the pointer event occurred on in display list order.
        //  Will be empty if no objects were interacted with.
        //  If populated, the bottom element (list[0]) is the highest object on the display list.
        //  If InputManager.topOnly is true this array will only contain one element.
        this.list = gameObjects;

        //  A reference to the top-most object on the display list (also this.list[0]). Undefined if there isn't any.
        this.gameObject = gameObjects[0];
    }

});

module.exports = PointerMoveEvent;


/***/ }),
/* 742 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var PointerOutEvent = new Class({

    Extends: Event,

    initialize:

    function PointerOutEvent (pointer, gameObjects)
    {
        Event.call(this, 'POINTER_OUT_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The x/y coordinates of the event
        this.x = pointer.x;
        this.y = pointer.y;

        //  An array of all the game objects the pointer event occurred on in display list order.
        //  Will be undefined if no objects were interacted with.
        //  If populated, the bottom element (list[0]) is the highest object on the display list.
        //  If InputManager.topOnly is true this array will only contain one element.
        this.list = gameObjects;

        //  A reference to the top-most object on the display list (also this.list[0])
        this.gameObject = gameObjects[0];
    }

});

module.exports = PointerOutEvent;


/***/ }),
/* 743 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var PointerOverEvent = new Class({

    Extends: Event,

    initialize:

    function PointerOverEvent (pointer, gameObjects)
    {
        Event.call(this, 'POINTER_OVER_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The x/y coordinates of the event
        this.x = pointer.x;
        this.y = pointer.y;

        //  An array of all the game objects the pointer event occurred on in display list order.
        //  Will be undefined if no objects were interacted with.
        //  If populated, the bottom element (list[0]) is the highest object on the display list.
        //  If InputManager.topOnly is true this array will only contain one element.
        this.list = gameObjects;

        //  A reference to the top-most object on the display list (also this.list[0])
        this.gameObject = gameObjects[0];
    }

});

module.exports = PointerOverEvent;


/***/ }),
/* 744 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var PointerUpEvent = new Class({

    Extends: Event,

    initialize:

    function PointerUpEvent (pointer, gameObjects)
    {
        Event.call(this, 'POINTER_UP_EVENT');

        //  The Pointer that triggered the event
        this.pointer = pointer;

        //  The native DOM event (MouseEvent, TouchEvent, etc)
        this.event = pointer.event;

        //  The camera on which the input event occurred
        this.camera = pointer.camera;

        //  The x/y coordinates of the event
        this.x = pointer.x;
        this.y = pointer.y;

        //  An array of all the game objects the pointer event occurred on in display list order.
        //  Will be empty if no objects were interacted with.
        //  If populated, the bottom element (list[0]) is the highest object on the display list.
        //  If InputManager.topOnly is true this array will only contain one element.
        this.list = gameObjects;

        //  A reference to the top-most object on the display list (same as event.list[0])
        this.gameObject = gameObjects[0];
    }

});

module.exports = PointerUpEvent;


/***/ }),
/* 745 */
/***/ (function(module, exports) {

var Begin = function ()
{
    var removeList = this._pendingRemoval;
    var insertList = this._pendingInsertion;

    var toRemove = removeList.length;
    var toInsert = insertList.length;

    if (toRemove === 0 && toInsert === 0)
    {
        //  Quick bail
        return;
    }

    var current = this._list;

    //  Delete old gameObjects
    for (var i = 0; i < toRemove; i++)
    {
        var gameObject = removeList[i];

        var index = current.indexOf(gameObject);

        if (index > -1)
        {
            current.splice(index, 1);

            //  TODO: Clear from _draggable, _drag and _over too

            this.clear(gameObject);
        }
    }

    //  Clear the removal list
    removeList.length = 0;

    //  Move pendingInsertion to list (also clears pendingInsertion at the same time)
    this._list = current.concat(insertList.splice(0));
};

module.exports = Begin;



/***/ }),
/* 746 */
/***/ (function(module, exports) {

var Boot = function ()
{
    this.cameras = this.scene.sys.cameras;

    this.displayList = this.scene.sys.displayList;
};

module.exports = Boot;


/***/ }),
/* 747 */
/***/ (function(module, exports) {

var Clear = function (gameObject)
{
    var input = gameObject.input;

    input.gameObject = undefined;
    input.target = undefined;
    input.hitArea = undefined;
    input.hitAreaCallback = undefined;
    input.callbackContext = undefined;

    gameObject.input = null;

    return gameObject;
};

module.exports = Clear;


/***/ }),
/* 748 */
/***/ (function(module, exports) {

var Disable = function (gameObject)
{
    gameObject.input.enabled = false;
};

module.exports = Disable;


/***/ }),
/* 749 */
/***/ (function(module, exports) {

var Enable = function (gameObject, shape, callback)
{
    if (gameObject.input)
    {
        //  If it is already has an InteractiveObject then just enable it and return
        gameObject.input.enabled = true;
    }
    else
    {
        //  Create an InteractiveObject and enable it
        this.setHitArea(gameObject, shape, callback);
    }

    return this;
};

module.exports = Enable;


/***/ }),
/* 750 */
/***/ (function(module, exports) {

var HitTestPointer = function (pointer)
{
    var camera = this.cameras.getCameraBelowPointer(pointer);

    if (camera)
    {
        pointer.camera = camera;

        //  Get a list of all objects that can be seen by the camera below the pointer in the scene and store in 'output' array.
        //  All objects in this array are input enabled, as checked by the hitTest function, so we don't need to check later on as well.
        return this.manager.hitTest(this._list, pointer.x, pointer.y, camera);
    }
    else
    {
        return [];
    }
};

module.exports = HitTestPointer;


/***/ }),
/* 751 */
/***/ (function(module, exports, __webpack_require__) {

var InputEvent = __webpack_require__(41);

var ProcessDownEvents = function (pointer)
{
    var currentlyOver = this._temp;

    this.events.dispatch(new InputEvent.POINTER_DOWN(pointer, currentlyOver));

    //  Go through all objects the pointer was over and fire their events / callbacks
    for (var i = 0; i < currentlyOver.length; i++)
    {
        var gameObject = currentlyOver[i];

        this.events.dispatch(new InputEvent.GAME_OBJECT_DOWN(pointer, gameObject));

        gameObject.input.onDown(gameObject, pointer, gameObject.input.localX, gameObject.input.localY);

        if (this.topOnly)
        {
            break;
        }
    }
};

module.exports = ProcessDownEvents;


/***/ }),
/* 752 */
/***/ (function(module, exports, __webpack_require__) {

var DistanceBetween = __webpack_require__(68);
var InputEvent = __webpack_require__(41);

var ProcessDragEvents = function (pointer, time)
{
    if (this._draggable.length === 0)
    {
        //  There are no draggable items, so let's not even bother going further
        return;
    }

    var i;
    var c;
    var gameObject;
    var list;
    var input;
    var currentlyOver = this._temp;

    //  0 = Not dragging anything
    //  1 = Primary button down and objects below, so collect a draglist
    //  2 = Pointer being checked if meets drag criteria
    //  3 = Pointer meets criteria, notify the draglist
    //  4 = Pointer actively dragging the draglist and has moved
    //  5 = Pointer actively dragging but has been released, notify draglist

    if (pointer.dragState === 0 && pointer.primaryDown && pointer.justDown && currentlyOver.length > 0)
    {
        pointer.dragState = 1;
    }
    else if (pointer.dragState > 0 && !pointer.primaryDown && pointer.justUp)
    {
        pointer.dragState = 5;
    }

    //  Process the various drag states

    //  1 = Primary button down and objects below, so collect a draglist
    if (pointer.dragState === 1)
    {
        //  Get draggable objects, sort them, pick the top (or all) and store them somewhere
        var draglist = [];

        for (i = 0; i < currentlyOver.length; i++)
        {
            gameObject = currentlyOver[i];

            if (gameObject.input.draggable)
            {
                draglist.push(gameObject);
            }
        }

        if (draglist.length === 0)
        {
            pointer.dragState = 0;

            return;
        }
        else if (draglist.length > 1)
        {
            this.sortGameObjects(draglist);

            if (this.topOnly)
            {
                draglist.splice(1);
            }
        }

        //  draglist now contains all potential candidates for dragging
        this._drag[pointer.id] = draglist;

        if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0)
        {
            //  No drag criteria, so snap immediately to mode 3
            pointer.dragState = 3;
        }
        else
        {
            //  Check the distance / time
            pointer.dragState = 2;
        }
    }

    //  2 = Pointer being checked if meets drag criteria
    if (pointer.dragState === 2)
    {
        //  Has it moved far enough to be considered a drag?
        if (this.dragDistanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= this.dragDistanceThreshold)
        {
            //  Alrighty, we've got a drag going on ...
            pointer.dragState = 3;
        }

        //  Held down long enough to be considered a drag?
        if (this.dragTimeThreshold > 0 && (time >= pointer.downTime + this.dragTimeThreshold))
        {
            //  Alrighty, we've got a drag going on ...
            pointer.dragState = 3;
        }
    }

    //  3 = Pointer meets criteria and is freshly down, notify the draglist
    if (pointer.dragState === 3)
    {
        list = this._drag[pointer.id];

        for (i = 0; i < list.length; i++)
        {
            gameObject = list[i];

            input = gameObject.input;

            input.dragState = 2;

            input.dragX = pointer.x - gameObject.x;
            input.dragY = pointer.y - gameObject.y;

            input.dragStartX = gameObject.x;
            input.dragStartY = gameObject.y;

            this.events.dispatch(new InputEvent.DRAG_START(pointer, gameObject));

            input.onDragStart(gameObject, pointer, input.dragX, input.dragY);
        }

        pointer.dragState = 4;

        return;
    }

    //  4 = Pointer actively dragging the draglist and has moved
    if (pointer.dragState === 4 && pointer.justMoved)
    {
        //  Let's filter out currentlyOver for dropZones only
        var dropZones = [];

        for (c = 0; c < currentlyOver.length; c++)
        {
            if (currentlyOver[c].input.dropZone)
            {
                dropZones.push(currentlyOver[c]);
            }
        }

        list = this._drag[pointer.id];

        for (i = 0; i < list.length; i++)
        {
            gameObject = list[i];

            input = gameObject.input;

            //  If this GO has a target then let's check it
            if (input.target)
            {
                var index = dropZones.indexOf(input.target);

                //  Got a target, are we still over it?
                if (index === 0)
                {
                    //  We're still over it, and it's still the top of the display list, phew ...
                    this.events.dispatch(new InputEvent.DRAG_OVER(pointer, gameObject, input.target));
                }
                else if (index > 0)
                {
                    //  Still over it but it's no longer top of the display list (targets must always be at the top)
                    this.events.dispatch(new InputEvent.DRAG_LEAVE(pointer, gameObject, input.target));

                    input.target = dropZones[0];

                    this.events.dispatch(new InputEvent.DRAG_ENTER(pointer, gameObject, input.target));
                }
                else
                {
                    //  Nope, we've moved on (or the target has!), leave the old target
                    this.events.dispatch(new InputEvent.DRAG_LEAVE(pointer, gameObject, input.target));

                    //  Anything new to replace it?
                    //  Yup!
                    if (dropZones[0])
                    {
                        input.target = dropZones[0];

                        this.events.dispatch(new InputEvent.DRAG_ENTER(pointer, gameObject, input.target));
                    }
                    else
                    {
                        //  Nope
                        input.target = null;
                    }
                }
            }
            else if (!input.target && dropZones[0])
            {
                input.target = dropZones[0];

                this.events.dispatch(new InputEvent.DRAG_ENTER(pointer, gameObject, input.target));
            }

            this.events.dispatch(new InputEvent.DRAG(pointer, gameObject));

            input.onDrag(gameObject, pointer);
        }
    }

    //  5 = Pointer actively dragging but has been released, notify draglist
    if (pointer.dragState === 5)
    {
        list = this._drag[pointer.id];

        for (i = 0; i < list.length; i++)
        {
            gameObject = list[i];

            input = gameObject.input;

            input.dragState = 0;

            input.dragX = input.localX - gameObject.displayOriginX;
            input.dragY = input.localY - gameObject.displayOriginY;

            var dropped = false;

            if (input.target)
            {
                this.events.dispatch(new InputEvent.DROP(pointer, gameObject, input.target));

                input.target = null;

                dropped = true;
            }

            //  And finally the dragend event

            this.events.dispatch(new InputEvent.DRAG_END(pointer, gameObject, dropped));

            input.onDragEnd(gameObject, pointer, input.dragX, input.dragY);
        }

        pointer.dragState = 0;
    }
};

module.exports = ProcessDragEvents;


/***/ }),
/* 753 */
/***/ (function(module, exports, __webpack_require__) {

var InputEvent = __webpack_require__(41);

var ProcessMoveEvents = function (pointer)
{
    var currentlyOver = this._temp;

    this.events.dispatch(new InputEvent.POINTER_MOVE(pointer, currentlyOver));

    //  Go through all objects the pointer was over and fire their events / callbacks
    for (var i = 0; i < currentlyOver.length; i++)
    {
        var gameObject = currentlyOver[i];

        this.events.dispatch(new InputEvent.GAME_OBJECT_MOVE(pointer, gameObject));

        gameObject.input.onMove(gameObject, pointer, gameObject.input.localX, gameObject.input.localY);

        if (this.topOnly)
        {
            break;
        }
    }
};

module.exports = ProcessMoveEvents;


/***/ }),
/* 754 */
/***/ (function(module, exports, __webpack_require__) {

var InputEvent = __webpack_require__(41);

var ProcessOverOutEvents = function (pointer)
{
    var currentlyOver = this._temp;

    var i;
    var gameObject;
    var justOut = [];
    var justOver = [];
    var stillOver = [];
    var previouslyOver = this._over[pointer.id];

    //  Go through all objects the pointer was previously over, and see if it still is
    for (i = 0; i < previouslyOver.length; i++)
    {
        gameObject = previouslyOver[i];

        if (currentlyOver.indexOf(gameObject) === -1)
        {
            //  Not in the currentlyOver array
            justOut.push(gameObject);
        }
        else
        {
            //  In the currentlyOver array
            stillOver.push(gameObject);
        }
    }

    //  Go through the hit test results
    for (i = 0; i < currentlyOver.length; i++)
    {
        gameObject = currentlyOver[i];

        //  Is this newly over?

        if (previouslyOver.indexOf(gameObject) === -1)
        {
            justOver.push(gameObject);
        }
    }

    //  By this point the arrays are filled, so now we can process what happened...

    //  Process the Just Out objects
    var total = justOut.length;

    if (total > 0)
    {
        this.sortGameObjects(justOut);

        this.events.dispatch(new InputEvent.POINTER_OUT(pointer, justOut));

        //  Call onOut for everything in the justOut array
        for (i = 0; i < total; i++)
        {
            gameObject = justOut[i];

            this.events.dispatch(new InputEvent.GAME_OBJECT_OUT(pointer, gameObject));

            gameObject.input.onOut(gameObject, pointer);

            if (this.topOnly)
            {
                break;
            }
        }
    }

    //  Process the Just Over objects
    total = justOver.length;

    if (total > 0)
    {
        this.sortGameObjects(justOver);

        this.events.dispatch(new InputEvent.POINTER_OVER(pointer, justOver));

        //  Call onOver for everything in the justOver array
        for (i = 0; i < total; i++)
        {
            gameObject = justOver[i];

            this.events.dispatch(new InputEvent.GAME_OBJECT_OVER(pointer, gameObject));

            gameObject.input.onOver(gameObject, pointer, gameObject.input.localX, gameObject.input.localY);

            if (this.topOnly)
            {
                break;
            }
        }
    }

    //  Add the contents of justOver to the previously over array
    previouslyOver = stillOver.concat(justOver);

    //  Then sort it into display list order
    this._over[pointer.id] = this.sortGameObjects(previouslyOver);
};

module.exports = ProcessOverOutEvents;


/***/ }),
/* 755 */
/***/ (function(module, exports, __webpack_require__) {

var InputEvent = __webpack_require__(41);

var ProcessUpEvents = function (pointer)
{
    var currentlyOver = this._temp;

    this.events.dispatch(new InputEvent.POINTER_UP(pointer, currentlyOver));

    //  Go through all objects the pointer was over and fire their events / callbacks
    for (var i = 0; i < currentlyOver.length; i++)
    {
        var gameObject = currentlyOver[i];

        this.events.dispatch(new InputEvent.GAME_OBJECT_UP(pointer, gameObject));

        gameObject.input.onUp(gameObject, pointer, gameObject.input.localX, gameObject.input.localY);

        if (this.topOnly)
        {
            break;
        }
    }
};

module.exports = ProcessUpEvents;


/***/ }),
/* 756 */
/***/ (function(module, exports) {

//  Queues a Game Object for insertion into this Input Manager on the next update.
var QueueForInsertion = function (child)
{
    if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1)
    {
        this._pendingInsertion.push(child);
    }

    return this;
};

module.exports = QueueForInsertion;


/***/ }),
/* 757 */
/***/ (function(module, exports) {

//  Queues a Game Object for removal from this Input Manager on the next update.
var QueueForRemoval = function (child)
{
    this._pendingRemoval.push(child);

    return this;
};

module.exports = QueueForRemoval;


/***/ }),
/* 758 */
/***/ (function(module, exports) {

var SetCallback = function (gameObjects, type, callback, context)
{
    if (this._validTypes.indexOf(type) === -1)
    {
        return this;
    }

    if (!Array.isArray(gameObjects))
    {
        gameObjects = [ gameObjects ];
    }

    for (var i = 0; i < gameObjects.length; i++)
    {
        var gameObject = gameObjects[i];

        if (gameObject.input)
        {
            gameObject.input[type] = callback;

            if (context)
            {
                gameObject.input.callbackContext = context;
            }
        }
    }

    return this;
};

module.exports = SetCallback;


/***/ }),
/* 759 */
/***/ (function(module, exports, __webpack_require__) {

var GetFastValue = __webpack_require__(11);

var SetCallbacks = function (gameObjects, config)
{
    var onDown = GetFastValue(config, 'onDown', null);
    var onUp = GetFastValue(config, 'onUp', null);
    var onOver = GetFastValue(config, 'onOver', null);
    var onOut = GetFastValue(config, 'onOut', null);
    var onMove = GetFastValue(config, 'onMove', null);
    var context = GetFastValue(config, 'context', null);

    if (onDown)
    {
        this.setOnDownCallback(gameObjects, onDown, context);
    }

    if (onUp)
    {
        this.setOnDownCallback(gameObjects, onUp, context);
    }

    if (onOver)
    {
        this.setOnDownCallback(gameObjects, onOver, context);
    }

    if (onOut)
    {
        this.setOnDownCallback(gameObjects, onOut, context);
    }

    if (onMove)
    {
        this.setOnMoveCallback(gameObjects, onMove, context);
    }

    return this;
};

module.exports = SetCallbacks;


/***/ }),
/* 760 */
/***/ (function(module, exports) {

var SetDraggable = function (gameObjects, value)
{
    if (value === undefined) { value = true; }

    if (!Array.isArray(gameObjects))
    {
        gameObjects = [ gameObjects ];
    }

    for (var i = 0; i < gameObjects.length; i++)
    {
        var gameObject = gameObjects[i];

        gameObject.input.draggable = value;

        var index = this._draggable.indexOf(gameObject);

        if (value && index === -1)
        {
            this._draggable.push(gameObject);
        }
        else if (!value && index > -1)
        {
            this._draggable.splice(index, 1);
        }
    }

    return this;
};

module.exports = SetDraggable;


/***/ }),
/* 761 */
/***/ (function(module, exports, __webpack_require__) {

var InteractiveObject = __webpack_require__(184);

var SetHitArea = function (gameObjects, shape, callback)
{
    if (shape === undefined)
    {
        return this.setHitAreaFromTexture(gameObjects);
    }

    if (!Array.isArray(gameObjects))
    {
        gameObjects = [ gameObjects ];
    }

    for (var i = 0; i < gameObjects.length; i++)
    {
        var gameObject = gameObjects[i];

        gameObject.input = InteractiveObject(gameObject, shape, callback);

        this.queueForInsertion(gameObject);
    }

    return this;
};

module.exports = SetHitArea;


/***/ }),
/* 762 */
/***/ (function(module, exports, __webpack_require__) {

var Circle = __webpack_require__(60);
var CircleContains = __webpack_require__(38);

var SetHitAreaCircle = function (gameObjects, x, y, radius, callback)
{
    if (callback === undefined) { callback = CircleContains; }

    var shape = new Circle(x, y, radius);

    return this.setHitArea(gameObjects, shape, callback);
};

module.exports = SetHitAreaCircle;


/***/ }),
/* 763 */
/***/ (function(module, exports, __webpack_require__) {

var Ellipse = __webpack_require__(93);
var EllipseContains = __webpack_require__(61);

var SetHitAreaEllipse = function (gameObjects, x, y, width, height, callback)
{
    if (callback === undefined) { callback = EllipseContains; }

    var shape = new Ellipse(x, y, width, height);

    return this.setHitArea(gameObjects, shape, callback);
};

module.exports = SetHitAreaEllipse;


/***/ }),
/* 764 */
/***/ (function(module, exports, __webpack_require__) {

var InteractiveObject = __webpack_require__(184);
var Rectangle = __webpack_require__(18);
var RectangleContains = __webpack_require__(32);

var SetHitAreaFromTexture = function (gameObjects, callback)
{
    if (callback === undefined) { callback = RectangleContains; }

    if (!Array.isArray(gameObjects))
    {
        gameObjects = [ gameObjects ];
    }

    for (var i = 0; i < gameObjects.length; i++)
    {
        var gameObject = gameObjects[i];
        var frame = gameObject.frame;

        var width = 0;
        var height = 0;

        if (frame)
        {
            width = frame.width;
            height = frame.height;
        }
        else if (gameObject.width)
        {
            width = gameObject.width;
            height = gameObject.height;
        }

        if (width !== 0 && height !== 0)
        {
            gameObject.input = InteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);

            this.queueForInsertion(gameObject);
        }
    }

    return this;
};

module.exports = SetHitAreaFromTexture;


/***/ }),
/* 765 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(18);
var RectangleContains = __webpack_require__(32);

var SetHitAreaRectangle = function (gameObjects, x, y, width, height, callback)
{
    if (callback === undefined) { callback = RectangleContains; }

    var shape = new Rectangle(x, y, width, height);

    return this.setHitArea(gameObjects, shape, callback);
};

module.exports = SetHitAreaRectangle;


/***/ }),
/* 766 */
/***/ (function(module, exports, __webpack_require__) {

var Triangle = __webpack_require__(40);
var TriangleContains = __webpack_require__(51);

var SetHitAreaTriangle = function (gameObjects, x1, y1, x2, y2, x3, y3, callback)
{
    if (callback === undefined) { callback = TriangleContains; }

    var shape = new Triangle(x1, y1, x2, y2, x3, y3);

    return this.setHitArea(gameObjects, shape, callback);
};

module.exports = SetHitAreaTriangle;


/***/ }),
/* 767 */
/***/ (function(module, exports) {

var SetOnDownCallback = function (gameObjects, callback, context)
{
    return this.setCallback(gameObjects, 'onDown', callback, context);
};

module.exports = SetOnDownCallback;


/***/ }),
/* 768 */
/***/ (function(module, exports) {

var SetOnMoveCallback = function (gameObjects, callback, context)
{
    return this.setCallback(gameObjects, 'onMove', callback, context);
};

module.exports = SetOnMoveCallback;


/***/ }),
/* 769 */
/***/ (function(module, exports) {

var SetOnOutCallback = function (gameObjects, callback, context)
{
    return this.setCallback(gameObjects, 'onOut', callback, context);
};

module.exports = SetOnOutCallback;


/***/ }),
/* 770 */
/***/ (function(module, exports) {

var SetOnOverCallback = function (gameObjects, callback, context)
{
    return this.setCallback(gameObjects, 'onOver', callback, context);
};

module.exports = SetOnOverCallback;


/***/ }),
/* 771 */
/***/ (function(module, exports) {

var SetOnUpCallback = function (gameObjects, callback, context)
{
    return this.setCallback(gameObjects, 'onUp', callback, context);
};

module.exports = SetOnUpCallback;


/***/ }),
/* 772 */
/***/ (function(module, exports) {

var SetPollAlways = function ()
{
    this.pollRate = 0;
    this._pollTimer = 0;

    return this;
};

module.exports = SetPollAlways;


/***/ }),
/* 773 */
/***/ (function(module, exports) {

var SetPollOnMove = function ()
{
    this.pollRate = -1;
    this._pollTimer = 0;

    return this;
};

module.exports = SetPollOnMove;


/***/ }),
/* 774 */
/***/ (function(module, exports) {

var SetPollRate = function (value)
{
    this.pollRate = value;
    this._pollTimer = 0;

    return this;
};

module.exports = SetPollRate;


/***/ }),
/* 775 */
/***/ (function(module, exports) {

//  Given an array of Game Objects, sort the array and return it,
//  so that the objects are in index order with the lowest at the bottom.
var SortGameObjects = function (gameObjects)
{
    if (gameObjects.length < 2)
    {
        return gameObjects;
    }

    this.scene.sys.depthSort();

    return gameObjects.sort(this.sortHandlerGO.bind(this));
};

module.exports = SortGameObjects;


/***/ }),
/* 776 */
/***/ (function(module, exports) {

//  Return the child lowest down the display list (with the smallest index)
var SortHandlerGO = function (childA, childB)
{
    //  The higher the index, the lower down the display list they are.
    //  So entry 0 will be the top-most item (visually)
    var indexA = this.displayList.getIndex(childA);
    var indexB = this.displayList.getIndex(childB);

    if (indexA < indexB)
    {
        return 1;
    }
    else if (indexA > indexB)
    {
        return -1;
    }

    //  Technically this shouldn't happen, but if the GO wasn't part of this display list then it'll
    //  have an index of -1, so in some cases it can
    return 0;
};

module.exports = SortHandlerGO;


/***/ }),
/* 777 */
/***/ (function(module, exports) {

//  Return the child lowest down the display list (with the smallest index)
var SortHandlerIO = function (childA, childB)
{
    //  The higher the index, the lower down the display list they are.
    //  So entry 0 will be the top-most item (visually)
    var indexA = this.displayList.getIndex(childA.gameObject);
    var indexB = this.displayList.getIndex(childB.gameObject);

    if (indexA < indexB)
    {
        return 1;
    }
    else if (indexA > indexB)
    {
        return -1;
    }

    //  Technically this shouldn't happen, but if the GO wasn't part of this display list then it'll
    //  have an index of -1, so in some cases it can
    return 0;
};

module.exports = SortHandlerIO;


/***/ }),
/* 778 */
/***/ (function(module, exports) {

//  Given an array of Interactive Objects, sort the array and return it,
//  so that the objects are in index order with the lowest at the bottom.
var SortInteractiveObjects = function (interactiveObjects)
{
    if (interactiveObjects.length < 2)
    {
        return interactiveObjects;
    }

    this.scene.sys.depthSort();

    return interactiveObjects.sort(this.sortHandlerIO.bind(this));
};

module.exports = SortInteractiveObjects;


/***/ }),
/* 779 */
/***/ (function(module, exports) {

var Update = function (time, delta)
{
    var pointer = this.manager.activePointer;

    var runUpdate = (pointer.dirty || this.pollRate === 0);

    if (this.pollRate > -1)
    {
        this._pollTimer -= delta;

        if (this._pollTimer < 0)
        {
            runUpdate = true;

            //  Discard timer diff
            this._pollTimer = this.pollRate;
        }
    }

    if (runUpdate)
    {
        this._temp = this.hitTestPointer(pointer);

        this.sortGameObjects(this._temp);

        this.processDragEvents(pointer, time);

        this.processOverOutEvents(pointer);

        if (pointer.justDown)
        {
            this.processDownEvents(pointer);
        }

        if (pointer.justUp)
        {
            this.processUpEvents(pointer);
        }

        if (pointer.justMoved)
        {
            this.processMoveEvents(pointer);
        }
    }
};

module.exports = Update;


/***/ }),
/* 780 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var MouseDownEvent = new Class({

    Extends: Event,

    initialize:

    function MouseDownEvent (nativeEvent)
    {
        Event.call(this, 'MOUSE_DOWN_EVENT');

        this.data = nativeEvent;

        this.x = nativeEvent.clientX;
        this.y = nativeEvent.clientY;
    }

});

module.exports = MouseDownEvent;


/***/ }),
/* 781 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var MouseMoveEvent = new Class({

    Extends: Event,

    initialize:

    function MouseMoveEvent (nativeEvent)
    {
        Event.call(this, 'MOUSE_MOVE_EVENT');

        this.data = nativeEvent;

        this.x = nativeEvent.clientX;
        this.y = nativeEvent.clientY;
    }

});

module.exports = MouseMoveEvent;


/***/ }),
/* 782 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var MouseUpEvent = new Class({

    Extends: Event,

    initialize:

    function MouseUpEvent (nativeEvent)
    {
        Event.call(this, 'MOUSE_UP_EVENT');

        this.data = nativeEvent;

        this.x = nativeEvent.clientX;
        this.y = nativeEvent.clientY;
    }

});

module.exports = MouseUpEvent;


/***/ }),
/* 783 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Mouse.Events

module.exports = {
    DOWN: __webpack_require__(780),
    UP: __webpack_require__(782),
    MOVE: __webpack_require__(781)
};


/***/ }),
/* 784 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Mouse

module.exports = {

    MouseManager: __webpack_require__(194) 
       
};


/***/ }),
/* 785 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

// https://developer.mozilla.org/en-US/docs/Web/API/Touch_events
// https://patrickhlauke.github.io/touch/tests/results/
// https://www.html5rocks.com/en/mobile/touch/

var TouchManager = new Class({

    initialize:

    function TouchManager (inputManager)
    {
        this.manager = inputManager;

        // @property {boolean} capture - If true the DOM events will have event.preventDefault applied to them, if false they will propagate fully.
        this.capture = false;

        this.enabled = false;

        this.target;

        this.handler;
    },

    boot: function ()
    {
        var config = this.manager.config;

        this.enabled = config.inputTouch;
        this.target = config.inputTouchEventTarget;

        if (!this.target)
        {
            this.target = this.manager.game.canvas;
        }

        if (this.enabled)
        {
            this.startListeners();
        }
    },

    startListeners: function ()
    {
        var queue = this.manager.queue;

        var _this = this;

        var handler = function (event)
        {
            if (event.preventDefaulted)
            {
                // Do nothing if event already handled
                return;
            }

            // console.log(event);

            queue.push(event);

            if (_this.capture)
            {
                event.preventDefault();
            }
        };

        this.handler = handler;

        this.target.addEventListener('touchstart', handler, false);
        this.target.addEventListener('touchmove', handler, false);
        this.target.addEventListener('touchend', handler, false);
    },

    stopListeners: function ()
    {
        this.target.removeEventListener('touchstart', this.handler);
        this.target.removeEventListener('touchmove', this.handler);
        this.target.removeEventListener('touchend', this.handler);
    }

});

module.exports = TouchManager;


/***/ }),
/* 786 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(16);
var Set = __webpack_require__(54);
var XHRSettings = __webpack_require__(103);
var Event = __webpack_require__(791);
// var EventDispatcher = require('../events/EventDispatcher');
var Class = __webpack_require__(0);
var ParseXMLBitmapFont = __webpack_require__(137);

//  Phaser.Loader.BaseLoader

//  To finish the loader ...
//  
//  3) Progress update

var BaseLoader = new Class({

    initialize:

    function BaseLoader (scene)
    {
        this.scene = scene;

        this.events = scene.sys.events;

        //  Move to a 'setURL' method?
        this.baseURL = '';
        this.path = '';

        //  Read from Game / Scene Config
        this.enableParallel = true;
        this.maxParallelDownloads = 4;

        //  xhr specific global settings (can be overridden on a per-file basis)
        this.xhr = XHRSettings();

        this.crossOrigin = undefined;

        this.list = new Set();
        this.inflight = new Set();
        this.failed = new Set();
        this.queue = new Set();
        this.storage = new Set();

        this.state = CONST.LOADER_IDLE;
    },

    setPath: function (path)
    {
        if (path.substr(-1) !== '/')
        {
            path = path.concat('/');
        }

        this.path = path;

        return this;
    },

    addFile: function (file)
    {
        if (!this.isReady())
        {
            return -1;
        }

        file.path = this.path;

        this.list.set(file);

        return this;
    },

    //  Is the Loader actively loading (or processing loaded files)
    isLoading: function ()
    {
        return (this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING);
    },

    //  Is the Loader ready to start a new load?
    isReady: function ()
    {
        return (this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE || this.state === CONST.LOADER_FAILED);
    },

    start: function ()
    {
        console.log(this.scene.sys.settings.key, '- BaseLoader start. Files to load:', this.list.size);

        if (!this.isReady())
        {
            return;
        }

        this.events.dispatch(new Event.LOADER_START_EVENT(this));

        if (this.list.size === 0)
        {
            this.finishedLoading();
        }
        else
        {
            this.state = CONST.LOADER_LOADING;

            this.failed.clear();
            this.inflight.clear();
            this.queue.clear();

            this.queue.debug = true;

            this.updateProgress();

            this.processLoadQueue();
        }
    },

    updateProgress: function ()
    {

    },

    processLoadQueue: function ()
    {
        // console.log('======== BaseLoader processLoadQueue');
        // console.log('List size', this.list.size);
        // console.log(this.inflight.size, 'items still in flight. Can load another', (this.maxParallelDownloads - this.inflight.size));

        var _this = this;

        this.list.each(function (file)
        {
            if (file.state === CONST.FILE_PENDING && _this.inflight.size < _this.maxParallelDownloads)
            {
                _this.inflight.set(file);

                _this.list.delete(file);

                _this.loadFile(file);
            }

            if (_this.inflight.size === _this.maxParallelDownloads)
            {
                //  Tells the Set iterator to abort
                return false;
            }

        });
    },

    //  private
    loadFile: function (file)
    {
        // console.log('LOADING', file.key);

        //  If the file doesn't have its own crossOrigin set,
        //  we'll use the Loaders (which is undefined by default)
        if (!file.crossOrigin)
        {
            file.crossOrigin = this.crossOrigin;
        }

        file.load(this.nextFile.bind(this), this.baseURL);
    },

    nextFile: function (previousFile, success)
    {
        // console.log('LOADED:', previousFile.src, success);

        //  Move the file that just loaded from the inflight list to the queue or failed Set

        if (success)
        {
            this.queue.set(previousFile);
        }
        else
        {
            this.failed.set(previousFile);
        }

        this.inflight.delete(previousFile);

        if (this.list.size > 0)
        {
            // console.log('nextFile - still something in the list');
            this.processLoadQueue();
        }
        else if (this.inflight.size === 0)
        {
            // console.log('nextFile calling finishedLoading');
            this.finishedLoading();
        }
    },

    finishedLoading: function ()
    {
        // console.log('---> BaseLoader.finishedLoading PROCESSING', this.queue.size, 'files');

        this.state = CONST.LOADER_PROCESSING;

        this.storage.clear();

        var _this = this;

        this.queue.each(function (file)
        {
            // console.log('%c Calling process on ' + file.key, 'color: #000000; background: #ffff00;');

            file.onProcess(_this.processUpdate.bind(_this));
        });
    },

    //  Called automatically by the File when it has finished processing
    processUpdate: function (file)
    {
        // console.log('-> processUpdate', file.key, file.state);

        //  This file has failed to load, so move it to the failed Set
        if (file.state === CONST.FILE_ERRORED)
        {
            this.failed.set(file);

            if (file.linkFile)
            {
                this.queue.delete(file.linkFile);
            }

            return this.removeFromQueue(file);
        }

        //  If we got here, then the file loaded

        //  Special handling for multi-part files

        if (file.linkFile)
        {
            if (file.state === CONST.FILE_COMPLETE && file.linkFile.state === CONST.FILE_COMPLETE)
            {
                //  Partner has loaded, so add them both to Storage

                this.storage.set({ type: file.linkType, fileA: file, fileB: file.linkFile });

                this.queue.delete(file.linkFile);

                this.removeFromQueue(file);
            }
        }
        else
        {
            this.storage.set(file);

            this.removeFromQueue(file);
        }
    },

    removeFromQueue: function (file)
    {
        this.queue.delete(file);

        if (this.queue.size === 0 && this.state === CONST.LOADER_PROCESSING)
        {
            //  We've processed all the files we loaded
            this.processComplete();
        }
    },

    processComplete: function ()
    {
        console.log(this.scene.sys.settings.key, '- Loader Complete. Loaded:', this.storage.size, 'Failed:', this.failed.size);

        this.list.clear();
        this.inflight.clear();
        this.queue.clear();

        this.processCallback();

        this.state = CONST.LOADER_COMPLETE;

        this.events.dispatch(new Event.LOADER_COMPLETE_EVENT(this));
    },

    //  The Loader has finished
    processCallback: function ()
    {
        if (this.storage.size === 0)
        {
            return;
        }

        //  The global Texture Manager
        var cache = this.scene.sys.cache;
        var textures = this.scene.sys.textures;
        var anims = this.scene.sys.anims;

        //  Process multiatlas groups first

        var file;
        var fileA;
        var fileB;

        for (var key in this._multilist)
        {
            var data = [];
            var images = [];
            var keys = this._multilist[key];

            for (var i = 0; i < keys.length; i++)
            {
                file = this.storage.get('key', keys[i]);

                if (file)
                {
                    if (file.type === 'image')
                    {
                        images.push(file.data);
                    }
                    else if (file.type === 'json')
                    {
                        data.push(file.data);
                    }

                    this.storage.delete(file);
                }
            }

            //  Do we have everything needed?
            if (images.length + data.length === keys.length)
            {
                //  Yup, add them to the Texture Manager

                //  Is the data JSON Hash or JSON Array?
                if (Array.isArray(data[0].frames))
                {
                    textures.addAtlasJSONArray(key, images, data);
                }
                else
                {
                    textures.addAtlasJSONHash(key, images, data);
                }
            }
        }

        //  Process all of the files

        //  Because AnimationJSON may require images to be loaded first, we process them last
        var animJSON = [];

        this.storage.each(function (file)
        {
            switch (file.type)
            {
                case 'animationJSON':
                    animJSON.push(file);
                    break;

                case 'image':
                case 'svg':
                case 'html':
                    textures.addImage(file.key, file.data);
                    break;

                case 'atlasjson':

                    fileA = file.fileA;
                    fileB = file.fileB;

                    if (fileA.type === 'image')
                    {
                        textures.addAtlas(fileA.key, fileA.data, fileB.data);
                    }
                    else
                    {
                        textures.addAtlas(fileB.key, fileB.data, fileA.data);
                    }
                    break;

                case 'unityatlas':

                    fileA = file.fileA;
                    fileB = file.fileB;

                    if (fileA.type === 'image')
                    {
                        textures.addUnityAtlas(fileA.key, fileA.data, fileB.data);
                    }
                    else
                    {
                        textures.addUnityAtlas(fileB.key, fileB.data, fileA.data);
                    }
                    break;

                case 'bitmapfont':

                    fileA = file.fileA;
                    fileB = file.fileB;

                    if (fileA.type === 'image')
                    {
                        cache.bitmapFont.add(fileB.key, { data: ParseXMLBitmapFont(fileB.data), texture: fileA.key, frame: null });
                        textures.addImage(fileA.key, fileA.data);
                    }
                    else
                    {
                        cache.bitmapFont.add(fileA.key, { data: ParseXMLBitmapFont(fileA.data), texture: fileB.key, frame: null });
                        textures.addImage(fileB.key, fileB.data);
                    }
                    break;

                case 'spritesheet':
                    textures.addSpriteSheet(file.key, file.data, file.config);
                    break;

                case 'json':
                    cache.json.add(file.key, file.data);
                    break;

                case 'xml':
                    cache.xml.add(file.key, file.data);
                    break;

                case 'text':
                    cache.text.add(file.key, file.data);
                    break;

                case 'binary':
                    cache.binary.add(file.key, file.data);
                    break;

                case 'sound':
                    cache.sound.add(file.key, file.data);
                    break;

                case 'glsl':
                    cache.shader.add(file.key, file.data);
                    break;
            }
        });

        animJSON.forEach(function (file)
        {
            anims.fromJSON(file.data);
        });

        this.storage.clear();
    },

    reset: function ()
    {
        this.list.clear();
        this.inflight.clear();
        this.failed.clear();
        this.queue.clear();
        this.storage.clear();

        this.events.removeAll('LOADER_START_EVENT');
        this.events.removeAll('LOADER_COMPLETE_EVENT');

        this.tag = '';
        this.path = '';
        this.baseURL = '';

        this.state = CONST.LOADER_IDLE;
    },

    destroy: function ()
    {
        this.reset();
        this.state = CONST.LOADER_DESTROYED;
    }

});

module.exports = BaseLoader;


/***/ }),
/* 787 */
/***/ (function(module, exports) {

var GetURL = function (file, baseURL)
{
    if (!file.url)
    {
        return false;
    }

    if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/))
    {
        return file.url;
    }
    else
    {
        return baseURL + file.url;
    }
};

module.exports = GetURL;


/***/ }),
/* 788 */
/***/ (function(module, exports, __webpack_require__) {

var MergeXHRSettings = __webpack_require__(195);

var XHRLoader = function (file, globalXHRSettings)
{
    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);

    var xhr = new XMLHttpRequest();

    xhr.open('GET', file.src, config.async, config.user, config.password);

    xhr.responseType = file.xhrSettings.responseType;
    xhr.timeout = config.timeout;

    if (config.header && config.headerValue)
    {
        xhr.setRequestHeader(config.header, config.headerValue);
    }

    if (config.overrideMimeType)
    {
        xhr.overrideMimeType(config.overrideMimeType);
    }

    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)

    xhr.onload = file.onLoad.bind(file);
    xhr.onerror = file.onError.bind(file);
    xhr.onprogress = file.onProgress.bind(file);

    //  This is the only standard method, the ones above are browser additions (maybe not universal?)
    // xhr.onreadystatechange

    xhr.send();

    return xhr;
};

module.exports = XHRLoader;


/***/ }),
/* 789 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var LoaderCompleteEvent = new Class({

    Extends: Event,

    initialize:

    function LoaderCompleteEvent (loader)
    {
        Event.call(this, 'LOADER_COMPLETE_EVENT');

        this.loader = loader;
    }

});

module.exports = LoaderCompleteEvent;


/***/ }),
/* 790 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var LoaderStartEvent = new Class({

    Extends: Event,

    initialize:

    function LoaderStartEvent (loader)
    {
        Event.call(this, 'LOADER_START_EVENT');

        this.loader = loader;
    }

});

module.exports = LoaderStartEvent;


/***/ }),
/* 791 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    LOADER_START_EVENT: __webpack_require__(790),
    LOADER_COMPLETE_EVENT: __webpack_require__(789)

};


/***/ }),
/* 792 */
/***/ (function(module, exports, __webpack_require__) {

var JSONFile = __webpack_require__(104);

var AnimationJSONFile = function (key, url, path, xhrSettings)
{
    var json = new JSONFile(key, url, path, xhrSettings);

    //  Override the File type
    json.type = 'animationJSON';

    return json;
};

AnimationJSONFile.create = function (loader, key, url, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new AnimationJSONFile(key[i], url, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new AnimationJSONFile(key, url, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = AnimationJSONFile;


/***/ }),
/* 793 */
/***/ (function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(37);
var JSONFile = __webpack_require__(104);

var AtlasJSONFile = function (key, textureURL, atlasURL, path, textureXhrSettings, atlasXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new JSONFile(key, atlasURL, path, atlasXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'atlasjson';
    data.linkType = 'atlasjson';

    return { texture: image, data: data };
};

module.exports = AtlasJSONFile;


/***/ }),
/* 794 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(16);
var File = __webpack_require__(19);
var GetFastValue = __webpack_require__(11);

//  Phaser.Loader.FileTypes.BinaryFile

var BinaryFile = new Class({

    Extends: File,

    initialize:

    function BinaryFile (key, url, path, xhrSettings)
    {
        var fileKey = (typeof key === 'string') ? key : GetFastValue(key, 'key', '');

        var fileConfig = {
            type: 'binary',
            extension: GetFastValue(key, 'extension', 'bin'),
            responseType: 'arraybuffer',
            key: fileKey,
            url: GetFastValue(key, 'file', url),
            path: path,
            xhrSettings: GetFastValue(key, 'xhr', xhrSettings)
        };

        File.call(this, fileConfig);
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.data = this.xhrLoader.response;

        this.onComplete();

        callback(this);
    }

});

BinaryFile.create = function (loader, key, url, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new BinaryFile(key[i], url, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new BinaryFile(key, url, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = BinaryFile;


/***/ }),
/* 795 */
/***/ (function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(37);
var XMLFile = __webpack_require__(197);

var BitmapFontFile = function (key, textureURL, xmlURL, path, textureXhrSettings, xmlXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new XMLFile(key, xmlURL, path, xmlXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'bitmapfont';
    data.linkType = 'bitmapfont';

    return { texture: image, data: data };
};

module.exports = BitmapFontFile;


/***/ }),
/* 796 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(16);
var File = __webpack_require__(19);
var GetFastValue = __webpack_require__(11);

//  Phaser.Loader.FileTypes.GLSLFile

var GLSLFile = new Class({

    Extends: File,

    initialize:

    function GLSLFile (key, url, path, xhrSettings)
    {
        var fileKey = (typeof key === 'string') ? key : GetFastValue(key, 'key', '');

        var fileConfig = {
            type: 'glsl',
            extension: GetFastValue(key, 'extension', 'glsl'),
            responseType: 'text',
            key: fileKey,
            url: GetFastValue(key, 'file', url),
            path: path,
            xhrSettings: GetFastValue(key, 'xhr', xhrSettings)
        };

        File.call(this, fileConfig);
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.data = this.xhrLoader.responseText;

        this.onComplete();

        callback(this);
    }

});

GLSLFile.create = function (loader, key, url, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new GLSLFile(key[i], url, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new GLSLFile(key, url, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = GLSLFile;


/***/ }),
/* 797 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(16);
var File = __webpack_require__(19);
var GetFastValue = __webpack_require__(11);

//  Phaser.Loader.FileTypes.HTMLFile

var HTMLFile = new Class({

    Extends: File,

    initialize:

    function HTMLFile (key, url, width, height, path, xhrSettings)
    {
        if (width === undefined) { width = 512; }
        if (height === undefined) { height = 512; }

        var fileKey = (typeof key === 'string') ? key : GetFastValue(key, 'key', '');

        var fileConfig = {
            type: 'html',
            extension: GetFastValue(key, 'extension', 'html'),
            responseType: 'text',
            key: fileKey,
            url: GetFastValue(key, 'file', url),
            path: path,
            xhrSettings: GetFastValue(key, 'xhr', xhrSettings),
            config: {
                width: width,
                height: height
            }
        };

        File.call(this, fileConfig);
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        var w = this.config.width;
        var h = this.config.height;

        var data = [];

        data.push('<svg width="' + w + 'px" height="' + h + 'px" viewBox="0 0 ' + w + ' ' + h + '" xmlns="http://www.w3.org/2000/svg">');
        data.push('<foreignObject width="100%" height="100%">');
        data.push('<body xmlns="http://www.w3.org/1999/xhtml">');
        data.push(this.xhrLoader.responseText);
        data.push('</body>');
        data.push('</foreignObject>');
        data.push('</svg>');

        var svg = [ data.join('\n') ];
        var _this = this;

        try
        {
            var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });
        }
        catch (e)
        {
            _this.state = CONST.FILE_ERRORED;

            callback(_this);

            return;
        }

        this.data = new Image();

        this.data.crossOrigin = this.crossOrigin;

        this.data.onload = function ()
        {
            URL.revokeObjectURL(_this.data.src);

            _this.onComplete();

            callback(_this);
        };

        this.data.onerror = function ()
        {
            URL.revokeObjectURL(_this.data.src);

            _this.state = CONST.FILE_ERRORED;

            callback(_this);
        };

        this.data.src = URL.createObjectURL(blob);
    }

});

HTMLFile.create = function (loader, key, url, width, height, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new HTMLFile(key[i], url, width, height, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new HTMLFile(key, url, width, height, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = HTMLFile;


/***/ }),
/* 798 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(16);
var File = __webpack_require__(19);
var GetFastValue = __webpack_require__(11);

//  Phaser.Loader.FileTypes.SVGFile

var SVGFile = new Class({

    Extends: File,

    initialize:

    function SVGFile (key, url, path, xhrSettings)
    {
        var fileKey = (typeof key === 'string') ? key : GetFastValue(key, 'key', '');

        var fileConfig = {
            type: 'svg',
            extension: GetFastValue(key, 'extension', 'svg'),
            responseType: 'text',
            key: fileKey,
            url: GetFastValue(key, 'file', url),
            path: path,
            xhrSettings: GetFastValue(key, 'xhr', xhrSettings)
        };

        File.call(this, fileConfig);
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        var svg = [ this.xhrLoader.responseText ];
        var _this = this;

        try
        {
            var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });
        }
        catch (e)
        {
            _this.state = CONST.FILE_ERRORED;

            callback(_this);

            return;
        }

        this.data = new Image();

        this.data.crossOrigin = this.crossOrigin;

        var retry = false;

        this.data.onload = function ()
        {
            URL.revokeObjectURL(_this.data.src);

            _this.onComplete();

            callback(_this);
        };

        this.data.onerror = function ()
        {
            URL.revokeObjectURL(_this.data.src);

            //  Safari 8 re-try
            if (!retry)
            {
                retry = true;

                var url = 'data:image/svg+xml,' + encodeURIComponent(svg.join(''));

                _this.data.src = URL.createObjectURL(url);
            }
            else
            {
                _this.state = CONST.FILE_ERRORED;

                callback(_this);
            }
        };

        this.data.src = URL.createObjectURL(blob);
    }

});

SVGFile.create = function (loader, key, url, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new SVGFile(key[i], url, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new SVGFile(key, url, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = SVGFile;


/***/ }),
/* 799 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(16);
var File = __webpack_require__(19);
var GetFastValue = __webpack_require__(11);

//  Phaser.Loader.FileTypes.ScriptFile

var ScriptFile = new Class({

    Extends: File,

    initialize:

    function ScriptFile (key, url, path, xhrSettings)
    {
        var fileKey = (typeof key === 'string') ? key : GetFastValue(key, 'key', '');

        var fileConfig = {
            type: 'script',
            extension: GetFastValue(key, 'extension', 'js'),
            responseType: 'text',
            key: fileKey,
            url: GetFastValue(key, 'file', url),
            path: path,
            xhrSettings: GetFastValue(key, 'xhr', xhrSettings)
        };

        File.call(this, fileConfig);
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.data = document.createElement('script');
        this.data.language = 'javascript';
        this.data.type = 'text/javascript';
        this.data.defer = false;
        this.data.text = this.xhrLoader.responseText;

        document.head.appendChild(this.data);

        this.onComplete();

        callback(this);
    }

});

ScriptFile.create = function (loader, key, url, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new ScriptFile(key[i], url, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new ScriptFile(key, url, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = ScriptFile;


/***/ }),
/* 800 */
/***/ (function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(37);

//  config can include: frameWidth, frameHeight, startFrame, endFrame, margin, spacing

var SpriteSheet = function (key, url, config, path, xhrSettings)
{
    var image = new ImageFile(key, url, path, xhrSettings, config);

    //  Override the File type
    image.type = 'spritesheet';

    return image;
};

SpriteSheet.create = function (loader, key, url, config, xhrSettings)
{
    if (Array.isArray(key))
    {
        for (var i = 0; i < key.length; i++)
        {
            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object
            loader.addFile(new SpriteSheet(key[i], url, null, loader.path, xhrSettings));
        }
    }
    else
    {
        loader.addFile(new SpriteSheet(key, url, config, loader.path, xhrSettings));
    }

    //  For method chaining
    return loader;
};

module.exports = SpriteSheet;


/***/ }),
/* 801 */
/***/ (function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(37);
var TextFile = __webpack_require__(196);

var UnityAtlasFile = function (key, textureURL, atlasURL, path, textureXhrSettings, atlasXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new TextFile(key, atlasURL, path, atlasXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'unityatlas';
    data.linkType = 'unityatlas';

    return { texture: image, data: data };
};

module.exports = UnityAtlasFile;


/***/ }),
/* 802 */
/***/ (function(module, exports) {

var Average = function (values)
{
    var sum = 0;

    for (var i = 0; i < values.length; i++)
    {
        sum += (+values[i]);
    }

    return sum / values.length;
};

module.exports = Average;


/***/ }),
/* 803 */
/***/ (function(module, exports) {

var CeilTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.ceil(value * p) / p;
};

module.exports = CeilTo;


/***/ }),
/* 804 */
/***/ (function(module, exports) {

var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ }),
/* 805 */
/***/ (function(module, exports) {

var FloatBetween = function (min, max)
{
    return Math.random() * (max - min) + min;
};

module.exports = FloatBetween;


/***/ }),
/* 806 */
/***/ (function(module, exports) {

var FloorTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.floor(value * p) / p;
};

module.exports = FloorTo;


/***/ }),
/* 807 */
/***/ (function(module, exports) {

//  distance - usually in pixels
//  time - how long should it take to cover the distance? In seconds
//  Returns the amount you will need to increment by each step to cover the distance in the time given
var GetSpeed = function (distance, time)
{
    return (distance / time) / 1000;
};

module.exports = GetSpeed;


/***/ }),
/* 808 */
/***/ (function(module, exports) {

var IsEven = function (value)
{
    // Use abstract equality == for "is number" test
    return (value == parseFloat(value)) ? !(value % 2) : void 0;
};

module.exports = IsEven;


/***/ }),
/* 809 */
/***/ (function(module, exports) {

var IsEvenStrict = function (value)
{
    // Use strict equality === for "is number" test
    return (value === parseFloat(value)) ? !(value % 2) : void 0;
};

module.exports = IsEvenStrict;


/***/ }),
/* 810 */
/***/ (function(module, exports) {


var MaxAdd = function (value, amount, max)
{
    return Math.min(value + amount, max);
};

module.exports = MaxAdd;


/***/ }),
/* 811 */
/***/ (function(module, exports) {

var MinSub = function (value, amount, min)
{
    return Math.max(value - amount, min);
};

module.exports = MinSub;


/***/ }),
/* 812 */
/***/ (function(module, exports) {

//  Work out what % value is of the range between min and max.
//  If max isn't given then you get the % of value to min.
//  You can optionally specify an upperMax, which is a mid-way point in the range
//  that represents 100%, after which the % starts to go down to zero again.

var Percent = function (value, min, max, upperMax)
{
    if (max === undefined) { max = min + 1; }

    var percentage = (value - min) / (max - min);

    if (percentage > 1)
    {
        if (upperMax !== undefined)
        {
            percentage = ((upperMax - value)) / (upperMax - max);

            if (percentage < 0)
            {
                percentage = 0;
            }
        }
        else
        {
            percentage = 1;
        }
    }
    else if (percentage < 0)
    {
        percentage = 0;
    }

    return percentage;
};

module.exports = Percent;


/***/ }),
/* 813 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(13);

var RadToDeg = function (radians)
{
    return radians * CONST.RAD_TO_DEG;
};

module.exports = RadToDeg;


/***/ }),
/* 814 */
/***/ (function(module, exports) {

var RandomXY = function (vector, scale)
{
    if (scale === undefined) { scale = 1; }

    var r = Math.random() * 2 * Math.PI;

    vector.x = Math.cos(r) * scale;
    vector.y = Math.sin(r) * scale;

    return vector;
};

module.exports = RandomXY;


/***/ }),
/* 815 */
/***/ (function(module, exports) {

//  p = Point or any object with public x/y properties

var Rotate = function (point, angle)
{
    var x = point.x;
    var y = point.y;

    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));
    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));

    return point;
};

module.exports = Rotate;


/***/ }),
/* 816 */
/***/ (function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAround = function (point, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = point.x - x;
    var ty = point.y - y;

    point.x = tx * c - ty * s + x;
    point.y = tx * s + ty * c + y;

    return point;
};

module.exports = RotateAround;


/***/ }),
/* 817 */
/***/ (function(module, exports) {

var RoundTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.round(value * p) / p;
};

module.exports = RoundTo;


/***/ }),
/* 818 */
/***/ (function(module, exports) {


var SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)
{
    if (sinAmp === undefined) { sinAmp = 1; }
    if (cosAmp === undefined) { cosAmp = 1; }
    if (frequency === undefined) { frequency = 1; }

    frequency *= Math.PI / length;

    var cos = [];
    var sin = [];

    for (var c = 0; c < length; c++)
    {
        cosAmp -= sinAmp * frequency;
        sinAmp += cosAmp * frequency;

        cos[c] = cosAmp;
        sin[c] = sinAmp;
    }

    return {
        sin: sin,
        cos: cos,
        length: length
    };
};

module.exports = SinCosTableGenerator;


/***/ }),
/* 819 */
/***/ (function(module, exports) {

/**
* Checks if two values are within the given tolerance of each other.
*
* @param {number} a - The first number to check
* @param {number} b - The second number to check
* @param {number} tolerance - The tolerance. Anything equal to or less than this is considered within the range.
* @return {boolean} True if a is <= tolerance of b.
*/
var Within = function (a, b, tolerance)
{
    return (Math.abs(a - b) <= tolerance);
};

module.exports = Within;


/***/ }),
/* 820 */
/***/ (function(module, exports) {

var Between = function (x1, y1, x2, y2)
{
    return Math.atan2(y2 - y1, x2 - x1);
};

module.exports = Between;


/***/ }),
/* 821 */
/***/ (function(module, exports) {

var BetweenPoints = function (point1, point2)
{
    return Math.atan2(point2.y - point1.y, point2.x - point1.x);
};

module.exports = BetweenPoints;


/***/ }),
/* 822 */
/***/ (function(module, exports) {

var BetweenPointsY = function (point1, point2)
{
    return Math.atan2(point2.x - point1.x, point2.y - point1.y);
};

module.exports = BetweenPointsY;


/***/ }),
/* 823 */
/***/ (function(module, exports) {

var BetweenY = function (x1, y1, x2, y2)
{
    return Math.atan2(x2 - x1, y2 - y1);
};

module.exports = BetweenY;


/***/ }),
/* 824 */
/***/ (function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(209);

var Reverse = function (angle)
{
    return Normalize(angle + Math.PI);
};

module.exports = Reverse;


/***/ }),
/* 825 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(13);

/**
* Rotates currentAngle towards targetAngle, taking the shortest rotation distance.
* The lerp argument is the amount to rotate by in this call.
* 
* @param {number} currentAngle - The current angle, in radians.
* @param {number} targetAngle - The target angle to rotate to, in radians.
* @param {number} [lerp=0.05] - The lerp value to add to the current angle.
* @return {number} The adjusted angle.
*/
var RotateTo = function (currentAngle, targetAngle, lerp)
{
    if (lerp === undefined) { lerp = 0.05; }

    if (currentAngle === targetAngle)
    {
        return currentAngle;
    }

    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))
    {
        currentAngle = targetAngle;
    }
    else
    {
        if (Math.abs(targetAngle - currentAngle) > Math.PI)
        {
            if (targetAngle < currentAngle)
            {
                targetAngle += MATH_CONST.PI2;
            }
            else
            {
                targetAngle -= MATH_CONST.PI2;
            }
        }

        if (targetAngle > currentAngle)
        {
            currentAngle += lerp;
        }
        else if (targetAngle < currentAngle)
        {
            currentAngle -= lerp;
        }
    }

    return currentAngle;
};

module.exports = RotateTo;


/***/ }),
/* 826 */
/***/ (function(module, exports) {

/**
* Gets the shortest angle between `angle1` and `angle2`.
* Both angles must be in the range -180 to 180, which is the same clamped
* range that `sprite.angle` uses, so you can pass in two sprite angles to
* this method, and get the shortest angle back between the two of them.
*
* The angle returned will be in the same range. If the returned angle is
* greater than 0 then it's a counter-clockwise rotation, if < 0 then it's
* a clockwise rotation.
* 
* @param {number} angle1 - The first angle. In the range -180 to 180.
* @param {number} angle2 - The second angle. In the range -180 to 180.
* @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.
*/
var ShortestBetween = function (angle1, angle2)
{
    var difference = angle2 - angle1;

    if (difference === 0)
    {
        return 0;
    }

    var times = Math.floor((difference - (-180)) / 360);

    return difference - (times * 360);

};

module.exports = ShortestBetween;


/***/ }),
/* 827 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(820),
    BetweenY: __webpack_require__(823),
    BetweenPoints: __webpack_require__(821),
    BetweenPointsY: __webpack_require__(822),
    Reverse: __webpack_require__(824),
    RotateTo: __webpack_require__(825),
    ShortestBetween: __webpack_require__(826),
    Normalize: __webpack_require__(209),
    Wrap: __webpack_require__(210),
    WrapDegrees: __webpack_require__(211)

};


/***/ }),
/* 828 */
/***/ (function(module, exports) {

var DistancePower = function (x1, y1, x2, y2, pow)
{
    if (pow === undefined) { pow = 2; }

    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
};

module.exports = DistancePower;


/***/ }),
/* 829 */
/***/ (function(module, exports) {

var DistanceSquared = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return dx * dx + dy * dy;
};

module.exports = DistanceSquared;


/***/ }),
/* 830 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(68),
    Power: __webpack_require__(828),
    Squared: __webpack_require__(829)

};


/***/ }),
/* 831 */
/***/ (function(module, exports, __webpack_require__) {

var Back = __webpack_require__(212);
var Bounce = __webpack_require__(213);
var Circular = __webpack_require__(214);
var Cubic = __webpack_require__(215);
var Elastic = __webpack_require__(216);
var Expo = __webpack_require__(217);
var Linear = __webpack_require__(218);
var Quadratic = __webpack_require__(219);
var Quartic = __webpack_require__(220);
var Quintic = __webpack_require__(221);
var Sine = __webpack_require__(222);

//  EaseMap
module.exports = {

    Power0: Linear,
    Power1: Quadratic.Out,
    Power2: Cubic.Out,
    Power3: Quartic.Out,
    Power4: Quintic.Out,

    Linear: Linear,
    Quad: Quadratic.Out,
    Cubic: Cubic.Out,
    Quart: Quartic.Out,
    Quint: Quintic.Out,
    Sine: Sine.Out,
    Expo: Expo.Out,
    Circ: Circular.Out,
    Elastic: Elastic.Out,
    Back: Back.Out,
    Bounce: Bounce.Out,

    'Quad.easeIn': Quadratic.In,
    'Cubic.easeIn': Cubic.In,
    'Quart.easeIn': Quartic.In,
    'Quint.easeIn': Quintic.In,
    'Sine.easeIn': Sine.In,
    'Expo.easeIn': Expo.In,
    'Circ.easeIn': Circular.In,
    'Elastic.easeIn': Elastic.In,
    'Back.easeIn': Back.In,
    'Bounce.easeIn': Bounce.In,

    'Quad.easeOut': Quadratic.Out,
    'Cubic.easeOut': Cubic.Out,
    'Quart.easeOut': Quartic.Out,
    'Quint.easeOut': Quintic.Out,
    'Sine.easeOut': Sine.Out,
    'Expo.easeOut': Expo.Out,
    'Circ.easeOut': Circular.Out,
    'Elastic.easeOut': Elastic.Out,
    'Back.easeOut': Back.Out,
    'Bounce.easeOut': Bounce.Out,

    'Quad.easeInOut': Quadratic.InOut,
    'Cubic.easeInOut': Cubic.InOut,
    'Quart.easeInOut': Quartic.InOut,
    'Quint.easeInOut': Quintic.InOut,
    'Sine.easeInOut': Sine.InOut,
    'Expo.easeInOut': Expo.InOut,
    'Circ.easeInOut': Circular.InOut,
    'Elastic.easeInOut': Elastic.InOut,
    'Back.easeInOut': Back.InOut,
    'Bounce.easeInOut': Bounce.InOut

};


/***/ }),
/* 832 */
/***/ (function(module, exports) {

var Ceil = function (value, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.ceil(value - epsilon);
};

module.exports = Ceil;


/***/ }),
/* 833 */
/***/ (function(module, exports) {

var Equal = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.abs(a - b) < epsilon;
};

module.exports = Equal;


/***/ }),
/* 834 */
/***/ (function(module, exports) {

var Floor = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.floor(value + epsilon);
};

module.exports = Floor;


/***/ }),
/* 835 */
/***/ (function(module, exports) {

var GreaterThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a > b - epsilon;
};

module.exports = GreaterThan;


/***/ }),
/* 836 */
/***/ (function(module, exports) {

var LessThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a < b + epsilon;
};

module.exports = LessThan;


/***/ }),
/* 837 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(832),
    Equal: __webpack_require__(833),
    Floor: __webpack_require__(834),
    GreaterThan: __webpack_require__(835),
    LessThan: __webpack_require__(836)

};


/***/ }),
/* 838 */
/***/ (function(module, exports, __webpack_require__) {

var Bernstein = __webpack_require__(198);

var BezierInterpolation = function (v, k)
{
    var b = 0;
    var n = v.length - 1;

    for (var i = 0; i <= n; i++)
    {
        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
    }

    return b;
};

module.exports = BezierInterpolation;


/***/ }),
/* 839 */
/***/ (function(module, exports, __webpack_require__) {

var CatmullRom = __webpack_require__(105);

var CatmullRomInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (v[0] === v[m])
    {
        if (k < 0)
        {
            i = Math.floor(f = m * (1 + k));
        }

        return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);
    }
    else
    {
        if (k < 0)
        {
            return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);
        }

        if (k > 1)
        {
            return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);
        }

        return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);
    }
};

module.exports = CatmullRomInterpolation;


/***/ }),
/* 840 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Math.Interpolation

module.exports = {

    Bezier: __webpack_require__(838),
    CatmullRom: __webpack_require__(839),
    CubicBezier: __webpack_require__(224),
    Linear: __webpack_require__(225)

};


/***/ }),
/* 841 */
/***/ (function(module, exports) {

//  Is value a power of 2?

var IsValuePowerOfTwo = function (value)
{
    return (value > 0 && (value & (value - 1)) === 0);
};

module.exports = IsValuePowerOfTwo;


/***/ }),
/* 842 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    GetNext: __webpack_require__(226),
    IsSize: __webpack_require__(108),
    IsValue: __webpack_require__(841)

};


/***/ }),
/* 843 */
/***/ (function(module, exports) {

var SnapCeil = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.ceil(value / gap);

    return start + value;
};

module.exports = SnapCeil;


/***/ }),
/* 844 */
/***/ (function(module, exports) {

var SnapFloor = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.floor(value / gap);

    return start + value;
};

module.exports = SnapFloor;


/***/ }),
/* 845 */
/***/ (function(module, exports) {

var SnapTo = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.round(value / gap);

    return start + value;
};

module.exports = SnapTo;


/***/ }),
/* 846 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(843),
    Floor: __webpack_require__(844),
    To: __webpack_require__(845)

};


/***/ }),
/* 847 */
/***/ (function(module, exports, __webpack_require__) {

//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)

var Class = __webpack_require__(0);
var LineCurve = __webpack_require__(228);
var Vector2 = __webpack_require__(20);

//  Local cache vars

var tmpVec2A = new Vector2();
// var tmpVec2B = new Vector2();

var Path = new Class({

    initialize:

    function Path ()
    {
        this.curves = [];

        this.cacheLengths = [];

        // Automatically closes the path
        this.autoClose = false;
    },

    //  If x2/y2 are not given then it creates a line between the previous curve end point (or 0x0) and x1,y1
    addLineCurve: function (x1, y1, x2, y2)
    {
        if (x2 === undefined && y2 === undefined)
        {
            //  Create a line from the previous end point to x1/y1
            x2 = x1;
            y2 = y1;

            var end = this.getEndPoint(tmpVec2A);

            this.curves.push(new LineCurve([ end.x, end.y, x2, y2 ]));
        }
        else
        {
            this.curves.push(new LineCurve([ x1, y1, x2, y2 ]));
        }

        return this;
    },

    add: function (curve)
    {
        this.curves.push(curve);

        return this;
    },

    getEndPoint: function (out)
    {
        if (out === undefined) { out = new Vector2(); }

        if (this.curves.length > 0)
        {
            this.curves[this.curves.length - 1].getPoint(1, out);
        }
        else
        {
            out.set(0, 0);
        }

        return out;
    },

    closePath: function ()
    {
        // Add a line curve if start and end of lines are not connected
        var startPoint = this.curves[0].getPoint(0);
        var endPoint = this.curves[this.curves.length - 1].getPoint(1);

        if (!startPoint.equals(endPoint))
        {
            //  This will copy a reference to the vectors, which probably isn't sensible
            this.curves.push(new LineCurve(endPoint, startPoint));
        }

        return this;
    },

    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:

    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')

    getPoint: function (t, out)
    {
        if (out === undefined) { out = new Vector2(); }

        var d = t * this.getLength();
        var curveLengths = this.getCurveLengths();
        var i = 0;

        // To think about boundaries points.

        while (i < curveLengths.length)
        {
            if (curveLengths[i] >= d)
            {
                var diff = curveLengths[i] - d;
                var curve = this.curves[i];

                var segmentLength = curve.getLength();
                var u = (segmentLength === 0) ? 0 : 1 - diff / segmentLength;

                return curve.getPointAt(u, out);
            }

            i++;
        }

        // loop where sum != 0, sum > d , sum+1 <d
        return null;
    },

    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength

    getLength: function ()
    {
        var lens = this.getCurveLengths();

        return lens[lens.length - 1];
    },

    // cacheLengths must be recalculated.
    updateArcLengths: function ()
    {
        this.needsUpdate = true;
        this.cacheLengths = null;

        this.getCurveLengths();
    },

    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.

    getCurveLengths: function ()
    {
        // We use cache values if curves and cache array are same length

        if (this.cacheLengths.length === this.curves.length)
        {
            return this.cacheLengths;
        }

        // Get length of sub-curve
        // Push sums into cached array

        var lengths = [];
        var sums = 0;

        for (var i = 0; i < this.curves.length; i++)
        {
            sums += this.curves[i].getLength();

            lengths.push(sums);
        }

        this.cacheLengths = lengths;

        return lengths;
    },

    getSpacedPoints: function (divisions)
    {
        if (divisions === undefined) { divisions = 40; }

        var points = [];

        for (var i = 0; i <= divisions; i++)
        {
            points.push(this.getPoint(i / divisions));
        }

        if (this.autoClose)
        {
            points.push(points[0]);
        }

        return points;
    },

    getPoints: function (divisions)
    {
        if (divisions === undefined) { divisions = 12; }

        var points = [];
        var last;

        for (var i = 0; i < this.curves.length; i++)
        {
            var curve = this.curves[i];

            var resolution = curve.getResolution(divisions);

            var pts = curve.getPoints(resolution);

            for (var j = 0; j < pts.length; j++)
            {
                var point = pts[j];

                if (last && last.equals(point))
                {
                    // ensures no consecutive points are duplicates
                    continue;
                }

                points.push(point);

                last = point;
            }
        }

        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0]))
        {
            points.push(points[0]);
        }

        return points;
    }

});

module.exports = Path;


/***/ }),
/* 848 */
/***/ (function(module, exports, __webpack_require__) {

//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)

var Class = __webpack_require__(0);
var CubicBezier = __webpack_require__(224);
var Curve = __webpack_require__(69);
var Vector2 = __webpack_require__(20);

//  Phaser.Curves.CubicBezier

var CubicBezierCurve = new Class({

    Extends: Curve,

    initialize:

    function CubicBezierCurve (v0, v1, v2, v3)
    {
        Curve.call(this);

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    },

    getResolution: function (divisions)
    {
        return divisions;
    },

    getPoint: function (t, out)
    {
        if (out === undefined) { out = new Vector2(); }

        var v0 = this.v0;
        var v1 = this.v1;
        var v2 = this.v2;
        var v3 = this.v3;

        return out.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    }

});

module.exports = CubicBezierCurve;


/***/ }),
/* 849 */
/***/ (function(module, exports, __webpack_require__) {

//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)

var Curve = __webpack_require__(69);
var Class = __webpack_require__(0);
var DegToRad = __webpack_require__(106);
var Vector2 = __webpack_require__(20);

//  Phaser.Curves.Ellipse

var EllipseCurve = new Class({

    Extends: Curve,

    initialize:

    function EllipseCurve (x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation)
    {
        if (yRadius === undefined) { yRadius = xRadius; }
        if (startAngle === undefined) { startAngle = 0; }
        if (endAngle === undefined) { endAngle = 360; }
        if (clockwise === undefined) { clockwise = false; }
        if (rotation === undefined) { rotation = 0; }

        Curve.call(this);

        this.x = x;
        this.y = y;

        this.xRadius = xRadius;
        this.yRadius = yRadius;

        //  Radians
        this.startAngle = DegToRad(startAngle);
        this.endAngle = DegToRad(endAngle);

        //  Boolean (anti-clockwise direction)
        this.clockwise = clockwise;

        //  The rotation of the arc
        this.rotation = DegToRad(rotation);
    },

    getResolution: function (divisions)
    {
        return divisions * 2;
    },

    getPoint: function (t, out)
    {
        if (out === undefined) { out = new Vector2(); }

        var twoPi = Math.PI * 2;
        var deltaAngle = this.endAngle - this.startAngle;
        var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

        // ensures that deltaAngle is 0 .. 2 PI
        while (deltaAngle < 0)
        {
            deltaAngle += twoPi;
        }

        while (deltaAngle > twoPi)
        {
            deltaAngle -= twoPi;
        }

        if (deltaAngle < Number.EPSILON)
        {
            if (samePoints)
            {
                deltaAngle = 0;
            }
            else
            {
                deltaAngle = twoPi;
            }
        }

        if (this.clockwise && ! samePoints)
        {
            if (deltaAngle === twoPi)
            {
                deltaAngle = - twoPi;
            }
            else
            {
                deltaAngle = deltaAngle - twoPi;
            }
        }

        var angle = this.startAngle + t * deltaAngle;
        var x = this.x + this.xRadius * Math.cos(angle);
        var y = this.y + this.yRadius * Math.sin(angle);

        if (this.rotation !== 0)
        {
            var cos = Math.cos(this.rotation);
            var sin = Math.sin(this.rotation);

            var tx = x - this.x;
            var ty = y - this.y;

            // Rotate the point about the center of the ellipse.
            x = tx * cos - ty * sin + this.x;
            y = tx * sin + ty * cos + this.y;
        }

        return out.set(x, y);
    }

});

module.exports = EllipseCurve;


/***/ }),
/* 850 */
/***/ (function(module, exports, __webpack_require__) {

//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)

var CatmullRom = __webpack_require__(105);
var Class = __webpack_require__(0);
var Curve = __webpack_require__(69);
var Vector2 = __webpack_require__(20);

//  Phaser.Curves.Spline

var SplineCurve = new Class({

    Extends: Curve,

    initialize:

    //  Array of vec2s
    function SplineCurve (points)
    {
        if (points === undefined) { points = []; }

        Curve.call(this);

        this.points = points;
    },

    getResolution: function (divisions)
    {
        return divisions * this.points.length;
    },

    getPoint: function (t, out)
    {
        if (out === undefined) { out = new Vector2(); }

        var points = this.points;

        var point = (points.length - 1) * t;

        var intPoint = Math.floor(point);

        var weight = point - intPoint;

        var p0 = points[ (intPoint === 0) ? intPoint : intPoint - 1 ];
        var p1 = points[ intPoint ];
        var p2 = points[ (intPoint > points.length - 2) ? points.length - 1 : intPoint + 1 ];
        var p3 = points[ (intPoint > points.length - 3) ? points.length - 1 : intPoint + 2 ];

        return out.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    }

});

module.exports = SplineCurve;


/***/ }),
/* 851 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {__webpack_require__(271);

var CONST = __webpack_require__(9);
var Extend = __webpack_require__(73);

//  This object is exported globally

/*
var Phaser = {

    Game: require('./boot/Game')

};
*/

var Phaser = {

    Actions: __webpack_require__(117),

    Create: __webpack_require__(262),

    Cameras: __webpack_require__(261),

    DOM: __webpack_require__(263),

    Game: __webpack_require__(260),

    Event: __webpack_require__(2),
    EventDispatcher: __webpack_require__(30),

    Math: __webpack_require__(268),

    Geom: __webpack_require__(265),

    Graphics: __webpack_require__(266),

    Input: __webpack_require__(267),

    GameObjects: __webpack_require__(264),

    Scene: __webpack_require__(48),

    Loader: {

        ImageFile: __webpack_require__(37)

    },

    Sound: __webpack_require__(272),

    Structs: __webpack_require__(273),
    
    Curves: __webpack_require__(269),

    Paths: __webpack_require__(270),

    // Physics: require('./physics'),

    Class: __webpack_require__(0),

    Utils: __webpack_require__(274)

};

//   Merge in the consts

Phaser = Extend(false, Phaser, CONST);

//  Export it

module.exports = Phaser;

global.Phaser = Phaser;

/*
 * "Documentation is like sex:  when it is good, it is very, very good;
 * and when it is bad, it is better than nothing."
 *  -- Dick Brandon
 */

/*
 * "Sometimes, the elegant implementation is just a function.
 * Not a method. Not a class. Not a framework. Just a function."
 *  -- John Carmack
 */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(116)))

/***/ }),
/* 852 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Physics.Impact.Body

var Class = __webpack_require__(0);
var COLLIDES = __webpack_require__(70);
var GetVelocity = __webpack_require__(856);
var TYPE = __webpack_require__(71);
var UpdateMotion = __webpack_require__(864);

/**
* An Impact.js compatible physics body.
* This re-creates the properties you'd get on an Entity and the math needed to update them.
*/

var Body = new Class({

    initialize:

    function Body (world, x, y, sx, sy)
    {
        if (sx === undefined) { sx = 16; }
        if (sy === undefined) { sy = sx; }

        this.world = world;

        this.gameObject = null;

        this.enabled = true;

        this.parent;

        this.id = world.getNextID();

        this.name = '';

        this.size = { x: sx, y: sy };
        this.offset = { x: 0, y: 0 };
        this.pos = { x: x, y: y };
        this.last = { x: x, y: y };
        this.vel = { x: 0, y: 0 };
        this.accel = { x: 0, y: 0 };
        this.friction = { x: 0, y: 0 };
        this.maxVel = { x: world.defaults.maxVelocityX, y: world.defaults.maxVelocityY };

        this.standing = false;

        this.gravityFactor = world.defaults.gravityFactor;
        this.bounciness = world.defaults.bounciness;
        this.minBounceVelocity = world.defaults.minBounceVelocity;

        this.accelGround = 0;
        this.accelAir = 0;
        this.jumpSpeed = 0;
    
        this.type = TYPE.NONE;
        this.checkAgainst = TYPE.NONE;
        this.collides = COLLIDES.NEVER;

        this.debugShowBody = world.defaults.debugShowBody;
        this.debugShowVelocity = world.defaults.debugShowVelocity;
        this.debugBodyColor = world.defaults.bodyDebugColor;

        this.updateCallback;
    
        //  min 44 deg, max 136 deg
        this.slopeStanding = { min: 0.767944870877505, max: 2.3736477827122884 };
    },

    reset: function (x, y)
    {
        this.pos = { x: x, y: y };
        this.last = { x: x, y: y };
        this.vel = { x: 0, y: 0 };
        this.accel = { x: 0, y: 0 };
        this.friction = { x: 0, y: 0 };
        this.maxVel = { x: 100, y: 100 };

        this.standing = false;

        this.gravityFactor = 1;
        this.bounciness = 0;
        this.minBounceVelocity = 40;

        this.accelGround = 0;
        this.accelAir = 0;
        this.jumpSpeed = 0;
    
        this.type = TYPE.NONE;
        this.checkAgainst = TYPE.NONE;
        this.collides = COLLIDES.NEVER;
    },

    update: function (delta)
    {
        var pos = this.pos;

        this.last.x = pos.x;
        this.last.y = pos.y;

        this.vel.y += this.world.gravity * delta * this.gravityFactor;
        
        this.vel.x = GetVelocity(delta, this.vel.x, this.accel.x, this.friction.x, this.maxVel.x);
        this.vel.y = GetVelocity(delta, this.vel.y, this.accel.y, this.friction.y, this.maxVel.y);
        
        var mx = this.vel.x * delta;
        var my = this.vel.y * delta;

        var res = this.world.collisionMap.trace(pos.x, pos.y, mx, my, this.size.x, this.size.y);

        if (this.handleMovementTrace(res))
        {
            UpdateMotion(this, res);
        }

        var go = this.gameObject;

        if (go)
        {
            go.x = (pos.x - this.offset.x) + go.displayOriginX * go.scaleX;
            go.y = (pos.y - this.offset.y) + go.displayOriginY * go.scaleY;
        }

        if (this.updateCallback)
        {
            this.updateCallback(this);
        }
    },

    drawDebug: function (graphic)
    {
        var pos = this.pos;

        if (this.debugShowBody)
        {
            graphic.lineStyle(1, this.debugBodyColor, 1);
            graphic.strokeRect(pos.x, pos.y, this.size.x, this.size.y);
        }

        if (this.debugShowVelocity)
        {
            var x = pos.x + this.size.x / 2;
            var y = pos.y + this.size.y / 2;

            graphic.lineStyle(1, this.world.defaults.velocityDebugColor, 1);
            graphic.lineBetween(x, y, x + this.vel.x, y + this.vel.y);
        }
    },

    willDrawDebug: function ()
    {
        return (this.debugShowBody || this.debugShowVelocity);
    },

    skipHash: function ()
    {
        return (!this.enabled || (this.type === 0 && this.checkAgainst === 0 && this.collides === 0));
    },

    touches: function (other)
    {
        return !(
            this.pos.x >= other.pos.x + other.size.x ||
            this.pos.x + this.size.x <= other.pos.x ||
            this.pos.y >= other.pos.y + other.size.y ||
            this.pos.y + this.size.y <= other.pos.y
        );
    },

    resetSize: function (x, y, width, height)
    {
        this.pos.x = x;
        this.pos.y = y;
        this.size.x = width;
        this.size.y = height;

        return this;
    },

    toJSON: function ()
    {
        var output = {
            name: this.name,
            size: { x: this.size.x, y: this.size.y },
            pos: { x: this.pos.x, y: this.pos.y },
            vel: { x: this.vel.x, y: this.vel.y },
            accel: { x: this.accel.x, y: this.accel.y },
            friction: { x: this.friction.x, y: this.friction.y },
            maxVel: { x: this.maxVel.x, y: this.maxVel.y },
            gravityFactor: this.gravityFactor,
            bounciness: this.bounciness,
            minBounceVelocity: this.minBounceVelocity,
            type: this.type,
            checkAgainst: this.checkAgainst,
            collides: this.collides
        };

        return output;
    },

    fromJSON: function (config)
    {
        //  TODO
    },

    //  Can be overridden by user code
    check: function (other)
    {
    },

    //  Can be overridden by user code
    collideWith: function (other, axis)
    {
        if (this.parent && this.parent._collideCallback)
        {
            this.parent._collideCallback.call(this.parent._callbackScope, this, other, axis);
        }
    },

    //  Can be overridden by user code but must return a boolean
    handleMovementTrace: function (res)
    {
        return true;
    },

    destroy: function ()
    {
        this.enabled = false;

        this.world = null;

        this.gameObject = null;

        this.parent = null;
    }

});

module.exports = Body;


/***/ }),
/* 853 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Physics.Impact.CollisionMap

var Class = __webpack_require__(0);
var DefaultDefs = __webpack_require__(854);

var CollisionMap = new Class({

    initialize:

    function CollisionMap (tilesize, data)
    {
        if (tilesize === undefined) { tilesize = 32; }

        this.tilesize = tilesize;

        this.data = (Array.isArray(data)) ? data : [];

        this.width = (Array.isArray(data)) ? data[0].length : 0;
        this.height = (Array.isArray(data)) ? data.length : 0;

        this.lastSlope = 55;

        this.tiledef = DefaultDefs;
    },

    trace: function (x, y, vx, vy, objectWidth, objectHeight)
    {
        // Set up the trace-result
        var res = {
            collision: { x: false, y: false, slope: false },
            pos: { x: x + vx, y: y + vy },
            tile: { x: 0, y: 0 }
        };

        if (!this.data)
        {
            return res;
        }
        
        var steps = Math.ceil(Math.max(Math.abs(vx), Math.abs(vy)) / this.tilesize);

        if (steps > 1)
        {
            var sx = vx / steps;
            var sy = vy / steps;
            
            for (var i = 0; i < steps && (sx || sy); i++)
            {
                this.step(res, x, y, sx, sy, objectWidth, objectHeight, vx, vy, i);
                
                x = res.pos.x;
                y = res.pos.y;

                if (res.collision.x)
                {
                    sx = 0;
                    vx = 0;
                }

                if (res.collision.y)
                {
                    sy = 0;
                    vy = 0;
                }

                if (res.collision.slope)
                {
                    break;
                }
            }
        }
        else
        {
            this.step(res, x, y, vx, vy, objectWidth, objectHeight, vx, vy, 0);
        }
        
        return res;
    },

    step: function (res, x, y, vx, vy, width, height, rvx, rvy, step)
    {
        var t = 0;
        var tileX;
        var tileY;
        var tilesize = this.tilesize;
        var mapWidth = this.width;
        var mapHeight = this.height;
        
        //  Horizontal
        if (vx)
        {
            var pxOffsetX = (vx > 0 ? width : 0);
            var tileOffsetX = (vx < 0 ? tilesize : 0);
            
            var firstTileY = Math.max(Math.floor(y / tilesize), 0);
            var lastTileY = Math.min(Math.ceil((y + height) / tilesize), mapHeight);
            
            tileX = Math.floor((res.pos.x + pxOffsetX) / tilesize);

            var prevTileX = Math.floor((x + pxOffsetX) / tilesize);

            if (step > 0 || tileX === prevTileX || prevTileX < 0 || prevTileX >= mapWidth)
            {
                prevTileX = -1;
            }
           
            if (tileX >= 0 && tileX < mapWidth)
            {
                for (tileY = firstTileY; tileY < lastTileY; tileY++)
                {
                    if (prevTileX !== -1)
                    {
                        t = this.data[tileY][prevTileX];

                        if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, prevTileX, tileY))
                        {
                            break;
                        }
                    }
                    
                    t = this.data[tileY][tileX];

                    if (t === 1 || t > this.lastSlope || (t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)))
                    {
                        if (t > 1 && t <= this.lastSlope && res.collision.slope)
                        {
                            break;
                        }
                        
                        res.collision.x = true;
                        res.tile.x = t;
                        res.pos.x = (tileX * tilesize) - pxOffsetX + tileOffsetX;
                        x = res.pos.x;
                        rvx = 0;

                        break;
                    }
                }
            }
        }
        
        //  Vertical
        if (vy)
        {
            var pxOffsetY = (vy > 0 ? height : 0);
            var tileOffsetY = (vy < 0 ? tilesize : 0);
            
            var firstTileX = Math.max(Math.floor(res.pos.x / tilesize), 0);
            var lastTileX = Math.min(Math.ceil((res.pos.x + width) / tilesize), mapWidth);
            
            tileY = Math.floor((res.pos.y + pxOffsetY) / tilesize);
            
            var prevTileY = Math.floor((y + pxOffsetY) / tilesize);

            if (step > 0 || tileY === prevTileY || prevTileY < 0 || prevTileY >= mapHeight)
            {
                prevTileY = -1;
            }
            
            if (tileY >= 0 && tileY < mapHeight)
            {
                for (tileX = firstTileX; tileX < lastTileX; tileX++)
                {
                    if (prevTileY !== -1)
                    {
                        t = this.data[prevTileY][tileX];

                        if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, prevTileY))
                        {
                            break;
                        }
                    }
                    
                    t = this.data[tileY][tileX];

                    if (t === 1 || t > this.lastSlope || (t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)))
                    {
                        if (t > 1 && t <= this.lastSlope && res.collision.slope)
                        {
                            break;
                        }
                        
                        res.collision.y = true;
                        res.tile.y = t;
                        res.pos.y = tileY * tilesize - pxOffsetY + tileOffsetY;

                        break;
                    }
                }
            }
        }
    },
    
    checkDef: function (res, t, x, y, vx, vy, width, height, tileX, tileY)
    {
        var def = this.tiledef[t];

        if (!def)
        {
            return false;
        }

        var tilesize = this.tilesize;
        
        var lx = (tileX + def[0]) * tilesize;
        var ly = (tileY + def[1]) * tilesize;
        var lvx = (def[2] - def[0]) * tilesize;
        var lvy = (def[3] - def[1]) * tilesize;
        var solid = def[4];
        
        var tx = x + vx + (lvy < 0 ? width : 0) - lx;
        var ty = y + vy + (lvx > 0 ? height : 0) - ly;
        
        if (lvx * ty - lvy * tx > 0)
        {
            if (vx * -lvy + vy * lvx < 0)
            {
                return solid;
            }
            
            var length = Math.sqrt(lvx * lvx + lvy * lvy);
            var nx = lvy / length;
            var ny = -lvx / length;
            
            var proj = tx * nx + ty * ny;
            var px = nx * proj;
            var py = ny * proj;
            
            if (px * px + py * py >= vx * vx + vy * vy)
            {
                return solid || (lvx * (ty - vy) - lvy * (tx - vx) < 0.5);
            }
            
            res.pos.x = x + vx - px;
            res.pos.y = y + vy - py;
            res.collision.slope = { x: lvx, y: lvy, nx: nx, ny: ny };

            return true;
        }
        
        return false;
    }

});

module.exports = CollisionMap;


/***/ }),
/* 854 */
/***/ (function(module, exports) {

var H = 0.5;
var N = 1 / 3;
var M = 2 / 3;

//  Tile ID to Slope defs.
//  First 4 elements = line data, final = solid or non-solid behind the line
    
module.exports = {

    2: [ 0, 1, 1, 0, true ],
    3: [ 0, 1, 1, H, true ],
    4: [ 0, H, 1, 0, true ],
    5: [ 0, 1, 1, M, true ],
    6: [ 0, M, 1, N, true ],
    7: [ 0, N, 1, 0, true ],
    8: [ H, 1, 0, 0, true ],
    9: [ 1, 0, H, 1, true ],
    10: [ H, 1, 1, 0, true ],
    11: [ 0, 0, H, 1, true ],
    12: [ 0, 0, 1, 0, false ],
    13: [ 1, 1, 0, 0, true ],
    14: [ 1, H, 0, 0, true ],
    15: [ 1, 1, 0, H, true ],
    16: [ 1, N, 0, 0, true ],
    17: [ 1, M, 0, N, true ],
    18: [ 1, 1, 0, M, true ],
    19: [ 1, 1, H, 0, true ],
    20: [ H, 0, 0, 1, true ],
    21: [ 0, 1, H, 0, true ],
    22: [ H, 0, 1, 1, true ],
    23: [ 1, 1, 0, 1, false ],
    24: [ 0, 0, 1, 1, true ],
    25: [ 0, 0, 1, H, true ],
    26: [ 0, H, 1, 1, true ],
    27: [ 0, 0, 1, N, true ],
    28: [ 0, N, 1, M, true ],
    29: [ 0, M, 1, 1, true ],
    30: [ N, 1, 0, 0, true ],
    31: [ 1, 0, M, 1, true ],
    32: [ M, 1, 1, 0, true ],
    33: [ 0, 0, N, 1, true ],
    34: [ 1, 0, 1, 1, false ],
    35: [ 1, 0, 0, 1, true ],
    36: [ 1, H, 0, 1, true ],
    37: [ 1, 0, 0, H, true ],
    38: [ 1, M, 0, 1, true ],
    39: [ 1, N, 0, M, true ],
    40: [ 1, 0, 0, N, true ],
    41: [ M, 1, N, 0, true ],
    42: [ M, 0, N, 1, true ],
    43: [ N, 1, M, 0, true ],
    44: [ N, 0, M, 1, true ],
    45: [ 0, 1, 0, 0, false ],
    52: [ 1, 1, M, 0, true ],
    53: [ N, 0, 0, 1, true ],
    54: [ 0, 1, N, 0, true ],
    55: [ M, 0, 1, 1, true ]

};


/***/ }),
/* 855 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var ImpactBody = __webpack_require__(858);
var ImpactImage = __webpack_require__(859);
var ImpactSprite = __webpack_require__(860);

var Factory = new Class({

    initialize:

    function Factory (world)
    {
        this.world = world;

        this.sys = world.scene.sys;
    },

    body: function (x, y, width, height)
    {
        return new ImpactBody(this.world, x, y, width, height);
    },

    image: function (x, y, key, frame)
    {
        var image = new ImpactImage(this.world, x, y, key, frame);

        this.sys.displayList.add(image);

        return image;
    },

    sprite: function (x, y, key, frame)
    {
        var sprite = new ImpactSprite(this.world, x, y, key, frame);

        this.sys.displayList.add(sprite);
        this.sys.updateList.add(sprite);

        return sprite;
    }

});

module.exports = Factory;


/***/ }),
/* 856 */
/***/ (function(module, exports, __webpack_require__) {

var Clamp = __webpack_require__(52);

var GetVelocity = function (delta, vel, accel, friction, max)
{
    if (accel)
    {
        return Clamp(vel + accel * delta, -max, max);
    }
    else if (friction)
    {
        var frictionDelta = friction * delta;
        
        if (vel - frictionDelta > 0)
        {
            return vel - frictionDelta;
        }
        else if (vel + frictionDelta < 0)
        {
            return vel + frictionDelta;
        }
        else
        {
            return 0;
        }
    }

    return Clamp(vel, -max, max);
};

module.exports = GetVelocity;


/***/ }),
/* 857 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Merge = __webpack_require__(115);
var World = __webpack_require__(865);
var Factory = __webpack_require__(855);

var Impact = new Class({

    initialize:

    function Impact (physicsManager, config)
    {
        this.config = config;

        physicsManager.world = new World(physicsManager.scene, config);

        physicsManager.add = new Factory(physicsManager.world);
    }

});

module.exports = Impact;


/***/ }),
/* 858 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var Components = __webpack_require__(109);

var ImpactBody = new Class({

    Mixins: [
        Components.Acceleration,
        Components.BodyScale,
        Components.BodyType,
        Components.Bounce,
        Components.CheckAgainst,
        Components.Collides,
        Components.Debug,
        Components.Friction,
        Components.Gravity,
        Components.Offset,
        Components.SetGameObject,
        Components.Velocity
    ],

    initialize:

    //  x/y is the top-left of the Body
    function ImpactBody (world, x, y, width, height)
    {
        this.body = world.create(x, y, width, height);

        this.body.parent = this;

        //  Local references to the Body properties
        this.size = this.body.size;
        this.offset = this.body.offset;
        this.vel = this.body.vel;
        this.accel = this.body.accel;
        this.friction = this.body.friction;
        this.maxVel = this.body.maxVel;
    }

});

module.exports = ImpactBody;


/***/ }),
/* 859 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var Components = __webpack_require__(109);
var Image = __webpack_require__(56);

var ImpactImage = new Class({

    Extends: Image,

    Mixins: [
        Components.Acceleration,
        Components.BodyScale,
        Components.BodyType,
        Components.Bounce,
        Components.CheckAgainst,
        Components.Collides,
        Components.Debug,
        Components.Friction,
        Components.Gravity,
        Components.Offset,
        Components.SetGameObject,
        Components.Velocity
    ],

    initialize:

    //  x/y is the center of the Image / Body, just like other default Game Objects
    function ImpactImage (world, x, y, texture, frame)
    {
        Image.call(this, world.scene, x, y, texture, frame);

        this.body = world.create(x - this.frame.centerX, y - this.frame.centerY, this.width, this.height);

        this.body.parent = this;
        this.body.gameObject = this;

        //  Local references to the Body properties
        this.size = this.body.size;
        this.offset = this.body.offset;
        this.vel = this.body.vel;
        this.accel = this.body.accel;
        this.friction = this.body.friction;
        this.maxVel = this.body.maxVel;
    }

});

module.exports = ImpactImage;


/***/ }),
/* 860 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var Components = __webpack_require__(109);
var Sprite = __webpack_require__(31);

var ImpactSprite = new Class({

    Extends: Sprite,

    Mixins: [
        Components.Acceleration,
        Components.BodyScale,
        Components.BodyType,
        Components.Bounce,
        Components.CheckAgainst,
        Components.Collides,
        Components.Debug,
        Components.Friction,
        Components.Gravity,
        Components.Offset,
        Components.SetGameObject,
        Components.Velocity
    ],

    initialize:

    //  x/y is the center of the Sprite / Body, just like other default Game Objects
    function ImpactSprite (world, x, y, texture, frame)
    {
        Sprite.call(this, world.scene, x, y, texture, frame);

        this.body = world.create(x - this.frame.centerX, y - this.frame.centerY, this.width, this.height);

        this.body.parent = this;
        this.body.gameObject = this;

        //  Local references to the Body properties
        this.size = this.body.size;
        this.offset = this.body.offset;
        this.vel = this.body.vel;
        this.accel = this.body.accel;
        this.friction = this.body.friction;
        this.maxVel = this.body.maxVel;
    }

});

module.exports = ImpactSprite;


/***/ }),
/* 861 */
/***/ (function(module, exports) {


var SeperateX = function (world, left, right, weak)
{
    var nudge = left.pos.x + left.size.x - right.pos.x;
    
    // We have a weak entity, so just move this one
    if (weak)
    {
        var strong = (left === weak) ? right : left;

        weak.vel.x = -weak.vel.x * weak.bounciness + strong.vel.x;
        
        var resWeak = world.collisionMap.trace(weak.pos.x, weak.pos.y, weak === left ? -nudge : nudge, 0, weak.size.x, weak.size.y);

        weak.pos.x = resWeak.pos.x;
    }
    else
    {
        var v2 = (left.vel.x - right.vel.x) / 2;

        left.vel.x = -v2;
        right.vel.x = v2;
    
        var resLeft = world.collisionMap.trace(left.pos.x, left.pos.y, -nudge / 2, 0, left.size.x, left.size.y);

        left.pos.x = Math.floor(resLeft.pos.x);
        
        var resRight = world.collisionMap.trace(right.pos.x, right.pos.y, nudge / 2, 0, right.size.x, right.size.y);

        right.pos.x = Math.ceil(resRight.pos.x);
    }
};

module.exports = SeperateX;


/***/ }),
/* 862 */
/***/ (function(module, exports) {


var SeperateY = function (world, top, bottom, weak)
{
    var nudge = (top.pos.y + top.size.y - bottom.pos.y);
    var nudgeX;
    var resTop;
    
    if (weak)
    {
        var strong = (top === weak) ? bottom : top;

        weak.vel.y = -weak.vel.y * weak.bounciness + strong.vel.y;
        
        // Riding on a platform?
        nudgeX = 0;

        if (weak === top && Math.abs(weak.vel.y - strong.vel.y) < weak.minBounceVelocity)
        {
            weak.standing = true;
            nudgeX = strong.vel.x * world.delta;
        }
        
        var resWeak = world.collisionMap.trace(weak.pos.x, weak.pos.y, nudgeX, weak === top ? -nudge : nudge, weak.size.x, weak.size.y);

        weak.pos.y = resWeak.pos.y;
        weak.pos.x = resWeak.pos.x;
    }
    else if (world.gravity && (bottom.standing || top.vel.y > 0))
    {
        resTop = world.collisionMap.trace(top.pos.x, top.pos.y, 0, -(top.pos.y + top.size.y - bottom.pos.y), top.size.x, top.size.y);

        top.pos.y = resTop.pos.y;
        
        if (top.bounciness > 0 && top.vel.y > top.minBounceVelocity)
        {
            top.vel.y *= -top.bounciness;
        }
        else
        {
            top.standing = true;
            top.vel.y = 0;
        }
    }
    else
    {
        var v2 = (top.vel.y - bottom.vel.y) / 2;

        top.vel.y = -v2;
        bottom.vel.y = v2;
        
        nudgeX = bottom.vel.x * world.delta;

        resTop = world.collisionMap.trace(top.pos.x, top.pos.y, nudgeX, -nudge / 2, top.size.x, top.size.y);

        top.pos.y = resTop.pos.y;
        
        var resBottom = world.collisionMap.trace(bottom.pos.x, bottom.pos.y, 0, nudge / 2, bottom.size.x, bottom.size.y);

        bottom.pos.y = resBottom.pos.y;
    }
};

module.exports = SeperateY;


/***/ }),
/* 863 */
/***/ (function(module, exports, __webpack_require__) {

var SeperateX = __webpack_require__(861);
var SeperateY = __webpack_require__(862);
var COLLIDES = __webpack_require__(70);
var Events = __webpack_require__(879);

//  Impact Physics Solver

var Solver = function (world, bodyA, bodyB)
{
    var weak = null;

    if (bodyA.collides === COLLIDES.LITE || bodyB.collides === COLLIDES.FIXED)
    {
        weak = bodyA;
    }
    else if (bodyB.collides === COLLIDES.LITE || bodyA.collides === COLLIDES.FIXED)
    {
        weak = bodyB;
    }

    if (bodyA.last.x + bodyA.size.x > bodyB.last.x && bodyA.last.x < bodyB.last.x + bodyB.size.x)
    {
        if (bodyA.last.y < bodyB.last.y)
        {
            SeperateY(world, bodyA, bodyB, weak);
        }
        else
        {
            SeperateY(world, bodyB, bodyA, weak);
        }

        bodyA.collideWith(bodyB, 'y');
        bodyB.collideWith(bodyA, 'y');

        world.events.dispatch(new Events.COLLIDE(bodyA, bodyB, 'y'));
    }
    else if (bodyA.last.y + bodyA.size.y > bodyB.last.y && bodyA.last.y < bodyB.last.y + bodyB.size.y)
    {
        if (bodyA.last.x < bodyB.last.x)
        {
            SeperateX(world, bodyA, bodyB, weak);
        }
        else
        {
            SeperateX(world, bodyB, bodyA, weak);
        }

        bodyA.collideWith(bodyB, 'x');
        bodyB.collideWith(bodyA, 'x');

        world.events.dispatch(new Events.COLLIDE(bodyA, bodyB, 'x'));
    }
};

module.exports = Solver;


/***/ }),
/* 864 */
/***/ (function(module, exports) {

// Set up the trace-result
// var res = {
//     collision: {x: false, y: false, slope: false},
//     pos: {x: x, y: y},
//     tile: {x: 0, y: 0}
// };

var UpdateMotion = function (body, res)
{
    body.standing = false;

    //  Y
    if (res.collision.y)
    {
        if (body.bounciness > 0 && Math.abs(body.vel.y) > body.minBounceVelocity)
        {
            body.vel.y *= -body.bounciness;
        }
        else
        {
            if (body.vel.y > 0)
            {
                body.standing = true;
            }

            body.vel.y = 0;
        }
    }

    //  X
    if (res.collision.x)
    {
        if (body.bounciness > 0 && Math.abs(body.vel.x) > body.minBounceVelocity)
        {
            body.vel.x *= -body.bounciness;
        }
        else
        {
            body.vel.x = 0;
        }
    }

    //  SLOPE
    if (res.collision.slope)
    {
        var s = res.collision.slope;
       
        if (body.bounciness > 0)
        {
            var proj = body.vel.x * s.nx + body.vel.y * s.ny;

            body.vel.x = (body.vel.x - s.nx * proj * 2) * body.bounciness;
            body.vel.y = (body.vel.y - s.ny * proj * 2) * body.bounciness;
        }
        else
        {
            var lengthSquared = s.x * s.x + s.y * s.y;
            var dot = (body.vel.x * s.x + body.vel.y * s.y) / lengthSquared;
            
            body.vel.x = s.x * dot;
            body.vel.y = s.y * dot;
            
            var angle = Math.atan2(s.x, s.y);

            if (angle > body.slopeStanding.min && angle < body.slopeStanding.max)
            {
                body.standing = true;
            }
        }
    }

    body.pos.x = res.pos.x;
    body.pos.y = res.pos.y;
};

module.exports = UpdateMotion;


/***/ }),
/* 865 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Physics.Impact.World

var Body = __webpack_require__(852);
var Class = __webpack_require__(0);
var COLLIDES = __webpack_require__(70);
var CollisionMap = __webpack_require__(853);
var GetFastValue = __webpack_require__(11);
var Set = __webpack_require__(54);
var Solver = __webpack_require__(863);
var TYPE = __webpack_require__(71);

var World = new Class({

    initialize:

    function World (scene, config)
    {
        this.scene = scene;

        this.events = scene.sys.events;

        this.bodies = new Set();

        this.gravity = GetFastValue(config, 'gravity', 0);

        //  Spatial hash cell dimensions
        this.cellSize = GetFastValue(config, 'cellSize', 64);

        this.collisionMap = new CollisionMap();

        this.timeScale = GetFastValue(config, 'timeScale', 1);

        //  Impacts maximum time step is 20 fps.
        this.maxStep = GetFastValue(config, 'maxStep', 0.05);

        this.enabled = true;

        this.drawDebug = GetFastValue(config, 'debug', false);

        this.debugGraphic;

        var _maxVelocity = GetFastValue(config, 'maxVelocity', 100);

        this.defaults = {
            debugShowBody: GetFastValue(config, 'debugShowBody', true),
            debugShowVelocity: GetFastValue(config, 'debugShowVelocity', true),
            bodyDebugColor: GetFastValue(config, 'debugBodyColor', 0xff00ff),
            velocityDebugColor: GetFastValue(config, 'debugVelocityColor', 0x00ff00),
            maxVelocityX: GetFastValue(config, 'maxVelocityX', _maxVelocity),
            maxVelocityY: GetFastValue(config, 'maxVelocityY', _maxVelocity),
            minBounceVelocity: GetFastValue(config, 'minBounceVelocity', 40),
            gravityFactor: GetFastValue(config, 'gravityFactor', 1),
            bounciness: GetFastValue(config, 'bounciness', 0)
        };

        /**
        * @property {object} walls - An object containing the 4 wall bodies that bound the physics world.
        */
        this.walls = { left: null, right: null, top: null, bottom: null };
    
        this.delta = 0;

        this._lastId = 0;

        if (GetFastValue(config, 'setBounds', false))
        {
            var boundsConfig = config['setBounds'];

            if (typeof boundsConfig === 'boolean')
            {
                this.setBounds();
            }
            else
            {
                var x = GetFastValue(boundsConfig, 'x', 0);
                var y = GetFastValue(boundsConfig, 'y', 0);
                var width = GetFastValue(boundsConfig, 'width', scene.sys.game.config.width);
                var height = GetFastValue(boundsConfig, 'height', scene.sys.game.config.height);
                var thickness = GetFastValue(boundsConfig, 'thickness', 64);
                var left = GetFastValue(boundsConfig, 'left', true);
                var right = GetFastValue(boundsConfig, 'right', true);
                var top = GetFastValue(boundsConfig, 'top', true);
                var bottom = GetFastValue(boundsConfig, 'bottom', true);

                this.setBounds(x, y, width, height, thickness, left, right, top, bottom);
            }
        }

        if (this.drawDebug)
        {
            this.createDebugGraphic();
        }
    },

    setCollisionMap: function (tilesize, data)
    {
        this.collisionMap = new CollisionMap(tilesize, data);

        return this.collisionMap;
    },

    /**
    * Sets the bounds of the Physics world to match the given world pixel dimensions.
    * You can optionally set which 'walls' to create: left, right, top or bottom.
    * If none of the walls are given it will default to use the walls settings it had previously.
    * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size
    * the newly created bounds will also not have the left and right walls.
    * Explicitly state them in the parameters to override this.
    *
    * @method Phaser.Physics.P2#setBounds
    * @param {number} x - The x coordinate of the top-left corner of the bounds.
    * @param {number} y - The y coordinate of the top-left corner of the bounds.
    * @param {number} width - The width of the bounds.
    * @param {number} height - The height of the bounds.
    * @param {boolean} [left=true] - If true will create the left bounds wall.
    * @param {boolean} [right=true] - If true will create the right bounds wall.
    * @param {boolean} [top=true] - If true will create the top bounds wall.
    * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.
    */
    setBounds: function (x, y, width, height, thickness, left, right, top, bottom)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (width === undefined) { width = this.scene.sys.game.config.width; }
        if (height === undefined) { height = this.scene.sys.game.config.height; }
        if (thickness === undefined) { thickness = 64; }
        if (left === undefined) { left = true; }
        if (right === undefined) { right = true; }
        if (top === undefined) { top = true; }
        if (bottom === undefined) { bottom = true; }

        this.updateWall(left, 'left', x - thickness, y, thickness, height);
        this.updateWall(right, 'right', x + width, y, thickness, height);
        this.updateWall(top, 'top', x, y - thickness, width, thickness);
        this.updateWall(bottom, 'bottom', x, y + height, width, thickness);

        return this;
    },

    //  position = 'left', 'right', 'top' or 'bottom'
    updateWall: function (add, position, x, y, width, height)
    {
        var wall = this.walls[position];

        if (add)
        {
            if (wall)
            {
                wall.resetSize(x, y, width, height);
            }
            else
            {
                this.walls[position] = this.create(x, y, width, height);
                this.walls[position].name = position;
                this.walls[position].gravityFactor = 0;
                this.walls[position].collides = COLLIDES.FIXED;
            }
        }
        else
        {
            if (wall)
            {
                this.bodies.remove(wall);
            }

            this.walls[position] = null;
        }
    },

    createDebugGraphic: function ()
    {
        var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });

        graphic.setZ(Number.MAX_SAFE_INTEGER);

        this.debugGraphic = graphic;

        this.drawDebug = true;

        return graphic;
    },

    getNextID: function ()
    {
        return this._lastId++;
    },

    create: function (x, y, sizeX, sizeY)
    {
        var body = new Body(this, x, y, sizeX, sizeY);

        this.bodies.set(body);

        return body;
    },

    pause: function ()
    {
        this.enabled = false;

        return this;
    },

    resume: function ()
    {
        this.enabled = true;

        return this;
    },

    update: function (time, delta)
    {
        if (!this.enabled || this.bodies.size === 0)
        {
            return;
        }

        //  Impact uses a divided delta value that is clamped to the maxStep (20fps) maximum
        this.delta = Math.min(delta / 1000, this.maxStep) * this.timeScale;

        //  Update all active bodies

        var i;
        var body;
        var bodies = this.bodies.entries;
        var len = bodies.length;
        var hash = {};
        var size = this.cellSize;

        for (i = 0; i < len; i++)
        {
            body = bodies[i];

            if (body.enabled)
            {
                body.update(this.delta);
            }
        }

        //  Run collision against them all now they're in the new positions from the update

        for (i = 0; i < len; i++)
        {
            body = bodies[i];

            if (!body.skipHash())
            {
                this.checkHash(body, hash, size);
            }
        }

        if (this.drawDebug)
        {
            var graphics = this.debugGraphic;

            graphics.clear();

            for (i = 0; i < len; i++)
            {
                body = bodies[i];

                if (body.willDrawDebug())
                {
                    body.drawDebug(graphics);
                }
            }
        }
    },

    //  Check the body against the spatial hash
    checkHash: function (body, hash, size)
    {
        var checked = {};

        var xmin = Math.floor(body.pos.x / size);
        var ymin = Math.floor(body.pos.y / size);
        var xmax = Math.floor((body.pos.x + body.size.x) / size) + 1;
        var ymax = Math.floor((body.pos.y + body.size.y) / size) + 1;

        for (var x = xmin; x < xmax; x++)
        {
            for (var y = ymin; y < ymax; y++)
            {
                if (!hash[x])
                {
                    hash[x] = {};
                    hash[x][y] = [ body ];
                }
                else if (!hash[x][y])
                {
                    hash[x][y] = [ body ];
                }
                else
                {
                    var cell = hash[x][y];

                    for (var c = 0; c < cell.length; c++)
                    {
                        if (body.touches(cell[c]) && !checked[cell[c].id])
                        {
                            checked[cell[c].id] = true;

                            this.checkBodies(body, cell[c]);
                        }
                    }

                    cell.push(body);
                }
            }
        }
    },

    checkBodies: function (bodyA, bodyB)
    {
        //  2 fixed bodies won't do anything
        if (bodyA.collides === COLLIDES.FIXED && bodyB.collides === COLLIDES.FIXED)
        {
            return;
        }

        //  bitwise checks
        if (bodyA.checkAgainst & bodyB.type)
        {
            bodyA.check(bodyB);
        }
        
        if (bodyB.checkAgainst & bodyA.type)
        {
            bodyB.check(bodyA);
        }
        
        if (bodyA.collides && bodyB.collides && bodyA.collides + bodyB.collides > COLLIDES.ACTIVE)
        {
            Solver(this, bodyA, bodyB);
        }
    },

    //////////////
    //  Helpers //
    //////////////

    setCollidesNever: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].collides = COLLIDES.NEVER;
        }

        return this;
    },

    setLite: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].collides = COLLIDES.LITE;
        }

        return this;
    },

    setPassive: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].collides = COLLIDES.PASSIVE;
        }

        return this;
    },

    setActive: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].collides = COLLIDES.ACTIVE;
        }

        return this;
    },

    setFixed: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].collides = COLLIDES.FIXED;
        }

        return this;
    },

    setTypeNone: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].type = TYPE.NONE;
        }

        return this;
    },

    setTypeA: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].type = TYPE.A;
        }

        return this;
    },

    setTypeB: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].type = TYPE.B;
        }

        return this;
    },

    setAvsB: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].type = TYPE.A;
            bodies[i].checkAgainst = TYPE.B;
        }

        return this;
    },

    setBvsA: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].type = TYPE.B;
            bodies[i].checkAgainst = TYPE.A;
        }

        return this;
    },

    setCheckAgainstNone: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].checkAgainst = TYPE.NONE;
        }

        return this;
    },

    setCheckAgainstA: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].checkAgainst = TYPE.A;
        }

        return this;
    },

    setCheckAgainstB: function (bodies)
    {
        for (var i = 0; i < bodies.length; i++)
        {
            bodies[i].checkAgainst = TYPE.B;
        }

        return this;
    },

    destroy: function ()
    {
        this.scene = null;

        this.events = null;

        this.bodies.clear();

        this.bodies = null;

        this.collisionMap = null;
    }

});

module.exports = World;


/***/ }),
/* 866 */
/***/ (function(module, exports) {

var Acceleration = {

    setAccelerationX: function (x)
    {
        this.accel.x = x;

        return this;
    },

    setAccelerationY: function (y)
    {
        this.accel.y = y;

        return this;
    },

    setAcceleration: function (x, y)
    {
        this.accel.x = x;
        this.accel.y = y;

        return this;
    }

};

module.exports = Acceleration;


/***/ }),
/* 867 */
/***/ (function(module, exports) {

var BodyScale = {

    setBodySize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.body.size.x = Math.round(width);
        this.body.size.y = Math.round(height);

        return this;
    },

    setBodyScale: function (scaleX, scaleY)
    {
        if (scaleY === undefined) { scaleY = scaleX; }

        var gameObject = this.body.gameObject;

        if (gameObject)
        {
            gameObject.setScale(scaleX, scaleY);

            return this.setBodySize(gameObject.width * gameObject.scaleX, gameObject.height * gameObject.scaleY);
        }
        else
        {
            return this.setBodySize(this.body.size.x * scaleX, this.body.size.y * scaleY);
        }
    }

};

module.exports = BodyScale;


/***/ }),
/* 868 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(71);

var BodyType = {

    getBodyType: function ()
    {
        return this.body.type;
    },

    setTypeNone: function ()
    {
        this.body.type = TYPE.NONE;

        return this;
    },

    setTypeA: function ()
    {
        this.body.type = TYPE.A;

        return this;
    },

    setTypeB: function ()
    {
        this.body.type = TYPE.B;

        return this;
    }

};

module.exports = BodyType;


/***/ }),
/* 869 */
/***/ (function(module, exports) {

var Bounce = {

    setBounce: function (value)
    {
        this.body.bounciness = value;

        return this;
    },

    setMinBounceVelocity: function (value)
    {
        this.body.minBounceVelocity = value;

        return this;
    },

    bounce: {

        get: function ()
        {
            return this.body.bounciness;
        },

        set: function (value)
        {
            this.body.bounciness = value;
        }

    }

};

module.exports = Bounce;


/***/ }),
/* 870 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(71);

var CheckAgainst = {

    setAvsB: function ()
    {
        this.setTypeA();

        return this.setCheckAgainstB();
    },

    setBvsA: function ()
    {
        this.setTypeB();

        return this.setCheckAgainstA();
    },

    setCheckAgainstNone: function ()
    {
        this.body.checkAgainst = TYPE.NONE;

        return this;
    },

    setCheckAgainstA: function ()
    {
        this.body.checkAgainst = TYPE.A;

        return this;
    },

    setCheckAgainstB: function ()
    {
        this.body.checkAgainst = TYPE.B;

        return this;
    },

    checkAgainst: {

        get: function ()
        {
            return this.body.checkAgainst;
        },

        set: function (value)
        {
            this.body.checkAgainst = value;
        }

    }

};

module.exports = CheckAgainst;


/***/ }),
/* 871 */
/***/ (function(module, exports, __webpack_require__) {

var COLLIDES = __webpack_require__(70);

var Collides = {

    _collideCallback: null,
    _callbackScope: null,

    setCollideCallback: function (callback, scope)
    {
        this._collideCallback = callback;

        if (scope)
        {
            this._callbackScope = scope;
        }

        return this;
    },

    setCollidesNever: function ()
    {
        this.body.collides = COLLIDES.NEVER;

        return this;
    },

    setLite: function ()
    {
        this.body.collides = COLLIDES.LITE;

        return this;
    },

    setPassive: function ()
    {
        this.body.collides = COLLIDES.PASSIVE;

        return this;
    },

    setActive: function ()
    {
        this.body.collides = COLLIDES.ACTIVE;

        return this;
    },

    setFixed: function ()
    {
        this.body.collides = COLLIDES.FIXED;

        return this;
    },

    collides: {

        get: function ()
        {
            return this.body.collides;
        },

        set: function (value)
        {
            this.body.collides = value;
        }

    }

};

module.exports = Collides;


/***/ }),
/* 872 */
/***/ (function(module, exports) {

var Debug = {

    setDebug: function (showBody, showVelocity, bodyColor)
    {
        this.debugShowBody = showBody;
        this.debugShowVelocity = showVelocity;
        this.debugBodyColor = bodyColor;

        return this;
    },

    setDebugBodyColor: function (value)
    {
        this.body.debugBodyColor = value;

        return this;
    },

    debugShowBody: {

        get: function ()
        {
            return this.body.debugShowBody;
        },

        set: function (value)
        {
            this.body.debugShowBody = value;
        }

    },

    debugShowVelocity: {

        get: function ()
        {
            return this.body.debugShowVelocity;
        },

        set: function (value)
        {
            this.body.debugShowVelocity = value;
        }

    },

    debugBodyColor: {

        get: function ()
        {
            return this.body.debugBodyColor;
        },

        set: function (value)
        {
            this.body.debugBodyColor = value;
        }

    }

};

module.exports = Debug;


/***/ }),
/* 873 */
/***/ (function(module, exports) {

var Friction = {

    setFrictionX: function (x)
    {
        this.friction.x = x;

        return this;
    },

    setFrictionY: function (y)
    {
        this.friction.y = y;

        return this;
    },

    setFriction: function (x, y)
    {
        this.friction.x = x;
        this.friction.y = y;

        return this;
    }

};

module.exports = Friction;


/***/ }),
/* 874 */
/***/ (function(module, exports) {

var Gravity = {

    setGravity: function (value)
    {
        this.body.gravityFactor = value;

        return this;
    },

    gravity: {

        get: function ()
        {
            return this.body.gravityFactor;
        },

        set: function (value)
        {
            this.body.gravityFactor = value;
        }

    }

};

module.exports = Gravity;


/***/ }),
/* 875 */
/***/ (function(module, exports) {

var Offset = {

    setOffset: function (x, y, width, height)
    {
        this.body.offset.x = x;
        this.body.offset.y = y;

        if (width)
        {
            this.setBodySize(width, height);
        }

        return this;
    }

};

module.exports = Offset;


/***/ }),
/* 876 */
/***/ (function(module, exports) {

var SetGameObject = {

    setGameObject: function (gameObject, sync)
    {
        if (sync === undefined) { sync = true; }

        if (gameObject)
        {
            this.body.gameObject = gameObject;

            if (sync)
            {
                this.syncGameObject();
            }
        }
        else
        {
            this.body.gameObject = null;
        }

        return this;
    },

    syncGameObject: function ()
    {
        var gameObject = this.body.gameObject;

        if (gameObject)
        {
            this.setBodySize(gameObject.width * gameObject.scaleX, gameObject.height * gameObject.scaleY);
        }

        return this;
    }

};

module.exports = SetGameObject;


/***/ }),
/* 877 */
/***/ (function(module, exports) {

var Velocity = {

    setVelocityX: function (x)
    {
        this.vel.x = x;

        return this;
    },

    setVelocityY: function (y)
    {
        this.vel.y = y;

        return this;
    },

    setVelocity: function (x, y)
    {
        this.vel.x = x;
        this.vel.y = y;

        return this;
    },

    setMaxVelocity: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.maxVel.x = x;
        this.maxVel.y = y;

        return this;
    }

};

module.exports = Velocity;


/***/ }),
/* 878 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Event = __webpack_require__(2);

var CollideEvent = new Class({

    Extends: Event,

    initialize:

    function CollideEvent (bodyA, bodyB, axis)
    {
        Event.call(this, 'COLLIDE_EVENT');

        //  The first body involved in the collision]
        this.bodyA = bodyA;

        //  The second body involved in the collision]
        this.bodyB = bodyB;

        //  The Game Object associated with bodyA (if any)
        this.gameObjectA = bodyA.gameObject;

        //  The Game Object associated with bodyB (if any)
        this.gameObjectB = bodyB.gameObject;

        //  Either 'x' or 'y'
        this.axis = axis;
    }

});

module.exports = CollideEvent;


/***/ }),
/* 879 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Physics.Impact.Events

module.exports = {

    COLLIDE: __webpack_require__(878)

};


/***/ }),
/* 880 */
/***/ (function(module, exports) {

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function (fun /*, thisArg */)
    {
        'use strict';

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== 'function')
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}


/***/ }),
/* 881 */
/***/ (function(module, exports) {

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}


/***/ }),
/* 882 */
/***/ (function(module, exports) {

/* Copyright 2013 Chris Wilson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*

This monkeypatch library is intended to be included in projects that are
written to the proper AudioContext spec (instead of webkitAudioContext),
and that use the new naming and proper bits of the Web Audio API (e.g.
using BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may
have to run on systems that only support the deprecated bits.

This library should be harmless to include if the browser supports
unprefixed "AudioContext", and/or if it supports the new names.

The patches this library handles:
if window.AudioContext is unsupported, it will be aliased to webkitAudioContext().
if AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or
noteGrainOn(), depending on parameters.

The following aliases only take effect if the new names are not already in place:

AudioBufferSourceNode.stop() is aliased to noteOff()
AudioContext.createGain() is aliased to createGainNode()
AudioContext.createDelay() is aliased to createDelayNode()
AudioContext.createScriptProcessor() is aliased to createJavaScriptNode()
AudioContext.createPeriodicWave() is aliased to createWaveTable()
OscillatorNode.start() is aliased to noteOn()
OscillatorNode.stop() is aliased to noteOff()
OscillatorNode.setPeriodicWave() is aliased to setWaveTable()
AudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()

This library does NOT patch the enumerated type changes, as it is
recommended in the specification that implementations support both integer
and string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel
BiquadFilterNode.type and OscillatorNode.type.

*/
(function (global, exports, perf) {
  'use strict';

  function fixSetTarget(param) {
    if (!param)	// if NYI, just return
      return;
    if (!param.setTargetAtTime)
      param.setTargetAtTime = param.setTargetValueAtTime;
  }

  if (window.hasOwnProperty('webkitAudioContext') &&
      !window.hasOwnProperty('AudioContext')) {
    window.AudioContext = webkitAudioContext;

    if (!AudioContext.prototype.hasOwnProperty('createGain'))
      AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
    if (!AudioContext.prototype.hasOwnProperty('createDelay'))
      AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
    if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor'))
      AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;
    if (!AudioContext.prototype.hasOwnProperty('createPeriodicWave'))
      AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;


    AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;
    AudioContext.prototype.createGain = function() {
      var node = this.internal_createGain();
      fixSetTarget(node.gain);
      return node;
    };

    AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;
    AudioContext.prototype.createDelay = function(maxDelayTime) {
      var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();
      fixSetTarget(node.delayTime);
      return node;
    };

    AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;
    AudioContext.prototype.createBufferSource = function() {
      var node = this.internal_createBufferSource();
      if (!node.start) {
        node.start = function ( when, offset, duration ) {
          if ( offset || duration )
            this.noteGrainOn( when || 0, offset, duration );
          else
            this.noteOn( when || 0 );
        };
      } else {
        node.internal_start = node.start;
        node.start = function( when, offset, duration ) {
          if( typeof duration !== 'undefined' )
            node.internal_start( when || 0, offset, duration );
          else
            node.internal_start( when || 0, offset || 0 );
        };
      }
      if (!node.stop) {
        node.stop = function ( when ) {
          this.noteOff( when || 0 );
        };
      } else {
        node.internal_stop = node.stop;
        node.stop = function( when ) {
          node.internal_stop( when || 0 );
        };
      }
      fixSetTarget(node.playbackRate);
      return node;
    };

    AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;
    AudioContext.prototype.createDynamicsCompressor = function() {
      var node = this.internal_createDynamicsCompressor();
      fixSetTarget(node.threshold);
      fixSetTarget(node.knee);
      fixSetTarget(node.ratio);
      fixSetTarget(node.reduction);
      fixSetTarget(node.attack);
      fixSetTarget(node.release);
      return node;
    };

    AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;
    AudioContext.prototype.createBiquadFilter = function() {
      var node = this.internal_createBiquadFilter();
      fixSetTarget(node.frequency);
      fixSetTarget(node.detune);
      fixSetTarget(node.Q);
      fixSetTarget(node.gain);
      return node;
    };

    if (AudioContext.prototype.hasOwnProperty( 'createOscillator' )) {
      AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;
      AudioContext.prototype.createOscillator = function() {
        var node = this.internal_createOscillator();
        if (!node.start) {
          node.start = function ( when ) {
            this.noteOn( when || 0 );
          };
        } else {
          node.internal_start = node.start;
          node.start = function ( when ) {
            node.internal_start( when || 0);
          };
        }
        if (!node.stop) {
          node.stop = function ( when ) {
            this.noteOff( when || 0 );
          };
        } else {
          node.internal_stop = node.stop;
          node.stop = function( when ) {
            node.internal_stop( when || 0 );
          };
        }
        if (!node.setPeriodicWave)
          node.setPeriodicWave = node.setWaveTable;
        fixSetTarget(node.frequency);
        fixSetTarget(node.detune);
        return node;
      };
    }
  }

  if (window.hasOwnProperty('webkitOfflineAudioContext') &&
      !window.hasOwnProperty('OfflineAudioContext')) {
    window.OfflineAudioContext = webkitOfflineAudioContext;
  }

}(window));



/***/ }),
/* 883 */
/***/ (function(module, exports) {

/**
* A polyfill for Function.prototype.bind
*/
if (!Function.prototype.bind) {

    /* jshint freeze: false */
    Function.prototype.bind = (function () {

        var slice = Array.prototype.slice;

        return function (thisArg) {

            var target = this, boundArgs = slice.call(arguments, 1);

            if (typeof target !== 'function')
            {
                throw new TypeError();
            }

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args);
            }

            bound.prototype = (function F(proto) {
                if (proto)
                {
                    F.prototype = proto;
                }

                if (!(this instanceof F))
                {
                    /* jshint supernew: true */
                    return new F;
                }
            })(target.prototype);

            return bound;
        };
    })();
}



/***/ }),
/* 884 */
/***/ (function(module, exports) {

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}


/***/ }),
/* 885 */
/***/ (function(module, exports) {

/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}


/***/ }),
/* 886 */
/***/ (function(module, exports) {

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}


/***/ }),
/* 887 */
/***/ (function(module, exports) {

/**
 * performance.now
 */
(function () {

    if ('performance' in window === false)
    {
        window.performance = {};
    }

    //  Thanks IE8
    Date.now = (Date.now || function () {
        return new Date().getTime();
    });

    if ('now' in window.performance === false)
    {
        var nowOffset = Date.now();

        if (performance.timing && performance.timing.navigationStart)
        {
            nowOffset = performance.timing.navigationStart;
        }

        window.performance.now = function now ()
        {
            return Date.now() - nowOffset;
        }
    }

})();


/***/ }),
/* 888 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();
    if (!global.performance) {
        global.performance = {};
    }
    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
        global[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now(),
            delay = 16 + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(116)))

/***/ }),
/* 889 */
/***/ (function(module, exports, __webpack_require__) {

var BlitImage = __webpack_require__(890);
var CanvasSnapshot = __webpack_require__(893);
var Class = __webpack_require__(0);
var CONST = __webpack_require__(9);
var DrawImage = __webpack_require__(891);
var GetBlendModes = __webpack_require__(892);
var GetContext = __webpack_require__(125);
var ScaleModes = __webpack_require__(35);
var Smoothing = __webpack_require__(76);

var CanvasRenderer = new Class({

    initialize:

    function CanvasRenderer (game)
    {
        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        this.game = game;

        //  Needed?
        this.type = CONST.CANVAS;

        this.drawCount = 0;

        //  Read all the following from game config (or Scene config?)
        // this.clearBeforeRender = true;
        // this.transparent = false;
        // this.autoResize = false;
        // this.roundPixels = false;

        this.width = game.config.width * game.config.resolution;
        this.height = game.config.height * game.config.resolution;
        this.resolution = game.config.resolution;

        this.scaleMode = (game.config.pixelArt) ? ScaleModes.NEAREST : ScaleModes.LINEAR;

        this.gameCanvas = game.canvas;

        /**
         * The canvas 2d context that everything is drawn with
         * @property context
         * @type CanvasRenderingContext2D
         */
        this.gameContext = GetContext(this.gameCanvas);

        this.gameConfig = game.config;

        this.currentContext = this.gameContext;

        //  Map to the required function
        this.drawImage = DrawImage;
        this.blitImage = BlitImage;

        this.blendModes = GetBlendModes();

        this.currentAlpha = 1;
        this.currentBlendMode = 0;
        this.currentScaleMode = 0;

        // this.tintMethod = this.tintWithPerPixel;

        this.init();
    },

    init: function ()
    {
        this.resize(this.width, this.height);
    },

    //  Resize the main game canvas
    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.gameCanvas.width = this.width;
        this.gameCanvas.height = this.height;

        if (this.autoResize)
        {
            this.gameCanvas.style.width = (this.width / res) + 'px';
            this.gameCanvas.style.height = (this.height / res) + 'px';
        }

        //  Resizing a canvas will reset imageSmoothingEnabled (and probably other properties)
        if (this.scaleMode === ScaleModes.NEAREST)
        {
            Smoothing.disable(this.gameContext);
        }
    },

    addContextLostCallback: function (callback)
    {
    },

    addContextRestoredCallback: function (callback)
    {
    },


    resetTransform: function ()
    {
        this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
    },

    setBlendMode: function (blendMode)
    {
        if (this.currentBlendMode !== blendMode)
        {
            this.currentContext.globalCompositeOperation = blendMode;
            this.currentBlendMode = blendMode;
        }

        return this.currentBlendMode;
    },

    setAlpha: function (alpha)
    {
        if (this.currentAlpha !== alpha)
        {
            this.currentContext.globalAlpha = alpha;
            this.currentAlpha = alpha;
        }

        return this.currentAlpha;
    },

    //  Call at the start of the render loop
    preRender: function ()
    {
        // console.log('%c render start ', 'color: #ffffff; background: #00ff00;');

        var ctx = this.gameContext;
        var config = this.gameConfig;

        var width = this.width;
        var height = this.height;

        if (config.clearBeforeRender)
        {
            ctx.clearRect(0, 0, width, height);
        }

        if (!config.transparent)
        {
            ctx.fillStyle = config.backgroundColor.rgba;
            ctx.fillRect(0, 0, width, height);
        }

        //  Add Pre-render hook

        this.drawCount = 0;
    },

    /**
     * Renders the Scene.
     *
     * @method render
     * @param {Phaser.Scene} scene - The Scene to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (scene, children, interpolationPercentage, camera)
    {
        // var w = scene.sys.width;
        // var h = scene.sys.height;
        var ctx = scene.sys.context;
        var settings = scene.sys.settings;
        var scissor = (camera.x !== 0 || camera.y !== 0 || camera.width !== ctx.canvas.width || camera.height !== ctx.canvas.height);
        var list = children.list;

        this.currentContext = ctx;

        //  If the alpha or blend mode didn't change since the last render, then don't set them again (saves 2 ops)

        if (!camera.transparent)
        {
            ctx.fillStyle = camera.backgroundColor.rgba;
            ctx.fillRect(0, 0, camera.width, camera.height);
        }

        if (this.currentAlpha !== 1)
        {
            ctx.globalAlpha = 1;
            this.currentAlpha = 1;
        }

        if (this.currentBlendMode !== 0)
        {
            ctx.globalCompositeOperation = 'source-over';
            this.currentBlendMode = 0;
        }

        this.currentScaleMode = 0;

        this.drawCount += list.length;

        if (scissor)
        {
            ctx.save();
            ctx.beginPath();
            ctx.rect(camera.x, camera.y, camera.width, camera.height);
            ctx.clip();
            ctx.closePath();
        }

        var matrix = camera.matrix.matrix;

        ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);

        for (var c = 0; c < list.length; c++)
        {
            var child = list[c];

            child.renderCanvas(this, child, interpolationPercentage, camera);
        }

        //  Call the Scene.render function
        scene.render.call(scene, ctx, interpolationPercentage);
        
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (camera._fadeAlpha > 0 || camera._flashAlpha > 0)
        {
            // fade rendering
            ctx.fillStyle = 'rgb(' + (camera._fadeRed * 255) + ',' + (camera._fadeGreen * 255) + ',' + (camera._fadeBlue * 255) + ')';
            ctx.globalAlpha = camera._fadeAlpha;
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

            // flash rendering
            ctx.fillStyle = 'rgb(' + (camera._flashRed * 255) + ',' + (camera._flashGreen * 255) + ',' + (camera._flashBlue * 255) + ')';
            ctx.globalAlpha = camera._flashAlpha;
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

            ctx.globalAlpha = 1.0;
        }

        //  Reset the camera scissor
        if (scissor)
        {
            ctx.restore();
        }
        
        //  Blast it to the Game Canvas (if needed)
        // if (settings.renderToTexture)
        // {
            // this.gameContext.drawImage(scene.sys.canvas, 0, 0, w, h, settings.x, settings.y, w, h);
        // }
    },

    postRender: function ()
    {
        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');

        var ctx = this.gameContext;

        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';

        this.currentAlpha = 1;
        this.currentBlendMode = 0;

        if (this.snapshotCallback)
        {
            this.snapshotCallback(CanvasSnapshot(this.gameCanvas));
            this.snapshotCallback = null;
        }

        //  Add Post-render hook
    },

    snapshot: function (callback)
    {
        this.snapshotCallback = callback;
    },

    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @method destroy
     * @param [removegameCanvas=true] {boolean} Removes the Canvas element from the DOM.
     */
    destroy: function ()
    {
        //  CanvasPool

        this.gameCanvas = null;
        this.gameContext = null;
    }

});

module.exports = CanvasRenderer;


/***/ }),
/* 890 */
/***/ (function(module, exports) {


//  No scaling, anchor, rotation or effects, literally draws the frame directly to the canvas
var BlitImage = function (dx, dy, frame, camera)
{
    var ctx = this.currentContext;
    var cd = frame.canvasData;

    ctx.drawImage(
        frame.source.image,
        cd.sx,
        cd.sy,
        cd.sWidth,
        cd.sHeight,
        dx - camera.scrollX,
        dy - camera.scrollY,
        cd.dWidth,
        cd.dHeight
    );
};

module.exports = BlitImage;


/***/ }),
/* 891 */
/***/ (function(module, exports) {


var DrawImage = function (src, camera)
{
    var ctx = this.currentContext;
    var frame = src.frame;
    var cd = frame.canvasData;

    //  Blend Mode

    if (this.currentBlendMode !== src.blendMode)
    {
        this.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = this.blendModes[src.blendMode];
    }

    //  Alpha

    if (this.currentAlpha !== src.alpha)
    {
        this.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing

    if (this.currentScaleMode !== src.scaleMode)
    {
        this.currentScaleMode = src.scaleMode;
        // ctx[this.smoothProperty] = (source.scaleMode === ScaleModes.LINEAR);
    }

    var dx = frame.x;
    var dy = frame.y;

    var fx = 1;
    var fy = 1;

    if (src.flipX)
    {
        fx = -1;
        dx -= cd.dWidth - src.displayOriginX;
    }
    else
    {
        dx -= src.displayOriginX;
    }

    if (src.flipY)
    {
        fy = -1;
        dy -= cd.dHeight - src.displayOriginY;
    }
    else
    {
        dy -= src.displayOriginY;
    }

    //  Perform Matrix ITRS

    ctx.save();

    ctx.translate(src.x - camera.scrollX * src.scrollFactorX, src.y - camera.scrollY * src.scrollFactorY);

    ctx.rotate(src.rotation);

    ctx.scale(src.scaleX, src.scaleY);
    ctx.scale(fx, fy);

    ctx.drawImage(frame.source.image, cd.sx, cd.sy, cd.sWidth, cd.sHeight, dx, dy, cd.dWidth, cd.dHeight);

    ctx.restore();
};

module.exports = DrawImage;


/***/ }),
/* 892 */
/***/ (function(module, exports, __webpack_require__) {

var modes = __webpack_require__(42);
var CanvasFeatures = __webpack_require__(128);

var GetBlendModes = function ()
{
    var output = [];
    var useNew = CanvasFeatures.supportNewBlendModes;

    output[modes.NORMAL] = 'source-over';
    output[modes.ADD] = 'lighter';
    output[modes.MULTIPLY] = (useNew) ? 'multiply' : 'source-over';
    output[modes.SCREEN] = (useNew) ? 'screen' : 'source-over';
    output[modes.OVERLAY] = (useNew) ? 'overlay' : 'source-over';
    output[modes.DARKEN] = (useNew) ? 'darken' : 'source-over';
    output[modes.LIGHTEN] = (useNew) ? 'lighten' : 'source-over';
    output[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : 'source-over';
    output[modes.COLOR_BURN] = (useNew) ? 'color-burn' : 'source-over';
    output[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : 'source-over';
    output[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : 'source-over';
    output[modes.DIFFERENCE] = (useNew) ? 'difference' : 'source-over';
    output[modes.EXCLUSION] = (useNew) ? 'exclusion' : 'source-over';
    output[modes.HUE] = (useNew) ? 'hue' : 'source-over';
    output[modes.SATURATION] = (useNew) ? 'saturation' : 'source-over';
    output[modes.COLOR] = (useNew) ? 'color' : 'source-over';
    output[modes.LUMINOSITY] = (useNew) ? 'luminosity' : 'source-over';

    return output;
};

module.exports = GetBlendModes;


/***/ }),
/* 893 */
/***/ (function(module, exports) {

var CanvasSnapshot = function (canvas)
{
    var src = canvas.toDataURL();

    var image = new Image();

    image.src = src;

    return image;
};

module.exports = CanvasSnapshot;


/***/ }),
/* 894 */
/***/ (function(module, exports) {

var WebGLSnapshot = function (sourceCanvas)
{
    var gl = sourceCanvas.getContext('experimental-webgl');
    var pixels = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
    gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

    //  CanvasPool?
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var imageData;

    canvas.width = gl.drawingBufferWidth;
    canvas.height = gl.drawingBufferHeight;

    imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

    var data = imageData.data;

    for (var y = 0; y < canvas.height; y += 1)
    {
        for (var x = 0; x < canvas.width; x += 1)
        {
            var si = ((canvas.height - y) * canvas.width + x) * 4;
            var di = (y * canvas.width + x) * 4;
            data[di + 0] = pixels[si + 0];
            data[di + 1] = pixels[si + 1];
            data[di + 2] = pixels[si + 2];
            data[di + 3] = pixels[si + 3];
        }
    }

    ctx.putImageData(imageData, 0, 0);

    var src = canvas.toDataURL();
    var image = new Image();

    image.src = src;

    return image;
};

module.exports = WebGLSnapshot;


/***/ }),
/* 895 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Resources = __webpack_require__(231);

var ResourceManager = new Class({

    initialize:

    function ResourceManager (gl)
    {
        this.gl = gl;

        //  Maybe add pooling here?
        this.shaderCache = {};
        this.shaderCount = 0;
    },

    createRenderTarget: function (width, height, colorBuffer, depthStencilBuffer)
    {
        var gl = this.gl;
        var framebufferObject = gl.createFramebuffer();
        var depthStencilRenderbufferObject = null;
        var colorRenderbufferObject = null;
        var complete = 0;

        gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferObject);

        if (depthStencilBuffer !== undefined && depthStencilBuffer !== null)
        {
            depthStencilBuffer.isRenderTexture = true;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, depthStencilBuffer.texture, depthStencilBuffer.mipLevel);
        }
        else
        {
            depthStencilRenderbufferObject = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilRenderbufferObject);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilRenderbufferObject);
        }

        if (colorBuffer !== undefined && colorBuffer !== null)
        {
            colorBuffer.isRenderTexture = true;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorBuffer.texture, colorBuffer.mipLevel);
        }
        else
        {
            colorRenderbufferObject = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, colorRenderbufferObject);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, colorRenderbufferObject);
        }

        complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        if (complete !== gl.FRAMEBUFFER_COMPLETE)
        {
            var errors = {
                36054: 'Incomplete Attachment',
                36055: 'Missing Attachment',
                36057: 'Incomplete Dimensions',
                36061: 'Framebuffer Unsupported'
            };
            throw new Error('Framebuffer incomplete. Framebuffer status: ' + errors[complete]);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return new Resources.RenderTarget(
            framebufferObject,
            width, height,
            (colorBuffer === undefined ? null : colorBuffer),
            (depthStencilBuffer === undefined ? null : depthStencilBuffer)
        );
    },

    createBuffer: function (target, initialDataOrSize, bufferUsage)
    {
        var gl = this.gl;
        var bufferObject = gl.createBuffer();
        gl.bindBuffer(target, bufferObject);
        gl.bufferData(target, initialDataOrSize, bufferUsage);

        switch (target)
        {
            case gl.ARRAY_BUFFER:
                return new Resources.VertexBuffer(gl, bufferObject);

            case gl.ELEMENT_ARRAY_BUFFER:
                return new Resources.IndexBuffer(gl, bufferObject);

            default:
                throw new Error('Invalid Buffer Target');
        }
    },

    createTexture: function (mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height)
    {
        var gl = this.gl;
        var texture = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);

        if (pixels === null || pixels === undefined)
        {
            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);
        }
        else
        {
            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);
            width = pixels.width;
            height = pixels.height;
        }

        gl.bindTexture(gl.TEXTURE_2D, null);

        return new Resources.Texture(texture, width, height);
    },

    createShader: function (shaderName, shaderSources)
    {
        if (shaderName === null || shaderName === undefined)
        {
            shaderName += 'Shader' + this.shaderCount;
            this.shaderCount += 1;
        }

        if (!(shaderName in this.shaderCache))
        {
            var gl = this.gl;
            var program;
            var vertShader;
            var fragShader;
            var status;
            var error;
            var shader;

            vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, shaderSources.vert);
            gl.compileShader(vertShader);

            status = gl.getShaderParameter(vertShader, gl.COMPILE_STATUS);
            error = gl.getShaderInfoLog(vertShader);

            if (!status && error && error.length > 0)
            {
                throw new Error('Vertex Shader Compilation Error. Shader name: ' + shaderName + '.\n' + error + '\n\n Shader source:\n' + shaderSources.vert);
            }
            else if (error && error.length > 10)
            {
                console.warn('Vertex Shader Compilation Warning. Shader name: ' + shaderName + '.\n' + error + '\n\n Shader source:\n' + shaderSources.vert);
            }

            fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, shaderSources.frag);
            gl.compileShader(fragShader);

            status = gl.getShaderParameter(fragShader, gl.COMPILE_STATUS);
            error = gl.getShaderInfoLog(fragShader);

            if (!status && error && error.length > 0)
            {
                throw new Error('Fragment Shader Compilation Error. Shader name: ' + shaderName + '.\n' + error + '\n\n Shader source:\n' + shaderSources.frag);
            }
            else if (error && error.length > 10)
            {
                console.warn('Fragment Shader Compilation Warning. Shader name: ' + shaderName + '.\n' + error + '\n\n Shader source:\n' + shaderSources.frag);
            }

            program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            gl.validateProgram(program);

            status = gl.getProgramParameter(program, gl.LINK_STATUS);
            error = gl.getProgramInfoLog(program);

            if (!status && error && error.length > 0)
            {
                throw new Error('Program Linking Error. Shader name: ' + shaderName + '.\n' + error);
            }
            else if (error && error.length > 10)
            {
                console.warn('Program Linking Warning. Shader name: ' + shaderName + '.\n' + error);
            }

            status = gl.getProgramParameter(program, gl.VALIDATE_STATUS);
            error = gl.getProgramInfoLog(program);

            if (!status && error && error.length > 0)
            {
                throw new Error('Program Validation Error. Shader name: ' + shaderName + '.\n' + error);
            }
            else if (error && error.length > 10)
            {
                console.warn('Program Validation Warning. Shader name: ' + shaderName + '.\n' + error);
            }

            shader = new Resources.Shader(shaderName, gl, program, vertShader, fragShader);

            this.shaderCache[shaderName] = shader;

            return shader;
        }
        else
        {
            return this.shaderCache[shaderName];
        }
    },

    deleteShader: function (shader)
    {
        var storedShader = this.shaderCache[shader.name];

        var gl = this.gl;

        if (storedShader !== undefined)
        {
            delete this.shaderCache[shader.name];
        }

        gl.deleteShader(shader.vertexShader);
        gl.deleteShader(shader.fragmentShader);
        gl.deleteProgram(shader.program);

        shader.vertexShader = null;
        shader.fragmentShader = null;
        shader.program = null;
        shader.name = null;
    },

    deleteBuffer: function (buffer)
    {
        var gl = this.gl;

        gl.deleteBuffer(buffer.bufferObject);
    }

});

module.exports = ResourceManager;


/***/ }),
/* 896 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey (@photonstorm)
* @author       Felipe Alfonso (@bitnenfer)
* @copyright    2017 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var BlendModes = __webpack_require__(42);
var BlitterBatch = __webpack_require__(897);
var Class = __webpack_require__(0);
var CONST = __webpack_require__(9);
var EffectRenderer = __webpack_require__(899);
var IsSizePowerOfTwo = __webpack_require__(108);
var QuadBatch = __webpack_require__(903);
var ParticleRenderer = __webpack_require__(901);
var ResourceManager = __webpack_require__(895);
var Resources = __webpack_require__(231);
var ScaleModes = __webpack_require__(35);
var ShapeBatch = __webpack_require__(905);
var SpriteBatch = __webpack_require__(907);
var TileBatch = __webpack_require__(909);
var TilemapRenderer = __webpack_require__(911);
var WebGLSnapshot = __webpack_require__(894);

var WebGLRenderer = new Class({

    initialize:

    function WebGLRenderer (game)
    {
        var _this = this;
        this.game = game;
        this.onContextLostCallbacks = [];
        this.onContextRestoredCallbacks = [];
        this.type = CONST.WEBGL;
        this.width = game.config.width * game.config.resolution;
        this.height = game.config.height * game.config.resolution;
        this.resolution = game.config.resolution;
        this.view = game.canvas;
        this.view.addEventListener('webglcontextlost', function (evt) {
            var callbacks = _this.onContextLostCallbacks;
            var renderers = _this.rendererArray;
            for (var index = 0; index < renderers.length; ++index)
            {
                renderers[index].destroy();
            }
            _this.contextLost = true;
            for (var index = 0; index < callbacks.length; ++index)
            {
                callbacks[index](_this);
            }
            evt.preventDefault();
        }, false);

        this.view.addEventListener('webglcontextrestored', function (evt) {
            var callbacks = _this.onContextRestoredCallbacks;
            _this.rendererArray.length = 0;
            _this.resourceManager.shaderCache = {};
            _this.resourceManager.shaderCount = 0;
            _this.contextLost = false;
            _this.init();
            _this.game.textures.each(function (texture) {
                for (var i = 0; i < texture.source.length; ++i)
                {
                    texture.source[i].init(_this.game);
                }
            }, null);
            for (var index = 0; index < callbacks.length; ++index)
            {
                callbacks[index](_this);
            }
        }, false);

        //   All of these settings will be able to be controlled via the Game Config
        this.config = {
            clearBeforeRender: true,
            transparent: false,
            autoResize: false,
            preserveDrawingBuffer: false,

            WebGLContextOptions: {
                alpha: true,
                antialias: true,
                premultipliedAlpha: true,
                stencil: true,
                preserveDrawingBuffer: false
            }
        };

        this.contextLost = false;
        this.maxTextures = 1;
        this.multiTexture = false;
        this.blendModes = [];
        this.gl = null;
        this.extensions = null;
        this.extensionList = {};
        this.rendererArray = [];
        this.blitterBatch = null;
        this.aaQuadBatch = null;
        this.spriteBatch = null;
        this.shapeBatch = null;
        this.effectRenderer = null;
        this.currentRenderer = null;
        this.currentTexture = [];
        this.shaderCache = {};
        this.currentShader = null;
        this.resourceManager = null;
        this.currentRenderTarget = null;
        this.snapshotCallback = null;

        this.scissor = {
            enabled: false,
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };

        this.init();
    },

    init: function ()
    {
        this.gl = this.view.getContext('webgl', this.config.WebGLContextOptions) || this.view.getContext('experimental-webgl', this.config.WebGLContextOptions);

        if (!this.gl)
        {
            this.contextLost = true;
            throw new Error('This browser does not support WebGL. Try using the Canvas renderer.');
        }
        var gl = this.gl;

        this.lostContext = this.getExtension('WEBGL_lose_context');

        var color = this.game.config.backgroundColor;

        this.resourceManager = new ResourceManager(gl);
    
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.clearColor(color.redGL, color.greenGL, color.blueGL, color.alphaGL);

        //  Map Blend Modes

        this.blendModes = [];

        for (var i = 0; i <= 16; i++)
        {
            this.blendModes.push({ func: [ gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], equation: gl.FUNC_ADD });
        }

        //  Add
        this.blendModes[1].func = [ gl.SRC_ALPHA, gl.DST_ALPHA ];

        //  Multiply
        this.blendModes[2].func = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];

        //  Screen
        this.blendModes[3].func = [ gl.SRC_ALPHA, gl.ONE ];

        this.blendMode = -1;
        this.extensions = gl.getSupportedExtensions();
        this.blitterBatch = this.addRenderer(new BlitterBatch(this.game, gl, this));
        this.quadBatch = this.addRenderer(new QuadBatch(this.game, gl, this));
        this.spriteBatch = this.addRenderer(new SpriteBatch(this.game, gl, this));
        this.shapeBatch = this.addRenderer(new ShapeBatch(this.game, gl, this));
        this.effectRenderer = this.addRenderer(new EffectRenderer(this.game, gl, this));
        this.tileBatch = this.addRenderer(new TileBatch(this.game, gl, this));
        this.tilemapRenderer = this.addRenderer(new TilemapRenderer(this.game, gl, this));
        this.particleRenderer = this.addRenderer(new ParticleRenderer(this.game, gl, this));
        this.currentRenderer = this.spriteBatch;
        this.currentVertexBuffer = null;
        this.setBlendMode(0);
        this.resize(this.width, this.height);
    },

    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFuncSeparate
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquation
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquationSeparate
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendColor
    addBlendMode: function (func, equation)
    {
        var index = this.blendModes.push({ func: func, equation: equation });

        return index - 1;
    },

    updateBlendMode: function (index, func, equation)
    {
        if (this.blendModes[index])
        {
            this.blendModes[index].func = func;

            if (equation)
            {
                this.blendModes[index].equation = equation;
            }
        }

        return this;
    },

    removeBlendMode: function (index)
    {
        if (index > 16 && this.blendModes[index])
        {
            this.blendModes.splice(index, 1);
        }

        return this;
    },

    getExtension: function (name)
    {
        if (!(name in this.extensionList))
        {
            this.extensionList[name] = this.gl.getExtension(name);
        }
        return this.extensionList[name];
    },

    addContextLostCallback: function (callback)
    {
        if (this.onContextLostCallbacks.indexOf(callback) === -1)
        {
            this.onContextLostCallbacks.push(callback);
        }
    },

    addContextRestoredCallback: function (callback)
    {
        if (this.onContextRestoredCallbacks.indexOf(callback) === -1)
        {
            this.onContextRestoredCallbacks.push(callback);
        }
    },

    createTexture: function (source, width, height)
    {
        width = source ? source.width : width;
        height = source ? source.height : height;

        var gl = this.gl;
        var filter = gl.NEAREST;
        var wrap = IsSizePowerOfTwo(width, height) ? gl.REPEAT : gl.CLAMP_TO_EDGE;

        if (!source.glTexture)
        {
            if (source.scaleMode === ScaleModes.LINEAR)
            {
                filter = gl.LINEAR;
            }
            else if (source.scaleMode === ScaleModes.NEAREST || this.game.config.pixelArt)
            {
                filter = gl.NEAREST;
            }

            if (!source && typeof width === 'number' && typeof height === 'number')
            {
                source.glTexture = this.resourceManager.createTexture(
                    0,
                    filter,
                    filter,
                    wrap,
                    wrap,
                    gl.RGBA,
                    null,
                    width, height
                );
            }
            else
            {
                source.glTexture = this.resourceManager.createTexture(
                    0,
                    filter,
                    filter,
                    wrap,
                    wrap,
                    gl.RGBA,
                    source.image
                );
            }
        }

        this.currentTexture[0] = null;
    },

    setTexture: function (texture, unit)
    {
        unit = unit || 0;
        if (this.currentTexture[unit] !== texture)
        {
            var gl = this.gl;

            this.currentRenderer.flush();
            
            gl.activeTexture(gl.TEXTURE0 + unit);

            if (texture !== null)
            {
                gl.bindTexture(gl.TEXTURE_2D, texture.texture);
            }
            else
            {
                gl.bindTexture(gl.TEXTURE_2D, null);
            }

            this.currentTexture[unit] = texture;
        }
    },

    setRenderer: function (renderer, texture, renderTarget)
    {
        this.setTexture(texture);
        this.setRenderTarget(renderTarget);
        
        if (this.currentRenderer !== renderer || this.currentRenderer.shouldFlush())
        {
            this.currentRenderer.flush();
            this.currentRenderer = renderer;
        }
    },

    setRenderTarget: function (renderTarget)
    {
        var gl = this.gl;

        if (this.currentRenderTarget !== renderTarget)
        {
            this.currentRenderer.flush();

            if (renderTarget !== null)
            {
                gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.framebufferObject);

                if (renderTarget.shouldClear)
                {
                    gl.clearColor(0, 0, 0, renderTarget.clearAlpha);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    renderTarget.shouldClear = false;
                }
            }
            else
            {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.width, this.height);
            }

            this.currentRenderTarget = renderTarget;
        }
    },

    resize: function (width, height)
    {
        var resolution = this.game.config.resolution;

        this.width = width * resolution;
        this.height = height * resolution;

        this.view.width = this.width;
        this.view.height = this.height;

        if (this.autoResize)
        {
            this.view.style.width = (this.width / resolution) + 'px';
            this.view.style.height = (this.height / resolution) + 'px';
        }

        this.gl.viewport(0, 0, this.width, this.height);

        for (var i = 0, l = this.rendererArray.length; i < l; ++i)
        {
            this.rendererArray[i].bind();
            this.rendererArray[i].resize(width, height, resolution);
        }

        this.currentRenderer.bind();
    },

    //  Call at the start of the render loop
    preRender: function ()
    {
        //  No point rendering if our context has been blown up!
        if (this.contextLost)
        {
            return;
        }

        this.setRenderTarget(null);
        //  Add Pre-render hook

        var gl = this.gl;
        var color = this.game.config.backgroundColor;

        gl.clearColor(color.redGL, color.greenGL, color.blueGL, color.alphaGL);

        // Some drivers require to call glClear
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

        this.setBlendMode(BlendModes.NORMAL);
    },

    /**
     * Renders a single Scene.
     *
     * @method render
     * @param {Phaser.Scene} scene - The Scene to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (scene, children, interpolationPercentage, camera)
    {
        if (this.contextLost) return;
        var gl = this.gl;
        var quadBatch = this.quadBatch;

        this.scissor.enabled = (camera.x !== 0 || camera.y !== 0 || camera.width !== gl.canvas.width || camera.height !== gl.canvas.height);

        this.setRenderTarget(null);

        if (this.scissor.enabled)
        {
            gl.enable(gl.SCISSOR_TEST);

            this.scissor.x = camera.x;
            this.scissor.y = gl.drawingBufferHeight - camera.y - camera.height;
            this.scissor.width = camera.width;
            this.scissor.height = camera.height;

            gl.scissor(this.scissor.x, this.scissor.y, this.scissor.width, this.scissor.height);
        }

        if (camera.backgroundColor.alphaGL > 0)
        {
            var color = camera.backgroundColor;

            quadBatch.bind();

            quadBatch.add(
                camera.x, camera.y, camera.width, camera.height,
                color.redGL, color.greenGL, color.blueGL, color.alphaGL
            );

            quadBatch.flush();

            this.currentRenderer.bind();
        }

        var list = children.list;
        var length = list.length;

        for (var index = 0; index < length; ++index)
        {
            var child = list[index];

            // Setting blend mode if needed
            var renderer = this.currentRenderer;
            var newBlendMode = child.blendMode;

            if (this.blendMode !== newBlendMode)
            {
                if (renderer)
                {
                    renderer.flush();
                }

                var blend = this.blendModes[newBlendMode].func;

                gl.enable(gl.BLEND);
                gl.blendEquation(this.blendModes[newBlendMode].equation);

                if (blend.length > 2)
                {
                    gl.blendFuncSeparate(blend[0], blend[1], blend[2], blend[3]);
                }
                else
                {
                    gl.blendFunc(blend[0], blend[1]);
                }

                this.blendMode = newBlendMode;
            }

            // drawing child
            child.renderWebGL(this, child, interpolationPercentage, camera);

            renderer = this.currentRenderer;

            if (renderer.isFull() || renderer.shouldFlush())
            {
                renderer.flush();
            }
        }
        
        this.currentRenderer.flush();
        
        if (camera._fadeAlpha > 0 || camera._flashAlpha > 0)
        {
            this.setRenderTarget(null);

            quadBatch.bind();

            // fade rendering
            quadBatch.add(
                camera.x, camera.y, camera.width, camera.height,
                camera._fadeRed,
                camera._fadeGreen,
                camera._fadeBlue,
                camera._fadeAlpha
            );

            // flash rendering
            quadBatch.add(
                camera.x, camera.y, camera.width, camera.height,
                camera._flashRed,
                camera._flashGreen,
                camera._flashBlue,
                camera._flashAlpha
            );

            quadBatch.flush();

            this.currentRenderer.bind();
        }

        if (this.scissor.enabled)
        {
            gl.disable(gl.SCISSOR_TEST);
        }
    },

    //  Called at the end of the render loop (tidy things up, etc)
    postRender: function ()
    {
        if (this.contextLost) return;

        this.currentRenderer.flush();

        if (this.snapshotCallback)
        {
            this.snapshotCallback(WebGLSnapshot(this.view));
            this.snapshotCallback = null;
        }

        //  Add Post-render hook

        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');
    },

    snapshot: function (callback)
    {
        this.snapshotCallback = callback;
    },

    createFBO: function () {},

    setBlendMode: function (newBlendMode)
    {
        var gl = this.gl;
        var renderer = this.currentRenderer;

        if (this.blendMode !== newBlendMode)
        {
            if (renderer)
            {
                renderer.flush();
            }

            var blend = this.blendModes[newBlendMode].func;

            gl.enable(gl.BLEND);
            gl.blendEquation(this.blendModes[newBlendMode].equation);

            if (blend.length > 2)
            {
                gl.blendFuncSeparate(blend[0], blend[1], blend[2], blend[3]);
            }
            else
            {
                gl.blendFunc(blend[0], blend[1]);
            }

            this.blendMode = newBlendMode;
        }
    },

    addRenderer: function (rendererInstance)
    {
        var index = this.rendererArray.indexOf(rendererInstance);

        if (index < 0)
        {
            this.rendererArray.push(rendererInstance);
            return rendererInstance;
        }

        return null;
    },

    setTextureFilterMode: function (texture, filterMode)
    {
        var gl = this.gl;
        var glFilter = [ gl.LINEAR, gl.NEAREST ][filterMode];

        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);

        if (this.currentTexture[0] !== null)
        {
            gl.bindTexture(gl.TEXTURE_2D, this.currentTexture[0].texture);
        }
        else
        {
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        return texture;
    },

    uploadCanvasToGPU: function (srcCanvas, dstTexture, shouldReallocate)
    {
        var gl = this.gl;

        if (!dstTexture)
        {
            dstTexture = new Resources.Texture(null, 0, 0);

            //  Only call this once
            dstTexture.texture = gl.createTexture();
        }

        if (dstTexture != this.currentTexture[0])
        {
            this.currentRenderer.flush();
        }

        gl.activeTexture(gl.TEXTURE0);

        if (!shouldReallocate)
        {
            //  Update resource
            gl.bindTexture(gl.TEXTURE_2D, dstTexture.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
        }
        else
        {
            //  Allocate or Reallocate resource
            gl.bindTexture(gl.TEXTURE_2D, dstTexture.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            dstTexture.width = srcCanvas.width;
            dstTexture.height = srcCanvas.height;
        }

        //  We must rebind old texture
        if (this.currentTexture.length > 0 && dstTexture != this.currentTexture[0] && this.currentTexture[0] !== null)
        {
            gl.bindTexture(gl.TEXTURE_2D, this.currentTexture[0].texture);
        }

        return dstTexture;
    },

    destroy: function ()
    {
        if (this.lostContext)
        {
            this.lostContext.loseContext();
        }
        this.gl = null;
    }

});

module.exports = WebGLRenderer;


/***/ }),
/* 897 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(898);
var DataBuffer16 = __webpack_require__(36);
var DataBuffer32 = __webpack_require__(29);
var PHASER_CONST = __webpack_require__(9);
var TexturedAndAlphaShader = __webpack_require__(920);

var BlitterBatch = new Class({

    initialize:

    function BlitterBatch (game, gl, manager)
    {
        this.game = game;
        this.type = PHASER_CONST.WEBGL;
        this.view = game.canvas;
        this.resolution = game.config.resolution;
        this.width = game.config.width * game.config.resolution;
        this.height = game.config.height * game.config.resolution;
        this.glContext = gl;
        this.maxParticles = null;
        this.shader = null;
        this.vertexBufferObject = null;
        this.indexBufferObject = null;
        this.vertexDataBuffer = null;
        this.indexDataBuffer = null;
        this.elementCount = 0;
        this.currentTexture2D = null;
        this.viewMatrixLocation = null;

        //   All of these settings will be able to be controlled via the Game Config
        this.config = {
            clearBeforeRender: true,
            transparent: false,
            autoResize: false,
            preserveDrawingBuffer: false,

            WebGLContextOptions: {
                alpha: true,
                antialias: true,
                premultipliedAlpha: true,
                stencil: true,
                preserveDrawingBuffer: false
            }
        };

        this.manager = manager;
        this.dirty = false;

        this.init(this.glContext);
    },

    init: function (gl)
    {
        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.PARTICLE_VERTEX_COUNT * CONST.MAX_PARTICLES);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.PARTICLE_INDEX_COUNT * CONST.MAX_PARTICLES);
        var shader = this.manager.resourceManager.createShader('TexturedAndAlphaShader', TexturedAndAlphaShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_PARTICLES * CONST.PARTICLE_INDEX_COUNT;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_alpha'), 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 16);

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;
        this.maxParticles = max;

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.PARTICLE_INDEX_COUNT, indexB += CONST.PARTICLE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }

        this.indexBufferObject.bind();
        this.vertexBufferObject.bind();
    },

    flush: function (shader)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0)
        {
            return;
        }
        
        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);

        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height, resolution, shader)
    {
        var activeShader = shader !== undefined ? shader : this.shader;
        
        this.width = width * resolution;
        this.height = height * resolution;

        activeShader.setConstantMatrix4x4(
            this.viewMatrixLocation,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    }

});

module.exports = BlitterBatch;


/***/ }),
/* 898 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec2) + sizeof(float)
    VERTEX_SIZE: 20,
    INDEX_SIZE: 2,
    PARTICLE_VERTEX_COUNT: 4,
    PARTICLE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    PARTICLE_VERTEX_COMPONENT_COUNT: 5,

    // Can't be bigger than 10,000 since index are 16-bit
    MAX_PARTICLES: 2000,

};

module.exports = CONST;


/***/ }),
/* 899 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(900);
var DataBuffer16 = __webpack_require__(36);
var DataBuffer32 = __webpack_require__(29);
var PHASER_CONST = __webpack_require__(9);
var TexturedAndNormalizedTintedShader = __webpack_require__(43);
var TransformMatrix = __webpack_require__(17);

var EffectRenderer = new Class({

    initialize:

    function EffectRenderer (game, gl, manager)
    {
        this.game = game;
        this.type = PHASER_CONST.WEBGL;
        this.view = game.canvas;
        this.resolution = game.config.resolution;
        this.width = game.config.width * game.config.resolution;
        this.height = game.config.height * game.config.resolution;
        this.glContext = gl;
        this.maxSprites = null;
        this.shader = null;
        this.vertexBufferObject = null;
        this.indexBufferObject = null;
        this.vertexDataBuffer = null;
        this.indexDataBuffer = null;
        this.elementCount = 0;
        this.currentTexture2D = null;
        this.viewMatrixLocation = null;
        this.tempMatrix = new TransformMatrix();

        //   All of these settings will be able to be controlled via the Game Config
        this.config = {
            clearBeforeRender: true,
            transparent: false,
            autoResize: false,
            preserveDrawingBuffer: false,

            WebGLContextOptions: {
                alpha: true,
                antialias: true,
                premultipliedAlpha: true,
                stencil: true,
                preserveDrawingBuffer: false
            }
        };

        this.manager = manager;
        this.dirty = false;

        this.init(this.glContext);
    },

    init: function (gl)
    {
        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.QUAD_VERTEX_COUNT * CONST.MAX_QUADS);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.QUAD_INDEX_COUNT * CONST.MAX_QUADS);
        var shader = this.manager.resourceManager.createShader('TexturedAndNormalizedTintedShader', TexturedAndNormalizedTintedShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_QUADS * CONST.QUAD_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 3, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 16);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_alpha'), 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 20);

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.QUAD_INDEX_COUNT, indexB += CONST.QUAD_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },
    
    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }

        this.indexBufferObject.bind();
        this.vertexBufferObject.bind();
    },

    flush: function (shader)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0)
        {
            return;
        }
        
        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);

        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height, resolution, shader)
    {
        var activeShader = shader !== undefined ? shader : this.shader;

        this.width = width * resolution;
        this.height = height * resolution;

        activeShader.setConstantMatrix4x4(
            activeShader.getUniformLocation('u_view_matrix'),
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    renderEffect: function (gameObject, camera, texture, textureWidth, textureHeight)
    {
        var tempMatrix = this.tempMatrix;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var width = textureWidth * (gameObject.flipX ? -1 : 1);
        var height = textureHeight * (gameObject.flipY ? -1 : 1);
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var x = -gameObject.displayOriginX + ((textureWidth) * (gameObject.flipX ? 1 : 0.0));
        var y = -gameObject.displayOriginY + ((textureHeight) * (gameObject.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alpha = gameObject.alpha;
        var tintTL = gameObject._tintTL;
        var tintTR = gameObject._tintTR;
        var tintBL = gameObject._tintBL;
        var tintBR = gameObject._tintBR;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf;
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setRenderer(this, texture, gameObject.renderTarget);
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        //  Top Left
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectU32[vertexOffset++] = tintTL;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        //  Bottom Left
        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectU32[vertexOffset++] = tintBL;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        //  Bottom Right
        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectU32[vertexOffset++] = tintBR;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        //  Top Right
        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectU32[vertexOffset++] = tintTR;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        this.flush(gameObject.dstShader);

        gameObject.dstRenderTarget.shouldClear = true;
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    }

});

module.exports = EffectRenderer;


/***/ }),
/* 900 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = (sizeof(vec2) * 4) + (sizeof(float) + sizeof(uint32))
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    QUAD_VERTEX_COUNT: 4,
    QUAD_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    QUAD_VERTEX_COMPONENT_COUNT: 6,

    // Can't be bigger since index are 16-bit
    MAX_QUADS: 2
    
};

module.exports = CONST;


/***/ }),
/* 901 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(902);
var DataBuffer16 = __webpack_require__(36);
var DataBuffer32 = __webpack_require__(29);
var PHASER_CONST = __webpack_require__(9);
var ParticleShader = __webpack_require__(918);
var TransformMatrix = __webpack_require__(17);

var ParticleRenderer = new Class({

    initialize:

    function ParticleRenderer (game, gl, manager)
    {
        this.game = game;
        this.type = PHASER_CONST.WEBGL;
        this.view = game.canvas;
        this.resolution = game.config.resolution;
        this.width = game.config.width * game.config.resolution;
        this.height = game.config.height * game.config.resolution;
        this.glContext = gl;
        this.maxSprites = null;
        this.shader = null;
        this.vertexBufferObject = null;
        this.indexBufferObject = null;
        this.vertexDataBuffer = null;
        this.indexDataBuffer = null;
        this.elementCount = 0;
        this.currentTexture2D = null;
        this.viewMatrixLocation = null;
        this.tempMatrix = new TransformMatrix();

        //   All of these settings will be able to be controlled via the Game Config
        this.config = {
            clearBeforeRender: true,
            transparent: false,
            autoResize: false,
            preserveDrawingBuffer: false,

            WebGLContextOptions: {
                alpha: true,
                antialias: true,
                premultipliedAlpha: true,
                stencil: true,
                preserveDrawingBuffer: false
            }
        };

        this.manager = manager;
        this.dirty = false;

        this.init(this.glContext);
    },

    init: function (gl)
    {
        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.VERTEX_COUNT * CONST.MAX);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.INDEX_COUNT * CONST.MAX);
        var shader = this.manager.resourceManager.createShader('ParticleShader', ParticleShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX * CONST.INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 4, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 16);

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.INDEX_COUNT, indexB += CONST.VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return this.isFull();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }

        this.indexBufferObject.bind();
        this.vertexBufferObject.bind();
    },

    flush: function (shader, renderTarget)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0)
        {
            return;
        }
        
        if (renderTarget)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget);
        }

        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);

        this.elementCount = 0;
        vertexDataBuffer.clear();

        if (renderTarget)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    resize: function (width, height, resolution, shader)
    {
        var activeShader = (shader !== undefined) ? shader : this.shader;
        var location = (activeShader === this.shader) ? this.viewMatrixLocation : activeShader.getUniformLocation('u_view_matrix');

        this.width = width * resolution;
        this.height = height * resolution;
        this.setProjectionMatrix(activeShader, location);
    },

    setProjectionMatrix: function (shader, location)
    {
        shader.setConstantMatrix4x4(
            location,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    },

    renderEmitter: function (emitter, camera)
    {
        var particles = emitter.alive;
        var length = particles.length;
        var frame = emitter.frame;
        var data = this.vertexDataBuffer;
        var vbF32 = data.floatView;
        var vbU32 = data.uintView;
        var vtxOffset = 0;
        var width = frame.width;
        var height = frame.height;
        var cameraMatrix = camera.matrix.matrix;
        var cma = cameraMatrix[0];
        var cmb = cameraMatrix[1];
        var cmc = cameraMatrix[2];
        var cmd = cameraMatrix[3];
        var cme = cameraMatrix[4];
        var cmf = cameraMatrix[5];
        var elementCount = this.elementCount;
        var uvs = frame.uvs;
        var u0 = uvs.x0;
        var v0 = uvs.y0;
        var u1 = uvs.x1;
        var v1 = uvs.y1;
        var u2 = uvs.x2;
        var v2 = uvs.y2;
        var u3 = uvs.x3;
        var v3 = uvs.y3;
        var ox = width * 0.5;
        var oy = height * 0.5;
        var particleCount = 0;
        var batchCount = Math.ceil(length / CONST.MAX);
        var renderTarget = emitter.renderTarget;
        var tempMatrix = this.tempMatrix;
        var tempMatrixMatrix = tempMatrix.matrix;
        var particleOffset = 0;

        if (length === 0) return;

        this.manager.setRenderer(this, frame.texture.source[frame.sourceIndex].glTexture, emitter.renderTarget);

        for (var batchIndex = 0; batchIndex < batchCount; ++batchIndex)
        {
            var batchSize = Math.min(length, CONST.MAX);
            for (var index = 0; index < batchSize; ++index)
            {
                var particle = particles[particleOffset + index];
                var x = -ox;
                var y = -oy;
                var scaleX = particle.scaleX;
                var scaleY = particle.scaleY;
                var rotation = particle.rotation;
                var color = particle.color;
                var xw = x + width;
                var yh = y + height;
                
                tempMatrix.applyITRS(particle.x, particle.y, rotation, scaleX, scaleY);

                var sra = tempMatrixMatrix[0];
                var srb = tempMatrixMatrix[1];
                var src = tempMatrixMatrix[2];
                var srd = tempMatrixMatrix[3];
                var sre = tempMatrixMatrix[4];
                var srf = tempMatrixMatrix[5];
                var mva = sra * cma + srb * cmc;
                var mvb = sra * cmb + srb * cmd;
                var mvc = src * cma + srd * cmc;
                var mvd = src * cmb + srd * cmd;
                var mve = sre * cma + srf * cmc + cme;
                var mvf = sre * cmb + srf * cmd + cmf;
                var tx0 = x * mva + y * mvc + mve;
                var ty0 = x * mvb + y * mvd + mvf;
                var tx1 = x * mva + yh * mvc + mve;
                var ty1 = x * mvb + yh * mvd + mvf;
                var tx2 = xw * mva + yh * mvc + mve;
                var ty2 = xw * mvb + yh * mvd + mvf;
                var tx3 = xw * mva + y * mvc + mve;
                var ty3 = xw * mvb + y * mvd + mvf;

                vtxOffset = data.allocate(20);
                elementCount += 6;

                //  Top Left
                vbF32[vtxOffset++] = tx0;
                vbF32[vtxOffset++] = ty0;
                vbF32[vtxOffset++] = u0;
                vbF32[vtxOffset++] = v0;
                vbU32[vtxOffset++] = color;

                //  Bottom Left
                vbF32[vtxOffset++] = tx1;
                vbF32[vtxOffset++] = ty1;
                vbF32[vtxOffset++] = u1;
                vbF32[vtxOffset++] = v1;
                vbU32[vtxOffset++] = color;

                //  Bottom Right
                vbF32[vtxOffset++] = tx2;
                vbF32[vtxOffset++] = ty2;
                vbF32[vtxOffset++] = u2;
                vbF32[vtxOffset++] = v2;
                vbU32[vtxOffset++] = color;

                //  Top Right
                vbF32[vtxOffset++] = tx3;
                vbF32[vtxOffset++] = ty3;
                vbF32[vtxOffset++] = u3;
                vbF32[vtxOffset++] = v3;
                vbU32[vtxOffset++] = color;
            }
            particleOffset += batchSize;
            length -= batchSize;
            this.elementCount = elementCount;
            this.flush(undefined, renderTarget);
            elementCount = 0;
        }

    }


});

module.exports = ParticleRenderer;


/***/ }),
/* 902 */
/***/ (function(module, exports) {

var CONST = {
    /*
    struct v
    {
        float position[2];
        float tex_coord[2];
        unsigned int color;
    };
    */
    VERTEX_SIZE: 20, /* sizeof(v) */
    INDEX_SIZE: 2,
    VERTEX_COUNT: 4,
    INDEX_COUNT: 6,
    COMPONENT32_COUNT: 5, /* sizeof(v) / 4 */
    MAX: 16000

};

module.exports = CONST;

/***/ }),
/* 903 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(904);
var DataBuffer16 = __webpack_require__(36);
var DataBuffer32 = __webpack_require__(29);
var PHASER_CONST = __webpack_require__(9);
var UntexturedAndTintedShader = __webpack_require__(923);

var QuadBatch = new Class({

    initialize:

    function QuadBatch (game, gl, manager)
    {
        this.game = game;
        this.type = PHASER_CONST.WEBGL;
        this.view = game.canvas;
        this.resolution = game.config.resolution;
        this.width = game.config.width * game.config.resolution;
        this.height = game.config.height * game.config.resolution;
        this.glContext = gl;
        this.maxQuads = null;
        this.shader = null;
        this.vertexBufferObject = null;
        this.indexBufferObject = null;
        this.vertexDataBuffer = null;
        this.indexDataBuffer = null;
        this.elementCount = 0;
        this.viewMatrixLocation = null;

        //   All of these settings will be able to be controlled via the Game Config
        this.config = {
            clearBeforeRender: true,
            transparent: false,
            autoResize: false,
            preserveDrawingBuffer: false,

            WebGLContextOptions: {
                alpha: true,
                antialias: true,
                premultipliedAlpha: true,
                stencil: true,
                preserveDrawingBuffer: false
            }
        };

        this.manager = manager;
        this.dirty = false;

        this.init(this.glContext);
    },

    init: function (gl)
    {
        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.AAQUAD_VERTEX_COUNT * CONST.MAX_AAQUAD);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.AAQUAD_INDEX_COUNT * CONST.MAX_AAQUAD);
        var shader = this.manager.resourceManager.createShader('UntexturedAndTintedShader', UntexturedAndTintedShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_AAQUAD * CONST.AAQUAD_INDEX_COUNT;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 4, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.AAQUAD_INDEX_COUNT, indexB += CONST.AAQUAD_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    add: function (x, y, width, height, red, green, blue, alpha)
    {
        // The user must check if the buffers are full before flushing
        // this is to give freedom of when should the renderer flush. var vertexDataBuffer = this.vertexDataBuffer;
        var vertexDataBuffer = this.vertexDataBuffer;
        var floatBuffer = vertexDataBuffer.floatView;
        var vertexOffset = vertexDataBuffer.allocate(CONST.AAQUAD_VERTEX_COMPONENT_COUNT * CONST.AAQUAD_VERTEX_COUNT);

        floatBuffer[vertexOffset++] = x;
        floatBuffer[vertexOffset++] = y;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x;
        floatBuffer[vertexOffset++] = y + height;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x + width;
        floatBuffer[vertexOffset++] = y + height;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x + width;
        floatBuffer[vertexOffset++] = y;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        this.elementCount += CONST.AAQUAD_INDEX_COUNT;
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }

        this.indexBufferObject.bind();
        this.vertexBufferObject.bind();
    },

    flush: function (shader)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0)
        {
            return;
        }
        
        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height, resolution, shader)
    {
        var activeShader = shader !== undefined ? shader : this.shader;
        
        this.width = width * resolution;
        this.height = height * resolution;

        activeShader.setConstantMatrix4x4(
            this.viewMatrixLocation,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    }

});

module.exports = QuadBatch;


/***/ }),
/* 904 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec4)
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    AAQUAD_VERTEX_COUNT: 4,
    AAQUAD_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    AAQUAD_VERTEX_COMPONENT_COUNT: 6,
    MAX_AAQUAD: 2000,

};

module.exports = CONST;


/***/ }),
/* 905 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(906);
var DataBuffer32 = __webpack_require__(29);
var Earcut = __webpack_require__(153);
var PHASER_CONST = __webpack_require__(9);
var UntexturedAndNormalizedTintedShader = __webpack_require__(922);

var ShapeBatch = new Class({

    initialize:

    function ShapeBatch (game, gl, manager)
    {
        this.game = game;
        this.type = PHASER_CONST.WEBGL;
        this.view = game.canvas;
        this.resolution = game.config.resolution;
        this.width = game.config.width * game.config.resolution;
        this.height = game.config.height * game.config.resolution;
        this.glContext = gl;
        this.maxVertices = null;
        this.shader = null;
        this.vertexBufferObject = null;
        this.vertexDataBuffer = null;
        this.vertexCount = 0;
        this.viewMatrixLocation = null;
        this.tempTriangle = [
            {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0},
            {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0},
            {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0},
            {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0}
        ];

        //   All of these settings will be able to be controlled via the Game Config
        this.config = {
            clearBeforeRender: true,
            transparent: false,
            autoResize: false,
            preserveDrawingBuffer: false,

            WebGLContextOptions: {
                alpha: true,
                antialias: true,
                premultipliedAlpha: true,
                stencil: true,
                preserveDrawingBuffer: false
            }
        };

        this.manager = manager;
        this.dirty = false;
        this.context = null;
        this.init(this.glContext);
    },

    init: function (gl)
    {
        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.MAX_VERTICES);
        var shader = this.manager.resourceManager.createShader('UntexturedAndNormalizedTintedShader', UntexturedAndNormalizedTintedShader);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var max = CONST.MAX_VERTICES;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 4, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_alpha'), 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 12);

        this.vertexDataBuffer = vertexDataBuffer;
        this.shader = shader;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;
        this.maxVertices = max;
        this.polygonCache = [];

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }

        this.vertexBufferObject.bind();
    },

    flush: function (shader)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.vertexCount === 0)
        {
            return;
        }

        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);

        gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);

        vertexDataBuffer.clear();

        this.vertexCount = 0;
    },

    resize: function (width, height, resolution, shader)
    {
        var activeShader = shader !== undefined ? shader : this.shader;

        this.width = width * resolution;
        this.height = height * resolution;

        activeShader.setConstantMatrix4x4(
            this.viewMatrixLocation,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    // Graphics Game Object properties
    // srcX, srcY, srcScaleX, srcScaleY, srcRotation,

    // line properties
    // ax, ay, bx, by, aLineWidth, bLineWidth, aLineColor, bLineColor, lineAlpha,

    // transform
    // a1, b1, c1, d1, e1, f1,
    // currentMatrix
    addLine: function (srcX, srcY, srcScaleX, srcScaleY, srcRotation, ax, ay, bx, by, aLineWidth, bLineWidth, aLineColor, bLineColor, lineAlpha, a1, b1, c1, d1, e1, f1, currentMatrix)
    {
        if (this.vertexCount + 6 > this.maxVertices)
        {
            this.flush();
        }

        this.vertexCount += 6;

        var a0 = currentMatrix.matrix[0];
        var b0 = currentMatrix.matrix[1];
        var c0 = currentMatrix.matrix[2];
        var d0 = currentMatrix.matrix[3];
        var e0 = currentMatrix.matrix[4];
        var f0 = currentMatrix.matrix[5];
        var a = a1 * a0 + b1 * c0;
        var b = a1 * b0 + b1 * d0;
        var c = c1 * a0 + d1 * c0;
        var d = c1 * b0 + d1 * d0;
        var e = e1 * a0 + f1 * c0 + e0;
        var f = e1 * b0 + f1 * d0 + f0;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var dx = bx - ax;
        var dy = by - ay;
        var len = Math.sqrt(dx * dx + dy * dy);
        var al0 = aLineWidth * (by - ay) / len;
        var al1 = aLineWidth * (ax - bx) / len;
        var bl0 = bLineWidth * (by - ay) / len;
        var bl1 = bLineWidth * (ax - bx) / len;
        var lx0 = bx - bl0;
        var ly0 = by - bl1;
        var lx1 = ax - al0;
        var ly1 = ay - al1;
        var lx2 = bx + bl0;
        var ly2 = by + bl1;
        var lx3 = ax + al0;
        var ly3 = ay + al1;
        var x0 = lx0 * a + ly0 * c + e;
        var y0 = lx0 * b + ly0 * d + f;
        var x1 = lx1 * a + ly1 * c + e;
        var y1 = lx1 * b + ly1 * d + f;
        var x2 = lx2 * a + ly2 * c + e;
        var y2 = lx2 * b + ly2 * d + f;
        var x3 = lx3 * a + ly3 * c + e;
        var y3 = lx3 * b + ly3 * d + f;
        var vertexOffset = vertexDataBuffer.allocate(24);

        vertexBufferF32[vertexOffset++] = x0;
        vertexBufferF32[vertexOffset++] = y0;
        vertexBufferU32[vertexOffset++] = bLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        vertexBufferF32[vertexOffset++] = x1;
        vertexBufferF32[vertexOffset++] = y1;
        vertexBufferU32[vertexOffset++] = aLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        vertexBufferF32[vertexOffset++] = x2;
        vertexBufferF32[vertexOffset++] = y2;
        vertexBufferU32[vertexOffset++] = bLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        vertexBufferF32[vertexOffset++] = x1;
        vertexBufferF32[vertexOffset++] = y1;
        vertexBufferU32[vertexOffset++] = aLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        vertexBufferF32[vertexOffset++] = x3;
        vertexBufferF32[vertexOffset++] = y3;
        vertexBufferU32[vertexOffset++] = aLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        vertexBufferF32[vertexOffset++] = x2;
        vertexBufferF32[vertexOffset++] = y2;
        vertexBufferU32[vertexOffset++] = bLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        return [
            x0, y0, bLineColor,
            x1, y1, aLineColor,
            x2, y2, bLineColor,
            x3, y3, aLineColor
        ];
    },

    // Graphics Game Object properties
    // srcX, srcY, srcScaleX, srcScaleY, srcRotation,

    // Path properties
    // path, lineWidth, lineColor, lineAlpha,

    // transform
    // a, b, c, d, e, f,

    // is last connection
    // isLastPath,
    // currentMatrix
    addStrokePath: function (srcX, srcY, srcScaleX, srcScaleY, srcRotation, path, lineWidth, lineColor, lineAlpha, a, b, c, d, e, f, isLastPath, currentMatrix)
    {
        var point0, point1;
        var pathLength = path.length;
        var polylines = this.polygonCache;
        var last, curr;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset;
        var line;

        for (var pathIndex = 0; pathIndex + 1 < pathLength; pathIndex += 1)
        {
            point0 = path[pathIndex];
            point1 = path[pathIndex + 1];

            line = this.addLine(
                srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                point0.x, point0.y,
                point1.x, point1.y,
                point0.width / 2, point1.width / 2,
                point0.rgb, point1.rgb, lineAlpha,
                a, b, c, d, e, f,
                currentMatrix
            );

            polylines.push(line);
        }

        /* Render joints */
        for (var index = 1, polylinesLength = polylines.length; index < polylinesLength; ++index)
        {
            if (this.vertexCount + 6 > this.maxVertices)
            {
                this.flush();
            }

            last = polylines[index - 1] || polylines[polylinesLength - 1];
            curr = polylines[index];
            vertexOffset = vertexDataBuffer.allocate(24);

            vertexBufferF32[vertexOffset++] = last[3 * 2 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 2 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 2 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = last[3 * 0 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 0 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 0 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = curr[3 * 3 + 0];
            vertexBufferF32[vertexOffset++] = curr[3 * 3 + 1];
            vertexBufferU32[vertexOffset++] = curr[3 * 3 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = last[3 * 0 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 0 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 0 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = last[3 * 2 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 2 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 2 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = curr[3 * 1 + 0];
            vertexBufferF32[vertexOffset++] = curr[3 * 1 + 1];
            vertexBufferU32[vertexOffset++] = curr[3 * 1 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            this.vertexCount += 6;
        }

        polylines.length = 0;
    },

    // Graphics Game Object properties
    // srcX, srcY, srcScaleX, srcScaleY, srcRotation,

    // Path properties
    // path, fillColor, fillAlpha,

    // transform
    // a1, b1, c1, d1, e1, f1,
    // currentMatrix
    addFillPath: function (srcX, srcY, srcScaleX, srcScaleY, srcRotation, path, fillColor, fillAlpha, a1, b1, c1, d1, e1, f1, currentMatrix)
    {
        var length = path.length;
        var polygonCache = this.polygonCache;
        var polygonIndexArray;
        var point;
        var v0, v1, v2;
        var vertexOffset;
        var vertexCount = this.vertexCount;
        var maxVertices = this.maxVertices;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var x0, y0, x1, y1, x2, y2;
        var tx0, ty0, tx1, ty1, tx2, ty2;
        var a0 = currentMatrix.matrix[0];
        var b0 = currentMatrix.matrix[1];
        var c0 = currentMatrix.matrix[2];
        var d0 = currentMatrix.matrix[3];
        var e0 = currentMatrix.matrix[4];
        var f0 = currentMatrix.matrix[5];
        var a = a1 * a0 + b1 * c0;
        var b = a1 * b0 + b1 * d0;
        var c = c1 * a0 + d1 * c0;
        var d = c1 * b0 + d1 * d0;
        var e = e1 * a0 + f1 * c0 + e0;
        var f = e1 * b0 + f1 * d0 + f0;

        for (var pathIndex = 0; pathIndex < length; ++pathIndex)
        {
            point = path[pathIndex];
            polygonCache.push(point.x, point.y);
        }

        polygonIndexArray = Earcut(polygonCache);
        length = polygonIndexArray.length;

        for (var index = 0; index < length; index += 3)
        {
            v0 = polygonIndexArray[index + 0] * 2;
            v1 = polygonIndexArray[index + 1] * 2;
            v2 = polygonIndexArray[index + 2] * 2;

            if (vertexCount + 3 > maxVertices)
            {
                this.vertexCount = vertexCount;
                this.flush();
                vertexCount = 0;
            }

            vertexOffset = vertexDataBuffer.allocate(12);
            vertexCount += 3;

            x0 = polygonCache[v0 + 0];
            y0 = polygonCache[v0 + 1];
            x1 = polygonCache[v1 + 0];
            y1 = polygonCache[v1 + 1];
            x2 = polygonCache[v2 + 0];
            y2 = polygonCache[v2 + 1];

            tx0 = x0 * a + y0 * c + e;
            ty0 = x0 * b + y0 * d + f;
            tx1 = x1 * a + y1 * c + e;
            ty1 = x1 * b + y1 * d + f;
            tx2 = x2 * a + y2 * c + e;
            ty2 = x2 * b + y2 * d + f;

            vertexBufferF32[vertexOffset++] = tx0;
            vertexBufferF32[vertexOffset++] = ty0;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

            vertexBufferF32[vertexOffset++] = tx1;
            vertexBufferF32[vertexOffset++] = ty1;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

            vertexBufferF32[vertexOffset++] = tx2;
            vertexBufferF32[vertexOffset++] = ty2;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

        }

        this.vertexCount = vertexCount;

        polygonCache.length = 0;
    },

    // Graphics Game Object properties
    // srcX, srcY, srcScaleX, srcScaleY, srcRotation,

    // Rectangle properties
    // x, y, width, height, fillColor, fillAlpha,

    // transform
    // a1, b1, c1, d1, e1, f1,
    // currentMatrix
    addFillRect: function (srcX, srcY, srcScaleX, srcScaleY, srcRotation, x, y, width, height, fillColor, fillAlpha, a1, b1, c1, d1, e1, f1, currentMatrix)
    {
        if (this.vertexCount + 6 > this.maxVertices)
        {
            this.flush();
        }

        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = vertexDataBuffer.allocate(24);
        var xw = x + width;
        var yh = y + height;
        var a0 = currentMatrix.matrix[0];
        var b0 = currentMatrix.matrix[1];
        var c0 = currentMatrix.matrix[2];
        var d0 = currentMatrix.matrix[3];
        var e0 = currentMatrix.matrix[4];
        var f0 = currentMatrix.matrix[5];
        var a = a1 * a0 + b1 * c0;
        var b = a1 * b0 + b1 * d0;
        var c = c1 * a0 + d1 * c0;
        var d = c1 * b0 + d1 * d0;
        var e = e1 * a0 + f1 * c0 + e0;
        var f = e1 * b0 + f1 * d0 + f0;
        var tx0 = x * a + y * c + e;
        var ty0 = x * b + y * d + f;
        var tx1 = x * a + yh * c + e;
        var ty1 = x * b + yh * d + f;
        var tx2 = xw * a + yh * c + e;
        var ty2 = xw * b + yh * d + f;
        var tx3 = xw * a + y * c + e;
        var ty3 = xw * b + y * d + f;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx3;
        vertexBufferF32[vertexOffset++] = ty3;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        this.vertexCount += 6;
    },

    // Graphics Game Object properties
    // srcX, srcY, srcScaleX, srcScaleY, srcRotation,

    // Triangle properties
    // x0, y0, x1, y1, x2, y2, fillColor, fillAlpha,

    // transform
    // a1, b1, c1, d1, e1, f1,
    // currentMatrix
    addFillTriangle: function (srcX, srcY, srcScaleX, srcScaleY, srcRotation, x0, y0, x1, y1, x2, y2, fillColor, fillAlpha, a1, b1, c1, d1, e1, f1, currentMatrix)
    {
        if (this.vertexCount + 3 > this.maxVertices)
        {
            this.flush();
        }

        var a0 = currentMatrix.matrix[0];
        var b0 = currentMatrix.matrix[1];
        var c0 = currentMatrix.matrix[2];
        var d0 = currentMatrix.matrix[3];
        var e0 = currentMatrix.matrix[4];
        var f0 = currentMatrix.matrix[5];
        var a = a1 * a0 + b1 * c0;
        var b = a1 * b0 + b1 * d0;
        var c = c1 * a0 + d1 * c0;
        var d = c1 * b0 + d1 * d0;
        var e = e1 * a0 + f1 * c0 + e0;
        var f = e1 * b0 + f1 * d0 + f0;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = vertexDataBuffer.allocate(12);
        var tx0 = x0 * a + y0 * c + e;
        var ty0 = x0 * b + y0 * d + f;
        var tx1 = x1 * a + y1 * c + e;
        var ty1 = x1 * b + y1 * d + f;
        var tx2 = x2 * a + y2 * c + e;
        var ty2 = x2 * b + y2 * d + f;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        this.vertexCount += 3;
    },

    // Graphics Game Object properties
    // srcX, srcY, srcScaleX, srcScaleY, srcRotation,

    // Triangle properties
    // x0, y0, x1, y1, x2, y2, lineWidth, lineColor, lineAlpha,

    // transform
    // a, b, c, d, e, f,
    // currentMatrix
    addStrokeTriangle: function (srcX, srcY, srcScaleX, srcScaleY, srcRotation, x0, y0, x1, y1, x2, y2, lineWidth, lineColor, lineAlpha, a, b, c, d, e, f, currentMatrix)
    {
        var tempTriangle = this.tempTriangle;

        tempTriangle[0].x = x0;
        tempTriangle[0].y = y0;
        tempTriangle[0].width = lineWidth;
        tempTriangle[0].rgb = lineColor;
        tempTriangle[0].alpha = lineAlpha;
        tempTriangle[1].x = x1;
        tempTriangle[1].y = y1;
        tempTriangle[1].width = lineWidth;
        tempTriangle[1].rgb = lineColor;
        tempTriangle[1].alpha = lineAlpha;
        tempTriangle[2].x = x2;
        tempTriangle[2].y = y2;
        tempTriangle[2].width = lineWidth;
        tempTriangle[2].rgb = lineColor;
        tempTriangle[2].alpha = lineAlpha;
        tempTriangle[3].x = x0;
        tempTriangle[3].y = y0;
        tempTriangle[3].width = lineWidth;
        tempTriangle[3].rgb = lineColor;
        tempTriangle[3].alpha = lineAlpha;

        this.addStrokePath(
            srcX, srcY, srcScaleX, srcScaleY, srcRotation,
            tempTriangle, lineWidth, lineColor, lineAlpha,
            a, b, c, d, e, f,
            false,
            currentMatrix
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.vertexBufferObject = null;
    }

});

module.exports = ShapeBatch;


/***/ }),
/* 906 */
/***/ (function(module, exports) {

var CONST = {

    VERTEX_SIZE: 16,

    // How many 32-bit components does the vertex have.
    SHAPE_VERTEX_COMPONENT_COUNT: 4,

    // Can't be bigger than 10,000 since index are 16-bit
    MAX_VERTICES: 16000
    
};

module.exports = CONST;


/***/ }),
/* 907 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(908);
var DataBuffer16 = __webpack_require__(36);
var DataBuffer32 = __webpack_require__(29);
var PHASER_CONST = __webpack_require__(9);
var TexturedAndNormalizedTintedShader = __webpack_require__(43);
var TransformMatrix = __webpack_require__(17);

var SpriteBatch = new Class({

    initialize:

    function SpriteBatch (game, gl, manager)
    {
        this.game = game;
        this.type = PHASER_CONST.WEBGL;
        this.view = game.canvas;
        this.resolution = game.config.resolution;
        this.width = game.config.width * game.config.resolution;
        this.height = game.config.height * game.config.resolution;
        this.glContext = gl;
        this.maxSprites = null;
        this.shader = null;
        this.vertexBufferObject = null;
        this.indexBufferObject = null;
        this.indexBufferObjectForMesh = null;
        this.vertexDataBuffer = null;
        this.indexDataBuffer = null;
        this.elementCount = 0;
        this.currentTexture2D = null;
        this.viewMatrixLocation = null;
        this.tempMatrix = new TransformMatrix();

        //   All of these settings will be able to be controlled via the Game Config
        this.config = {
            clearBeforeRender: true,
            transparent: false,
            autoResize: false,
            preserveDrawingBuffer: false,

            WebGLContextOptions: {
                alpha: true,
                antialias: true,
                premultipliedAlpha: true,
                stencil: true,
                preserveDrawingBuffer: false
            }
        };

        this.manager = manager;
        this.dirty = false;
        this.drawIndexed = true;
        this.lastDrawIndexed = true;
        this.lastDrawingMesh = false;
        this.drawingMesh = false;
        this.vertexCount = 0;

        this.init(this.glContext);
    },

    init: function (gl)
    {
        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.SPRITE_VERTEX_COUNT * CONST.MAX_SPRITES);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.SPRITE_INDEX_COUNT * CONST.MAX_SPRITES);
        var shader = this.manager.resourceManager.createShader('TexturedAndNormalizedTintedShader', TexturedAndNormalizedTintedShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var indexBufferObjectForMesh = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_SPRITES * CONST.SPRITE_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.indexBufferObjectForMesh = indexBufferObjectForMesh;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 3, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 16);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_alpha'), 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 20);

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.SPRITE_INDEX_COUNT, indexB += CONST.SPRITE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        if (this.drawIndexed !== this.lastDrawIndexed || this.lastDrawingMesh !== this.drawingMesh || this.isFull())
        {
            this.lastDrawIndexed = this.drawIndexed;
            this.lastDrawingMesh = this.drawingMesh;
            return true;
        }

        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }

        this.vertexBufferObject.bind();
    },

    flush: function (shader, renderTarget)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0 && this.vertexCount === 0)
        {
            return;
        }
        
        if (renderTarget)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget);
        }

        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);

        if (this.drawIndexed)
        {
            if (this.drawingMesh)
            {
                this.indexBufferObjectForMesh.bind();
                this.indexBufferObjectForMesh.updateResource(this.indexDataBuffer.buffer, 0);
            }
            else
            {
                this.indexBufferObject.bind();
            }

            gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        }
        else
        {
            gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
        }
        
        vertexDataBuffer.clear();
        this.elementCount = 0;
        this.vertexCount = 0;

        if (renderTarget)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    resize: function (width, height, resolution, shader)
    {
        var activeShader = (shader !== undefined) ? shader : this.shader;
        var location = (activeShader === this.shader) ? this.viewMatrixLocation : activeShader.getUniformLocation('u_view_matrix');

        this.width = width * resolution;
        this.height = height * resolution;
        this.setProjectionMatrix(activeShader, location);
    },

    setProjectionMatrix: function (shader, location)
    {
        shader.setConstantMatrix4x4(
            location,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    },

    addMeshIndexed: function (gameObject, camera)
    {
        var tempMatrix = this.tempMatrix;
        var frame = gameObject.frame;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var vertices = gameObject.vertices;
        var uv = gameObject.uv;
        var length = vertices.length;
        var totalVertices = (length / 2)|0;
        var indexBuffer = this.indexDataBuffer.uintView;
        var indices = gameObject.indices;
        var colors = gameObject.colors;
        var alphas = gameObject.alphas;
        var indexLength = indices.length;
        var indexOffset = 0;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf;
        
        this.manager.setRenderer(this, frame.texture.source[frame.sourceIndex].glTexture, gameObject.renderTarget);
        indexOffset = this.vertexCount;
        this.drawIndexed = true;
        this.drawingMesh = true;
        this.vertexCount += totalVertices;

        vertexOffset = vertexDataBuffer.allocate(totalVertices * 6);

        var index;
        var index0;

        for (index = 0, index0 = 0; index < length; index += 2)
        {
            var x = vertices[index + 0];
            var y = vertices[index + 1];
            var tx = x * mva + y * mvc + mve;
            var ty = x * mvb + y * mvd + mvf;
            vertexBufferObjectF32[vertexOffset++] = tx;
            vertexBufferObjectF32[vertexOffset++] = ty;
            vertexBufferObjectF32[vertexOffset++] = uv[index + 0];
            vertexBufferObjectF32[vertexOffset++] = uv[index + 1];
            vertexBufferObjectU32[vertexOffset++] = colors[index0];
            vertexBufferObjectF32[vertexOffset++] = alphas[index0];
            index0 += 1;
        }

        var elementCount = this.elementCount;

        for (index = 0; index < indexLength; ++index)
        {
            indexBuffer[elementCount + index] = indexOffset + indices[index];
        }

        this.elementCount += indexLength;
    },

    addMesh: function (gameObject, camera)
    {
        var tempMatrix = this.tempMatrix;
        var frame = gameObject.frame;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var vertices = gameObject.vertices;
        var uv = gameObject.uv;
        var colors = gameObject.colors;
        var alphas = gameObject.alphas;
        var length = vertices.length;
        var totalVertices = (length / 2)|0;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf;
        
        this.manager.setRenderer(this, frame.texture.source[frame.sourceIndex].glTexture, gameObject.renderTarget);
        this.drawIndexed = false;
        this.drawingMesh = true;
        this.vertexCount += totalVertices;

        vertexOffset = vertexDataBuffer.allocate(totalVertices * 6);

        for (var index = 0, index0 = 0; index < length; index += 2)
        {
            var x = vertices[index + 0];
            var y = vertices[index + 1];
            var tx = x * mva + y * mvc + mve;
            var ty = x * mvb + y * mvd + mvf;
            vertexBufferObjectF32[vertexOffset++] = tx;
            vertexBufferObjectF32[vertexOffset++] = ty;
            vertexBufferObjectF32[vertexOffset++] = uv[index + 0];
            vertexBufferObjectF32[vertexOffset++] = uv[index + 1];
            vertexBufferObjectU32[vertexOffset++] = colors[index0];
            vertexBufferObjectF32[vertexOffset++] = alphas[index0];
            index0 += 1;
        }
    },

    addTileTextureRect: function (texture, x, y, width, height, alpha, tint, scrollFactorX, scrollFactorY, textureWidth, textureHeight, rectX, rectY, rectW, rectH, camera, renderTarget)
    {
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var halfTileWidth = (width) * 0.5;
        var halfTileHeight = (height) * 0.5;
        var u0 = (rectX - (halfTileWidth - 0.5)) / textureWidth;
        var v0 = (rectY - (halfTileHeight - 0.5)) / textureHeight;
        var u1 = (rectX + (halfTileWidth - 0.5)) / textureWidth;
        var v1 = (rectY + (halfTileHeight - 0.5)) / textureHeight;
        var scrollX = camera.scrollX * scrollFactorX;
        var scrollY = camera.scrollY * scrollFactorY;
        
        mva = cameraMatrix[0];
        mvb = cameraMatrix[1];
        mvc = cameraMatrix[2];
        mvd = cameraMatrix[3];
        mve = cameraMatrix[4];
        mvf = cameraMatrix[5];

        tx0 = (x * mva + y * mvc + mve) - scrollX;
        ty0 = (x * mvb + y * mvd + mvf) - scrollY;
        tx1 = (x * mva + yh * mvc + mve) - scrollX;
        ty1 = (x * mvb + yh * mvd + mvf) - scrollY;
        tx2 = (xw * mva + yh * mvc + mve) - scrollX;
        ty2 = (xw * mvb + yh * mvd + mvf) - scrollY;
        tx3 = (xw * mva + y * mvc + mve) - scrollX;
        ty3 = (xw * mvb + y * mvd + mvf) - scrollY;

        this.manager.setRenderer(this, texture, renderTarget);
        this.drawIndexed = true;
        this.drawingMesh = false;
        this.elementCount += 6;
        vertexOffset = vertexDataBuffer.allocate(24);
        
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = u0;
        vertexBufferObjectF32[vertexOffset++] = v0;
        vertexBufferObjectU32[vertexOffset++] = tint;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = u0;
        vertexBufferObjectF32[vertexOffset++] = v1;
        vertexBufferObjectU32[vertexOffset++] = tint;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = u1;
        vertexBufferObjectF32[vertexOffset++] = v1;
        vertexBufferObjectU32[vertexOffset++] = tint;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = u1;
        vertexBufferObjectF32[vertexOffset++] = v0;
        vertexBufferObjectU32[vertexOffset++] = tint;
        vertexBufferObjectF32[vertexOffset++] = alpha;
    },

    addSpriteTextureRect: function (gameObject, camera, texture, rectX, rectY, rectWidth, rectHeight, textureWidth, textureHeight)
    {
        var tempMatrix = this.tempMatrix;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var width = rectWidth * (gameObject.flipX ? -1 : 1);
        var height = rectHeight * (gameObject.flipY ? -1 : 1);
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var x = -gameObject.displayOriginX + ((rectWidth) * (gameObject.flipX ? 1 : 0.0));
        var y = -gameObject.displayOriginY + ((rectHeight) * (gameObject.flipY ? 1 : 0.0));
        var xw = x + rectWidth;
        var yh = y + rectHeight;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alphaTL = gameObject._alphaTL;
        var alphaTR = gameObject._alphaTR;
        var alphaBL = gameObject._alphaBL;
        var alphaBR = gameObject._alphaBR;
        var tintTL = gameObject._tintTL;
        var tintTR = gameObject._tintTR;
        var tintBL = gameObject._tintBL;
        var tintBR = gameObject._tintBR;
        var u0 = 0; // rectX / textureWidth;
        var v0 = 0; // rectY / textureHeight;
        var u1 = 1; // u0 + (rectWidth / textureWidth);
        var v1 = 1; // v0 + (rectHeight / textureHeight);

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf;
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setRenderer(this, texture, gameObject.renderTarget);
        this.drawIndexed = true;
        this.drawingMesh = false;
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        //  Top Left
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = u0;
        vertexBufferObjectF32[vertexOffset++] = v0;
        vertexBufferObjectU32[vertexOffset++] = tintTL;
        vertexBufferObjectF32[vertexOffset++] = alphaTL;

        //  Bottom Left
        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = u0;
        vertexBufferObjectF32[vertexOffset++] = v1;
        vertexBufferObjectU32[vertexOffset++] = tintBL;
        vertexBufferObjectF32[vertexOffset++] = alphaBL;

        //  Bottom Right
        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = u1;
        vertexBufferObjectF32[vertexOffset++] = v1;
        vertexBufferObjectU32[vertexOffset++] = tintBR;
        vertexBufferObjectF32[vertexOffset++] = alphaBR;

        //  Top Right
        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = u1;
        vertexBufferObjectF32[vertexOffset++] = v0;
        vertexBufferObjectU32[vertexOffset++] = tintTR;
        vertexBufferObjectF32[vertexOffset++] = alphaTR;
    },

    addSpriteTexture: function (gameObject, camera, texture, textureWidth, textureHeight)
    {
        var tempMatrix = this.tempMatrix;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var width = textureWidth * (gameObject.flipX ? -1 : 1);
        var height = textureHeight * (gameObject.flipY ? -1 : 1);
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var x = -gameObject.displayOriginX + ((textureWidth) * (gameObject.flipX ? 1 : 0.0));
        var y = -gameObject.displayOriginY + ((textureHeight) * (gameObject.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alphaTL = gameObject._alphaTL;
        var alphaTR = gameObject._alphaTR;
        var alphaBL = gameObject._alphaBL;
        var alphaBR = gameObject._alphaBR;
        var tintTL = gameObject._tintTL;
        var tintTR = gameObject._tintTR;
        var tintBL = gameObject._tintBL;
        var tintBR = gameObject._tintBR;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf;
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setRenderer(this, texture, gameObject.renderTarget);
        this.drawIndexed = true;
        this.drawingMesh = false;
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        //  Top Left
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectU32[vertexOffset++] = tintTL;
        vertexBufferObjectF32[vertexOffset++] = alphaTL;

        //  Bottom Left
        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectU32[vertexOffset++] = tintBL;
        vertexBufferObjectF32[vertexOffset++] = alphaBL;

        //  Bottom Right
        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectU32[vertexOffset++] = tintBR;
        vertexBufferObjectF32[vertexOffset++] = alphaBR;

        //  Top Right
        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectU32[vertexOffset++] = tintTR;
        vertexBufferObjectF32[vertexOffset++] = alphaTR;
    },

    addSprite: function (gameObject, camera)
    {
        var tempMatrix = this.tempMatrix;
        var frame = gameObject.frame;
        var forceFlipY = (frame.texture.source[frame.sourceIndex].glTexture.isRenderTexture ? true : false);
        var flipX = gameObject.flipX;
        var flipY = gameObject.flipY ^ forceFlipY;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var uvs = frame.uvs;
        var width = frame.width * (flipX ? -1 : 1);
        var height = frame.height * (flipY ? -1 : 1);
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var x = -gameObject.displayOriginX + frame.x + ((frame.width) * (flipX ? 1 : 0.0));
        var y = -gameObject.displayOriginY + frame.y + ((frame.height) * (flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alphaTL = gameObject._alphaTL;
        var alphaTR = gameObject._alphaTR;
        var alphaBL = gameObject._alphaBL;
        var alphaBR = gameObject._alphaBR;
        var tintTL = gameObject._tintTL;
        var tintTR = gameObject._tintTR;
        var tintBL = gameObject._tintBL;
        var tintBR = gameObject._tintBR;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf;
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setRenderer(this, frame.texture.source[frame.sourceIndex].glTexture, gameObject.renderTarget);
        this.drawIndexed = true;
        this.drawingMesh = false;
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        //  Top Left
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = uvs.x0;
        vertexBufferObjectF32[vertexOffset++] = uvs.y0;
        vertexBufferObjectU32[vertexOffset++] = tintTL;
        vertexBufferObjectF32[vertexOffset++] = alphaTL;

        //  Bottom Left
        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = uvs.x1;
        vertexBufferObjectF32[vertexOffset++] = uvs.y1;
        vertexBufferObjectU32[vertexOffset++] = tintBL;
        vertexBufferObjectF32[vertexOffset++] = alphaBL;

        //  Bottom Right
        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = uvs.x2;
        vertexBufferObjectF32[vertexOffset++] = uvs.y2;
        vertexBufferObjectU32[vertexOffset++] = tintBR;
        vertexBufferObjectF32[vertexOffset++] = alphaBR;

        //  Top Right
        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = uvs.x3;
        vertexBufferObjectF32[vertexOffset++] = uvs.y3;
        vertexBufferObjectU32[vertexOffset++] = tintTR;
        vertexBufferObjectF32[vertexOffset++] = alphaTR;
    }

});

module.exports = SpriteBatch;


/***/ }),
/* 908 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = (sizeof(vec2) * 4) + (sizeof(float) + sizeof(uint32))
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    SPRITE_VERTEX_COUNT: 4,
    SPRITE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    SPRITE_VERTEX_COMPONENT_COUNT: 6,

    // Can't be bigger since index are 16-bit
    MAX_SPRITES: 2000
    
};

module.exports = CONST;


/***/ }),
/* 909 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(910);
var DataBuffer16 = __webpack_require__(36);
var DataBuffer32 = __webpack_require__(29);
var PHASER_CONST = __webpack_require__(9);
var TexturedAndNormalizedTintedShader = __webpack_require__(43);
var TransformMatrix = __webpack_require__(17);

var TileBatch = new Class({

    initialize:

    function TileBatch (game, gl, manager)
    {
        this.game = game;
        this.type = PHASER_CONST.WEBGL;
        this.view = game.canvas;
        this.resolution = game.config.resolution;
        this.width = game.config.width * game.config.resolution;
        this.height = game.config.height * game.config.resolution;
        this.glContext = gl;
        this.maxSprites = null;
        this.shader = null;
        this.vertexBufferObject = null;
        this.indexBufferObject = null;
        this.vertexDataBuffer = null;
        this.indexDataBuffer = null;
        this.elementCount = 0;
        this.currentTexture2D = null;
        this.viewMatrixLocation = null;
        this.tempMatrix = new TransformMatrix();

        //   All of these settings will be able to be controlled via the Game Config
        this.config = {
            clearBeforeRender: true,
            transparent: false,
            autoResize: false,
            preserveDrawingBuffer: false,

            WebGLContextOptions: {
                alpha: true,
                antialias: true,
                premultipliedAlpha: true,
                stencil: true,
                preserveDrawingBuffer: false
            }
        };

        this.manager = manager;
        this.dirty = false;

        this.init(this.glContext);
    },

    init: function (gl)
    {
        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.SPRITE_VERTEX_COUNT * CONST.MAX_SPRITES);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.SPRITE_INDEX_COUNT * CONST.MAX_SPRITES);
        var shader = this.manager.resourceManager.createShader('TexturedAndNormalizedTintedShader', TexturedAndNormalizedTintedShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_SPRITES * CONST.SPRITE_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 3, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 16);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_alpha'), 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 20);

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.SPRITE_INDEX_COUNT, indexB += CONST.SPRITE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }

        this.indexBufferObject.bind();
        this.vertexBufferObject.bind();
    },

    flush: function (shader, renderTarget)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0)
        {
            return;
        }
        
        if (renderTarget)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget);
        }

        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);

        vertexDataBuffer.clear();

        this.elementCount = 0;

        if (renderTarget)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    resize: function (width, height, resolution, shader)
    {
        var activeShader = shader !== undefined ? shader : this.shader;
        var location = activeShader == this.shader ? this.viewMatrixLocation : activeShader.getUniformLocation('u_view_matrix');

        this.width = width * resolution;
        this.height = height * resolution;
        this.setProjectionMatrix(activeShader, location);
    },

    setProjectionMatrix: function (shader, location)
    {
        shader.setConstantMatrix4x4(
            location,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    },

    addTileSprite: function (gameObject, camera)
    {
        var tempMatrix = this.tempMatrix;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var width = gameObject.width * (gameObject.flipX ? -1 : 1);
        var height = gameObject.height * (gameObject.flipY ? -1 : 1);
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var displayOriginX = gameObject.originX * gameObject.width;
        var displayOriginY = gameObject.originY * gameObject.height;
        var x = -displayOriginX + ((gameObject.width) * (gameObject.flipX ? 1 : 0.0));
        var y = -displayOriginY + ((gameObject.height) * (gameObject.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var u0 = 0;
        var v0 = 0;
        var u1 = width / gameObject.frame.width;
        var v1 = height / gameObject.frame.height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alpha = gameObject.alpha;
        var tilePositionX = gameObject.tilePositionX / gameObject.frame.width;
        var tilePositionY = gameObject.tilePositionY / gameObject.frame.height;
        var texture = gameObject.tileTexture;
        var tintTL = gameObject._tintTL;
        var tintTR = gameObject._tintTR;
        var tintBL = gameObject._tintBL;
        var tintBR = gameObject._tintBR;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf;
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setRenderer(this, texture, gameObject.renderTarget);
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        //  Top Left
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = u0 + tilePositionX;
        vertexBufferObjectF32[vertexOffset++] = v0 + tilePositionY;
        vertexBufferObjectU32[vertexOffset++] = tintTL;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        //  Bottom Left
        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = u0 + tilePositionX;
        vertexBufferObjectF32[vertexOffset++] = v1 + tilePositionY;
        vertexBufferObjectU32[vertexOffset++] = tintBL;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        //  Bottom Right
        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = u1 + tilePositionX;
        vertexBufferObjectF32[vertexOffset++] = v1 + tilePositionY;
        vertexBufferObjectU32[vertexOffset++] = tintBR;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        //  Top Right
        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = u1 + tilePositionX;
        vertexBufferObjectF32[vertexOffset++] = v0 + tilePositionY;
        vertexBufferObjectU32[vertexOffset++] = tintTR;
        vertexBufferObjectF32[vertexOffset++] = alpha;
    }

});

module.exports = TileBatch;


/***/ }),
/* 910 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = (sizeof(vec2) * 4) + (sizeof(float) + sizeof(uint32))
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    SPRITE_VERTEX_COUNT: 4,
    SPRITE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    SPRITE_VERTEX_COMPONENT_COUNT: 6,

    // Can't be bigger since index are 16-bit
    MAX_SPRITES: 2000
    
};

module.exports = CONST;


/***/ }),
/* 911 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(230);
var DataBuffer16 = __webpack_require__(36);
var DataBuffer32 = __webpack_require__(29);
var PHASER_CONST = __webpack_require__(9);
var TilemapShader = __webpack_require__(921);

var TilemapRenderer = new Class({

    initialize:

    function TilemapRenderer (game, gl, manager)
    {
        this.game = game;
        this.type = PHASER_CONST.WEBGL;
        this.view = game.canvas;
        this.resolution = game.config.resolution;
        this.width = game.config.width * game.config.resolution;
        this.height = game.config.height * game.config.resolution;
        this.glContext = gl;
        this.shader = null;
        this.viewMatrixLocation = null;

        //   All of these settings will be able to be controlled via the Game Config
        this.config = {
            clearBeforeRender: true,
            transparent: false,
            autoResize: false,
            preserveDrawingBuffer: false,

            WebGLContextOptions: {
                alpha: true,
                antialias: true,
                premultipliedAlpha: true,
                stencil: true,
                preserveDrawingBuffer: false
            }
        };

        this.manager = manager;
        this.dirty = false;

        this.init(this.glContext);
    },

    init: function (gl)
    {
        var shader = this.manager.resourceManager.createShader('TilemapShader', TilemapShader);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var scrollLocation = shader.getUniformLocation('u_scroll');
        var scrollFactorLocation = shader.getUniformLocation('u_scroll_factor');
        var tilemapPositionLocation = shader.getUniformLocation('u_tilemap_position');

        this.shader = shader;
        this.viewMatrixLocation = viewMatrixLocation;
        this.scrollLocation = scrollLocation;
        this.scrollFactorLocation = scrollFactorLocation;
        this.tilemapPositionLocation = tilemapPositionLocation;

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return false;
    },

    add: function (x, y, width, height, red, green, blue, alpha)
    {
        
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }
    },

    flush: function (shader)
    {
    },

    resize: function (width, height, resolution, shader)
    {
        var activeShader = shader !== undefined ? shader : this.shader;
        
        this.width = width * resolution;
        this.height = height * resolution;

        activeShader.setConstantMatrix4x4(
            this.viewMatrixLocation,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);

        this.shader = null;
    }

});

module.exports = TilemapRenderer;


/***/ }),
/* 912 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CurrentIndexBuffer = null;
var IndexBuffer = new Class({

    initialize:

    function IndexBuffer (gl, bufferObject)
    {
        this.gl = gl;
        this.bufferTarget = gl.ELEMENT_ARRAY_BUFFER;
        this.bufferObject = bufferObject;
    },

    bind: function ()
    {
        var gl = this.gl;
        if (CurrentIndexBuffer !== this)
        {
            CurrentIndexBuffer = this;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferObject);
        }

        return this;
    },

    updateResource: function (bufferData, offset)
    {
        var gl = this.gl;

        if (CurrentIndexBuffer !== this)
        {
            CurrentIndexBuffer = this;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferObject);
        }
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset, bufferData);

        return this;
    }

});

IndexBuffer.SetDirty = function ()
{
    CurrentIndexBuffer = null;
};

module.exports = IndexBuffer;


/***/ }),
/* 913 */
/***/ (function(module, exports) {

var RenderTarget = function (framebufferObject, width, height, colorBuffer, depthStencilBuffer)
{
    this.framebufferObject = framebufferObject;
    this.width = width;
    this.height = height;
    this.colorBuffer = colorBuffer;
    this.depthStencilBuffer = depthStencilBuffer;
    this.shouldClear = false;
    this.clearAlpha = 0.0;
};

module.exports = RenderTarget;


/***/ }),
/* 914 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CurrentShader = null;
var Shader = new Class({

    initialize:

    function Shader (name, gl, program, vertexShader, fragmentShader)
    {
        this.gl = gl;
        this.program = program;
        this.vertexShader = vertexShader;
        this.fragmentShader = fragmentShader;
        this.name = name;
    },

    bindAttribLocation: function (index, name)
    {
        this.gl.bindAttribLocation(this.program, index, name);

    },

    getUniformLocation: function (name)
    {
        return this.gl.getUniformLocation(this.program, name);
    },

    getAttribLocation: function (name)
    {
        return this.gl.getAttribLocation(this.program, name);
    },

    setConstantFloat1: function (location, x)
    {
        this.bind();
        this.gl.uniform1f(location, x);

        return this;
    },
    
    setConstantFloat2: function (location, x, y)
    {
        this.bind();
        this.gl.uniform2f(location, x, y);

        return this;
    },
    
    setConstantFloat3: function (location, x, y, z)
    {
        this.bind();
        this.gl.uniform3f(location, x, y, z);

        return this;
    },
    
    setConstantFloat4: function (location, x, y, z, w)
    {
        this.bind();
        this.gl.uniform4f(location, x, y, z, w);

        return this;
    },
    
    setConstantInt1: function (location, x)
    {
        this.bind();
        this.gl.uniform1i(location, x);

        return this;
    },
    
    setConstantInt2: function (location, x, y)
    {
        this.bind();
        this.gl.uniform2i(location, x, y);

        return this;
    },
    
    setConstantInt3: function (location, x, y, z)
    {
        this.bind();
        this.gl.uniform3i(location, x, y, z);

        return this;
    },
    
    setConstantInt4: function (location, x, y, z, w)
    {
        this.bind();
        this.gl.uniform4i(location, x, y, z, w);

        return this;
    },
    
    setConstantMatrix2x2: function (location, floatArray)
    {
        this.bind();
        this.gl.uniformMatrix2fv(location, false, floatArray);

        return this;
    },
    
    setConstantMatrix3x3: function (location, floatArray)
    {
        this.bind();
        this.gl.uniformMatrix3fv(location, false, floatArray);

        return this;
    },
    
    setConstantMatrix4x4: function (location, floatArray)
    {
        this.bind();
        this.gl.uniformMatrix4fv(location, false, floatArray);

        return this;
    },

    bind: function ()
    {
        if (CurrentShader !== this)
        {
            CurrentShader = this;
            this.gl.useProgram(this.program);
        }

        return this;
    }

});

Shader.SetDirty = function ()
{
    CurrentShader = null;
};

module.exports = Shader;


/***/ }),
/* 915 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var Texture = new Class({

    initialize:

    function Texture (texture, width, height)
    {
        this.texture = texture;
        this.width = width;
        this.height = height;
        this.isRenderTexture = false;
    }

});

module.exports = Texture;


/***/ }),
/* 916 */
/***/ (function(module, exports) {

var GBufferShader = function ()
{
    var frag = [
        '#extension GL_EXT_draw_buffers : require',

        'precision mediump float;',

        'uniform sampler2D uMainTexture;',
        'uniform sampler2D uNormTexture;',

        'varying vec2 v_tex_coord;',
        'varying vec3 v_color;',
        'varying float v_alpha;',

        'void main()',
        '{',
        '    vec4 spriteColor = texture2D(uMainTexture, v_tex_coord) * vec4(v_color, v_alpha);',
        '    vec3 spriteNormal = texture2D(uNormTexture, v_tex_coord).rgb;',
            
        '    gl_FragData[0] = spriteColor;',
        '    gl_FragData[1] = vec4(spriteNormal, spriteColor.a);',
        '}'
    ];

    return frag.join('\n');
};

module.exports = GBufferShader;


/***/ }),
/* 917 */
/***/ (function(module, exports) {

var LightFragmentShader = function (maxLights)
{
    var frag = [
        'precision mediump float;',

        'struct Light',
        '{',
        '    vec3 position;',
        '    vec3 color;',
        '    float attenuation;',
        '    float radius;',
        '};',

        'uniform vec4 uCamera; /* x, y, rotation, zoom */',
        'uniform vec2 uResolution;',
        'uniform sampler2D uMainTexture;',
        'uniform sampler2D uNormTexture;',
        'uniform vec3 uAmbientLightColor;',
        'uniform Light uLights[' + maxLights + '];',

        'varying vec2 v_tex_coord;',
        'varying vec3 v_color;',
        'varying float v_alpha;',

        'void main()',
        '{',
        '    vec3 finalColor = vec3(0.0, 0.0, 0.0);',
        '    vec4 spriteColor = texture2D(uMainTexture, v_tex_coord) * vec4(v_color, v_alpha);',
        '    vec3 spriteNormal = texture2D(uNormTexture, v_tex_coord).rgb;',
        '    vec3 normal = normalize(vec3(spriteNormal * 2.0 - 1.0));',
        '    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;',

        '    for (int index = 0; index < ' + maxLights + '; ++index)',
        '    {',
        '        Light light = uLights[index];',
        '        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), light.position.z);',
        '        vec3 lightNormal = normalize(lightDir);',
        '        float distToSurf = length(lightDir) * uCamera.w;',
        '        float diffuseFactor = max(dot(normal, lightNormal), 0.0);',
        '        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;',
        '        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);',
        '        vec3 diffuse = light.color * spriteColor.rgb * diffuseFactor;',
        '        finalColor += attenuation * diffuse;',
        '    }',

        '    gl_FragColor = vec4(uAmbientLightColor + finalColor, spriteColor.a);',
        '}'
    ];

    return frag.join('\n');
};

module.exports = LightFragmentShader;


/***/ }),
/* 918 */
/***/ (function(module, exports) {

var ParticleShader = function ()
{
    var vert = [
        'precision mediump float;',
        'uniform mat4 u_view_matrix;',

        'attribute vec2 a_position;',
        'attribute vec2 a_tex_coord;',
        'attribute vec4 a_color;',

        'varying vec4 v_color;',
        'varying vec2 v_tex_coord;',

        'void main()',
        '{',
        '    gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',

        '    v_color = a_color;',
        '    v_tex_coord = a_tex_coord;',
        '}'
    ];

    var frag = [
        'precision mediump float;',

        'uniform sampler2D u_main_sampler;',

        'varying vec4 v_color;',
        'varying vec2 v_tex_coord;',

        'void main()',
        '{',
        '    gl_FragColor = texture2D(u_main_sampler, v_tex_coord) * v_color;',
        '}'
    ];

    return {
        vert: vert.join('\n'),
        frag: frag.join('\n')
    };
};

module.exports = ParticleShader();


/***/ }),
/* 919 */
/***/ (function(module, exports) {

var Phong2DShaderDeferred = function (maxLights)
{
    var vert = [
        'precision mediump float;',
        'attribute vec2 vertexPosition;',
        'void main()',
        '{',
        '    gl_Position = vec4(vertexPosition, 0.0, 1.0);',
        '}'
    ];

    var frag = [
        'precision mediump float;',

        'struct Light',
        '{',
        '    vec3 position;',
        '    vec3 color;',
        '    float attenuation;',
        '    float radius;',
        '};',

        'uniform vec4 uCamera; /* x, y, rotation, zoom */',
        'uniform vec2 uResolution;',
        'uniform sampler2D uGbufferColor;',
        'uniform sampler2D uGbufferNormal;',
        'uniform vec3 uAmbientLightColor;',
        'uniform Light uLights[' + maxLights + '];',

        'void main()',
        '{',
        '    vec2 uv = vec2(gl_FragCoord.xy / uResolution);',
        '    vec3 finalColor = vec3(0.0, 0.0, 0.0);',
        '    vec4 gbColor = texture2D(uGbufferColor, uv);',
        '    vec3 gbNormal = texture2D(uGbufferNormal, uv).rgb;',
        '    vec3 normal = normalize(vec3(gbNormal * 2.0 - 1.0));',
        '    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;',

        '    for (int index = 0; index < ' + maxLights + '; ++index)',
        '    {                ',
        '        Light light = uLights[index];',
        '        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), light.position.z);',
        '        vec3 lightNormal = normalize(lightDir);',
        '        float distToSurf = length(lightDir) * uCamera.w;',
        '        float diffuseFactor = max(dot(normal, lightNormal), 0.0);',
        '        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;',
        '        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);',
        '        vec3 diffuse = light.color * gbColor.rgb * diffuseFactor;',
        '        finalColor += attenuation * diffuse;',
        '    }',

        '    gl_FragColor = vec4(uAmbientLightColor + finalColor, gbColor.a);',
        '}'
    ];

    return {
        vert: vert.join('\n'),
        frag: frag.join('\n')
    };
};

module.exports = Phong2DShaderDeferred;


/***/ }),
/* 920 */
/***/ (function(module, exports) {

module.exports = {
    vert: [
        'uniform mat4 u_view_matrix;',
        'attribute vec2 a_position;',
        'attribute vec2 a_tex_coord;',
        'attribute float a_alpha;',
        'varying vec2 v_tex_coord;',
        'varying float v_alpha;',
        'void main () {',
        '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
        '   v_tex_coord = a_tex_coord;',
        '   v_alpha = a_alpha;',
        '}'
    ].join('\n'),
    frag: [
        'precision mediump float;',
        'uniform sampler2D u_sampler2D;',
        'varying vec2 v_tex_coord;',
        'varying float v_alpha;',
        'void main() {',
        '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord) * vec4(1.0, 1.0, 1.0, v_alpha);',
        '}'
    ].join('\n')
};


/***/ }),
/* 921 */
/***/ (function(module, exports) {

module.exports = {
    vert: [
        'uniform mat4 u_view_matrix;',
        'uniform vec2 u_scroll;',
        'uniform vec2 u_scroll_factor;',
        'uniform vec2 u_tilemap_position;',
        'attribute vec2 a_position;',
        'attribute vec2 a_tex_coord;',
        'varying vec2 v_tex_coord;',
        'void main () {',
        '   gl_Position = u_view_matrix * vec4(u_tilemap_position + a_position + (u_scroll * u_scroll_factor), 1.0, 1.0);',
        '   v_tex_coord = a_tex_coord;',
        '}'
    ].join('\n'),
    frag: [
        'precision mediump float;',
        'uniform sampler2D u_sampler2D;',
        'varying vec2 v_tex_coord;',
        'void main() {',
        '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord);',
        '}'
    ].join('\n')
};


/***/ }),
/* 922 */
/***/ (function(module, exports) {

module.exports = {
    vert: [
        'precision mediump float;',
        'uniform mat4 u_view_matrix;',
        'attribute vec2 a_position;',
        'attribute vec4 a_color;',
        'attribute float a_alpha;',
        'varying vec4 v_color;',
        'varying float v_alpha;',
        'void main () {',
        '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
        '   v_color = a_color;',
        '   v_alpha = a_alpha;',
        '}'
    ].join('\n'),
    frag: [
        'precision mediump float;',
        'varying vec4 v_color;',
        'varying float v_alpha;',
        'void main() {',
        '   gl_FragColor = vec4(v_color.bgr, v_alpha);',
        '}'
    ].join('\n')
};


/***/ }),
/* 923 */
/***/ (function(module, exports) {

module.exports = {
    vert: [
        'uniform mat4 u_view_matrix;',
        'attribute vec2 a_position;',
        'attribute vec4 a_color;',
        'varying vec4 v_color;',
        'void main () {',
        '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
        '   v_color = a_color;',
        '}'
    ].join('\n'),
    frag:[
        'precision lowp float;',
        'varying vec4 v_color;',
        'void main() {',
        '   gl_FragColor = v_color;',
        '}'
    ].join('\n')
};


/***/ }),
/* 924 */
/***/ (function(module, exports) {


module.exports = {

    PENDING: 0,
    INSTALLED: 1,

    BOOT: 0,
    INIT: 1,
    PRELOAD: 2,
    CREATE: 3,
    UPDATE: 4,
    RENDER: 5,
    SHUTDOWN: 6

};


/***/ }),
/* 925 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var GlobalSceneManager = new Class({

    initialize:

    function GlobalSceneManager (game, sceneConfig)
    {
        this.game = game;

        //  Everything kept in here
        this.keys = {};
        this.scenes = [];

        //  Only active scenes are kept in here. They are moved here when started, and moved out when not.
        //  All scenes are stored in the scenes array, regardless of being active or not.
        this.active = [];

        //  A scene pending to be added to the Scene Manager is stored in here until the manager has time to add it.
        this._pending = [];

        //  An array of scenes waiting to be started once the game has booted
        this._start = [];

        if (sceneConfig)
        {
            if (Array.isArray(sceneConfig))
            {
                for (var i = 0; i < sceneConfig.length; i++)
                {
                    //  The i === 0 part just starts the first Scene given
                    this._pending.push({
                        index: i,
                        key: 'default',
                        scene: sceneConfig[i],
                        autoStart: (i === 0),
                        data: {}
                    });
                }
            }
            else
            {
                this._pending.push({
                    index: 0,
                    key: 'default',
                    scene: sceneConfig,
                    autoStart: true,
                    data: {}
                });
            }
        }
    },

    add: __webpack_require__(926),
    boot: __webpack_require__(927),
    bootScene: __webpack_require__(928),
    bringToTop: __webpack_require__(929),
    create: __webpack_require__(930),
    createSceneDisplay: __webpack_require__(931),
    createSceneFromFunction: __webpack_require__(932),
    createSceneFromInstance: __webpack_require__(933),
    createSceneFromObject: __webpack_require__(934),
    getActiveScene: __webpack_require__(935),
    getActiveSceneIndex: __webpack_require__(936),
    getActiveSceneIndexByKey: __webpack_require__(937),
    getKey: __webpack_require__(938),
    getScene: __webpack_require__(939),
    getSceneAt: __webpack_require__(940),
    getSceneIndex: __webpack_require__(941),
    getSceneIndexByKey: __webpack_require__(942),
    isActive: __webpack_require__(943),
    isSleeping: __webpack_require__(944),
    loadComplete: __webpack_require__(945),
    moveDown: __webpack_require__(946),
    moveUp: __webpack_require__(947),
    pause: __webpack_require__(948),
    payloadComplete: __webpack_require__(949),
    resume: __webpack_require__(950),
    sendToBack: __webpack_require__(951),
    setupCallbacks: __webpack_require__(952),
    sleep: __webpack_require__(953),
    start: __webpack_require__(954),
    stop: __webpack_require__(955),
    swap: __webpack_require__(956),
    swapPosition: __webpack_require__(957),
    wake: __webpack_require__(958)

});

module.exports = GlobalSceneManager;


/***/ }),
/* 926 */
/***/ (function(module, exports, __webpack_require__) {

var Scene = __webpack_require__(48);

/**
* Adds a new Scene into the GlobalSceneManager. You must give each Scene a unique key by which you'll identify it.
* The Scene can be either a Phaser.Scene object (or an object that extends it), a plain JavaScript object or a function.
* If a function is given a new scene object will be created by calling it.
*
* @param {string} key - A unique key you use to reference this scene, i.e. "MainMenu", "Level1".
* @param {Phaser.Scene|object|function} scene  - The scene you want to switch to.
* @param {boolean} [autoStart=false]  - If true the Scene will be started immediately after adding it.
*/
var Add = function (key, sceneConfig, autoStart)
{
    if (autoStart === undefined) { autoStart = false; }

    //  if not booted, then put scene into a holding pattern
    if (!this.game.isBooted)
    {
        this._pending.push({
            index: this._pending.length,
            key: key,
            scene: sceneConfig,
            autoStart: autoStart
        });

        return;
    }

    // var ok = key;
    key = this.getKey(key, sceneConfig);

    var newScene;

    if (sceneConfig instanceof Scene)
    {
        newScene = this.createSceneFromInstance(key, sceneConfig);
    }
    else if (typeof sceneConfig === 'object')
    {
        sceneConfig.key = key;

        newScene = this.createSceneFromObject(key, sceneConfig);
    }
    else if (typeof sceneConfig === 'function')
    {
        newScene = this.createSceneFromFunction(key, sceneConfig);
    }

    //  Replace key in case the scene changed it
    key = newScene.sys.settings.key;

    this.keys[key] = newScene;

    this.scenes.push(newScene);

    if (autoStart || newScene.sys.settings.active)
    {
        if (this.game.isBooted)
        {
            this.start(key);
        }
        else
        {
            this._start.push(key);
        }
    }

    return newScene;
};

module.exports = Add;


/***/ }),
/* 927 */
/***/ (function(module, exports) {

/**
* The Boot handler is called by Phaser.Game when it first starts up.
* The renderer is available by now.
*/
var Boot = function ()
{
    var i;
    var entry;

    for (i = 0; i < this._pending.length; i++)
    {
        entry = this._pending[i];

        this.add(entry.key, entry.scene, entry.autoStart);
    }

    for (i = 0; i < this._start.length; i++)
    {
        entry = this._start[i];

        this.start(entry);
    }

    //  Clear the pending lists
    this._start = [];
    this._pending = [];
};

module.exports = Boot;


/***/ }),
/* 928 */
/***/ (function(module, exports) {

var BootScene = function (scene)
{
    if (scene.init)
    {
        scene.init.call(scene, scene.sys.settings.data);
    }

    var loader = scene.sys.load;
        
    loader.reset();

    if (scene.preload)
    {
        scene.preload(this.game);

        //  Is the loader empty?
        if (loader.list.size === 0)
        {
            this.create(scene);
        }
        else
        {
            //  Start the loader going as we have something in the queue

            loader.events.once('LOADER_COMPLETE_EVENT', this.loadComplete.bind(this));

            loader.start();
        }
    }
    else
    {
        //  No preload? Then there was nothing to load either
        this.create(scene);
    }
};

module.exports = BootScene;


/***/ }),
/* 929 */
/***/ (function(module, exports) {

//  If the arguments are strings they are assumed to be keys, otherwise they are Scene objects
//  You can only swap the positions of Active (rendering / updating) Scenes. If a Scene is not active it cannot be moved.

var BringToTop = function (scene)
{
    var index = (typeof scene === 'string') ? this.getActiveSceneIndexByKey(scene) : this.getActiveSceneIndex(scene);

    if (index < this.active.length)
    {
        var i = 0;
        var entry = this.active.splice(index, 1);

        for (i = 0; i < this.active.length; i++)
        {
            this.active[i].index = i;
        }

        this.active.push({ index: i, scene: entry[0].scene });
    }
};

module.exports = BringToTop;


/***/ }),
/* 930 */
/***/ (function(module, exports, __webpack_require__) {

var SortScenes = __webpack_require__(111);

var Create = function (scene)
{
    //  Insert at the correct index, or it just all goes wrong :)

    var i = this.getSceneIndex(scene);

    this.active.push({ index: i, scene: scene });

    //  Sort the 'active' array based on the index property
    this.active.sort(SortScenes);

    if (scene.create)
    {
        scene.create.call(scene, scene.sys.settings.data);
    }
};

module.exports = Create;


/***/ }),
/* 931 */
/***/ (function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(15);
var CONST = __webpack_require__(9);
var GetContext = __webpack_require__(125);
var CanvasInterpolation = __webpack_require__(75);

var CreateSceneDisplay = function (scene)
{
    var settings = scene.sys.settings;

    var width = settings.width;
    var height = settings.height;

    var config = this.game.config;

    if (config.renderType === CONST.CANVAS)
    {
        if (settings.renderToTexture)
        {
            scene.sys.canvas = CanvasPool.create(scene, width, height);
            scene.sys.context = GetContext(scene.sys.canvas);
        }
        else
        {
            scene.sys.canvas = this.game.canvas;
            scene.sys.context = this.game.context;
        }

        //  Pixel Art mode?
        if (config.pixelArt)
        {
            CanvasInterpolation.setCrisp(scene.sys.canvas);
        }
    }
};

module.exports = CreateSceneDisplay;


/***/ }),
/* 932 */
/***/ (function(module, exports, __webpack_require__) {

var Scene = __webpack_require__(48);
var Systems = __webpack_require__(232);
var NOOP = __webpack_require__(3);

var CreateSceneFromFunction = function (key, scene)
{
    var newScene = new scene();

    if (newScene instanceof Scene)
    {
        var configKey = newScene.sys.settings.key;

        if (configKey !== '')
        {
            key = configKey;
        }

        if (this.keys.hasOwnProperty(key))
        {
            throw new Error('Cannot add a Scene with duplicate key: ' + key);
        }

        return this.createSceneFromInstance(key, newScene);
    }
    else
    {
        newScene.sys = new Systems(newScene);

        newScene.sys.settings.key = key;

        newScene.sys.init(this.game);

        this.createSceneDisplay(newScene);

        //  Default required functions

        if (!newScene.init)
        {
            newScene.init = NOOP;
        }

        if (!newScene.preload)
        {
            newScene.preload = NOOP;
        }

        if (!newScene.create)
        {
            newScene.create = NOOP;
        }

        if (!newScene.shutdown)
        {
            newScene.shutdown = NOOP;
        }

        if (!newScene.update)
        {
            newScene.update = NOOP;
        }

        if (!newScene.render)
        {
            newScene.render = NOOP;
        }

        return newScene;
    }
};

module.exports = CreateSceneFromFunction;


/***/ }),
/* 933 */
/***/ (function(module, exports) {

var CreateSceneFromInstance = function (key, newScene)
{
    var configKey = newScene.sys.settings.key;

    if (configKey !== '')
    {
        key = configKey;
    }
    else
    {
        newScene.sys.settings.key = key;
    }

    newScene.sys.init(this.game);

    this.createSceneDisplay(newScene);

    return newScene;
};

module.exports = CreateSceneFromInstance;


/***/ }),
/* 934 */
/***/ (function(module, exports, __webpack_require__) {

var Scene = __webpack_require__(48);

var CreateSceneFromObject = function (key, sceneConfig)
{
    var newScene = new Scene(sceneConfig);

    var configKey = newScene.sys.settings.key;

    if (configKey !== '')
    {
        key = configKey;
    }
    else
    {
        newScene.sys.settings.key = key;
    }

    newScene.sys.init(this.game);

    this.createSceneDisplay(newScene);

    return this.setupCallbacks(newScene, sceneConfig);
};

module.exports = CreateSceneFromObject;


/***/ }),
/* 935 */
/***/ (function(module, exports) {

var GetActiveScene = function (key)
{
    var scene = this.getScene(key);

    for (var i = 0; i < this.active.length; i++)
    {
        if (this.active[i].scene === scene)
        {
            return this.active[i];
        }
    }
};

module.exports = GetActiveScene;


/***/ }),
/* 936 */
/***/ (function(module, exports) {

var GetActiveSceneIndex = function (scene)
{
    for (var i = 0; i < this.active.length; i++)
    {
        if (this.active[i].scene === scene)
        {
            return this.active[i].index;
        }
    }

    return -1;
};

module.exports = GetActiveSceneIndex;


/***/ }),
/* 937 */
/***/ (function(module, exports) {

var GetActiveSceneIndexByKey = function (key)
{
    var scene = this.keys[key];

    for (var i = 0; i < this.active.length; i++)
    {
        if (this.active[i].scene === scene)
        {
            return this.active[i].index;
        }
    }

    return -1;
};

module.exports = GetActiveSceneIndexByKey;


/***/ }),
/* 938 */
/***/ (function(module, exports, __webpack_require__) {

var Scene = __webpack_require__(48);

//  private
var GetKey = function (key, sceneConfig)
{
    if (!key) { key = 'default'; }

    if (typeof sceneConfig === 'function')
    {
        return key;
    }
    else if (sceneConfig instanceof Scene)
    {
        key = sceneConfig.sys.settings.key;
    }
    else if (typeof sceneConfig === 'object' && sceneConfig.hasOwnProperty('key'))
    {
        key = sceneConfig.key;
    }

    //  By this point it's either 'default' or extracted from the Scene

    if (this.keys.hasOwnProperty(key))
    {
        throw new Error('Cannot add a Scene with duplicate key: ' + key);
    }
    else
    {
        return key;
    }
};

module.exports = GetKey;


/***/ }),
/* 939 */
/***/ (function(module, exports) {

var GetScene = function (key)
{
    return this.keys[key];
};

module.exports = GetScene;


/***/ }),
/* 940 */
/***/ (function(module, exports) {

//  Gets the Active scene at the given position

var GetSceneAt = function (index)
{
    if (this.active[index])
    {
        return this.active[index].scene;
    }
};

module.exports = GetSceneAt;


/***/ }),
/* 941 */
/***/ (function(module, exports) {

var GetSceneIndex = function (scene)
{
    return this.scenes.indexOf(scene);
};

module.exports = GetSceneIndex;


/***/ }),
/* 942 */
/***/ (function(module, exports) {

var GetSceneIndexByKey = function (key)
{
    var scene = this.keys[key];

    return this.scenes.indexOf(scene);
};

module.exports = GetSceneIndexByKey;


/***/ }),
/* 943 */
/***/ (function(module, exports) {

var IsActive = function (key)
{
    var entry = this.getActiveScene(key);

    return (entry && entry.scene.sys.settings.active);
};

module.exports = IsActive;


/***/ }),
/* 944 */
/***/ (function(module, exports) {

var IsSleeping = function (key)
{
    var entry = this.getActiveScene(key);

    if (entry)
    {
        return (!entry.scene.sys.settings.active && !entry.scene.sys.settings.visible);
    }

    return false;
};

module.exports = IsSleeping;


/***/ }),
/* 945 */
/***/ (function(module, exports) {

var LoadComplete = function (event)
{
    var scene = event.loader.scene;

    this.create(scene);
};

module.exports = LoadComplete;


/***/ }),
/* 946 */
/***/ (function(module, exports) {

//  If the arguments are strings they are assumed to be keys, otherwise they are Scene objects
//  You can only swap the positions of Active (rendering / updating) Scenes. If a Scene is not active it cannot be moved.

var MoveDown = function (scene)
{
    var index = (typeof scene === 'string') ? this.getActiveSceneIndexByKey(scene) : this.getActiveSceneIndex(scene);

    if (index > 0)
    {
        var sceneB = this.getSceneAt(index - 1);

        if (sceneB)
        {
            this.swapPosition(scene, sceneB);
        }
    }
};

module.exports = MoveDown;


/***/ }),
/* 947 */
/***/ (function(module, exports) {

//  If the arguments are strings they are assumed to be keys, otherwise they are Scene objects
//  You can only swap the positions of Active (rendering / updating) Scenes. If a Scene is not active it cannot be moved.

var MoveUp = function (scene)
{
    var index = (typeof scene === 'string') ? this.getActiveSceneIndexByKey(scene) : this.getActiveSceneIndex(scene);

    if (index !== -1 && index < this.active.length - 1)
    {
        var sceneB = this.getSceneAt(index + 1);

        if (sceneB)
        {
            this.swapPosition(scene, sceneB);
        }
    }
};

module.exports = MoveUp;


/***/ }),
/* 948 */
/***/ (function(module, exports) {

var Pause = function (key)
{
    var entry = this.getActiveScene(key);

    if (entry)
    {
        entry.scene.sys.pause();
    }
};

module.exports = Pause;


/***/ }),
/* 949 */
/***/ (function(module, exports) {

var PayloadComplete = function (event)
{
    var scene = event.loader.scene;

    this.bootScene(scene);
};

module.exports = PayloadComplete;


/***/ }),
/* 950 */
/***/ (function(module, exports) {

var Resume = function (key)
{
    var entry = this.getActiveScene(key);

    if (entry)
    {
        entry.scene.sys.resume();
    }
};

module.exports = Resume;


/***/ }),
/* 951 */
/***/ (function(module, exports) {

//  If the arguments are strings they are assumed to be keys, otherwise they are Scene objects
//  You can only swap the positions of Active (rendering / updating) Scenes. If a Scene is not active it cannot be moved.

var SendToBack = function (scene)
{
    var index = (typeof scene === 'string') ? this.getActiveSceneIndexByKey(scene) : this.getActiveSceneIndex(scene);

    if (index > 0)
    {
        var entry = this.active.splice(index, 1);

        this.active.unshift({ index: 0, scene: entry[0].scene });

        for (var i = 0; i < this.active.length; i++)
        {
            this.active[i].index = i;
        }
    }
};

module.exports = SendToBack;


/***/ }),
/* 952 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(4);
var NOOP = __webpack_require__(3);

var SetupCallbacks = function (scene, sceneConfig)
{
    if (sceneConfig === undefined) { sceneConfig = scene; }

    //  Extract callbacks or set NOOP

    scene.init = GetValue(sceneConfig, 'init', NOOP);
    scene.preload = GetValue(sceneConfig, 'preload', NOOP);
    scene.create = GetValue(sceneConfig, 'create', NOOP);
    scene.shutdown = GetValue(sceneConfig, 'shutdown', NOOP);

    //  Game Loop level callbacks

    scene.update = GetValue(sceneConfig, 'update', NOOP);
    scene.render = GetValue(sceneConfig, 'render', NOOP);

    return scene;
};

module.exports = SetupCallbacks;


/***/ }),
/* 953 */
/***/ (function(module, exports) {

var Sleep = function (key)
{
    var entry = this.getActiveScene(key);

    if (entry)
    {
        entry.scene.sys.sleep();
    }
};

module.exports = Sleep;


/***/ }),
/* 954 */
/***/ (function(module, exports) {

var Start = function (key, data)
{
    if (data === undefined) { data = {}; }

    //  if not booted, then put scene into a holding pattern
    if (!this.game.isBooted)
    {
        for (var i = 0; i < this._pending.length; i++)
        {
            var entry = this._pending[i];

            if (entry.key === key)
            {
                entry.autoStart = true;
                entry.data = data;
            }
        }

        return;
    }

    var scene = this.getScene(key);

    if (scene)
    {
        //  Already started? Nothing more to do here ...
        if (this.isActive(key))
        {
            return;
        }

        scene.sys.start(data);

        var loader = scene.sys.load;

        //  Files payload?
        if (loader && Array.isArray(scene.sys.settings.files))
        {
            loader.reset();

            if (loader.loadArray(scene.sys.settings.files))
            {
                loader.events.once('LOADER_COMPLETE_EVENT', this.payloadComplete.bind(this));

                loader.start();
            }
            else
            {
                this.bootScene(scene);
            }
        }
        else
        {
            this.bootScene(scene);
        }
    }
};

module.exports = Start;


/***/ }),
/* 955 */
/***/ (function(module, exports, __webpack_require__) {

var SortScenes = __webpack_require__(111);

var Stop = function (key)
{
    var entry = this.getActiveScene(key);

    if (entry)
    {
        entry.scene.sys.shutdown();

        //  Remove from the active list
        var index = this.active.indexOf(entry);

        if (index !== -1)
        {
            this.active.splice(index, 1);

            this.active.sort(SortScenes);
        }
    }
};

module.exports = Stop;


/***/ }),
/* 956 */
/***/ (function(module, exports) {

var Swap = function (from, to)
{
    this.sleep(from);

    if (this.isSleeping(to))
    {
        this.wake(to);
    }
    else
    {
        this.start(to);
    }
};

module.exports = Swap;


/***/ }),
/* 957 */
/***/ (function(module, exports, __webpack_require__) {

var SortScenes = __webpack_require__(111);

//  If the arguments are strings they are assumed to be keys, otherwise they are Scene objects
//  You can only swap the positions of Active (rendering / updating) Scenes. If a Scene is not active it cannot be moved.

var SwapPosition = function (scene1, scene2)
{
    if (scene1 === scene2)
    {
        return;
    }

    var index1 = (typeof scene1 === 'string') ? this.getActiveSceneIndexByKey(scene1) : this.getActiveSceneIndex(scene1);
    var index2 = (typeof scene2 === 'string') ? this.getActiveSceneIndexByKey(scene2) : this.getActiveSceneIndex(scene2);

    if (index1 !== -1 && index2 !== -1)
    {
        this.active[index1].index = index2;
        this.active[index2].index = index1;

        this.active.sort(SortScenes);
    }
};

module.exports = SwapPosition;


/***/ }),
/* 958 */
/***/ (function(module, exports) {

var Wake = function (key)
{
    var entry = this.getActiveScene(key);

    if (entry)
    {
        entry.scene.sys.wake();
    }
};

module.exports = Wake;


/***/ }),
/* 959 */
/***/ (function(module, exports) {

//  These properties get injected into the Scene and map to local systems
//  The map key is the local system reference, the value is the property that is added to the Scene
//  These defaults can be modified via the Scene config object

var InjectionMap = {

    game: 'game',

    anims: 'anims',
    cache: 'cache',
    registry: 'registry',
    textures: 'textures',

    add: 'add',
    cameras: 'cameras',
    data: 'data',
    displayList: 'children',
    events: 'events',
    inputManager: 'input',
    load: 'load',
    make: 'make',
    physicsManager: 'physics',
    pool: 'pool',
    sceneManager: 'scene',
    time: 'time',
    tweens: 'tweens'

};

module.exports = InjectionMap;


/***/ }),
/* 960 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(924);
var ScaleModes = __webpack_require__(35);
var GetValue = __webpack_require__(4);
var InjectionMap = __webpack_require__(959);

var Settings = {

    create: function (config)
    {
        if (typeof config === 'string')
        {
            config = { key: config };
        }
        else if (config === undefined)
        {
            //  Pass the 'hasOwnProperty' checks
            config = {};
        }

        return {

            status: CONST.PENDING,

            op: CONST.BOOT,

            key: GetValue(config, 'key', ''),
            active: GetValue(config, 'active', false),
            visible: GetValue(config, 'visible', true),

            //  Loader payload array

            data: {},

            files: GetValue(config, 'files', false),

            //  Cameras

            cameras: GetValue(config, 'cameras', null),

            //  Scene Property Injection Map

            map: GetValue(config, 'map', InjectionMap),

            //  Physics
            physics: GetValue(config, 'physics', {}),

            //  Scene Render Settings (applies only to this Scene)

            scaleMode: GetValue(config, 'scaleMode', ScaleModes.DEFAULT),
            roundPixels: GetValue(config, 'roundPixels', false),

            dirtyRender: GetValue(config, 'dirtyRender', false),
            renderToTexture: GetValue(config, 'renderToTexture', false),

            //  The following only apply if renderToTexture is true

            autoResize: GetValue(config, 'autoResize', false)

        };
    }

};

module.exports = Settings;


/***/ }),
/* 961 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Data = __webpack_require__(112);

var DataStore = new Class({

    initialize:

    function DataStore (scene)
    {
        this.scene = scene;

        this.events = scene.sys.events;

        this._list = [];
        this._data = [];
    },

    getData: function (gameObject)
    {
        var data;
        var idx = this._list.indexOf(gameObject);

        if (idx === -1)
        {
            data = new Data(gameObject, this.events);

            this._list.push(gameObject);
            this._data.push(data);
        }
        else
        {
            data = this._data[idx];
        }

        return data;
    },

    get: function (gameObject, key)
    {
        var data = this.getData(gameObject);

        return data.get(key);
    },

    set: function (gameObject, key, value)
    {
        var data = this.getData(gameObject);

        return data.set(key, value);
    },

    getAll: function (gameObject)
    {
        var data = this.getData(gameObject);

        return data.getAll();
    },

    query: function (gameObject, search)
    {
        var data = this.getData(gameObject);

        return data.query(search);
    },

    before: function (gameObject, key, callback, scope)
    {
        var data = this.getData(gameObject);

        return data.before(key, callback, scope);
    },

    after: function (gameObject, key, callback, scope)
    {
        var data = this.getData(gameObject);

        return data.after(key, callback, scope);
    },

    each: function (gameObject, callback, scope, args)
    {
        var data = this.getData(gameObject);

        return data.each(callback, scope);
    },

    merge: function (gameObject, data, overwrite)
    {
        var data = this.getData(gameObject);

        return data.merge(data, overwrite);
    },

    remove: function (gameObject, key)
    {
        var data = this.getData(gameObject);

        return data.remove(key);
    },

    removeListeners: function (gameObject, key)
    {
        var data = this.getData(gameObject);

        return data.removeListeners(key);
    },

    pop: function (gameObject, key)
    {
        var data = this.getData(gameObject);

        return data.pop(key);
    },

    has: function (gameObject, key)
    {
        var data = this.getData(gameObject);

        return data.has(key);
    },

    reset: function (gameObject)
    {
        var data = this.getData(gameObject);

        return data.reset();
    },

    freeze: function (gameObject)
    {
        var data = this.getData(gameObject);

        data.freeze = true;
    },

    unfreeze: function (gameObject)
    {
        var data = this.getData(gameObject);

        data.freeze = false;
    },

    kill: function (gameObject)
    {
        if (this.list.hasOwnProperty(gameObject))
        {
            var data = this.list[gameObject];

            data.destroy();

            delete this.list[gameObject];
        }
    }

});

module.exports = DataStore;


/***/ }),
/* 962 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var InputEvent = __webpack_require__(41);
var SceneInputManager = __webpack_require__(727);

var InputManager = new Class({

    Extends: SceneInputManager,

    initialize:

    function InputManager (scene)
    {
        SceneInputManager.call(this, scene);
    },

    pointScreenToWorldHitTest: function (gameObjects, x, y, camera)
    {
        return this.manager.pointScreenToWorldHitTest(gameObjects, x, y, camera);
    }

});

module.exports = InputManager;


/***/ }),
/* 963 */
/***/ (function(module, exports, __webpack_require__) {

var BaseLoader = __webpack_require__(786);
var Class = __webpack_require__(0);
var NumberArray = __webpack_require__(249);

var AnimationJSONFile = __webpack_require__(792);
var AtlasJSONFile = __webpack_require__(793);
var BinaryFile = __webpack_require__(794);
var BitmapFontFile = __webpack_require__(795);
var GLSLFile = __webpack_require__(796);
var HTMLFile = __webpack_require__(797);
var ImageFile = __webpack_require__(37);
var JSONFile = __webpack_require__(104);
var ScriptFile = __webpack_require__(799);
var SpriteSheet = __webpack_require__(800);
var SVGFile = __webpack_require__(798);
var TextFile = __webpack_require__(196);
var UnityAtlasFile = __webpack_require__(801);
var XMLFile = __webpack_require__(197);

var Loader = new Class({

    Extends: BaseLoader,

    initialize:

    function Loader (scene)
    {
        BaseLoader.call(this, scene);

        this._multilist = {};
    },

    //  key can be either a string, an object or an array of objects

    image: function (key, url, xhrSettings)
    {
        return ImageFile.create(this, key, url, xhrSettings);
    },

    animation: function (key, url, xhrSettings)
    {
        return AnimationJSONFile.create(this, key, url, xhrSettings);
    },

    json: function (key, url, xhrSettings)
    {
        return JSONFile.create(this, key, url, xhrSettings);
    },

    script: function (key, url, xhrSettings)
    {
        return ScriptFile.create(this, key, url, xhrSettings);
    },

    xml: function (key, url, xhrSettings)
    {
        return XMLFile.create(this, key, url, xhrSettings);
    },

    binary: function (key, url, xhrSettings)
    {
        return BinaryFile.create(this, key, url, xhrSettings);
    },

    text: function (key, url, xhrSettings)
    {
        return TextFile.create(this, key, url, xhrSettings);
    },

    glsl: function (key, url, xhrSettings)
    {
        return GLSLFile.create(this, key, url, xhrSettings);
    },

    html: function (key, url, width, height, xhrSettings)
    {
        return HTMLFile.create(this, key, url, width, height, xhrSettings);
    },

    svg: function (key, url, xhrSettings)
    {
        return SVGFile.create(this, key, url, xhrSettings);
    },

    //  config can include: frameWidth, frameHeight, startFrame, endFrame, margin, spacing
    spritesheet: function (key, url, config, xhrSettings)
    {
        return SpriteSheet.create(this, key, url, config, xhrSettings);
    },

    //  ---------------------------------------------------
    //  Multi-File Loaders
    //  ---------------------------------------------------

    unityAtlas: function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
    {
        //  Returns an object with two properties: 'texture' and 'data'
        var files = new UnityAtlasFile(key, textureURL, atlasURL, this.path, textureXhrSettings, atlasXhrSettings);

        this.addFile(files.texture);
        this.addFile(files.data);

        return this;
    },

    atlas: function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
    {
        //  Returns an object with two properties: 'texture' and 'data'
        var files = new AtlasJSONFile(key, textureURL, atlasURL, this.path, textureXhrSettings, atlasXhrSettings);

        this.addFile(files.texture);
        this.addFile(files.data);

        return this;
    },

    bitmapFont: function (key, textureURL, xmlURL, textureXhrSettings, xmlXhrSettings)
    {
        //  Returns an object with two properties: 'texture' and 'data'
        var files = new BitmapFontFile(key, textureURL, xmlURL, this.path, textureXhrSettings, xmlXhrSettings);

        this.addFile(files.texture);
        this.addFile(files.data);

        return this;
    },

    multiatlas: function (key, textureURLs, atlasURLs, textureXhrSettings, atlasXhrSettings)
    {
        if (typeof textureURLs === 'number')
        {
            var total = textureURLs;
            var suffix = (atlasURLs === undefined) ? '' : atlasURLs;

            textureURLs = NumberArray(0, total, key + suffix, '.png');
            atlasURLs = NumberArray(0, total, key + suffix, '.json');
        }
        else
        {
            if (!Array.isArray(textureURLs))
            {
                textureURLs = [ textureURLs ];
            }

            if (!Array.isArray(atlasURLs))
            {
                atlasURLs = [ atlasURLs ];
            }
        }

        var file;
        var i = 0;
        var multiKey;

        this._multilist[key] = [];

        for (i = 0; i < textureURLs.length; i++)
        {
            multiKey = '_MA_IMG_' + key + '_' + i.toString();

            file = new ImageFile(multiKey, textureURLs[i], this.path, textureXhrSettings);

            this.addFile(file);

            this._multilist[key].push(multiKey);
        }

        for (i = 0; i < atlasURLs.length; i++)
        {
            multiKey = '_MA_JSON_' + key + '_' + i.toString();

            file = new JSONFile(multiKey, atlasURLs[i], this.path, atlasXhrSettings);

            this.addFile(file);

            this._multilist[key].push(multiKey);
        }
    },

    loadArray: function (files)
    {
        if (Array.isArray(files))
        {
            for (var i = 0; i < files.length; i++)
            {
                this.file(files[i]);
            }
        }

        return (this.list.size > 0);
    },

    file: function (file)
    {
        var entry;

        switch (file.type)
        {
            case 'spritesheet':
                entry = this.spritesheet(file.key, file.url, file.config, file.xhrSettings);
                break;

            case 'atlas':
                entry = this.atlas(file.key, file.textureURL, file.atlasURL, file.textureXhrSettings, file.atlasXhrSettings);
                break;

            case 'bitmapFont':
                entry = this.bitmapFont(file.key, file.textureURL, file.xmlURL, file.textureXhrSettings, file.xmlXhrSettings);
                break;

            case 'multiatlas':
                entry = this.multiatlas(file.key, file.textureURLs, file.atlasURLs, file.textureXhrSettings, file.atlasXhrSettings);
                break;

            //  image, json, xml, binary, text, glsl, svg
            default:
                entry = this[file.type](file.key, file.url, file.xhrSettings);
                break;
        }

        return entry;
    }
    
});

module.exports = Loader;


/***/ }),
/* 964 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GetValue = __webpack_require__(4);
var Merge = __webpack_require__(115);
var NOOP = __webpack_require__(3);

//  Physics Systems
var Impact = __webpack_require__(857);

var PhysicsManager = new Class({

    initialize:

    function PhysicsManager (scene)
    {
        this.scene = scene;

        this.gameConfig = scene.sys.game.config.physics;
        this.defaultSystem = scene.sys.game.config.defaultPhysicsSystem;
        this.sceneConfig = scene.sys.settings.physics;

        //  This gets set to an instance of the physics system during boot
        this.system;

        //  This gets set by the physics system during boot
        this.world = { update: NOOP };

        //  This gets set by the physics system during boot
        this.add;
    },

    boot: function ()
    {
        var sceneSystem = GetValue(this.sceneConfig, 'system', false);

        if (!this.defaultSystem && !sceneSystem)
        {
            //  No default physics system or system in this scene, so abort
            return;
        }

        //  Which physics system are we using in this Scene?
        var system = (sceneSystem !== false) ? sceneSystem : this.defaultSystem;

        //  Create the config for it
        var config = Merge(this.sceneConfig, GetValue(this.gameConfig, system, {}));

        switch (system)
        {
            case 'impact':
                this.system = new Impact(this, config);
                break;
        }
    },

    update: function (time, delta)
    {
        this.world.update(time, delta);
    }

});

module.exports = PhysicsManager;


/***/ }),
/* 965 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var ObjectPool = __webpack_require__(86);
var SpritePool = __webpack_require__(518);

var PoolManager = new Class({

    initialize:

    function PoolManager (scene)
    {
        this.scene = scene;

        this._active = [];
        this._pendingInsertion = [];
        this._pendingRemoval = [];

        this.processing = false;
    },

    add: function (pool)
    {
        if (this.processing)
        {
            this._pendingInsertion.push(pool);
        }
        else
        {
            this._active.push(pool);
        }

        return this;
    },

    createSpritePool: function (maxSize, key, frame)
    {
        var pool = new SpritePool(this, maxSize, key, frame);

        this.add(pool);

        return pool;
    },

    createObjectPool: function (classType, maxSize)
    {
        if (maxSize === undefined) { maxSize = -1; }

        var pool = new ObjectPool(this, classType, maxSize);

        this.add(pool);

        return pool;
    },

    begin: function ()
    {
        var toRemove = this._pendingRemoval.length;
        var toInsert = this._pendingInsertion.length;

        if (toRemove === 0 && toInsert === 0)
        {
            //  Quick bail
            return;
        }

        var i;
        var pool;

        //  Delete old pools
        for (i = 0; i < toRemove; i++)
        {
            pool = this._pendingRemoval[i];

            var index = this._active.indexOf(pool);

            if (index > -1)
            {
                this._active.splice(index, 1);
            }

            pool.destroy();
        }

        //  Move pending to active
        this._active = this._active.concat(this._pendingInsertion.splice(0));

        //  Clear the lists
        this._pendingRemoval.length = 0;
        this._pendingInsertion.length = 0;
    },

    update: function (time, delta)
    {
        this.processing = true;

        for (var i = 0; i < this._active.length; i++)
        {
            var pool = this._active[i];

            pool.update.call(pool, time, delta);
        }

        this.processing = false;
    },

    //  Scene that owns this Pool is shutting down
    shutdown: function ()
    {
        var i;

        for (i = 0; i < this._pendingInsertion.length; i++)
        {
            this._pendingInsertion[i].destroy();
        }

        for (i = 0; i < this._active.length; i++)
        {
            this._active[i].destroy();
        }

        for (i = 0; i < this._pendingRemoval.length; i++)
        {
            this._pendingRemoval[i].destroy();
        }

        this._active.length = 0;
        this._pendingRemoval.length = 0;
        this._pendingInsertion.length = 0;
    },

    //  Game level nuke
    destroy: function ()
    {
        this.shutdown();

        this.scene = undefined;
    }

});

module.exports = PoolManager;


/***/ }),
/* 966 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

//  A proxy class to the Global Scene Manager
var SceneManager = new Class({

    initialize:

    function SceneManager (scene)
    {
        //  The Scene that owns this plugin
        this.scene = scene;

        this.settings = scene.sys.settings;

        this.key = scene.sys.settings.key;

        //  GlobalSceneManager
        this.manager = scene.sys.game.scene;

        //  Private
        this._queue = [];
    },

    update: function ()
    {
        var len = this._queue.length;

        if (len === 0)
        {
            return;
        }

        var manager = this.manager;

        //  Process the queue
        for (var i = 0; i < len; i++)
        {
            var action = this._queue[i];

            switch (action.type)
            {
                case 'add':
                    manager.add(action.key, action.data, action.autoStart);
                    break;

                case 'start':
                    manager.stop(this.key);
                    manager.start(action.key, action.data);
                    break;

                case 'launch':
                    manager.start(action.key, action.data);
                    break;

                case 'pause':
                    manager.pause(action.key);
                    break;

                case 'resume':
                    manager.resume(action.key);
                    break;

                case 'stop':
                    manager.stop(action.key);
                    break;

                case 'swap':
                    manager.swap(this.key, action.key);
                    break;

                case 'moveUp':
                    manager.moveUp(this.key);
                    break;

                case 'moveDown':
                    manager.moveDown(this.key);
                    break;

                case 'bringToTop':
                    manager.bringToTop(this.key);
                    break;

                case 'sendToBack':
                    manager.sendToBack(this.key);
                    break;

                case 'swapPosition':
                    manager.swapPosition(this.key, action.key);
                    break;

                case 'sleep':
                    manager.sleep(action.key);
                    break;

                case 'wake':
                    manager.wake(action.key);
                    break;
            }
        }

        this._queue.length = 0;
    },

    //  Shutdown this Scene and run the given one
    start: function (key, data)
    {
        if (key === undefined) { key = this.key; }

        this._queue.push({ type: 'start', key: key, data: data });

        return this;
    },

    //  Add the Scene into the Scene Manager and start it if 'autoStart' is true or the Scene config 'active' property is set
    add: function (key, sceneConfig, autoStart)
    {
        this._queue.push({ type: 'add', key: key, data: sceneConfig, autoStart: autoStart });

        return this;
    },

    //  Launch the given Scene and run it in parallel with this one
    launch: function (key, data)
    {
        if (key === undefined) { key = this.key; }

        this._queue.push({ type: 'launch', key: key, data: data });

        return this;
    },

    //  Pause the Scene - this stops the update step from happening but it still renders
    pause: function (key)
    {
        if (key === undefined) { key = this.key; }

        this._queue.push({ type: 'pause', key: key });

        return this;
    },

    //  Resume the Scene - starts the update loop again
    resume: function (key)
    {
        if (key === undefined) { key = this.key; }

        this._queue.push({ type: 'resume', key: key });

        return this;
    },

    //  Makes the Scene sleep (no update, no render) but doesn't shutdown
    sleep: function (key)
    {
        this._queue.push({ type: 'sleep', key: key });

        return this;
    },

    //  Makes the Scene wake-up (starts update and render)
    wake: function (key)
    {
        this._queue.push({ type: 'wake', key: key });

        return this;
    },

    //  Makes this Scene sleep then starts the Scene given
    swap: function (key)
    {
        this._queue.push({ type: 'swap', key: key });

        return this;
    },

    //  Shutdown the Scene, clearing display list, timers, etc
    stop: function (key)
    {
        if (key === undefined) { key = this.key; }

        this._queue.push({ type: 'stop', key: key });

        return this;
    },

    setVisible: function (value)
    {
        this.settings.visible = value;

        return this;
    },

    swapPosition: function (key)
    {
        this._queue.push({ type: 'swapPosition', key: key });
    },

    moveUp: function ()
    {
        this._queue.push({ type: 'moveUp' });
    },

    moveDown: function ()
    {
        this._queue.push({ type: 'moveDown' });
    },

    bringToTop: function ()
    {
        this._queue.push({ type: 'bringToTop' });
    },

    sendToBack: function ()
    {
        this._queue.push({ type: 'sendToBack' });
    },

    get: function (key)
    {
        return this.manager.getScene(key);
    },

    transitionTo: function (key, duration)
    {
    },

    isActive: function (key)
    {
        if (key === undefined) { key = this.key; }

        return this.manager.isActive(key);
    }

});

module.exports = SceneManager;


/***/ }),
/* 967 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);

var UpdateList = new Class({

    initialize:

    function UpdateList (scene)
    {
        this.scene = scene;

        this._list = [];
        this._pendingInsertion = [];
        this._pendingRemoval = [];
    },

    add: function (child)
    {
        this._pendingInsertion.push(child);
    },

    begin: function ()
    {
        var toRemove = this._pendingRemoval.length;
        var toInsert = this._pendingInsertion.length;

        if (toRemove === 0 && toInsert === 0)
        {
            //  Quick bail
            return;
        }

        var i;
        var gameObject;

        //  Delete old gameObjects
        for (i = 0; i < toRemove; i++)
        {
            gameObject = this._pendingRemoval[i];

            var index = this._list.indexOf(gameObject);

            if (index > -1)
            {
                this._list.splice(index, 1);
            }

            //  Pool them?
            // gameObject.destroy();
        }

        //  Move pending to active
        this._list = this._list.concat(this._pendingInsertion.splice(0));

        //  Clear the lists
        this._pendingRemoval.length = 0;
        this._pendingInsertion.length = 0;
    },

    update: function (time, delta)
    {
        for (var i = 0; i < this._list.length; i++)
        {
            var gameObject = this._list[i];

            if (gameObject.active)
            {
                gameObject.preUpdate.call(gameObject, time, delta);
            }
        }
    },

    remove: function (child)
    {
        var index = this._list.indexOf(child);

        if (index !== -1)
        {
            this._list.splice(index, 1);
        }
        
        return child;
    },

    removeAll: function ()
    {
        var i = this._list.length;

        while (i--)
        {
            this.remove(this._list[i]);
        }

        return this;
    },

    //  Scene that owns this Clock is shutting down
    shutdown: function ()
    {
        this.removeAll();

        this._list.length = 0;
        this._pendingRemoval.length = 0;
        this._pendingInsertion.length = 0;
    },

    //  Game level nuke
    destroy: function ()
    {
        this.shutdown();

        this.scene = undefined;
    }

});

module.exports = UpdateList;


/***/ }),
/* 968 */
/***/ (function(module, exports, __webpack_require__) {


var Between = __webpack_require__(65);
var Class = __webpack_require__(0);
var GetValue = __webpack_require__(4);

//  Phaser.Sound.Dynamic.FX

//  Based on Sound.js by KittyKatAttack
//  https://github.com/kittykatattack/sound.js

// frequency,      //The sound's fequency pitch in Hertz
// attack,              //The time, in seconds, to fade the sound in
// decay,               //The time, in seconds, to fade the sound out
// type,                //waveform type: "sine", "triangle", "square", "sawtooth"
// volume,         //The sound's maximum volume
// panValue,            //The speaker pan. left: -1, middle: 0, right: 1
// wait,                //The time, in seconds, to wait before playing the sound
// pitchBend,     //The number of Hz in which to bend the sound's pitch down
// reverse,             //If `reverse` is true the pitch will bend up
// random,         //A range, in Hz, within which to randomize the pitch
// dissonance,          //A value in Hz. It creates 2 dissonant frequencies above and below the target pitch
// echo,                //An array: [delayTimeInSeconds, feedbackTimeInSeconds, filterValueInHz]
// reverb,              //An array: [durationInSeconds, decayRateInSeconds, reverse]
// timeout              //A number, in seconds, which is the maximum duration for sound effects

var FX = new Class({

    initialize:

    function FX (ctx, config)
    {
        this.audioContext = ctx;

        this.frequencyValue = GetValue(config, 'frequency', 200);
        this.attack = GetValue(config, 'attack', 0);
        this.decay = GetValue(config, 'decay', 1);
        this.type = GetValue(config, 'type', 'sine');
        this.volumeValue = GetValue(config, 'volume', 1);
        this.panValue = GetValue(config, 'pan', 0);
        this.wait = GetValue(config, 'wait', 0);
        this.pitchBendAmount = GetValue(config, 'pitchBend', 0);
        this.reverse = GetValue(config, 'reverse', false);
        this.randomValue = GetValue(config, 'random', 0);
        this.dissonance = GetValue(config, 'dissonance', 0);
        this.echo = GetValue(config, 'echo', false);
        this.echoDelay = GetValue(config, 'echo.delay', 0);
        this.echoFeedback = GetValue(config, 'echo.feedback', 0);
        this.echoFilter = GetValue(config, 'echo.filter', 0);
        this.reverb = GetValue(config, 'reverb', false);
        this.reverbDuration = GetValue(config, 'reverb.duration', 0);
        this.reverbDecay = GetValue(config, 'reverb.decay', 0);
        this.reverbReverse = GetValue(config, 'reverb.reverse', false);
        this.timeout = GetValue(config, 'timeout', false);

        this.volume = ctx.createGain();
        this.pan = (!ctx.createStereoPanner) ? ctx.createPanner() : ctx.createStereoPanner();

        this.volume.connect(this.pan);
        this.pan.connect(ctx.destination);

        //  Set the values

        this.volume.gain.value = this.volumeValue;

        if (!ctx.createStereoPanner)
        {
            this.pan.setPosition(this.panValue, 0, 1 - Math.abs(this.panValue));
        }
        else
        {
            this.pan.pan.value = this.panValue;
        }

        //  Create an oscillator, gain and pan nodes, and connect them together to the destination

        var oscillator = ctx.createOscillator();

        oscillator.connect(this.volume);
        oscillator.type = this.type;

        //  Optionally randomize the pitch if `randomValue` > 0.
        //  A random pitch is selected that's within the range specified by `frequencyValue`.
        //  The random pitch will be either above or below the target frequency.

        if (this.randomValue > 0)
        {
            oscillator.frequency.value = Between(
                this.frequencyValue - this.randomValue / 2,
                this.frequencyValue + this.randomValue / 2
            );
        }
        else
        {
            oscillator.frequency.value = this.frequencyValue;
        }

        //  Apply effects

        if (this.attack > 0)
        {
            this.fadeIn(this.volume);
        }

        this.fadeOut(this.volume);

        if (this.pitchBendAmount > 0)
        {
            this.pitchBend(oscillator);
        }

        if (this.echo)
        {
            this.addEcho(this.volume);
        }

        if (this.reverb)
        {
            this.addReverb(this.volume);
        }

        if (this.dissonance > 0)
        {
            this.addDissonance();
        }

        this.play(oscillator);

        var _this = this;

        oscillator.onended = function ()
        {
            _this.pan.disconnect();
            _this.volume.disconnect();
        };
    },

    play: function (oscillator)
    {
        oscillator.start(this.audioContext.currentTime + this.wait);

        //Oscillators have to be stopped otherwise they accumulate in 
        //memory and tax the CPU. They'll be stopped after a default
        //timeout of 2 seconds, which should be enough for most sound 
        //effects. Override this in the `soundEffect` parameters if you
        //need a longer sound

        oscillator.stop(this.audioContext.currentTime + this.wait + 2);
    },

    fadeIn: function (volume)
    {
        volume.gain.value = 0;

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait);

        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);
    },

    fadeOut: function (volume)
    {
        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait + this.attack + this.decay);
    },

    addReverb: function (volume)
    {
        var convolver = this.audioContext.createConvolver();

        convolver.buffer = this.impulseResponse(this.reverbDuration, this.reverbDecay, this.reverbReverse, this.audioContext);

        volume.connect(convolver);

        convolver.connect(this.pan);
    },

    addEcho: function (volume)
    {
        var feedback = this.audioContext.createGain();
        var delay = this.audioContext.createDelay();
        var filter = this.audioContext.createBiquadFilter();

        //  Set the node values

        feedback.gain.value = this.echoFeedback;
        delay.delayTime.value = this.echoDelay;

        if (this.echoFilter)
        {
            filter.frequency.value = this.echoFilter;
        }

        //  Create the delay feedback loop (with optional filtering)

        delay.connect(feedback);

        if (this.echoFilter)
        {
            feedback.connect(filter);
            filter.connect(delay);
        }
        else
        {
            feedback.connect(delay);
        }

        //  Connect the delay node to the oscillator volume node

        volume.connect(delay);

        //  Connect the delay node to the main sound chains pan node,
        //  so that the echo effect is directed to the correct speaker

        delay.connect(this.pan);
    },

    pitchBend: function (oscillator)
    {
        var frequency = oscillator.frequency.value;

        if (!this.reverse)
        {
            //  If reverse is false, make the sound drop in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency - this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }
        else
        {
            //  If reverse is true, make the sound rise in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency + this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }

    },

    addDissonance: function ()
    {
        //  Create two more oscillators and gain nodes

        var ctx = this.audioContext;

        var d1 = ctx.createOscillator();
        var d2 = ctx.createOscillator();
        var d1Volume = ctx.createGain();
        var d2Volume = ctx.createGain();

        //  Set the volume to the `volumeValue`
        d1Volume.gain.value = this.volumeValue;
        d2Volume.gain.value = this.volumeValue;

        //  Connect the oscillators to the gain and destination nodes
        d1.connect(d1Volume);
        d2.connect(d2Volume);

        d1Volume.connect(ctx.destination);
        d2Volume.connect(ctx.destination);

        //  Set the waveform to "sawtooth" for a harsh effect
        d1.type = 'sawtooth';
        d2.type = 'sawtooth';

        //  Make the two oscillators play at frequencies above and below the main sound's frequency.
        //  Use whatever value was supplied by the `dissonance` argument
        d1.frequency.value = this.frequencyValue + this.dissonance;
        d2.frequency.value = this.frequencyValue - this.dissonance;

        //  Fade in / out, pitch bend and play the oscillators to match the main sound
        if (this.attack > 0)
        {
            this.fadeIn(d1Volume);
            this.fadeIn(d2Volume);
        }

        if (this.decay > 0)
        {
            this.fadeOut(d1Volume);
            this.fadeOut(d2Volume);
        }

        if (this.pitchBendAmount > 0)
        {
            this.pitchBend(d1);
            this.pitchBend(d2);
        }

        if (this.echo)
        {
            this.addEcho(d1Volume);
            this.addEcho(d2Volume);
        }

        if (this.reverb)
        {
            this.addReverb(d1Volume);
            this.addReverb(d2Volume);
        }

        this.play(d1);
        this.play(d2);
    },

    impulseResponse: function (duration, decay, reverse)
    {
        //  The length of the buffer.
        var length = this.audioContext.sampleRate * duration;

        //  Create an audio buffer (an empty sound container) to store the reverb effect.
        var impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);

        //  Use `getChannelData` to initialize empty arrays to store sound data for the left and right channels.
        var left = impulse.getChannelData(0);
        var right = impulse.getChannelData(1);

        //  Loop through each sample-frame and fill the channel data with random noise.
        for (var i = 0; i < length; i++)
        {
            //  Apply the reverse effect, if `reverse` is `true`.
            var n = (reverse) ? length - i : i;

            //  Fill the left and right channels with random white noise which decays exponentially.
            left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
            right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
        }

        //  Return the `impulse`.
        return impulse;
    }

});

module.exports = FX;


/***/ }),
/* 969 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Sound.Dynamic

module.exports = {

    FX: __webpack_require__(968)

};


/***/ }),
/* 970 */
/***/ (function(module, exports, __webpack_require__) {

var quickselect = __webpack_require__(250);

//  Phaser.Structs.RTree

/**
 * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.
 * It's based on an optimized R-tree data structure with bulk insertion support.
 *
 * Spatial index is a special data structure for points and rectangles that allows you to perform queries like
 * "all items within this bounding box" very efficiently (e.g. hundreds of times faster than looping over all items).
 */

function rbush (maxEntries, format)
{
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format)
    {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function ()
    {
        return this._all(this.data, []);
    },

    search: function (bbox)
    {
        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox)
    {
        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data)
    {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item)
    {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function ()
    {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn)
    {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data)
    {
        this.data = data;
        return this;
    },

    _all: function (node, result)
    {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height)
    {
        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path)
    {
        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode)
    {
        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level)
    {
        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode)
    {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M)
    {
        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M)
    {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare)
    {
        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level)
    {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path)
    {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format)
    {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem (item, items, equalsFn)
{
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox (node, toBBox)
{
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox (node, k, p, toBBox, destNode)
{
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend (a, b)
{
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX (a, b) { return a.minX - b.minX; }
function compareNodeMinY (a, b) { return a.minY - b.minY; }

function bboxArea (a) { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin (a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea (a, b)
{
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea (a, b)
{
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains (a, b)
{
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects (a, b)
{
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode (children)
{
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect (arr, left, right, n, compare)
{
    var stack = [left, right],
        mid;

    while (stack.length)
    {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

module.exports = rbush;


/***/ }),
/* 971 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var Extend = __webpack_require__(73);

/**
* A Frame is a section of a Texture.
*/
var Frame = new Class({

    initialize:

    function Frame (texture, name, sourceIndex, x, y, width, height)
    {
        /**
        * @property {Phaser.Texture} texture - The Texture this frame belongs to.
        */
        this.texture = texture;

        /**
        * @property {string} name - The name of this frame within the Texture.
        */
        this.name = name;

        this.source = texture.source[sourceIndex];

        this.sourceIndex = sourceIndex;

        /**
        * @property {number} cutX - X position within the source image to cut from.
        */
        this.cutX = x;

        /**
        * @property {number} cutY - Y position within the source image to cut from.
        */
        this.cutY = y;

        /**
        * @property {number} cutWidth - The width of the area in the source image to cut.
        */
        this.cutWidth = width;

        /**
        * @property {number} cutHeight - The height of the area in the source image to cut.
        */
        this.cutHeight = height;

        /**
        * @property {number} x - The X rendering offset of this Frame, taking trim into account.
        */
        this.x = 0;

        /**
        * @property {number} y - The Y rendering offset of this Frame, taking trim into account.
        */
        this.y = 0;

        /**
        * @property {number} width - The rendering width of this Frame, taking trim into account.
        */
        this.width = width;

        /**
        * @property {number} height - The rendering height of this Frame, taking trim into account.
        */
        this.height = height;

        /**
        * @property {number} width - The rendering width of this Frame, taking trim into account.
        */
        this.centerX = Math.floor(width / 2);

        /**
        * @property {number} height - The rendering height of this Frame, taking trim into account.
        */
        this.centerY = Math.floor(height / 2);

        /**
        * Is this frame is rotated or not in the Texture?
        * Rotation allows you to use rotated frames in texture atlas packing.
        * It has nothing to do with Sprite rotation.
        *
        * @property {boolean} rotated
        * @default
        */
        this.rotated = false;

        //  Over-rides the Renderer setting? -1 = use Renderer Setting, 0 = No rounding, 1 = Round
        this.autoRound = -1;

        /**
        * The un-modified source frame, trim and UV data.
        *
        * @private
        * @property {object} data
        */
        this.data = {
            cut: {
                x: x,
                y: y,
                w: width,
                h: height,
                r: x + width,
                b: y + height
            },
            trim: false,
            sourceSize: {
                w: width,
                h: height
            },
            spriteSourceSize: {
                x: 0,
                y: 0,
                w: width,
                h: height
            },
            uvs: {
                x0: 0,
                y0: 0,
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                x3: 0,
                y3: 0
            },
            radius: 0.5 * Math.sqrt(width * width + height * height),
            drawImage: {
                sx: x,
                sy: y,
                sWidth: width,
                sHeight: height,
                dWidth: width,
                dHeight: height
            }
        };

        this.updateUVs();
    },

    /**
    * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.
    *
    * @method Phaser.TextureFrame#setTrim
    * @param {number} actualWidth - The width of the frame before being trimmed.
    * @param {number} actualHeight - The height of the frame before being trimmed.
    * @param {number} destX - The destination X position of the trimmed frame for display.
    * @param {number} destY - The destination Y position of the trimmed frame for display.
    * @param {number} destWidth - The destination width of the trimmed frame for display.
    * @param {number} destHeight - The destination height of the trimmed frame for display.
    */
    setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)
    {
        var data = this.data;
        var ss = data.spriteSourceSize;

        //  Store actual values

        data.trim = true;

        data.sourceSize.w = actualWidth;
        data.sourceSize.h = actualHeight;

        ss.x = destX;
        ss.y = destY;
        ss.w = destWidth;
        ss.h = destHeight;

        //  Adjust properties
        this.x = destX;
        this.y = destY;

        this.width = destWidth;
        this.height = destHeight;

        this.centerX = Math.floor(destWidth / 2);
        this.centerY = Math.floor(destHeight / 2);

        this.updateUVs();

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVs
    * @private
    */
    updateUVs: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x0 = this.cutX / tw;
        uvs.y0 = this.cutY / th;

        uvs.x1 = this.cutX / tw;
        uvs.y1 = (this.cutY + this.cutHeight) / th;

        uvs.x2 = (this.cutX + this.cutWidth) / tw;
        uvs.y2 = (this.cutY + this.cutHeight) / th;

        uvs.x3 = (this.cutX + this.cutWidth) / tw;
        uvs.y3 = this.cutY / th;

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVsInverted
    * @private
    */
    updateUVsInverted: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x3 = (this.cutX + this.cutHeight) / tw;
        uvs.y3 = (this.cutY + this.cutWidth) / th;

        uvs.x2 = this.cutX / tw;
        uvs.y2 = (this.cutY + this.cutWidth) / th;
        
        uvs.x1 = this.cutX / tw;
        uvs.y1 = this.cutY / th;
        
        uvs.x0 = (this.cutX + this.cutHeight) / tw;
        uvs.y0 = this.cutY / th;

        return this;
    },

    clone: function ()
    {
        var clone = new Frame(this.texture, this.name, this.sourceIndex);

        clone.cutX = this.cutX;
        clone.cutY = this.cutY;
        clone.cutWidth = this.cutWidth;
        clone.cutHeight = this.cutHeight;

        clone.x = this.x;
        clone.y = this.y;

        clone.width = this.width;
        clone.height = this.height;

        clone.centerX = this.centerX;
        clone.centerY = this.centerY;

        clone.rotated = this.rotated;

        clone.data = Extend(true, clone.data, this.data);

        clone.updateUVs();

        return clone;
    },

    destroy: function ()
    {
    },

    /**
    * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realWidth
    * @property {any} realWidth
    */
    realWidth: {

        get: function ()
        {
            return this.data.sourceSize.w;
        }

    },

    /**
    * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realHeight
    * @property {any} realHeight
    */
    realHeight: {

        get: function ()
        {
            return this.data.sourceSize.h;
        }

    },

    /**
    * UVs
    *
    * @name Phaser.TextureFrame#uvs
    * @property {Object} uvs
    */
    uvs: {

        get: function ()
        {
            return this.data.uvs;
        }

    },

    /**
    * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)
    * @name Phaser.TextureFrame#radius
    * @property {number} radius
    */
    radius: {

        get: function ()
        {
            return this.data.radius;
        }

    },

    /**
    * Is the Frame trimmed?
    * @name Phaser.TextureFrame#trimmed
    * @property {boolean} trimmed
    */
    trimmed: {

        get: function ()
        {
            return this.data.trim;
        }

    },

    /**
    * Canvas Draw Image data
    *
    * @name Phaser.TextureFrame#canvasData
    * @property {Object} canvasData
    */
    canvasData: {

        get: function ()
        {
            return this.data.drawImage;
        }

    }

});

module.exports = Frame;


/***/ }),
/* 972 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var Frame = __webpack_require__(971);
var TextureSource = __webpack_require__(974);

/**
* A Texture consists of a source, usually an Image from the Cache, or a Canvas, and a collection
* of Frames. The Frames represent the different areas of the Texture. For example a texture atlas
* may have many Frames, one for each element within the atlas. Where-as a single image would have
* just one frame, that encompasses the whole image.
*
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*/
var Texture = new Class({

    initialize:

    function Texture (manager, key, source, width, height)
    {
        this.manager = manager;

        if (!Array.isArray(source))
        {
            source = [ source ];
        }

        this.key = key;

        /**
        * The source that is used to create the texture.
        * Usually an Image, but can also be a Canvas.
        */
        this.source = [];

        this.frames = {};

        this.firstFrame = '__BASE';

        this.frameTotal = 0;

        //  Load the Sources
        for (var i = 0; i < source.length; i++)
        {
            this.source.push(new TextureSource(this, source[i], width, height));
        }
    },

    add: function (name, sourceIndex, x, y, width, height)
    {
        var frame = new Frame(this, name, sourceIndex, x, y, width, height);

        this.frames[name] = frame;

        //  Set the first frame of the Texture (other than __BASE)
        //  This is used to ensure we don't spam the display with entire
        //  atlases of sprite sheets, but instead just the first frame of them
        //  should the dev incorrectly specify the frame index
        if (this.frameTotal === 1)
        {
            this.firstFrame = name;
        }

        this.frameTotal++;

        return frame;
    },

    has: function (name)
    {
        return (this.frames[name]);
    },

    get: function (name)
    {
        if (name === undefined || name === null)
        {
            name = (this.frameTotal === 1) ? '__BASE' : this.firstFrame;
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'];
        }
        else
        {
            return frame;
        }
    },

    getFrameNames: function (includeBase)
    {
        if (includeBase === undefined) { includeBase = false; }

        var out = Object.keys(this.frames);

        if (!includeBase)
        {
            var idx = out.indexOf('__BASE');

            if (idx !== -1)
            {
                out.splice(idx, 1);
            }
        }

        return out;
    },

    getSourceImage: function (name)
    {
        if (name === undefined || name === null || this.frameTotal === 1)
        {
            name = '__BASE';
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'].source.image;
        }
        else
        {
            return frame.source.image;
        }
    },

    setFilter: function (filterMode)
    {
        for (var i = 0; i < this.source.length; i++)
        {
            this.source[i].setFilter(filterMode);
        }
    },

    destroy: function ()
    {
    }

});

module.exports = Texture;


/***/ }),
/* 973 */
/***/ (function(module, exports, __webpack_require__) {


var CanvasPool = __webpack_require__(15);
var Class = __webpack_require__(0);
var Color = __webpack_require__(33);
var GenerateTexture = __webpack_require__(126);
var GetValue = __webpack_require__(4);
var Parser = __webpack_require__(984);
var Texture = __webpack_require__(972);

/**
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* Access it via `scene.textures`.
*/
var TextureManager = new Class({

    initialize:

    function TextureManager (game)
    {
        this.game = game;

        this.list = {};

        this._tempCanvas = CanvasPool.create2D(this, 1, 1);
        this._tempContext = this._tempCanvas.getContext('2d');
    },

    boot: function ()
    {
        this.addBase64('__DEFAULT', this.game.config.defaultImage);
        this.addBase64('__MISSING', this.game.config.missingImage);
    },

    addBase64: function (key, data)
    {
        var _this = this;
        var image = new Image();

        image.onload = function ()
        {
            var texture = _this.create(key, image);
        
            Parser.Image(texture, 0);
        };

        image.src = data;
    },

    addImage: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Image(texture, 0);

        return texture;
    },

    generate: function (key, config)
    {
        var canvas = CanvasPool.create(this, 1, 1);

        config.canvas = canvas;

        GenerateTexture(config);

        return this.addCanvas(key, canvas);
    },

    createCanvas: function (key, width, height)
    {
        if (width === undefined) { width = 256; }
        if (height === undefined) { height = 256; }

        var canvas = CanvasPool.create(this, width, height);

        return this.addCanvas(key, canvas);
    },

    addCanvas: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Canvas(texture, 0);

        return texture;
    },

    addAtlas: function (key, source, data)
    {
        //  Is it a Hash or an Array?

        if (Array.isArray(data.frames))
        {
            return this.addAtlasJSONArray(key, source, data);
        }
        else
        {
            return this.addAtlasJSONHash(key, source, data);
        }
    },

    addAtlasJSONArray: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONArray(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONArray(texture, 0, data);
        }

        return texture;
    },

    addAtlasJSONHash: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONHash(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONHash(texture, 0, data);
        }

        return texture;
    },

    addUnityAtlas: function (key, source, data)
    {
        var texture = this.create(key, source);

        Parser.UnityYAML(texture, 0, data);

        return texture;
    },

    /**
     * [addSpriteSheet description]
     * @param {[type]} key    [description]
     * @param {[type]} source [description]
     * @param {[type]} config [description]
     * @param {number} config.frameWidth - The fixed width of each frame.
     * @param {number} [config.frameHeight] - The fixed height of each frame. If not set it will use the frameWidth as the height.
     * @param {number} [config.startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
     * @param {number} [config.endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
     * @param {number} [config.margin=0] - If the frames have been drawn with a margin, specify the amount here.
     * @param {number} [config.spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
     */
    addSpriteSheet: function (key, source, config)
    {
        var texture = this.create(key, source);

        var width = texture.source[0].width;
        var height = texture.source[0].height;

        Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);

        return texture;
    },

    addSpriteSheetFromAtlas: function (key, config)
    {
        var atlasKey = GetValue(config, 'atlas', null);
        var atlasFrame = GetValue(config, 'frame', null);

        if (!atlasKey || !atlasFrame)
        {
            return;
        }

        var atlas = this.get(atlasKey);
        var sheet = atlas.get(atlasFrame);

        if (sheet)
        {
            var texture = this.create(key, sheet.source.image);

            // {
            //     "filename": "explosion",
            //     "frame": {"x":2,"y":2,"w":319,"h":312}, = cutX, Y, W, H
            //     "rotated": false,
            //     "trimmed": true,
            //     "spriteSourceSize": {"x":1,"y":6,"w":319,"h":312},
            //     "sourceSize": {"w":320,"h":320},
            //     "pivot": {"x":0.5,"y":0.5}
            // },

            //  If trimmed we need to help the parser adjust

            console.log(sheet);

            if (sheet.trimmed)
            {
                Parser.SpriteSheetFromAtlas(texture, sheet, config);
            }
            else
            {
                Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);
            }

            return texture;
        }
    },

    addAtlasStarlingXML: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.StarlingXML(texture, i, data[i]);
            }
        }
        else
        {
            Parser.StarlingXML(texture, 0, data);
        }

        return texture;
    },

    addAtlasPyxel: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.Pyxel(texture, i, data[i]);
            }
        }
        else
        {
            Parser.Pyxel(texture, 0, data);
        }

        return texture;
    },

    create: function (key, source, width, height)
    {
        var texture = new Texture(this, key, source, width, height);

        this.list[key] = texture;

        return texture;
    },

    exists: function (key)
    {
        return (this.list.hasOwnProperty(key));
    },

    get: function (key)
    {
        if (key === undefined) { key = '__DEFAULT'; }

        if (this.list[key])
        {
            return this.list[key];
        }
        else
        {
            return this.list['__MISSING'];
        }
    },

    cloneFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame).clone();
        }
    },

    getFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame);
        }
    },

    getPixel: function (x, y, key, frame)
    {
        var textureFrame = this.getFrame(key, frame);

        if (textureFrame)
        {
            var source = textureFrame.source.image;

            if (x >= 0 && x <= source.width && y >= 0 && y <= source.height)
            {
                x += textureFrame.cutX;
                y += textureFrame.cutY;

                // if (textureFrame.trimmed)
                // {
                    // x -= this.sprite.texture.trim.x;
                    // y -= this.sprite.texture.trim.y;
                // }

                var context = this._tempContext;

                context.clearRect(0, 0, 1, 1);
                context.drawImage(source, x, y, 1, 1, 0, 0, 1, 1);

                var rgb = context.getImageData(0, 0, 1, 1);

                return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
            }
        }

        return null;
    },

    setTexture: function (gameObject, key, frame)
    {
        if (this.list[key])
        {
            gameObject.texture = this.list[key];
            gameObject.frame = gameObject.texture.get(frame);
        }

        return gameObject;
    },

    /**
    * Passes all Textures to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var texture in this.list)
        {
            args[0] = this.list[texture];

            callback.apply(thisArg, args);
        }
    }

});

module.exports = TextureManager;


/***/ }),
/* 974 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var CONST = __webpack_require__(9);
var IsSizePowerOfTwo = __webpack_require__(108);
var ScaleModes = __webpack_require__(35);

var TextureSource = new Class({

    initialize:

    function TextureSource (texture, source, width, height)
    {
        var game = texture.manager.game;

        this.texture = texture;

        this.image = source;

        this.compressionAlgorithm = null;

        this.resolution = 1;
        
        this.width = width || source.naturalWidth || source.width || 0;

        this.height = height || source.naturalHeight || source.height || 0;

        this.scaleMode = ScaleModes.DEFAULT;

        this.isCanvas = (source instanceof HTMLCanvasElement);

        this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);

        this.init(game);
    },

    init: function (game)
    {
        this.glTexture = null;

        if (game.config.renderType === CONST.WEBGL)
        {
            game.renderer.createTexture(this, this.width, this.height);
        }

        if (game.config.pixelArt)
        {
            this.setFilter(1);
        }
    },

    setFilter: function (filterMode)
    {
        var game = this.texture.manager.game;

        if (game.config.renderType === CONST.WEBGL)
        {
            game.renderer.setTextureFilterMode(this.glTexture, filterMode);
        }
    }

});

module.exports = TextureSource;


/***/ }),
/* 975 */
/***/ (function(module, exports) {

var Canvas = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = Canvas;


/***/ }),
/* 976 */
/***/ (function(module, exports) {

var Image = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = Image;


/***/ }),
/* 977 */
/***/ (function(module, exports) {

var JSONArray = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Array given, missing \'frames\' array');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed array
    var frames = json['frames'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        var src = frames[i];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
        }
    }

    return texture;
};

module.exports = JSONArray;


/***/ }),
/* 978 */
/***/ (function(module, exports) {

var JSONHash = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Hash given, missing \'frames\' Object');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed Object
    var frames = json['frames'];
    var newFrame;

    for (var key in frames)
    {
        var src = frames[key];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
        }
    }

    return texture;
};

module.exports = JSONHash;


/***/ }),
/* 979 */
/***/ (function(module, exports) {

var Pyxel = function (texture, json)
{
    //  Malformed? There are a few keys to check here.
    var signature = [ 'layers', 'tilewidth', 'tileheight', 'tileswide', 'tileshigh' ];

    signature.forEach(function (key)
    {
        if (!json[key])
        {
            // console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + key + '" key.');
            // console.log(json);
            return;
        }
    });

    // For this purpose, I only care about parsing tilemaps with a single layer.
    if (json['layers'].length !== 1)
    {
        // console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.');
        // console.log(json);
        return;
    }

    var data = new Phaser.FrameData();

    var tileheight = json['tileheight'];
    var tilewidth = json['tilewidth'];

    var frames = json['layers'][0]['tiles'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        newFrame = data.addFrame(new Phaser.Frame(
            i,
            frames[i].x,
            frames[i].y,
            tilewidth,
            tileheight,
            "frame_" + i  // No names are included in pyxel tilemap data.
        ));

        // No trim data is included.
        newFrame.setTrim(false);
    }

    return data;
};

module.exports = Pyxel;


/***/ }),
/* 980 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(4);

var SpriteSheet = function (texture, sourceIndex, x, y, width, height, config)
{
    var frameWidth = GetValue(config, 'frameWidth', null);
    var frameHeight = GetValue(config, 'frameHeight', frameWidth);

    //  If missing we can't proceed
    if (frameWidth === null)
    {
        throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.');
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    var startFrame = GetValue(config, 'startFrame', 0);
    var endFrame = GetValue(config, 'endFrame', -1);
    var margin = GetValue(config, 'margin', 0);
    var spacing = GetValue(config, 'spacing', 0);

    var row = Math.floor((width - margin) / (frameWidth + spacing));
    var column = Math.floor((height - margin) / (frameHeight + spacing));
    var total = row * column;

    if (startFrame > total || startFrame < -total)
    {
        startFrame = 0;
    }

    if (startFrame < 0)
    {
        //  Allow negative skipframes.
        startFrame = total + startFrame;
    }

    if (endFrame !== -1)
    {
        total = startFrame + (endFrame + 1);
    }

    var fx = margin;
    var fy = margin;
    var ax = 0;
    var ay = 0;

    for (var i = 0; i < total; i++)
    {
        ax = 0;
        ay = 0;

        var w = fx + frameWidth;
        var h = fy + frameHeight;

        if (w > width)
        {
            ax = w - width;
        }

        if (h > height)
        {
            ay = h - height;
        }

        texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);

        fx += frameWidth + spacing;

        if (fx + frameWidth > width)
        {
            fx = margin;
            fy += frameHeight + spacing;
        }
    }

    return texture;
};

module.exports = SpriteSheet;


/***/ }),
/* 981 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(4);

var SpriteSheetFromAtlas = function (texture, frame, config)
{
    var frameWidth = GetValue(config, 'frameWidth', null);
    var frameHeight = GetValue(config, 'frameHeight', frameWidth);

    //  If missing we can't proceed
    if (!frameWidth)
    {
        throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.');
    }

    //  Add in a __BASE entry (for the entire atlas)
    // var source = texture.source[0];
    // texture.add('__BASE', 0, 0, 0, source.width, source.height);

    var startFrame = GetValue(config, 'startFrame', 0);
    var endFrame = GetValue(config, 'endFrame', -1);
    var margin = GetValue(config, 'margin', 0);
    var spacing = GetValue(config, 'spacing', 0);

    var x = frame.cutX;
    var y = frame.cutY;
    var cutWidth = frame.cutWidth;
    var cutHeight = frame.cutHeight;
    var sheetWidth = frame.realWidth;
    var sheetHeight = frame.realHeight;

    var row = Math.floor((sheetWidth - margin) / (frameWidth + spacing));
    var column = Math.floor((sheetHeight - margin) / (frameHeight + spacing));
    var total = row * column;

    console.log('split sheet into rows/cols:', row, column, 'total frames:', total);

    if (startFrame > total || startFrame < -total)
    {
        startFrame = 0;
    }

    if (startFrame < 0)
    {
        //  Allow negative skipframes.
        startFrame = total + startFrame;
    }

    if (endFrame !== -1)
    {
        total = startFrame + (endFrame + 1);
    }

    var fx = margin;
    var fy = margin;
    var ax = 0;
    var ay = 0;
    var sheetFrame;

    for (var i = 0; i < total; i++)
    {
        ax = 0;
        ay = 0;

        var w = fx + frameWidth;
        var h = fy + frameHeight;

        if (w > width)
        {
            ax = w - width;
        }

        if (h > height)
        {
            ay = h - height;
        }

        sheetFrame = texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);

        // sheetFrame.setTrim(sheetWidth, sheetHeight, )

        // setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)


        fx += frameWidth + spacing;

        if (fx + frameWidth > width)
        {
            fx = margin;
            fy += frameHeight + spacing;
        }
    }

    return texture;
};

module.exports = SpriteSheetFromAtlas;


/***/ }),
/* 982 */
/***/ (function(module, exports) {

var StarlingXML = function (texture, xml)
{
    //  Malformed?
    if (!xml.getElementsByTagName('TextureAtlas'))
    {
        // console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
        return;
    }

    //  Let's create some frames then
    var data = new Phaser.FrameData();
    var frames = xml.getElementsByTagName('SubTexture');
    var newFrame;

    var name;
    var frame;
    var x;
    var y;
    var width;
    var height;
    var frameX;
    var frameY;
    var frameWidth;
    var frameHeight;

    for (var i = 0; i < frames.length; i++)
    {
        frame = frames[i].attributes;

        name = frame.name.value;
        x = parseInt(frame.x.value, 10);
        y = parseInt(frame.y.value, 10);
        width = parseInt(frame.width.value, 10);
        height = parseInt(frame.height.value, 10);

        frameX = null;
        frameY = null;

        if (frame.frameX)
        {
            frameX = Math.abs(parseInt(frame.frameX.value, 10));
            frameY = Math.abs(parseInt(frame.frameY.value, 10));
            frameWidth = parseInt(frame.frameWidth.value, 10);
            frameHeight = parseInt(frame.frameHeight.value, 10);
        }

        newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name));

        //  Trimmed?
        if (frameX !== null || frameY !== null)
        {
            newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);
        }
    }

    return data;

};

module.exports = StarlingXML;


/***/ }),
/* 983 */
/***/ (function(module, exports) {

/*
Example data:

TextureImporter:
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  spriteSheet:
    sprites:
    - name: asteroids_0
      rect:
        serializedVersion: 2
        x: 5
        y: 328
        width: 65
        height: 82
      alignment: 0
      pivot: {x: 0, y: 0}
      border: {x: 0, y: 0, z: 0, w: 0}
    - name: asteroids_1
      rect:
        serializedVersion: 2
        x: 80
        y: 322
        width: 53
        height: 88
      alignment: 0
      pivot: {x: 0, y: 0}
      border: {x: 0, y: 0, z: 0, w: 0}
  spritePackingTag: Asteroids
*/

var imageHeight = 0;

var addFrame = function (texture, sourceIndex, name, frame)
{
    //  The frame values are the exact coordinates to cut the frame out of the atlas from

    var y = imageHeight - frame.y - frame.height;

    var newFrame = texture.add(name, sourceIndex, frame.x, y, frame.width, frame.height);

    // console.log('name', name, 'rect', frame.x, y, frame.width, frame.height);

    //  These are the original (non-trimmed) sprite values
    /*
    if (src.trimmed)
    {
        newFrame.setTrim(
            src.sourceSize.w,
            src.sourceSize.h,
            src.spriteSourceSize.x,
            src.spriteSourceSize.y,
            src.spriteSourceSize.w,
            src.spriteSourceSize.h
        );
    }
    */
};

// https://docs.unity3d.com/ScriptReference/SpriteMetaData.html

var UnityYAML = function (texture, sourceIndex, yaml)
{
    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    imageHeight = source.height;

    var data = yaml.split('\n');

    var lineRegExp = /^[ ]*(- )*(\w+)+[: ]+(.*)/;

    var prevSprite = '';
    var currentSprite = '';
    var rect = { x: 0, y: 0, width: 0, height: 0 };
    var pivot = { x: 0, y: 0 };
    var border = { x: 0, y: 0, z: 0, w: 0 };

    for (var i = 0; i < data.length; i++)
    {
        var results = data[i].match(lineRegExp);

        if (!results)
        {
            continue;
        }

        var isList = (results[1] === '- ');
        var key = results[2];
        var value = results[3];

        if (isList)
        {
            if (currentSprite !== prevSprite)
            {
                addFrame(texture, sourceIndex, currentSprite, rect);

                prevSprite = currentSprite;
            }

            rect = { x: 0, y: 0, width: 0, height: 0 };
        }

        if (key === 'name')
        {
            //  Start new list
            currentSprite = value;
            continue;
        }

        switch (key)
        {
            case 'x':
            case 'y':
            case 'width':
            case 'height':
                rect[key] = parseInt(value, 10);
                break;

            case 'pivot':
                pivot = eval('var obj = ' + value);
                break;

            case 'border':
                border = eval('var obj = ' + value);
                break;
        }
    }

    if (currentSprite !== prevSprite)
    {
        addFrame(texture, sourceIndex, currentSprite, rect);
    }

    return texture;
};

module.exports = UnityYAML;


/***/ }),
/* 984 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = {
    Canvas: __webpack_require__(975),
    Image: __webpack_require__(976),
    JSONArray: __webpack_require__(977),
    JSONHash: __webpack_require__(978),
    Pyxel: __webpack_require__(979),
    SpriteSheet: __webpack_require__(980),
    SpriteSheetFromAtlas: __webpack_require__(981),
    StarlingXML: __webpack_require__(982),
    UnityYAML: __webpack_require__(983)
};


/***/ }),
/* 985 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var TimerEvent = __webpack_require__(986);

var Clock = new Class({

    initialize:

    function Clock (scene)
    {
        this.scene = scene;

        this.now = Date.now();

        //  Scale the delta time coming into the Clock by this factor
        //  which then influences anything using this Clock for calculations, like TimerEvents
        this.timeScale = 1;

        this.paused = false;

        this._active = [];
        this._pendingInsertion = [];
        this._pendingRemoval = [];
    },

    addEvent: function (config)
    {
        var event = new TimerEvent(config);

        this._pendingInsertion.push(event);

        return event;
    },

    delayedCall: function (delay, callback, args, callbackScope)
    {
        return this.addEvent({ delay: delay, callback: callback, args: args, callbackScope: callbackScope });
    },

    clearPendingEvents: function ()
    {
        this._pendingInsertion = [];
    },

    removeAllEvents: function ()
    {
        this._pendingRemoval = this._pendingRemoval.concat(this._active);

        return this;
    },

    begin: function ()
    {
        var toRemove = this._pendingRemoval.length;
        var toInsert = this._pendingInsertion.length;

        if (toRemove === 0 && toInsert === 0)
        {
            //  Quick bail
            return;
        }

        var i;
        var event;

        //  Delete old events
        for (i = 0; i < toRemove; i++)
        {
            event = this._pendingRemoval[i];

            var index = this._active.indexOf(event);

            if (index > -1)
            {
                this._active.splice(index, 1);
            }

            //  Pool them?
            event.destroy();
        }

        for (i = 0; i < toInsert; i++)
        {
            event = this._pendingInsertion[i];

            event.elapsed = event.startAt * event.timeScale;

            this._active.push(event);
        }

        //  Clear the lists
        this._pendingRemoval.length = 0;
        this._pendingInsertion.length = 0;
    },

    update: function (time, delta)
    {
        this.now = time;

        if (this.paused)
        {
            return;
        }

        delta * this.timeScale;

        for (var i = 0; i < this._active.length; i++)
        {
            var event = this._active[i];

            if (event.paused)
            {
                continue;
            }

            //  Use delta time to increase elapsed.
            //  Avoids needing to adjust for pause / resume.
            //  Automatically smoothed by TimeStep class.
            //  In testing accurate to +- 1ms!
            event.elapsed += delta * event.timeScale;

            if (event.elapsed >= event.delay)
            {
                var remainder = event.elapsed - event.delay;

                //  Limit it, in case it's checked in the callback
                event.elapsed = event.delay;

                //  Process the event
                if (!event.hasDispatched && event.callback)
                {
                    event.hasDispatched = true;
                    event.callback.apply(event.callbackScope, event.args);
                }

                if (event.repeatCount > 0)
                {
                    event.repeatCount--;

                    event.elapsed = remainder;
                    event.hasDispatched = false;
                }
                else
                {
                    this._pendingRemoval.push(event);
                }
            }
        }
    },

    //  Scene that owns this Clock is shutting down
    shutdown: function ()
    {
        var i;

        for (i = 0; i < this._pendingInsertion.length; i++)
        {
            this._pendingInsertion[i].destroy();
        }

        for (i = 0; i < this._active.length; i++)
        {
            this._active[i].destroy();
        }

        for (i = 0; i < this._pendingRemoval.length; i++)
        {
            this._pendingRemoval[i].destroy();
        }

        this._active.length = 0;
        this._pendingRemoval.length = 0;
        this._pendingInsertion.length = 0;
    },

    //  Game level nuke
    destroy: function ()
    {
        this.shutdown();

        this.scene = undefined;
    }

});

module.exports = Clock;


/***/ }),
/* 986 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GetFastValue = __webpack_require__(11);

var TimerEvent = new Class({

    initialize:

    function TimerEvent (config)
    {
        /**
        * @property {number} delay - The delay in ms at which this TimerEvent fires.
        * @readOnly
        */
        this.delay = 0;

        /**
        * @property {number} repeat - The total number of times this TimerEvent will repeat before finishing.
        * @readOnly
        */
        this.repeat = 0;

        /**
        * @property {number} repeatCount - If repeating this contains the current repeat count.
        */
        this.repeatCount = 0;

        /**
        * @property {boolean} loop - True if this TimerEvent loops, otherwise false.
        * @readOnly
        */
        this.loop = false;

        /**
        * @property {function} callback - The callback that will be called when the TimerEvent occurs.
        */
        this.callback;

        /**
        * @property {object} callbackContext - The context in which the callback will be called.
        */
        this.callbackScope;

        /**
        * @property {any[]} arguments - Additional arguments to be passed to the callback.
        */
        this.args;

        //  Scale the time causing this TimerEvent to update
        this.timeScale = 1;

        //  Start this many MS into the elapsed (useful if you want a long duration with repeat, but for the first loop to fire quickly)
        this.startAt = 0;

        this.elapsed = 0;

        this.paused = false;

        this.hasDispatched = false;

        this.reset(config);
    },

    reset: function (config)
    {
        this.delay = GetFastValue(config, 'delay', 0);

        //  Can also be set to -1 for an infinite loop (same as setting loop: true)
        this.repeat = GetFastValue(config, 'repeat', 0);

        this.loop = GetFastValue(config, 'loop', false);

        this.callback = GetFastValue(config, 'callback', undefined);

        this.callbackScope = GetFastValue(config, 'callbackScope', this.callback);

        this.args = GetFastValue(config, 'args', []);

        this.timeScale = GetFastValue(config, 'timeScale', 1);

        this.startAt = GetFastValue(config, 'startAt', 0);

        this.paused = GetFastValue(config, 'paused', false);

        this.elapsed = 0;
        this.hasDispatched = false;
        this.repeatCount = (this.repeat === -1 || this.loop) ? 999999999999 : this.repeat;

        return this;
    },

    //  Gets the progress of the current iteration, not factoring in repeats
    getProgress: function ()
    {
        return (this.elapsed / this.delay);
    },

    //  Gets the progress of the timer overall, factoring in repeats.
    getOverallProgress: function ()
    {
        if (this.repeat > 0)
        {
            var totalDuration = this.delay + (this.delay * this.repeat);
            var totalElapsed = this.elapsed + (this.delay * (this.repeat - this.repeatCount));

            return (totalElapsed / totalDuration);
        }
        else
        {
            return this.getProgress();
        }
    },

    getRepeatCount: function ()
    {
        return this.repeatCount;
    },

    getElapsed: function ()
    {
        return this.elapsed;
    },

    getElapsedSeconds: function ()
    {
        return this.elapsed * 0.001;
    },

    remove: function (dispatchCallback)
    {
        if (dispatchCallback === undefined) { dispatchCallback = false; }

        this.elapsed = this.delay;

        this.hasDispatched = !!dispatchCallback;

        this.repeatCount = 0;
    },

    //  Called internaly, private
    destroy: function ()
    {
        this.callback = undefined;
        this.callbackScope = undefined;
        this.args.length = 0;
    }

});

module.exports = TimerEvent;


/***/ }),
/* 987 */
/***/ (function(module, exports, __webpack_require__) {

var RESERVED = __webpack_require__(1005);

var GetProps = function (config)
{
    var key;
    var keys = [];

    //  First see if we have a props object

    if (config.hasOwnProperty('props'))
    {
        for (key in config.props)
        {
            //  Skip any property that starts with an underscore
            if (key.substr(0, 1) !== '_')
            {
                keys.push({ key: key, value: config.props[key] });
            }
        }
    }
    else
    {
        for (key in config)
        {
            //  Skip any property that is in the ReservedProps list or that starts with an underscore
            if (RESERVED.indexOf(key) === -1 && key.substr(0, 1) !== '_')
            {
                keys.push({ key: key, value: config[key] });
            }
        }
    }

    return keys;
};

module.exports = GetProps;


/***/ }),
/* 988 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(4);

var GetTweens = function (config)
{
    var tweens = GetValue(config, 'tweens', null);

    if (tweens === null)
    {
        return [];
    }
    else if (typeof tweens === 'function')
    {
        tweens = tweens.call();
    }

    if (!Array.isArray(tweens))
    {
        tweens = [ tweens ];
    }

    return tweens;
};

module.exports = GetTweens;


/***/ }),
/* 989 */
/***/ (function(module, exports) {

function hasGetStart (def)
{
    return (!!def.getStart && typeof def.getStart === 'function');
}

function hasGetEnd (def)
{
    return (!!def.getEnd && typeof def.getEnd === 'function');
}

function hasGetters (def)
{
    return hasGetStart(def) || hasGetEnd(def);
}

var GetValueOp = function (key, propertyValue)
{
    var callbacks;

    //  The returned value sets what the property will be at the END of the Tween (usually called at the start of the Tween)
    var getEnd = function (target, key, value) { return value; };

    //  The returned value sets what the property will be at the START of the Tween (usually called at the end of the Tween)
    var getStart = function (target, key, value) { return value; };

    var t = typeof(propertyValue);

    if (t === 'number')
    {
        // props: {
        //     x: 400,
        //     y: 300
        // }

        getEnd = function ()
        {
            return propertyValue;
        };
    }
    else if (t === 'string')
    {
        // props: {
        //     x: '+=400',
        //     y: '-=300',
        //     z: '*=2',
        //     w: '/=2'
        // }

        var op = propertyValue[0];
        var num = parseFloat(propertyValue.substr(2));

        switch (op)
        {
            case '+':
                getEnd = function (target, key, value)
                {
                    return value + num;
                };
                break;

            case '-':
                getEnd = function (target, key, value)
                {
                    return value - num;
                };
                break;

            case '*':
                getEnd = function (target, key, value)
                {
                    return value * num;
                };
                break;

            case '/':
                getEnd = function (target, key, value)
                {
                    return value / num;
                };
                break;

            default:
                getEnd = function ()
                {
                    return parseFloat(propertyValue);
                };
        }
    }
    else if (t === 'function')
    {
        //  The same as setting just the getEnd function and no getStart

        // props: {
        //     x: function (target, key, value) { return value + 50); },
        // }

        getEnd = propertyValue;
    }
    else if (t === 'object' && hasGetters(propertyValue))
    {
        /*
        x: {
            //  Called at the start of the Tween. The returned value sets what the property will be at the END of the Tween.
            getEnd: function (target, key, value)
            {
                return value;
            },

            //  Called at the end of the Tween. The returned value sets what the property will be at the START of the Tween.
            getStart: function (target, key, value)
            {
                return value;
            }
        }
        */

        if (hasGetEnd(propertyValue))
        {
            getEnd = propertyValue.getEnd;
        }

        if (hasGetStart(propertyValue))
        {
            getStart = propertyValue.getStart;
        }
    }
    else if (propertyValue.hasOwnProperty('value'))
    {
        //  Value may still be a string, function or a number
        // props: {
        //     x: { value: 400, ... },
        //     y: { value: 300, ... }
        // }

        callbacks = GetValueOp(key, propertyValue.value);
    }

    //  If callback not set by the else if block above then set it here and return it
    if (!callbacks)
    {
        callbacks = {
            getEnd: getEnd,
            getStart: getStart
        };
    }

    return callbacks;
};

module.exports = GetValueOp;


/***/ }),
/* 990 */
/***/ (function(module, exports, __webpack_require__) {

var Clone = __webpack_require__(72);
var Defaults = __webpack_require__(238);
var GetBoolean = __webpack_require__(235);
var GetEaseFunction = __webpack_require__(113);
var GetNewValue = __webpack_require__(236);
var GetTargets = __webpack_require__(237);
var GetTweens = __webpack_require__(988);
var GetValue = __webpack_require__(4);
var GetAdvancedValue = __webpack_require__(7);
var Timeline = __webpack_require__(1004);
var TweenBuilder = __webpack_require__(114);

var TimelineBuilder = function (manager, config)
{
    var timeline = new Timeline(manager);

    var tweens = GetTweens(config);

    if (tweens.length === 0)
    {
        timeline.paused = true;

        return timeline;
    }

    var defaults = Clone(Defaults);

    defaults.targets = GetTargets(config);

    //  totalDuration: If specified each tween in the Timeline is given an equal portion of the totalDuration

    var totalDuration = GetAdvancedValue(config, 'totalDuration', 0);

    if (totalDuration > 0)
    {
        defaults.duration = Math.floor(totalDuration / tweens.length);
    }
    else
    {
        defaults.duration = GetNewValue(config, 'duration', defaults.duration);
    }

    defaults.delay = GetNewValue(config, 'delay', defaults.delay);
    defaults.easeParams = GetValue(config, 'easeParams', defaults.easeParams);
    defaults.ease = GetEaseFunction(GetValue(config, 'ease', defaults.ease), defaults.easeParams);
    defaults.hold = GetNewValue(config, 'hold', defaults.hold);
    defaults.repeat = GetNewValue(config, 'repeat', defaults.repeat);
    defaults.repeatDelay = GetNewValue(config, 'repeatDelay', defaults.repeatDelay);
    defaults.yoyo = GetBoolean(config, 'yoyo', defaults.yoyo);
    defaults.flipX = GetBoolean(config, 'flipX', defaults.flipX);
    defaults.flipY = GetBoolean(config, 'flipY', defaults.flipY);

    //  Create the Tweens
    for (var i = 0; i < tweens.length; i++)
    {
        timeline.queue(TweenBuilder(timeline, tweens[i], defaults));
    }

    timeline.completeDelay = GetAdvancedValue(config, 'completeDelay', 0);
    timeline.loop = Math.round(GetAdvancedValue(config, 'loop', 0));
    timeline.loopDelay = Math.round(GetAdvancedValue(config, 'loopDelay', 0));
    timeline.paused = GetBoolean(config, 'paused', false);
    timeline.useFrames = GetBoolean(config, 'useFrames', false);

    //  Callbacks

    var scope = GetValue(config, 'callbackScope', timeline);

    var timelineArray = [ timeline ];

    var onStart = GetValue(config, 'onStart', false);

    //  The Start of the Timeline
    if (onStart)
    {
        var onStartScope = GetValue(config, 'onStartScope', scope);
        var onStartParams = GetValue(config, 'onStartParams', []);

        timeline.setCallback('onStart', onStart, timelineArray.concat(onStartParams), onStartScope);
    }

    var onUpdate = GetValue(config, 'onUpdate', false);

    //  Every time the Timeline updates (regardless which Tweens are running)
    if (onUpdate)
    {
        var onUpdateScope = GetValue(config, 'onUpdateScope', scope);
        var onUpdateParams = GetValue(config, 'onUpdateParams', []);

        timeline.setCallback('onUpdate', onUpdate, timelineArray.concat(onUpdateParams), onUpdateScope);
    }

    var onLoop = GetValue(config, 'onLoop', false);

    //  Called when the whole Timeline loops
    if (onLoop)
    {
        var onLoopScope = GetValue(config, 'onLoopScope', scope);
        var onLoopParams = GetValue(config, 'onLoopParams', []);

        timeline.setCallback('onLoop', onLoop, timelineArray.concat(onLoopParams), onLoopScope);
    }

    var onYoyo = GetValue(config, 'onYoyo', false);

    //  Called when a Timeline yoyos
    if (onYoyo)
    {
        var onYoyoScope = GetValue(config, 'onYoyoScope', scope);
        var onYoyoParams = GetValue(config, 'onYoyoParams', []);

        timeline.setCallback('onYoyo', onYoyo, timelineArray.concat(null, onYoyoParams), onYoyoScope);
    }

    var onComplete = GetValue(config, 'onComplete', false);

    //  Called when the Timeline completes, after the completeDelay, etc.
    if (onComplete)
    {
        var onCompleteScope = GetValue(config, 'onCompleteScope', scope);
        var onCompleteParams = GetValue(config, 'onCompleteParams', []);

        timeline.setCallback('onComplete', onComplete, timelineArray.concat(onCompleteParams), onCompleteScope);
    }

    return timeline;
};

module.exports = TimelineBuilder;


/***/ }),
/* 991 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(0);
var TimelineBuilder = __webpack_require__(990);
var TweenBuilder = __webpack_require__(114);
var TWEEN_CONST = __webpack_require__(14);

var TweenManager = new Class({

    initialize:

    function TweenManager (scene)
    {
        //  The Scene the Tween Manager belongs to (tweens are Scene specific, not Game global)
        this.scene = scene;

        this.timeScale = 1;

        this._add = [];
        this._pending = [];
        this._active = [];
        this._destroy = [];

        this._toProcess = 0;
    },

    //  Scene is starting up
    boot: function ()
    {
        this.timeScale = 1;
    },

    //  Create a Tween Timeline and return it, but do NOT add it to the active or pending Tween lists
    createTimeline: function (config)
    {
        return TimelineBuilder(this, config);
    },

    //  Create a Tween Timeline and add it to the active Tween list
    timeline: function (config)
    {
        var timeline = TimelineBuilder(this, config);

        if (!timeline.paused)
        {
            this._add.push(timeline);

            this._toProcess++;
        }

        return timeline;
    },

    //  Create a Tween and return it, but do NOT add it to the active or pending Tween lists
    create: function (config)
    {
        return TweenBuilder(this, config);
    },

    //  Create a Tween and add it to the active Tween list
    add: function (config)
    {
        var tween = TweenBuilder(this, config);

        this._add.push(tween);

        this._toProcess++;

        return tween;
    },

    //  Add an existing tween into the active Tween list
    existing: function (tween)
    {
        this._add.push(tween);

        this._toProcess++;

        return this;
    },

    begin: function ()
    {
        if (this._toProcess === 0)
        {
            //  Quick bail
            return;
        }

        var list = this._destroy;
        var active = this._active;
        var i;
        var tween;

        //  Clear the 'destroy' list
        for (i = 0; i < list.length; i++)
        {
            tween = list[i];

            //  Remove from the 'active' array
            var idx = active.indexOf(tween);

            if (idx !== -1)
            {
                tween.state = TWEEN_CONST.REMOVED;
                active.splice(idx, 1);
            }
        }

        list.length = 0;

        //  Process the addition list
        //  This stops callbacks and out of sync events from populating the active array mid-way during the update

        list = this._add;

        for (i = 0; i < list.length; i++)
        {
            tween = list[i];

            //  Return true if the Tween should be started right away, otherwise false
            if (tween.init())
            {
                tween.play();

                this._active.push(tween);
            }
            else
            {
                this._pending.push(tween);
            }
        }

        list.length = 0;

        this._toProcess = 0;
    },

    update: function (timestamp, delta)
    {
        //  Process active tweens
        var list = this._active;
        var tween;

        //  Scale the delta
        delta *= this.timeScale;

        for (var i = 0; i < list.length; i++)
        {
            tween = list[i];

            //  If Tween.update returns 'true' then it means it has completed,
            //  so move it to the destroy list
            if (tween.update(timestamp, delta))
            {
                this._destroy.push(tween);
                this._toProcess++;
            }
        }
    },

    makeActive: function (tween)
    {
        if (this._add.indexOf(tween) !== -1 || this._active.indexOf(tween) !== -1)
        {
            return;
        }

        var idx = this._pending.indexOf(tween);

        if (idx !== -1)
        {
            this._pending.splice(idx, 1);
        }

        this._add.push(tween);

        tween.state = TWEEN_CONST.PENDING_ADD;

        this._toProcess++;

        return this;
    },

    setGlobalTimeScale: __webpack_require__(1002),
    getGlobalTimeScale: __webpack_require__(995),
    getAllTweens: __webpack_require__(994),
    getTweensOf: __webpack_require__(996),
    isTweening: __webpack_require__(997),
    killAll: __webpack_require__(998),
    killTweensOf: __webpack_require__(999),
    pauseAll: __webpack_require__(1000),
    resumeAll: __webpack_require__(1001),
    each: __webpack_require__(993),
    shutdown: __webpack_require__(1003),
    destroy: __webpack_require__(992)

    // TODO: kill: function (vars, target)
});

module.exports = TweenManager;


/***/ }),
/* 992 */
/***/ (function(module, exports) {

//  Game level nuke
var Destroy = function ()
{
    this.shutdown();
};

module.exports = Destroy;


/***/ }),
/* 993 */
/***/ (function(module, exports) {

/**
* Passes all Tweens to the given callback.
*
* @method each
* @param {function} callback - The function to call.
* @param {object} [thisArg] - Value to use as `this` when executing callback.
* @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
*/
var Each = function (callback, thisArg)
{
    var args = [ null ];

    for (var i = 1; i < arguments.length; i++)
    {
        args.push(arguments[i]);
    }

    for (var texture in this.list)
    {
        args[0] = this.list[texture];

        callback.apply(thisArg, args);
    }
};

module.exports = Each;


/***/ }),
/* 994 */
/***/ (function(module, exports) {

var GetAllTweens = function ()
{
    var list = this._active;
    var output = [];

    for (var i = 0; i < list.length; i++)
    {
        output.push(list[i]);
    }

    return output;
};

module.exports = GetAllTweens;


/***/ }),
/* 995 */
/***/ (function(module, exports) {

var GetGlobalTimeScale = function ()
{
    return this.timeScale;
};

module.exports = GetGlobalTimeScale;


/***/ }),
/* 996 */
/***/ (function(module, exports) {

//  Single Target or an Array of targets
var GetTweensOf = function (target)
{
    var list = this._active;
    var tween;
    var output = [];
    var i;

    if (Array.isArray(target))
    {
        for (i = 0; i < list.length; i++)
        {
            tween = list[i];

            for (var t = 0; t < target.length; i++)
            {
                if (tween.hasTarget(target[t]))
                {
                    output.push(tween);
                }
            }
        }
    }
    else
    {
        for (i = 0; i < list.length; i++)
        {
            tween = list[i];

            if (tween.hasTarget(target))
            {
                output.push(tween);
            }
        }
    }

    return output;
};

module.exports = GetTweensOf;


/***/ }),
/* 997 */
/***/ (function(module, exports) {

//  Single Target only
var IsTweening = function (target)
{
    var list = this._active;
    var tween;

    for (var i = 0; i < list.length; i++)
    {
        tween = list[i];

        if (tween.hasTarget(target) && tween.isPlaying())
        {
            return true;
        }
    }

    return false;
};

module.exports = IsTweening;


/***/ }),
/* 998 */
/***/ (function(module, exports) {

var KillAll = function ()
{
    var tweens = this.getAllTweens();

    for (var i = 0; i < tweens.length; i++)
    {
        tweens[i].stop();
    }

    return this;
};

module.exports = KillAll;


/***/ }),
/* 999 */
/***/ (function(module, exports) {

//  Single Target or an Array of targets
var KillTweensOf = function (target)
{
    var tweens = this.getTweensOf(target);

    for (var i = 0; i < tweens.length; i++)
    {
        tweens[i].stop();
    }

    return this;
};

module.exports = KillTweensOf;


/***/ }),
/* 1000 */
/***/ (function(module, exports) {

var PauseAll = function ()
{
    var list = this._active;

    for (var i = 0; i < list.length; i++)
    {
        list[i].pause();
    }

    return this;
};

module.exports = PauseAll;


/***/ }),
/* 1001 */
/***/ (function(module, exports) {

var ResumeAll = function ()
{
    var list = this._active;

    for (var i = 0; i < list.length; i++)
    {
        list[i].resume();
    }

    return this;
};

module.exports = ResumeAll;


/***/ }),
/* 1002 */
/***/ (function(module, exports) {

var SetGlobalTimeScale = function (value)
{
    this.timeScale = value;

    return this;
};

module.exports = SetGlobalTimeScale;


/***/ }),
/* 1003 */
/***/ (function(module, exports) {

//  Scene that owns this manager is shutting down
var Shutdown = function ()
{
    this.killAll();

    this._add = [];
    this._pending = [];
    this._active = [];
    this._destroy = [];

    this._toProcess = 0;
};

module.exports = Shutdown;


/***/ }),
/* 1004 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var TweenBuilder = __webpack_require__(114);
var TWEEN_CONST = __webpack_require__(14);

var Timeline = new Class({

    initialize:

    function Timeline (manager)
    {
        this.manager = manager;

        this.isTimeline = true;

        //  An array of Tween objects, each containing a unique property and target being tweened.
        this.data = [];

        //  data array doesn't usually change, so we can cache the length
        this.totalData = 0;

        //  If true then duration, delay, etc values are all frame totals
        this.useFrames = false;

        //  Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
        //  Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.
        this.timeScale = 1;

        //  Loop this tween? Can be -1 for an infinite loop, or an integer.
        //  When enabled it will play through ALL TweenDatas again (use TweenData.repeat to loop a single TD)
        this.loop = 0;

        //  Time in ms/frames before the tween loops.
        this.loopDelay = 0;

        //  How many loops are left to run?
        this.loopCounter = 0;

        //  Time in ms/frames before the 'onComplete' event fires. This never fires if loop = true (as it never completes)
        this.completeDelay = 0;

        //  Countdown timer (used by loopDelay and completeDelay)
        this.countdown = 0;

        //  The current state of the tween
        this.state = TWEEN_CONST.PENDING_ADD;

        //  The state of the tween when it was paused (used by Resume)
        this._pausedState = TWEEN_CONST.PENDING_ADD;

        //  Does the Tween start off paused? (if so it needs to be started with Tween.play)
        this.paused = false;

        //  Elapsed time in ms/frames of this run through the Tween.
        this.elapsed = 0;

        //  Total elapsed time in ms/frames of the entire Tween, including looping.
        this.totalElapsed = 0;

        //  Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays
        this.duration = 0;

        //  Value between 0 and 1. The amount through the Tween, excluding loops.
        this.progress = 0;

        //  Time in ms/frames for all Tweens to complete (including looping)
        this.totalDuration = 0;

        //  Value between 0 and 1. The amount through the entire Tween, including looping.
        this.totalProgress = 0;

        this.callbacks = {
            onComplete: null,
            onLoop: null,
            onStart: null,
            onUpdate: null,
            onYoyo: null
        };

        this.callbackScope;
    },

    setTimeScale: function (value)
    {
        this.timeScale = value;

        return this;
    },

    getTimeScale: function ()
    {
        return this.timeScale;
    },

    isPlaying: function ()
    {
        return (this.state === TWEEN_CONST.ACTIVE);
    },

    add: function (config)
    {
        return this.queue(TweenBuilder(this, config));
    },

    queue: function (tween)
    {
        if (!this.isPlaying())
        {
            tween.parent = this;
            tween.parentIsTimeline = true;

            this.data.push(tween);

            this.totalData = this.data.length;
        }

        return this;
    },

    hasOffset: function (tween)
    {
        return (tween.offset !== null);
    },

    isOffsetAbsolute: function (value)
    {
        return (typeof(value) === 'number');
    },

    isOffsetRelative: function (value)
    {
        var t = typeof(value);

        if (t === 'string')
        {
            var op = value[0];

            if (op === '-' || op === '+')
            {
                return true;
            }
        }

        return false;
    },

    getRelativeOffset: function (value, base)
    {
        var op = value[0];
        var num = parseFloat(value.substr(2));
        var result = base;

        switch (op)
        {
            case '+':
                result += num;
                break;

            case '-':
                result -= num;
                break;
        }

        //  Cannot ever be < 0
        return Math.max(0, result);
    },

    calcDuration: function ()
    {
        var prevEnd = 0;
        var totalDuration = 0;
        var offsetDuration = 0;

        for (var i = 0; i < this.totalData; i++)
        {
            var tween = this.data[i];

            tween.init();

            if (this.hasOffset(tween))
            {
                if (this.isOffsetAbsolute(tween.offset))
                {
                    //  An actual number, so it defines the start point from the beginning of the timeline
                    tween.calculatedOffset = tween.offset;

                    if (tween.offset === 0)
                    {
                        offsetDuration = 0;
                    }

                    // console.log('Timeline.calcDuration', i, 'absolute', tween.calculatedOffset);
                }
                else if (this.isOffsetRelative(tween.offset))
                {
                    //  A relative offset (i.e. '-=1000', so starts at 'offset' ms relative to the PREVIOUS Tweens ending time)
                    tween.calculatedOffset = this.getRelativeOffset(tween.offset, prevEnd);

                    // console.log('Timeline.calcDuration', i, 'relative', tween.calculatedOffset);
                }
            }
            else
            {
                //  Sequential
                tween.calculatedOffset = offsetDuration;
                
                // console.log('Timeline.calcDuration', i, 'sequential', tween.calculatedOffset);
            }

            prevEnd = tween.totalDuration + tween.calculatedOffset;

            // console.log('Span', i, tween.calculatedOffset, 'to', prevEnd);

            totalDuration += tween.totalDuration;
            offsetDuration += tween.totalDuration;
        }

        //  Excludes loop values
        this.duration = totalDuration;

        this.loopCounter = (this.loop === -1) ? 999999999999 : this.loop;

        if (this.loopCounter > 0)
        {
            this.totalDuration = this.duration + this.completeDelay + ((this.duration + this.loopDelay) * this.loopCounter);
        }
        else
        {
            this.totalDuration = this.duration + this.completeDelay;
        }
    },

    init: function ()
    {
        this.calcDuration();

        this.progress = 0;
        this.totalProgress = 0;

        if (this.paused)
        {
            this.state = TWEEN_CONST.PAUSED;

            return false;
        }
        else
        {
            return true;
        }
    },

    resetTweens: function (resetFromLoop)
    {
        for (var i = 0; i < this.totalData; i++)
        {
            var tween = this.data[i];

            tween.play(resetFromLoop);
        }
    },

    setCallback: function (type, callback, params, scope)
    {
        if (Timeline.TYPES.indexOf(type) !== -1)
        {
            this.callbacks[type] = { func: callback, scope: scope, params: params };
        }

        return this;
    },

    play: function ()
    {
        if (this.state === TWEEN_CONST.ACTIVE)
        {
            return;
        }

        if (this.paused)
        {
            this.paused = false;
        
            this.manager.makeActive(this);

            return;
        }
        else
        {
            this.resetTweens(false);

            this.state = TWEEN_CONST.ACTIVE;
        }

        var onStart = this.callbacks.onStart;

        if (onStart)
        {
            onStart.func.apply(onStart.scope, onStart.params);
        }
    },

    nextState: function ()
    {
        if (this.loopCounter > 0)
        {
            //  Reset the elapsed time
            //  TODO: Probably ought to be set to the remainder from elapsed - duration
            //  as the tweens nearly always over-run by a few ms due to rAf

            this.elapsed = 0;
            this.progress = 0;

            this.loopCounter--;

            var onLoop = this.callbacks.onLoop;

            if (onLoop)
            {
                onLoop.func.apply(onLoop.scope, onLoop.params);
            }

            this.resetTweens(true);

            if (this.loopDelay > 0)
            {
                this.countdown = this.loopDelay;
                this.state = TWEEN_CONST.LOOP_DELAY;
            }
            else
            {
                this.state = TWEEN_CONST.ACTIVE;
            }
        }
        else if (this.completeDelay > 0)
        {
            this.countdown = this.completeDelay;
            this.state = TWEEN_CONST.COMPLETE_DELAY;
        }
        else
        {
            var onComplete = this.callbacks.onComplete;

            if (onComplete)
            {
                onComplete.func.apply(onComplete.scope, onComplete.params);
            }

            this.state = TWEEN_CONST.PENDING_REMOVE;
        }
    },

    //  Returns 'true' if this Timeline has finished and should be removed from the Tween Manager
    //  Otherwise, returns false
    update: function (timestamp, delta)
    {
        if (this.state === TWEEN_CONST.PAUSED)
        {
            return;
        }

        var rawDelta = delta;

        if (this.useFrames)
        {
            delta = 1 * this.manager.timeScale;
        }

        delta *= this.timeScale;

        this.elapsed += delta;
        this.progress = Math.min(this.elapsed / this.duration, 1);

        this.totalElapsed += delta;
        this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);

        switch (this.state)
        {
            case TWEEN_CONST.ACTIVE:

                var stillRunning = this.totalData;

                for (var i = 0; i < this.totalData; i++)
                {
                    var tween = this.data[i];

                    if (tween.update(timestamp, rawDelta))
                    {
                        stillRunning--;
                    }
                }

                var onUpdate = this.callbacks.onUpdate;

                if (onUpdate)
                {
                    onUpdate.func.apply(onUpdate.scope, onUpdate.params);
                }

                //  Anything still running? If not, we're done
                if (stillRunning === 0)
                {
                    this.nextState();
                }

                break;

            case TWEEN_CONST.LOOP_DELAY:

                this.countdown -= delta;

                if (this.countdown <= 0)
                {
                    this.state = TWEEN_CONST.ACTIVE;
                }

                break;

            case TWEEN_CONST.COMPLETE_DELAY:

                this.countdown -= delta;

                if (this.countdown <= 0)
                {
                    var onComplete = this.callbacks.onComplete;

                    if (onComplete)
                    {
                        onComplete.func.apply(onComplete.scope, onComplete.params);
                    }

                    this.state = TWEEN_CONST.PENDING_REMOVE;
                }

                break;
        }

        return (this.state === TWEEN_CONST.PENDING_REMOVE);
    },

    //  Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager
    stop: function ()
    {
        this.state = TWEEN_CONST.PENDING_REMOVE;
    },

    pause: function ()
    {
        if (this.state === TWEEN_CONST.PAUSED)
        {
            return;
        }

        this.paused = true;

        this._pausedState = this.state;

        this.state = TWEEN_CONST.PAUSED;

        return this;
    },

    resume: function ()
    {
        if (this.state === TWEEN_CONST.PAUSED)
        {
            this.paused = false;

            this.state = this._pausedState;
        }

        return this;
    },

    hasTarget: function (target)
    {
        for (var i = 0; i < this.data.length; i++)
        {
            if (this.data[i].hasTarget(target))
            {
                return true;
            }
        }
        
        return false;
    },

    destroy: function ()
    {
        for (var i = 0; i < this.data.length; i++)
        {
            this.data[i].destroy();
        }

    }
});

Timeline.TYPES = [ 'onStart', 'onUpdate', 'onLoop', 'onComplete', 'onYoyo' ];

module.exports = Timeline;


/***/ }),
/* 1005 */
/***/ (function(module, exports) {

//  RESERVED properties that a Tween config object uses

//  completeDelay: The time the tween will wait before the onComplete event is dispatched once it has completed
//  delay: The time the tween will wait before it first starts
//  duration: The duration of the tween
//  ease: The ease function used by the tween
//  easeParams: The parameters to go with the ease function (if any)
//  hold: The time the tween will pause before running a yoyo
//  loop: The time the tween will pause before starting either a yoyo or returning to the start for a repeat
//  loopDelay: 
//  offset: Used when the Tween is part of a Timeline
//  paused: Does the tween start in a paused state, or playing?
//  props: The properties being tweened by the tween
//  repeat: The number of times the tween will repeat itself (a value of 1 means the tween will play twice, as it repeated once)
//  repeatDelay: The time the tween will pause for before starting a repeat. The tween holds in the start state.
//  targets: The targets the tween is updating.
//  useFrames: Use frames or milliseconds?
//  yoyo: boolean - Does the tween reverse itself (yoyo) when it reaches the end?

module.exports = [
    'callbackScope',
    'completeDelay',
    'delay',
    'duration',
    'ease',
    'easeParams',
    'flipX',
    'flipY',
    'hold',
    'loop',
    'loopDelay',
    'offset',
    'onComplete',
    'onCompleteParams',
    'onCompleteScope',
    'onLoop',
    'onLoopParams',
    'onLoopScope',
    'onRepeat',
    'onRepeatParams',
    'onRepeatScope',
    'onStart',
    'onStartParams',
    'onStartScope',
    'onUpdate',
    'onUpdateParams',
    'onUpdateScope',
    'onYoyo',
    'onYoyoParams',
    'onYoyoScope',
    'paused',
    'props',
    'repeat',
    'repeatDelay',
    'targets',
    'useFrames',
    'yoyo'
];


/***/ }),
/* 1006 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(0);
var GameObjectCreator = __webpack_require__(5);
var GameObjectFactory = __webpack_require__(6);
var TWEEN_CONST = __webpack_require__(14);

var Tween = new Class({

    initialize:

    function Tween (parent, data, targets)
    {
        this.parent = parent;

        //  Is the parent of this Tween a Timeline?
        this.parentIsTimeline = parent.hasOwnProperty('isTimeline');

        //  An array of TweenData objects, each containing a unique property and target being tweened.
        this.data = data;

        //  data array doesn't change, so we can cache the length
        this.totalData = data.length;

        //  An array of references to the target/s this Tween is operating on
        this.targets = targets;

        //  Cached target total (not necessarily the same as the data total)
        this.totalTargets = targets.length;

        //  If true then duration, delay, etc values are all frame totals
        this.useFrames = false;

        //  Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
        //  Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.
        this.timeScale = 1;

        //  Loop this tween? Can be -1 for an infinite loop, or an integer.
        //  When enabled it will play through ALL TweenDatas again (use TweenData.repeat to loop a single TD)
        this.loop = 0;

        //  Time in ms/frames before the tween loops.
        this.loopDelay = 0;

        //  How many loops are left to run?
        this.loopCounter = 0;

        //  Time in ms/frames before the 'onComplete' event fires. This never fires if loop = -1 (as it never completes)
        this.completeDelay = 0;

        //  Countdown timer (used by timeline offset, loopDelay and completeDelay)
        this.countdown = 0;

        //  Set only if this Tween is part of a Timeline.
        this.offset = 0;

        //  Set only if this Tween is part of a Timeline. The calculated offset amount.
        this.calculatedOffset = 0;

        //  The current state of the tween
        this.state = TWEEN_CONST.PENDING_ADD;

        //  The state of the tween when it was paused (used by Resume)
        this._pausedState = TWEEN_CONST.PENDING_ADD;

        //  Does the Tween start off paused? (if so it needs to be started with Tween.play)
        this.paused = false;

        //  Elapsed time in ms/frames of this run through the Tween.
        this.elapsed = 0;

        //  Total elapsed time in ms/frames of the entire Tween, including looping.
        this.totalElapsed = 0;

        //  Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays
        this.duration = 0;

        //  Value between 0 and 1. The amount through the Tween, excluding loops.
        this.progress = 0;

        //  Time in ms/frames for the Tween to complete (including looping)
        this.totalDuration = 0;

        //  Value between 0 and 1. The amount through the entire Tween, including looping.
        this.totalProgress = 0;

        this.callbacks = {
            onComplete: null,
            onLoop: null,
            onRepeat: null,
            onStart: null,
            onUpdate: null,
            onYoyo: null
        };

        this.callbackScope;
    },

    setTimeScale: function (value)
    {
        this.timeScale = value;

        return this;
    },

    getTimeScale: function ()
    {
        return this.timeScale;
    },

    isPlaying: function ()
    {
        return (this.state === TWEEN_CONST.ACTIVE);
    },

    hasTarget: function (target)
    {
        return (this.targets.indexOf(target) !== -1);
    },

    updateTo: function (key, value, startToCurrent)
    {
        for (var i = 0; i < this.totalData; i++)
        {
            var tweenData = this.data[i];

            if (tweenData.key === key)
            {
                tweenData.end = value;

                if (startToCurrent)
                {
                    tweenData.start = tweenData.current;
                }

                break;
            }
        }

        return this;
    },

    restart: function ()
    {
        this.stop();
        this.play();
    },

    calcDuration: __webpack_require__(1008),
    init: __webpack_require__(1009),
    nextState: __webpack_require__(1010),
    pause: __webpack_require__(1011),
    play: __webpack_require__(1012),
    resetTweenData: __webpack_require__(1013),
    resume: __webpack_require__(1014),
    seek: __webpack_require__(1015),
    setCallback: __webpack_require__(1016),
    stop: __webpack_require__(1017),
    update: __webpack_require__(1018)

});

Tween.TYPES = [
    'onComplete',
    'onLoop',
    'onRepeat',
    'onStart',
    'onUpdate',
    'onYoyo'
];

//  When registering a factory function 'this' refers to the GameObjectFactory context.
//  
//  There are several properties available to use:
//  
//  this.scene - a reference to the Scene that owns the GameObjectFactory
//  this.displayList - a reference to the Display List the Scene owns
//  this.updateList - a reference to the Update List the Scene owns

GameObjectFactory.register('tween', function (config)
{
    return this.scene.sys.tweens.add(config);
});

//  When registering a factory function 'this' refers to the GameObjectCreator context.

GameObjectCreator.register('tween', function (config)
{
    return this.scene.sys.tweens.create(config);
});

module.exports = Tween;


/***/ }),
/* 1007 */
/***/ (function(module, exports) {

var TweenData = function (target, key, getEnd, getStart, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY)
{
    return {

        //  The target to tween
        target: target,

        //  The property of the target to tween
        key: key,

        //  The returned value sets what the property will be at the END of the Tween.
        getEndValue: getEnd,

        //  The returned value sets what the property will be at the START of the Tween.
        getStartValue: getStart,

        //  The ease function this tween uses.
        ease: ease,

        //  Duration of the tween in ms/frames, excludes time for yoyo or repeats.
        duration: 0,

        //  The total calculated duration of this TweenData (based on duration, repeat, delay and yoyo)
        totalDuration: 0,

        //  Time in ms/frames before tween will start.
        delay: 0,

        //  Cause the tween to return back to its start value after hold has expired.
        yoyo: yoyo,

        //  Time in ms/frames the tween will pause before running the yoyo or starting a repeat.
        hold: 0,

        //  Number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.
        repeat: 0,

        //  Time in ms/frames before the repeat will start.
        repeatDelay: 0,

        //  Automatically call toggleFlipX when the TweenData yoyos or repeats
        flipX: flipX,

        //  Automatically call toggleFlipY when the TweenData yoyos or repeats
        flipY: flipY,

        //  Between 0 and 1 showing completion of this TweenData.
        progress: 0,

        //  Delta counter.
        elapsed: 0,

        //  How many repeats are left to run?
        repeatCounter: 0,

        //  Ease Value Data:

        start: 0,
        current: 0,
        end: 0,

        //  Time Durations
        t1: 0,
        t2: 0,

        //  LoadValue generation functions
        gen: {
            delay: delay,
            duration: duration,
            hold: hold,
            repeat: repeat,
            repeatDelay: repeatDelay
        },

        //  TWEEN_CONST.CREATED
        state: 0
    };
};

module.exports = TweenData;


/***/ }),
/* 1008 */
/***/ (function(module, exports) {

var CalcDuration = function ()
{
    var max = 0;

    var data = this.data;

    for (var i = 0; i < this.totalData; i++)
    {
        var tweenData = data[i];

        //  Set t1 (duration + hold + yoyo)
        tweenData.t1 = tweenData.duration + tweenData.hold;

        if (tweenData.yoyo)
        {
            tweenData.t1 += tweenData.duration;
        }

        //  Set t2 (repeatDelay + duration + hold + yoyo)
        tweenData.t2 = tweenData.t1 + tweenData.repeatDelay;

        //  Total Duration
        tweenData.totalDuration = tweenData.delay + tweenData.t1;

        if (tweenData.repeat === -1)
        {
            tweenData.totalDuration += (tweenData.t2 * 999999999999);
        }
        else if (tweenData.repeat > 0)
        {
            tweenData.totalDuration += (tweenData.t2 * tweenData.repeat);
        }

        if (tweenData.totalDuration > max)
        {
            //  Get the longest TweenData from the Tween, used to calculate the Tween TD
            max = tweenData.totalDuration;
        }
    }

    //  Excludes loop values
    this.duration = max;

    this.loopCounter = (this.loop === -1) ? 999999999999 : this.loop;

    if (this.loopCounter > 0)
    {
        this.totalDuration = this.duration + this.completeDelay + ((this.duration + this.loopDelay) * this.loopCounter);
    }
    else
    {
        this.totalDuration = this.duration + this.completeDelay;
    }
};

module.exports = CalcDuration;


/***/ }),
/* 1009 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(14);

//  Return true if this Tween should be moved from the pending list to the active list
var Init = function ()
{
    var data = this.data;
    var totalTargets = this.totalTargets;

    for (var i = 0; i < this.totalData; i++)
    {
        var tweenData = data[i];
        var target = tweenData.target;
        var gen = tweenData.gen;

        tweenData.delay = gen.delay(i, totalTargets, target);
        tweenData.duration = gen.duration(i, totalTargets, target);
        tweenData.hold = gen.hold(i, totalTargets, target);
        tweenData.repeat = gen.repeat(i, totalTargets, target);
        tweenData.repeatDelay = gen.repeatDelay(i, totalTargets, target);
    }

    this.calcDuration();

    this.progress = 0;
    this.totalProgress = 0;
    this.elapsed = 0;
    this.totalElapsed = 0;

    //  You can't have a paused Tween if it's part of a Timeline
    if (this.paused && !this.parentIsTimeline)
    {
        this.state = TWEEN_CONST.PAUSED;

        return false;
    }
    else
    {
        return true;
    }
};

module.exports = Init;


/***/ }),
/* 1010 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(14);

var NextState = function ()
{
    if (this.loopCounter > 0)
    {
        this.elapsed = 0;
        this.progress = 0;
        this.loopCounter--;

        var onLoop = this.callbacks.onLoop;

        if (onLoop)
        {
            onLoop.params[1] = this.targets;

            onLoop.func.apply(onLoop.scope, onLoop.params);
        }

        this.resetTweenData(true);

        if (this.loopDelay > 0)
        {
            this.countdown = this.loopDelay;
            this.state = TWEEN_CONST.LOOP_DELAY;
        }
        else
        {
            this.state = TWEEN_CONST.ACTIVE;
        }
    }
    else if (this.completeDelay > 0)
    {
        this.countdown = this.completeDelay;
        this.state = TWEEN_CONST.COMPLETE_DELAY;
    }
    else
    {
        var onComplete = this.callbacks.onComplete;

        if (onComplete)
        {
            onComplete.params[1] = this.targets;

            onComplete.func.apply(onComplete.scope, onComplete.params);
        }

        this.state = TWEEN_CONST.PENDING_REMOVE;
    }
};

module.exports = NextState;


/***/ }),
/* 1011 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(14);

var Pause = function ()
{
    if (this.state === TWEEN_CONST.PAUSED)
    {
        return;
    }

    this.paused = true;

    this._pausedState = this.state;

    this.state = TWEEN_CONST.PAUSED;

    return this;
};

module.exports = Pause;


/***/ }),
/* 1012 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(14);

var Play = function (resetFromTimeline)
{
    if (this.state === TWEEN_CONST.ACTIVE)
    {
        return;
    }
    else if (this.state === TWEEN_CONST.PENDING_REMOVE || this.state === TWEEN_CONST.REMOVED)
    {
        this.init();
        this.parent.makeActive(this);
        resetFromTimeline = true;
    }

    var onStart = this.callbacks.onStart;

    if (this.parentIsTimeline)
    {
        this.resetTweenData(resetFromTimeline);

        if (this.calculatedOffset === 0)
        {
            if (onStart)
            {
                onStart.params[1] = this.targets;

                onStart.func.apply(onStart.scope, onStart.params);
            }

            this.state = TWEEN_CONST.ACTIVE;
        }
        else
        {
            this.countdown = this.calculatedOffset;

            this.state = TWEEN_CONST.OFFSET_DELAY;
        }
    }
    else if (this.paused)
    {
        this.paused = false;
    
        this.parent.makeActive(this);

        return;
    }
    else
    {
        this.resetTweenData(resetFromTimeline);

        this.state = TWEEN_CONST.ACTIVE;

        if (onStart)
        {
            onStart.params[1] = this.targets;

            onStart.func.apply(onStart.scope, onStart.params);
        }
    }
};

module.exports = Play;


/***/ }),
/* 1013 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(14);

var ResetTweenData = function (resetFromLoop)
{
    var data = this.data;

    for (var i = 0; i < this.totalData; i++)
    {
        var tweenData = data[i];

        tweenData.progress = 0;
        tweenData.elapsed = 0;

        tweenData.repeatCounter = (tweenData.repeat === -1) ? 999999999999 : tweenData.repeat;

        if (resetFromLoop)
        {
            tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start);

            tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.end);

            tweenData.current = tweenData.start;

            tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
        }
        else if (tweenData.delay > 0)
        {
            tweenData.elapsed = tweenData.delay;
            tweenData.state = TWEEN_CONST.DELAY;
        }
        else
        {
            tweenData.state = TWEEN_CONST.PENDING_RENDER;
        }
    }
};

module.exports = ResetTweenData;


/***/ }),
/* 1014 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(14);

var Pause = function ()
{
    if (this.state === TWEEN_CONST.PAUSED)
    {
        this.paused = false;

        this.state = this._pausedState;
    }

    return this;
};

module.exports = Pause;


/***/ }),
/* 1015 */
/***/ (function(module, exports) {

// var TWEEN_CONST = require('../const');

//  For now progress = 0 to 1
var Seek = function (toPosition)
{
    var data = this.data;

    for (var i = 0; i < this.totalData; i++)
    {
        //  This won't work with loop > 0 yet
        var ms = this.totalDuration * toPosition;

        var tweenData = data[i];
        var progress = 0;
        var elapsed = 0;

        if (ms <= tweenData.delay)
        {
            progress = 0;
            elapsed = 0;
        }
        else if (ms >= tweenData.totalDuration)
        {
            progress = 1;
            elapsed = tweenData.duration;
        }
        else if (ms > tweenData.delay && ms <= tweenData.t1)
        {
            //  Keep it zero bound
            ms = Math.max(0, ms - tweenData.delay);

            //  Somewhere in the first playthru range
            progress = ms / tweenData.t1;
            elapsed = tweenData.duration * progress;
        }
        else if (ms > tweenData.t1 && ms < tweenData.totalDuration)
        {
            //  Somewhere in repeat land
            ms -= tweenData.delay;
            ms -= tweenData.t1;

            var repeats = Math.floor(ms / tweenData.t2);

            //  remainder
            ms = ((ms / tweenData.t2) % 1) * tweenData.t2;

            if (ms > tweenData.repeatDelay)
            {
                progress = ms / tweenData.t1;
                elapsed = tweenData.duration * progress;
            }
        }

        tweenData.progress = progress;
        tweenData.elapsed = elapsed;

        var v = tweenData.ease(tweenData.progress);

        tweenData.current = tweenData.start + ((tweenData.end - tweenData.start) * v);

        // console.log(tweenData.key, 'Seek', tweenData.target[tweenData.key], 'to', tweenData.current, 'pro', tweenData.progress, 'marker', marker, progress);

        tweenData.target[tweenData.key] = tweenData.current;
    }
};

module.exports = Seek;


/***/ }),
/* 1016 */
/***/ (function(module, exports) {


var SetCallback = function (type, callback, params, scope)
{
    this.callbacks[type] = { func: callback, scope: scope, params: params };

    return this;
};

module.exports = SetCallback;


/***/ }),
/* 1017 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(14);

//  Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager

var Stop = function ()
{
    this.state = TWEEN_CONST.PENDING_REMOVE;
};

module.exports = Stop;


/***/ }),
/* 1018 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(14);
var UpdateTweenData = __webpack_require__(1019);

//  Returns 'true' if this Tween has finished and should be removed from the Tween Manager
//  Otherwise, returns false
var Update = function (timestamp, delta)
{
    if (this.state === TWEEN_CONST.PAUSED)
    {
        return false;
    }

    if (this.useFrames)
    {
        delta = 1 * this.parent.timeScale;
    }

    delta *= this.timeScale;

    this.elapsed += delta;
    this.progress = Math.min(this.elapsed / this.duration, 1);

    this.totalElapsed += delta;
    this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);

    switch (this.state)
    {
        case TWEEN_CONST.ACTIVE:

            var stillRunning = false;

            for (var i = 0; i < this.totalData; i++)
            {
                if (UpdateTweenData(this, this.data[i], delta))
                {
                    stillRunning = true;
                }
            }

            //  Anything still running? If not, we're done
            if (!stillRunning)
            {
                this.nextState();
            }

            break;

        case TWEEN_CONST.LOOP_DELAY:

            this.countdown -= delta;

            if (this.countdown <= 0)
            {
                this.state = TWEEN_CONST.ACTIVE;
            }

            break;

        case TWEEN_CONST.OFFSET_DELAY:

            this.countdown -= delta;

            if (this.countdown <= 0)
            {
                var onStart = this.callbacks.onStart;

                if (onStart)
                {
                    onStart.params[1] = this.targets;

                    onStart.func.apply(onStart.scope, onStart.params);
                }

                this.state = TWEEN_CONST.ACTIVE;
            }

            break;

        case TWEEN_CONST.COMPLETE_DELAY:

            this.countdown -= delta;

            if (this.countdown <= 0)
            {
                var onComplete = this.callbacks.onComplete;

                if (onComplete)
                {
                    onComplete.func.apply(onComplete.scope, onComplete.params);
                }

                this.state = TWEEN_CONST.PENDING_REMOVE;
            }

            break;
    }

    return (this.state === TWEEN_CONST.PENDING_REMOVE);
};

module.exports = Update;


/***/ }),
/* 1019 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(14);

var SetStateFromEnd = function (tween, tweenData, diff)
{
    if (tweenData.yoyo)
    {
        //  We've hit the end of a Playing Forward TweenData and we have a yoyo

        //  Account for any extra time we got from the previous frame
        tweenData.elapsed = diff;
        tweenData.progress = diff / tweenData.duration;

        if (tweenData.flipX)
        {
            tweenData.target.toggleFlipX();
        }

        //  Problem: The flip and callback and so on gets called for every TweenData that triggers it at the same time.
        //  If you're tweening several properties it can fire for all of them, at once.

        if (tweenData.flipY)
        {
            tweenData.target.toggleFlipY();
        }

        var onYoyo = tween.callbacks.onYoyo;

        if (onYoyo)
        {
            //  Element 1 is reserved for the target of the yoyo (and needs setting here)
            onYoyo.params[1] = tweenData.target;

            onYoyo.func.apply(onYoyo.scope, onYoyo.params);
        }

        tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start);

        return TWEEN_CONST.PLAYING_BACKWARD;
    }
    else if (tweenData.repeatCounter > 0)
    {
        //  We've hit the end of a Playing Forward TweenData and we have a Repeat.
        //  So we're going to go right back to the start to repeat it again.

        tweenData.repeatCounter--;

        //  Account for any extra time we got from the previous frame
        tweenData.elapsed = diff;
        tweenData.progress = diff / tweenData.duration;

        // tweenData.elapsed = 0;
        // tweenData.progress = 0;

        if (tweenData.flipX)
        {
            tweenData.target.toggleFlipX();
        }

        if (tweenData.flipY)
        {
            tweenData.target.toggleFlipY();
        }

        var onRepeat = tween.callbacks.onRepeat;

        if (onRepeat)
        {
            //  Element 1 is reserved for the target of the repeat (and needs setting here)
            onRepeat.params[1] = tweenData.target;

            onRepeat.func.apply(onRepeat.scope, onRepeat.params);
        }

        tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start);

        tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.end);

        //  Delay?
        if (tweenData.repeatDelay > 0)
        {
            tweenData.elapsed = tweenData.repeatDelay - diff;

            tweenData.current = tweenData.start;

            tweenData.target[tweenData.key] = tweenData.current;

            return TWEEN_CONST.REPEAT_DELAY;
        }
        else
        {
            return TWEEN_CONST.PLAYING_FORWARD;
        }
    }

    return TWEEN_CONST.COMPLETE;
};

//  Was PLAYING_BACKWARD and has hit the start
var SetStateFromStart = function (tween, tweenData, diff)
{
    if (tweenData.repeatCounter > 0)
    {
        tweenData.repeatCounter--;

        //  Account for any extra time we got from the previous frame
        tweenData.elapsed = diff;
        tweenData.progress = diff / tweenData.duration;

        // tweenData.elapsed = 0;
        // tweenData.progress = 0;

        if (tweenData.flipX)
        {
            tweenData.target.toggleFlipX();
        }

        if (tweenData.flipY)
        {
            tweenData.target.toggleFlipY();
        }

        var onRepeat = tween.callbacks.onRepeat;

        if (onRepeat)
        {
            //  Element 1 is reserved for the target of the repeat (and needs setting here)
            onRepeat.params[1] = tweenData.target;

            onRepeat.func.apply(onRepeat.scope, onRepeat.params);
        }

        tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.end);

        //  Delay?
        if (tweenData.repeatDelay > 0)
        {
            tweenData.elapsed = tweenData.repeatDelay - diff;

            tweenData.current = tweenData.start;

            tweenData.target[tweenData.key] = tweenData.current;

            return TWEEN_CONST.REPEAT_DELAY;
        }
        else
        {
            return TWEEN_CONST.PLAYING_FORWARD;
        }
    }

    return TWEEN_CONST.COMPLETE;
};

//  Delta is either a value in ms, or 1 if Tween.useFrames is true
var UpdateTweenData = function (tween, tweenData, delta)
{
    switch (tweenData.state)
    {
        case TWEEN_CONST.PLAYING_FORWARD:
        case TWEEN_CONST.PLAYING_BACKWARD:

            var elapsed = tweenData.elapsed;
            var duration = tweenData.duration;
            var diff = 0;

            elapsed += delta;

            if (elapsed > duration)
            {
                diff = elapsed - duration;
                elapsed = duration;
            }

            var forward = (tweenData.state === TWEEN_CONST.PLAYING_FORWARD);
            var progress = elapsed / duration;

            var v;

            if (forward)
            {
                v = tweenData.ease(progress);
            }
            else
            {
                v = tweenData.ease(1 - progress);
            }

            tweenData.current = tweenData.start + ((tweenData.end - tweenData.start) * v);

            tweenData.target[tweenData.key] = tweenData.current;

            tweenData.elapsed = elapsed;
            tweenData.progress = progress;

            var onUpdate = tween.callbacks.onUpdate;

            if (onUpdate)
            {
                onUpdate.params[1] = tweenData.target;

                onUpdate.func.apply(onUpdate.scope, onUpdate.params);
            }

            if (progress === 1)
            {
                if (forward)
                {
                    if (tweenData.hold > 0)
                    {
                        tweenData.elapsed = tweenData.hold - diff;

                        tweenData.state = TWEEN_CONST.HOLD_DELAY;
                    }
                    else
                    {
                        tweenData.state = SetStateFromEnd(tween, tweenData, diff);
                    }
                }
                else
                {
                    tweenData.state = SetStateFromStart(tween, tweenData, diff);
                }
            }

            break;

        case TWEEN_CONST.DELAY:

            tweenData.elapsed -= delta;

            if (tweenData.elapsed <= 0)
            {
                tweenData.elapsed = Math.abs(tweenData.elapsed);

                tweenData.state = TWEEN_CONST.PENDING_RENDER;
            }

            break;

        case TWEEN_CONST.REPEAT_DELAY:

            tweenData.elapsed -= delta;

            if (tweenData.elapsed <= 0)
            {
                tweenData.elapsed = Math.abs(tweenData.elapsed);

                tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
            }

            break;

        case TWEEN_CONST.HOLD_DELAY:

            tweenData.elapsed -= delta;

            if (tweenData.elapsed <= 0)
            {
                tweenData.state = SetStateFromEnd(tween, tweenData, Math.abs(tweenData.elapsed));
            }

            break;

        case TWEEN_CONST.PENDING_RENDER:

            tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.target[tweenData.key]);

            tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start);

            tweenData.current = tweenData.start;

            tweenData.target[tweenData.key] = tweenData.start;

            tweenData.state = TWEEN_CONST.PLAYING_FORWARD;

            break;
    }

    //  Return TRUE if this TweenData still playing, otherwise return FALSE
    return (tweenData.state !== TWEEN_CONST.COMPLETE);
};

module.exports = UpdateTweenData;


/***/ }),
/* 1020 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(248);

var AlignInMap = [];

AlignInMap[CONST.BOTTOM_CENTER] = __webpack_require__(239);
AlignInMap[CONST.BOTTOM_LEFT] = __webpack_require__(240);
AlignInMap[CONST.BOTTOM_RIGHT] = __webpack_require__(241);
AlignInMap[CONST.CENTER] = __webpack_require__(242);
AlignInMap[CONST.LEFT_CENTER] = __webpack_require__(243);
AlignInMap[CONST.RIGHT_CENTER] = __webpack_require__(244);
AlignInMap[CONST.TOP_CENTER] = __webpack_require__(245);
AlignInMap[CONST.TOP_LEFT] = __webpack_require__(246);
AlignInMap[CONST.TOP_RIGHT] = __webpack_require__(247);

var AlignIn = function (child, container, position, offsetX, offsetY)
{
    return AlignInMap[position](child, container, offsetX, offsetY);
};

module.exports = AlignIn;


/***/ }),
/* 1021 */
/***/ (function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(44);
var GetBottom = __webpack_require__(21);
var SetCenterX = __webpack_require__(46);
var SetTop = __webpack_require__(28);

var ToBottomCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(parent) + offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomCenter;


/***/ }),
/* 1022 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(22);
var GetBottom = __webpack_require__(21);
var SetLeft = __webpack_require__(26);
var SetTop = __webpack_require__(28);

var ToBottomLeft = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(parent) - offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomLeft;


/***/ }),
/* 1023 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(23);
var GetBottom = __webpack_require__(21);
var SetRight = __webpack_require__(27);
var SetTop = __webpack_require__(28);

var ToBottomRight = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(parent) + offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomRight;


/***/ }),
/* 1024 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(22);
var GetBottom = __webpack_require__(21);
var SetRight = __webpack_require__(27);
var SetBottom = __webpack_require__(25);

var ToLeftBottom = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetBottom(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToLeftBottom;


/***/ }),
/* 1025 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(22);
var GetCenterY = __webpack_require__(45);
var SetRight = __webpack_require__(27);
var SetCenterY = __webpack_require__(47);

var ToLeftCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetCenterY(gameObject, GetCenterY(parent) + offsetY);

    return gameObject;
};

module.exports = ToLeftCenter;


/***/ }),
/* 1026 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(22);
var GetTop = __webpack_require__(24);
var SetRight = __webpack_require__(27);
var SetTop = __webpack_require__(28);

var ToLeftTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetTop(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToLeftTop;


/***/ }),
/* 1027 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(23);
var GetBottom = __webpack_require__(21);
var SetLeft = __webpack_require__(26);
var SetBottom = __webpack_require__(25);

var ToRightBottom = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetBottom(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToRightBottom;


/***/ }),
/* 1028 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(23);
var GetCenterY = __webpack_require__(45);
var SetLeft = __webpack_require__(26);
var SetCenterY = __webpack_require__(47);

var ToRightTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetCenterY(gameObject, GetCenterY(parent) + offsetY);

    return gameObject;
};

module.exports = ToRightTop;


/***/ }),
/* 1029 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(23);
var GetTop = __webpack_require__(24);
var SetLeft = __webpack_require__(26);
var SetTop = __webpack_require__(28);

var ToRightTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetTop(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToRightTop;


/***/ }),
/* 1030 */
/***/ (function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(44);
var GetTop = __webpack_require__(24);
var SetCenterX = __webpack_require__(46);
var SetBottom = __webpack_require__(25);

var ToTopCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(parent) + offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopCenter;


/***/ }),
/* 1031 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(22);
var GetTop = __webpack_require__(24);
var SetLeft = __webpack_require__(26);
var SetBottom = __webpack_require__(25);

var ToTopLeft = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(parent) - offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopLeft;


/***/ }),
/* 1032 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(23);
var GetTop = __webpack_require__(24);
var SetRight = __webpack_require__(27);
var SetBottom = __webpack_require__(25);

var ToTopRight = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(parent) + offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopRight;


/***/ }),
/* 1033 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Utils.Align

module.exports = {

    InBottomCenter: __webpack_require__(239),
    InBottomLeft: __webpack_require__(240),
    InBottomRight: __webpack_require__(241),
    InCenter: __webpack_require__(242),
    InLeftCenter: __webpack_require__(243),
    InRightCenter: __webpack_require__(244),
    InTopCenter: __webpack_require__(245),
    InTopLeft: __webpack_require__(246),
    InTopRight: __webpack_require__(247),
    ToBottomCenter: __webpack_require__(1021),
    ToBottomLeft: __webpack_require__(1022),
    ToBottomRight: __webpack_require__(1023),
    ToLeftBottom: __webpack_require__(1024),
    ToLeftCenter: __webpack_require__(1025),
    ToLeftTop: __webpack_require__(1026),
    ToRightBottom: __webpack_require__(1027),
    ToRightCenter: __webpack_require__(1028),
    ToRightTop: __webpack_require__(1029),
    ToTopCenter: __webpack_require__(1030),
    ToTopLeft: __webpack_require__(1031),
    ToTopRight: __webpack_require__(1032)

};


/***/ }),
/* 1034 */
/***/ (function(module, exports) {

/**
* Snaps a value to the nearest value in an array.
* The result will always be in the range `[first_value, last_value]`.
*
* @method
* @param {number} value - The search value
* @param {number[]} arr - The input array which _must_ be sorted.
* @return {number} The nearest value found.
*/
var FindClosestInSorted = function (value, array)
{
    if (!array.length)
    {
        return NaN;
    }
    else if (array.length === 1 || value < array[0])
    {
        return array[0];
    }

    var i = 1;

    while (array[i] < value)
    {
        i++;
    }

    var low = array[i - 1];
    var high = (i < array.length) ? array[i] : Number.POSITIVE_INFINITY;

    return ((high - value) <= (value - low)) ? high : low;
};

module.exports = FindClosestInSorted;


/***/ }),
/* 1035 */
/***/ (function(module, exports) {

/**
* Fetch a random entry from the given array.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was selected.
*/

var GetRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return (array[randomIndex] === undefined) ? null : array[randomIndex];
};

module.exports = GetRandomElement;


/***/ }),
/* 1036 */
/***/ (function(module, exports, __webpack_require__) {

var RoundAwayFromZero = __webpack_require__(206);

/**
* Create an array of numbers (positive and/or negative) progressing from `start`
* up to but not including `end` by advancing by `step`.
*
* If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.
*
* Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;
* for forward compatibility make sure to pass in actual numbers.
*
* @method Phaser.ArrayUtils#numberArrayStep
* @param {number} start - The start of the range.
* @param {number} [end] - The end of the range.
* @param {number} [step=1] - The value to increment or decrement by.
* @returns {Array} Returns the new array of numbers.
* @example
* NumberArrayStep(4);
* // => [0, 1, 2, 3]
*
* NumberArrayStep(1, 5);
* // => [1, 2, 3, 4]
*
* NumberArrayStep(0, 20, 5);
* // => [0, 5, 10, 15]
*
* NumberArrayStep(0, -4, -1);
* // => [0, -1, -2, -3]
*
* NumberArrayStep(1, 4, 0);
* // => [1, 1, 1]
*
* NumberArrayStep(0);
* // => []
*/
var NumberArrayStep = function (start, end, step)
{
    if (start === undefined) { start = 0; }
    if (end === undefined) { end = null; }
    if (step === undefined) { step = 1; }

    if (end === null)
    {
        end = start;
        start = 0;
    }

    var result = [];

    var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);

    for (var i = 0; i < total; i++)
    {
        result.push(start);
        start += step;
    }

    return result;
};

module.exports = NumberArrayStep;


/***/ }),
/* 1037 */
/***/ (function(module, exports, __webpack_require__) {

var SpliceOne = __webpack_require__(255);

/**
* Removes a random object from the given array and returns it.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was removed.
*/

var RemoveRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return SpliceOne(array, randomIndex);
};

module.exports = RemoveRandomElement;


/***/ }),
/* 1038 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Utils.Array

module.exports = {

    FindClosestInSorted: __webpack_require__(1034),
    GetRandomElement: __webpack_require__(1035),
    NumberArray: __webpack_require__(249),
    NumberArrayStep: __webpack_require__(1036),
    QuickSelect: __webpack_require__(250),
    Range: __webpack_require__(251),
    RemoveRandomElement: __webpack_require__(1037),
    RotateLeft: __webpack_require__(252),
    RotateRight: __webpack_require__(253),
    Shuffle: __webpack_require__(254),
    SpliceOne: __webpack_require__(255)

};


/***/ }),
/* 1039 */
/***/ (function(module, exports) {

/**
* The amount the Game Object is visually offset from its x coordinate.
* This is the same as `width * origin.x`.
* It will only be > 0 if origin.x is not equal to zero.
*
* @property {number} offsetX
* @readOnly
*/

var GetOffsetX = function (gameObject)
{
    return gameObject.width * gameObject.originX;
};

module.exports = GetOffsetX;


/***/ }),
/* 1040 */
/***/ (function(module, exports) {

/**
* The amount the Game Object is visually offset from its x coordinate.
* This is the same as `width * origin.x`.
* It will only be > 0 if origin.x is not equal to zero.
*
* @property {number} offsetX
* @readOnly
*/

var GetOffsetY = function (gameObject)
{
    return gameObject.height * gameObject.originY;
};

module.exports = GetOffsetY;


/***/ }),
/* 1041 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Utils.Bounds

module.exports = {

    CenterOn: __webpack_require__(257),
    GetBottom: __webpack_require__(21),
    GetCenterX: __webpack_require__(44),
    GetCenterY: __webpack_require__(45),
    GetLeft: __webpack_require__(22),
    GetOffsetX: __webpack_require__(1039),
    GetOffsetY: __webpack_require__(1040),
    GetRight: __webpack_require__(23),
    GetTop: __webpack_require__(24),
    SetBottom: __webpack_require__(25),
    SetCenterX: __webpack_require__(46),
    SetCenterY: __webpack_require__(47),
    SetLeft: __webpack_require__(26),
    SetRight: __webpack_require__(27),
    SetTop: __webpack_require__(28)
    
};


/***/ }),
/* 1042 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(4);
var Clamp = __webpack_require__(52);

var GetMinMaxValue = function (source, key, min, max, defaultValue)
{
    if (defaultValue === undefined) { defaultValue = min; }

    var value = GetValue(source, key, defaultValue);

    return Clamp(value, min, max);
};

module.exports = GetMinMaxValue;


/***/ }),
/* 1043 */
/***/ (function(module, exports, __webpack_require__) {

//  Creates a new Object using all values from obj1.
//  
//  Then scans obj2. If a property is found in obj2 that *also* exists in obj1,
//  the value from obj2 is used, otherwise the property is skipped.

var Clone = __webpack_require__(72);

var MergeRight = function (obj1, obj2)
{
    var clone = Clone(obj1);

    for (var key in obj2)
    {
        if (clone.hasOwnProperty(key))
        {
            clone[key] = obj2[key];
        }
    }

    return clone;
};

module.exports = MergeRight;


/***/ }),
/* 1044 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Utils.Object

module.exports = {

    Clone: __webpack_require__(72),
    Extend: __webpack_require__(73),
    GetAdvancedValue: __webpack_require__(7),
    GetFastValue: __webpack_require__(11),
    GetMinMaxValue: __webpack_require__(1042),
    GetValue: __webpack_require__(4),
    IsPlainObject: __webpack_require__(258),
    Merge: __webpack_require__(115),
    MergeRight: __webpack_require__(1043)

};


/***/ }),
/* 1045 */
/***/ (function(module, exports) {

/**
 * Replaces %1, %2, %3 etc in the String with the values
 * given in the array. Values are cast to strings.
 * If no value exists an empty string is inserted.
 * 
 * @param {string} string - The string containing the markers
 * @param {array} values - An array containing the values to replace the markers with
*/
var Format = function (string, values)
{
    string.replace(/%([0-9]+)/g, function (s, n)
    {
        return values[Number(n) - 1];
    });

    return string;
};

module.exports = Format;


/***/ }),
/* 1046 */
/***/ (function(module, exports) {

/**
* Takes the given string and reverses it, returning the reversed string.
* For example if given the string `Atari 520ST` it would return `TS025 iratA`.
*
* @method Phaser.Utils.reverseString
* @param {string} string - The string to be reversed.
* @return {string} The reversed string.
*/
var ReverseString = function (string)
{
    return string.split('').reverse().join('');
};

module.exports = ReverseString;


/***/ }),
/* 1047 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Pad: __webpack_require__(259),
    Format: __webpack_require__(1045),
    Reverse: __webpack_require__(1046)

};


/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA3YTc1NjRiYzc4MmU5Yjk3YmRmMCIsIndlYnBhY2s6Ly8vLi91dGlscy9DbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzIiwid2VicGFjazovLy8uL2V2ZW50cy9FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9OT09QLmpzIiwid2VicGFjazovLy8uL3V0aWxzL29iamVjdC9HZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RDcmVhdG9yLmpzIiwid2VicGFjazovLy8uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9CdWlsZEdhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvb2JqZWN0L0dldEZhc3RWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L1BvaW50LmpzIiwid2VicGFjazovLy8uL21hdGgvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vdHdlZW4vY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL0NhbnZhc1Bvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2NvbnN0LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvVHJhbnNmb3JtTWF0cml4LmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL1ZlY3RvcjIuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYm91bmRzL0dldEJvdHRvbS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvR2V0TGVmdC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvR2V0UmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYm91bmRzL0dldFRvcC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvU2V0Qm90dG9tLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2JvdW5kcy9TZXRMZWZ0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2JvdW5kcy9TZXRSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvU2V0VG9wLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0RhdGFCdWZmZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9WZWN0b3IzLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL1NjYWxlTW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvRGF0YUJ1ZmZlcjE2LmpzIiwid2VicGFjazovLy8uL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlLmpzIiwid2VicGFjazovLy8uL2dlb20vY2lyY2xlL0NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9BbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL1RyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9CbGVuZE1vZGVzLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2JvdW5kcy9HZXRDZW50ZXJYLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2JvdW5kcy9HZXRDZW50ZXJZLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2JvdW5kcy9TZXRDZW50ZXJYLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2JvdW5kcy9TZXRDZW50ZXJZLmpzIiwid2VicGFjazovLy8uL3NjZW5lL2xvY2FsL1NjZW5lLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9kZXZpY2UvT1MuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9Db250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL0NsYW1wLmpzIiwid2VicGFjazovLy8uL21hdGgvTWF0cml4NC5qcyIsIndlYnBhY2s6Ly8vLi9zdHJ1Y3RzL1NldC5qcyIsIndlYnBhY2s6Ly8vLi9kZXZpY2UvQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9tZXNoL01lc2guanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvc3ByaXRlM2QvU3ByaXRlM0QuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvem9uZS9ab25lLmpzIiwid2VicGFjazovLy8uL2dlb20vY2lyY2xlL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvVmFsdWVUb0NvbG9yLmpzIiwid2VicGFjazovLy8uL2lucHV0L2dhbWVwYWQvZXZlbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL21hdGgvQmV0d2Vlbi5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL1ZlY3RvcjQuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9XcmFwLmpzIiwid2VicGFjazovLy8uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuLmpzIiwid2VicGFjazovLy8uL3BhdGhzL2N1cnZlcy9DdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9DT0xMSURFUy5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9UWVBFLmpzIiwid2VicGFjazovLy8uL3V0aWxzL29iamVjdC9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9vYmplY3QvRXh0ZW5kLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS8yZC9DYW1lcmEuanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL0NhbnZhc0ludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL1Ntb290aGluZy5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZWZmZWN0bGF5ZXIvRWZmZWN0TGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZW1pdHRlci9QYXJ0aWNsZUVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvQ29tbWFuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZ3JvdXAvR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbGlnaHRsYXllci9MaWdodExheWVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3Bvb2wvT2JqZWN0UG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9xdWFkL1F1YWQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvcmVuZGVycGFzcy9SZW5kZXJQYXNzLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZW1hcC9keW5hbWljL1RpbGVtYXAuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZW1hcC9zdGF0aWMvU3RhdGljVGlsZW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlc3ByaXRlL1RpbGVTcHJpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9lbGxpcHNlL0VsbGlwc2UuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL0dldFBvaW50c09uTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kWFkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9Eb3QuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvR2V0QXNwZWN0UmF0aW8uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9Db250YWluc0FycmF5LmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvUm90YXRlQXJvdW5kWFkuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvR2V0Q29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvZ2xvYmFsL2luYy9HZXRUcmFuc2Zvcm1lZFBvaW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2tleXMvS2V5Q29kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL1hIUlNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9maWxldHlwZXMvSlNPTkZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9DYXRtdWxsUm9tLmpzIiwid2VicGFjazovLy8uL21hdGgvRGVnVG9SYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9Sb3RhdGVBcm91bmREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL3BvdzIvSXNTaXplUG93ZXJPZlR3by5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9jb21wb25lbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3Jlc291cmNlcy9WZXJ0ZXhCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9Tb3J0U2NlbmVzLmpzIiwid2VicGFjazovLy8uL3NjZW5lL3BsdWdpbnMvRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9idWlsZGVyL0dldEVhc2VGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9idWlsZGVyL1R3ZWVuQnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9vYmplY3QvTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vd2VicGFjay9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL2luZGV4LmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9pbmMvR2V0RnJhbWVzLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS8zZC9DYW1lcmEzRC5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvM2QvT3J0aG9ncmFwaGljQ2FtZXJhLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS8zZC9QZXJzcGVjdGl2ZUNhbWVyYS5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvY29udHJvbHMvS2V5Q29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvY29udHJvbHMvU21vb3RoZWRLZXlDb250cm9sLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS9sb2NhbC9pbmMvQWRkUGVyc3BlY3RpdmVDYW1lcmEuanMiLCJ3ZWJwYWNrOi8vLy4vY2FudmFzL0dldENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vY3JlYXRlL0dlbmVyYXRlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9jcmVhdGUvcGFsZXR0ZXMvQXJuZTE2LmpzIiwid2VicGFjazovLy8uL2RldmljZS9DYW52YXNGZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi9kZXZpY2UvRmVhdHVyZXMuanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL0FkZFRvRE9NLmpzIiwid2VicGFjazovLy8uL2RvbS9ET01Db250ZW50TG9hZGVkLmpzIiwid2VicGFjazovLy8uL2RvbS9QYXJzZVhNTC5qcyIsIndlYnBhY2s6Ly8vLi9kb20vUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uL2V2ZW50cy9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9CdWlsZEdhbWVPYmplY3RBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9HZXRCaXRtYXBUZXh0U2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L1BhcnNlWE1MQml0bWFwRm9udC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc0NhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2xpZ2h0bGF5ZXIvRm9yd2FyZFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dlb20vY2lyY2xlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvUmFuZG9tLmpzIiwid2VicGFjazovLy8uL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lLmpzIiwid2VicGFjazovLy8uL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L0dldE1hZ25pdHVkZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L0dldE1hZ25pdHVkZVNxLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvTXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9Ob3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9seWdvbi9FYXJjdXQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2x5Z29uL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvQ2VudGVyT24uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvRGVjb21wb3NlLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL01hcmNoaW5nQW50cy5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9QZXJpbWV0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvQ2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9EZWNvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9JbkNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0FkZC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0NvbG9yQnVybi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0NvbG9yRG9kZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9EYXJrZW4uanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaWdodGVuLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyQnVybi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckRvZGdlLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvT3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL1JlZmxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9TdWJ0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL1ZpdmlkTGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvQ29tcG9uZW50VG9IZXguanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvR2V0Q29sb3IzMi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9IU1ZUb1JHQi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9IZXhTdHJpbmdUb0NvbG9yLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL0h1ZVRvQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb0NvbG9yLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb1JHQi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9SR0JTdHJpbmdUb0NvbG9yLmpzIiwid2VicGFjazovLy8uL2lucHV0L0ludGVyYWN0aXZlT2JqZWN0LmpzIiwid2VicGFjazovLy8uL2lucHV0L2dhbWVwYWQvQXhpcy5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9nYW1lcGFkL0J1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9nYW1lcGFkL0dhbWVwYWQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvZ2FtZXBhZC9HYW1lcGFkTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9nbG9iYWwvaW5jL1BvaW50V2l0aGluR2FtZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9LZXlib2FyZE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQvY29tYm8vS2V5Q29tYm8uanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQvY29tYm8vUHJvY2Vzc0tleUNvbWJvLmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2tleXMvS2V5LmpzIiwid2VicGFjazovLy8uL2lucHV0L21vdXNlL01vdXNlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvZmlsZXR5cGVzL1RleHRGaWxlLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9maWxldHlwZXMvWE1MRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL0Jlcm5zdGVpbi5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL0ZhY3RvcmlhbC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL0xpbmVhci5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL01hdHJpeDMuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9RdWF0ZXJuaW9uLmpzIiwid2VicGFjazovLy8uL21hdGgvUmFuZG9tWFlaLmpzIiwid2VicGFjazovLy8uL21hdGgvUmFuZG9tWFlaVy5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL1JvdGF0ZVZlYzMuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9Sb3VuZEF3YXlGcm9tWmVyby5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL1Ntb290aFN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9TbW9vdGhlclN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9hbmdsZS9Ob3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9hbmdsZS9XcmFwLmpzIiwid2VicGFjazovLy8uL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9lYXNpbmcvQmFjay5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Vhc2luZy9Cb3VuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9lYXNpbmcvQ2lyY3VsYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9lYXNpbmcvQ3ViaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9lYXNpbmcvRWxhc3RpYy5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Vhc2luZy9FeHBvLmpzIiwid2VicGFjazovLy8uL21hdGgvZWFzaW5nL0xpbmVhci5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Vhc2luZy9RdWFkcmF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9lYXNpbmcvUXVhcnRpYy5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Vhc2luZy9RdWludGljLmpzIiwid2VicGFjazovLy8uL21hdGgvZWFzaW5nL1NpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9lYXNpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9pbnRlcnBvbGF0aW9uL0N1YmljQmV6aWVySW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2ludGVycG9sYXRpb24vTGluZWFySW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL3BvdzIvR2V0UG93ZXJPZlR3by5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL3JhbmRvbS1kYXRhLWdlbmVyYXRvci9SYW5kb21EYXRhR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL3BhdGhzL2N1cnZlcy9saW5lL0xpbmVDdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9XZWJHTFN1cHBvcnRlZEV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3RpbGVtYXByZW5kZXJlci9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvbG9jYWwvU3lzdGVtcy5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9wbHVnaW5zL0Rpc3BsYXlMaXN0LmpzIiwid2VicGFjazovLy8uL3N0cnVjdHMvTWFwLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL2J1aWxkZXIvR2V0Qm9vbGVhbi5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9idWlsZGVyL0dldE5ld1ZhbHVlLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL2J1aWxkZXIvR2V0VGFyZ2V0cy5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi90d2Vlbi9EZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9JbkJvdHRvbUNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9JbkJvdHRvbUxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWxpZ24vSW5Cb3R0b21SaWdodC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9JbkNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9JbkxlZnRDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWxpZ24vSW5SaWdodENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9JblRvcENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9JblRvcExlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWxpZ24vSW5Ub3BSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hcnJheS9OdW1iZXJBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hcnJheS9RdWlja1NlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hcnJheS9SYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hcnJheS9Sb3RhdGVMZWZ0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FycmF5L1JvdGF0ZVJpZ2h0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FycmF5L1NodWZmbGUuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYXJyYXkvU3BsaWNlT25lLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FycmF5L1N0YWJsZVNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYm91bmRzL0NlbnRlck9uLmpzIiwid2VicGFjazovLy8uL3V0aWxzL29iamVjdC9Jc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL3N0cmluZy9QYWQuanMiLCJ3ZWJwYWNrOi8vLy4vYm9vdC9HYW1lLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jcmVhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL2luZGV4LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2dlb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYXRocy9jdXJ2ZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGF0aHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGxzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NvdW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL3N0cnVjdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9BbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL0NhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9HZXRGaXJzdC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL0dyaWRBbGlnbi5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL0luY0FscGhhLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvSW5jWC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL0luY1hZLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvSW5jWS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1BsYWNlT25DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9QbGFjZU9uRWxsaXBzZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1BsYWNlT25MaW5lLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUGxhY2VPblJlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1BsYWNlT25UcmlhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1BsYXlBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9SYW5kb21DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9SYW5kb21FbGxpcHNlLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUmFuZG9tTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1JhbmRvbVJlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1JhbmRvbVRyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUm90YXRlLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUm90YXRlQXJvdW5kLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUm90YXRlQXJvdW5kRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TY2FsZVguanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TY2FsZVhZLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU2NhbGVZLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU2V0QWxwaGEuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TZXRCbGVuZE1vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TZXREZXB0aC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1NldEhpdEFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TZXRPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TZXRSb3RhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1NldFNjYWxlLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU2V0U2NhbGVYLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU2V0U2NhbGVZLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU2V0VmlzaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1NldFguanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TZXRYWS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1NldFkuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TaGlmdFBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU21vb3RoU3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1Ntb290aGVyU3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1NwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1RvZ2dsZVZpc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL2ZyYW1lL0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvaW5jL0FkZEZyYW1lLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9pbmMvQWRkRnJhbWVBdC5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvaW5jL0NoZWNrRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL2ZyYW1lL2luYy9Db21wbGV0ZUFuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvaW5jL0ZyYW1lLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9pbmMvR2V0Rmlyc3RUaWNrLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9pbmMvR2V0RnJhbWVBdC5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvaW5jL0dldE5leHRUaWNrLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9pbmMvTG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvaW5jL05leHRGcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvaW5jL1ByZXZpb3VzRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL2ZyYW1lL2luYy9SZW1vdmVGcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvaW5jL1JlbW92ZUZyYW1lQXQuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL2ZyYW1lL2luYy9SZXBlYXRBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL2ZyYW1lL2luYy9TZXRGcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvaW5jL1RvSlNPTi5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvaW5jL1VwZGF0ZUZyYW1lU2VxdWVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvQW5pbWF0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vbWFuYWdlci9ldmVudHMvQWRkQW5pbWF0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvZXZlbnRzL1BhdXNlQWxsQW5pbWF0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvZXZlbnRzL1JlbW92ZUFuaW1hdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2V2ZW50cy9SZXN1bWVBbGxBbmltYXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vbWFuYWdlci9pbmMvQWRkQW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2luYy9DcmVhdGVGcmFtZUFuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vbWFuYWdlci9pbmMvRnJvbUpTT04uanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvaW5jL0dlbmVyYXRlRnJhbWVOYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vbWFuYWdlci9pbmMvR2VuZXJhdGVGcmFtZU51bWJlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvaW5jL0dldEFuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vbWFuYWdlci9pbmMvTG9hZEFuaW1hdGlvblRvR2FtZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vbWFuYWdlci9pbmMvUGF1c2VBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvaW5jL1BsYXlBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvaW5jL1JlbW92ZUFuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vbWFuYWdlci9pbmMvUmVzdW1lQWxsLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2luYy9TdGFnZ2VyUGxheUFuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vbWFuYWdlci9pbmMvVG9KU09OLmpzIiwid2VicGFjazovLy8uL2Jvb3QvQ29uZmlnLmpzIiwid2VicGFjazovLy8uL2Jvb3QvQ3JlYXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYm9vdC9EZWJ1Z0hlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ib290L1RpbWVTdGVwLmpzIiwid2VicGFjazovLy8uL2Jvb3QvVmlzaWJpbGl0eUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY2FjaGUvQmFzZUNhY2hlLmpzIiwid2VicGFjazovLy8uL2NhY2hlL0dsb2JhbENhY2hlLmpzIiwid2VicGFjazovLy8uL2NhY2hlL2V2ZW50cy9DYWNoZUFkZEV2ZW50LmpzIiwid2VicGFjazovLy8uL2NhY2hlL2V2ZW50cy9DYWNoZVJlbW92ZUV2ZW50LmpzIiwid2VicGFjazovLy8uL2NhY2hlL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvMmQvaW5jL0NhbWVyYVRvU2NyZWVuLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS8yZC9pbmMvQ2VudGVyVG9Cb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9DZW50ZXJUb1NpemUuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9DdWxsLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS8yZC9pbmMvQ3VsbEhpdFRlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9DdWxsVGlsZW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvMmQvaW5jL0Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9GYWRlLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS8yZC9pbmMvRmxhc2guanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9JZ25vcmUuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9QcmVSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9SZW1vdmVCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9TZXRCYWNrZ3JvdW5kQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9TZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9TZXROYW1lLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS8yZC9pbmMvU2V0UG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9TZXRSb3RhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvMmQvaW5jL1NldFJvdW5kUGl4ZWxzLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS8yZC9pbmMvU2V0U2NlbmUuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9TZXRTY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9TZXRTaXplLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS8yZC9pbmMvU2V0Vmlld3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9TZXRab29tLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS8yZC9pbmMvU2hha2UuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9TdGFydEZvbGxvdy5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvMmQvaW5jL1N0b3BGb2xsb3cuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9Ub0pTT04uanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhLzJkL2luYy9VcGRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhL2xvY2FsL0NhbWVyYU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhL2xvY2FsL2luYy9BZGQyRENhbWVyYS5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvbG9jYWwvaW5jL0FkZEV4aXN0aW5nLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS9sb2NhbC9pbmMvQWRkS2V5Q29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvbG9jYWwvaW5jL0FkZE9ydGhvZ3JhcGhpY0NhbWVyYS5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvbG9jYWwvaW5jL0FkZFNtb290aGVkS2V5Q29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvbG9jYWwvaW5jL0Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4vY2FtZXJhL2xvY2FsL2luYy9Gcm9tSlNPTi5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvbG9jYWwvaW5jL0dldENhbWVyYUJlbG93UG9pbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvbG9jYWwvaW5jL1JlbW92ZUNhbWVyYS5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvbG9jYWwvaW5jL1JlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvbG9jYWwvaW5jL1Jlc2V0QWxsLmpzIiwid2VicGFjazovLy8uL2NhbWVyYS9sb2NhbC9pbmMvVXBkYXRlLmpzIiwid2VicGFjazovLy8uL2NoZWNrc3VtLmpzIiwid2VicGFjazovLy8uL2NyZWF0ZS9HcmlkLmpzIiwid2VicGFjazovLy8uL2NyZWF0ZS9wYWxldHRlcy9DNjQuanMiLCJ3ZWJwYWNrOi8vLy4vY3JlYXRlL3BhbGV0dGVzL0NHQS5qcyIsIndlYnBhY2s6Ly8vLi9jcmVhdGUvcGFsZXR0ZXMvSk1QLmpzIiwid2VicGFjazovLy8uL2NyZWF0ZS9wYWxldHRlcy9NU1guanMiLCJ3ZWJwYWNrOi8vLy4vY3JlYXRlL3BhbGV0dGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2RldmljZS9BdWRpby5qcyIsIndlYnBhY2s6Ly8vLi9kZXZpY2UvRnVsbHNjcmVlbi5qcyIsIndlYnBhY2s6Ly8vLi9kZXZpY2UvSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2aWNlL1ZpZGVvLmpzIiwid2VicGFjazovLy8uL2RldmljZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9kb20vQWRkRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9kb20vUmVtb3ZlRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9kb20vUmVtb3ZlRnJvbURPTS5qcyIsIndlYnBhY2s6Ly8vLi9kb20vVG91Y2hBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL1VzZXJTZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vZXZlbnRzL0V2ZW50QmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ldmVudHMvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L1BhcnNlRnJvbUF0bGFzLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvUGFyc2VSZXRyb0ZvbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0Q3JlYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dFJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0Q3JlYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0UmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlckNhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlckNyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JvYi5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL0FscGhhLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvQW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvQmxlbmRNb2RlLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvQ29tcHV0ZWRTaXplLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvRGF0YVByb3h5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvRmxpcC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL0dldEJvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL09yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1JlbmRlclRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1NjYWxlTW9kZS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1Njcm9sbEZhY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1NpemUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9UZXh0dXJlLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvVGludC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1RvSlNPTi5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1Zpc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vRGVsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vRGVsYXllZFBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vR2V0Q3VycmVudEtleS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9Mb2FkLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL1BhdXNlLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL1BhdXNlZC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9QbGF5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL1Byb2dyZXNzLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL1JlbW92ZS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9SZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vUmVwZWF0RGVsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vUmVzdGFydC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9SZXN1bWUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vU3RvcC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9UaW1lU2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vVG90YWxGcmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vVG90YWxQcm9ncmVzcy5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9VcGRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vVXBkYXRlRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vWW95by5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9lZmZlY3RsYXllci9FZmZlY3RMYXllckNhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2VmZmVjdGxheWVyL0VmZmVjdExheWVyQ3JlYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9lZmZlY3RsYXllci9FZmZlY3RMYXllckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZWZmZWN0bGF5ZXIvRWZmZWN0TGF5ZXJSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZWZmZWN0bGF5ZXIvRWZmZWN0TGF5ZXJXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2VtaXR0ZXIvUGFydGljbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZW1pdHRlci9QYXJ0aWNsZUVtaXR0ZXJDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9lbWl0dGVyL1BhcnRpY2xlRW1pdHRlckNyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZW1pdHRlci9QYXJ0aWNsZUVtaXR0ZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2VtaXR0ZXIvUGFydGljbGVFbWl0dGVyUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2VtaXR0ZXIvUGFydGljbGVFbWl0dGVyV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc0NyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9ncm91cC9Hcm91cENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZ3JvdXAvR3JvdXBGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VDcmVhdG9yLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZVJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZVdlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbGlnaHRsYXllci9Db25zdC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9saWdodGxheWVyL0RlZmVycmVkUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbGlnaHRsYXllci9MaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9saWdodGxheWVyL0xpZ2h0TGF5ZXJDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9saWdodGxheWVyL0xpZ2h0TGF5ZXJDcmVhdG9yLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2xpZ2h0bGF5ZXIvTGlnaHRMYXllckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbGlnaHRsYXllci9MaWdodExheWVyUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2xpZ2h0bGF5ZXIvTGlnaHRMYXllcldlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbGlnaHRsYXllci9TcHJpdGVOb3JtYWxQYWlyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL21lc2gvTWVzaENhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL21lc2gvTWVzaENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbWVzaC9NZXNoRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9tZXNoL01lc2hSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbWVzaC9NZXNoV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9wb29sL1Nwcml0ZVBvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvcXVhZC9RdWFkQ3JlYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9xdWFkL1F1YWRGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3JlbmRlcnBhc3MvUmVuZGVyUGFzc0NhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3JlbmRlcnBhc3MvUmVuZGVyUGFzc0NyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvcmVuZGVycGFzcy9SZW5kZXJQYXNzRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9yZW5kZXJwYXNzL1JlbmRlclBhc3NSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvcmVuZGVycGFzcy9SZW5kZXJQYXNzV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9zcHJpdGUzZC9TcHJpdGUzRENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvc3ByaXRlM2QvU3ByaXRlM0RGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlQ3JlYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RleHQvR2V0VGV4dFNpemUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGV4dC9NZWFzdXJlVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90ZXh0L1RleHRTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0Q2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dFJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0V2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL2R5bmFtaWMvVGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL2R5bmFtaWMvVGlsZW1hcENhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RpbGVtYXAvZHluYW1pYy9UaWxlbWFwQ3JlYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL2R5bmFtaWMvVGlsZW1hcEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZW1hcC9keW5hbWljL1RpbGVtYXBSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZW1hcC9keW5hbWljL1RpbGVtYXBXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RpbGVtYXAvc3RhdGljL1N0YXRpY1RpbGVtYXBDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwQ3JlYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RpbGVtYXAvc3RhdGljL1N0YXRpY1RpbGVtYXBXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RpbGVzcHJpdGUvVGlsZVNwcml0ZUNhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RpbGVzcHJpdGUvVGlsZVNwcml0ZUNyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZXNwcml0ZS9UaWxlU3ByaXRlRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlc3ByaXRlL1RpbGVTcHJpdGVSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZXNwcml0ZS9UaWxlU3ByaXRlV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy96b25lL1pvbmVDcmVhdG9yLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3pvbmUvWm9uZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9jaXJjbGUvQXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9DaXJjdW1mZXJlbmNlLmpzIiwid2VicGFjazovLy8uL2dlb20vY2lyY2xlL0NpcmN1bWZlcmVuY2VQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy8uL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9jaXJjbGUvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy8uL2dlb20vY2lyY2xlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9PZmZzZXRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvQXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvQ2lyY3VtZmVyZW5jZVBvaW50LmpzIiwid2VicGFjazovLy8uL2dlb20vZWxsaXBzZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy8uL2dlb20vZWxsaXBzZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvRXF1YWxzLmpzIiwid2VicGFjazovLy8uL2dlb20vZWxsaXBzZS9HZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9lbGxpcHNlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvT2Zmc2V0UG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9lbGxpcHNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbnRlcnNlY3RzL0dldFJlY3RhbmdsZUludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZVNlZ21lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvVHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvVmFsdWVzLmpzIiwid2VicGFjazovLy8uL2dlb20vaW50ZXJzZWN0cy9UcmlhbmdsZVRvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL2dlb20vaW50ZXJzZWN0cy9UcmlhbmdsZVRvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2ludGVyc2VjdHMvVHJpYW5nbGVUb1RyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL2dlb20vaW50ZXJzZWN0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvQ2VudGVyT24uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL0Nsb25lLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvRXF1YWxzLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9HZXRNaWRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvR2V0Tm9ybWFsLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9HZXRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvSGVpZ2h0LmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9MZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL05vcm1hbFguanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL05vcm1hbFkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvUGVycFNsb3BlLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9SZWZsZWN0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL1NldFRvQW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL1Nsb3BlLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9XaWR0aC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9BZGQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9DZWlsLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L0Nyb3NzLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvRGl2aWRlLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvRXF1YWxzLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9HZXRDZW50cm9pZC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L0ludGVycG9sYXRlLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvSW52ZXJ0LmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvTmVnYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9Ob3JtYWxpemVSaWdodEhhbmQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9QZXJwLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvUHJvamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L1Byb2plY3RVbml0LmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvUlBlcnAuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9TZXRNYWduaXR1ZGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9TdWJ0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL2dlb20vcG9seWdvbi9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvbHlnb24vR2V0QUFCQi5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvbHlnb24vR2V0TnVtYmVyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2x5Z29uL2luZGV4LmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvQ2VpbC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9DZWlsQWxsLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0Nsb25lLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0NvcHlGcm9tLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9GaXRJbnNpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvRml0T3V0c2lkZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9GbG9vci5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9GbG9vckFsbC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9HZXRDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvR2V0U2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9JbmZsYXRlLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL01lcmdlUG9pbnRzLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL01lcmdlUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVhZLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9PZmZzZXRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9PdmVybGFwcy5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9QZXJpbWV0ZXJQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9TY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9Vbmlvbi5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9CdWlsZEVxdWlsYXRlcmFsLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvQnVpbGRGcm9tUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL0J1aWxkUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9DZW50ZXJPbi5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL0NpcmN1bUNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL0NpcmN1bUNpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL0Nsb25lLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL0NvcHlGcm9tLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvRXF1YWxzLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvUm90YXRlLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0F2ZXJhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9EaWZmZXJlbmNlLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvRXhjbHVzaW9uLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvR2xvdy5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0hhcmRMaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0hhcmRNaXguanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaW5lYXJMaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL011bHRpcGx5LmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTmVnYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9Ob3JtYWwuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9QaG9lbml4LmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvUGluTGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9TY3JlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9Tb2Z0TGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9DU1NUb0NvbG9yLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL0NvbG9yVG9SR0JBLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL0hTTFRvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvSFNWQ29sb3JXaGVlbC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9JbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9SR0JUb0hTVi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9SR0JUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9SYW5kb21SR0IuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvUG9pbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9nYW1lcGFkL2NvbmZpZ3MvU05FU19VU0JfQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9nYW1lcGFkL2NvbmZpZ3MvU29ueV9QbGF5U3RhdGlvbl9EdWFsU2hvY2tfNC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9nYW1lcGFkL2NvbmZpZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvZ2FtZXBhZC9ldmVudHMvR2FtZXBhZENvbm5lY3RlZEV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2dhbWVwYWQvZXZlbnRzL0dhbWVwYWREaXNjb25uZWN0ZWRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9nYW1lcGFkL2V2ZW50cy9HYW1lcGFkRG93bkV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2dhbWVwYWQvZXZlbnRzL0dhbWVwYWRVcEV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2dhbWVwYWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvZ2xvYmFsL0dsb2JhbElucHV0TWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9nbG9iYWwvaW5jL0hpdFRlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvZ2xvYmFsL2luYy9Qb2ludFNjcmVlblRvV29ybGRIaXRUZXN0LmpzIiwid2VicGFjazovLy8uL2lucHV0L2dsb2JhbC9pbmMvUG9pbnRXaXRoaW5IaXRBcmVhLmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2NvbWJvL0FkdmFuY2VLZXlDb21iby5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9jb21iby9LZXlDb21ib01hdGNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQvY29tYm8vUmVzZXRLZXlDb21iby5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9ldmVudHMvS2V5RG93bkV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2V2ZW50cy9LZXlVcEV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9rZXlzL0Rvd25EdXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9rZXlzL0p1c3REb3duLmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2tleXMvSnVzdFVwLmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2tleXMvUHJvY2Vzc0tleURvd24uanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQva2V5cy9Qcm9jZXNzS2V5VXAuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQva2V5cy9VcER1cmF0aW9uLmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL1NjZW5lSW5wdXRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9EcmFnRW5kRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvZXZlbnRzL0RyYWdFbnRlckV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9EcmFnRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvZXZlbnRzL0RyYWdMZWF2ZUV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9EcmFnT3ZlckV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9EcmFnU3RhcnRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9ldmVudHMvRHJvcEV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9HYW1lT2JqZWN0RG93bkV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9HYW1lT2JqZWN0TW92ZUV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9HYW1lT2JqZWN0T3V0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvZXZlbnRzL0dhbWVPYmplY3RPdmVyRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvZXZlbnRzL0dhbWVPYmplY3RVcEV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9Qb2ludGVyRG93bkV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9Qb2ludGVyTW92ZUV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2V2ZW50cy9Qb2ludGVyT3V0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvZXZlbnRzL1BvaW50ZXJPdmVyRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvZXZlbnRzL1BvaW50ZXJVcEV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2luYy9CZWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9pbmMvQm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9pbmMvQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL0Rpc2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL0VuYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9pbmMvSGl0VGVzdFBvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1Byb2Nlc3NEb3duRXZlbnRzLmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2luYy9Qcm9jZXNzRHJhZ0V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9pbmMvUHJvY2Vzc01vdmVFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1Byb2Nlc3NPdmVyT3V0RXZlbnRzLmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2luYy9Qcm9jZXNzVXBFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1F1ZXVlRm9ySW5zZXJ0aW9uLmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2luYy9RdWV1ZUZvclJlbW92YWwuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NldENhbGxiYWNrLmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2luYy9TZXRDYWxsYmFja3MuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NldERyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9pbmMvU2V0SGl0QXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9pbmMvU2V0SGl0QXJlYUNpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9pbmMvU2V0SGl0QXJlYUVsbGlwc2UuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NldEhpdEFyZWFGcm9tVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9pbmMvU2V0SGl0QXJlYVJlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9pbmMvU2V0SGl0QXJlYVRyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2luYy9TZXRPbkRvd25DYWxsYmFjay5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9sb2NhbC9pbmMvU2V0T25Nb3ZlQ2FsbGJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NldE9uT3V0Q2FsbGJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NldE9uT3ZlckNhbGxiYWNrLmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2luYy9TZXRPblVwQ2FsbGJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NldFBvbGxBbHdheXMuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NldFBvbGxPbk1vdmUuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NldFBvbGxSYXRlLmpzIiwid2VicGFjazovLy8uL2lucHV0L2xvY2FsL2luYy9Tb3J0R2FtZU9iamVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NvcnRIYW5kbGVyR08uanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NvcnRIYW5kbGVySU8uanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1NvcnRJbnRlcmFjdGl2ZU9iamVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbG9jYWwvaW5jL1VwZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9tb3VzZS9ldmVudHMvTW91c2VEb3duRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbW91c2UvZXZlbnRzL01vdXNlTW92ZUV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L21vdXNlL2V2ZW50cy9Nb3VzZVVwRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbW91c2UvZXZlbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2lucHV0L21vdXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL2lucHV0L3RvdWNoL1RvdWNoTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvQmFzZUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvR2V0VVJMLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9YSFJMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2V2ZW50cy9Mb2FkZXJDb21wbGV0ZUV2ZW50LmpzIiwid2VicGFjazovLy8uL2xvYWRlci9ldmVudHMvTG9hZGVyU3RhcnRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvZXZlbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2xvYWRlci9maWxldHlwZXMvQW5pbWF0aW9uSlNPTkZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2ZpbGV0eXBlcy9BdGxhc0pTT05GaWxlLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9maWxldHlwZXMvQmluYXJ5RmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvZmlsZXR5cGVzL0JpdG1hcEZvbnRGaWxlLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2ZpbGV0eXBlcy9IVE1MRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvZmlsZXR5cGVzL1NWR0ZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2ZpbGV0eXBlcy9TY3JpcHRGaWxlLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9maWxldHlwZXMvU3ByaXRlU2hlZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2ZpbGV0eXBlcy9Vbml0eUF0bGFzRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL0F2ZXJhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9DZWlsVG8uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9EaWZmZXJlbmNlLmpzIiwid2VicGFjazovLy8uL21hdGgvRmxvYXRCZXR3ZWVuLmpzIiwid2VicGFjazovLy8uL21hdGgvRmxvb3JUby5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL0dldFNwZWVkLmpzIiwid2VicGFjazovLy8uL21hdGgvSXNFdmVuLmpzIiwid2VicGFjazovLy8uL21hdGgvSXNFdmVuU3RyaWN0LmpzIiwid2VicGFjazovLy8uL21hdGgvTWF4QWRkLmpzIiwid2VicGFjazovLy8uL21hdGgvTWluU3ViLmpzIiwid2VicGFjazovLy8uL21hdGgvUGVyY2VudC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL1JhZFRvRGVnLmpzIiwid2VicGFjazovLy8uL21hdGgvUmFuZG9tWFkuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9Sb3RhdGVBcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9Sb3VuZFRvLmpzIiwid2VicGFjazovLy8uL21hdGgvU2luQ29zVGFibGVHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9XaXRoaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9hbmdsZS9CZXR3ZWVuLmpzIiwid2VicGFjazovLy8uL21hdGgvYW5nbGUvQmV0d2VlblBvaW50cy5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2FuZ2xlL0JldHdlZW5Qb2ludHNZLmpzIiwid2VicGFjazovLy8uL21hdGgvYW5nbGUvQmV0d2VlblkuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9hbmdsZS9SZXZlcnNlLmpzIiwid2VicGFjazovLy8uL21hdGgvYW5nbGUvUm90YXRlVG8uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9hbmdsZS9TaG9ydGVzdEJldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9hbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlUG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZVNxdWFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Vhc2luZy9FYXNlTWFwLmpzIiwid2VicGFjazovLy8uL21hdGgvZnV6enkvQ2VpbC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Z1enp5L0VxdWFsLmpzIiwid2VicGFjazovLy8uL21hdGgvZnV6enkvRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9mdXp6eS9HcmVhdGVyVGhhbi5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Z1enp5L0xlc3NUaGFuLmpzIiwid2VicGFjazovLy8uL21hdGgvZnV6enkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9pbnRlcnBvbGF0aW9uL0JlemllckludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9pbnRlcnBvbGF0aW9uL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy8uL21hdGgvaW50ZXJwb2xhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL3BvdzIvSXNWYWx1ZVBvd2VyT2ZUd28uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9wb3cyL2luZGV4LmpzIiwid2VicGFjazovLy8uL21hdGgvc25hcC9TbmFwQ2VpbC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL3NuYXAvU25hcEZsb29yLmpzIiwid2VicGFjazovLy8uL21hdGgvc25hcC9TbmFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9zbmFwL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhdGhzL1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vcGF0aHMvY3VydmVzL2N1YmljYmV6aWVyL0N1YmljQmV6aWVyQ3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vcGF0aHMvY3VydmVzL2VsbGlwc2UvRWxsaXBzZUN1cnZlLmpzIiwid2VicGFjazovLy8uL3BhdGhzL2N1cnZlcy9zcGxpbmUvU3BsaW5lQ3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vcGhhc2VyLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L0JvZHkuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9pbXBhY3QvQ29sbGlzaW9uTWFwLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L0RlZmF1bHREZWZzLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9pbXBhY3QvR2V0VmVsb2NpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9pbXBhY3QvSW1wYWN0LmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L0ltcGFjdEJvZHkuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9pbXBhY3QvSW1wYWN0SW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9pbXBhY3QvSW1wYWN0U3ByaXRlLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L1NlcGVyYXRlWC5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9TZXBlcmF0ZVkuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9pbXBhY3QvU29sdmVyLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L1VwZGF0ZU1vdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9Xb3JsZC5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9jb21wb25lbnRzL0FjY2VsZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9jb21wb25lbnRzL0JvZHlTY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9jb21wb25lbnRzL0JvZHlUeXBlLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvQm91bmNlLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvQ2hlY2tBZ2FpbnN0LmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvQ29sbGlkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9pbXBhY3QvY29tcG9uZW50cy9EZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9jb21wb25lbnRzL0ZyaWN0aW9uLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvR3Jhdml0eS5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9jb21wb25lbnRzL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9jb21wb25lbnRzL1NldEdhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9pbXBhY3QvY29tcG9uZW50cy9WZWxvY2l0eS5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9ldmVudHMvQ29sbGlkZUV2ZW50LmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wb2x5ZmlsbHMvQXJyYXkuZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9wb2x5ZmlsbHMvQXJyYXkuaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9wb2x5ZmlsbHMvQXVkaW9Db250ZXh0TW9ua2V5UGF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGxzL0Z1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGxzL01hdGgudHJ1bmMuanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGxzL1VpbnQzMkFycmF5LmpzIiwid2VicGFjazovLy8uL3BvbHlmaWxscy9jb25zb2xlLmpzIiwid2VicGFjazovLy8uL3BvbHlmaWxscy9wZXJmb3JtYW5jZS5ub3cuanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0JsaXRJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9jYW52YXMvdXRpbHMvRHJhd0ltYWdlLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL2NhbnZhcy91dGlscy9HZXRCbGVuZE1vZGVzLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3NuYXBzaG90L0NhbnZhc1NuYXBzaG90LmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3NuYXBzaG90L1dlYkdMU25hcHNob3QuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvUmVzb3VyY2VNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL2JsaXR0ZXJiYXRjaC9CbGl0dGVyQmF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL2JsaXR0ZXJiYXRjaC9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvZWZmZWN0cmVuZGVyZXIvRWZmZWN0UmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL2VmZmVjdHJlbmRlcmVyL2NvbnN0LmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9wYXJ0aWNsZXJlbmRlcmVyL1BhcnRpY2xlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3BhcnRpY2xlcmVuZGVyZXIvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3F1YWRiYXRjaC9RdWFkQmF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3F1YWRiYXRjaC9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvc2hhcGViYXRjaC9TaGFwZUJhdGNoLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9zaGFwZWJhdGNoL2NvbnN0LmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9zcHJpdGViYXRjaC9TcHJpdGVCYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvc3ByaXRlYmF0Y2gvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3RpbGViYXRjaC9UaWxlQmF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3RpbGViYXRjaC9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvdGlsZW1hcHJlbmRlcmVyL1RpbGVtYXBSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvSW5kZXhCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVzb3VyY2VzL1JlbmRlclRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvU2hhZGVyLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3Jlc291cmNlcy9UZXh0dXJlLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvR0J1ZmZlclNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0xpZ2h0RnJhZ21lbnRTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9QYXJ0aWNsZVNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1Bob25nMkRTaGFkZXJEZWZlcnJlZC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1RleHR1cmVkQW5kQWxwaGFTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9UaWxlbWFwU2hhZGVyLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVW50ZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9VbnRleHR1cmVkQW5kVGludGVkU2hhZGVyLmpzIiwid2VicGFjazovLy8uL3NjZW5lL2NvbnN0LmpzIiwid2VicGFjazovLy8uL3NjZW5lL2dsb2JhbC9HbG9iYWxTY2VuZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9BZGQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9Cb290LmpzIiwid2VicGFjazovLy8uL3NjZW5lL2dsb2JhbC9pbmMvQm9vdFNjZW5lLmpzIiwid2VicGFjazovLy8uL3NjZW5lL2dsb2JhbC9pbmMvQnJpbmdUb1RvcC5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL0NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL0NyZWF0ZVNjZW5lRGlzcGxheS5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL0NyZWF0ZVNjZW5lRnJvbUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL3NjZW5lL2dsb2JhbC9pbmMvQ3JlYXRlU2NlbmVGcm9tSW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9DcmVhdGVTY2VuZUZyb21PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9HZXRBY3RpdmVTY2VuZS5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL0dldEFjdGl2ZVNjZW5lSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9HZXRBY3RpdmVTY2VuZUluZGV4QnlLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9HZXRLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9HZXRTY2VuZS5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL0dldFNjZW5lQXQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9HZXRTY2VuZUluZGV4LmpzIiwid2VicGFjazovLy8uL3NjZW5lL2dsb2JhbC9pbmMvR2V0U2NlbmVJbmRleEJ5S2V5LmpzIiwid2VicGFjazovLy8uL3NjZW5lL2dsb2JhbC9pbmMvSXNBY3RpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9Jc1NsZWVwaW5nLmpzIiwid2VicGFjazovLy8uL3NjZW5lL2dsb2JhbC9pbmMvTG9hZENvbXBsZXRlLmpzIiwid2VicGFjazovLy8uL3NjZW5lL2dsb2JhbC9pbmMvTW92ZURvd24uanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9Nb3ZlVXAuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9QYXVzZS5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL1BheWxvYWRDb21wbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL1Jlc3VtZS5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL1NlbmRUb0JhY2suanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9TZXR1cENhbGxiYWNrcy5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL1NsZWVwLmpzIiwid2VicGFjazovLy8uL3NjZW5lL2dsb2JhbC9pbmMvU3RhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvZ2xvYmFsL2luYy9TdG9wLmpzIiwid2VicGFjazovLy8uL3NjZW5lL2dsb2JhbC9pbmMvU3dhcC5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL1N3YXBQb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9nbG9iYWwvaW5jL1dha2UuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvbG9jYWwvSW5qZWN0aW9uTWFwLmpzIiwid2VicGFjazovLy8uL3NjZW5lL2xvY2FsL1NldHRpbmdzLmpzIiwid2VicGFjazovLy8uL3NjZW5lL3BsdWdpbnMvRGF0YVN0b3JlLmpzIiwid2VicGFjazovLy8uL3NjZW5lL3BsdWdpbnMvSW5wdXRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NjZW5lL3BsdWdpbnMvTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NjZW5lL3BsdWdpbnMvUGh5c2ljc01hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc2NlbmUvcGx1Z2lucy9Qb29sTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9wbHVnaW5zL1NjZW5lTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9zY2VuZS9wbHVnaW5zL1VwZGF0ZUxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc291bmQvZHluYW1pYy9GWC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VuZC9keW5hbWljL2luZGV4LmpzIiwid2VicGFjazovLy8uL3N0cnVjdHMvUlRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vdGV4dHVyZXMvRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vdGV4dHVyZXMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi90ZXh0dXJlcy9UZXh0dXJlU291cmNlLmpzIiwid2VicGFjazovLy8uL3RleHR1cmVzL3BhcnNlcnMvQ2FudmFzLmpzIiwid2VicGFjazovLy8uL3RleHR1cmVzL3BhcnNlcnMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGV4dHVyZXMvcGFyc2Vycy9KU09OQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vdGV4dHVyZXMvcGFyc2Vycy9KU09OSGFzaC5qcyIsIndlYnBhY2s6Ly8vLi90ZXh0dXJlcy9wYXJzZXJzL1B5eGVsLmpzIiwid2VicGFjazovLy8uL3RleHR1cmVzL3BhcnNlcnMvU3ByaXRlU2hlZXQuanMiLCJ3ZWJwYWNrOi8vLy4vdGV4dHVyZXMvcGFyc2Vycy9TcHJpdGVTaGVldEZyb21BdGxhcy5qcyIsIndlYnBhY2s6Ly8vLi90ZXh0dXJlcy9wYXJzZXJzL1N0YXJsaW5nWE1MLmpzIiwid2VicGFjazovLy8uL3RleHR1cmVzL3BhcnNlcnMvVW5pdHlZQU1MLmpzIiwid2VicGFjazovLy8uL3RleHR1cmVzL3BhcnNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vdGltZS9DbG9jay5qcyIsIndlYnBhY2s6Ly8vLi90aW1lL1RpbWVyRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vYnVpbGRlci9HZXRQcm9wcy5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9idWlsZGVyL0dldFR3ZWVucy5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9idWlsZGVyL0dldFZhbHVlT3AuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vYnVpbGRlci9UaW1lbGluZUJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vbWFuYWdlci9Ud2Vlbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vbWFuYWdlci9pbmMvRGVzdHJveS5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9tYW5hZ2VyL2luYy9FYWNoLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL21hbmFnZXIvaW5jL0dldEFsbFR3ZWVucy5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9tYW5hZ2VyL2luYy9HZXRHbG9iYWxUaW1lU2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vbWFuYWdlci9pbmMvR2V0VHdlZW5zT2YuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vbWFuYWdlci9pbmMvSXNUd2VlbmluZy5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9tYW5hZ2VyL2luYy9LaWxsQWxsLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL21hbmFnZXIvaW5jL0tpbGxUd2VlbnNPZi5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9tYW5hZ2VyL2luYy9QYXVzZUFsbC5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9tYW5hZ2VyL2luYy9SZXN1bWVBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vbWFuYWdlci9pbmMvU2V0R2xvYmFsVGltZVNjYWxlLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL21hbmFnZXIvaW5jL1NodXRkb3duLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL3RpbWVsaW5lL1RpbWVsaW5lLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL3R3ZWVuL1Jlc2VydmVkUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vdHdlZW4vVHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vdHdlZW4vVHdlZW5EYXRhLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL3R3ZWVuL2luYy9DYWxjRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vdHdlZW4vaW5jL0luaXQuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vdHdlZW4vaW5jL05leHRTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi90d2Vlbi9pbmMvUGF1c2UuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vdHdlZW4vaW5jL1BsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vdHdlZW4vaW5jL1Jlc2V0VHdlZW5EYXRhLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL3R3ZWVuL2luYy9SZXN1bWUuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vdHdlZW4vaW5jL1NlZWsuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vdHdlZW4vaW5jL1NldENhbGxiYWNrLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL3R3ZWVuL2luYy9TdG9wLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL3R3ZWVuL2luYy9VcGRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vdHdlZW4vaW5jL1VwZGF0ZVR3ZWVuRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9BbGlnbkluLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL1RvQm90dG9tQ2VudGVyLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL1RvQm90dG9tTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9Ub0JvdHRvbVJpZ2h0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL1RvTGVmdEJvdHRvbS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9Ub0xlZnRDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWxpZ24vVG9MZWZ0VG9wLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL1RvUmlnaHRCb3R0b20uanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWxpZ24vVG9SaWdodENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9Ub1JpZ2h0VG9wLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL1RvVG9wQ2VudGVyLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL1RvVG9wTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9Ub1RvcFJpZ2h0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FycmF5L0ZpbmRDbG9zZXN0SW5Tb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYXJyYXkvR2V0UmFuZG9tRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hcnJheS9OdW1iZXJBcnJheVN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYXJyYXkvUmVtb3ZlUmFuZG9tRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvR2V0T2Zmc2V0WC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvR2V0T2Zmc2V0WS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvb2JqZWN0L0dldE1pbk1heFZhbHVlLmpzIiwid2VicGFjazovLy8uL3V0aWxzL29iamVjdC9NZXJnZVJpZ2h0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9zdHJpbmcvRm9ybWF0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL3N0cmluZy9SZXZlcnNlLmpzIiwid2VicGFjazovLy8uL3V0aWxzL3N0cmluZy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDaEVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwT0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdFBBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5Q0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUJBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hEQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzdEQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3JCQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixXQUFXLEtBQUssU0FBUzs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGtCQUFrQixLQUFLLGdCQUFnQjs7QUFFeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLGNBQWMsS0FBSyxVQUFVOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdEJBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEIsT0FBTzs7QUFFckM7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM3QkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDZkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUMzQkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0MsbUNBQW1DLFlBQVk7QUFDL0MsaUNBQWlDLHFCQUFxQjs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdkpBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN2QkE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLDhCQUE4QixPQUFPO0FBQ3JDLDhCQUE4QixPQUFPO0FBQ3JDLDhCQUE4QixPQUFPO0FBQ3JDLCtCQUErQixRQUFRO0FBQ3ZDLCtCQUErQixRQUFROztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVSxjQUFjOztBQUUxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNwT0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87QUFDckMsa0NBQWtDLFdBQVc7QUFDN0MsbUNBQW1DLFlBQVk7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYzs7QUFFbEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNwS0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM3UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDdkRBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYzs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYzs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7OztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QyxrQ0FBa0MsV0FBVztBQUM3QyxpQ0FBaUMsVUFBVTtBQUMzQyxrQ0FBa0MsYUFBYTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3RSQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDMVhBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0Isc0RBQXNEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixlQUFlO0FBQ3ZDLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDLCtCQUErQixRQUFRO0FBQ3ZDLCtCQUErQixRQUFRO0FBQ3ZDLCtCQUErQixRQUFRO0FBQ3ZDLCtCQUErQixRQUFRO0FBQ3ZDLCtCQUErQixRQUFROztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMxTEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0IsdUJBQXVCO0FBQ3ZCLHFFQUFxRTtBQUNyRSxzQ0FBc0M7QUFDdEMsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixVQUFVO0FBQ1Y7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkMsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0Isc0JBQXNCO0FBQ3RCLHdGQUF3RjtBQUN4RixVQUFVO0FBQ1Y7QUFDQTs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDcEJBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNMQTs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsR0FBRyx1QkFBdUIsT0FBTztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaE1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLE1BQU07QUFDaEIsVUFBVSxNQUFNO0FBQ2hCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqNUJBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNuTEE7O0FBRUE7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLE9BQU8sc0dBQXNHO0FBQ2hJOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7OztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDLG1DQUFtQyxnQkFBZ0I7O0FBRW5EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM3RkE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLDhCQUE4QixPQUFPO0FBQ3JDLG1DQUFtQyxZQUFZOztBQUUvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3ZCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pSQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUM7O0FBRXpFOztBQUVBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLG1DQUFtQzs7QUFFekU7O0FBRUEsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixLQUFLLHdCQUF3QjtBQUNsRCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ25QQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDbEdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDN0JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxXQUFXOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxXQUFXOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BELGtDQUFrQyw4QkFBOEI7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3RELG9DQUFvQyxnQkFBZ0I7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0QsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDBCQUEwQixFQUFFO0FBQy9FOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDL1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsK0JBQStCO0FBQ2pFLG1DQUFtQyxpQ0FBaUM7O0FBRXBFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7Ozs7Ozs7O0FDL2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7O0FBRXBEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtDQUFrQyxXQUFXOztBQUU3QztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7OztBQy9mQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLG1DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDclZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRCwyQ0FBMkMsc0NBQXNDO0FBQ2pGLDBDQUEwQyxzQkFBc0I7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7O0FBRXBFO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7OztBQ3JPQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNsVkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxtRUFBbUU7QUFDM0k7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxtRUFBbUU7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87QUFDckMsaUNBQWlDLFlBQVk7O0FBRTdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7OztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3RIQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87QUFDckMsa0NBQWtDLFdBQVc7QUFDN0MsbUNBQW1DLFlBQVk7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0MsZ0NBQWdDLGNBQWM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pELDRCQUE0QixVQUFVOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXLGNBQWM7O0FBRXhEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZGQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RCw4QkFBOEIsY0FBYztBQUM1Qyw2QkFBNkIsV0FBVztBQUN4QyxpQ0FBaUMsZUFBZTtBQUNoRCxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM3UkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVFQUF1RTtBQUN2RSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3BCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7OztBQ3BCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hEQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1Q0FBdUM7QUFDeEQsaUJBQWlCLHdEQUF3RDtBQUN6RSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RCxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7O0FBRXBEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCOztBQUVwRDs7QUFFQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUyw2QkFBNkI7QUFDN0UsMENBQTBDLFlBQVksc0NBQXNDOztBQUU1Rjs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0EsNENBQTRDLGtCQUFrQjtBQUM5RDtBQUNBLGdEQUFnRCxrQkFBa0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxvQ0FBb0MsOEJBQThCOztBQUVsRSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEI7O0FBRWxFLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esb0NBQW9DLDhCQUE4Qjs7QUFFbEUsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxvQ0FBb0MsOEJBQThCOztBQUVsRSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCOztBQUVyRDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCOztBQUVyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7Ozs7OztBQ3BrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdELDJDQUEyQyxvQkFBb0I7O0FBRS9EOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwwQ0FBMEMsb0NBQW9DO0FBQzlFLDJDQUEyQyxzQ0FBc0M7O0FBRWpGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQsMENBQTBDLG1CQUFtQjtBQUM3RCwyQ0FBMkMsb0JBQW9COztBQUUvRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ2xFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsV0FBVzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3BIQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxXQUFXOztBQUU3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDMU9BOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0Msa0JBQWtCO0FBQ3RELDhCQUE4QixzQkFBc0I7QUFDcEQsK0JBQStCLHdCQUF3Qjs7QUFFdkQ7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2RUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzFGQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1TEE7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7O0FBRTlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3BDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDdkZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2JBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DLGlDQUFpQyxjQUFjOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEhBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELGdCQUFnQjtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDek5BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNwSkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDckJBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QywrQkFBK0IsUUFBUTtBQUN2QywrQkFBK0IsUUFBUTtBQUN2QywrQkFBK0IsUUFBUTs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDbElBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbURBQW1ELDZCQUE2QjtBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDMUJBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsS0FBSztBQUNMLDJCQUEyQixZQUFZO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLGlDQUFpQywrQkFBK0I7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDLHVCQUF1QixvQkFBb0I7QUFDM0MsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUN0cEJBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3Qjs7QUFFQSxzQkFBc0IsTUFBTSw2RUFBNkUsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQzNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBLDRCQUE0QixVQUFVOztBQUV0QyxjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLDJCQUEyQjtBQUN6QyxjQUFjLGdDQUFnQztBQUM5QyxjQUFjLDRCQUE0Qjs7QUFFMUM7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixVQUFVOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBLGtCQUFrQixhQUFhOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGNBQWM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7QUFFdEMsY0FBYyxpQ0FBaUM7QUFDL0MsY0FBYyxpQ0FBaUM7QUFDL0MsY0FBYyxpQ0FBaUM7O0FBRS9DO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsY0FBYzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsY0FBYzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDBCQUEwQixPQUFPOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDOURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxxQ0FBcUMsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2xDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzFCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0RBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDM0NBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ2xEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNoRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3ROQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdHQUF3RztBQUM1SDtBQUNBLG9HQUFvRyxpQkFBaUI7QUFDckg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDeElBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4REE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7O0FBRUEsdUJBQXVCLGNBQWM7QUFDckM7O0FBRUEsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTs7QUFFQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBOztBQUVBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7O0FBRUEsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTs7QUFFQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBOztBQUVBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7O0FBRUEsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTs7QUFFQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTs7QUFFQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBOztBQUVBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDL0VBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQy9GQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlaQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3ZlQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVzs7QUFFekMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsK0JBQStCLGNBQWM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsK0JBQStCLGNBQWM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsK0JBQStCLGNBQWM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDcENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBLGtEQUFrRDtBQUNsRCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qix3Q0FBd0M7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzVWQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNqRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNmQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3RSQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtDQUFrQyxXQUFXOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUI7O0FBRWpFOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsSUFBSTtBQUNsQixlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RCxtQ0FBbUMsMkJBQTJCOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQscUNBQXFDLDZCQUE2Qjs7QUFFbEUsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxJQUFJO0FBQ2xCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQscUNBQXFDLDZCQUE2Qjs7QUFFbEU7O0FBRUEsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELHFDQUFxQyw2QkFBNkI7O0FBRWxFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixjQUFjLElBQUk7QUFDbEIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixjQUFjLElBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsT0FBTztBQUNyQixjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0IsY0FBYyxRQUFRO0FBQ3RCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMvcEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hEQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzdGQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0EsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLFFBQVE7QUFDbEIsV0FBVyxJQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7O0FBRXpDOztBQUVBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEIsVUFBVSxRQUFRO0FBQ2xCLFdBQVcsSUFBSTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXOztBQUV6Qzs7QUFFQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDekJBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsSTs7Ozs7O0FDOUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsT0FBTztBQUNqQixVQUFVLFFBQVE7QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDLDRCQUE0QixXQUFXO0FBQ3ZDLDRCQUE0QixTQUFTOztBQUVyQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDcktBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakJBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsRkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDWEE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1JBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7O0FDTkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7QUN2THRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsT0FBTywyQkFBMkI7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsaUNBQWlDLGlCQUFpQjs7QUFFbEQ7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsaUNBQWlDLGlCQUFpQjs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3RCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixXQUFXOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLHFFQUFxRTtBQUNuRyw4QkFBOEIscUVBQXFFO0FBQ25HLDhCQUE4QixxRUFBcUU7O0FBRW5HO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLDhCQUE4QixXQUFXOztBQUV6QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkMsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkMsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLDhCQUE4QixXQUFXOztBQUV6QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQsK0JBQStCLFdBQVcsY0FBYzs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEdBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDeklBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDdERBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDbkJBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ2hCQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ25CQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNoQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ25CQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBLCtDQUErQyxnQ0FBZ0M7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3pEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3RCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkMsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDelhBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDckRBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN4Q0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3BCQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDcEJBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDLDhCQUE4QixhQUFhO0FBQzNDLDZCQUE2QixZQUFZOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsV0FBVztBQUN2Qyw4QkFBOEIsYUFBYTtBQUMzQyw2QkFBNkIsWUFBWTs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQ0FBa0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNURBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7O0FBRXZEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTs7QUFFMUM7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLDhCQUE4QixXQUFXOztBQUV6Qzs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLDhCQUE4QixXQUFXOztBQUV6Qzs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3pDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDL0NBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTztBQUNqQyw4QkFBOEIsMENBQTBDO0FBQ3hFLCtCQUErQiw0Q0FBNEM7QUFDM0UsaUNBQWlDLGtCQUFrQjs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLHNCQUFzQjtBQUNwRCwrQkFBK0Isd0JBQXdCOztBQUV2RDs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUEsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwRkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBLDBCOzs7Ozs7QUNIQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7OztBQ3RJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25CQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCw2RUFBNkU7QUFDakk7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsMENBQTBDO0FBQ2hHO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5R0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDMURBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTtBQUNBO0FBQ0EsbUNBQW1DLG9CQUFvQjs7QUFFdkQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM1UUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELG1EQUFtRDs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQkE7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsaUVBQWlFLEVBQUU7QUFDL0c7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5REFBeUQsaUVBQWlFLEVBQUU7O0FBRTVIO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLFNBQVM7QUFDVDtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0VBQW9FOztBQUVwRTs7Ozs7OztBQ3RMQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUSx5REFBeUQsNkZBQTZGOztBQUV4TTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDbkJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ2REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCLDZFQUE2RSw2RkFBNkY7O0FBRXRPO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hSQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7OztBQ3BCRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNkRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVMQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7OztBQ2pCRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNkRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pGQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNoRkE7O0FBRUE7O0FBRUE7QUFDQSxjQUFjOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG9DQUFvQyxhQUFhOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDN0pBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM1R0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDcENBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNuQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN6R0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDakRBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVyxtQ0FBbUM7O0FBRWpGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkMsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDaERBOztBQUVBOztBQUVBOztBQUVBLDhCOzs7Ozs7QUNOQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNsQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2pCQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDN0RBOztBQUVBO0FBQ0EsY0FBYzs7QUFFZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9COztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDMUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYzs7QUFFZDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7O0FBRWpEOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7O0FBRWpEOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVzs7QUFFN0M7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVzs7QUFFN0M7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVzs7QUFFN0M7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUN6TEE7O0FBRUE7QUFDQSxjQUFjOztBQUVkOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUI7QUFDakUsbUNBQW1DLGdCQUFnQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjs7QUFFM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBLDBDQUEwQywyQkFBMkI7O0FBRXJFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7QUNyQkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7Ozs7O0FDakJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMxRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7OztBQ2pCRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7OztBQ25CRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNSRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNkRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0REFBNEQsc0JBQXNCO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL1hBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ1JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDcEJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDakJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ2REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsb0NBQW9DO0FBQzdELHlCQUF5QixxQ0FBcUM7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BLQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNwQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7QUNkRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7QUNqQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDWEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7QUN2QkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7Ozs7O0FDakJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7OztBQ25CRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7QUNqQkE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDckJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7Ozs7OztBQ2pCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7OztBQ3hCRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7OztBQ25CRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDeEJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDbkJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCOztBQUUxRCxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtDQUFrQzs7QUFFNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87QUFDckMsa0NBQWtDLGdCQUFnQjtBQUNsRCxpQ0FBaUMsVUFBVTtBQUMzQyx5Q0FBeUMsc0JBQXNCO0FBQy9ELHVDQUF1QyxtQkFBbUI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjs7QUFFbEQ7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTs7QUFFM0M7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjs7QUFFbEQ7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUzs7QUFFekM7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMzVEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsYUFBYSxLQUFLLFdBQVc7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7OztBQzNERDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNkRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0NBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7OztBQzNCRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNkRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7QUMzQkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDZEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDckJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ2REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDZEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDZEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsY0FBYzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hGQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ1hBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN2Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2QsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ25CQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzdCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTs7QUFFNUMsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGNBQWM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGNBQWM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGNBQWM7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNsQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUMsK0JBQStCLFlBQVk7QUFDM0MsK0JBQStCLFlBQVk7QUFDM0MsNEJBQTRCLFVBQVU7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzlDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3ZCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCOztBQUUxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDakJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkRBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSx5QkFBeUI7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RjtBQUNBO0FBQ0E7QUFDQSw2RjtBQUNBO0FBQ0E7QUFDQSwyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQkE7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBLDJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU87O0FBRWpDOztBQUVBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEJBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qyw4QkFBOEIsV0FBVzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qyw4QkFBOEIsV0FBVzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsOEJBQThCLFdBQVc7O0FBRXpDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7Ozs7Ozs7QUMxQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DLCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDLDRCQUE0QixXQUFXOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2QkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMzT0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0JBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNwQkE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDcEJBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN0QkE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3RCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN6TEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLGFBQWE7QUFDMUQ7O0FBRUEsbUJBQW1CLDhCQUE4QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMvQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsV0FBVzs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3hEQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM3QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNsQkE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDbEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlOztBQUVoRDtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTs7QUFFaEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDNUtBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN0Q0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQy9CQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDcENBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMvQkE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQy9CQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ25DQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDL0JBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ2hDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNoQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM1QkE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDaENBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ2hDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuUEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3RHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDMUJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQywyQkFBMkI7O0FBRTVEOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCOztBQUU3RDs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsOEJBQThCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzNDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsOEJBQThCOztBQUUvRDs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLDZCQUE2Qjs7QUFFOUQ7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3JCQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3JCQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3JCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTkE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdGQUFnRixxQkFBcUI7O0FBRXJHO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyx5REFBeUQ7O0FBRTNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQsd0VBQXdFO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdFQUF3RTtBQUNqSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN2ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDckNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ2xCQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNsQkE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMvQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOURBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0MsbUNBQW1DLGNBQWM7O0FBRWpEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsc0JBQXNCLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLHNCQUFzQixnQkFBZ0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekMsNkJBQTZCLFdBQVc7O0FBRXhDOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLDZCQUE2QixXQUFXOztBQUV4Qzs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixlQUFlOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ25DQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVzs7QUFFekM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLDZCQUE2QixXQUFXOztBQUV4Qzs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQywrQkFBK0IsWUFBWTtBQUMzQyxrQ0FBa0MsZUFBZTs7QUFFakQ7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7O0FDN0JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBLDRCQUE0QixTQUFTOztBQUVyQztBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7O0FBRWxEO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCOztBQUVsRDtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7O0FBRWxEO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBLDhCQUE4QixXQUFXOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7O0FBRXREOztBQUVBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjs7QUFFdEQ7QUFDQTs7QUFFQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3pPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzVDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RCx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELHFDQUFxQyxnQkFBZ0I7QUFDckQsc0NBQXNDLG1CQUFtQjtBQUN6RCxxQ0FBcUMsY0FBYzs7QUFFbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNoSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7O0FBRWhEOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7OENDcERBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDLCtCQUErQixTQUFTOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsdUJBQXVCOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6Qix1QkFBdUI7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQsa0JBQWtCLCtCQUErQjtBQUNqRCxrQkFBa0IsK0JBQStCO0FBQ2pELG9CQUFvQixtQ0FBbUM7QUFDdkQsdUJBQXVCLHlDQUF5QztBQUNoRSxxQkFBcUIscUNBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDNU9BOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxlQUFlOztBQUVwRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Qsa0JBQWtCLHVCQUF1QjtBQUN6QyxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDclBBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMxQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUNuQkE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3REQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRCxhQUFhLFdBQVc7QUFDeEIsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBLHNCQUFzQjs7QUFFdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEIsT0FBTztBQUNyQyxrQ0FBa0MsMENBQTBDO0FBQzVFLG1DQUFtQyw0Q0FBNEM7QUFDL0Usc0NBQXNDLGdCQUFnQjtBQUN0RCxpQ0FBaUMsYUFBYTtBQUM5QyxrQ0FBa0MsY0FBYztBQUNoRCxnQ0FBZ0MsWUFBWTtBQUM1QyxtQ0FBbUMsZUFBZTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG1EQUFtRCxhQUFhOztBQUVoRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDeGVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDMUJBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCOztBQUVuRDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDaENBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDaENBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7O0FDaENBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7O0FDdkRBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3RFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzlEQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzFCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2pCQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWE7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDckNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNwQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQy9CQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNUQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7OztBQ3BMRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5Qjs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7QUM5QkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMscURBQXFEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQkFBcUI7O0FBRWhGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EseURBQXlELHFCQUFxQjs7QUFFOUU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUN4U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDekVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6Q0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNwUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQSxrQ0FBa0Msd0dBQXdHO0FBQzFJOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlDQUFpQzs7QUFFM0U7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseURBQXlELHFCQUFxQjtBQUM5RSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3pxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3hLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDL1FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsQ0FBQzs7QUFFRDs7Ozs7OztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUI7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzNNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0RBQWdEO0FBQzdELGFBQWEsZ0RBQWdEO0FBQzdELGFBQWEsZ0RBQWdEO0FBQzdELGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiw0QkFBNEI7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStELHlCQUF5QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ25tQkE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN0dkJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNuU0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN6SEE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6SUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7O0FBRXhDLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUIsK0JBQStCOztBQUUvQjtBQUNBLFVBQVU7QUFDViw4RkFBOEY7QUFDOUYsMEVBQTBFOztBQUUxRSwwQ0FBMEM7QUFDMUMsZ0VBQWdFO0FBQ2hFLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QiwrQkFBK0I7QUFDL0IsMEJBQTBCO0FBQzFCLFdBQVc7O0FBRVgsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLHlDQUF5QztBQUN6QyxrREFBa0Q7O0FBRWxELGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUIsK0JBQStCOztBQUUvQjtBQUNBLFVBQVU7QUFDVixtREFBbUQ7QUFDbkQsOEZBQThGO0FBQzlGLDBFQUEwRTtBQUMxRSxxRUFBcUU7QUFDckUsNEVBQTRFOztBQUU1RSxnQ0FBZ0MsMkJBQTJCO0FBQzNELGNBQWM7QUFDZCw4Q0FBOEM7QUFDOUMsNkdBQTZHO0FBQzdHLHdEQUF3RDtBQUN4RCxpRUFBaUU7QUFDakUsMEVBQTBFO0FBQzFFLCtFQUErRTtBQUMvRSx3R0FBd0c7QUFDeEcsOEVBQThFO0FBQzlFLHFEQUFxRDtBQUNyRCxjQUFjOztBQUVkLGlGQUFpRjtBQUNqRixVQUFVO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsb0NBQW9DOztBQUVwQyxtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDLGdDQUFnQzs7QUFFaEMsOEJBQThCO0FBQzlCLGtDQUFrQzs7QUFFbEM7QUFDQSxVQUFVO0FBQ1Ysc0VBQXNFOztBQUV0RSwrQkFBK0I7QUFDL0IsdUNBQXVDO0FBQ3ZDLFVBQVU7QUFDVjs7QUFFQTtBQUNBLGlDQUFpQzs7QUFFakMsMENBQTBDOztBQUUxQyw4QkFBOEI7QUFDOUIsa0NBQWtDOztBQUVsQztBQUNBLFVBQVU7QUFDViw2RUFBNkU7QUFDN0UsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHVDQUF1QztBQUN2QztBQUNBLFVBQVU7QUFDViwwREFBMEQ7QUFDMUQsVUFBVTtBQUNWOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLCtCQUErQjtBQUMvQiwwQkFBMEI7QUFDMUIsV0FBVzs7QUFFWCw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLHlDQUF5QztBQUN6QywwQ0FBMEM7QUFDMUMseUNBQXlDO0FBQ3pDLGtEQUFrRDs7QUFFbEQ7QUFDQSxVQUFVO0FBQ1YsMkRBQTJEO0FBQzNELG1EQUFtRDtBQUNuRCx5REFBeUQ7QUFDekQsK0RBQStEO0FBQy9ELGlFQUFpRTtBQUNqRSw0RUFBNEU7O0FBRTVFLGdDQUFnQywyQkFBMkI7QUFDM0QsY0FBYztBQUNkLDhDQUE4QztBQUM5Qyw2R0FBNkc7QUFDN0csd0RBQXdEO0FBQ3hELGlFQUFpRTtBQUNqRSwwRUFBMEU7QUFDMUUsK0VBQStFO0FBQy9FLHdHQUF3RztBQUN4RywwRUFBMEU7QUFDMUUscURBQXFEO0FBQ3JELGNBQWM7O0FBRWQsNkVBQTZFO0FBQzdFLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0RBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQyxpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkIscUVBQXFFO0FBQ3JFLHNDQUFzQztBQUN0Qyw4QkFBOEI7QUFDOUIsVUFBVTtBQUNWO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsdUNBQXVDO0FBQ3ZDLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0Isc0JBQXNCO0FBQ3RCLDhGQUE4RjtBQUM5RixVQUFVO0FBQ1Y7QUFDQTs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLCtCQUErQjtBQUMvQixzQ0FBc0M7QUFDdEMseUNBQXlDO0FBQ3pDLG1DQUFtQztBQUNuQyxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDLHVCQUF1QjtBQUN2Qix5SEFBeUg7QUFDekgsc0NBQXNDO0FBQ3RDLFVBQVU7QUFDVjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHVDQUF1QztBQUN2QyxrQ0FBa0M7QUFDbEMsc0JBQXNCO0FBQ3RCLCtEQUErRDtBQUMvRCxVQUFVO0FBQ1Y7QUFDQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLG9DQUFvQztBQUNwQyxtQ0FBbUM7QUFDbkMsZ0NBQWdDO0FBQ2hDLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLHVCQUF1QjtBQUN2QixxRUFBcUU7QUFDckUsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixVQUFVO0FBQ1Y7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLHNCQUFzQjtBQUN0QixzREFBc0Q7QUFDdEQsVUFBVTtBQUNWO0FBQ0E7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxtQ0FBbUM7QUFDbkMsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qix1QkFBdUI7QUFDdkIscUVBQXFFO0FBQ3JFLDhCQUE4QjtBQUM5QixVQUFVO0FBQ1Y7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsc0JBQXNCO0FBQ3RCLG1DQUFtQztBQUNuQyxVQUFVO0FBQ1Y7QUFDQTs7Ozs7Ozs7QUNqQkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3pGQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsNkJBQTZCO0FBQ3ZDLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQW1COztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDcENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTs7QUFFQTs7Ozs7OztBQ3JCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLHlCQUF5Qjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixrQ0FBa0M7O0FBRS9ELHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCOztBQUV6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxREE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0I7O0FBRXBCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQy9EQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM1SkE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDak9BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUZBQWlGOztBQUVqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYzs7QUFFbEQ7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzNJQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjs7QUFFaEQsMEJBQTBCLHNDQUFzQzs7QUFFaEU7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpRUFBaUU7O0FBRTNGO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCOztBQUVoRCwwQkFBMEIsdUNBQXVDOztBQUVqRTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjs7QUFFaEQsMEJBQTBCLDBCQUEwQjs7QUFFcEQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7O0FBRWhELDBCQUEwQiwyQkFBMkI7O0FBRXJEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCOztBQUVwRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5Qjs7QUFFbkQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7O0FBRW5EO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCOztBQUVoRCwwQkFBMEIseUJBQXlCOztBQUVuRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRCxLQUFLOztBQUVMO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0MsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQyxLQUFLOztBQUVMO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjs7QUFFaEQ7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDM09BOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7OztBQ2xIQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDMVVBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7O0FDTkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsU0FBUzs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELFNBQVM7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9COztBQUVBO0FBQ0EsS0FBSzs7QUFFTCw2QkFBNkIsYUFBYSxFQUFFOztBQUU1QztBQUNBOztBQUVBLHlCQUF5QixrQkFBa0IsRUFBRTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixZQUFZOztBQUVsQzs7QUFFQTs7QUFFQSx1QkFBdUIsYUFBYTs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakIsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHdCQUF3QjtBQUN6RCxpQ0FBaUMsd0JBQXdCOztBQUV6RCx1QkFBdUIsOENBQThDO0FBQ3JFLHlCQUF5Qiw4Q0FBOEM7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUMva0JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN4V0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0MsbUNBQW1DLGNBQWM7O0FBRWpEOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ0E7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLGtDQUFrQyxnQkFBZ0I7QUFDbEQsNkJBQTZCO0FBQzdCLGdCQUFnQjs7QUFFaEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsT0FBTztBQUNyQixjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDclhBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDakRBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hGQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzNEQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsa0JBQWtCOztBQUVsQixtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1hBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4Qiw2RUFBNkU7QUFDM0csS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3hMQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw2Q0FBNkMsMEJBQTBCOztBQUV2RTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3BKQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQ0FBcUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0JBQStCO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELGNBQWM7O0FBRTlEO0FBQ0Esa0RBQWtELGNBQWM7O0FBRWhFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsb0JBQW9CLEVBQUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLFVBQVUsT0FBTztBQUNqQixVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUEsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7Ozs7OztBQ2pmQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM3TEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9FQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkRBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ25EQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlEQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDckNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNUQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3BHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzFSQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxTQUFTO0FBQ25CLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekMsK0JBQStCLHVCQUF1Qjs7QUFFdEQ7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3ZCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6Qyw0QkFBNEIsWUFBWTtBQUN4Qyw2QkFBNkIsVUFBVTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDNURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6QywrQkFBK0IsdUJBQXVCOztBQUV0RDs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDekJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxvQkFBb0I7O0FBRXpEOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3RCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJwaGFzZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIlBoYXNlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQaGFzZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUGhhc2VyXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gODUxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA3YTc1NjRiYzc4MmU5Yjk3YmRmMCIsIi8vICBUYWtlbiBmcm9tIGtsYXNzZSBieSBtYXR0ZGVzbCBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wva2xhc3NlXHJcblxyXG5mdW5jdGlvbiBoYXNHZXR0ZXJPclNldHRlciAoZGVmKVxyXG57XHJcbiAgICByZXR1cm4gKCEhZGVmLmdldCAmJiB0eXBlb2YgZGVmLmdldCA9PT0gJ2Z1bmN0aW9uJykgfHwgKCEhZGVmLnNldCAmJiB0eXBlb2YgZGVmLnNldCA9PT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFByb3BlcnR5IChkZWZpbml0aW9uLCBrLCBpc0NsYXNzRGVzY3JpcHRvcilcclxue1xyXG4gICAgLy8gIFRoaXMgbWF5IGJlIGEgbGlnaHR3ZWlnaHQgb2JqZWN0LCBPUiBpdCBtaWdodCBiZSBhIHByb3BlcnR5IHRoYXQgd2FzIGRlZmluZWQgcHJldmlvdXNseS5cclxuICAgIFxyXG4gICAgLy8gIEZvciBzaW1wbGUgY2xhc3MgZGVzY3JpcHRvcnMgd2UgY2FuIGp1c3QgYXNzdW1lIGl0cyBOT1QgcHJldmlvdXNseSBkZWZpbmVkLlxyXG4gICAgdmFyIGRlZiA9IChpc0NsYXNzRGVzY3JpcHRvcikgPyBkZWZpbml0aW9uW2tdIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZpbml0aW9uLCBrKTtcclxuXHJcbiAgICBpZiAoIWlzQ2xhc3NEZXNjcmlwdG9yICYmIGRlZi52YWx1ZSAmJiB0eXBlb2YgZGVmLnZhbHVlID09PSAnb2JqZWN0JylcclxuICAgIHtcclxuICAgICAgICBkZWYgPSBkZWYudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFRoaXMgbWlnaHQgYmUgYSByZWd1bGFyIHByb3BlcnR5LCBvciBpdCBtYXkgYmUgYSBnZXR0ZXIvc2V0dGVyIHRoZSB1c2VyIGRlZmluZWQgaW4gYSBjbGFzcy5cclxuICAgIGlmIChkZWYgJiYgaGFzR2V0dGVyT3JTZXR0ZXIoZGVmKSlcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRlZi5lbnVtZXJhYmxlID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlZi5lbnVtZXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZGVmLmNvbmZpZ3VyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWYuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkZWY7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNOb25Db25maWd1cmFibGUgKG9iaiwgaylcclxue1xyXG4gICAgdmFyIHByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgayk7XHJcblxyXG4gICAgaWYgKCFwcm9wKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJvcC52YWx1ZSAmJiB0eXBlb2YgcHJvcC52YWx1ZSA9PT0gJ29iamVjdCcpXHJcbiAgICB7XHJcbiAgICAgICAgcHJvcCA9IHByb3AudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb3AuY29uZmlndXJhYmxlID09PSBmYWxzZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dGVuZCAoY3RvciwgZGVmaW5pdGlvbiwgaXNDbGFzc0Rlc2NyaXB0b3IsIGV4dGVuZClcclxue1xyXG4gICAgZm9yICh2YXIgayBpbiBkZWZpbml0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghZGVmaW5pdGlvbi5oYXNPd25Qcm9wZXJ0eShrKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlZiA9IGdldFByb3BlcnR5KGRlZmluaXRpb24sIGssIGlzQ2xhc3NEZXNjcmlwdG9yKTtcclxuXHJcbiAgICAgICAgaWYgKGRlZiAhPT0gZmFsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSWYgRXh0ZW5kcyBpcyB1c2VkLCB3ZSB3aWxsIGNoZWNrIGl0cyBwcm90b3R5cGUgdG8gc2VlIGlmIHRoZSBmaW5hbCB2YXJpYWJsZSBleGlzdHMuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZXh0ZW5kIHx8IGN0b3I7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGFzTm9uQ29uZmlndXJhYmxlKHBhcmVudC5wcm90b3R5cGUsIGspKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgSnVzdCBza2lwIHRoZSBmaW5hbCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgaWYgKENsYXNzLmlnbm9yZUZpbmFscylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgV2UgY2Fubm90IHJlLWRlZmluZSBhIHByb3BlcnR5IHRoYXQgaXMgY29uZmlndXJhYmxlPWZhbHNlLlxyXG4gICAgICAgICAgICAgICAgLy8gIFNvIHdlIHdpbGwgY29uc2lkZXIgdGhlbSBmaW5hbCBhbmQgdGhyb3cgYW4gZXJyb3IuIFRoaXMgaXMgYnlcclxuICAgICAgICAgICAgICAgIC8vICBkZWZhdWx0IHNvIGl0IGlzIGNsZWFyIHRvIHRoZSBkZXZlbG9wZXIgd2hhdCBpcyBoYXBwZW5pbmcuXHJcbiAgICAgICAgICAgICAgICAvLyAgWW91IGNhbiBzZXQgaWdub3JlRmluYWxzIHRvIHRydWUgaWYgeW91IG5lZWQgdG8gZXh0ZW5kIGEgY2xhc3NcclxuICAgICAgICAgICAgICAgIC8vICB3aGljaCBoYXMgY29uZmlndXJhYmxlPWZhbHNlOyBpdCB3aWxsIHNpbXBseSBub3QgcmUtZGVmaW5lIGZpbmFsIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBvdmVycmlkZSBmaW5hbCBwcm9wZXJ0eSBcXCcnICsgayArICdcXCcsIHNldCBDbGFzcy5pZ25vcmVGaW5hbHMgPSB0cnVlIHRvIHNraXAnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrLCBkZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZVtrXSA9IGRlZmluaXRpb25ba107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtaXhpbiAobXlDbGFzcywgbWl4aW5zKVxyXG57XHJcbiAgICBpZiAoIW1peGlucylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1peGlucykpXHJcbiAgICB7XHJcbiAgICAgICAgbWl4aW5zID0gWyBtaXhpbnMgXTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBleHRlbmQobXlDbGFzcywgbWl4aW5zW2ldLnByb3RvdHlwZSB8fCBtaXhpbnNbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBjbGFzcyB3aXRoIHRoZSBnaXZlbiBkZXNjcmlwdG9yLlxyXG4gKiBUaGUgY29uc3RydWN0b3IsIGRlZmluZWQgYnkgdGhlIG5hbWUgYGluaXRpYWxpemVgLFxyXG4gKiBpcyBhbiBvcHRpb25hbCBmdW5jdGlvbi4gSWYgdW5zcGVjaWZpZWQsIGFuIGFub255bW91c1xyXG4gKiBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgd2hpY2ggY2FsbHMgdGhlIHBhcmVudCBjbGFzcyAoaWZcclxuICogb25lIGV4aXN0cykuXHJcbiAqXHJcbiAqIFlvdSBjYW4gYWxzbyB1c2UgYEV4dGVuZHNgIGFuZCBgTWl4aW5zYCB0byBwcm92aWRlIHN1YmNsYXNzaW5nXHJcbiAqIGFuZCBpbmhlcml0YW5jZS5cclxuICpcclxuICogQGNsYXNzICBDbGFzc1xyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb24gYSBkaWN0aW9uYXJ5IG9mIGZ1bmN0aW9ucyBmb3IgdGhlIGNsYXNzXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqICAgICAgdmFyIE15Q2xhc3MgPSBuZXcgUGhhc2VyLkNsYXNzKHtcclxuICogICAgICBcclxuICogICAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgICAgICAgICB0aGlzLmZvbyA9IDIuMDtcclxuICogICAgICAgICAgfSxcclxuICpcclxuICogICAgICAgICAgYmFyOiBmdW5jdGlvbigpIHtcclxuICogICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvbyArIDU7XHJcbiAqICAgICAgICAgIH1cclxuICogICAgICB9KTtcclxuICovXHJcbmZ1bmN0aW9uIENsYXNzIChkZWZpbml0aW9uKVxyXG57XHJcbiAgICBpZiAoIWRlZmluaXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgZGVmaW5pdGlvbiA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBUaGUgdmFyaWFibGUgbmFtZSBoZXJlIGRpY3RhdGVzIHdoYXQgd2Ugc2VlIGluIENocm9tZSBkZWJ1Z2dlclxyXG4gICAgdmFyIGluaXRpYWxpemU7XHJcbiAgICB2YXIgRXh0ZW5kcztcclxuXHJcbiAgICBpZiAoZGVmaW5pdGlvbi5pbml0aWFsaXplKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbi5pbml0aWFsaXplICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0aWFsaXplIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5pdGlhbGl6ZSA9IGRlZmluaXRpb24uaW5pdGlhbGl6ZTtcclxuXHJcbiAgICAgICAgLy8gIFVzdWFsbHkgd2Ugc2hvdWxkIGF2b2lkICdkZWxldGUnIGluIFY4IGF0IGFsbCBjb3N0cy5cclxuICAgICAgICAvLyAgSG93ZXZlciwgaXRzIHVubGlrZWx5IHRvIG1ha2UgYW55IHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VcclxuICAgICAgICAvLyAgaGVyZSBzaW5jZSB3ZSBvbmx5IGNhbGwgdGhpcyBvbiBjbGFzcyBjcmVhdGlvbiAoaS5lLiBub3Qgb2JqZWN0IGNyZWF0aW9uKS5cclxuICAgICAgICBkZWxldGUgZGVmaW5pdGlvbi5pbml0aWFsaXplO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmIChkZWZpbml0aW9uLkV4dGVuZHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYmFzZSA9IGRlZmluaXRpb24uRXh0ZW5kcztcclxuXHJcbiAgICAgICAgICAgIGluaXRpYWxpemUgPSBmdW5jdGlvbiAoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRlZmluaXRpb24uRXh0ZW5kcylcclxuICAgIHtcclxuICAgICAgICBpbml0aWFsaXplLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZGVmaW5pdGlvbi5FeHRlbmRzLnByb3RvdHlwZSk7XHJcbiAgICAgICAgaW5pdGlhbGl6ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBpbml0aWFsaXplO1xyXG5cclxuICAgICAgICAvLyAgRm9yIGdldE93blByb3BlcnR5RGVzY3JpcHRvciB0byB3b3JrLCB3ZSBuZWVkIHRvIGFjdCBkaXJlY3RseSBvbiB0aGUgRXh0ZW5kcyAob3IgTWl4aW4pXHJcblxyXG4gICAgICAgIEV4dGVuZHMgPSBkZWZpbml0aW9uLkV4dGVuZHM7XHJcblxyXG4gICAgICAgIGRlbGV0ZSBkZWZpbml0aW9uLkV4dGVuZHM7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBpbml0aWFsaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBHcmFiIHRoZSBtaXhpbnMsIGlmIHRoZXkgYXJlIHNwZWNpZmllZC4uLlxyXG4gICAgdmFyIG1peGlucyA9IG51bGw7XHJcblxyXG4gICAgaWYgKGRlZmluaXRpb24uTWl4aW5zKVxyXG4gICAge1xyXG4gICAgICAgIG1peGlucyA9IGRlZmluaXRpb24uTWl4aW5zO1xyXG4gICAgICAgIGRlbGV0ZSBkZWZpbml0aW9uLk1peGlucztcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRmlyc3QsIG1peGluIGlmIHdlIGNhbi5cclxuICAgIG1peGluKGluaXRpYWxpemUsIG1peGlucyk7XHJcblxyXG4gICAgLy8gIE5vdyB3ZSBncmFiIHRoZSBhY3R1YWwgZGVmaW5pdGlvbiB3aGljaCBkZWZpbmVzIHRoZSBvdmVycmlkZXMuXHJcbiAgICBleHRlbmQoaW5pdGlhbGl6ZSwgZGVmaW5pdGlvbiwgdHJ1ZSwgRXh0ZW5kcyk7XHJcblxyXG4gICAgcmV0dXJuIGluaXRpYWxpemU7XHJcbn1cclxuXHJcbkNsYXNzLmV4dGVuZCA9IGV4dGVuZDtcclxuQ2xhc3MubWl4aW4gPSBtaXhpbjtcclxuQ2xhc3MuaWdub3JlRmluYWxzID0gZmFsc2U7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL0NsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhhc2VyLmlvPlxyXG4gKiBAY29weXJpZ2h0ICAgIDIwMTcgUGhvdG9uIFN0b3JtIEx0ZC5cclxuICogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuICovXHJcblxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4vY29tcG9uZW50cycpO1xyXG52YXIgRGF0YVByb3h5ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0RhdGFQcm94eScpO1xyXG5cclxudmFyIEdhbWVPYmplY3QgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBjbGFzcyB0aGF0IGFsbCBHYW1lIE9iamVjdHMgZXh0ZW5kLlxyXG4gICAgICogWW91IGRvbid0IGNyZWF0ZSBHYW1lT2JqZWN0cyBkaXJlY3RseSBhbmQgdGhleSBjYW5ub3QgYmUgYWRkZWQgdG8gdGhlIGRpc3BsYXkgbGlzdC5cclxuICAgICAqIEluc3RlYWQsIHVzZSB0aGVtIGFzIHRoZSBiYXNlIGZvciB5b3VyIG93biBjdXN0b20gY2xhc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgR2FtZU9iamVjdFxyXG4gICAgICogQG5hbWVzcGFjZSBQaGFzZXIuR2FtZU9iamVjdHNcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UGhhc2VyLlNjZW5lfSBzY2VuZSAtIFRoZSBTY2VuZSB0byB3aGljaCB0aGlzIEdhbWUgT2JqZWN0IGJlbG9uZ3MuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHlwZSBvZiBHYW1lIE9iamVjdCwgaS5lLiBgc3ByaXRlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gR2FtZU9iamVjdCAoc2NlbmUsIHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFNjZW5lIHRvIHdoaWNoIHRoaXMgR2FtZSBPYmplY3QgYmVsb25ncy5cclxuICAgICAgICAgKiBHYW1lIE9iamVjdHMgY2FuIG9ubHkgYmVsb25nIHRvIG9uZSBTY2VuZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlNjZW5lfSBzY2VuZVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEdhbWUgT2JqZWN0LCBpLmUuIGBzcHJpdGVgLlxyXG4gICAgICAgICAqIFVzZWQgaW50ZXJuYWxseSBieSBQaGFzZXIgYnV0IGlzIGF2YWlsYWJsZSBmb3IgeW91ciBvd24gY3VzdG9tIGNsYXNzZXMgdG8gcG9wdWxhdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgR2FtZSBPYmplY3QuXHJcbiAgICAgICAgICogRW1wdHkgYnkgZGVmYXVsdCBhbmQgbmV2ZXIgcG9wdWxhdGVkIGJ5IFBoYXNlciwgdGhpcyBpcyBsZWZ0IGZvciBkZXZlbG9wZXJzIHRvIHVzZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZT0nJ11cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5hbWUgPSAnJztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGlzIEdhbWUgT2JqZWN0LlxyXG4gICAgICAgICAqIEEgR2FtZSBPYmplY3Qgd2l0aCBhbiBhY3RpdmUgc3RhdGUgb2YgYHRydWVgIGlzIHByb2Nlc3NlZCBieSB0aGUgU2NlbmVzIFVwZGF0ZUxpc3QsIGlmIGFkZGVkIHRvIGl0LlxyXG4gICAgICAgICAqIEFuIGFjdGl2ZSBvYmplY3QgaXMgb25lIHdoaWNoIGlzIGhhdmluZyBpdHMgbG9naWMgYW5kIGludGVybmFsIHN5c3RlbXMgdXBkYXRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FjdGl2ZT10cnVlXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFRhYiBJbmRleCBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiAgICAgICAgICogUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgYnkgcGx1Z2lucyBhbmQgdGhlIElucHV0IE1hbmFnZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IFt0YWJJbmRleD0tMV1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRhYkluZGV4ID0gLTE7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgcHJveHkgdG8gdGhlIERhdGEgY2xhc3MuXHJcbiAgICAgICAgICogSXQgYWxsb3dzIHlvdSB0byBzdG9yZSwgcXVlcnkgYW5kIGdldCBrZXkvdmFsdWUgcGFpcmVkIGluZm9ybWF0aW9uIHNwZWNpZmljIHRvIHRoaXMgR2FtZSBPYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge0RhdGFQcm94eX0gZGF0YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhUHJveHkoc2NlbmUsIHRoaXMpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZmxhZ3MgdGhhdCBhcmUgY29tcGFyZWQgYWdhaW5zdCBgUkVOREVSX01BU0tgIHRvIGRldGVybWluZSBpZiB0aGlzIEdhbWUgT2JqZWN0IHdpbGwgcmVuZGVyIG9yIG5vdC5cclxuICAgICAgICAgKiBUaGUgYml0cyBhcmUgMDAwMSB8IDAwMTAgfCAwMTAwIHwgMTAwMCBzZXQgYnkgdGhlIGNvbXBvbmVudHMgVmlzaWJsZSwgQWxwaGEsIFRyYW5zZm9ybSBhbmQgVGV4dHVyZSByZXNwZWN0aXZlbHkuXHJcbiAgICAgICAgICogSWYgdGhvc2UgY29tcG9uZW50cyBhcmUgbm90IHVzZWQgYnkgeW91ciBjdXN0b20gY2xhc3MgdGhlbiB5b3UgY2FuIHVzZSB0aGlzIGJpdG1hc2sgYXMgeW91IHdpc2guXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IFtyZW5kZXJGbGFncz0xNV1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlbmRlckZsYWdzID0gMTU7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgYml0bWFzayB0aGF0IGNvbnRyb2xzIGlmIHRoaXMgR2FtZSBPYmplY3QgaXMgZHJhd24gYnkgYSBDYW1lcmEgb3Igbm90LlxyXG4gICAgICAgICAqIE5vdCB1c3VhbGx5IHNldCBkaXJlY3RseS4gSW5zdGVhZCBjYWxsIGBDYW1lcmEuaWdub3JlYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FtZXJhRmlsdGVyPTBdXHJcbiAgICAgICAgICogQHNlZSBQaGFzZXIuQ2FtZXJhcy5DYW1lcmEuaWdub3JlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYW1lcmFGaWx0ZXIgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGlzIEdhbWUgT2JqZWN0IGlzIGVuYWJsZWQgZm9yIGlucHV0IHRoZW4gdGhpcyBwcm9wZXJ0eSB3aWxsIGNvbnRhaW4gYW4gSW50ZXJhY3RpdmVPYmplY3QgaW5zdGFuY2UuXHJcbiAgICAgICAgICogTm90IHVzdWFsbHkgc2V0IGRpcmVjdGx5LiBJbnN0ZWFkIGNhbGwgYEdhbWVPYmplY3Quc2V0SW50ZXJhY3RpdmUoKWAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge1BoYXNlci5JbnB1dC5JbnRlcmFjdGl2ZU9iamVjdHxudWxsfSBbaW5wdXQ9bnVsbF1cclxuICAgICAgICAgKiBAc2VlIHNldEludGVyYWN0aXZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbnB1dCA9IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoaXMgR2FtZSBPYmplY3QgaXMgZW5hYmxlZCBmb3IgcGh5c2ljcyB0aGVuIHRoaXMgcHJvcGVydHkgd2lsbCBjb250YWluIGEgcmVmZXJlbmNlIHRvIGEgUGh5c2ljcyBCb2R5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtQaGFzZXIuUGh5c2ljcy5Cb2R5fG51bGx9IFtib2R5PW51bGxdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gIFRlbGwgdGhlIFNjZW5lIHRvIHJlLXNvcnQgdGhlIGNoaWxkcmVuXHJcbiAgICAgICAgdGhpcy5zY2VuZS5zeXMuc29ydENoaWxkcmVuRmxhZyA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYGFjdGl2ZWAgcHJvcGVydHkgb2YgdGhpcyBHYW1lIE9iamVjdCBhbmQgcmV0dXJucyB0aGlzIEdhbWUgT2JqZWN0IGZvciBmdXJ0aGVyIGNoYWluaW5nLlxyXG4gICAgICogQSBHYW1lIE9iamVjdCB3aXRoIGl0cyBgYWN0aXZlYCBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgIHdpbGwgYmUgdXBkYXRlZCBieSB0aGUgU2NlbmVzIFVwZGF0ZUxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBzZXRBY3RpdmVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVHJ1ZSBpZiB0aGlzIEdhbWUgT2JqZWN0IHNob3VsZCBiZSBzZXQgYXMgYWN0aXZlLCBmYWxzZSBpZiBub3QuXHJcbiAgICAgKiBAcmV0dXJuIHtHYW1lT2JqZWN0fSBUaGlzIEdhbWVPYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHNldEFjdGl2ZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGBuYW1lYCBwcm9wZXJ0eSBvZiB0aGlzIEdhbWUgT2JqZWN0IGFuZCByZXR1cm5zIHRoaXMgR2FtZSBPYmplY3QgZm9yIGZ1cnRoZXIgY2hhaW5pbmcuXHJcbiAgICAgKiBUaGUgYG5hbWVgIHByb3BlcnR5IGlzIG5vdCBwb3B1bGF0ZWQgYnkgUGhhc2VyIGFuZCBpcyBwcmVzZW50ZWQgZm9yIHlvdXIgb3duIHVzZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZSBnYW1lIG9iamVjdHMvaW1hZ2Uvc2V0IG5hbWUuanNcclxuICAgICAqIEB0dXRvcmlhbCBnYW1lIG9iamVjdHMvYmFzaWNzXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBzZXROYW1lXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIG5hbWUgdG8gYmUgZ2l2ZW4gdG8gdGhpcyBHYW1lIE9iamVjdC5cclxuICAgICAqIEByZXR1cm4ge0dhbWVPYmplY3R9IFRoaXMgR2FtZU9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc2V0TmFtZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXNzIHRoaXMgR2FtZSBPYmplY3QgdG8gdGhlIElucHV0IE1hbmFnZXIgdG8gZW5hYmxlIGl0IGZvciBJbnB1dC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZSBnYW1lIG9iamVjdHMvaW1hZ2Uvc2V0IGludGVyYWN0aXZlLmpzXHJcbiAgICAgKiBAdHV0b3JpYWwgaW5wdXQvYmFzaWNzXHJcbiAgICAgKiBcclxuICAgICAqIEBtZXRob2Qgc2V0SW50ZXJhY3RpdmVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gW3NoYXBlXSAtIEEgZ2VvbWV0cmljIHNoYXBlIHRoYXQgZGVmaW5lcyB0aGUgaGl0IGFyZWEgZm9yIHRoZSBHYW1lIE9iamVjdC4gSWYgbm90IHNwZWNpZmllZCBhIFJlY3RhbmdsZSB3aWxsIGJlIHVzZWQuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIEdhbWUgT2JqZWN0IGlzIGludGVyYWN0ZWQgd2l0aC5cclxuICAgICAqIEByZXR1cm4ge0dhbWVPYmplY3R9IFRoaXMgR2FtZU9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc2V0SW50ZXJhY3RpdmU6IGZ1bmN0aW9uIChzaGFwZSwgY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5zeXMuaW5wdXRNYW5hZ2VyLmVuYWJsZSh0aGlzLCBzaGFwZSwgY2FsbGJhY2spO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFRvIGJlIG92ZXJyaWRkZW4gYnkgY3VzdG9tIEdhbWVPYmplY3RzLiBBbGxvd3MgYmFzZSBvYmplY3RzIHRvIGJlIHVzZWQgaW4gYSBQb29sLlxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHRvSlNPTlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBDb21wb25lbnRzLlRvSlNPTih0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGUgcmVuZGVyTWFzayB3aXRoIHRoZSByZW5kZXJGbGFncyB0byBzZWUgaWYgdGhpcyBHYW1lIE9iamVjdCB3aWxsIHJlbmRlciBvciBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCB3aWxsUmVuZGVyXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgR2FtZSBPYmplY3Qgc2hvdWxkIGJlIHJlbmRlcmVkLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHdpbGxSZW5kZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIChHYW1lT2JqZWN0LlJFTkRFUl9NQVNLID09PSB0aGlzLnJlbmRlckZsYWdzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGlzIEdhbWUgT2JqZWN0IHJlbW92aW5nIGl0IGZyb20gdGhlIERpc3BsYXkgTGlzdCBhbmQgVXBkYXRlIExpc3QgYW5kXHJcbiAgICAgKiBzZXZlcmluZyBhbGwgdGllcyB0byBwYXJlbnQgcmVzb3VyY2VzLlxyXG4gICAgICogXHJcbiAgICAgKiBBbHNvIHJlbW92ZXMgaXRzZWxmIGZyb20gdGhlIElucHV0IE1hbmFnZXIgYW5kIFBoeXNpY3MgTWFuYWdlciBpZiBwcmV2aW91c2x5IGVuYWJsZWQuXHJcbiAgICAgKiBcclxuICAgICAqIFVzZSB0aGlzIHRvIHJlbW92ZSBhIEdhbWUgT2JqZWN0IGZyb20geW91ciBnYW1lIGlmIHlvdSBkb24ndCBldmVyIHBsYW4gdG8gdXNlIGl0IGFnYWluLlxyXG4gICAgICogQXMgbG9uZyBhcyBubyByZWZlcmVuY2UgdG8gaXQgZXhpc3RzIHdpdGhpbiB5b3VyIG93biBjb2RlIGl0IHNob3VsZCBiZWNvbWUgZnJlZSBmb3JcclxuICAgICAqIGdhcmJhZ2UgY29sbGVjdGlvbiBieSB0aGUgYnJvd3Nlci5cclxuICAgICAqIFxyXG4gICAgICogSWYgeW91IGp1c3Qgd2FudCB0byB0ZW1wb3JhcmlseSBkaXNhYmxlIGFuIG9iamVjdCB0aGVuIGxvb2sgYXQgdXNpbmcgdGhlXHJcbiAgICAgKiBHYW1lIE9iamVjdCBQb29sIGluc3RlYWQgb2YgZGVzdHJveWluZyBpdCwgYXMgZGVzdHJveWVkIG9iamVjdHMgY2Fubm90IGJlIHJlc3VycmVjdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICovXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2NlbmUuc3lzLmRpc3BsYXlMaXN0LnJlbW92ZSh0aGlzKTtcclxuICAgICAgICB0aGlzLnNjZW5lLnN5cy51cGRhdGVMaXN0LnJlbW92ZSh0aGlzKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLnN5cy5pbnB1dE1hbmFnZXIuY2xlYXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5ib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5zeXMucGh5c2ljc01hbmFnZXIucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICB0aGlzLnNjZW5lID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICogVGhlIGJpdG1hc2sgdGhhdCBgR2FtZU9iamVjdC5yZW5kZXJGbGFnc2AgaXMgY29tcGFyZWQgYWdhaW5zdCB0byBkZXRlcm1pbmUgaWYgdGhlIEdhbWUgT2JqZWN0IHdpbGwgcmVuZGVyIG9yIG5vdC5cclxuICpcclxuICogQGNvbnN0YW50IHtpbnRlZ2VyfSBSRU5ERVJfTUFTS1xyXG4gKiBAZGVmYXVsdFxyXG4gKi9cclxuR2FtZU9iamVjdC5SRU5ERVJfTUFTSyA9IDE1O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lT2JqZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL0dhbWVPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBFdmVudCAodHlwZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGVsZW1lbnQgdGhhdCBpbml0aWF0ZWQgdGhlIGV2ZW50LlxyXG4gICAgICAgIHRoaXMudGFyZ2V0O1xyXG5cclxuICAgICAgICB0aGlzLl9wcm9wYWdhdGUgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24gKHRhcmdldClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuXHJcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2V2ZW50cy9FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIE5PT1AgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvLyAgTk9PUCAoTm8gT3BlcmF0aW9uKSBDYWxsYmFja1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOT09QO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL05PT1AuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFNvdXJjZSBvYmplY3RcclxuLy8gIFRoZSBrZXkgYXMgYSBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIGtleXMsIGkuZS4gJ2Jhbm5lcicsIG9yICdiYW5uZXIuaGlkZUJhbm5lcidcclxuLy8gIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RcclxuXHJcbnZhciBHZXRWYWx1ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKVxyXG57XHJcbiAgICBpZiAoIXNvdXJjZSB8fCB0eXBlb2Ygc291cmNlID09PSAnbnVtYmVyJylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZVtrZXldO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5LmluZGV4T2YoJy4nKSlcclxuICAgIHtcclxuICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSBzb3VyY2U7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG5cclxuICAgICAgICAvLyAgVXNlIGZvciBsb29wIGhlcmUgc28gd2UgY2FuIGJyZWFrIGVhcmx5XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5oYXNPd25Qcm9wZXJ0eShrZXlzW2ldKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFllcyBpdCBoYXMgYSBrZXkgcHJvcGVydHksIGxldCdzIGNhcnJ5IG9uIGRvd25cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyZW50W2tleXNbaV1dO1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFtrZXlzW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBDYW4ndCBnbyBhbnkgZnVydGhlciwgc28gcmVzZXQgdG8gZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFZhbHVlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL29iamVjdC9HZXRWYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIEdhbWVPYmplY3RDcmVhdG9yID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEdhbWVPYmplY3RDcmVhdG9yIChzY2VuZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbi8vICBTdGF0aWMgbWV0aG9kIGNhbGxlZCBkaXJlY3RseSBieSB0aGUgR2FtZSBPYmplY3QgY3JlYXRvciBmdW5jdGlvbnNcclxuXHJcbkdhbWVPYmplY3RDcmVhdG9yLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHR5cGUsIGZhY3RvcnlGdW5jdGlvbilcclxue1xyXG4gICAgLy8gY29uc29sZS5sb2coJ3JlZ2lzdGVyJywgdHlwZSk7XHJcblxyXG4gICAgaWYgKCFHYW1lT2JqZWN0Q3JlYXRvci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkodHlwZSkpXHJcbiAgICB7XHJcbiAgICAgICAgR2FtZU9iamVjdENyZWF0b3IucHJvdG90eXBlW3R5cGVdID0gZmFjdG9yeUZ1bmN0aW9uO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lT2JqZWN0Q3JlYXRvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RDcmVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcblxyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR2FtZU9iamVjdEZhY3RvcnkgKHNjZW5lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwbGF5TGlzdDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxpc3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIGJvb3Q6IGZ1bmN0aW9uIChzeXMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5TGlzdCA9IHN5cy5kaXNwbGF5TGlzdDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxpc3QgPSBzeXMudXBkYXRlTGlzdDtcclxuICAgIH0sXHJcblxyXG4gICAgZXhpc3Rpbmc6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICBpZiAoY2hpbGQucmVuZGVyQ2FudmFzIHx8IGNoaWxkLnJlbmRlcldlYkdMKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5TGlzdC5hZGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoaWxkLnByZVVwZGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGlzdC5hZGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheUxpc3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGlzdCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbi8vICBTdGF0aWMgbWV0aG9kIGNhbGxlZCBkaXJlY3RseSBieSB0aGUgR2FtZSBPYmplY3QgZmFjdG9yeSBmdW5jdGlvbnNcclxuXHJcbkdhbWVPYmplY3RGYWN0b3J5LnJlZ2lzdGVyID0gZnVuY3Rpb24gKHR5cGUsIGZhY3RvcnlGdW5jdGlvbilcclxue1xyXG4gICAgLy8gY29uc29sZS5sb2coJ3JlZ2lzdGVyJywgdHlwZSk7XHJcblxyXG4gICAgaWYgKCFHYW1lT2JqZWN0RmFjdG9yeS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkodHlwZSkpXHJcbiAgICB7XHJcbiAgICAgICAgR2FtZU9iamVjdEZhY3RvcnkucHJvdG90eXBlW3R5cGVdID0gZmFjdG9yeUZ1bmN0aW9uO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lT2JqZWN0RmFjdG9yeTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRIID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuL0dldFZhbHVlJyk7XHJcblxyXG4vLyAgQWxsb3dlZCB0eXBlczpcclxuXHJcbi8vICBJbXBsaWNpdFxyXG4vLyAge1xyXG4vLyAgICAgIHg6IDRcclxuLy8gIH1cclxuLy9cclxuLy8gIEZyb20gZnVuY3Rpb25cclxuLy8gIHtcclxuLy8gICAgICB4OiBmdW5jdGlvbiAoKVxyXG4vLyAgfVxyXG4vL1xyXG4vLyAgUmFuZG9tbHkgcGljayBvbmUgZWxlbWVudCBmcm9tIHRoZSBhcnJheVxyXG4vLyAge1xyXG4vLyAgICAgIHg6IFthLCBiLCBjLCBkLCBlLCBmXVxyXG4vLyAgfVxyXG4vL1xyXG4vLyAgUmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heDpcclxuLy8gIHtcclxuLy8gICAgICB4OiB7IHJhbmRJbnQ6IFttaW4sIG1heF0gfVxyXG4vLyAgfVxyXG4vL1xyXG4vLyAgUmFuZG9tIGZsb2F0IGJldHdlZW4gbWluIGFuZCBtYXg6XHJcbi8vICB7XHJcbi8vICAgICAgeDogeyByYW5kRmxvYXQ6IFttaW4sIG1heF0gfVxyXG4vLyAgfVxyXG5cclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSBmdW5jdGlvbiAoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSlcclxue1xyXG4gICAgdmFyIHZhbHVlID0gR2V0VmFsdWUoc291cmNlLCBrZXksIG51bGwpO1xyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1BVEguUk5ELnBpY2sodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JylcclxuICAgIHtcclxuICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ3JhbmRJbnQnKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNQVRILlJORC5pbnRlZ2VySW5SYW5nZSh2YWx1ZS5yYW5kSW50WzBdLCB2YWx1ZS5yYW5kSW50WzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ3JhbmRGbG9hdCcpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1BVEguUk5ELnJlYWxJblJhbmdlKHZhbHVlLnJhbmRGbG9hdFswXSwgdmFsdWUucmFuZEZsb2F0WzFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlKGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBZHZhbmNlZFZhbHVlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL29iamVjdC9HZXRBZHZhbmNlZFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2FtZU9iamVjdHMuQ29tcG9uZW50c1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQWxwaGE6IHJlcXVpcmUoJy4vQWxwaGEnKSxcclxuICAgIEFuaW1hdGlvbjogcmVxdWlyZSgnLi9BbmltYXRpb24nKSxcclxuICAgIEJsZW5kTW9kZTogcmVxdWlyZSgnLi9CbGVuZE1vZGUnKSxcclxuICAgIENvbXB1dGVkU2l6ZTogcmVxdWlyZSgnLi9Db21wdXRlZFNpemUnKSxcclxuICAgIEZsaXA6IHJlcXVpcmUoJy4vRmxpcCcpLFxyXG4gICAgR2V0Qm91bmRzOiByZXF1aXJlKCcuL0dldEJvdW5kcycpLFxyXG4gICAgT3JpZ2luOiByZXF1aXJlKCcuL09yaWdpbicpLFxyXG4gICAgUmVuZGVyVGFyZ2V0OiByZXF1aXJlKCcuL1JlbmRlclRhcmdldCcpLFxyXG4gICAgU2NhbGVNb2RlOiByZXF1aXJlKCcuL1NjYWxlTW9kZScpLFxyXG4gICAgU2Nyb2xsRmFjdG9yOiByZXF1aXJlKCcuL1Njcm9sbEZhY3RvcicpLFxyXG4gICAgU2l6ZTogcmVxdWlyZSgnLi9TaXplJyksXHJcbiAgICBUZXh0dXJlOiByZXF1aXJlKCcuL1RleHR1cmUnKSxcclxuICAgIFRpbnQ6IHJlcXVpcmUoJy4vVGludCcpLFxyXG4gICAgVG9KU09OOiByZXF1aXJlKCcuL1RvSlNPTicpLFxyXG4gICAgVHJhbnNmb3JtOiByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxyXG4gICAgVHJhbnNmb3JtTWF0cml4OiByZXF1aXJlKCcuL1RyYW5zZm9ybU1hdHJpeCcpLFxyXG4gICAgVmlzaWJsZTogcmVxdWlyZSgnLi9WaXNpYmxlJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENPTlNUID0ge1xyXG5cclxuICAgIFZFUlNJT046ICczLjAuMCcsXHJcblxyXG4gICAgQmxlbmRNb2RlczogcmVxdWlyZSgnLi9yZW5kZXJlci9CbGVuZE1vZGVzJyksXHJcbiAgICBTY2FsZU1vZGVzOiByZXF1aXJlKCcuL3JlbmRlcmVyL1NjYWxlTW9kZXMnKSxcclxuXHJcbiAgICBBVVRPOiAwLFxyXG4gICAgQ0FOVkFTOiAxLFxyXG4gICAgV0VCR0w6IDIsXHJcbiAgICBIRUFETEVTUzogMyxcclxuXHJcbiAgICBGT1JFVkVSOiAtMSxcclxuXHJcbiAgICBOT05FOiA0LFxyXG4gICAgVVA6IDUsXHJcbiAgICBET1dOOiA2LFxyXG4gICAgTEVGVDogNyxcclxuICAgIFJJR0hUOiA4XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDT05TVDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0QWR2YW5jZWRWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL29iamVjdC9HZXRBZHZhbmNlZFZhbHVlJyk7XHJcbnZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvU2NhbGVNb2RlcycpO1xyXG52YXIgQmxlbmRNb2RlcyA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL0JsZW5kTW9kZXMnKTtcclxuXHJcbnZhciBCdWlsZEdhbWVPYmplY3QgPSBmdW5jdGlvbiAoc2NlbmUsIGdhbWVPYmplY3QsIGNvbmZpZylcclxue1xyXG4gICAgLy8gIFBvc2l0aW9uXHJcblxyXG4gICAgZ2FtZU9iamVjdC54ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd4JywgMCk7XHJcbiAgICBnYW1lT2JqZWN0LnkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3knLCAwKTtcclxuICAgIGdhbWVPYmplY3QuZGVwdGggPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2RlcHRoJywgMCk7XHJcblxyXG4gICAgLy8gIEZsaXBcclxuXHJcbiAgICBnYW1lT2JqZWN0LmZsaXBYID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmbGlwWCcsIGZhbHNlKTtcclxuICAgIGdhbWVPYmplY3QuZmxpcFkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2ZsaXBZJywgZmFsc2UpO1xyXG5cclxuICAgIC8vICBTY2FsZVxyXG4gICAgLy8gIEVpdGhlcjogeyBzY2FsZTogMiB9IG9yIHsgc2NhbGU6IHsgeDogMiwgeTogMiB9fVxyXG5cclxuICAgIHZhciBzY2FsZSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnc2NhbGUnLCBudWxsKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHNjYWxlID09PSAnbnVtYmVyJylcclxuICAgIHtcclxuICAgICAgICBnYW1lT2JqZWN0LnNldFNjYWxlKHNjYWxlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjYWxlICE9PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWVPYmplY3Quc2NhbGVYID0gR2V0QWR2YW5jZWRWYWx1ZShzY2FsZSwgJ3gnLCAxKTtcclxuICAgICAgICBnYW1lT2JqZWN0LnNjYWxlWSA9IEdldEFkdmFuY2VkVmFsdWUoc2NhbGUsICd5JywgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNjcm9sbEZhY3RvclxyXG4gICAgLy8gIEVpdGhlcjogeyBzY3JvbGxGYWN0b3I6IDIgfSBvciB7IHNjcm9sbEZhY3RvcjogeyB4OiAyLCB5OiAyIH19XHJcblxyXG4gICAgdmFyIHNjcm9sbEZhY3RvciA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnc2Nyb2xsRmFjdG9yJywgbnVsbCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBzY3JvbGxGYWN0b3IgPT09ICdudW1iZXInKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWVPYmplY3Quc2V0U2Nyb2xsRmFjdG9yKHNjcm9sbEZhY3Rvcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzY3JvbGxGYWN0b3IgIT09IG51bGwpXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JYID0gR2V0QWR2YW5jZWRWYWx1ZShzY3JvbGxGYWN0b3IsICd4JywgMSk7XHJcbiAgICAgICAgZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JZID0gR2V0QWR2YW5jZWRWYWx1ZShzY3JvbGxGYWN0b3IsICd5JywgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFJvdGF0aW9uXHJcblxyXG4gICAgZ2FtZU9iamVjdC5yb3RhdGlvbiA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAncm90YXRpb24nLCAwKTtcclxuXHJcbiAgICB2YXIgYW5nbGUgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2FuZ2xlJywgbnVsbCk7XHJcblxyXG4gICAgaWYgKGFuZ2xlICE9PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWVPYmplY3QuYW5nbGUgPSBhbmdsZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQWxwaGFcclxuXHJcbiAgICBnYW1lT2JqZWN0LmFscGhhID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdhbHBoYScsIDEpO1xyXG5cclxuICAgIC8vICBPcmlnaW5cclxuICAgIC8vICBFaXRoZXI6IHsgb3JpZ2luOiAwLjUgfSBvciB7IG9yaWdpbjogeyB4OiAwLjUsIHk6IDAuNSB9fVxyXG5cclxuICAgIHZhciBvcmlnaW4gPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ29yaWdpbicsIG51bGwpO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygb3JpZ2luID09PSAnbnVtYmVyJylcclxuICAgIHtcclxuICAgICAgICBnYW1lT2JqZWN0LnNldE9yaWdpbihvcmlnaW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3JpZ2luICE9PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBveCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAneCcsIDAuNSk7XHJcbiAgICAgICAgdmFyIG95ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd5JywgMC41KTtcclxuXHJcbiAgICAgICAgZ2FtZU9iamVjdC5zZXRPcmlnaW4ob3gsIG95KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgU2NhbGVNb2RlXHJcblxyXG4gICAgZ2FtZU9iamVjdC5zY2FsZU1vZGUgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3NjYWxlTW9kZScsIFNjYWxlTW9kZXMuREVGQVVMVCk7XHJcblxyXG4gICAgLy8gIEJsZW5kTW9kZVxyXG5cclxuICAgIGdhbWVPYmplY3QuYmxlbmRNb2RlID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdibGVuZE1vZGUnLCBCbGVuZE1vZGVzLk5PUk1BTCk7XHJcblxyXG4gICAgLy8gIFZpc2libGVcclxuXHJcbiAgICBnYW1lT2JqZWN0LnZpc2libGUgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3Zpc2libGUnLCB0cnVlKTtcclxuXHJcbiAgICAvLyAgQWRkIHRvIFNjZW5lXHJcblxyXG4gICAgdmFyIGFkZCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnYWRkJywgdHJ1ZSk7XHJcblxyXG4gICAgaWYgKGFkZClcclxuICAgIHtcclxuICAgICAgICBzY2VuZS5zeXMuZGlzcGxheUxpc3QuYWRkKGdhbWVPYmplY3QpO1xyXG5cclxuICAgICAgICBpZiAoZ2FtZU9iamVjdC5wcmVVcGRhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzY2VuZS5zeXMudXBkYXRlTGlzdC5hZGQoZ2FtZU9iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZEdhbWVPYmplY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvQnVpbGRHYW1lT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgU291cmNlIG9iamVjdFxyXG4vLyAgVGhlIGtleSBhcyBhIHN0cmluZywgY2FuIG9ubHkgYmUgMSBsZXZlbCBkZWVwIChubyBwZXJpb2RzKSwgbXVzdCBleGlzdCBhdCB0aGUgdG9wIGxldmVsIG9mIHRoZSBzb3VyY2Ugb2JqZWN0XHJcbi8vICBUaGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0XHJcblxyXG52YXIgR2V0RmFzdFZhbHVlID0gZnVuY3Rpb24gKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpXHJcbntcclxuICAgIHZhciB0ID0gdHlwZW9mKHNvdXJjZSk7XHJcblxyXG4gICAgaWYgKCFzb3VyY2UgfHwgdCA9PT0gJ251bWJlcicgfHwgdCA9PT0gJ3N0cmluZycpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2Vba2V5XTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRGYXN0VmFsdWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvb2JqZWN0L0dldEZhc3RWYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBQb2ludCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBQb2ludCAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUk5EID0gcmVxdWlyZSgnLi9yYW5kb20tZGF0YS1nZW5lcmF0b3IvUmFuZG9tRGF0YUdlbmVyYXRvcicpO1xyXG5cclxudmFyIE1BVEhfQ09OU1QgPSB7XHJcblxyXG4gICAgUEkyOiBNYXRoLlBJICogMixcclxuICAgIFRBVTogTWF0aC5QSSAqIDAuNSxcclxuICAgIEVQU0lMT046IDEuMGUtNixcclxuICAgIERFR19UT19SQUQ6IE1hdGguUEkgLyAxODAsXHJcbiAgICBSQURfVE9fREVHOiAxODAgLyBNYXRoLlBJLFxyXG5cclxuICAgIC8vICBSYW5kb20gRGF0YSBHZW5lcmF0b3JcclxuICAgIFJORDogbmV3IFJORCgpXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNQVRIX0NPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUV0VFTl9DT05TVCA9IHtcclxuXHJcbiAgICAvLyAgVHdlZW5EYXRhOlxyXG5cclxuICAgIENSRUFURUQ6IDAsXHJcbiAgICBJTklUOiAxLFxyXG4gICAgREVMQVk6IDIsXHJcbiAgICBPRkZTRVRfREVMQVk6IDMsXHJcbiAgICBQRU5ESU5HX1JFTkRFUjogNCxcclxuICAgIFBMQVlJTkdfRk9SV0FSRDogNSxcclxuICAgIFBMQVlJTkdfQkFDS1dBUkQ6IDYsXHJcbiAgICBIT0xEX0RFTEFZOiA3LFxyXG4gICAgUkVQRUFUX0RFTEFZOiA4LFxyXG4gICAgQ09NUExFVEU6IDksXHJcblxyXG4gICAgLy8gIFR3ZWVuIHNwZWNpZmljIChzdGFydHMgZnJvbSAyMCB0byBjbGVhbmx5IGFsbG93IGV4dHJhIFR3ZWVuRGF0YSBjb25zdHMgaW4gdGhlIGZ1dHVyZSlcclxuXHJcbiAgICBQRU5ESU5HX0FERDogMjAsXHJcbiAgICBQQVVTRUQ6IDIxLFxyXG4gICAgTE9PUF9ERUxBWTogMjIsXHJcbiAgICBBQ1RJVkU6IDIzLFxyXG4gICAgQ09NUExFVEVfREVMQVk6IDI0LFxyXG4gICAgUEVORElOR19SRU1PVkU6IDI1LFxyXG4gICAgUkVNT1ZFRDogMjZcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRXRUVOX0NPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL3R3ZWVuL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgU21vb3RoaW5nID0gcmVxdWlyZSgnLi9TbW9vdGhpbmcnKTtcclxuXHJcbi8vIFRoZSBwb29sIGludG8gd2hpY2ggdGhlIGNhbnZhcyBlbGVtZW50cyBhcmUgcGxhY2VkLlxyXG52YXIgcG9vbCA9IFtdO1xyXG5cclxuLy8gIEF1dG9tYXRpY2FsbHkgYXBwbHkgc21vb3RoaW5nKGZhbHNlKSB0byBjcmVhdGVkIENhbnZhcyBlbGVtZW50c1xyXG52YXIgX2Rpc2FibGVDb250ZXh0U21vb3RoaW5nID0gZmFsc2U7XHJcblxyXG4vLyAgVGhpcyBzaW5nbGV0b24gaXMgaW5zdGFudGlhdGVkIGFzIHNvb24gYXMgUGhhc2VyIGxvYWRzLFxyXG4vLyAgYmVmb3JlIGEgUGhhc2VyLkdhbWUgaW5zdGFuY2UgaGFzIGV2ZW4gYmVlbiBjcmVhdGVkLlxyXG4vLyAgV2hpY2ggbWVhbnMgYWxsIGluc3RhbmNlcyBvZiBQaGFzZXIgR2FtZXMgb24gdGhlIHNhbWUgcGFnZVxyXG4vLyAgY2FuIHNoYXJlIHRoZSBvbmUgc2luZ2xlIHBvb2xcclxuXHJcbi8vIFRoZSBDYW52YXNQb29sIGlzIGEgZ2xvYmFsIHN0YXRpYyBvYmplY3QsIHRoYXQgYWxsb3dzIFBoYXNlciB0byByZWN5Y2xlIGFuZCBwb29sIENhbnZhcyBET00gZWxlbWVudHMuXHJcbnZhciBDYW52YXNQb29sID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgLy8gQ3JlYXRlcyBhIG5ldyBDYW52YXMgRE9NIGVsZW1lbnQsIG9yIHB1bGxzIG9uZSBmcm9tIHRoZSBwb29sIGlmIGZyZWUuXHJcbiAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodCwgdHlwZSlcclxuICAgIHtcclxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDE7IH1cclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMTsgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHsgdHlwZSA9IENPTlNULkNBTlZBUzsgfVxyXG5cclxuICAgICAgICB2YXIgY2FudmFzO1xyXG4gICAgICAgIHZhciBjb250YWluZXIgPSBmaXJzdCh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHtcclxuICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxyXG4gICAgICAgICAgICAgICAgY2FudmFzOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHBvb2wucHVzaChjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgY2FudmFzID0gY29udGFpbmVyLmNhbnZhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnBhcmVudCA9IHBhcmVudDtcclxuXHJcbiAgICAgICAgICAgIGNhbnZhcyA9IGNvbnRhaW5lci5jYW52YXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoX2Rpc2FibGVDb250ZXh0U21vb3RoaW5nICYmIHR5cGUgPT09IENPTlNULkNBTlZBUylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNtb290aGluZy5kaXNhYmxlKGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNyZWF0ZTJEID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlKHBhcmVudCwgd2lkdGgsIGhlaWdodCwgQ09OU1QuQ0FOVkFTKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNyZWF0ZVdlYkdMID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlKHBhcmVudCwgd2lkdGgsIGhlaWdodCwgQ09OU1QuV0VCR0wpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHZXRzIHRoZSBmaXJzdCBmcmVlIGNhbnZhcyBpbmRleCBmcm9tIHRoZSBwb29sLlxyXG4gICAgdmFyIGZpcnN0ID0gZnVuY3Rpb24gKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkgeyB0eXBlID0gQ09OU1QuQ0FOVkFTOyB9XHJcblxyXG4gICAgICAgIHBvb2wuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIucGFyZW50ICYmIGNvbnRhaW5lci50eXBlID09PSB0eXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyAgTG9va3MgdXAgYSBjYW52YXMgYmFzZWQgb24gaXRzIHBhcmVudCwgYW5kIGlmIGZvdW5kIHB1dHMgaXQgYmFjayBpbiB0aGUgcG9vbCwgZnJlZWluZyBpdCB1cCBmb3IgcmUtdXNlLlxyXG4gICAgLy8gIFRoZSBjYW52YXMgaGFzIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IHNldCB0byAxLCBhbmQgaXRzIHBhcmVudCBhdHRyaWJ1dGUgbnVsbGVkLlxyXG4gICAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChwYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIENoZWNrIHRvIHNlZSBpZiB0aGUgcGFyZW50IGlzIGEgY2FudmFzIG9iamVjdFxyXG4gICAgICAgIHZhciBpc0NhbnZhcyA9IHBhcmVudCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xyXG5cclxuICAgICAgICBwb29sLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhaW5lcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICgoaXNDYW52YXMgJiYgY29udGFpbmVyLmNhbnZhcyA9PT0gcGFyZW50KSB8fCAoIWlzQ2FudmFzICYmIGNvbnRhaW5lci5wYXJlbnQgPT09IHBhcmVudCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXNQb29sLnJlbW92ZSBmb3VuZCBhbmQgcmVtb3ZlZCcpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLndpZHRoID0gMTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYW52YXMuaGVpZ2h0ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyAgR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIHVzZWQgY2FudmFzIGVsZW1lbnRzIGluIHRoZSBwb29sLlxyXG4gICAgdmFyIHRvdGFsID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYyA9IDA7XHJcblxyXG4gICAgICAgIHBvb2wuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH07XHJcblxyXG4gICAgLy8gIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBmcmVlIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cclxuICAgIHZhciBmcmVlID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gcG9vbC5sZW5ndGggLSB0b3RhbCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyAgRGlzYWJsZSBjb250ZXh0IHNtb290aGluZyBvbiBhbnkgbmV3IENhbnZhcyBlbGVtZW50IGNyZWF0ZWRcclxuICAgIHZhciBkaXNhYmxlU21vb3RoaW5nID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBfZGlzYWJsZUNvbnRleHRTbW9vdGhpbmcgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyAgRW5hYmxlIGNvbnRleHQgc21vb3RoaW5nIG9uIGFueSBuZXcgQ2FudmFzIGVsZW1lbnQgY3JlYXRlZFxyXG4gICAgdmFyIGVuYWJsZVNtb290aGluZyA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgX2Rpc2FibGVDb250ZXh0U21vb3RoaW5nID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY3JlYXRlMkQ6IGNyZWF0ZTJELFxyXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlLFxyXG4gICAgICAgIGNyZWF0ZVdlYkdMOiBjcmVhdGVXZWJHTCxcclxuICAgICAgICBkaXNhYmxlU21vb3RoaW5nOiBkaXNhYmxlU21vb3RoaW5nLFxyXG4gICAgICAgIGVuYWJsZVNtb290aGluZzogZW5hYmxlU21vb3RoaW5nLFxyXG4gICAgICAgIGZpcnN0OiBmaXJzdCxcclxuICAgICAgICBmcmVlOiBmcmVlLFxyXG4gICAgICAgIHBvb2w6IHBvb2wsXHJcbiAgICAgICAgcmVtb3ZlOiByZW1vdmUsXHJcbiAgICAgICAgdG90YWw6IHRvdGFsXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLy8gIElmIHdlIGV4cG9ydCB0aGUgY2FsbGVkIGZ1bmN0aW9uIGhlcmUsIGl0J2xsIG9ubHkgYmUgaW52b2tlZCBvbmNlIChub3QgZXZlcnkgdGltZSBpdCdzIHJlcXVpcmVkKS5cclxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNQb29sKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9tL0NhbnZhc1Bvb2wuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGSUxFX0NPTlNUID0ge1xyXG5cclxuICAgIExPQURFUl9JRExFOiAwLFxyXG4gICAgTE9BREVSX0xPQURJTkc6IDEsXHJcbiAgICBMT0FERVJfUFJPQ0VTU0lORzogMixcclxuICAgIExPQURFUl9DT01QTEVURTogMyxcclxuICAgIExPQURFUl9ERVNUUk9ZRUQ6IDQsXHJcblxyXG4gICAgRklMRV9QRU5ESU5HOiA1LCAgICAgIC8vIGZpbGUgaXMgaW4gdGhlIGxvYWQgcXVldWUgYnV0IG5vdCB5ZXQgc3RhcnRlZFxyXG4gICAgRklMRV9MT0FESU5HOiA2LCAgICAgIC8vIGZpbGUgaGFzIGJlZW4gc3RhcnRlZCB0byBsb2FkIGJ5IHRoZSBsb2FkZXIgKG9uTG9hZCBjYWxsZWQpXHJcbiAgICBGSUxFX0xPQURFRDogNywgICAgICAgLy8gZmlsZSBoYXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgYXdhaXRpbmcgcHJvY2Vzc2luZ1xyXG4gICAgRklMRV9GQUlMRUQ6IDgsICAgICAgIC8vIGZpbGUgZmFpbGVkIHRvIGxvYWRcclxuICAgIEZJTEVfUFJPQ0VTU0lORzogOSwgICAvLyBmaWxlIGlzIGJlaW5nIHByb2Nlc3NlZCAob25Qcm9jZXNzIGNhbGxiYWNrKVxyXG4gICAgRklMRV9XQUlUSU5HX0xJTktGSUxFOiAxMCwgICAvLyBmaWxlIGlzIGJlaW5nIHByb2Nlc3NlZCAob25Qcm9jZXNzIGNhbGxiYWNrKVxyXG4gICAgRklMRV9FUlJPUkVEOiAxMSwgICAvLyBmaWxlIGlzIGJlaW5nIHByb2Nlc3NlZCAob25Qcm9jZXNzIGNhbGxiYWNrKVxyXG4gICAgRklMRV9DT01QTEVURTogMTIsICAgICAvLyBmaWxlIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nXHJcbiAgICBGSUxFX0RFU1RST1lFRDogMTMsICAgICAvLyBmaWxlIGhhcyBiZWVuIGRlc3Ryb3llZFxyXG5cclxuICAgIFRFWFRVUkVfQVRMQVNfSlNPTl9BUlJBWTogMjAsXHJcbiAgICBURVhUVVJFX0FUTEFTX0pTT05fSEFTSDogMjFcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZJTEVfQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIFRyYW5zZm9ybU1hdHJpeCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1NYXRyaXggKGEsIGIsIGMsIGQsIHR4LCB0eSlcclxuICAgIHtcclxuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7IGEgPSAxOyB9XHJcbiAgICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkgeyBiID0gMDsgfVxyXG4gICAgICAgIGlmIChjID09PSB1bmRlZmluZWQpIHsgYyA9IDA7IH1cclxuICAgICAgICBpZiAoZCA9PT0gdW5kZWZpbmVkKSB7IGQgPSAxOyB9XHJcbiAgICAgICAgaWYgKHR4ID09PSB1bmRlZmluZWQpIHsgdHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHR5ID09PSB1bmRlZmluZWQpIHsgdHkgPSAwOyB9XHJcblxyXG4gICAgICAgIHRoaXMubWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShbIGEsIGIsIGMsIGQsIHR4LCB0eSwgMCwgMCwgMSBdKTtcclxuXHJcbiAgICAgICAgdGhpcy5kZWNvbXBvc2VkTWF0cml4ID0ge1xyXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxyXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiAwLFxyXG4gICAgICAgICAgICBzY2FsZVg6IDEsXHJcbiAgICAgICAgICAgIHNjYWxlWTogMSxcclxuICAgICAgICAgICAgcm90YXRpb246IDBcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkSWRlbnRpdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG4gICAgICAgIFxyXG4gICAgICAgIG1hdHJpeFswXSA9IDE7XHJcbiAgICAgICAgbWF0cml4WzFdID0gMDtcclxuICAgICAgICBtYXRyaXhbMl0gPSAwO1xyXG4gICAgICAgIG1hdHJpeFszXSA9IDE7XHJcbiAgICAgICAgbWF0cml4WzRdID0gMDtcclxuICAgICAgICBtYXRyaXhbNV0gPSAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcblxyXG4gICAgICAgIG1hdHJpeFs0XSA9IG1hdHJpeFswXSAqIHggKyBtYXRyaXhbMl0gKiB5ICsgbWF0cml4WzRdO1xyXG4gICAgICAgIG1hdHJpeFs1XSA9IG1hdHJpeFsxXSAqIHggKyBtYXRyaXhbM10gKiB5ICsgbWF0cml4WzVdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGU6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuXHJcbiAgICAgICAgbWF0cml4WzBdICo9IHg7XHJcbiAgICAgICAgbWF0cml4WzFdICo9IHg7XHJcbiAgICAgICAgbWF0cml4WzJdICo9IHk7XHJcbiAgICAgICAgbWF0cml4WzNdICo9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGU6IGZ1bmN0aW9uIChyYWRpYW4pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJhZGlhblNpbiA9IE1hdGguc2luKHJhZGlhbik7XHJcbiAgICAgICAgdmFyIHJhZGlhbkNvcyA9IE1hdGguY29zKHJhZGlhbik7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShyYWRpYW5Db3MsIC1yYWRpYW5TaW4sIHJhZGlhblNpbiwgcmFkaWFuQ29zLCAwLCAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChvdGhlck1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcblxyXG4gICAgICAgIHZhciBhMCA9IG1hdHJpeFswXTtcclxuICAgICAgICB2YXIgYjAgPSBtYXRyaXhbMV07XHJcbiAgICAgICAgdmFyIGMwID0gbWF0cml4WzJdO1xyXG4gICAgICAgIHZhciBkMCA9IG1hdHJpeFszXTtcclxuICAgICAgICB2YXIgdHgwID0gbWF0cml4WzRdO1xyXG4gICAgICAgIHZhciB0eTAgPSBtYXRyaXhbNV07XHJcblxyXG4gICAgICAgIHZhciBhMSA9IG90aGVyTWF0cml4WzBdO1xyXG4gICAgICAgIHZhciBiMSA9IG90aGVyTWF0cml4WzFdO1xyXG4gICAgICAgIHZhciBjMSA9IG90aGVyTWF0cml4WzJdO1xyXG4gICAgICAgIHZhciBkMSA9IG90aGVyTWF0cml4WzNdO1xyXG4gICAgICAgIHZhciB0eDEgPSBvdGhlck1hdHJpeFs0XTtcclxuICAgICAgICB2YXIgdHkxID0gb3RoZXJNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIG1hdHJpeFswXSA9IGExICogYTAgKyBiMSAqIGMwO1xyXG4gICAgICAgIG1hdHJpeFsxXSA9IGExICogYjAgKyBiMSAqIGQwO1xyXG4gICAgICAgIG1hdHJpeFsyXSA9IGMxICogYTAgKyBkMSAqIGMwO1xyXG4gICAgICAgIG1hdHJpeFszXSA9IGMxICogYjAgKyBkMSAqIGQwO1xyXG4gICAgICAgIG1hdHJpeFs0XSA9IHR4MSAqIGEwICsgdHkxICogYzAgKyB0eDA7XHJcbiAgICAgICAgbWF0cml4WzVdID0gdHgxICogYjAgKyB0eTEgKiBkMCArIHR5MDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHR4LCB0eSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcblxyXG4gICAgICAgIHZhciBhMCA9IG1hdHJpeFswXTtcclxuICAgICAgICB2YXIgYjAgPSBtYXRyaXhbMV07XHJcbiAgICAgICAgdmFyIGMwID0gbWF0cml4WzJdO1xyXG4gICAgICAgIHZhciBkMCA9IG1hdHJpeFszXTtcclxuICAgICAgICB2YXIgdHgwID0gbWF0cml4WzRdO1xyXG4gICAgICAgIHZhciB0eTAgPSBtYXRyaXhbNV07XHJcblxyXG4gICAgICAgIG1hdHJpeFswXSA9IGEgKiBhMCArIGIgKiBjMDtcclxuICAgICAgICBtYXRyaXhbMV0gPSBhICogYjAgKyBiICogZDA7XHJcbiAgICAgICAgbWF0cml4WzJdID0gYyAqIGEwICsgZCAqIGMwO1xyXG4gICAgICAgIG1hdHJpeFszXSA9IGMgKiBiMCArIGQgKiBkMDtcclxuICAgICAgICBtYXRyaXhbNF0gPSB0eCAqIGEwICsgdHkgKiBjMCArIHR4MDtcclxuICAgICAgICBtYXRyaXhbNV0gPSB0eCAqIGIwICsgdHkgKiBkMCArIHR5MDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zZm9ybVBvaW50OiBmdW5jdGlvbiAoeCwgeSwgcG9pbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHBvaW50ID09PSB1bmRlZmluZWQpIHsgcG9pbnQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcblxyXG4gICAgICAgIHZhciBhID0gbWF0cml4WzBdO1xyXG4gICAgICAgIHZhciBiID0gbWF0cml4WzFdO1xyXG4gICAgICAgIHZhciBjID0gbWF0cml4WzJdO1xyXG4gICAgICAgIHZhciBkID0gbWF0cml4WzNdO1xyXG4gICAgICAgIHZhciB0eCA9IG1hdHJpeFs0XTtcclxuICAgICAgICB2YXIgdHkgPSBtYXRyaXhbNV07XHJcblxyXG4gICAgICAgIHBvaW50LnggPSB4ICogYSArIHkgKiBjICsgdHg7XHJcbiAgICAgICAgcG9pbnQueSA9IHggKiBiICsgeSAqIGQgKyB0eTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgfSxcclxuXHJcbiAgICBpbnZlcnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG5cclxuICAgICAgICB2YXIgYSA9IG1hdHJpeFswXTtcclxuICAgICAgICB2YXIgYiA9IG1hdHJpeFsxXTtcclxuICAgICAgICB2YXIgYyA9IG1hdHJpeFsyXTtcclxuICAgICAgICB2YXIgZCA9IG1hdHJpeFszXTtcclxuICAgICAgICB2YXIgdHggPSBtYXRyaXhbNF07XHJcbiAgICAgICAgdmFyIHR5ID0gbWF0cml4WzVdO1xyXG5cclxuICAgICAgICB2YXIgbiA9IGEgKiBkIC0gYiAqIGM7XHJcblxyXG4gICAgICAgIG1hdHJpeFswXSA9IGQgLyBuO1xyXG4gICAgICAgIG1hdHJpeFsxXSA9IC1iIC8gbjtcclxuICAgICAgICBtYXRyaXhbMl0gPSAtYyAvIG47XHJcbiAgICAgICAgbWF0cml4WzNdID0gYSAvIG47XHJcbiAgICAgICAgbWF0cml4WzRdID0gKGMgKiB0eSAtIGQgKiB0eCkgLyBuO1xyXG4gICAgICAgIG1hdHJpeFs1XSA9IC0oYSAqIHR5IC0gYiAqIHR4KSAvIG47XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB0eCwgdHkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG5cclxuICAgICAgICBtYXRyaXhbMF0gPSBhO1xyXG4gICAgICAgIG1hdHJpeFsxXSA9IGI7XHJcbiAgICAgICAgbWF0cml4WzJdID0gYztcclxuICAgICAgICBtYXRyaXhbM10gPSBkO1xyXG4gICAgICAgIG1hdHJpeFs0XSA9IHR4O1xyXG4gICAgICAgIG1hdHJpeFs1XSA9IHR5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGVjb21wb3NlTWF0cml4OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkZWNvbXBvc2VkTWF0cml4ID0gdGhpcy5kZWNvbXBvc2VkTWF0cml4O1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcblxyXG4gICAgICAgIHZhciBhID0gbWF0cml4WzBdO1xyXG4gICAgICAgIHZhciBiID0gbWF0cml4WzFdO1xyXG4gICAgICAgIHZhciBjID0gbWF0cml4WzJdO1xyXG4gICAgICAgIHZhciBkID0gbWF0cml4WzNdO1xyXG5cclxuICAgICAgICB2YXIgYTIgPSBhICogYTtcclxuICAgICAgICB2YXIgYjIgPSBiICogYjtcclxuICAgICAgICB2YXIgYzIgPSBjICogYztcclxuICAgICAgICB2YXIgZDIgPSBkICogZDtcclxuXHJcbiAgICAgICAgdmFyIHN4ID0gTWF0aC5zcXJ0KGEyICsgYzIpO1xyXG4gICAgICAgIHZhciBzeSA9IE1hdGguc3FydChiMiArIGQyKTtcclxuXHJcbiAgICAgICAgZGVjb21wb3NlZE1hdHJpeC50cmFuc2xhdGVYID0gbWF0cml4WzRdO1xyXG4gICAgICAgIGRlY29tcG9zZWRNYXRyaXgudHJhbnNsYXRlWSA9IG1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgZGVjb21wb3NlZE1hdHJpeC5zY2FsZVggPSBzeDtcclxuICAgICAgICBkZWNvbXBvc2VkTWF0cml4LnNjYWxlWSA9IHN5O1xyXG5cclxuICAgICAgICBkZWNvbXBvc2VkTWF0cml4LnJvdGF0aW9uID0gTWF0aC5hY29zKGEgLyBzeCkgKiAoTWF0aC5hdGFuKC1jIC8gYSkgPCAwID8gLTEgOiAxKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRlY29tcG9zZWRNYXRyaXg7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qIGlkZW50aXR5ICsgdHJhbnNsYXRlICsgcm90YXRlICsgc2NhbGUgKi9cclxuICAgIGFwcGx5SVRSUzogZnVuY3Rpb24gKHgsIHksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcblxyXG4gICAgICAgIHZhciBzciA9IE1hdGguc2luKHJvdGF0aW9uKTtcclxuICAgICAgICB2YXIgY3IgPSBNYXRoLmNvcyhyb3RhdGlvbik7XHJcblxyXG4gICAgICAgIC8vIFRyYW5zbGF0ZVxyXG4gICAgICAgIG1hdHJpeFs0XSA9IHg7XHJcbiAgICAgICAgbWF0cml4WzVdID0geTtcclxuXHJcbiAgICAgICAgLy8gUm90YXRlIGFuZCBTY2FsZVxyXG4gICAgICAgIG1hdHJpeFswXSA9IGNyICogc2NhbGVYO1xyXG4gICAgICAgIG1hdHJpeFsxXSA9IC1zciAqIHNjYWxlWDtcclxuICAgICAgICBtYXRyaXhbMl0gPSBzciAqIHNjYWxlWTtcclxuICAgICAgICBtYXRyaXhbM10gPSBjciAqIHNjYWxlWTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtTWF0cml4O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvVHJhbnNmb3JtTWF0cml4LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxuLy8gIEVuY2Fwc3VsYXRlcyBhIDJEIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IGl0cyBjb3JuZXIgcG9pbnQgaW4gdGhlIHRvcC1sZWZ0XHJcbi8vICBhbmQgaXRzIGV4dGVuZHMgaW4geCAod2lkdGgpIGFuZCB5IChoZWlnaHQpXHJcblxyXG52YXIgUmVjdGFuZ2xlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFJlY3RhbmdsZSAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7IHdpZHRoID0gMDsgfVxyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSAwOyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRvOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VG8oMCwgMCwgMCwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSB3aWR0aDsgfVxyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgVE9QXHJcbiAgICBnZXRMaW5lQTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4geyB4MTogdGhpcy54LCB5MTogdGhpcy55LCB4MjogdGhpcy5yaWdodCwgeTI6IHRoaXMueSB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUklHSFRcclxuICAgIGdldExpbmVCOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB7IHgxOiB0aGlzLnJpZ2h0LCB5MTogdGhpcy55LCB4MjogdGhpcy5yaWdodCwgeTI6IHRoaXMuYm90dG9tIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBCT1RUT01cclxuICAgIGdldExpbmVDOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB7IHgxOiB0aGlzLnJpZ2h0LCB5MTogdGhpcy5ib3R0b20sIHgyOiB0aGlzLngsIHkyOiB0aGlzLmJvdHRvbSB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgTEVGVFxyXG4gICAgZ2V0TGluZUQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDE6IHRoaXMueCwgeTE6IHRoaXMuYm90dG9tLCB4MjogdGhpcy54LCB5MjogdGhpcy55IH07XHJcbiAgICB9LFxyXG5cclxuICAgIGxlZnQ6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSB0aGlzLnJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0IC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMueClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdmFsdWUgLSB0aGlzLng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3A6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSB0aGlzLmJvdHRvbSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9ICh0aGlzLmJvdHRvbSAtIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy55KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHZhbHVlIC0gdGhpcy55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2VudGVyWDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgKHRoaXMud2lkdGggLyAyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlIC0gKHRoaXMud2lkdGggLyAyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjZW50ZXJZOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyAodGhpcy5oZWlnaHQgLyAyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlIC0gKHRoaXMuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvUmVjdGFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2V0RmFzdFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldEZhc3RWYWx1ZScpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBHZXRVUkwgPSByZXF1aXJlKCcuL0dldFVSTCcpO1xyXG52YXIgTWVyZ2VYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vTWVyZ2VYSFJTZXR0aW5ncycpO1xyXG52YXIgWEhSTG9hZGVyID0gcmVxdWlyZSgnLi9YSFJMb2FkZXInKTtcclxudmFyIFhIUlNldHRpbmdzID0gcmVxdWlyZSgnLi9YSFJTZXR0aW5ncycpO1xyXG5cclxuLy8gIFBoYXNlci5Mb2FkZXIuRmlsZVxyXG5cclxudmFyIEZpbGUgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgLy8gb2xkIHNpZ25hdHVyZTogdHlwZSwga2V5LCB1cmwsIHJlc3BvbnNlVHlwZSwgeGhyU2V0dGluZ3MsIGNvbmZpZ1xyXG4gICAgZnVuY3Rpb24gRmlsZSAoZmlsZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICAvLyAgZmlsZSB0eXBlIChpbWFnZSwganNvbiwgZXRjKSBmb3Igc29ydGluZyB3aXRoaW4gdGhlIExvYWRlclxyXG4gICAgICAgIHRoaXMudHlwZSA9IEdldEZhc3RWYWx1ZShmaWxlQ29uZmlnLCAndHlwZScsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gIHVuaXF1ZSBjYWNoZSBrZXkgKHVuaXF1ZSB3aXRoaW4gaXRzIGZpbGUgdHlwZSlcclxuICAgICAgICB0aGlzLmtleSA9IEdldEZhc3RWYWx1ZShmaWxlQ29uZmlnLCAna2V5JywgZmFsc2UpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMudHlwZSB8fCAhdGhpcy5rZXkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLicgKyB0aGlzLnR5cGUgKyAnXFwnIGludmFsaWQga2V5IHByb3ZpZGVkLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFRoZSBVUkwgb2YgdGhlIGZpbGUsIG5vdCBpbmNsdWRpbmcgYmFzZVVSTFxyXG4gICAgICAgIHRoaXMudXJsID0gR2V0RmFzdFZhbHVlKGZpbGVDb25maWcsICd1cmwnKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudXJsID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVybCA9IEdldEZhc3RWYWx1ZShmaWxlQ29uZmlnLCAncGF0aCcsICcnKSArIHRoaXMua2V5ICsgJy4nICsgR2V0RmFzdFZhbHVlKGZpbGVDb25maWcsICdleHRlbnNpb24nLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXJsID0gR2V0RmFzdFZhbHVlKGZpbGVDb25maWcsICdwYXRoJywgJycpLmNvbmNhdCh0aGlzLnVybCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgU2V0IHdoZW4gdGhlIExvYWRlciBjYWxscyAnbG9hZCcgb24gdGhpcyBmaWxlXHJcbiAgICAgICAgdGhpcy5zcmMgPSAnJztcclxuXHJcbiAgICAgICAgdGhpcy54aHJTZXR0aW5ncyA9IFhIUlNldHRpbmdzKEdldEZhc3RWYWx1ZShmaWxlQ29uZmlnLCAncmVzcG9uc2VUeXBlJywgdW5kZWZpbmVkKSk7XHJcblxyXG4gICAgICAgIGlmIChHZXRGYXN0VmFsdWUoZmlsZUNvbmZpZywgJ3hoclNldHRpbmdzJywgZmFsc2UpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54aHJTZXR0aW5ncyA9IE1lcmdlWEhSU2V0dGluZ3ModGhpcy54aHJTZXR0aW5ncywgR2V0RmFzdFZhbHVlKGZpbGVDb25maWcsICd4aHJTZXR0aW5ncycsIHt9KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnhockxvYWRlciA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BFTkRJTkc7XHJcblxyXG4gICAgICAgIC8vICBTZXQgYnkgb25Qcm9ncmVzcyAob25seSBpZiBsb2FkaW5nIHZpYSBYSFIpXHJcbiAgICAgICAgdGhpcy5ieXRlc1RvdGFsID0gMDtcclxuICAgICAgICB0aGlzLmJ5dGVzTG9hZGVkID0gLTE7XHJcbiAgICAgICAgdGhpcy5wZXJjZW50Q29tcGxldGUgPSAtMTtcclxuXHJcbiAgICAgICAgLy8gIEZvciBDT1JzIGJhc2VkIGxvYWRpbmcuXHJcbiAgICAgICAgLy8gIElmIHRoaXMgaXMgdW5kZWZpbmVkIHRoZW4gdGhlIEZpbGUgd2lsbCBjaGVjayBCYXNlTG9hZGVyLmNyb3NzT3JpZ2luIGFuZCB1c2UgdGhhdCAoaWYgc2V0KVxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8vICBUaGUgYWN0dWFsIHByb2Nlc3NlZCBmaWxlIGRhdGFcclxuICAgICAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8vICBBIGNvbmZpZyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBieSBmaWxlIHR5cGVzIHRvIHN0b3JlIHRyYW5zaXRpb25hbCBkYXRhXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBHZXRGYXN0VmFsdWUoZmlsZUNvbmZpZywgJ2NvbmZpZycsIHt9KTtcclxuXHJcbiAgICAgICAgLy8gIE11bHRpcGFydCBmaWxlPyAoaS5lLiBhbiBhdGxhcyBhbmQgaXRzIGpzb24gdG9nZXRoZXIpXHJcbiAgICAgICAgdGhpcy5saW5rRmlsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxpbmtUeXBlID0gJyc7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldFhIUjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnhockxvYWRlci5vbmxvYWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy54aHJMb2FkZXIub25lcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnhockxvYWRlci5vbnByb2dyZXNzID0gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIHdoZW4gdGhlIEltYWdlIGxvYWRzXHJcbiAgICAvLyAgUHJvZ3Jlc3NFdmVudFxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZXNldFhIUigpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMsIHRydWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZXNldFhIUigpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMsIGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKGV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ieXRlc0xvYWRlZCA9IGV2ZW50LmxvYWRlZDtcclxuICAgICAgICAgICAgdGhpcy5ieXRlc1RvdGFsID0gZXZlbnQudG90YWw7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBlcmNlbnRDb21wbGV0ZSA9IE1hdGgubWluKCh0aGlzLmJ5dGVzTG9hZGVkIC8gdGhpcy5ieXRlc1RvdGFsKSwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnBlcmNlbnRDb21wbGV0ZSArICclICgnICsgdGhpcy5ieXRlc0xvYWRlZCArICcgYnl0ZXMpJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uUHJvY2VzczogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgICAgICBjYWxsYmFjayh0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5saW5rRmlsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmtGaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX1dBSVRJTkdfTElOS0ZJTEUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBUaGUgbGlua2ZpbGUgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcsIGFuZCBpcyB3YWl0aW5nIGZvciB0aGlzIGZpbGUsIHNvIGxldCdzIGRvIHRoZW0gYm90aFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfQ09NUExFVEU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtGaWxlLnN0YXRlID0gQ09OU1QuRklMRV9DT01QTEVURTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBUaGUgbGlua2ZpbGUgc3RpbGwgaGFzbid0IGZpbmlzaGVkIGxvYWRpbmcgYW5kL29yIHByb2Nlc3NpbmcgeWV0XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9XQUlUSU5HX0xJTktGSUxFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0NPTVBMRVRFO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGxlZCBieSB0aGUgTG9hZGVyLCBzdGFydHMgdGhlIGFjdHVhbCBmaWxlIGRvd25sb2FkaW5nXHJcbiAgICBsb2FkOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGJhc2VVUkwsIGdsb2JhbFhIUilcclxuICAgIHtcclxuICAgICAgICBpZiAoYmFzZVVSTCA9PT0gdW5kZWZpbmVkKSB7IGJhc2VVUkwgPSAnJzsgfVxyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG4gICAgICAgIHRoaXMuc3JjID0gR2V0VVJMKHRoaXMsIGJhc2VVUkwpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zcmMuaW5kZXhPZignZGF0YTonKSA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2NhbCBkYXRhIFVSSScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnhockxvYWRlciA9IFhIUkxvYWRlcih0aGlzLCBnbG9iYWxYSFIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9GaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQWRhcHRlZCBmcm9tIFtnbC1tYXRyaXhdKGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeCkgYnkgdG9qaSBcclxuLy8gIGFuZCBbdmVjbWF0aF0oaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL3ZlY21hdGgpIGJ5IG1hdHRkZXNsXHJcblxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIFZlY3RvcjIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gVmVjdG9yMiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geC54IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHgueSB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHkgfHwgMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uIChzcmMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ID0gc3JjLnggfHwgMDtcclxuICAgICAgICB0aGlzLnkgPSBzcmMueSB8fCAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geC54IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHgueSB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKHYpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy54ID09PSB2LngpICYmICh0aGlzLnkgPT09IHYueSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhbmdsZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xyXG5cclxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcclxuXHJcbiAgICAgICAgaWYgKGFuZ2xlIDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFuZ2xlICs9IDIgKiBNYXRoLlBJO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChzcmMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ICs9IHNyYy54O1xyXG4gICAgICAgIHRoaXMueSArPSBzcmMueTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAoc3JjKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCAtPSBzcmMueDtcclxuICAgICAgICB0aGlzLnkgLT0gc3JjLnk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKHNyYylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggKj0gc3JjLng7XHJcbiAgICAgICAgdGhpcy55ICo9IHNyYy55O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGU6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoaXNGaW5pdGUodmFsdWUpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ICo9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnkgKj0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAoc3JjKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCAvPSBzcmMueDtcclxuICAgICAgICB0aGlzLnkgLz0gc3JjLnk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBuZWdhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ID0gLXRoaXMueDtcclxuICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChzcmMpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGR4ID0gc3JjLnggLSB0aGlzLng7XHJcbiAgICAgICAgdmFyIGR5ID0gc3JjLnkgLSB0aGlzLnk7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZVNxOiBmdW5jdGlvbiAoc3JjKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkeCA9IHNyYy54IC0gdGhpcy54O1xyXG4gICAgICAgIHZhciBkeSA9IHNyYy55IC0gdGhpcy55O1xyXG5cclxuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgICB9LFxyXG5cclxuICAgIGxlbmd0aDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoU3E6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcblxyXG4gICAgICAgIHJldHVybiB4ICogeCArIHkgKiB5O1xyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHk7XHJcblxyXG4gICAgICAgIGlmIChsZW4gPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4ICogbGVuO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5ICogbGVuO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmlnaHQtaGFuZCBub3JtYWxpemUgKG1ha2UgdW5pdCBsZW5ndGgpIHRoaXMgVmVjdG9yXHJcbiAgICAqL1xyXG4gICAgbm9ybWFsaXplUmlnaHRIYW5kOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG5cclxuICAgICAgICB0aGlzLnggPSB0aGlzLnkgKiAtMTtcclxuICAgICAgICB0aGlzLnkgPSB4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZG90OiBmdW5jdGlvbiAoc3JjKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiBzcmMueCArIHRoaXMueSAqIHNyYy55O1xyXG4gICAgfSxcclxuXHJcbiAgICBjcm9zczogZnVuY3Rpb24gKHNyYylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogc3JjLnkgLSB0aGlzLnkgKiBzcmMueDtcclxuICAgIH0sXHJcblxyXG4gICAgbGVycDogZnVuY3Rpb24gKHNyYywgdClcclxuICAgIHtcclxuICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7IHQgPSAwOyB9XHJcblxyXG4gICAgICAgIHZhciBheCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgYXkgPSB0aGlzLnk7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGF4ICsgdCAqIChzcmMueCAtIGF4KTtcclxuICAgICAgICB0aGlzLnkgPSBheSArIHQgKiAoc3JjLnkgLSBheSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc2Zvcm1NYXQzOiBmdW5jdGlvbiAobWF0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciBtID0gbWF0LnZhbDtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XHJcbiAgICAgICAgdGhpcy55ID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc2Zvcm1NYXQ0OiBmdW5jdGlvbiAobWF0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciBtID0gbWF0LnZhbDtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xyXG4gICAgICAgIHRoaXMueSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgdGhpcy55ID0gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcblZlY3RvcjIucHJvdG90eXBlLnN1YiA9IFZlY3RvcjIucHJvdG90eXBlLnN1YnRyYWN0O1xyXG5WZWN0b3IyLnByb3RvdHlwZS5tdWwgPSBWZWN0b3IyLnByb3RvdHlwZS5tdWx0aXBseTtcclxuVmVjdG9yMi5wcm90b3R5cGUuZGl2ID0gVmVjdG9yMi5wcm90b3R5cGUuZGl2aWRlO1xyXG5WZWN0b3IyLnByb3RvdHlwZS5kaXN0ID0gVmVjdG9yMi5wcm90b3R5cGUuZGlzdGFuY2U7XHJcblZlY3RvcjIucHJvdG90eXBlLmRpc3RTcSA9IFZlY3RvcjIucHJvdG90eXBlLmRpc3RhbmNlU3E7XHJcblZlY3RvcjIucHJvdG90eXBlLmxlbiA9IFZlY3RvcjIucHJvdG90eXBlLmxlbmd0aDtcclxuVmVjdG9yMi5wcm90b3R5cGUubGVuU3EgPSBWZWN0b3IyLnByb3RvdHlwZS5sZW5ndGhTcTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yMjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL1ZlY3RvcjIuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XHJcbiovXHJcblxyXG52YXIgR2V0Qm90dG9tID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHJldHVybiAoZ2FtZU9iamVjdC55ICsgZ2FtZU9iamVjdC5oZWlnaHQpIC0gKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5vcmlnaW5ZKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qm90dG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9HZXRCb3R0b20uanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XHJcbiovXHJcblxyXG52YXIgR2V0TGVmdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdC54IC0gKGdhbWVPYmplY3Qud2lkdGggKiBnYW1lT2JqZWN0Lm9yaWdpblgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRMZWZ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9HZXRMZWZ0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgbGVmdCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB4IC0gb2Zmc2V0WGAuXHJcbipcclxuKiBAcHJvcGVydHkge251bWJlcn0gbGVmdFxyXG4qL1xyXG5cclxudmFyIEdldFJpZ2h0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHJldHVybiAoZ2FtZU9iamVjdC54ICsgZ2FtZU9iamVjdC53aWR0aCkgLSAoZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Qub3JpZ2luWCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFJpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9HZXRSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeSAtIG9mZnNldFlgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IHRvcFxyXG4qL1xyXG5cclxudmFyIEdldFRvcCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdC55IC0gKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5vcmlnaW5ZKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VG9wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9HZXRUb3AuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XHJcbiovXHJcblxyXG52YXIgU2V0Qm90dG9tID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHZhbHVlKVxyXG57XHJcbiAgICBnYW1lT2JqZWN0LnkgPSAodmFsdWUgLSBnYW1lT2JqZWN0LmhlaWdodCkgKyAoZ2FtZU9iamVjdC5oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRCb3R0b207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL1NldEJvdHRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeCAtIG9mZnNldFhgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcclxuKi9cclxuXHJcbnZhciBTZXRMZWZ0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHZhbHVlKVxyXG57XHJcbiAgICBnYW1lT2JqZWN0LnggPSB2YWx1ZSArIChnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5vcmlnaW5YKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0TGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9ib3VuZHMvU2V0TGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeCAtIG9mZnNldFhgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcclxuKi9cclxuXHJcbnZhciBTZXRSaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB2YWx1ZSlcclxue1xyXG4gICAgZ2FtZU9iamVjdC54ID0gKHZhbHVlIC0gZ2FtZU9iamVjdC53aWR0aCkgKyAoZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Qub3JpZ2luWCk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFJpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9TZXRSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeSAtIG9mZnNldFlgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IHRvcFxyXG4qL1xyXG5cclxudmFyIFNldFRvcCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB2YWx1ZSlcclxue1xyXG4gICAgZ2FtZU9iamVjdC55ID0gdmFsdWUgKyAoZ2FtZU9iamVjdC5oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRUb3A7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL1NldFRvcC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBEYXRhQnVmZmVyMzIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gRGF0YUJ1ZmZlcjMyIChieXRlU2l6ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmR3b3JkTGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmR3b3JkQ2FwYWNpdHkgPSBieXRlU2l6ZSAvIDQ7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVNpemUpO1xyXG4gICAgICAgIHRoaXMuZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5pbnRWaWV3ID0gbmV3IEludDMyQXJyYXkodGhpcy5idWZmZXIpO1xyXG4gICAgICAgIHRoaXMudWludFZpZXcgPSBuZXcgVWludDMyQXJyYXkodGhpcy5idWZmZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmR3b3JkTGVuZ3RoID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Qnl0ZUxlbmd0aDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kd29yZExlbmd0aCAqIDQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEJ5dGVDYXBhY2l0eTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgIH0sXHJcblxyXG4gICAgYWxsb2NhdGU6IGZ1bmN0aW9uIChkd29yZFNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLmR3b3JkTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuZHdvcmRMZW5ndGggKz0gZHdvcmRTaXplO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50TGVuZ3RoO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRVc2VkQnVmZmVyQXNGbG9hdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdFZpZXcuc3ViYXJyYXkoMCwgdGhpcy5kd29yZExlbmd0aCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVzZWRCdWZmZXJBc0ludDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRVc2VkQnVmZmVyQXNVaW50OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVpbnRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFCdWZmZXIzMjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC91dGlscy9EYXRhQnVmZmVyMzIuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudEJpbmRpbmcgPSByZXF1aXJlKCcuL0V2ZW50QmluZGluZycpO1xyXG5cclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIgKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5oYXNGaWx0ZXJzID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEJpbmRpbmc6IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdzLmhhc093blByb3BlcnR5KHR5cGUpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVCaW5kaW5nOiBmdW5jdGlvbiAodHlwZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuZ2V0QmluZGluZyh0eXBlKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZV0gPSBuZXcgRXZlbnRCaW5kaW5nKHRoaXMsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbdHlwZV07XHJcbiAgICB9LFxyXG5cclxuICAgIG9uOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIHByaW9yaXR5KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7IHByaW9yaXR5ID0gMDsgfVxyXG5cclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuY3JlYXRlQmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLmFkZChsaXN0ZW5lciwgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbmNlOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIHByaW9yaXR5KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7IHByaW9yaXR5ID0gMDsgfVxyXG5cclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuY3JlYXRlQmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLmFkZChsaXN0ZW5lciwgcHJpb3JpdHksIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBBZGQgYSBjYWxsYmFjayB0aGF0IGlzIG5vdGlmaWVkIGV2ZXJ5IHRpbWUgdGhpcyBFdmVudERpc3BhdGNoZXIgZGlzcGF0Y2hlcyBhbiBldmVudFxyXG4gICAgLy8gIG5vIG1hdHRlciB3aGF0IHRoZSBldmVudCB0eXBlIGlzLiBGaWx0ZXJzIGFyZSBpbnZva2VkIGZpcnN0LCBiZWZvcmUgYW55IGJpbmRpbmdzLFxyXG4gICAgLy8gIGFuZCBjYW4gc3RvcCBldmVudHMgaWYgdGhleSB3aXNoIChpbiB3aGljaCBjYXNlIHRoZXknbGwgbmV2ZXIgcmVhY2ggdGhlIGJpbmRpbmdzKVxyXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmZpbHRlcnMuaW5kZXhPZihjYWxsYmFjayk7XHJcblxyXG4gICAgICAgIGlmIChpID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBBZGQgdGhlIGZpbHRlclxyXG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBSZW1vdmUgdGhlIGZpbHRlclxyXG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmhhc0ZpbHRlcnMgPSAodGhpcy5maWx0ZXJzLmxlbmd0aCA+IDApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaGFzOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcodHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChiaW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmcuaGFzKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdG90YWw6IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nLnRvdGFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgIC8vICBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBsaXN0ZW5lciByZWdpc3RlcmVkIHdpdGggdGhlIEV2ZW50RGlzcGF0Y2hlciwgYSBjYWxsIHRvIHRoaXMgbWV0aG9kIGhhcyBubyBlZmZlY3QuXHJcbiAgICBvZmY6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcilcclxuICAgIHtcclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLnJlbW92ZShsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgX2Rpc3BhdGNoSGFuZGxlcjogZnVuY3Rpb24gKGV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIGV2ZW50LnJlc2V0KHRoaXMpO1xyXG5cclxuICAgICAgICAvLyAgUGFzcyB0aGUgZXZlbnQgdGhyb3VnaCB0aGUgZmlsdGVycyBmaXJzdFxyXG5cclxuICAgICAgICBpZiAodGhpcy5oYXNGaWx0ZXJzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgRGlkIHRoZSBmaWx0ZXIga2lsbCB0aGUgZXZlbnQ/IElmIHNvLCB3ZSBjYW4gYWJvcnQgbm93XHJcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Ll9wcm9wYWdhdGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyhldmVudC50eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLmRpc3BhdGNoKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hIYW5kbGVyKGV2ZW50W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEhhbmRsZXIoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFJlbW92ZXMgYWxsIGxpc3RlbmVycywgYnV0IHJldGFpbnMgdGhlIGV2ZW50IHR5cGUgZW50cmllc1xyXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAodHlwZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUFsbEZpbHRlcnM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuaGFzRmlsdGVycyA9IGZhbHNlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGVsZXRlOiBmdW5jdGlvbiAodHlwZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW3R5cGVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGV0ZUFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBiaW5kaW5nIGluIHRoaXMuYmluZGluZ3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRlbGV0ZUFsbCgpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsRmlsdGVycygpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RGlzcGF0Y2hlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cycpO1xyXG52YXIgU3ByaXRlUmVuZGVyID0gcmVxdWlyZSgnLi9TcHJpdGVSZW5kZXInKTtcclxuXHJcbnZhciBTcHJpdGUgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLkZsaXAsXHJcbiAgICAgICAgQ29tcG9uZW50cy5HZXRCb3VuZHMsXHJcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXHJcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJUYXJnZXQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TaXplLFxyXG4gICAgICAgIENvbXBvbmVudHMuVGV4dHVyZSxcclxuICAgICAgICBDb21wb25lbnRzLlRpbnQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIFNwcml0ZVJlbmRlclxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFNwcml0ZSAoc2NlbmUsIHgsIHksIHRleHR1cmUsIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzY2VuZSwgJ1Nwcml0ZScpO1xyXG5cclxuICAgICAgICB0aGlzLmFuaW1zID0gbmV3IENvbXBvbmVudHMuQW5pbWF0aW9uKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRleHR1cmUodGV4dHVyZSwgZnJhbWUpO1xyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5zZXRTaXplVG9GcmFtZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0T3JpZ2luKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHByZVVwZGF0ZTogZnVuY3Rpb24gKHRpbWUsIGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYW5pbXMudXBkYXRlKHRpbWUsIGRlbHRhKTtcclxuICAgIH0sXHJcblxyXG4gICAgcGxheTogZnVuY3Rpb24gKGtleSwgc3RhcnRGcmFtZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFuaW1zLnBsYXkoa2V5LCBzdGFydEZyYW1lKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IENvbXBvbmVudHMuVG9KU09OKHRoaXMpO1xyXG5cclxuICAgICAgICAvLyAgRXh0cmEgU3ByaXRlIGRhdGEgaXMgYWRkZWQgaGVyZVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIGlmIChyZWN0LndpZHRoIDw9IDAgfHwgcmVjdC5oZWlnaHQgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChyZWN0LnggPD0geCAmJiByZWN0LnggKyByZWN0LndpZHRoID49IHggJiYgcmVjdC55IDw9IHkgJiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPj0geSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2V0Q29sb3IgPSByZXF1aXJlKCcuL0dldENvbG9yJyk7XHJcbnZhciBHZXRDb2xvcjMyID0gcmVxdWlyZSgnLi9HZXRDb2xvcjMyJyk7XHJcblxyXG52YXIgQ29sb3IgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQ29sb3IgKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyZWQgPT09IHVuZGVmaW5lZCkgeyByZWQgPSAwOyB9XHJcbiAgICAgICAgaWYgKGdyZWVuID09PSB1bmRlZmluZWQpIHsgZ3JlZW4gPSAwOyB9XHJcbiAgICAgICAgaWYgKGJsdWUgPT09IHVuZGVmaW5lZCkgeyBibHVlID0gMDsgfVxyXG4gICAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7IGFscGhhID0gMjU1OyB9XHJcblxyXG4gICAgICAgIC8vICBBbGwgcHJpdmF0ZVxyXG4gICAgICAgIHRoaXMuciA9IDA7XHJcbiAgICAgICAgdGhpcy5nID0gMDtcclxuICAgICAgICB0aGlzLmIgPSAwO1xyXG4gICAgICAgIHRoaXMuYSA9IDI1NTtcclxuXHJcbiAgICAgICAgdGhpcy5nbCA9IFsgMC4wLCAwLjAsIDAuMCwgMS4wIF07XHJcblxyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gMDtcclxuICAgICAgICB0aGlzLl9jb2xvcjMyID0gMDtcclxuICAgICAgICB0aGlzLl9yZ2JhID0gJyc7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VG8ocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc3BhcmVudDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5ncmVlbiA9IDA7XHJcbiAgICAgICAgdGhpcy5ibHVlID0gMDtcclxuICAgICAgICB0aGlzLmFscGhhID0gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBWYWx1ZXMgYXJlIGluIHRoZSByYW5nZSAwIHRvIDI1NVxyXG4gICAgc2V0VG86IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcclxuICAgIHtcclxuICAgICAgICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkgeyBhbHBoYSA9IDI1NTsgfVxyXG5cclxuICAgICAgICB0aGlzLnJlZCA9IHJlZDtcclxuICAgICAgICB0aGlzLmdyZWVuID0gZ3JlZW47XHJcbiAgICAgICAgdGhpcy5ibHVlID0gYmx1ZTtcclxuICAgICAgICB0aGlzLmFscGhhID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgVmFsdWVzIGFyZSBpbiB0aGUgcmFuZ2UgMCB0byAxXHJcbiAgICBzZXRHTFRvOiBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHsgYWxwaGEgPSAxOyB9XHJcblxyXG4gICAgICAgIHRoaXMucmVkR0wgPSByZWQ7XHJcbiAgICAgICAgdGhpcy5ncmVlbkdMID0gZ3JlZW47XHJcbiAgICAgICAgdGhpcy5ibHVlR0wgPSBibHVlO1xyXG4gICAgICAgIHRoaXMuYWxwaGFHTCA9IGFscGhhO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJvbVJHQjogZnVuY3Rpb24gKGNvbG9yKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVkID0gY29sb3IucjtcclxuICAgICAgICB0aGlzLmdyZWVuID0gY29sb3IuZztcclxuICAgICAgICB0aGlzLmJsdWUgPSBjb2xvci5iO1xyXG5cclxuICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoJ2EnKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxwaGEgPSBjb2xvci5hO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9jb2xvciA9IEdldENvbG9yKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yMzIgPSBHZXRDb2xvcjMyKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgdGhpcy5fcmdiYSA9ICdyZ2JhKCcgKyB0aGlzLnIgKyAnLCcgKyB0aGlzLmcgKyAnLCcgKyB0aGlzLmIgKyAnLCcgKyAodGhpcy5hIC8gMjU1KSArICcpJztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBTYW1lIGFzIHNldFJHQiBidXQgcGVyZm9ybXMgc2FmZXR5IGNoZWNrcyBvbiBhbGwgdGhlIHZhbHVlcyBnaXZlblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb2xvcjoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY29sb3IzMjoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3IzMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZ2JhOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZ2JhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBHZXRzIGFuZCBzZXRzIHRoZSByZWQgdmFsdWUsIG5vcm1hbGl6ZWQgdG8gdGhlIDAgdG8gMSByYW5nZVxyXG4gICAgcmVkR0w6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xbMF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmdsWzBdID0gTWF0aC5taW4oTWF0aC5hYnModmFsdWUpLCAxKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuciA9IE1hdGguZmxvb3IodGhpcy5nbFswXSAqIDI1NSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdyZWVuR0w6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xbMV07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmdsWzFdID0gTWF0aC5taW4oTWF0aC5hYnModmFsdWUpLCAxKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZyA9IE1hdGguZmxvb3IodGhpcy5nbFsxXSAqIDI1NSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJsdWVHTDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbFsyXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xbMl0gPSBNYXRoLm1pbihNYXRoLmFicyh2YWx1ZSksIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5mbG9vcih0aGlzLmdsWzJdICogMjU1KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGFHTDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbFszXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xbM10gPSBNYXRoLm1pbihNYXRoLmFicyh2YWx1ZSksIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hID0gTWF0aC5mbG9vcih0aGlzLmdsWzNdICogMjU1KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEdldHMgYW5kIHNldHMgdGhlIHJlZCB2YWx1ZSwgbm9ybWFsaXplZCB0byB0aGUgMCB0byAyNTUgcmFuZ2VcclxuICAgIHJlZDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKE1hdGguYWJzKHZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnIgPSBNYXRoLm1pbih2YWx1ZSwgMjU1KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2xbMF0gPSB2YWx1ZSAvIDI1NTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ3JlZW46IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihNYXRoLmFicyh2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5nID0gTWF0aC5taW4odmFsdWUsIDI1NSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdsWzFdID0gdmFsdWUgLyAyNTU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJsdWU6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihNYXRoLmFicyh2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4odmFsdWUsIDI1NSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdsWzJdID0gdmFsdWUgLyAyNTU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFscGhhOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IoTWF0aC5hYnModmFsdWUpKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYSA9IE1hdGgubWluKHZhbHVlLCAyNTUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5nbFszXSA9IHZhbHVlIC8gMjU1O1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQWRhcHRlZCBmcm9tIFtnbC1tYXRyaXhdKGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeCkgYnkgdG9qaSBcclxuLy8gIGFuZCBbdmVjbWF0aF0oaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL3ZlY21hdGgpIGJ5IG1hdHRkZXNsXHJcblxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIFZlY3RvcjMgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gVmVjdG9yMyAoeCwgeSwgeilcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geC54IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHgueSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnogPSB4LnogfHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geCB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IHogfHwgMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcclxuICAgIH0sXHJcblxyXG4gICAgY3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoYSwgYilcclxuICAgIHtcclxuICAgICAgICB2YXIgYXggPSBhLng7XHJcbiAgICAgICAgdmFyIGF5ID0gYS55O1xyXG4gICAgICAgIHZhciBheiA9IGEuejtcclxuICAgICAgICB2YXIgYnggPSBiLng7XHJcbiAgICAgICAgdmFyIGJ5ID0gYi55O1xyXG4gICAgICAgIHZhciBieiA9IGIuejtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XHJcbiAgICAgICAgdGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XHJcbiAgICAgICAgdGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBlcXVhbHM6IGZ1bmN0aW9uICh2KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMueCA9PT0gdi54KSAmJiAodGhpcy55ID09PSB2LnkpICYmICh0aGlzLnogPT09IHYueikpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoc3JjKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IHNyYy54O1xyXG4gICAgICAgIHRoaXMueSA9IHNyYy55O1xyXG4gICAgICAgIHRoaXMueiA9IHNyYy56IHx8IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICh4LCB5LCB6KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4LnggfHwgMDtcclxuICAgICAgICAgICAgdGhpcy55ID0geC55IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IHgueiB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHkgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy56ID0geiB8fCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHYpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ICs9IHYueDtcclxuICAgICAgICB0aGlzLnkgKz0gdi55O1xyXG4gICAgICAgIHRoaXMueiArPSB2LnogfHwgMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAodilcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggLT0gdi54O1xyXG4gICAgICAgIHRoaXMueSAtPSB2Lnk7XHJcbiAgICAgICAgdGhpcy56IC09IHYueiB8fCAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uICh2KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCAqPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ICo9IHYueTtcclxuICAgICAgICB0aGlzLnogKj0gdi56IHx8IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZTogZnVuY3Rpb24gKHNjYWxlKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChpc0Zpbml0ZShzY2FsZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggKj0gc2NhbGU7XHJcbiAgICAgICAgICAgIHRoaXMueSAqPSBzY2FsZTtcclxuICAgICAgICAgICAgdGhpcy56ICo9IHNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnogPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpdmlkZTogZnVuY3Rpb24gKHYpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54IC89IHYueDtcclxuICAgICAgICB0aGlzLnkgLz0gdi55O1xyXG4gICAgICAgIHRoaXMueiAvPSB2LnogfHwgMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIG5lZ2F0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSAtdGhpcy54O1xyXG4gICAgICAgIHRoaXMueSA9IC10aGlzLnk7XHJcbiAgICAgICAgdGhpcy56ID0gLXRoaXMuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAodilcclxuICAgIHtcclxuICAgICAgICB2YXIgZHggPSB2LnggLSB0aGlzLng7XHJcbiAgICAgICAgdmFyIGR5ID0gdi55IC0gdGhpcy55O1xyXG4gICAgICAgIHZhciBkeiA9IHYueiAtIHRoaXMueiB8fCAwO1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlU3E6IGZ1bmN0aW9uICh2KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkeCA9IHYueCAtIHRoaXMueDtcclxuICAgICAgICB2YXIgZHkgPSB2LnkgLSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIGR6ID0gdi56IC0gdGhpcy56IHx8IDA7XHJcblxyXG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XHJcbiAgICB9LFxyXG5cclxuICAgIGxlbmd0aDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuICAgICAgICB2YXIgeiA9IHRoaXMuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xyXG4gICAgfSxcclxuXHJcbiAgICBsZW5ndGhTcTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuICAgICAgICB2YXIgeiA9IHRoaXMuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcclxuICAgIH0sXHJcblxyXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciB6ID0gdGhpcy56O1xyXG4gICAgICAgIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XHJcblxyXG4gICAgICAgIGlmIChsZW4gPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy54ID0geCAqIGxlbjtcclxuICAgICAgICAgICAgdGhpcy55ID0geSAqIGxlbjtcclxuICAgICAgICAgICAgdGhpcy56ID0geiAqIGxlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBkb3Q6IGZ1bmN0aW9uICh2KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyb3NzOiBmdW5jdGlvbiAodilcclxuICAgIHtcclxuICAgICAgICB2YXIgYXggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIGF5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciBheiA9IHRoaXMuejtcclxuICAgICAgICB2YXIgYnggPSB2Lng7XHJcbiAgICAgICAgdmFyIGJ5ID0gdi55O1xyXG4gICAgICAgIHZhciBieiA9IHYuejtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XHJcbiAgICAgICAgdGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XHJcbiAgICAgICAgdGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwOiBmdW5jdGlvbiAodiwgdClcclxuICAgIHtcclxuICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7IHQgPSAwOyB9XHJcblxyXG4gICAgICAgIHZhciBheCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgYXkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIGF6ID0gdGhpcy56O1xyXG5cclxuICAgICAgICB0aGlzLnggPSBheCArIHQgKiAodi54IC0gYXgpO1xyXG4gICAgICAgIHRoaXMueSA9IGF5ICsgdCAqICh2LnkgLSBheSk7XHJcbiAgICAgICAgdGhpcy56ID0gYXogKyB0ICogKHYueiAtIGF6KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zZm9ybU1hdDM6IGZ1bmN0aW9uIChtYXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XHJcbiAgICAgICAgdmFyIG0gPSBtYXQudmFsO1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XHJcbiAgICAgICAgdGhpcy55ID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xyXG4gICAgICAgIHRoaXMueiA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zZm9ybU1hdDQ6IGZ1bmN0aW9uIChtYXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XHJcbiAgICAgICAgdmFyIG0gPSBtYXQudmFsO1xyXG5cclxuICAgICAgICB0aGlzLnggPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXTtcclxuICAgICAgICB0aGlzLnkgPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXTtcclxuICAgICAgICB0aGlzLnogPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc2Zvcm1RdWF0OiBmdW5jdGlvbiAocSlcclxuICAgIHtcclxuICAgICAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciB6ID0gdGhpcy56O1xyXG4gICAgICAgIHZhciBxeCA9IHEueDtcclxuICAgICAgICB2YXIgcXkgPSBxLnk7XHJcbiAgICAgICAgdmFyIHF6ID0gcS56O1xyXG4gICAgICAgIHZhciBxdyA9IHEudztcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcclxuICAgICAgICB2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XHJcbiAgICAgICAgdmFyIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xyXG4gICAgICAgIHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcclxuICAgICAgICB2YXIgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xyXG5cclxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XHJcbiAgICAgICAgdGhpcy54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcclxuICAgICAgICB0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xyXG4gICAgICAgIHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGxpZXMgdGhpcyBWZWN0b3IzIGJ5IHRoZSBzcGVjaWZpZWQgbWF0cml4LCBcclxuICAgICAqIGFwcGx5aW5nIGEgVyBkaXZpZGUuIFRoaXMgaXMgdXNlZnVsIGZvciBwcm9qZWN0aW9uLFxyXG4gICAgICogZS5nLiB1bnByb2plY3RpbmcgYSAyRCBwb2ludCBpbnRvIDNEIHNwYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcHJvamVjdFxyXG4gICAgICogQHBhcmFtIHtNYXRyaXg0fSB0aGUgNHg0IG1hdHJpeCB0byBtdWx0aXBseSB3aXRoIFxyXG4gICAgICogQHJldHVybiB7VmVjdG9yM30gdGhpcyBvYmplY3QgZm9yIGNoYWluaW5nXHJcbiAgICAgKi9cclxuICAgIHByb2plY3Q6IGZ1bmN0aW9uIChtYXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XHJcbiAgICAgICAgdmFyIG0gPSBtYXQudmFsO1xyXG5cclxuICAgICAgICB2YXIgYTAwID0gbVswXTtcclxuICAgICAgICB2YXIgYTAxID0gbVsxXTtcclxuICAgICAgICB2YXIgYTAyID0gbVsyXTtcclxuICAgICAgICB2YXIgYTAzID0gbVszXTtcclxuICAgICAgICB2YXIgYTEwID0gbVs0XTtcclxuICAgICAgICB2YXIgYTExID0gbVs1XTtcclxuICAgICAgICB2YXIgYTEyID0gbVs2XTtcclxuICAgICAgICB2YXIgYTEzID0gbVs3XTtcclxuICAgICAgICB2YXIgYTIwID0gbVs4XTtcclxuICAgICAgICB2YXIgYTIxID0gbVs5XTtcclxuICAgICAgICB2YXIgYTIyID0gbVsxMF07XHJcbiAgICAgICAgdmFyIGEyMyA9IG1bMTFdO1xyXG4gICAgICAgIHZhciBhMzAgPSBtWzEyXTtcclxuICAgICAgICB2YXIgYTMxID0gbVsxM107XHJcbiAgICAgICAgdmFyIGEzMiA9IG1bMTRdO1xyXG4gICAgICAgIHZhciBhMzMgPSBtWzE1XTtcclxuXHJcbiAgICAgICAgdmFyIGx3ID0gMSAvICh4ICogYTAzICsgeSAqIGExMyArIHogKiBhMjMgKyBhMzMpO1xyXG5cclxuICAgICAgICB0aGlzLnggPSAoeCAqIGEwMCArIHkgKiBhMTAgKyB6ICogYTIwICsgYTMwKSAqIGx3O1xyXG4gICAgICAgIHRoaXMueSA9ICh4ICogYTAxICsgeSAqIGExMSArIHogKiBhMjEgKyBhMzEpICogbHc7XHJcbiAgICAgICAgdGhpcy56ID0gKHggKiBhMDIgKyB5ICogYTEyICsgeiAqIGEyMiArIGEzMikgKiBsdztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5wcm9qZWN0IHRoaXMgcG9pbnQgZnJvbSAyRCBzcGFjZSB0byAzRCBzcGFjZS5cclxuICAgICAqIFRoZSBwb2ludCBzaG91bGQgaGF2ZSBpdHMgeCBhbmQgeSBwcm9wZXJ0aWVzIHNldCB0b1xyXG4gICAgICogMkQgc2NyZWVuIHNwYWNlLCBhbmQgdGhlIHogZWl0aGVyIGF0IDAgKG5lYXIgcGxhbmUpXHJcbiAgICAgKiBvciAxIChmYXIgcGxhbmUpLiBUaGUgcHJvdmlkZWQgbWF0cml4IGlzIGFzc3VtZWQgdG8gYWxyZWFkeVxyXG4gICAgICogYmUgY29tYmluZWQsIGkuZS4gcHJvamVjdGlvbiAqIHZpZXcgKiBtb2RlbC5cclxuICAgICAqXHJcbiAgICAgKiBBZnRlciB0aGlzIG9wZXJhdGlvbiwgdGhpcyB2ZWN0b3IncyAoeCwgeSwgeikgY29tcG9uZW50cyB3aWxsXHJcbiAgICAgKiByZXByZXNlbnQgdGhlIHVucHJvamVjdGVkIDNEIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSAge1ZlY3RvcjR9IHZpZXdwb3J0ICAgICAgICAgIHNjcmVlbiB4LCB5LCB3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVsc1xyXG4gICAgICogQHBhcmFtICB7TWF0cml4NH0gaW52UHJvamVjdGlvblZpZXcgY29tYmluZWQgcHJvamVjdGlvbiBhbmQgdmlldyBtYXRyaXhcclxuICAgICAqIEByZXR1cm4ge1ZlY3RvcjN9ICAgICAgICAgICAgICAgICAgIHRoaXMgb2JqZWN0LCBmb3IgY2hhaW5pbmdcclxuICAgICAqL1xyXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbiAodmlld3BvcnQsIGludlByb2plY3Rpb25WaWV3KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB2aWV3WCA9IHZpZXdwb3J0Lng7XHJcbiAgICAgICAgdmFyIHZpZXdZID0gdmlld3BvcnQueTtcclxuICAgICAgICB2YXIgdmlld1dpZHRoID0gdmlld3BvcnQuejtcclxuICAgICAgICB2YXIgdmlld0hlaWdodCA9IHZpZXdwb3J0Lnc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLnggLSB2aWV3WDtcclxuICAgICAgICB2YXIgeSA9ICh2aWV3SGVpZ2h0IC0gdGhpcy55IC0gMSkgLSB2aWV3WTtcclxuICAgICAgICB2YXIgeiA9IHRoaXMuejtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gKDIgKiB4KSAvIHZpZXdXaWR0aCAtIDE7XHJcbiAgICAgICAgdGhpcy55ID0gKDIgKiB5KSAvIHZpZXdIZWlnaHQgLSAxO1xyXG4gICAgICAgIHRoaXMueiA9IDIgKiB6IC0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdChpbnZQcm9qZWN0aW9uVmlldyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICB0aGlzLnogPSAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuVmVjdG9yMy5wcm90b3R5cGUuc3ViID0gVmVjdG9yMy5wcm90b3R5cGUuc3VidHJhY3Q7XHJcblZlY3RvcjMucHJvdG90eXBlLm11bCA9IFZlY3RvcjMucHJvdG90eXBlLm11bHRpcGx5O1xyXG5WZWN0b3IzLnByb3RvdHlwZS5kaXYgPSBWZWN0b3IzLnByb3RvdHlwZS5kaXZpZGU7XHJcblZlY3RvcjMucHJvdG90eXBlLmRpc3QgPSBWZWN0b3IzLnByb3RvdHlwZS5kaXN0YW5jZTtcclxuVmVjdG9yMy5wcm90b3R5cGUuZGlzdFNxID0gVmVjdG9yMy5wcm90b3R5cGUuZGlzdGFuY2VTcTtcclxuVmVjdG9yMy5wcm90b3R5cGUubGVuID0gVmVjdG9yMy5wcm90b3R5cGUubGVuZ3RoO1xyXG5WZWN0b3IzLnByb3RvdHlwZS5sZW5TcSA9IFZlY3RvcjMucHJvdG90eXBlLmxlbmd0aFNxO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3IzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvVmVjdG9yMy5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgREVGQVVMVDogMCxcclxuICAgIExJTkVBUjogMCxcclxuICAgIE5FQVJFU1Q6IDFcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvU2NhbGVNb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBEYXRhQnVmZmVyMTYgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gRGF0YUJ1ZmZlcjE2IChieXRlU2l6ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLndvcmRMZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMud29yZENhcGFjaXR5ID0gYnl0ZVNpemUgLyAyO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTaXplKTtcclxuICAgICAgICB0aGlzLmludFZpZXcgPSBuZXcgSW50MTZBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy51aW50VmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMud29yZExlbmd0aCA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEJ5dGVMZW5ndGg6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud29yZExlbmd0aCAqIDI7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEJ5dGVDYXBhY2l0eTogZnVuY3Rpb24gKCkgXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICB9LFxyXG5cclxuICAgIGFsbG9jYXRlOiBmdW5jdGlvbiAod29yZFNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLndvcmRMZW5ndGg7XHJcbiAgICAgICAgdGhpcy53b3JkTGVuZ3RoICs9IHdvcmRTaXplO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50TGVuZ3RoO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRVc2VkQnVmZmVyQXNTaG9ydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRWaWV3LnN1YmFycmF5KDAsIHRoaXMud29yZExlbmd0aCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVzZWRCdWZmZXJBc1dvcmQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudWludFZpZXcuc3ViYXJyYXkoMCwgdGhpcy53b3JkTGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXRhQnVmZmVyMTY7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvRGF0YUJ1ZmZlcjE2LmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxudmFyIEdldEZhc3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRGYXN0VmFsdWUnKTtcclxuXHJcbi8vICBQaGFzZXIuTG9hZGVyLkZpbGVUeXBlcy5JbWFnZUZpbGVcclxuXHJcbnZhciBJbWFnZUZpbGUgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEZpbGUsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICAvLyB0aGlzLmxvYWQuaW1hZ2UoJ3BpYycsICdhc3NldHMvcGljcy90YWlrb2RydW1tYXN0ZXIuanBnJyk7XHJcbiAgICAvLyB0aGlzLmxvYWQuaW1hZ2UoeyBrZXk6ICdwaWMnLCBmaWxlOiAnYXNzZXRzL3BpY3MvdGFpa29kcnVtbWFzdGVyLmpwZycgfSk7XHJcbiAgICAvLyB0aGlzLmxvYWQuaW1hZ2Uoe1xyXG4gICAgLy8gICAgIGtleTogJ2J1bm55JyxcclxuICAgIC8vICAgICBmaWxlOiAnYXNzZXRzL3Nwcml0ZXMvYnVubnkucG5nJyxcclxuICAgIC8vICAgICB4aHI6IHtcclxuICAgIC8vICAgICAgICAgdXNlcjogJ3Jvb3QnLFxyXG4gICAgLy8gICAgICAgICBwYXNzd29yZDogJ3RoM0cxYnMwbicsXHJcbiAgICAvLyAgICAgICAgIHRpbWVvdXQ6IDMwLFxyXG4gICAgLy8gICAgICAgICBoZWFkZXI6ICdDb250ZW50LVR5cGUnLFxyXG4gICAgLy8gICAgICAgICBoZWFkZXJWYWx1ZTogJ3RleHQveG1sJ1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH0pO1xyXG4gICAgLy8gdGhpcy5sb2FkLmltYWdlKHsga2V5OiAnYnVubnknIH0pO1xyXG4gICAgLy8gdGhpcy5sb2FkLmltYWdlKHsga2V5OiAnYnVubnknLCBleHRlbnNpb246ICdqcGcnIH0pO1xyXG4gICAgZnVuY3Rpb24gSW1hZ2VGaWxlIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MsIGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB2YXIgZmlsZUtleSA9ICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykgPyBrZXkgOiBHZXRGYXN0VmFsdWUoa2V5LCAna2V5JywgJycpO1xyXG5cclxuICAgICAgICB2YXIgZmlsZUNvbmZpZyA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBHZXRGYXN0VmFsdWUoa2V5LCAnZXh0ZW5zaW9uJywgJ3BuZycpLFxyXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdibG9iJyxcclxuICAgICAgICAgICAga2V5OiBmaWxlS2V5LFxyXG4gICAgICAgICAgICB1cmw6IEdldEZhc3RWYWx1ZShrZXksICdmaWxlJywgdXJsKSxcclxuICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgeGhyU2V0dGluZ3M6IEdldEZhc3RWYWx1ZShrZXksICd4aHInLCB4aHJTZXR0aW5ncyksXHJcbiAgICAgICAgICAgIGNvbmZpZzogR2V0RmFzdFZhbHVlKGtleSwgJ2NvbmZpZycsIGNvbmZpZylcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBGaWxlLmNhbGwodGhpcywgZmlsZUNvbmZpZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uUHJvY2VzczogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBJbWFnZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG5cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEub25sb2FkID0gZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoX3RoaXMuZGF0YS5zcmMpO1xyXG5cclxuICAgICAgICAgICAgX3RoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5vbmVycm9yID0gZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoX3RoaXMuZGF0YS5zcmMpO1xyXG5cclxuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0VSUk9SRUQ7XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjayhfdGhpcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy54aHJMb2FkZXIucmVzcG9uc2UpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5JbWFnZUZpbGUuY3JlYXRlID0gZnVuY3Rpb24gKGxvYWRlciwga2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIElmIGl0J3MgYW4gYXJyYXkgaXQgaGFzIHRvIGJlIGFuIGFycmF5IG9mIE9iamVjdHMsIHNvIHdlIGdldCBldmVyeXRoaW5nIG91dCBvZiB0aGUgJ2tleScgb2JqZWN0XHJcbiAgICAgICAgICAgIGxvYWRlci5hZGRGaWxlKG5ldyBJbWFnZUZpbGUoa2V5W2ldLCB1cmwsIGxvYWRlci5wYXRoLCB4aHJTZXR0aW5ncykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBsb2FkZXIuYWRkRmlsZShuZXcgSW1hZ2VGaWxlKGtleSwgdXJsLCBsb2FkZXIucGF0aCwgeGhyU2V0dGluZ3MpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRm9yIG1ldGhvZCBjaGFpbmluZ1xyXG4gICAgcmV0dXJuIGxvYWRlcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29udGFpbnMgPSBmdW5jdGlvbiAoY2lyY2xlLCB4LCB5KVxyXG57XHJcbiAgICAvLyAgQ2hlY2sgaWYgeC95IGFyZSB3aXRoaW4gdGhlIGJvdW5kcyBmaXJzdFxyXG4gICAgaWYgKGNpcmNsZS5yYWRpdXMgPiAwICYmIHggPj0gY2lyY2xlLmxlZnQgJiYgeCA8PSBjaXJjbGUucmlnaHQgJiYgeSA+PSBjaXJjbGUudG9wICYmIHkgPD0gY2lyY2xlLmJvdHRvbSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZHggPSAoY2lyY2xlLnggLSB4KSAqIChjaXJjbGUueCAtIHgpO1xyXG4gICAgICAgIHZhciBkeSA9IChjaXJjbGUueSAtIHkpICogKGNpcmNsZS55IC0geSk7XHJcblxyXG4gICAgICAgIHJldHVybiAoZHggKyBkeSkgPD0gKGNpcmNsZS5yYWRpdXMgKiBjaXJjbGUucmFkaXVzKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL0NvbnRhaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQW5nbGUgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIobGluZS55MiAtIGxpbmUueTEsIGxpbmUueDIgLSBsaW5lLngxKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL0FuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxuLy8gQSB0cmlhbmdsZSBpcyBhIHBsYW5lIGNyZWF0ZWQgYnkgY29ubmVjdGluZyB0aHJlZSBwb2ludHMuXHJcbi8vIFRoZSBmaXJzdCB0d28gYXJndW1lbnRzIHNwZWNpZnkgdGhlIGZpcnN0IHBvaW50LCB0aGUgbWlkZGxlIHR3byBhcmd1bWVudHNcclxuLy8gc3BlY2lmeSB0aGUgc2Vjb25kIHBvaW50LCBhbmQgdGhlIGxhc3QgdHdvIGFyZ3VtZW50cyBzcGVjaWZ5IHRoZSB0aGlyZCBwb2ludC5cclxuXHJcbnZhciBUcmlhbmdsZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBUcmlhbmdsZSAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MylcclxuICAgIHtcclxuICAgICAgICB0aGlzLngxID0gMDtcclxuICAgICAgICB0aGlzLnkxID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy54MiA9IDA7XHJcbiAgICAgICAgdGhpcy55MiA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMueDMgPSAwO1xyXG4gICAgICAgIHRoaXMueTMgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHgxID09PSB1bmRlZmluZWQpIHsgeDEgPSAwOyB9XHJcbiAgICAgICAgaWYgKHkxID09PSB1bmRlZmluZWQpIHsgeTEgPSAwOyB9XHJcbiAgICAgICAgaWYgKHgyID09PSB1bmRlZmluZWQpIHsgeDIgPSAwOyB9XHJcbiAgICAgICAgaWYgKHkyID09PSB1bmRlZmluZWQpIHsgeTIgPSAwOyB9XHJcbiAgICAgICAgaWYgKHgzID09PSB1bmRlZmluZWQpIHsgeDMgPSAwOyB9XHJcbiAgICAgICAgaWYgKHkzID09PSB1bmRlZmluZWQpIHsgeTMgPSAwOyB9XHJcblxyXG4gICAgICAgIHRoaXMueDEgPSB4MTtcclxuICAgICAgICB0aGlzLnkxID0geTE7XHJcblxyXG4gICAgICAgIHRoaXMueDIgPSB4MjtcclxuICAgICAgICB0aGlzLnkyID0geTI7XHJcblxyXG4gICAgICAgIHRoaXMueDMgPSB4MztcclxuICAgICAgICB0aGlzLnkzID0geTM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRMaW5lQTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4geyB4MTogdGhpcy54MSwgeTE6IHRoaXMueTEsIHgyOiB0aGlzLngyLCB5MjogdGhpcy55MiB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRMaW5lQjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4geyB4MTogdGhpcy54MiwgeTE6IHRoaXMueTIsIHgyOiB0aGlzLngzLCB5MjogdGhpcy55MyB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRMaW5lQzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4geyB4MTogdGhpcy54MywgeTE6IHRoaXMueTMsIHgyOiB0aGlzLngxLCB5MjogdGhpcy55MSB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBsZWZ0OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLngxLCB0aGlzLngyLCB0aGlzLngzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkaWZmID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLngxIDw9IHRoaXMueDIgJiYgdGhpcy54MSA8PSB0aGlzLngzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MSAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueDIgPD0gdGhpcy54MSAmJiB0aGlzLngyIDw9IHRoaXMueDMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLngyIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MyAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLngxIC09IGRpZmY7XHJcbiAgICAgICAgICAgIHRoaXMueDIgLT0gZGlmZjtcclxuICAgICAgICAgICAgdGhpcy54MyAtPSBkaWZmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLngxLCB0aGlzLngyLCB0aGlzLngzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkaWZmID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLngxID49IHRoaXMueDIgJiYgdGhpcy54MSA+PSB0aGlzLngzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MSAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueDIgPj0gdGhpcy54MSAmJiB0aGlzLngyID49IHRoaXMueDMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLngyIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MyAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLngxIC09IGRpZmY7XHJcbiAgICAgICAgICAgIHRoaXMueDIgLT0gZGlmZjtcclxuICAgICAgICAgICAgdGhpcy54MyAtPSBkaWZmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy55MSwgdGhpcy55MiwgdGhpcy55Myk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGlmZiA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy55MSA8PSB0aGlzLnkyICYmIHRoaXMueTEgPD0gdGhpcy55MylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMueTEgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnkyIDw9IHRoaXMueTEgJiYgdGhpcy55MiA8PSB0aGlzLnkzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy55MiAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMueTMgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy55MSAtPSBkaWZmO1xyXG4gICAgICAgICAgICB0aGlzLnkyIC09IGRpZmY7XHJcbiAgICAgICAgICAgIHRoaXMueTMgLT0gZGlmZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b206IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMueTEsIHRoaXMueTIsIHRoaXMueTMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRpZmYgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMueTEgPj0gdGhpcy55MiAmJiB0aGlzLnkxID49IHRoaXMueTMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLnkxIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy55MiA+PSB0aGlzLnkxICYmIHRoaXMueTIgPj0gdGhpcy55MylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMueTIgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLnkzIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMueTEgLT0gZGlmZjtcclxuICAgICAgICAgICAgdGhpcy55MiAtPSBkaWZmO1xyXG4gICAgICAgICAgICB0aGlzLnkzIC09IGRpZmY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmlhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL1RyaWFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLklucHV0LkV2ZW50c1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgRFJBRzogcmVxdWlyZSgnLi9EcmFnRXZlbnQnKSxcclxuICAgIERSQUdfRU5EOiByZXF1aXJlKCcuL0RyYWdFbmRFdmVudCcpLFxyXG4gICAgRFJBR19FTlRFUjogcmVxdWlyZSgnLi9EcmFnRW50ZXJFdmVudCcpLFxyXG4gICAgRFJBR19MRUFWRTogcmVxdWlyZSgnLi9EcmFnTGVhdmVFdmVudCcpLFxyXG4gICAgRFJBR19PVkVSOiByZXF1aXJlKCcuL0RyYWdPdmVyRXZlbnQnKSxcclxuICAgIERSQUdfU1RBUlQ6IHJlcXVpcmUoJy4vRHJhZ1N0YXJ0RXZlbnQnKSxcclxuICAgIERST1A6IHJlcXVpcmUoJy4vRHJvcEV2ZW50JyksXHJcblxyXG4gICAgR0FNRV9PQkpFQ1RfRE9XTjogcmVxdWlyZSgnLi9HYW1lT2JqZWN0RG93bkV2ZW50JyksXHJcbiAgICBHQU1FX09CSkVDVF9NT1ZFOiByZXF1aXJlKCcuL0dhbWVPYmplY3RNb3ZlRXZlbnQnKSxcclxuICAgIEdBTUVfT0JKRUNUX09VVDogcmVxdWlyZSgnLi9HYW1lT2JqZWN0T3V0RXZlbnQnKSxcclxuICAgIEdBTUVfT0JKRUNUX09WRVI6IHJlcXVpcmUoJy4vR2FtZU9iamVjdE92ZXJFdmVudCcpLFxyXG4gICAgR0FNRV9PQkpFQ1RfVVA6IHJlcXVpcmUoJy4vR2FtZU9iamVjdFVwRXZlbnQnKSxcclxuXHJcbiAgICBQT0lOVEVSX0RPV046IHJlcXVpcmUoJy4vUG9pbnRlckRvd25FdmVudCcpLFxyXG4gICAgUE9JTlRFUl9NT1ZFOiByZXF1aXJlKCcuL1BvaW50ZXJNb3ZlRXZlbnQnKSxcclxuICAgIFBPSU5URVJfT1VUOiByZXF1aXJlKCcuL1BvaW50ZXJPdXRFdmVudCcpLFxyXG4gICAgUE9JTlRFUl9PVkVSOiByZXF1aXJlKCcuL1BvaW50ZXJPdmVyRXZlbnQnKSxcclxuICAgIFBPSU5URVJfVVA6IHJlcXVpcmUoJy4vUG9pbnRlclVwRXZlbnQnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9ldmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuQmxlbmRNb2Rlc1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgTk9STUFMOiAwLFxyXG4gICAgQUREOiAxLFxyXG4gICAgTVVMVElQTFk6IDIsXHJcbiAgICBTQ1JFRU46IDMsXHJcbiAgICBPVkVSTEFZOiA0LFxyXG4gICAgREFSS0VOOiA1LFxyXG4gICAgTElHSFRFTjogNixcclxuICAgIENPTE9SX0RPREdFOiA3LFxyXG4gICAgQ09MT1JfQlVSTjogOCxcclxuICAgIEhBUkRfTElHSFQ6IDksXHJcbiAgICBTT0ZUX0xJR0hUOiAxMCxcclxuICAgIERJRkZFUkVOQ0U6IDExLFxyXG4gICAgRVhDTFVTSU9OOiAxMixcclxuICAgIEhVRTogMTMsXHJcbiAgICBTQVRVUkFUSU9OOiAxNCxcclxuICAgIENPTE9SOiAxNSxcclxuICAgIExVTUlOT1NJVFk6IDE2XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL0JsZW5kTW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgdmVydDogW1xyXG4gICAgICAgICd1bmlmb3JtIG1hdDQgdV92aWV3X21hdHJpeDsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMzIGFfY29sb3I7JyxcclxuICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfYWxwaGE7JyxcclxuICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMyB2X2NvbG9yOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdl9hbHBoYTsnLFxyXG4gICAgICAgICd2b2lkIG1haW4gKCkgeycsXHJcbiAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdV92aWV3X21hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wLCAxLjApOycsXHJcbiAgICAgICAgJyAgIHZfdGV4X2Nvb3JkID0gYV90ZXhfY29vcmQ7JyxcclxuICAgICAgICAnICAgdl9jb2xvciA9IGFfY29sb3I7JyxcclxuICAgICAgICAnICAgdl9hbHBoYSA9IGFfYWxwaGE7JyxcclxuICAgICAgICAnfSdcclxuICAgIF0uam9pbignXFxuJyksXHJcbiAgICBmcmFnOiBbXHJcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXHJcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVfc2FtcGxlcjJEOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleF9jb29yZDsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzMgdl9jb2xvcjsnLFxyXG4gICAgICAgICd2YXJ5aW5nIGZsb2F0IHZfYWxwaGE7JyxcclxuICAgICAgICAndm9pZCBtYWluKCkgeycsXHJcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3NhbXBsZXIyRCwgdl90ZXhfY29vcmQpICogdmVjNCh2X2NvbG9yLCB2X2FscGhhKTsnLFxyXG4gICAgICAgICd9J1xyXG4gICAgXS5qb2luKCdcXG4nKVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgY2VudGVyIHggY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgKHggLSBvZmZzZXRYKSArICh3aWR0aCAvIDIpYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBjZW50ZXJYXHJcbiovXHJcblxyXG52YXIgR2V0Q2VudGVyWCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdC54IC0gKGdhbWVPYmplY3Qud2lkdGggKiBnYW1lT2JqZWN0Lm9yaWdpblgpICsgKGdhbWVPYmplY3Qud2lkdGggKiAwLjUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRDZW50ZXJYO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9HZXRDZW50ZXJYLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgY2VudGVyIHggY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgKHggLSBvZmZzZXRYKSArICh3aWR0aCAvIDIpYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBjZW50ZXJYXHJcbiovXHJcblxyXG52YXIgR2V0Q2VudGVyWSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdC55IC0gKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5vcmlnaW5ZKSArIChnYW1lT2JqZWN0LmhlaWdodCAqIDAuNSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldENlbnRlclk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL0dldENlbnRlclkuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBjZW50ZXIgeCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGAoeCAtIG9mZnNldFgpICsgKHdpZHRoIC8gMilgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGNlbnRlclhcclxuKi9cclxuXHJcbi8vICBQaGFzZXIuVXRpbHMuQm91bmRzLkdldENlbnRlclgoYm9iKVxyXG4vLyAgUGhhc2VyLlV0aWxzLkJvdW5kcy5DZW50ZXJPbihib2IsIHgsIHkpXHJcbi8vICBQaGFzZXIuVXRpbHMuQm91bmRzLkNlbnRlclgoYm9iLCB4KVxyXG4vLyAgUGhhc2VyLlV0aWxzLkJvdW5kcy5DZW50ZXJZKGJvYiwgeClcclxuXHJcbnZhciBTZXRDZW50ZXJYID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHgpXHJcbntcclxuICAgIHZhciBvZmZzZXRYID0gZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Qub3JpZ2luWDtcclxuXHJcbiAgICBnYW1lT2JqZWN0LnggPSAoeCArIG9mZnNldFgpIC0gKGdhbWVPYmplY3Qud2lkdGggKiAwLjUpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRDZW50ZXJYO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9TZXRDZW50ZXJYLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgY2VudGVyIHggY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgKHggLSBvZmZzZXRYKSArICh3aWR0aCAvIDIpYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBjZW50ZXJYXHJcbiovXHJcblxyXG4vLyAgUGhhc2VyLlV0aWxzLkJvdW5kcy5HZXRDZW50ZXJYKGJvYilcclxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuQ2VudGVyT24oYm9iLCB4LCB5KVxyXG4vLyAgUGhhc2VyLlV0aWxzLkJvdW5kcy5DZW50ZXJYKGJvYiwgeClcclxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuQ2VudGVyWShib2IsIHgpXHJcblxyXG52YXIgU2V0Q2VudGVyWSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB5KVxyXG57XHJcbiAgICB2YXIgb2Zmc2V0WSA9IGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5vcmlnaW5ZO1xyXG5cclxuICAgIGdhbWVPYmplY3QueSA9ICh5ICsgb2Zmc2V0WSkgLSAoZ2FtZU9iamVjdC5oZWlnaHQgKiAwLjUpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRDZW50ZXJZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9TZXRDZW50ZXJZLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIFN5c3RlbXMgPSByZXF1aXJlKCcuL1N5c3RlbXMnKTtcclxuXHJcbnZhciBTY2VuZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBTY2VuZSAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUaGUgU2NlbmUgU3lzdGVtcy4gWW91IG11c3QgbmV2ZXIgb3ZlcndyaXRlIHRoaXMgcHJvcGVydHksIG9yIGFsbCBoZWxsIHdpbGwgYnJlYWsgbG9zZS5cclxuICAgICAgICB0aGlzLnN5cyA9IG5ldyBTeXN0ZW1zKHRoaXMsIGNvbmZpZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBTaG91bGQgYmUgb3ZlcnJpZGRlbiBieSB5b3VyIG93biBTY2VuZXNcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHlvdXIgb3duIFNjZW5lc1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2xvY2FsL1NjZW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEFERF9BTklNQVRJT05fRVZFTlQ6IHJlcXVpcmUoJy4vQWRkQW5pbWF0aW9uRXZlbnQnKSxcclxuICAgIFBBVVNFX0FMTF9BTklNQVRJT05fRVZFTlQ6IHJlcXVpcmUoJy4vUGF1c2VBbGxBbmltYXRpb25FdmVudCcpLFxyXG4gICAgUkVNT1ZFX0FOSU1BVElPTl9FVkVOVDogcmVxdWlyZSgnLi9SZW1vdmVBbmltYXRpb25FdmVudCcpLFxyXG4gICAgUkVTVU1FX0FMTF9BTklNQVRJT05fRVZFTlQ6IHJlcXVpcmUoJy4vUmVzdW1lQWxsQW5pbWF0aW9uRXZlbnQnKVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2V2ZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9TID0ge1xyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IGRlc2t0b3AgLSBJcyBydW5uaW5nIG9uIGEgZGVza3RvcD9cclxuICAgIGRlc2t0b3A6IGZhbHNlLFxyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IHdlYkFwcCAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgYXMgYSBXZWJBcHAsIGkuZS4gd2l0aGluIGEgV2ViVmlld1xyXG4gICAgd2ViQXBwOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBpT1MgLSBJcyBydW5uaW5nIG9uIGlPUz9cclxuICAgIGlPUzogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7bnVtYmVyfSBpT1NWZXJzaW9uIC0gSWYgcnVubmluZyBpbiBpT1MgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxyXG4gICAgaU9TVmVyc2lvbjogMCxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBpUGhvbmUgLSBJcyBydW5uaW5nIG9uIGlQaG9uZT9cclxuICAgIGlQaG9uZTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaVBhZCAtIElzIHJ1bm5pbmcgb24gaVBhZD9cclxuICAgIGlQYWQ6IGZhbHNlLFxyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IGNvY29vbkpTIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBDb2Nvb25KUz9cclxuICAgIGNvY29vbkpTOiBmYWxzZSxcclxuICAgIFxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29jb29uSlNBcHAgLSBJcyB0aGlzIGdhbWUgcnVubmluZyB3aXRoIENvY29vbkpTLkFwcD9cclxuICAgIGNvY29vbkpTQXBwOiBmYWxzZSxcclxuICAgIFxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29yZG92YSAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgQXBhY2hlIENvcmRvdmE/XHJcbiAgICBjb3Jkb3ZhOiBmYWxzZSxcclxuICAgIFxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbm9kZSAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgTm9kZS5qcz9cclxuICAgIG5vZGU6IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBub2RlV2Via2l0IC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBOb2RlLVdlYmtpdD9cclxuICAgIG5vZGVXZWJraXQ6IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBlbGVjdHJvbiAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgR2l0SHViIEVsZWN0cm9uP1xyXG4gICAgZWxlY3Ryb246IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBlamVjdGEgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIEVqZWN0YT9cclxuICAgIGVqZWN0YTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY3Jvc3N3YWxrIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciB0aGUgSW50ZWwgQ3Jvc3N3YWxrIFhESz9cclxuICAgIGNyb3Nzd2FsazogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5kcm9pZCAtIElzIHJ1bm5pbmcgb24gYW5kcm9pZD9cclxuICAgIGFuZHJvaWQ6IGZhbHNlLFxyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IGNocm9tZU9TIC0gSXMgcnVubmluZyBvbiBjaHJvbWVPUz9cclxuICAgIGNocm9tZU9TOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBsaW51eCAtIElzIHJ1bm5pbmcgb24gbGludXg/XHJcbiAgICBsaW51eDogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFjT1MgLSBJcyBydW5uaW5nIG9uIG1hY09TP1xyXG4gICAgbWFjT1M6IGZhbHNlLFxyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IHdpbmRvd3MgLSBJcyBydW5uaW5nIG9uIHdpbmRvd3M/XHJcbiAgICB3aW5kb3dzOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSB3aW5kb3dzUGhvbmUgLSBJcyBydW5uaW5nIG9uIGEgV2luZG93cyBQaG9uZT9cclxuICAgIHdpbmRvd3NQaG9uZTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdml0YSAtIElzIHJ1bm5pbmcgb24gYSBQbGF5U3RhdGlvbiBWaXRhP1xyXG4gICAgdml0YTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0ga2luZGxlIC0gSXMgcnVubmluZyBvbiBhbiBBbWF6b24gS2luZGxlP1xyXG4gICAga2luZGxlOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtudW1iZXJ9IHBpeGVsUmF0aW8gLSBQaXhlbFJhdGlvIG9mIHRoZSBob3N0IGRldmljZT9cclxuICAgIHBpeGVsUmF0aW86IDFcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XHJcblxyXG4gICAgaWYgKC9XaW5kb3dzLy50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy53aW5kb3dzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9NYWMgT1MvLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLm1hY09TID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9MaW51eC8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MubGludXggPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL0FuZHJvaWQvLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmFuZHJvaWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL2lQW2FvXWR8aVBob25lL2kudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuaU9TID0gdHJ1ZTtcclxuICAgICAgICAobmF2aWdhdG9yLmFwcFZlcnNpb24pLm1hdGNoKC9PUyAoXFxkKykvKTtcclxuICAgICAgICBPUy5pT1NWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvS2luZGxlLy50ZXN0KHVhKSB8fCAoL1xcYktGW0EtWl1bQS1aXSsvKS50ZXN0KHVhKSB8fCAoL1NpbGsuKk1vYmlsZSBTYWZhcmkvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5raW5kbGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBUaGlzIHdpbGwgTk9UIGRldGVjdCBlYXJseSBnZW5lcmF0aW9ucyBvZiBLaW5kbGUgRmlyZSwgSSB0aGluayB0aGVyZSBpcyBubyByZWxpYWJsZSB3YXkuLi5cclxuICAgICAgICAvLyBFLmcuIFwiTW96aWxsYS81LjAgKE1hY2ludG9zaDsgVTsgSW50ZWwgTWFjIE9TIFggMTBfNl8zOyBlbi11czsgU2lsay8xLjEuMC04MCkgQXBwbGVXZWJLaXQvNTMzLjE2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi81LjAgU2FmYXJpLzUzMy4xNiBTaWxrLUFjY2VsZXJhdGVkPXRydWVcIlxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL0NyT1MvLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmNocm9tZU9TID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvUGxheXN0YXRpb24gVml0YS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLnZpdGEgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgvV2luZG93cyBQaG9uZS9pLnRlc3QodWEpIHx8ICgvSUVNb2JpbGUvaSkudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuYW5kcm9pZCA9IGZhbHNlO1xyXG4gICAgICAgIE9TLmlPUyA9IGZhbHNlO1xyXG4gICAgICAgIE9TLm1hY09TID0gZmFsc2U7XHJcbiAgICAgICAgT1Mud2luZG93cyA9IHRydWU7XHJcbiAgICAgICAgT1Mud2luZG93c1Bob25lID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2lsayA9ICgvU2lsay8pLnRlc3QodWEpO1xyXG5cclxuICAgIGlmIChPUy53aW5kb3dzIHx8IE9TLm1hY09TIHx8IChPUy5saW51eCAmJiAhc2lsaykgfHwgT1MuY2hyb21lT1MpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuZGVza3RvcCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFdpbmRvd3MgUGhvbmUgLyBUYWJsZSByZXNldFxyXG4gICAgaWYgKE9TLndpbmRvd3NQaG9uZSB8fCAoKC9XaW5kb3dzIE5UL2kudGVzdCh1YSkpICYmICgvVG91Y2gvaS50ZXN0KHVhKSkpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmRlc2t0b3AgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgV2ViQXBwIG1vZGUgaW4gaU9TXHJcbiAgICBpZiAobmF2aWdhdG9yLnN0YW5kYWxvbmUpXHJcbiAgICB7XHJcbiAgICAgICAgT1Mud2ViQXBwID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICE9PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuY29yZG92YSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICgodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCcpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLm5vZGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoT1Mubm9kZSAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PT0gJ29iamVjdCcpXHJcbiAgICB7XHJcbiAgICAgICAgT1Mubm9kZVdlYmtpdCA9ICEhcHJvY2Vzcy52ZXJzaW9uc1snbm9kZS13ZWJraXQnXTtcclxuICAgICAgICBcclxuICAgICAgICBPUy5lbGVjdHJvbiA9ICEhcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKG5hdmlnYXRvci5pc0NvY29vbkpTKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmNvY29vbkpTID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdHJ5XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBPUy5jb2Nvb25KU0FwcCA9ICh0eXBlb2YgQ29jb29uSlMgIT09ICd1bmRlZmluZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgT1MuY29jb29uSlNBcHAgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdpbmRvdy5lamVjdGEgIT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICBPUy5lamVjdGEgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgoL0Nyb3Nzd2Fsay8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmNyb3Nzd2FsayA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgT1MuaVBob25lID0gdWEudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdpcGhvbmUnKSAhPT0gLTE7XHJcbiAgICBPUy5pUGFkID0gdWEudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdpcGFkJykgIT09IC0xO1xyXG5cclxuICAgIE9TLnBpeGVsUmF0aW8gPSB3aW5kb3dbJ2RldmljZVBpeGVsUmF0aW8nXSB8fCAxO1xyXG5cclxuICAgIHJldHVybiBPUztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGV2aWNlL09TLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L1xyXG5cclxudmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCB4LCB5KVxyXG57XHJcbiAgICB2YXIgdjB4ID0gdHJpYW5nbGUueDMgLSB0cmlhbmdsZS54MTtcclxuICAgIHZhciB2MHkgPSB0cmlhbmdsZS55MyAtIHRyaWFuZ2xlLnkxO1xyXG5cclxuICAgIHZhciB2MXggPSB0cmlhbmdsZS54MiAtIHRyaWFuZ2xlLngxO1xyXG4gICAgdmFyIHYxeSA9IHRyaWFuZ2xlLnkyIC0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgdmFyIHYyeCA9IHggLSB0cmlhbmdsZS54MTtcclxuICAgIHZhciB2MnkgPSB5IC0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgdmFyIGRvdDAwID0gKHYweCAqIHYweCkgKyAodjB5ICogdjB5KTtcclxuICAgIHZhciBkb3QwMSA9ICh2MHggKiB2MXgpICsgKHYweSAqIHYxeSk7XHJcbiAgICB2YXIgZG90MDIgPSAodjB4ICogdjJ4KSArICh2MHkgKiB2MnkpO1xyXG4gICAgdmFyIGRvdDExID0gKHYxeCAqIHYxeCkgKyAodjF5ICogdjF5KTtcclxuICAgIHZhciBkb3QxMiA9ICh2MXggKiB2MngpICsgKHYxeSAqIHYyeSk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xyXG4gICAgdmFyIGIgPSAoKGRvdDAwICogZG90MTEpIC0gKGRvdDAxICogZG90MDEpKTtcclxuICAgIHZhciBpbnYgPSAoYiA9PT0gMCkgPyAwIDogKDEgLyBiKTtcclxuICAgIHZhciB1ID0gKChkb3QxMSAqIGRvdDAyKSAtIChkb3QwMSAqIGRvdDEyKSkgKiBpbnY7XHJcbiAgICB2YXIgdiA9ICgoZG90MDAgKiBkb3QxMikgLSAoZG90MDEgKiBkb3QwMikpICogaW52O1xyXG5cclxuICAgIHJldHVybiAodSA+PSAwICYmIHYgPj0gMCAmJiAodSArIHYgPCAxKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEZvcmNlIGEgdmFsdWUgd2l0aGluIHRoZSBib3VuZGFyaWVzIGJ5IGNsYW1waW5nIGl0IHRvIHRoZSByYW5nZSBgbWluYCwgYG1heGAuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI2NsYW1wXHJcbiogQHBhcmFtIHtmbG9hdH0gdiAtIFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkLlxyXG4qIEBwYXJhbSB7ZmxvYXR9IG1pbiAtIFRoZSBtaW5pbXVtIGJvdW5kcy5cclxuKiBAcGFyYW0ge2Zsb2F0fSBtYXggLSBUaGUgbWF4aW11bSBib3VuZHMuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgY2xhbXBlZCB2YWx1ZS5cclxuKi9cclxudmFyIENsYW1wID0gZnVuY3Rpb24gKHZhbHVlLCBtaW4sIG1heClcclxue1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbGFtcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL0NsYW1wLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQWRhcHRlZCBmcm9tIFtnbC1tYXRyaXhdKGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeCkgYnkgdG9qaSBcclxuLy8gIGFuZCBbdmVjbWF0aF0oaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL3ZlY21hdGgpIGJ5IG1hdHRkZXNsXHJcblxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcclxuXHJcbnZhciBNYXRyaXg0ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIE1hdHJpeDQgKG0pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy52YWwgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuXHJcbiAgICAgICAgaWYgKG0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQXNzdW1lIE1hdHJpeDQgd2l0aCB2YWw6XHJcbiAgICAgICAgICAgIHRoaXMuY29weShtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIERlZmF1bHQgdG8gaWRlbnRpdHlcclxuICAgICAgICAgICAgdGhpcy5pZGVudGl0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXg0KHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChzcmMpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weShzcmMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoc3JjKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXQgPSB0aGlzLnZhbDtcclxuICAgICAgICB2YXIgYSA9IHNyYy52YWw7XHJcblxyXG4gICAgICAgIG91dFswXSA9IGFbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXTtcclxuICAgICAgICBvdXRbMl0gPSBhWzJdO1xyXG4gICAgICAgIG91dFszXSA9IGFbM107XHJcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcclxuICAgICAgICBvdXRbNV0gPSBhWzVdO1xyXG4gICAgICAgIG91dFs2XSA9IGFbNl07XHJcbiAgICAgICAgb3V0WzddID0gYVs3XTtcclxuICAgICAgICBvdXRbOF0gPSBhWzhdO1xyXG4gICAgICAgIG91dFs5XSA9IGFbOV07XHJcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xyXG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcclxuICAgICAgICBvdXRbMTJdID0gYVsxMl07XHJcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xyXG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcclxuICAgICAgICBvdXRbMTVdID0gYVsxNV07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBmcm9tQXJyYXk6IGZ1bmN0aW9uIChhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXQgPSB0aGlzLnZhbDtcclxuXHJcbiAgICAgICAgb3V0WzBdID0gYVswXTtcclxuICAgICAgICBvdXRbMV0gPSBhWzFdO1xyXG4gICAgICAgIG91dFsyXSA9IGFbMl07XHJcbiAgICAgICAgb3V0WzNdID0gYVszXTtcclxuICAgICAgICBvdXRbNF0gPSBhWzRdO1xyXG4gICAgICAgIG91dFs1XSA9IGFbNV07XHJcbiAgICAgICAgb3V0WzZdID0gYVs2XTtcclxuICAgICAgICBvdXRbN10gPSBhWzddO1xyXG4gICAgICAgIG91dFs4XSA9IGFbOF07XHJcbiAgICAgICAgb3V0WzldID0gYVs5XTtcclxuICAgICAgICBvdXRbMTBdID0gYVsxMF07XHJcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xyXG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcclxuICAgICAgICBvdXRbMTNdID0gYVsxM107XHJcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xyXG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGlkZW50aXR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXQgPSB0aGlzLnZhbDtcclxuXHJcbiAgICAgICAgb3V0WzBdID0gMTtcclxuICAgICAgICBvdXRbMV0gPSAwO1xyXG4gICAgICAgIG91dFsyXSA9IDA7XHJcbiAgICAgICAgb3V0WzNdID0gMDtcclxuICAgICAgICBvdXRbNF0gPSAwO1xyXG4gICAgICAgIG91dFs1XSA9IDE7XHJcbiAgICAgICAgb3V0WzZdID0gMDtcclxuICAgICAgICBvdXRbN10gPSAwO1xyXG4gICAgICAgIG91dFs4XSA9IDA7XHJcbiAgICAgICAgb3V0WzldID0gMDtcclxuICAgICAgICBvdXRbMTBdID0gMTtcclxuICAgICAgICBvdXRbMTFdID0gMDtcclxuICAgICAgICBvdXRbMTJdID0gMDtcclxuICAgICAgICBvdXRbMTNdID0gMDtcclxuICAgICAgICBvdXRbMTRdID0gMDtcclxuICAgICAgICBvdXRbMTVdID0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zcG9zZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsO1xyXG5cclxuICAgICAgICB2YXIgYTAxID0gYVsxXTtcclxuICAgICAgICB2YXIgYTAyID0gYVsyXTtcclxuICAgICAgICB2YXIgYTAzID0gYVszXTtcclxuICAgICAgICB2YXIgYTEyID0gYVs2XTtcclxuICAgICAgICB2YXIgYTEzID0gYVs3XTtcclxuICAgICAgICB2YXIgYTIzID0gYVsxMV07XHJcblxyXG4gICAgICAgIGFbMV0gPSBhWzRdO1xyXG4gICAgICAgIGFbMl0gPSBhWzhdO1xyXG4gICAgICAgIGFbM10gPSBhWzEyXTtcclxuICAgICAgICBhWzRdID0gYTAxO1xyXG4gICAgICAgIGFbNl0gPSBhWzldO1xyXG4gICAgICAgIGFbN10gPSBhWzEzXTtcclxuICAgICAgICBhWzhdID0gYTAyO1xyXG4gICAgICAgIGFbOV0gPSBhMTI7XHJcbiAgICAgICAgYVsxMV0gPSBhWzE0XTtcclxuICAgICAgICBhWzEyXSA9IGEwMztcclxuICAgICAgICBhWzEzXSA9IGExMztcclxuICAgICAgICBhWzE0XSA9IGEyMztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGludmVydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsO1xyXG5cclxuICAgICAgICB2YXIgYTAwID0gYVswXTtcclxuICAgICAgICB2YXIgYTAxID0gYVsxXTtcclxuICAgICAgICB2YXIgYTAyID0gYVsyXTtcclxuICAgICAgICB2YXIgYTAzID0gYVszXTtcclxuXHJcbiAgICAgICAgdmFyIGExMCA9IGFbNF07XHJcbiAgICAgICAgdmFyIGExMSA9IGFbNV07XHJcbiAgICAgICAgdmFyIGExMiA9IGFbNl07XHJcbiAgICAgICAgdmFyIGExMyA9IGFbN107XHJcblxyXG4gICAgICAgIHZhciBhMjAgPSBhWzhdO1xyXG4gICAgICAgIHZhciBhMjEgPSBhWzldO1xyXG4gICAgICAgIHZhciBhMjIgPSBhWzEwXTtcclxuICAgICAgICB2YXIgYTIzID0gYVsxMV07XHJcblxyXG4gICAgICAgIHZhciBhMzAgPSBhWzEyXTtcclxuICAgICAgICB2YXIgYTMxID0gYVsxM107XHJcbiAgICAgICAgdmFyIGEzMiA9IGFbMTRdO1xyXG4gICAgICAgIHZhciBhMzMgPSBhWzE1XTtcclxuXHJcbiAgICAgICAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcclxuICAgICAgICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xyXG4gICAgICAgIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XHJcbiAgICAgICAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcclxuXHJcbiAgICAgICAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcclxuICAgICAgICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xyXG4gICAgICAgIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XHJcbiAgICAgICAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcclxuXHJcbiAgICAgICAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcclxuICAgICAgICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xyXG4gICAgICAgIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XHJcbiAgICAgICAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcclxuXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcclxuICAgICAgICB2YXIgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xyXG5cclxuICAgICAgICBpZiAoIWRldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGV0ID0gMSAvIGRldDtcclxuXHJcbiAgICAgICAgYVswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xyXG4gICAgICAgIGFbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcclxuICAgICAgICBhWzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XHJcbiAgICAgICAgYVszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xyXG4gICAgICAgIGFbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcclxuICAgICAgICBhWzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XHJcbiAgICAgICAgYVs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xyXG4gICAgICAgIGFbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcclxuICAgICAgICBhWzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XHJcbiAgICAgICAgYVs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xyXG4gICAgICAgIGFbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XHJcbiAgICAgICAgYVsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcclxuICAgICAgICBhWzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xyXG4gICAgICAgIGFbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XHJcbiAgICAgICAgYVsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcclxuICAgICAgICBhWzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgYWRqb2ludDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsO1xyXG5cclxuICAgICAgICB2YXIgYTAwID0gYVswXTtcclxuICAgICAgICB2YXIgYTAxID0gYVsxXTtcclxuICAgICAgICB2YXIgYTAyID0gYVsyXTtcclxuICAgICAgICB2YXIgYTAzID0gYVszXTtcclxuXHJcbiAgICAgICAgdmFyIGExMCA9IGFbNF07XHJcbiAgICAgICAgdmFyIGExMSA9IGFbNV07XHJcbiAgICAgICAgdmFyIGExMiA9IGFbNl07XHJcbiAgICAgICAgdmFyIGExMyA9IGFbN107XHJcblxyXG4gICAgICAgIHZhciBhMjAgPSBhWzhdO1xyXG4gICAgICAgIHZhciBhMjEgPSBhWzldO1xyXG4gICAgICAgIHZhciBhMjIgPSBhWzEwXTtcclxuICAgICAgICB2YXIgYTIzID0gYVsxMV07XHJcblxyXG4gICAgICAgIHZhciBhMzAgPSBhWzEyXTtcclxuICAgICAgICB2YXIgYTMxID0gYVsxM107XHJcbiAgICAgICAgdmFyIGEzMiA9IGFbMTRdO1xyXG4gICAgICAgIHZhciBhMzMgPSBhWzE1XTtcclxuXHJcbiAgICAgICAgYVswXSA9IChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xyXG4gICAgICAgIGFbMV0gPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XHJcbiAgICAgICAgYVsyXSA9IChhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xyXG4gICAgICAgIGFbM10gPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XHJcbiAgICAgICAgYVs0XSA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcclxuICAgICAgICBhWzVdID0gKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XHJcbiAgICAgICAgYVs2XSA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcclxuICAgICAgICBhWzddID0gKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XHJcbiAgICAgICAgYVs4XSA9IChhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkpO1xyXG4gICAgICAgIGFbOV0gPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XHJcbiAgICAgICAgYVsxMF0gPSAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcclxuICAgICAgICBhWzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcclxuICAgICAgICBhWzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcclxuICAgICAgICBhWzEzXSA9IChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xyXG4gICAgICAgIGFbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xyXG4gICAgICAgIGFbMTVdID0gKGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXRlcm1pbmFudDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsO1xyXG5cclxuICAgICAgICB2YXIgYTAwID0gYVswXTtcclxuICAgICAgICB2YXIgYTAxID0gYVsxXTtcclxuICAgICAgICB2YXIgYTAyID0gYVsyXTtcclxuICAgICAgICB2YXIgYTAzID0gYVszXTtcclxuXHJcbiAgICAgICAgdmFyIGExMCA9IGFbNF07XHJcbiAgICAgICAgdmFyIGExMSA9IGFbNV07XHJcbiAgICAgICAgdmFyIGExMiA9IGFbNl07XHJcbiAgICAgICAgdmFyIGExMyA9IGFbN107XHJcblxyXG4gICAgICAgIHZhciBhMjAgPSBhWzhdO1xyXG4gICAgICAgIHZhciBhMjEgPSBhWzldO1xyXG4gICAgICAgIHZhciBhMjIgPSBhWzEwXTtcclxuICAgICAgICB2YXIgYTIzID0gYVsxMV07XHJcblxyXG4gICAgICAgIHZhciBhMzAgPSBhWzEyXTtcclxuICAgICAgICB2YXIgYTMxID0gYVsxM107XHJcbiAgICAgICAgdmFyIGEzMiA9IGFbMTRdO1xyXG4gICAgICAgIHZhciBhMzMgPSBhWzE1XTtcclxuXHJcbiAgICAgICAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcclxuICAgICAgICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xyXG4gICAgICAgIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XHJcbiAgICAgICAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcclxuICAgICAgICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xyXG4gICAgICAgIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XHJcbiAgICAgICAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcclxuICAgICAgICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xyXG4gICAgICAgIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XHJcbiAgICAgICAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcclxuICAgICAgICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xyXG4gICAgICAgIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcclxuICAgICAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKHNyYylcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsO1xyXG5cclxuICAgICAgICB2YXIgYTAwID0gYVswXTtcclxuICAgICAgICB2YXIgYTAxID0gYVsxXTtcclxuICAgICAgICB2YXIgYTAyID0gYVsyXTtcclxuICAgICAgICB2YXIgYTAzID0gYVszXTtcclxuXHJcbiAgICAgICAgdmFyIGExMCA9IGFbNF07XHJcbiAgICAgICAgdmFyIGExMSA9IGFbNV07XHJcbiAgICAgICAgdmFyIGExMiA9IGFbNl07XHJcbiAgICAgICAgdmFyIGExMyA9IGFbN107XHJcblxyXG4gICAgICAgIHZhciBhMjAgPSBhWzhdO1xyXG4gICAgICAgIHZhciBhMjEgPSBhWzldO1xyXG4gICAgICAgIHZhciBhMjIgPSBhWzEwXTtcclxuICAgICAgICB2YXIgYTIzID0gYVsxMV07XHJcblxyXG4gICAgICAgIHZhciBhMzAgPSBhWzEyXTtcclxuICAgICAgICB2YXIgYTMxID0gYVsxM107XHJcbiAgICAgICAgdmFyIGEzMiA9IGFbMTRdO1xyXG4gICAgICAgIHZhciBhMzMgPSBhWzE1XTtcclxuXHJcbiAgICAgICAgdmFyIGIgPSBzcmMudmFsO1xyXG5cclxuICAgICAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcclxuICAgICAgICB2YXIgYjAgPSBiWzBdO1xyXG4gICAgICAgIHZhciBiMSA9IGJbMV07XHJcbiAgICAgICAgdmFyIGIyID0gYlsyXTtcclxuICAgICAgICB2YXIgYjMgPSBiWzNdO1xyXG5cclxuICAgICAgICBhWzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XHJcbiAgICAgICAgYVsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xyXG4gICAgICAgIGFbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcclxuICAgICAgICBhWzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XHJcblxyXG4gICAgICAgIGIwID0gYls0XTtcclxuICAgICAgICBiMSA9IGJbNV07XHJcbiAgICAgICAgYjIgPSBiWzZdO1xyXG4gICAgICAgIGIzID0gYls3XTtcclxuXHJcbiAgICAgICAgYVs0XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xyXG4gICAgICAgIGFbNV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcclxuICAgICAgICBhWzZdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XHJcbiAgICAgICAgYVs3XSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xyXG5cclxuICAgICAgICBiMCA9IGJbOF07XHJcbiAgICAgICAgYjEgPSBiWzldO1xyXG4gICAgICAgIGIyID0gYlsxMF07XHJcbiAgICAgICAgYjMgPSBiWzExXTtcclxuXHJcbiAgICAgICAgYVs4XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xyXG4gICAgICAgIGFbOV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcclxuICAgICAgICBhWzEwXSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xyXG4gICAgICAgIGFbMTFdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XHJcblxyXG4gICAgICAgIGIwID0gYlsxMl07XHJcbiAgICAgICAgYjEgPSBiWzEzXTtcclxuICAgICAgICBiMiA9IGJbMTRdO1xyXG4gICAgICAgIGIzID0gYlsxNV07XHJcblxyXG4gICAgICAgIGFbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XHJcbiAgICAgICAgYVsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcclxuICAgICAgICBhWzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xyXG4gICAgICAgIGFbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICh2KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gdi54O1xyXG4gICAgICAgIHZhciB5ID0gdi55O1xyXG4gICAgICAgIHZhciB6ID0gdi56O1xyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWw7XHJcblxyXG4gICAgICAgIGFbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XHJcbiAgICAgICAgYVsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcclxuICAgICAgICBhWzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcclxuICAgICAgICBhWzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlOiBmdW5jdGlvbiAodilcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IHYueDtcclxuICAgICAgICB2YXIgeSA9IHYueTtcclxuICAgICAgICB2YXIgeiA9IHYuejtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsO1xyXG5cclxuICAgICAgICBhWzBdID0gYVswXSAqIHg7XHJcbiAgICAgICAgYVsxXSA9IGFbMV0gKiB4O1xyXG4gICAgICAgIGFbMl0gPSBhWzJdICogeDtcclxuICAgICAgICBhWzNdID0gYVszXSAqIHg7XHJcblxyXG4gICAgICAgIGFbNF0gPSBhWzRdICogeTtcclxuICAgICAgICBhWzVdID0gYVs1XSAqIHk7XHJcbiAgICAgICAgYVs2XSA9IGFbNl0gKiB5O1xyXG4gICAgICAgIGFbN10gPSBhWzddICogeTtcclxuXHJcbiAgICAgICAgYVs4XSA9IGFbOF0gKiB6O1xyXG4gICAgICAgIGFbOV0gPSBhWzldICogejtcclxuICAgICAgICBhWzEwXSA9IGFbMTBdICogejtcclxuICAgICAgICBhWzExXSA9IGFbMTFdICogejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBBeGlzID0gdmVjMywgYW5nbGUgPSByYWRpYW5zXHJcbiAgICBtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiAoYXhpcywgYW5nbGUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXHJcblxyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIHZhciB0ID0gMSAtIGM7XHJcbiAgICAgICAgdmFyIHggPSBheGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSBheGlzLnk7XHJcbiAgICAgICAgdmFyIHogPSBheGlzLno7XHJcbiAgICAgICAgdmFyIHR4ID0gdCAqIHg7XHJcbiAgICAgICAgdmFyIHR5ID0gdCAqIHk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0KFxyXG4gICAgICAgICAgICB0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXHJcbiAgICAgICAgICAgIHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcclxuICAgICAgICAgICAgdHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZTogZnVuY3Rpb24gKHJhZCwgYXhpcylcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsO1xyXG4gICAgICAgIHZhciB4ID0gYXhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gYXhpcy55O1xyXG4gICAgICAgIHZhciB6ID0gYXhpcy56O1xyXG4gICAgICAgIHZhciBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcclxuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGxlbikgPCBFUFNJTE9OKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGxlbiA9IDEgLyBsZW47XHJcbiAgICAgICAgeCAqPSBsZW47XHJcbiAgICAgICAgeSAqPSBsZW47XHJcbiAgICAgICAgeiAqPSBsZW47XHJcblxyXG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XHJcbiAgICAgICAgdmFyIHQgPSAxIC0gYztcclxuXHJcbiAgICAgICAgdmFyIGEwMCA9IGFbMF07XHJcbiAgICAgICAgdmFyIGEwMSA9IGFbMV07XHJcbiAgICAgICAgdmFyIGEwMiA9IGFbMl07XHJcbiAgICAgICAgdmFyIGEwMyA9IGFbM107XHJcblxyXG4gICAgICAgIHZhciBhMTAgPSBhWzRdO1xyXG4gICAgICAgIHZhciBhMTEgPSBhWzVdO1xyXG4gICAgICAgIHZhciBhMTIgPSBhWzZdO1xyXG4gICAgICAgIHZhciBhMTMgPSBhWzddO1xyXG5cclxuICAgICAgICB2YXIgYTIwID0gYVs4XTtcclxuICAgICAgICB2YXIgYTIxID0gYVs5XTtcclxuICAgICAgICB2YXIgYTIyID0gYVsxMF07XHJcbiAgICAgICAgdmFyIGEyMyA9IGFbMTFdO1xyXG5cclxuICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcclxuICAgICAgICB2YXIgYjAwID0geCAqIHggKiB0ICsgYztcclxuICAgICAgICB2YXIgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XHJcbiAgICAgICAgdmFyIGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xyXG5cclxuICAgICAgICB2YXIgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7XHJcbiAgICAgICAgdmFyIGIxMSA9IHkgKiB5ICogdCArIGM7XHJcbiAgICAgICAgdmFyIGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xyXG5cclxuICAgICAgICB2YXIgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7XHJcbiAgICAgICAgdmFyIGIyMSA9IHkgKiB6ICogdCAtIHggKiBzO1xyXG4gICAgICAgIHZhciBiMjIgPSB6ICogeiAqIHQgKyBjO1xyXG5cclxuICAgICAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIGFbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XHJcbiAgICAgICAgYVsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcclxuICAgICAgICBhWzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xyXG4gICAgICAgIGFbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XHJcbiAgICAgICAgYVs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcclxuICAgICAgICBhWzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xyXG4gICAgICAgIGFbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XHJcbiAgICAgICAgYVs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcclxuICAgICAgICBhWzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xyXG4gICAgICAgIGFbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XHJcbiAgICAgICAgYVsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XHJcbiAgICAgICAgYVsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVYOiBmdW5jdGlvbiAocmFkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWw7XHJcbiAgICAgICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MocmFkKTtcclxuXHJcbiAgICAgICAgdmFyIGExMCA9IGFbNF07XHJcbiAgICAgICAgdmFyIGExMSA9IGFbNV07XHJcbiAgICAgICAgdmFyIGExMiA9IGFbNl07XHJcbiAgICAgICAgdmFyIGExMyA9IGFbN107XHJcblxyXG4gICAgICAgIHZhciBhMjAgPSBhWzhdO1xyXG4gICAgICAgIHZhciBhMjEgPSBhWzldO1xyXG4gICAgICAgIHZhciBhMjIgPSBhWzEwXTtcclxuICAgICAgICB2YXIgYTIzID0gYVsxMV07XHJcblxyXG4gICAgICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cclxuICAgICAgICBhWzRdID0gYTEwICogYyArIGEyMCAqIHM7XHJcbiAgICAgICAgYVs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xyXG4gICAgICAgIGFbNl0gPSBhMTIgKiBjICsgYTIyICogcztcclxuICAgICAgICBhWzddID0gYTEzICogYyArIGEyMyAqIHM7XHJcbiAgICAgICAgYVs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xyXG4gICAgICAgIGFbOV0gPSBhMjEgKiBjIC0gYTExICogcztcclxuICAgICAgICBhWzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xyXG4gICAgICAgIGFbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVZOiBmdW5jdGlvbiAocmFkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWw7XHJcbiAgICAgICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MocmFkKTtcclxuXHJcbiAgICAgICAgdmFyIGEwMCA9IGFbMF07XHJcbiAgICAgICAgdmFyIGEwMSA9IGFbMV07XHJcbiAgICAgICAgdmFyIGEwMiA9IGFbMl07XHJcbiAgICAgICAgdmFyIGEwMyA9IGFbM107XHJcblxyXG4gICAgICAgIHZhciBhMjAgPSBhWzhdO1xyXG4gICAgICAgIHZhciBhMjEgPSBhWzldO1xyXG4gICAgICAgIHZhciBhMjIgPSBhWzEwXTtcclxuICAgICAgICB2YXIgYTIzID0gYVsxMV07XHJcblxyXG4gICAgICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cclxuICAgICAgICBhWzBdID0gYTAwICogYyAtIGEyMCAqIHM7XHJcbiAgICAgICAgYVsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xyXG4gICAgICAgIGFbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcclxuICAgICAgICBhWzNdID0gYTAzICogYyAtIGEyMyAqIHM7XHJcbiAgICAgICAgYVs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xyXG4gICAgICAgIGFbOV0gPSBhMDEgKiBzICsgYTIxICogYztcclxuICAgICAgICBhWzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xyXG4gICAgICAgIGFbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVaOiBmdW5jdGlvbiAocmFkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWw7XHJcbiAgICAgICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MocmFkKTtcclxuXHJcbiAgICAgICAgdmFyIGEwMCA9IGFbMF07XHJcbiAgICAgICAgdmFyIGEwMSA9IGFbMV07XHJcbiAgICAgICAgdmFyIGEwMiA9IGFbMl07XHJcbiAgICAgICAgdmFyIGEwMyA9IGFbM107XHJcblxyXG4gICAgICAgIHZhciBhMTAgPSBhWzRdO1xyXG4gICAgICAgIHZhciBhMTEgPSBhWzVdO1xyXG4gICAgICAgIHZhciBhMTIgPSBhWzZdO1xyXG4gICAgICAgIHZhciBhMTMgPSBhWzddO1xyXG5cclxuICAgICAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgYVswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xyXG4gICAgICAgIGFbMV0gPSBhMDEgKiBjICsgYTExICogcztcclxuICAgICAgICBhWzJdID0gYTAyICogYyArIGExMiAqIHM7XHJcbiAgICAgICAgYVszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xyXG4gICAgICAgIGFbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcclxuICAgICAgICBhWzVdID0gYTExICogYyAtIGEwMSAqIHM7XHJcbiAgICAgICAgYVs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xyXG4gICAgICAgIGFbN10gPSBhMTMgKiBjIC0gYTAzICogcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uOiBmdW5jdGlvbiAocSwgdilcclxuICAgIHtcclxuICAgICAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcclxuICAgICAgICB2YXIgb3V0ID0gdGhpcy52YWw7XHJcblxyXG4gICAgICAgIHZhciB4ID0gcS54O1xyXG4gICAgICAgIHZhciB5ID0gcS55O1xyXG4gICAgICAgIHZhciB6ID0gcS56O1xyXG4gICAgICAgIHZhciB3ID0gcS53O1xyXG5cclxuICAgICAgICB2YXIgeDIgPSB4ICsgeDtcclxuICAgICAgICB2YXIgeTIgPSB5ICsgeTtcclxuICAgICAgICB2YXIgejIgPSB6ICsgejtcclxuXHJcbiAgICAgICAgdmFyIHh4ID0geCAqIHgyO1xyXG4gICAgICAgIHZhciB4eSA9IHggKiB5MjtcclxuICAgICAgICB2YXIgeHogPSB4ICogejI7XHJcblxyXG4gICAgICAgIHZhciB5eSA9IHkgKiB5MjtcclxuICAgICAgICB2YXIgeXogPSB5ICogejI7XHJcbiAgICAgICAgdmFyIHp6ID0geiAqIHoyO1xyXG5cclxuICAgICAgICB2YXIgd3ggPSB3ICogeDI7XHJcbiAgICAgICAgdmFyIHd5ID0gdyAqIHkyO1xyXG4gICAgICAgIHZhciB3eiA9IHcgKiB6MjtcclxuXHJcbiAgICAgICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcclxuICAgICAgICBvdXRbMV0gPSB4eSArIHd6O1xyXG4gICAgICAgIG91dFsyXSA9IHh6IC0gd3k7XHJcbiAgICAgICAgb3V0WzNdID0gMDtcclxuXHJcbiAgICAgICAgb3V0WzRdID0geHkgLSB3ejtcclxuICAgICAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xyXG4gICAgICAgIG91dFs2XSA9IHl6ICsgd3g7XHJcbiAgICAgICAgb3V0WzddID0gMDtcclxuXHJcbiAgICAgICAgb3V0WzhdID0geHogKyB3eTtcclxuICAgICAgICBvdXRbOV0gPSB5eiAtIHd4O1xyXG4gICAgICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xyXG4gICAgICAgIG91dFsxMV0gPSAwO1xyXG5cclxuICAgICAgICBvdXRbMTJdID0gdi54O1xyXG4gICAgICAgIG91dFsxM10gPSB2Lnk7XHJcbiAgICAgICAgb3V0WzE0XSA9IHYuejtcclxuICAgICAgICBvdXRbMTVdID0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21RdWF0OiBmdW5jdGlvbiAocSlcclxuICAgIHtcclxuICAgICAgICB2YXIgb3V0ID0gdGhpcy52YWw7XHJcblxyXG4gICAgICAgIHZhciB4ID0gcS54O1xyXG4gICAgICAgIHZhciB5ID0gcS55O1xyXG4gICAgICAgIHZhciB6ID0gcS56O1xyXG4gICAgICAgIHZhciB3ID0gcS53O1xyXG5cclxuICAgICAgICB2YXIgeDIgPSB4ICsgeDtcclxuICAgICAgICB2YXIgeTIgPSB5ICsgeTtcclxuICAgICAgICB2YXIgejIgPSB6ICsgejtcclxuXHJcbiAgICAgICAgdmFyIHh4ID0geCAqIHgyO1xyXG4gICAgICAgIHZhciB4eSA9IHggKiB5MjtcclxuICAgICAgICB2YXIgeHogPSB4ICogejI7XHJcblxyXG4gICAgICAgIHZhciB5eSA9IHkgKiB5MjtcclxuICAgICAgICB2YXIgeXogPSB5ICogejI7XHJcbiAgICAgICAgdmFyIHp6ID0geiAqIHoyO1xyXG5cclxuICAgICAgICB2YXIgd3ggPSB3ICogeDI7XHJcbiAgICAgICAgdmFyIHd5ID0gdyAqIHkyO1xyXG4gICAgICAgIHZhciB3eiA9IHcgKiB6MjtcclxuXHJcbiAgICAgICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcclxuICAgICAgICBvdXRbMV0gPSB4eSArIHd6O1xyXG4gICAgICAgIG91dFsyXSA9IHh6IC0gd3k7XHJcbiAgICAgICAgb3V0WzNdID0gMDtcclxuXHJcbiAgICAgICAgb3V0WzRdID0geHkgLSB3ejtcclxuICAgICAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xyXG4gICAgICAgIG91dFs2XSA9IHl6ICsgd3g7XHJcbiAgICAgICAgb3V0WzddID0gMDtcclxuXHJcbiAgICAgICAgb3V0WzhdID0geHogKyB3eTtcclxuICAgICAgICBvdXRbOV0gPSB5eiAtIHd4O1xyXG4gICAgICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xyXG4gICAgICAgIG91dFsxMV0gPSAwO1xyXG5cclxuICAgICAgICBvdXRbMTJdID0gMDtcclxuICAgICAgICBvdXRbMTNdID0gMDtcclxuICAgICAgICBvdXRbMTRdID0gMDtcclxuICAgICAgICBvdXRbMTVdID0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4NH0gdGhpcyBmb3IgY2hhaW5pbmdcclxuICAgICAqL1xyXG4gICAgZnJ1c3R1bTogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXQgPSB0aGlzLnZhbDtcclxuXHJcbiAgICAgICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpO1xyXG4gICAgICAgIHZhciB0YiA9IDEgLyAodG9wIC0gYm90dG9tKTtcclxuICAgICAgICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xyXG5cclxuICAgICAgICBvdXRbMF0gPSAobmVhciAqIDIpICogcmw7XHJcbiAgICAgICAgb3V0WzFdID0gMDtcclxuICAgICAgICBvdXRbMl0gPSAwO1xyXG4gICAgICAgIG91dFszXSA9IDA7XHJcblxyXG4gICAgICAgIG91dFs0XSA9IDA7XHJcbiAgICAgICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xyXG4gICAgICAgIG91dFs2XSA9IDA7XHJcbiAgICAgICAgb3V0WzddID0gMDtcclxuXHJcbiAgICAgICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcclxuICAgICAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xyXG4gICAgICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcclxuICAgICAgICBvdXRbMTFdID0gLTE7XHJcblxyXG4gICAgICAgIG91dFsxMl0gPSAwO1xyXG4gICAgICAgIG91dFsxM10gPSAwO1xyXG4gICAgICAgIG91dFsxNF0gPSAoZmFyICogbmVhciAqIDIpICogbmY7XHJcbiAgICAgICAgb3V0WzE1XSA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4NH0gdGhpcyBmb3IgY2hhaW5pbmdcclxuICAgICAqL1xyXG4gICAgcGVyc3BlY3RpdmU6IGZ1bmN0aW9uIChmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcilcclxuICAgIHtcclxuICAgICAgICB2YXIgb3V0ID0gdGhpcy52YWw7XHJcbiAgICAgICAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMik7XHJcbiAgICAgICAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcclxuXHJcbiAgICAgICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcclxuICAgICAgICBvdXRbMV0gPSAwO1xyXG4gICAgICAgIG91dFsyXSA9IDA7XHJcbiAgICAgICAgb3V0WzNdID0gMDtcclxuXHJcbiAgICAgICAgb3V0WzRdID0gMDtcclxuICAgICAgICBvdXRbNV0gPSBmO1xyXG4gICAgICAgIG91dFs2XSA9IDA7XHJcbiAgICAgICAgb3V0WzddID0gMDtcclxuXHJcbiAgICAgICAgb3V0WzhdID0gMDtcclxuICAgICAgICBvdXRbOV0gPSAwO1xyXG4gICAgICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcclxuICAgICAgICBvdXRbMTFdID0gLTE7XHJcblxyXG4gICAgICAgIG91dFsxMl0gPSAwO1xyXG4gICAgICAgIG91dFsxM10gPSAwO1xyXG4gICAgICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XHJcbiAgICAgICAgb3V0WzE1XSA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4NH0gdGhpcyBmb3IgY2hhaW5pbmdcclxuICAgICAqL1xyXG4gICAgb3J0aG86IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcilcclxuICAgIHtcclxuICAgICAgICB2YXIgb3V0ID0gdGhpcy52YWw7XHJcbiAgICAgICAgdmFyIGxyID0gbGVmdCAtIHJpZ2h0O1xyXG4gICAgICAgIHZhciBidCA9IGJvdHRvbSAtIHRvcDtcclxuICAgICAgICB2YXIgbmYgPSBuZWFyIC0gZmFyO1xyXG5cclxuICAgICAgICAvLyAgQXZvaWQgZGl2aXNpb24gYnkgemVyb1xyXG4gICAgICAgIGxyID0gKGxyID09PSAwKSA/IGxyIDogMSAvIGxyO1xyXG4gICAgICAgIGJ0ID0gKGJ0ID09PSAwKSA/IGJ0IDogMSAvIGJ0O1xyXG4gICAgICAgIG5mID0gKG5mID09PSAwKSA/IG5mIDogMSAvIG5mO1xyXG5cclxuICAgICAgICBvdXRbMF0gPSAtMiAqIGxyO1xyXG4gICAgICAgIG91dFsxXSA9IDA7XHJcbiAgICAgICAgb3V0WzJdID0gMDtcclxuICAgICAgICBvdXRbM10gPSAwO1xyXG5cclxuICAgICAgICBvdXRbNF0gPSAwO1xyXG4gICAgICAgIG91dFs1XSA9IC0yICogYnQ7XHJcbiAgICAgICAgb3V0WzZdID0gMDtcclxuICAgICAgICBvdXRbN10gPSAwO1xyXG5cclxuICAgICAgICBvdXRbOF0gPSAwO1xyXG4gICAgICAgIG91dFs5XSA9IDA7XHJcbiAgICAgICAgb3V0WzEwXSA9IDIgKiBuZjtcclxuICAgICAgICBvdXRbMTFdID0gMDtcclxuXHJcbiAgICAgICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XHJcbiAgICAgICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XHJcbiAgICAgICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xyXG4gICAgICAgIG91dFsxNV0gPSAxO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7VmVjdG9yM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcclxuICAgICAqIEBwYXJhbSB7VmVjdG9yM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxyXG4gICAgICogQHBhcmFtIHtWZWN0b3IzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4NH0gdGhpcyBmb3IgY2hhaW5pbmdcclxuICAgICAqL1xyXG4gICAgbG9va0F0OiBmdW5jdGlvbiAoZXllLCBjZW50ZXIsIHVwKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXQgPSB0aGlzLnZhbDtcclxuXHJcbiAgICAgICAgdmFyIGV5ZXggPSBleWUueDtcclxuICAgICAgICB2YXIgZXlleSA9IGV5ZS55O1xyXG4gICAgICAgIHZhciBleWV6ID0gZXllLno7XHJcblxyXG4gICAgICAgIHZhciB1cHggPSB1cC54O1xyXG4gICAgICAgIHZhciB1cHkgPSB1cC55O1xyXG4gICAgICAgIHZhciB1cHogPSB1cC56O1xyXG5cclxuICAgICAgICB2YXIgY2VudGVyeCA9IGNlbnRlci54O1xyXG4gICAgICAgIHZhciBjZW50ZXJ5ID0gY2VudGVyLnk7XHJcbiAgICAgICAgdmFyIGNlbnRlcnogPSBjZW50ZXIuejtcclxuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IEVQU0lMT04gJiZcclxuICAgICAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgRVBTSUxPTiAmJlxyXG4gICAgICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBFUFNJTE9OKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpdHkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xyXG4gICAgICAgIHZhciB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xyXG4gICAgICAgIHZhciB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xyXG5cclxuICAgICAgICB2YXIgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xyXG5cclxuICAgICAgICB6MCAqPSBsZW47XHJcbiAgICAgICAgejEgKj0gbGVuO1xyXG4gICAgICAgIHoyICo9IGxlbjtcclxuXHJcbiAgICAgICAgdmFyIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcclxuICAgICAgICB2YXIgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xyXG4gICAgICAgIHZhciB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XHJcblxyXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xyXG5cclxuICAgICAgICBpZiAoIWxlbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHgwID0gMDtcclxuICAgICAgICAgICAgeDEgPSAwO1xyXG4gICAgICAgICAgICB4MiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxlbiA9IDEgLyBsZW47XHJcbiAgICAgICAgICAgIHgwICo9IGxlbjtcclxuICAgICAgICAgICAgeDEgKj0gbGVuO1xyXG4gICAgICAgICAgICB4MiAqPSBsZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcclxuICAgICAgICB2YXIgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcclxuICAgICAgICB2YXIgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcclxuXHJcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XHJcblxyXG4gICAgICAgIGlmICghbGVuKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeTAgPSAwO1xyXG4gICAgICAgICAgICB5MSA9IDA7XHJcbiAgICAgICAgICAgIHkyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGVuID0gMSAvIGxlbjtcclxuICAgICAgICAgICAgeTAgKj0gbGVuO1xyXG4gICAgICAgICAgICB5MSAqPSBsZW47XHJcbiAgICAgICAgICAgIHkyICo9IGxlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG91dFswXSA9IHgwO1xyXG4gICAgICAgIG91dFsxXSA9IHkwO1xyXG4gICAgICAgIG91dFsyXSA9IHowO1xyXG4gICAgICAgIG91dFszXSA9IDA7XHJcblxyXG4gICAgICAgIG91dFs0XSA9IHgxO1xyXG4gICAgICAgIG91dFs1XSA9IHkxO1xyXG4gICAgICAgIG91dFs2XSA9IHoxO1xyXG4gICAgICAgIG91dFs3XSA9IDA7XHJcblxyXG4gICAgICAgIG91dFs4XSA9IHgyO1xyXG4gICAgICAgIG91dFs5XSA9IHkyO1xyXG4gICAgICAgIG91dFsxMF0gPSB6MjtcclxuICAgICAgICBvdXRbMTFdID0gMDtcclxuXHJcbiAgICAgICAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcclxuICAgICAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xyXG4gICAgICAgIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XHJcbiAgICAgICAgb3V0WzE1XSA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5NYXRyaXg0LnByb3RvdHlwZS5tdWwgPSBNYXRyaXg0LnByb3RvdHlwZS5tdWx0aXBseTtcclxuTWF0cml4NC5wcm90b3R5cGUuaWR0ID0gTWF0cml4NC5wcm90b3R5cGUuaWRlbnRpdHk7XHJcbk1hdHJpeDQucHJvdG90eXBlLnJlc2V0ID0gTWF0cml4NC5wcm90b3R5cGUuaWR0O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXRyaXg0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvTWF0cml4NC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbi8vIEEgU2V0IGlzIGEgY29sbGVjdGlvbiBvZiB1bmlxdWUgZWxlbWVudHMuXHJcbnZhciBTZXQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gU2V0IChlbGVtZW50cylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmVudHJpZXMgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZWxlbWVudHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5lbnRyaWVzLmluZGV4T2YodmFsdWUpID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoZW50cnlbcHJvcGVydHldID09PSB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBcnJheTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzLnNsaWNlKDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZWxldGU6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmVudHJpZXMuaW5kZXhPZih2YWx1ZSk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZHVtcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmdyb3VwKCdTZXQnKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVudHJ5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8vICBGb3Igd2hlbiB5b3Uga25vdyB0aGlzIFNldCB3aWxsIGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgaXRlcmF0aW9uXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmVudHJpZXMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHRlbXBbaV0pID09PSBmYWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgRm9yIHdoZW4geW91IGFic29sdXRlbHkga25vdyB0aGlzIFNldCB3b24ndCBiZSBtb2RpZmllZCBkdXJpbmcgdGhlIGl0ZXJhdGlvblxyXG4gICAgaXRlcmF0ZTogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRyaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHRoaXMuZW50cmllc1tpXSwgaSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZW50cmllcy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZW50cmllcy5pbmRleE9mKHZhbHVlKSA+IC0xKTtcclxuICAgIH0sXHJcblxyXG4gICAgdW5pb246IGZ1bmN0aW9uIChzZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgc2V0LnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuZXdTZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1NldDtcclxuICAgIH0sXHJcblxyXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoc2V0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuZXdTZXQgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzZXQuY29udGFpbnModmFsdWUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3U2V0O1xyXG4gICAgfSxcclxuXHJcbiAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbiAoc2V0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuZXdTZXQgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghc2V0LmNvbnRhaW5zKHZhbHVlKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbmV3U2V0LmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1NldDtcclxuICAgIH0sXHJcblxyXG4gICAgc2l6ZToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzLmxlbmd0aDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMubGVuZ3RoID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3RydWN0cy9TZXQuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcclxuXHJcbnZhciBCcm93c2VyID0ge1xyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IGFyb3JhIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBBcm9yYS5cclxuICAgIGFyb3JhOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBjaHJvbWUgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIENocm9tZS5cclxuICAgIGNocm9tZTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaHJvbWVWZXJzaW9uIC0gSWYgcnVubmluZyBpbiBDaHJvbWUgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxyXG4gICAgY2hyb21lVmVyc2lvbjogMCxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBlcGlwaGFueSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gRXBpcGhhbnkuXHJcbiAgICBlcGlwaGFueTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmlyZWZveCAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gRmlyZWZveC5cclxuICAgIGZpcmVmb3g6IGZhbHNlLFxyXG5cclxuICAgIC8vICBAcHJvcGVydHkge251bWJlcn0gZmlyZWZveFZlcnNpb24gLSBJZiBydW5uaW5nIGluIEZpcmVmb3ggdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxyXG4gICAgZmlyZWZveFZlcnNpb246IDAsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbW9iaWxlU2FmYXJpIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBNb2JpbGUgU2FmYXJpLlxyXG4gICAgbW9iaWxlU2FmYXJpOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBpZSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXHJcbiAgICBpZTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZVZlcnNpb24gLSBJZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyIHRoaXMgd2lsbCBjb250YWluIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci4gQmV5b25kIElFMTAgeW91IHNob3VsZCB1c2UgRGV2aWNlLnRyaWRlbnQgYW5kIERldmljZS50cmlkZW50VmVyc2lvbi5cclxuICAgIGllVmVyc2lvbjogMCxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBtaWRvcmkgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIE1pZG9yaS5cclxuICAgIG1pZG9yaTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3BlcmEgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIE9wZXJhLlxyXG4gICAgb3BlcmE6IGZhbHNlLFxyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IHNhZmFyaSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gU2FmYXJpLlxyXG4gICAgc2FmYXJpOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtudW1iZXJ9IHNhZmFyaVZlcnNpb24gLSBJZiBydW5uaW5nIGluIFNhZmFyaSB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICBzYWZhcmlWZXJzaW9uOiAwLFxyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IHRyaWRlbnQgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGEgVHJpZGVudCB2ZXJzaW9uIG9mIEludGVybmV0IEV4cGxvcmVyIChJRTExKylcclxuICAgIHRyaWRlbnQ6IGZhbHNlLFxyXG5cclxuICAgIC8vICBAcHJvcGVydHkge251bWJlcn0gdHJpZGVudFZlcnNpb24gLSBJZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyIDExIHRoaXMgd2lsbCBjb250YWluIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci4gU2VlIHtAbGluayBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvbXM1Mzc1MDModj12cy44NSkuYXNweH1cclxuICAgIHRyaWRlbnRWZXJzaW9uOiAwLFxyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IGVkZ2UgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIE1pY3Jvc29mdCBFZGdlIGJyb3dzZXIuXHJcbiAgICBlZGdlOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBzaWxrIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiB0aGUgU2lsayBicm93c2VyIChhcyB1c2VkIG9uIHRoZSBBbWF6b24gS2luZGxlKVxyXG4gICAgc2lsazogZmFsc2VcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XHJcblxyXG4gICAgaWYgKCgvQXJvcmEvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmFyb3JhID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9FZGdlXFwvXFxkKy8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5lZGdlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvQ2hyb21lXFwvKFxcZCspLykudGVzdCh1YSkgJiYgIU9TLndpbmRvd3NQaG9uZSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmNocm9tZSA9IHRydWU7XHJcbiAgICAgICAgQnJvd3Nlci5jaHJvbWVWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL0VwaXBoYW55LykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5lcGlwaGFueSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL0ZpcmVmb3hcXEQrKFxcZCspLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcclxuICAgICAgICBCcm93c2VyLmZpcmVmb3hWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL0FwcGxlV2ViS2l0LykudGVzdCh1YSkgJiYgT1MuaU9TKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIubW9iaWxlU2FmYXJpID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvTVNJRSAoXFxkK1xcLlxcZCspOy8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuaWUgPSB0cnVlO1xyXG4gICAgICAgIEJyb3dzZXIuaWVWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL01pZG9yaS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIubWlkb3JpID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvT3BlcmEvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLm9wZXJhID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvU2FmYXJpLykudGVzdCh1YSkgJiYgIU9TLndpbmRvd3NQaG9uZSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLnNhZmFyaSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL1RyaWRlbnRcXC8oXFxkK1xcLlxcZCspKC4qKXJ2OihcXGQrXFwuXFxkKykvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmllID0gdHJ1ZTtcclxuICAgICAgICBCcm93c2VyLnRyaWRlbnQgPSB0cnVlO1xyXG4gICAgICAgIEJyb3dzZXIudHJpZGVudFZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgICAgICBCcm93c2VyLmllVmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMywgMTApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTaWxrIGdldHMgaXRzIG93biBpZiBjbGF1c2UgYmVjYXVzZSBpdHMgdWEgYWxzbyBjb250YWlucyAnU2FmYXJpJ1xyXG4gICAgaWYgKCgvU2lsay8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuc2lsayA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEJyb3dzZXI7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RldmljZS9Ccm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cycpO1xyXG52YXIgSW1hZ2VSZW5kZXIgPSByZXF1aXJlKCcuL0ltYWdlUmVuZGVyJyk7XHJcblxyXG52YXIgSW1hZ2UgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLkZsaXAsXHJcbiAgICAgICAgQ29tcG9uZW50cy5HZXRCb3VuZHMsXHJcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXHJcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJUYXJnZXQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TaXplLFxyXG4gICAgICAgIENvbXBvbmVudHMuVGV4dHVyZSxcclxuICAgICAgICBDb21wb25lbnRzLlRpbnQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIEltYWdlUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gSW1hZ2UgKHNjZW5lLCB4LCB5LCB0ZXh0dXJlLCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc2NlbmUsICdJbWFnZScpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRleHR1cmUodGV4dHVyZSwgZnJhbWUpO1xyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5zZXRTaXplVG9GcmFtZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0T3JpZ2luKCk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzJyk7XHJcbnZhciBNZXNoUmVuZGVyID0gcmVxdWlyZSgnLi9NZXNoUmVuZGVyJyk7XHJcblxyXG52YXIgTWVzaCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuRmxpcCxcclxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBDb21wb25lbnRzLlNjcm9sbEZhY3RvcixcclxuICAgICAgICBNZXNoUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gTWVzaCAoc2NlbmUsIHgsIHksIHZlcnRpY2VzLCB1diwgaW5kaWNlcywgY29sb3JzLCBhbHBoYXMsIHRleHR1cmUsIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzY2VuZSwgJ01lc2gnKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRleHR1cmUsIGZyYW1lKTtcclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZVRvRnJhbWUoKTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigpO1xyXG5cclxuICAgICAgICBpZiAodmVydGljZXMubGVuZ3RoICE9PSB1di5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BoYXNlcjogVmVydGV4IGNvdW50IG11c3QgbWF0Y2ggVVYgY291bnQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0aWNlc1VCID0gKHZlcnRpY2VzLmxlbmd0aCAvIDIpIHwgMDtcclxuXHJcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPiAwICYmIGNvbG9ycy5sZW5ndGggPCB2ZXJ0aWNlc1VCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaGFzZXI6IENvbG9yIGNvdW50IG11c3QgbWF0Y2ggVmVydGV4IGNvdW50Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWxwaGFzLmxlbmd0aCA+IDAgJiYgYWxwaGFzLmxlbmd0aCA8IHZlcnRpY2VzVUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BoYXNlcjogQWxwaGEgY291bnQgbXVzdCBtYXRjaCBWZXJ0ZXggY291bnQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpO1xyXG5cclxuICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlc1VCOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yc1tpXSA9IDB4RkZGRkZGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWxwaGFzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlc1VCOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFscGhhc1tpXSA9IDEuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpO1xyXG4gICAgICAgIHRoaXMudXYgPSBuZXcgRmxvYXQzMkFycmF5KHV2KTtcclxuICAgICAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyk7XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgVWludDMyQXJyYXkoY29sb3JzKTtcclxuICAgICAgICB0aGlzLmFscGhhcyA9IG5ldyBGbG9hdDMyQXJyYXkoYWxwaGFzKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXNoO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL21lc2gvTWVzaC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBTcHJpdGUgPSByZXF1aXJlKCcuLi9zcHJpdGUvU3ByaXRlJyk7XHJcbnZhciBWZWN0b3IyID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWN0b3IyJyk7XHJcbnZhciBWZWN0b3I0ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWN0b3I0Jyk7XHJcblxyXG52YXIgU3ByaXRlM0QgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBTcHJpdGUzRCAoc2NlbmUsIHgsIHksIHosIHRleHR1cmUsIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzY2VuZSwgJ1Nwcml0ZTNEJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdCA9IG5ldyBTcHJpdGUoc2NlbmUsIDAsIDAsIHRleHR1cmUsIGZyYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWN0b3I0KHgsIHksIHopO1xyXG5cclxuICAgICAgICB0aGlzLnNpemUgPSBuZXcgVmVjdG9yMih0aGlzLmdhbWVPYmplY3Qud2lkdGgsIHRoaXMuZ2FtZU9iamVjdC5oZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLnNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRqdXN0U2NhbGVYID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFkanVzdFNjYWxlWSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcm9qZWN0OiBmdW5jdGlvbiAoY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICB2YXIgZ2FtZU9iamVjdCA9IHRoaXMuZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgY2FtZXJhLnByb2plY3QocG9zLCBnYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgY2FtZXJhLmdldFBvaW50U2l6ZShwb3MsIHRoaXMuc2l6ZSwgdGhpcy5zY2FsZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlLnggPD0gMCB8fCB0aGlzLnNjYWxlLnkgPD0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3Quc2V0VmlzaWJsZShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghZ2FtZU9iamVjdC52aXNpYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBnYW1lT2JqZWN0LnNldFZpc2libGUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFkanVzdFNjYWxlWClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdC5zY2FsZVggPSB0aGlzLnNjYWxlLng7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFkanVzdFNjYWxlWSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdC5zY2FsZVkgPSB0aGlzLnNjYWxlLnk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdhbWVPYmplY3Quc2V0RGVwdGgoZ2FtZU9iamVjdC56ICogLTEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdmlzaWJsZToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lT2JqZWN0LnZpc2libGUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB4OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB5OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB6OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLno7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnogPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZTNEO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3Nwcml0ZTNkL1Nwcml0ZTNELmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIEJsZW5kTW9kZXMgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlci9CbGVuZE1vZGVzJyk7XHJcbnZhciBDaXJjbGUgPSByZXF1aXJlKCcuLi8uLi9nZW9tL2NpcmNsZS9DaXJjbGUnKTtcclxudmFyIENpcmNsZUNvbnRhaW5zID0gcmVxdWlyZSgnLi4vLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnMnKTtcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi4vLi4vZ2VvbS9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XHJcbnZhciBSZWN0YW5nbGVDb250YWlucyA9IHJlcXVpcmUoJy4uLy4uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zJyk7XHJcblxyXG4vLyAgQSBab25lIGlzIGEgbm9uLXJlbmRlcmluZyBHYW1lIE9iamVjdCB0aGF0IGhhcyBhIHBvc2l0aW9uIGFuZCBzaXplLlxyXG4vLyAgSXQgaGFzIG5vIHRleHR1cmUgYW5kIG5ldmVyIHJlbmRlcnMsIGJ1dCBkb2VzIGxpdmUgb24gdGhlIGRpc3BsYXkgbGlzdCBhbmRcclxuLy8gIGNhbiBiZSBtb3ZlZCwgc2NhbGVkIGFuZCByb3RhdGVkIGxpa2UgYW55IG90aGVyIEdhbWUgT2JqZWN0LlxyXG4vLyAgVGhlIGRlZmF1bHQgb3JpZ2luIGlzIDAuNSwgdGhlIGNlbnRlciBvZiB0aGUgWm9uZSwgdGhlIHNhbWUgYXMgd2l0aCBHYW1lIE9iamVjdHMuXHJcbi8vICBJdCdzIHVzZWZ1bCBmb3IgbGlua2luZyB0byBkcm9wIHpvbmVzIGFuZCBpbnB1dCBoaXQgYXJlYXMgYW5kIGhhcyBhIGNvdXBsZSBvZiBoZWxwZXIgbWV0aG9kcyBzcGVjaWZpY2FsbHkgZm9yIHRoaXMuXHJcbi8vICBBbHNvIHVzZWZ1bCBmb3Igb2JqZWN0IG92ZXJsYXAgY2hlY2tzLCBvciBhcyBhIGJhc2UgZm9yIHlvdXIgb3duIG5vbi1kaXNwbGF5aW5nIG9iamVjdHMuXHJcblxyXG52YXIgWm9uZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gWm9uZSAoc2NlbmUsIHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSAxOyB9XHJcbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IHdpZHRoOyB9XHJcblxyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzY2VuZSwgJ1pvbmUnKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgICAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gQmxlbmRNb2Rlcy5OT1JNQUw7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDZW50ZXJlZCBvbiB0aGUgWm9uZXMgeC95XHJcbiAgICBzZXRDaXJjbGVEcm9wWm9uZTogZnVuY3Rpb24gKHJhZGl1cylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXREcm9wWm9uZShuZXcgQ2lyY2xlKDAsIDAsIHJhZGl1cyksIENpcmNsZUNvbnRhaW5zKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENlbnRlcmVkIG9uIHRoZSBab25lcyB4L3kgcG9zaXRpb25cclxuICAgIHNldFJlY3RhbmdsZURyb3Bab25lOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IC0od2lkdGggLyAyKTtcclxuICAgICAgICB2YXIgeSA9IC0oaGVpZ2h0IC8gMik7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNldERyb3Bab25lKG5ldyBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCksIFJlY3RhbmdsZUNvbnRhaW5zKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIERlZmluZSB5b3VyIG93biBzaGFwZSBhcyB0aGUgZHJvcCB6b25lXHJcbiAgICBzZXREcm9wWm9uZTogZnVuY3Rpb24gKHNoYXBlLCBjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICBpZiAoc2hhcGUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UmVjdGFuZ2xlRHJvcFpvbmUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJhY3RpdmUoc2hhcGUsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kcm9wWm9uZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyQ2FudmFzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyV2ViR0w6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFpvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvem9uZS9ab25lLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIENpcmNsZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBDaXJjbGUgKHgsIHksIHJhZGl1cylcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgICAgIGlmIChyYWRpdXMgPT09IHVuZGVmaW5lZCkgeyByYWRpdXMgPSAwOyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcclxuICAgICAgICB0aGlzLl9kaWFtZXRlciA9IHJhZGl1cyAqIDI7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRvOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XHJcbiAgICAgICAgdGhpcy5fZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VG8oMCwgMCwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9yYWRpdXMgPD0gMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJhZGl1czoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpYW1ldGVyID0gdmFsdWUgKiAyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpYW1ldGVyOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWFtZXRlcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpYW1ldGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHZhbHVlICogMC41O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlZnQ6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAtIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlICsgdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZSAtIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3A6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSAtIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlICsgdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy55ID0gdmFsdWUgLSB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9jaXJjbGUvQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29udGFpbnMgPSBmdW5jdGlvbiAoZWxsaXBzZSwgeCwgeSlcclxue1xyXG4gICAgaWYgKGVsbGlwc2Uud2lkdGggPD0gMCB8fCBlbGxpcHNlLmhlaWdodCA8PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuIFxyXG4gICAgLy8gIE5vcm1hbGl6ZSB0aGUgY29vcmRzIHRvIGFuIGVsbGlwc2Ugd2l0aCBjZW50ZXIgMCwwIGFuZCBhIHJhZGl1cyBvZiAwLjVcclxuICAgIHZhciBub3JteCA9ICgoeCAtIGVsbGlwc2UueCkgLyBlbGxpcHNlLndpZHRoKSAtIDAuNTtcclxuICAgIHZhciBub3JteSA9ICgoeSAtIGVsbGlwc2UueSkgLyBlbGxpcHNlLmhlaWdodCkgLSAwLjU7XHJcbiBcclxuICAgIG5vcm14ICo9IG5vcm14O1xyXG4gICAgbm9ybXkgKj0gbm9ybXk7XHJcbiBcclxuICAgIHJldHVybiAobm9ybXggKyBub3JteSA8IDAuMjUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWlucztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2VsbGlwc2UvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGlzIGlzIGJhc2VkIG9mZiBhbiBleHBsYW5hdGlvbiBhbmQgZXhwYW5kZWQgbWF0aCBwcmVzZW50ZWQgYnkgUGF1bCBCb3Vya2U6XHJcbi8vICBTZWUgaHR0cDonbG9jYWwud2FzcC51d2EuZWR1LmF1L35wYm91cmtlL2dlb21ldHJ5L2xpbmVsaW5lMmQvXHJcblxyXG52YXIgTGluZVRvTGluZSA9IGZ1bmN0aW9uIChsaW5lMSwgbGluZTIsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgdmFyIHgxID0gbGluZTEueDE7XHJcbiAgICB2YXIgeTEgPSBsaW5lMS55MTtcclxuICAgIHZhciB4MiA9IGxpbmUxLngyO1xyXG4gICAgdmFyIHkyID0gbGluZTEueTI7XHJcblxyXG4gICAgdmFyIHgzID0gbGluZTIueDE7XHJcbiAgICB2YXIgeTMgPSBsaW5lMi55MTtcclxuICAgIHZhciB4NCA9IGxpbmUyLngyO1xyXG4gICAgdmFyIHk0ID0gbGluZTIueTI7XHJcblxyXG4gICAgdmFyIG51bUEgPSAoeDQgLSB4MykgKiAoeTEgLSB5MykgLSAoeTQgLSB5MykgKiAoeDEgLSB4Myk7XHJcbiAgICB2YXIgbnVtQiA9ICh4MiAtIHgxKSAqICh5MSAtIHkzKSAtICh5MiAtIHkxKSAqICh4MSAtIHgzKTtcclxuICAgIHZhciBkZU5vbSA9ICh5NCAtIHkzKSAqICh4MiAtIHgxKSAtICh4NCAtIHgzKSAqICh5MiAtIHkxKTtcclxuXHJcbiAgICAvLyAgTWFrZSBzdXJlIHRoZXJlIGlzIG5vdCBhIGRpdmlzaW9uIGJ5IHplcm8gLSB0aGlzIGFsc28gaW5kaWNhdGVzIHRoYXQgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbC5cclxuICAgIC8vICBJZiBudW1BIGFuZCBudW1CIHdlcmUgYm90aCBlcXVhbCB0byB6ZXJvIHRoZSBsaW5lcyB3b3VsZCBiZSBvbiB0b3Agb2YgZWFjaCBvdGhlciAoY29pbmNpZGVudGFsKS5cclxuICAgIC8vICBUaGlzIGNoZWNrIGlzIG5vdCBkb25lIGJlY2F1c2UgaXQgaXMgbm90IG5lY2Vzc2FyeSBmb3IgdGhpcyBpbXBsZW1lbnRhdGlvbiAodGhlIHBhcmFsbGVsIGNoZWNrIGFjY291bnRzIGZvciB0aGlzKS5cclxuXHJcbiAgICBpZiAoZGVOb20gPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBDYWxjdWxhdGUgdGhlIGludGVybWVkaWF0ZSBmcmFjdGlvbmFsIHBvaW50IHRoYXQgdGhlIGxpbmVzIHBvdGVudGlhbGx5IGludGVyc2VjdC5cclxuXHJcbiAgICB2YXIgdUEgPSBudW1BIC8gZGVOb207XHJcbiAgICB2YXIgdUIgPSBudW1CIC8gZGVOb207XHJcblxyXG4gICAgLy8gIFRoZSBmcmFjdGlvbmFsIHBvaW50IHdpbGwgYmUgYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZSBpZiB0aGUgbGluZXMgaW50ZXJzZWN0LlxyXG4gICAgLy8gIElmIHRoZSBmcmFjdGlvbmFsIGNhbGN1bGF0aW9uIGlzIGxhcmdlciB0aGFuIDEgb3Igc21hbGxlciB0aGFuIDAgdGhlIGxpbmVzIHdvdWxkIG5lZWQgdG8gYmUgbG9uZ2VyIHRvIGludGVyc2VjdC5cclxuXHJcbiAgICBpZiAodUEgPj0gMCAmJiB1QSA8PSAxICYmIHVCID49IDAgJiYgdUIgPD0gMSlcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IHgxICsgKHVBICogKHgyIC0geDEpKTtcclxuICAgICAgICBvdXQueSA9IHkxICsgKHVBICogKHkyIC0geTEpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVG9MaW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUkdCU3RyaW5nVG9Db2xvciA9IHJlcXVpcmUoJy4vUkdCU3RyaW5nVG9Db2xvcicpO1xyXG52YXIgSGV4U3RyaW5nVG9Db2xvciA9IHJlcXVpcmUoJy4vSGV4U3RyaW5nVG9Db2xvcicpO1xyXG52YXIgSW50ZWdlclRvQ29sb3IgPSByZXF1aXJlKCcuL0ludGVnZXJUb0NvbG9yJyk7XHJcblxyXG52YXIgVmFsdWVUb0NvbG9yID0gZnVuY3Rpb24gKGlucHV0KVxyXG57XHJcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJylcclxuICAgIHtcclxuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpLnRvTG93ZXJDYXNlKCkgPT09ICdyZ2InKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJHQlN0cmluZ1RvQ29sb3IoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gSGV4U3RyaW5nVG9Db2xvcihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gSW50ZWdlclRvQ29sb3IoaW5wdXQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWYWx1ZVRvQ29sb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvVmFsdWVUb0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLklucHV0LkdhbWVwYWQuRXZlbnRzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIENPTk5FQ1RFRDogcmVxdWlyZSgnLi9HYW1lcGFkQ29ubmVjdGVkRXZlbnQnKSxcclxuICAgIERJU0NPTk5FQ1RFRDogcmVxdWlyZSgnLi9HYW1lcGFkRGlzY29ubmVjdGVkRXZlbnQnKSxcclxuICAgIERPV046IHJlcXVpcmUoJy4vR2FtZXBhZERvd25FdmVudCcpLFxyXG4gICAgVVA6IHJlcXVpcmUoJy4vR2FtZXBhZFVwRXZlbnQnKVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2dhbWVwYWQvZXZlbnRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlbiA9IGZ1bmN0aW9uIChtaW4sIG1heClcclxue1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9CZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQWRhcHRlZCBmcm9tIFtnbC1tYXRyaXhdKGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeCkgYnkgdG9qaSBcclxuLy8gIGFuZCBbdmVjbWF0aF0oaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL3ZlY21hdGgpIGJ5IG1hdHRkZXNsXHJcblxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIFZlY3RvcjQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gVmVjdG9yNCAoeCwgeSwgeiwgdylcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geC54IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHgueSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnogPSB4LnogfHwgMDtcclxuICAgICAgICAgICAgdGhpcy53ID0geC53IHx8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHggfHwgMDtcclxuICAgICAgICAgICAgdGhpcy55ID0geSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnogPSB6IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IHcgfHwgMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yNCh0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoc3JjKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IHNyYy54O1xyXG4gICAgICAgIHRoaXMueSA9IHNyYy55O1xyXG4gICAgICAgIHRoaXMueiA9IHNyYy56IHx8IDA7XHJcbiAgICAgICAgdGhpcy53ID0gc3JjLncgfHwgMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKHYpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy54ID09PSB2LngpICYmICh0aGlzLnkgPT09IHYueSkgJiYgKHRoaXMueiA9PT0gdi56KSAmJiAodGhpcy53ID09PSB2LncpKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoeCwgeSwgeiwgdylcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geC54IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHgueSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnogPSB4LnogfHwgMDtcclxuICAgICAgICAgICAgdGhpcy53ID0geC53IHx8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHggfHwgMDtcclxuICAgICAgICAgICAgdGhpcy55ID0geSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnogPSB6IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IHcgfHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh2KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCArPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ICs9IHYueTtcclxuICAgICAgICB0aGlzLnogKz0gdi56IHx8IDA7XHJcbiAgICAgICAgdGhpcy53ICs9IHYudyB8fCAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uICh2KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCAtPSB2Lng7XHJcbiAgICAgICAgdGhpcy55IC09IHYueTtcclxuICAgICAgICB0aGlzLnogLT0gdi56IHx8IDA7XHJcbiAgICAgICAgdGhpcy53IC09IHYudyB8fCAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGU6IGZ1bmN0aW9uIChzY2FsZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggKj0gc2NhbGU7XHJcbiAgICAgICAgdGhpcy55ICo9IHNjYWxlO1xyXG4gICAgICAgIHRoaXMueiAqPSBzY2FsZTtcclxuICAgICAgICB0aGlzLncgKj0gc2NhbGU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBsZW5ndGg6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBsZW5ndGhTcTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuICAgICAgICB2YXIgeiA9IHRoaXMuejtcclxuICAgICAgICB2YXIgdyA9IHRoaXMudztcclxuXHJcbiAgICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XHJcbiAgICAgICAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xyXG5cclxuICAgICAgICBpZiAobGVuID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMueCA9IHggKiBsZW47XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHkgKiBsZW47XHJcbiAgICAgICAgICAgIHRoaXMueiA9IHogKiBsZW47XHJcbiAgICAgICAgICAgIHRoaXMudyA9IHcgKiBsZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZG90OiBmdW5jdGlvbiAodilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xyXG4gICAgfSxcclxuXHJcbiAgICBsZXJwOiBmdW5jdGlvbiAodiwgdClcclxuICAgIHtcclxuICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7IHQgPSAwOyB9XHJcblxyXG4gICAgICAgIHZhciBheCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgYXkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIGF6ID0gdGhpcy56O1xyXG4gICAgICAgIHZhciBhdyA9IHRoaXMudztcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYXggKyB0ICogKHYueCAtIGF4KTtcclxuICAgICAgICB0aGlzLnkgPSBheSArIHQgKiAodi55IC0gYXkpO1xyXG4gICAgICAgIHRoaXMueiA9IGF6ICsgdCAqICh2LnogLSBheik7XHJcbiAgICAgICAgdGhpcy53ID0gYXcgKyB0ICogKHYudyAtIGF3KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpcGx5OiBmdW5jdGlvbiAodilcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggKj0gdi54O1xyXG4gICAgICAgIHRoaXMueSAqPSB2Lnk7XHJcbiAgICAgICAgdGhpcy56ICo9IHYueiB8fCAxO1xyXG4gICAgICAgIHRoaXMudyAqPSB2LncgfHwgMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpdmlkZTogZnVuY3Rpb24gKHYpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54IC89IHYueDtcclxuICAgICAgICB0aGlzLnkgLz0gdi55O1xyXG4gICAgICAgIHRoaXMueiAvPSB2LnogfHwgMTtcclxuICAgICAgICB0aGlzLncgLz0gdi53IHx8IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHYpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGR4ID0gdi54IC0gdGhpcy54O1xyXG4gICAgICAgIHZhciBkeSA9IHYueSAtIHRoaXMueTtcclxuICAgICAgICB2YXIgZHogPSB2LnogLSB0aGlzLnogfHwgMDtcclxuICAgICAgICB2YXIgZHcgPSB2LncgLSB0aGlzLncgfHwgMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHogKyBkdyAqIGR3KTtcclxuICAgIH0sXHJcblxyXG4gICAgZGlzdGFuY2VTcTogZnVuY3Rpb24gKHYpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGR4ID0gdi54IC0gdGhpcy54O1xyXG4gICAgICAgIHZhciBkeSA9IHYueSAtIHRoaXMueTtcclxuICAgICAgICB2YXIgZHogPSB2LnogLSB0aGlzLnogfHwgMDtcclxuICAgICAgICB2YXIgZHcgPSB2LncgLSB0aGlzLncgfHwgMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeiArIGR3ICogZHc7XHJcbiAgICB9LFxyXG5cclxuICAgIG5lZ2F0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSAtdGhpcy54O1xyXG4gICAgICAgIHRoaXMueSA9IC10aGlzLnk7XHJcbiAgICAgICAgdGhpcy56ID0gLXRoaXMuejtcclxuICAgICAgICB0aGlzLncgPSAtdGhpcy53O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNmb3JtTWF0NDogZnVuY3Rpb24gKG1hdClcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuICAgICAgICB2YXIgeiA9IHRoaXMuejtcclxuICAgICAgICB2YXIgdyA9IHRoaXMudztcclxuICAgICAgICB2YXIgbSA9IG1hdC52YWw7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcclxuICAgICAgICB0aGlzLnkgPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XHJcbiAgICAgICAgdGhpcy56ID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcclxuICAgICAgICB0aGlzLncgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFRPRE86IGlzIHRoaXMgcmVhbGx5IHRoZSBzYW1lIGFzIFZlY3RvcjM/XHJcbiAgICAvLyAgQWxzbywgd2hhdCBhYm91dCB0aGlzOiBodHRwOi8vbW9sZWN1bGFybXVzaW5ncy53b3JkcHJlc3MuY29tLzIwMTMvMDUvMjQvYS1mYXN0ZXItcXVhdGVybmlvbi12ZWN0b3ItbXVsdGlwbGljYXRpb24vXHJcbiAgICB0cmFuc2Zvcm1RdWF0OiBmdW5jdGlvbiAocSlcclxuICAgIHtcclxuICAgICAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciB6ID0gdGhpcy56O1xyXG4gICAgICAgIHZhciBxeCA9IHEueDtcclxuICAgICAgICB2YXIgcXkgPSBxLnk7XHJcbiAgICAgICAgdmFyIHF6ID0gcS56O1xyXG4gICAgICAgIHZhciBxdyA9IHEudztcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcclxuICAgICAgICB2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XHJcbiAgICAgICAgdmFyIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xyXG4gICAgICAgIHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcclxuICAgICAgICB2YXIgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xyXG5cclxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XHJcbiAgICAgICAgdGhpcy54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcclxuICAgICAgICB0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xyXG4gICAgICAgIHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgdGhpcy56ID0gMDtcclxuICAgICAgICB0aGlzLncgPSAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuVmVjdG9yNC5wcm90b3R5cGUuc3ViID0gVmVjdG9yNC5wcm90b3R5cGUuc3VidHJhY3Q7XHJcblZlY3RvcjQucHJvdG90eXBlLm11bCA9IFZlY3RvcjQucHJvdG90eXBlLm11bHRpcGx5O1xyXG5WZWN0b3I0LnByb3RvdHlwZS5kaXYgPSBWZWN0b3I0LnByb3RvdHlwZS5kaXZpZGU7XHJcblZlY3RvcjQucHJvdG90eXBlLmRpc3QgPSBWZWN0b3I0LnByb3RvdHlwZS5kaXN0YW5jZTtcclxuVmVjdG9yNC5wcm90b3R5cGUuZGlzdFNxID0gVmVjdG9yNC5wcm90b3R5cGUuZGlzdGFuY2VTcTtcclxuVmVjdG9yNC5wcm90b3R5cGUubGVuID0gVmVjdG9yNC5wcm90b3R5cGUubGVuZ3RoO1xyXG5WZWN0b3I0LnByb3RvdHlwZS5sZW5TcSA9IFZlY3RvcjQucHJvdG90eXBlLmxlbmd0aFNxO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3I0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvVmVjdG9yNC5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdyYXAgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4KVxyXG57XHJcbiAgICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XHJcblxyXG4gICAgcmV0dXJuIChtaW4gKyAoKCgodmFsdWUgLSBtaW4pICUgcmFuZ2UpICsgcmFuZ2UpICUgcmFuZ2UpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV3JhcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL1dyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXN0YW5jZUJldHdlZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbntcclxuICAgIHZhciBkeCA9IHgxIC0geDI7XHJcbiAgICB2YXIgZHkgPSB5MSAtIHkyO1xyXG5cclxuICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZUJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZUJldHdlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBCYXNlZCBvbiB0aGUgdGhyZWUuanMgQ3VydmUgY2xhc3NlcyBjcmVhdGVkIGJ5IFt6ejg1XShodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nKVxyXG5cclxudmFyIENsYW1wID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9DbGFtcCcpO1xyXG52YXIgVmVjdG9yMiA9IHJlcXVpcmUoJy4uLy4uL21hdGgvVmVjdG9yMicpO1xyXG52YXIgVmVjdG9yMyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvVmVjdG9yMycpO1xyXG52YXIgTWF0cml4NCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvTWF0cml4NCcpO1xyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxuLy8gIExvY2FsIGNhY2hlIHZhcnNcclxuXHJcbnZhciB0bXBWZWMyQSA9IG5ldyBWZWN0b3IyKCk7XHJcbnZhciB0bXBWZWMyQiA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG4vLyAgT3VyIEJhc2UgQ3VydmUgd2hpY2ggYWxsIG90aGVyIGN1cnZlcyBleHRlbmRcclxuXHJcbnZhciBDdXJ2ZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBDdXJ2ZSAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdERpdmlzaW9ucyA9IDU7XHJcblxyXG4gICAgICAgIHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gMTAwO1xyXG5cclxuICAgICAgICB0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXHJcbiAgICAvLyAtIHUgWzAgLi4gMV1cclxuXHJcbiAgICBnZXRQb2ludEF0OiBmdW5jdGlvbiAodSwgb3V0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyh1KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnQodCwgb3V0KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXHJcblxyXG4gICAgZ2V0UG9pbnRzOiBmdW5jdGlvbiAoZGl2aXNpb25zKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgeyBkaXZpc2lvbnMgPSB0aGlzLmRlZmF1bHREaXZpc2lvbnM7IH1cclxuXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoaXMuZ2V0UG9pbnQoZCAvIGRpdmlzaW9ucykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBvaW50cztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcclxuXHJcbiAgICBnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uIChkaXZpc2lvbnMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSB7IGRpdmlzaW9ucyA9IHRoaXMuZGVmYXVsdERpdmlzaW9uczsgfVxyXG5cclxuICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKGQgLyBkaXZpc2lvbnMsIG51bGwsIGRpdmlzaW9ucyk7XHJcblxyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLmdldFBvaW50KHQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXHJcblxyXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBsZW5ndGhzW2xlbmd0aHMubGVuZ3RoIC0gMV07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXHJcblxyXG4gICAgZ2V0TGVuZ3RoczogZnVuY3Rpb24gKGRpdmlzaW9ucylcclxuICAgIHtcclxuICAgICAgICBpZiAoZGl2aXNpb25zID09PSB1bmRlZmluZWQpIHsgZGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM7IH1cclxuXHJcbiAgICAgICAgaWYgKCh0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEpICYmICF0aGlzLm5lZWRzVXBkYXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgY2FjaGUgPSBbXTtcclxuICAgICAgICB2YXIgY3VycmVudDtcclxuICAgICAgICB2YXIgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoMCwgdG1wVmVjMkEpO1xyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG5cclxuICAgICAgICBjYWNoZS5wdXNoKDApO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHArKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldFBvaW50KHAgLyBkaXZpc2lvbnMsIHRtcFZlYzJCKTtcclxuXHJcbiAgICAgICAgICAgIHN1bSArPSBjdXJyZW50LmRpc3RhbmNlKGxhc3QpO1xyXG5cclxuICAgICAgICAgICAgY2FjaGUucHVzaChzdW0pO1xyXG5cclxuICAgICAgICAgICAgbGFzdC5jb3B5KGN1cnJlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06c3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmdldExlbmd0aHMoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEdpdmVuIGEgZGlzdGFuY2UgaW4gcGl4ZWxzLCBnZXQgYSB0IHRvIGZpbmQgcC5cclxuICAgIGdldFRGcm9tRGlzdGFuY2U6IGZ1bmN0aW9uIChkaXN0YW5jZSwgZGl2aXNpb25zKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFV0b1RtYXBwaW5nKDAsIGRpc3RhbmNlLCBkaXZpc2lvbnMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XHJcblxyXG4gICAgZ2V0VXRvVG1hcHBpbmc6IGZ1bmN0aW9uICh1LCBkaXN0YW5jZSwgZGl2aXNpb25zKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKGRpdmlzaW9ucyk7XHJcblxyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB2YXIgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgdmFyIHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XHJcblxyXG4gICAgICAgIGlmIChkaXN0YW5jZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBDYW5ub3Qgb3ZlcnNob290IHRoZSBjdXJ2ZVxyXG4gICAgICAgICAgICB0YXJnZXRBcmNMZW5ndGggPSBNYXRoLm1pbihkaXN0YW5jZSwgYXJjTGVuZ3Roc1tpbCAtIDFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbaWwgLSAxXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXHJcblxyXG4gICAgICAgIHZhciBsb3cgPSAwO1xyXG4gICAgICAgIHZhciBoaWdoID0gaWwgLSAxO1xyXG4gICAgICAgIHZhciBjb21wYXJpc29uO1xyXG5cclxuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpID0gTWF0aC5mbG9vcihsb3cgKyAoaGlnaCAtIGxvdykgLyAyKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xyXG5cclxuICAgICAgICAgICAgY29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbaV0gLSB0YXJnZXRBcmNMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29tcGFyaXNvbiA8IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxvdyA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBhcmlzb24gPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBoaWdoID0gaSAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBoaWdoID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpID0gaGlnaDtcclxuXHJcbiAgICAgICAgaWYgKGFyY0xlbmd0aHNbaV0gPT09IHRhcmdldEFyY0xlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpIC8gKGlsIC0gMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xyXG5cclxuICAgICAgICB2YXIgbGVuZ3RoQmVmb3JlID0gYXJjTGVuZ3Roc1tpXTtcclxuICAgICAgICB2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzW2kgKyAxXTtcclxuXHJcbiAgICAgICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTtcclxuXHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcclxuXHJcbiAgICAgICAgdmFyIHNlZ21lbnRGcmFjdGlvbiA9ICh0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUpIC8gc2VnbWVudExlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxyXG5cclxuICAgICAgICByZXR1cm4gKGkgKyBzZWdtZW50RnJhY3Rpb24pIC8gKGlsIC0gMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcclxuICAgIC8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcclxuICAgIC8vIDIgcG9pbnRzIGEgc21hbGwgZGVsdGEgYXBhcnQgd2lsbCBiZSB1c2VkIHRvIGZpbmQgaXRzIGdyYWRpZW50XHJcbiAgICAvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXHJcblxyXG4gICAgZ2V0VGFuZ2VudDogZnVuY3Rpb24gKHQsIG91dClcclxuICAgIHtcclxuICAgICAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFZlY3RvcjIoKTsgfVxyXG5cclxuICAgICAgICB2YXIgZGVsdGEgPSAwLjAwMDE7XHJcbiAgICAgICAgdmFyIHQxID0gdCAtIGRlbHRhO1xyXG4gICAgICAgIHZhciB0MiA9IHQgKyBkZWx0YTtcclxuXHJcbiAgICAgICAgLy8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxyXG5cclxuICAgICAgICBpZiAodDEgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdDEgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHQyID4gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHQyID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0UG9pbnQodDEsIHRtcFZlYzJBKTtcclxuICAgICAgICB0aGlzLmdldFBvaW50KHQyLCBvdXQpO1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0LnN1Yih0bXBWZWMyQSkubm9ybWFsaXplKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRhbmdlbnRBdDogZnVuY3Rpb24gKHUsIG91dClcclxuICAgIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcodSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRhbmdlbnQodCwgb3V0KTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDdXJ2ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYXRocy9jdXJ2ZXMvQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvbGxpc2lvbiBUeXBlcyAtIERldGVybWluZSBpZiBhbmQgaG93IGVudGl0aWVzIGNvbGxpZGUgd2l0aCBlYWNoIG90aGVyXHJcblxyXG4vLyBJbiBBQ1RJVkUgdnMuIExJVEUgb3IgRklYRUQgdnMuIEFOWSBjb2xsaXNpb25zLCBvbmx5IHRoZSBcIndlYWtcIiBlbnRpdHkgbW92ZXMsXHJcbi8vIHdoaWxlIHRoZSBvdGhlciBvbmUgc3RheXMgZml4ZWQuIEluIEFDVElWRSB2cy4gQUNUSVZFIGFuZCBBQ1RJVkUgdnMuIFBBU1NJVkVcclxuLy8gY29sbGlzaW9ucywgYm90aCBlbnRpdGllcyBhcmUgbW92ZWQuIExJVEUgb3IgUEFTU0lWRSBlbnRpdGllcyBkb24ndCBjb2xsaWRlXHJcbi8vIHdpdGggb3RoZXIgTElURSBvciBQQVNTSVZFIGVudGl0aWVzIGF0IGFsbC4gVGhlIGJlaGFpdmlvdXIgZm9yIEZJWEVEIHZzLlxyXG4vLyBGSVhFRCBjb2xsaXNpb25zIGlzIHVuZGVmaW5lZC5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE5FVkVSOiAwLFxyXG4gICAgTElURTogMSxcclxuICAgIFBBU1NJVkU6IDIsXHJcbiAgICBBQ1RJVkU6IDQsXHJcbiAgICBGSVhFRDogOFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9DT0xMSURFUy5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29sbGlzaW9uIFR5cGVzIC0gRGV0ZXJtaW5lIGlmIGFuZCBob3cgZW50aXRpZXMgY29sbGlkZSB3aXRoIGVhY2ggb3RoZXJcclxuXHJcbi8vIEluIEFDVElWRSB2cy4gTElURSBvciBGSVhFRCB2cy4gQU5ZIGNvbGxpc2lvbnMsIG9ubHkgdGhlIFwid2Vha1wiIGVudGl0eSBtb3ZlcyxcclxuLy8gd2hpbGUgdGhlIG90aGVyIG9uZSBzdGF5cyBmaXhlZC4gSW4gQUNUSVZFIHZzLiBBQ1RJVkUgYW5kIEFDVElWRSB2cy4gUEFTU0lWRVxyXG4vLyBjb2xsaXNpb25zLCBib3RoIGVudGl0aWVzIGFyZSBtb3ZlZC4gTElURSBvciBQQVNTSVZFIGVudGl0aWVzIGRvbid0IGNvbGxpZGVcclxuLy8gd2l0aCBvdGhlciBMSVRFIG9yIFBBU1NJVkUgZW50aXRpZXMgYXQgYWxsLiBUaGUgYmVoYXZpb3IgZm9yIEZJWEVEIHZzLlxyXG4vLyBGSVhFRCBjb2xsaXNpb25zIGlzIHVuZGVmaW5lZC5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE5PTkU6IDAsXHJcbiAgICBBOiAxLFxyXG4gICAgQjogMixcclxuICAgIEJPVEg6IDNcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvVFlQRS5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFNoYWxsb3cgT2JqZWN0IENsb25lLiBXaWxsIG5vdCBjbG9uZSBuZXN0ZWQgb2JqZWN0cy5cclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChvYmopXHJcbntcclxuICAgIHZhciBjbG9uZSA9IHt9O1xyXG5cclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2xvbmVba2V5XSA9IG9ialtrZXldLnNsaWNlKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbG9uZVtrZXldID0gb2JqW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbG9uZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvb2JqZWN0L0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vSXNQbGFpbk9iamVjdCcpO1xyXG5cclxuLyoqXHJcbiogVGhpcyBpcyBhIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5leHRlbmQvXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuVXRpbHMuZXh0ZW5kXHJcbiogQHBhcmFtIHtib29sZWFufSBkZWVwIC0gUGVyZm9ybSBhIGRlZXAgY29weT9cclxuKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgdG8gY29weSB0by5cclxuKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBleHRlbmRlZCBvYmplY3QuXHJcbiovXHJcbnZhciBFeHRlbmQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXHJcbiAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXHJcbiAgICAgICAgZGVlcCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cclxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIilcclxuICAgIHtcclxuICAgICAgICBkZWVwID0gdGFyZ2V0O1xyXG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcclxuICAgICAgICAvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgaSA9IDI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXh0ZW5kIFBoYXNlciBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcclxuICAgIGlmIChsZW5ndGggPT09IGkpXHJcbiAgICB7XHJcbiAgICAgICAgdGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAtLWk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXHJcbiAgICAgICAgaWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxyXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbbmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gY29weSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcclxuICAgICAgICAgICAgICAgIGlmIChkZWVwICYmIGNvcHkgJiYgKElzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjb3B5KSkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3B5SXNBcnJheSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBJc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IEV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9vYmplY3QvRXh0ZW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi4vLi4vZ2VvbS9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XHJcbnZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xyXG52YXIgVmFsdWVUb0NvbG9yID0gcmVxdWlyZSgnLi4vLi4vZ3JhcGhpY3MvY29sb3IvVmFsdWVUb0NvbG9yJyk7XHJcblxyXG52YXIgQ2FtZXJhID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIENhbWVyYSAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNjZW5lO1xyXG5cclxuICAgICAgICB0aGlzLm5hbWUgPSAnJztcclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy5yb3VuZFBpeGVscyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyAgQm91bmRzXHJcbiAgICAgICAgdGhpcy51c2VCb3VuZHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9ib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5wdXRFbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5zY3JvbGxYID0gMC4wO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsWSA9IDAuMDtcclxuICAgICAgICB0aGlzLnpvb20gPSAxLjA7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDAuMDtcclxuICAgICAgICB0aGlzLm1hdHJpeCA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoMSwgMCwgMCwgMSwgMCwgMCk7XHJcblxyXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gVmFsdWVUb0NvbG9yKCdyZ2JhKDAsMCwwLDApJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzYWJsZUN1bGwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmN1bGxlZE9iamVjdHMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gIFNoYWtlXHJcbiAgICAgICAgdGhpcy5fc2hha2VEdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fc2hha2VJbnRlbnNpdHkgPSAwO1xyXG4gICAgICAgIHRoaXMuX3NoYWtlT2Zmc2V0WCA9IDA7XHJcbiAgICAgICAgdGhpcy5fc2hha2VPZmZzZXRZID0gMDtcclxuXHJcbiAgICAgICAgLy8gIEZhZGVcclxuICAgICAgICB0aGlzLl9mYWRlRHVyYXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMuX2ZhZGVSZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2ZhZGVHcmVlbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fZmFkZUJsdWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2ZhZGVBbHBoYSA9IDA7XHJcblxyXG4gICAgICAgIC8vICBGbGFzaFxyXG4gICAgICAgIHRoaXMuX2ZsYXNoRHVyYXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMuX2ZsYXNoUmVkID0gMTtcclxuICAgICAgICB0aGlzLl9mbGFzaEdyZWVuID0gMTtcclxuICAgICAgICB0aGlzLl9mbGFzaEJsdWUgPSAxO1xyXG4gICAgICAgIHRoaXMuX2ZsYXNoQWxwaGEgPSAwO1xyXG5cclxuICAgICAgICAvLyAgRm9sbG93XHJcbiAgICAgICAgdGhpcy5fZm9sbG93ID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5faWQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICBjYW1lcmFUb1NjcmVlbjogcmVxdWlyZSgnLi9pbmMvQ2FtZXJhVG9TY3JlZW4nKSxcclxuICAgIGNlbnRlclRvQm91bmRzOiByZXF1aXJlKCcuL2luYy9DZW50ZXJUb0JvdW5kcycpLFxyXG4gICAgY2VudGVyVG9TaXplOiByZXF1aXJlKCcuL2luYy9DZW50ZXJUb1NpemUnKSxcclxuICAgIGN1bGw6IHJlcXVpcmUoJy4vaW5jL0N1bGwnKSxcclxuICAgIGN1bGxIaXRUZXN0OiByZXF1aXJlKCcuL2luYy9DdWxsSGl0VGVzdCcpLFxyXG4gICAgY3VsbFRpbGVtYXA6IHJlcXVpcmUoJy4vaW5jL0N1bGxUaWxlbWFwJyksXHJcbiAgICBkZXN0cm95OiByZXF1aXJlKCcuL2luYy9EZXN0cm95JyksXHJcbiAgICBmYWRlOiByZXF1aXJlKCcuL2luYy9GYWRlJyksXHJcbiAgICBmbGFzaDogcmVxdWlyZSgnLi9pbmMvRmxhc2gnKSxcclxuICAgIGlnbm9yZTogcmVxdWlyZSgnLi9pbmMvSWdub3JlJyksXHJcbiAgICBwcmVSZW5kZXI6IHJlcXVpcmUoJy4vaW5jL1ByZVJlbmRlcicpLFxyXG4gICAgcmVtb3ZlQm91bmRzOiByZXF1aXJlKCcuL2luYy9SZW1vdmVCb3VuZHMnKSxcclxuICAgIHNldEJhY2tncm91bmRDb2xvcjogcmVxdWlyZSgnLi9pbmMvU2V0QmFja2dyb3VuZENvbG9yJyksXHJcbiAgICBzZXRCb3VuZHM6IHJlcXVpcmUoJy4vaW5jL1NldEJvdW5kcycpLFxyXG4gICAgc2V0TmFtZTogcmVxdWlyZSgnLi9pbmMvU2V0TmFtZScpLFxyXG4gICAgc2V0UG9zaXRpb246IHJlcXVpcmUoJy4vaW5jL1NldFBvc2l0aW9uJyksXHJcbiAgICBzZXRSb3RhdGlvbjogcmVxdWlyZSgnLi9pbmMvU2V0Um90YXRpb24nKSxcclxuICAgIHNldFJvdW5kUGl4ZWxzOiByZXF1aXJlKCcuL2luYy9TZXRSb3VuZFBpeGVscycpLFxyXG4gICAgc2V0U2NlbmU6IHJlcXVpcmUoJy4vaW5jL1NldFNjZW5lJyksXHJcbiAgICBzZXRTY3JvbGw6IHJlcXVpcmUoJy4vaW5jL1NldFNjcm9sbCcpLFxyXG4gICAgc2V0U2l6ZTogcmVxdWlyZSgnLi9pbmMvU2V0U2l6ZScpLFxyXG4gICAgc2V0Vmlld3BvcnQ6IHJlcXVpcmUoJy4vaW5jL1NldFZpZXdwb3J0JyksXHJcbiAgICBzZXRab29tOiByZXF1aXJlKCcuL2luYy9TZXRab29tJyksXHJcbiAgICBzaGFrZTogcmVxdWlyZSgnLi9pbmMvU2hha2UnKSxcclxuICAgIHN0YXJ0Rm9sbG93OiByZXF1aXJlKCcuL2luYy9TdGFydEZvbGxvdycpLFxyXG4gICAgc3RvcEZvbGxvdzogcmVxdWlyZSgnLi9pbmMvU3RvcEZvbGxvdycpLFxyXG4gICAgdG9KU09OOiByZXF1aXJlKCcuL2luYy9Ub0pTT04nKSxcclxuICAgIHVwZGF0ZTogcmVxdWlyZSgnLi9pbmMvVXBkYXRlJylcclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYW1lcmE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL0NhbWVyYS5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhbnZhc0ludGVycG9sYXRpb24gPSB7XHJcblxyXG4gICAgLy8gIFNldHMgdGhlIENTUyBpbWFnZS1yZW5kZXJpbmcgcHJvcGVydHkgb24gdGhlIGdpdmVuIGNhbnZhcyB0byBiZSAnY3Jpc3AnIChha2EgJ29wdGltaXplIGNvbnRyYXN0JyBvbiB3ZWJraXQpLlxyXG4gICAgLy8gIE5vdGUgdGhhdCBpZiB0aGlzIGRvZXNuJ3QgZ2l2ZW4gdGhlIGRlc2lyZWQgcmVzdWx0IHRoZW4gc2VlIHRoZSBzZXRTbW9vdGhpbmdFbmFibGVkLlxyXG4gICAgc2V0Q3Jpc3A6IGZ1bmN0aW9uIChjYW52YXMpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHR5cGVzID0gWyAnb3B0aW1pemVTcGVlZCcsICdjcmlzcC1lZGdlcycsICctbW96LWNyaXNwLWVkZ2VzJywgJy13ZWJraXQtb3B0aW1pemUtY29udHJhc3QnLCAnb3B0aW1pemUtY29udHJhc3QnLCAncGl4ZWxhdGVkJyBdO1xyXG5cclxuICAgICAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FudmFzLnN0eWxlWydpbWFnZS1yZW5kZXJpbmcnXSA9IHR5cGU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNhbnZhcy5zdHlsZS5tc0ludGVycG9sYXRpb25Nb2RlID0gJ25lYXJlc3QtbmVpZ2hib3InO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU2V0cyB0aGUgQ1NTIGltYWdlLXJlbmRlcmluZyBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gY2FudmFzIHRvIGJlICdiaWN1YmljJyAoYWthICdhdXRvJykuXHJcbiAgICAvLyAgTm90ZSB0aGF0IGlmIHRoaXMgZG9lc24ndCBnaXZlbiB0aGUgZGVzaXJlZCByZXN1bHQgdGhlbiBzZWUgdGhlIENhbnZhc1V0aWxzLnNldFNtb290aGluZ0VuYWJsZWQgbWV0aG9kLlxyXG4gICAgc2V0QmljdWJpYzogZnVuY3Rpb24gKGNhbnZhcylcclxuICAgIHtcclxuICAgICAgICBjYW52YXMuc3R5bGVbJ2ltYWdlLXJlbmRlcmluZyddID0gJ2F1dG8nO1xyXG4gICAgICAgIGNhbnZhcy5zdHlsZS5tc0ludGVycG9sYXRpb25Nb2RlID0gJ2JpY3ViaWMnO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzSW50ZXJwb2xhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vQ2FudmFzSW50ZXJwb2xhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbi8vICBCcm93c2VyIHNwZWNpZmljIHByZWZpeCwgc28gbm90IGdvaW5nIHRvIGNoYW5nZSBiZXR3ZWVuIGNvbnRleHRzLCBvbmx5IGJldHdlZW4gYnJvd3NlcnNcclxudmFyIHByZWZpeCA9ICcnO1xyXG5cclxudmFyIFNtb290aGluZyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIC8vIEdldHMgdGhlIFNtb290aGluZyBFbmFibGVkIHZlbmRvciBwcmVmaXggYmVpbmcgdXNlZCBvbiB0aGUgZ2l2ZW4gY29udGV4dCwgb3IgbnVsbCBpZiBub3Qgc2V0LlxyXG4gICAgdmFyIGdldFByZWZpeCA9IGZ1bmN0aW9uIChjb250ZXh0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB2ZW5kb3JzID0gWyAnaScsICd3ZWJraXRJJywgJ21zSScsICdtb3pJJywgJ29JJyBdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcyA9IHZlbmRvcnNbaV0gKyAnbWFnZVNtb290aGluZ0VuYWJsZWQnO1xyXG5cclxuICAgICAgICAgICAgaWYgKHMgaW4gY29udGV4dClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0cyB0aGUgSW1hZ2UgU21vb3RoaW5nIHByb3BlcnR5IG9uIHRoZSBnaXZlbiBjb250ZXh0LiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBpbWFnZSBzbW9vdGhpbmcuXHJcbiAgICAqIEJ5IGRlZmF1bHQgYnJvd3NlcnMgaGF2ZSBpbWFnZSBzbW9vdGhpbmcgZW5hYmxlZCwgd2hpY2ggaXNuJ3QgYWx3YXlzIHdoYXQgeW91IHZpc3VhbGx5IHdhbnQsIGVzcGVjaWFsbHlcclxuICAgICogd2hlbiB1c2luZyBwaXhlbCBhcnQgaW4gYSBnYW1lLiBOb3RlIHRoYXQgdGhpcyBzZXRzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgY29udGV4dCBpdHNlbGYsIHNvIHRoYXQgYW55IGltYWdlXHJcbiAgICAqIGRyYXduIHRvIHRoZSBjb250ZXh0IHdpbGwgYmUgYWZmZWN0ZWQuIFRoaXMgc2V0cyB0aGUgcHJvcGVydHkgYWNyb3NzIGFsbCBjdXJyZW50IGJyb3dzZXJzIGJ1dCBzdXBwb3J0IGlzXHJcbiAgICAqIHBhdGNoeSBvbiBlYXJsaWVyIGJyb3dzZXJzLCBlc3BlY2lhbGx5IG9uIG1vYmlsZS5cclxuICAgICovXHJcbiAgICB2YXIgZW5hYmxlID0gZnVuY3Rpb24gKGNvbnRleHQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJycpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwcmVmaXggPSBnZXRQcmVmaXgoY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJlZml4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGV4dFtwcmVmaXhdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0cyB0aGUgSW1hZ2UgU21vb3RoaW5nIHByb3BlcnR5IG9uIHRoZSBnaXZlbiBjb250ZXh0LiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBpbWFnZSBzbW9vdGhpbmcuXHJcbiAgICAqIEJ5IGRlZmF1bHQgYnJvd3NlcnMgaGF2ZSBpbWFnZSBzbW9vdGhpbmcgZW5hYmxlZCwgd2hpY2ggaXNuJ3QgYWx3YXlzIHdoYXQgeW91IHZpc3VhbGx5IHdhbnQsIGVzcGVjaWFsbHlcclxuICAgICogd2hlbiB1c2luZyBwaXhlbCBhcnQgaW4gYSBnYW1lLiBOb3RlIHRoYXQgdGhpcyBzZXRzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgY29udGV4dCBpdHNlbGYsIHNvIHRoYXQgYW55IGltYWdlXHJcbiAgICAqIGRyYXduIHRvIHRoZSBjb250ZXh0IHdpbGwgYmUgYWZmZWN0ZWQuIFRoaXMgc2V0cyB0aGUgcHJvcGVydHkgYWNyb3NzIGFsbCBjdXJyZW50IGJyb3dzZXJzIGJ1dCBzdXBwb3J0IGlzXHJcbiAgICAqIHBhdGNoeSBvbiBlYXJsaWVyIGJyb3dzZXJzLCBlc3BlY2lhbGx5IG9uIG1vYmlsZS5cclxuICAgICovXHJcbiAgICB2YXIgZGlzYWJsZSA9IGZ1bmN0aW9uIChjb250ZXh0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChwcmVmaXggPT09ICcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByZWZpeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRleHRbcHJlZml4XSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGNvbnRleHQgaGFzIGltYWdlIHNtb290aGluZyBlbmFibGVkLCBvdGhlcndpc2UgcmV0dXJucyBgZmFsc2VgLlxyXG4gICAgICogUmV0dXJucyBudWxsIGlmIG5vIHNtb290aGluZyBwcmVmaXggaXMgYXZhaWxhYmxlLlxyXG4gICAgICovXHJcbiAgICB2YXIgaXNFbmFibGVkID0gZnVuY3Rpb24gKGNvbnRleHQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIChwcmVmaXggIT09IG51bGwpID8gY29udGV4dFtwcmVmaXhdIDogbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkaXNhYmxlOiBkaXNhYmxlLFxyXG4gICAgICAgIGVuYWJsZTogZW5hYmxlLFxyXG4gICAgICAgIGdldFByZWZpeDogZ2V0UHJlZml4LFxyXG4gICAgICAgIGlzRW5hYmxlZDogaXNFbmFibGVkXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbW9vdGhpbmcoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vU21vb3RoaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL0dhbWVPYmplY3QnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzJyk7XHJcbnZhciBSZW5kZXIgPSByZXF1aXJlKCcuL0R5bmFtaWNCaXRtYXBUZXh0UmVuZGVyJyk7XHJcbnZhciBHZXRCaXRtYXBUZXh0U2l6ZSA9IHJlcXVpcmUoJy4uL0dldEJpdG1hcFRleHRTaXplJyk7XHJcblxyXG52YXIgRHluYW1pY0JpdG1hcFRleHQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlRleHR1cmUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UaW50LFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBDb21wb25lbnRzLlNjcm9sbEZhY3RvcixcclxuICAgICAgICBSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBEeW5hbWljQml0bWFwVGV4dCAoc2NlbmUsIHgsIHksIGZvbnQsIHRleHQsIHNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkgeyB0ZXh0ID0gJyc7IH1cclxuXHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHNjZW5lLCAnRHluYW1pY0JpdG1hcFRleHQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5mb250ID0gZm9udDtcclxuXHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5zY2VuZS5zeXMuY2FjaGUuYml0bWFwRm9udC5nZXQoZm9udCk7XHJcblxyXG4gICAgICAgIHRoaXMuZm9udERhdGEgPSBlbnRyeS5kYXRhO1xyXG5cclxuICAgICAgICB0aGlzLnRleHQgPSAoQXJyYXkuaXNBcnJheSh0ZXh0KSkgPyB0ZXh0LmpvaW4oJ1xcbicpIDogdGV4dDtcclxuXHJcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IHNpemUgfHwgdGhpcy5mb250RGF0YS5zaXplO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRleHR1cmUoZW50cnkudGV4dHVyZSwgZW50cnkuZnJhbWUpO1xyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5zZXRPcmlnaW4oMCwgMCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IHRoaXMuZ2V0VGV4dEJvdW5kcygpO1xyXG5cclxuICAgICAgICB0aGlzLnNjcm9sbFggPSAwO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsWSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuY3JvcFdpZHRoID0gMDtcclxuICAgICAgICB0aGlzLmNyb3BIZWlnaHQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmRpc3BsYXlDYWxsYmFjaztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jcm9wV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmNyb3BIZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXREaXNwbGF5Q2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRpc3BsYXlDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Rm9udFNpemU6IGZ1bmN0aW9uIChzaXplKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBzaXplO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dDogZnVuY3Rpb24gKHRleHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjcm9sbFg6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFggPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjcm9sbFk6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFkgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHtcclxuICAgIC8vICAgICBsb2NhbDoge1xyXG4gICAgLy8gICAgICAgICB4LFxyXG4gICAgLy8gICAgICAgICB5LFxyXG4gICAgLy8gICAgICAgICB3aWR0aCxcclxuICAgIC8vICAgICAgICAgaGVpZ2h0XHJcbiAgICAvLyAgICAgfSxcclxuICAgIC8vICAgICBnbG9iYWw6IHtcclxuICAgIC8vICAgICAgICAgeCxcclxuICAgIC8vICAgICAgICAgeSxcclxuICAgIC8vICAgICAgICAgd2lkdGgsXHJcbiAgICAvLyAgICAgICAgIGhlaWdodFxyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxuXHJcbiAgICBnZXRUZXh0Qm91bmRzOiBmdW5jdGlvbiAocm91bmQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIGxvY2FsID0gdGhlIEJpdG1hcFRleHQgYmFzZWQgb24gZm9udFNpemUgYW5kIDB4MCBjb29yZHNcclxuICAgICAgICAvLyAgZ2xvYmFsID0gdGhlIEJpdG1hcFRleHQsIHRha2luZyBpbnRvIGFjY291bnQgc2NhbGUgYW5kIHdvcmxkIHBvc2l0aW9uXHJcblxyXG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IEdldEJpdG1hcFRleHRTaXplKHRoaXMsIHJvdW5kKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcclxuICAgIH0sXHJcblxyXG4gICAgd2lkdGg6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRUZXh0Qm91bmRzKGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5nbG9iYWwud2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaGVpZ2h0OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VGV4dEJvdW5kcyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMuZ2xvYmFsLmhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG91dCA9IENvbXBvbmVudHMuVG9KU09OKHRoaXMpO1xyXG5cclxuICAgICAgICAvLyAgRXh0cmEgZGF0YSBpcyBhZGRlZCBoZXJlXHJcblxyXG4gICAgICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgICAgICBmb250OiB0aGlzLmZvbnQsXHJcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcclxuICAgICAgICAgICAgZm9udFNpemU6IHRoaXMuZm9udFNpemVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBvdXQuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHluYW1pY0JpdG1hcFRleHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBHZXRCaXRtYXBUZXh0U2l6ZSA9IHJlcXVpcmUoJy4uL0dldEJpdG1hcFRleHRTaXplJyk7XHJcbnZhciBQYXJzZUZyb21BdGxhcyA9IHJlcXVpcmUoJy4uL1BhcnNlRnJvbUF0bGFzJyk7XHJcbnZhciBQYXJzZVJldHJvRm9udCA9IHJlcXVpcmUoJy4uL1BhcnNlUmV0cm9Gb250Jyk7XHJcbnZhciBSZW5kZXIgPSByZXF1aXJlKCcuL0JpdG1hcFRleHRSZW5kZXInKTtcclxuXHJcbnZhciBCaXRtYXBUZXh0ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBHYW1lT2JqZWN0LFxyXG5cclxuICAgIE1peGluczogW1xyXG4gICAgICAgIENvbXBvbmVudHMuQWxwaGEsXHJcbiAgICAgICAgQ29tcG9uZW50cy5CbGVuZE1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXHJcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJUYXJnZXQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxyXG4gICAgICAgIENvbXBvbmVudHMuVGludCxcclxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcclxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQml0bWFwVGV4dCAoc2NlbmUsIHgsIHksIGZvbnQsIHRleHQsIHNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkgeyB0ZXh0ID0gJyc7IH1cclxuXHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHNjZW5lLCAnQml0bWFwVGV4dCcpO1xyXG5cclxuICAgICAgICB0aGlzLmZvbnQgPSBmb250O1xyXG5cclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnNjZW5lLnN5cy5jYWNoZS5iaXRtYXBGb250LmdldChmb250KTtcclxuXHJcbiAgICAgICAgdGhpcy5mb250RGF0YSA9IGVudHJ5LmRhdGE7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dCA9IChBcnJheS5pc0FycmF5KHRleHQpKSA/IHRleHQuam9pbignXFxuJykgOiB0ZXh0O1xyXG5cclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gc2l6ZSB8fCB0aGlzLmZvbnREYXRhLnNpemU7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZShlbnRyeS50ZXh0dXJlLCBlbnRyeS5mcmFtZSk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigwLCAwKTtcclxuXHJcbiAgICAgICAgdGhpcy5fYm91bmRzID0gdGhpcy5nZXRUZXh0Qm91bmRzKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZvbnRTaXplOiBmdW5jdGlvbiAoc2l6ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gc2l6ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHQ6IGZ1bmN0aW9uICh0ZXh0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyB7XHJcbiAgICAvLyAgICAgbG9jYWw6IHtcclxuICAgIC8vICAgICAgICAgeCxcclxuICAgIC8vICAgICAgICAgeSxcclxuICAgIC8vICAgICAgICAgd2lkdGgsXHJcbiAgICAvLyAgICAgICAgIGhlaWdodFxyXG4gICAgLy8gICAgIH0sXHJcbiAgICAvLyAgICAgZ2xvYmFsOiB7XHJcbiAgICAvLyAgICAgICAgIHgsXHJcbiAgICAvLyAgICAgICAgIHksXHJcbiAgICAvLyAgICAgICAgIHdpZHRoLFxyXG4gICAgLy8gICAgICAgICBoZWlnaHRcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgZ2V0VGV4dEJvdW5kczogZnVuY3Rpb24gKHJvdW5kKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBsb2NhbCA9IHRoZSBCaXRtYXBUZXh0IGJhc2VkIG9uIGZvbnRTaXplIGFuZCAweDAgY29vcmRzXHJcbiAgICAgICAgLy8gIGdsb2JhbCA9IHRoZSBCaXRtYXBUZXh0LCB0YWtpbmcgaW50byBhY2NvdW50IHNjYWxlIGFuZCB3b3JsZCBwb3NpdGlvblxyXG5cclxuICAgICAgICB0aGlzLl9ib3VuZHMgPSBHZXRCaXRtYXBUZXh0U2l6ZSh0aGlzLCByb3VuZCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgICB9LFxyXG5cclxuICAgIHdpZHRoOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VGV4dEJvdW5kcyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMuZ2xvYmFsLndpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGhlaWdodDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmdldFRleHRCb3VuZHMoZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzLmdsb2JhbC5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXQgPSBDb21wb25lbnRzLlRvSlNPTih0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gIEV4dHJhIGRhdGEgaXMgYWRkZWQgaGVyZVxyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICAgICAgZm9udDogdGhpcy5mb250LFxyXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgb3V0LmRhdGEgPSBkYXRhO1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5CaXRtYXBUZXh0LlBhcnNlUmV0cm9Gb250ID0gUGFyc2VSZXRyb0ZvbnQ7XHJcbkJpdG1hcFRleHQuUGFyc2VGcm9tQXRsYXMgPSBQYXJzZUZyb21BdGxhcztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQml0bWFwVGV4dDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmxpdHRlclJlbmRlciA9IHJlcXVpcmUoJy4vQmxpdHRlclJlbmRlcicpO1xyXG52YXIgQm9iID0gcmVxdWlyZSgnLi9Cb2InKTtcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzJyk7XHJcbnZhciBEaXNwbGF5TGlzdCA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvRGlzcGxheUxpc3QnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG4vKipcclxuKiBBIEJsaXR0ZXIgR2FtZSBPYmplY3QuXHJcbipcclxuKiBUaGUgQmxpdHRlciBHYW1lIE9iamVjdCBpcyBhIHNwZWNpYWwgdHlwZSBvZiBDb250YWluZXIsIHRoYXQgY29udGFpbnMgQmxpdHRlci5Cb2Igb2JqZWN0cy5cclxuKiBUaGVzZSBvYmplY3RzIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGp1c3QgdGV4dHVyZSBmcmFtZXMgd2l0aCBhIHBvc2l0aW9uIGFuZCBub3RoaW5nIG1vcmUuXHJcbiogQm9icyBkb24ndCBoYXZlIGFueSB1cGRhdGUgbWV0aG9kcywgb3IgdGhlIGFiaWxpdHkgdG8gaGF2ZSBjaGlsZHJlbiwgb3IgYW55IGtpbmQgb2Ygc3BlY2lhbCBlZmZlY3RzLlxyXG4qIFRoZXkgYXJlIGVzc2VudGlhbGx5IGp1c3Qgc3VwZXItZmFzdCB0ZXh0dXJlIGZyYW1lIHJlbmRlcmVycywgYW5kIHRoZSBCbGl0dGVyIG9iamVjdCBjcmVhdGVzIGFuZCBtYW5hZ2VzIHRoZW0uXHJcbiovXHJcblxyXG52YXIgQmxpdHRlciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuUmVuZGVyVGFyZ2V0LFxyXG4gICAgICAgIENvbXBvbmVudHMuU2NhbGVNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcclxuICAgICAgICBDb21wb25lbnRzLlRleHR1cmUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2Nyb2xsRmFjdG9yLFxyXG4gICAgICAgIEJsaXR0ZXJSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBCbGl0dGVyIChzY2VuZSwgeCwgeSwgdGV4dHVyZSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHNjZW5lLCAnQmxpdHRlcicpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRleHR1cmUodGV4dHVyZSwgZnJhbWUpO1xyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcblxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgRGlzcGxheUxpc3QodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyTGlzdCA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBmcmFtZSBNVVNUIGJlIHBhcnQgb2YgdGhlIEJsaXR0ZXIgdGV4dHVyZVxyXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoeCwgeSwgZnJhbWUsIHZpc2libGUsIGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHsgdmlzaWJsZSA9IHRydWU7IH1cclxuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyB9XHJcblxyXG4gICAgICAgIGlmIChmcmFtZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZnJhbWUgPSB0aGlzLmZyYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmcmFtZSA9IHRoaXMudGV4dHVyZS5nZXQoZnJhbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJvYiA9IG5ldyBCb2IoeCwgeSwgZnJhbWUsIHZpc2libGUpO1xyXG5cclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmFkZEF0KGJvYiwgaW5kZXgsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiBib2I7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBmcmFtZSBNVVNUIGJlIHBhcnQgb2YgdGhlIEJsaXR0ZXIgdGV4dHVyZVxyXG4gICAgY3JlYXRlRnJvbUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHF1YW50aXR5LCBmcmFtZSwgdmlzaWJsZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYm9icyA9IHRoaXMuY3JlYXRlTXVsdGlwbGUocXVhbnRpdHksIGZyYW1lLCB2aXNpYmxlKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2JzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGJvYiA9IGJvYnNbaV07XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGJvYiwgaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYm9icztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIGZyYW1lIE1VU1QgYmUgcGFydCBvZiB0aGUgQmxpdHRlciB0ZXh0dXJlXHJcbiAgICBjcmVhdGVNdWx0aXBsZTogZnVuY3Rpb24gKHF1YW50aXR5LCBmcmFtZSwgdmlzaWJsZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoZnJhbWUgPT09IHVuZGVmaW5lZCkgeyBmcmFtZSA9IHRoaXMuZnJhbWU7IH1cclxuICAgICAgICBpZiAodmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB7IHZpc2libGUgPSB0cnVlOyB9XHJcblxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcmFtZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmcmFtZSA9IFsgZnJhbWUgXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBib2JzID0gW107XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgZnJhbWUuZm9yRWFjaChmdW5jdGlvbiAoc2luZ2xlRnJhbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1YW50aXR5OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJvYnMucHVzaChfdGhpcy5jcmVhdGUoMCwgMCwgc2luZ2xlRnJhbWUsIHZpc2libGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gYm9icztcclxuICAgIH0sXHJcblxyXG4gICAgY2hpbGRDYW5SZW5kZXI6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKGNoaWxkLnZpc2libGUgJiYgY2hpbGQuYWxwaGEgPiAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVuZGVyTGlzdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdCA9IHRoaXMuY2hpbGRyZW4ubGlzdC5maWx0ZXIodGhpcy5jaGlsZENhblJlbmRlciwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckxpc3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxpdHRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMnKTtcclxudmFyIFJlbmRlciA9IHJlcXVpcmUoJy4vRWZmZWN0TGF5ZXJSZW5kZXInKTtcclxudmFyIFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyJyk7XHJcblxyXG4vLyAgRWZmZWN0TGF5ZXIgcmVuZGVycyBhbGwgZWxlbWVudHMgb24gdGhlIGxheWVyIHRvIGFuIG9mZnNjcmVlbiByZW5kZXIgdGFyZ2V0XHJcbi8vICBhbmQgdGhlbiB3aGVuIHJlbmRlcmluZyB0aGUgY29sb3IgYnVmZmVyIG9mIHRoYXQgcmVuZGVyIHRhcmdldCB0byB0aGUgbWFpbiBzY3JlZW5cclxuLy8gIGl0IGFwcGxpZXMgdGhlIGVmZmVjdCBsYXllciBzaGFkZXIuXHJcblxyXG52YXIgRWZmZWN0TGF5ZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLkZsaXAsXHJcbiAgICAgICAgQ29tcG9uZW50cy5HZXRCb3VuZHMsXHJcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXHJcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJUYXJnZXQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TaXplLFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBDb21wb25lbnRzLlNjcm9sbEZhY3RvcixcclxuICAgICAgICBSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBFZmZlY3RMYXllciAoc2NlbmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGVmZmVjdE5hbWUsIGZyYWdtZW50U2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzY2VuZSwgJ0VmZmVjdExheWVyJyk7XHJcbiAgICAgICBcclxuICAgICAgICB2YXIgcG90ID0gKCh3aWR0aCAmICh3aWR0aCAtIDEpKSA9PSAwICYmIChoZWlnaHQgJiAoaGVpZ2h0IC0gMSkpID09IDApO1xyXG4gICAgICAgIHZhciByZXNvdXJjZU1hbmFnZXIgPSBzY2VuZS5zeXMuZ2FtZS5yZW5kZXJlci5yZXNvdXJjZU1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHdyYXA7XHJcbiAgICAgICAgdmFyIGdsO1xyXG5cclxuICAgICAgICB0aGlzLmRzdFJlbmRlclRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJUZXh0dXJlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRzdFNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9O1xyXG5cclxuICAgICAgICBpZiAocmVzb3VyY2VNYW5hZ2VyICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbCA9IHNjZW5lLnN5cy5nYW1lLnJlbmRlcmVyLmdsO1xyXG4gICAgICAgICAgICB3cmFwID0gcG90ID8gZ2wuUkVQRUFUIDogZ2wuQ0xBTVBfVE9fRURHRTtcclxuICAgICAgICAgICAgdGhpcy5kc3RTaGFkZXIgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlU2hhZGVyKGVmZmVjdE5hbWUsIHtcclxuICAgICAgICAgICAgICAgIHZlcnQ6IFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlci52ZXJ0LFxyXG4gICAgICAgICAgICAgICAgZnJhZzogZnJhZ21lbnRTaGFkZXJcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlVGV4dHVyZShcclxuICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICBnbC5MSU5FQVIsIGdsLkxJTkVBUixcclxuICAgICAgICAgICAgICAgIHdyYXAsIHdyYXAsXHJcbiAgICAgICAgICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgICAgICAgICAgbnVsbCwgd2lkdGgsIGhlaWdodFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kc3RSZW5kZXJUYXJnZXQgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlUmVuZGVyVGFyZ2V0KHdpZHRoLCBoZWlnaHQsIHRoaXMucmVuZGVyVGV4dHVyZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIHNjZW5lLnN5cy5nYW1lLnJlbmRlcmVyLmN1cnJlbnRUZXh0dXJlWzBdID0gbnVsbDsgLy8gZm9yY2UgcmViaW5kaW5nIG9mIHByZXYgdGV4dHVyZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5mbGlwWSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgICAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5zZXRPcmlnaW4oMCwgMCk7XHJcblxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIuYWRkQ29udGV4dFJlc3RvcmVkQ2FsbGJhY2soZnVuY3Rpb24gKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNvdXJjZU1hbmFnZXIgPSByZW5kZXJlci5yZXNvdXJjZU1hbmFnZXI7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG4gICAgICAgICAgICB2YXIgd3JhcCA9IHBvdCA/IGdsLlJFUEVBVCA6IGdsLkNMQU1QX1RPX0VER0U7XHJcbiAgICAgICAgICAgIF90aGlzLmRzdFNoYWRlciA9IHJlc291cmNlTWFuYWdlci5jcmVhdGVTaGFkZXIoZWZmZWN0TmFtZSwge1xyXG4gICAgICAgICAgICAgICAgdmVydDogVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyLnZlcnQsXHJcbiAgICAgICAgICAgICAgICBmcmFnOiBmcmFnbWVudFNoYWRlclxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlclRleHR1cmUgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlVGV4dHVyZShcclxuICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICBnbC5MSU5FQVIsIGdsLkxJTkVBUixcclxuICAgICAgICAgICAgICAgIHdyYXAsIHdyYXAsXHJcbiAgICAgICAgICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgICAgICAgICAgbnVsbCwgX3RoaXMud2lkdGgsIF90aGlzLmhlaWdodFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgX3RoaXMuZHN0UmVuZGVyVGFyZ2V0ID0gcmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVJlbmRlclRhcmdldChfdGhpcy53aWR0aCwgX3RoaXMuaGVpZ2h0LCBfdGhpcy5yZW5kZXJUZXh0dXJlLCBudWxsKTtcclxuICAgICAgICAgICAgX3RoaXMudW5pZm9ybXMgPSB7fTtcclxuICAgICAgICAgICAgc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIuY3VycmVudFRleHR1cmVbMF0gPSBudWxsOyAvLyBmb3JjZSByZWJpbmRpbmcgb2YgcHJldiB0ZXh0dXJlXHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDbGVhckFscGhhOiBmdW5jdGlvbiAoYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHN0UmVuZGVyVGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kc3RSZW5kZXJUYXJnZXQuY2xlYXJBbHBoYSA9IGFscGhhO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyT2ZmU2NyZWVuOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gdGhpcy5kc3RSZW5kZXJUYXJnZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmRlck9uU2NyZWVuOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxuICAgIHtcclxuICAgICAgICBpZiAoZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0ID0gdGhpcy5kc3RSZW5kZXJUYXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChnYW1lT2JqZWN0LnJlbmRlclRhcmdldCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uOiBmdW5jdGlvbiAodW5pZm9ybU5hbWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRzdFNoYWRlciA9IHRoaXMuZHN0U2hhZGVyO1xyXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XHJcbiAgICAgICAgdmFyIGxvY2F0aW9uO1xyXG5cclxuICAgICAgICBpZiAodW5pZm9ybU5hbWUgaW4gdW5pZm9ybXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsb2NhdGlvbiA9IHVuaWZvcm1zW3VuaWZvcm1OYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbG9jYXRpb24gPSBkc3RTaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbdW5pZm9ybU5hbWVdID0gbG9jYXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZsb2F0OiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIHgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRzdFNoYWRlciA9IHRoaXMuZHN0U2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAoZHN0U2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHN0U2hhZGVyLnNldENvbnN0YW50RmxvYXQxKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgeCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZsb2F0MjogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudEZsb2F0Mih0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSksIHgsIHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGbG9hdDM6IGZ1bmN0aW9uICh1bmlmb3JtTmFtZSwgeCwgeSwgeilcclxuICAgIHtcclxuICAgICAgICB2YXIgZHN0U2hhZGVyID0gdGhpcy5kc3RTaGFkZXI7XHJcblxyXG4gICAgICAgIGlmIChkc3RTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkc3RTaGFkZXIuc2V0Q29uc3RhbnRGbG9hdDModGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5LCB6KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RmxvYXQ0OiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIHgsIHksIHosIHcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRzdFNoYWRlciA9IHRoaXMuZHN0U2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAoZHN0U2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHN0U2hhZGVyLnNldENvbnN0YW50RmxvYXQ0KHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgeCwgeSwgeiwgdyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEludDogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudEludDEodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW50MjogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudEludDIodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW50MzogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5LCB6KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudEludDModGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5LCB6KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW50NDogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5LCB6LCB3KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudEludDQodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5LCB6LCB3KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TWF0cml4MngyOiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIG1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgZHN0U2hhZGVyID0gdGhpcy5kc3RTaGFkZXI7XHJcblxyXG4gICAgICAgIGlmIChkc3RTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkc3RTaGFkZXIuc2V0Q29uc3RhbnRNYXRyaXgyeDIodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCBtYXRyaXgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRNYXRyaXgzeDM6IGZ1bmN0aW9uICh1bmlmb3JtTmFtZSwgbWF0cml4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudE1hdHJpeDN4Myh0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSksIG1hdHJpeCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldE1hdHJpeDR4NDogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCBtYXRyaXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRzdFNoYWRlciA9IHRoaXMuZHN0U2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAoZHN0U2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHN0U2hhZGVyLnNldENvbnN0YW50TWF0cml4NHg0KHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgbWF0cml4KTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RMYXllcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9lZmZlY3RsYXllci9FZmZlY3RMYXllci5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW4gPSByZXF1aXJlKCcuLi8uLi9tYXRoL0JldHdlZW4nKTtcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzJyk7XHJcbnZhciBEZWdUb1JhZCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvRGVnVG9SYWQnKTtcclxudmFyIEVhc2luZyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvZWFzaW5nJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgR2V0RWFzZUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHdlZW4vYnVpbGRlci9HZXRFYXNlRnVuY3Rpb24nKTtcclxudmFyIFBhcnRpY2xlID0gcmVxdWlyZSgnLi9QYXJ0aWNsZScpO1xyXG52YXIgUmVuZGVyID0gcmVxdWlyZSgnLi9QYXJ0aWNsZUVtaXR0ZXJSZW5kZXInKTtcclxudmFyIFN0YWJsZVNvcnQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hcnJheS9TdGFibGVTb3J0Jyk7XHJcblxyXG52YXIgUGFydGljbGVFbWl0dGVyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBHYW1lT2JqZWN0LFxyXG5cclxuICAgIE1peGluczogW1xyXG4gICAgICAgIENvbXBvbmVudHMuQWxwaGEsXHJcbiAgICAgICAgQ29tcG9uZW50cy5CbGVuZE1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJUYXJnZXQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBQYXJ0aWNsZUVtaXR0ZXIgKHNjZW5lLCB4LCB5LCB0ZXh0dXJlLCBmcmFtZSlcclxuICAgIHtcclxuXHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHNjZW5lLCAnUGFydGljbGVFbWl0dGVyJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZGVhZCA9IFtdO1xyXG4gICAgICAgIHRoaXMuYWxpdmUgPSBbXTtcclxuICAgICAgICB0aGlzLm1pblNwZWVkID0gMDtcclxuICAgICAgICB0aGlzLm1heFNwZWVkID0gMDtcclxuICAgICAgICB0aGlzLnN0YXJ0U2NhbGUgPSAxLjA7XHJcbiAgICAgICAgdGhpcy5lbmRTY2FsZSA9IDEuMDtcclxuICAgICAgICB0aGlzLnN0YXJ0QWxwaGEgPSAxLjA7XHJcbiAgICAgICAgdGhpcy5lbmRBbHBoYSA9IDEuMDtcclxuICAgICAgICB0aGlzLm1pbkVtaXRBbmdsZSA9IDA7XHJcbiAgICAgICAgdGhpcy5tYXhFbWl0QW5nbGUgPSAzNjA7XHJcbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcclxuICAgICAgICB0aGlzLmVuZEFuZ2xlID0gMDtcclxuICAgICAgICB0aGlzLmdyYXZpdHlYID0gMDtcclxuICAgICAgICB0aGlzLmdyYXZpdHlZID0gMDtcclxuICAgICAgICB0aGlzLmxpZmUgPSAxLjA7XHJcbiAgICAgICAgdGhpcy5kZWxheSA9IDAuMDtcclxuICAgICAgICB0aGlzLmRlbGF5Q291bnRlciA9IDAuMDtcclxuICAgICAgICB0aGlzLmRlYXRoQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW1pdENvdW50ID0gMTtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lYXNpbmdGdW5jdGlvbkFscGhhID0gRWFzaW5nLkxpbmVhcjtcclxuICAgICAgICB0aGlzLmVhc2luZ0Z1bmN0aW9uU2NhbGUgPSBFYXNpbmcuTGluZWFyO1xyXG4gICAgICAgIHRoaXMuZWFzaW5nRnVuY3Rpb25Sb3RhdGlvbiA9IEVhc2luZy5MaW5lYXI7XHJcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRleHR1cmUsIGZyYW1lKTtcclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRFYXNlOiBmdW5jdGlvbiAoZWFzZU5hbWUsIGVhc2VQYXJhbSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZWFzZSA9IEdldEVhc2VGdW5jdGlvbihlYXNlTmFtZSwgZWFzZVBhcmFtKTtcclxuXHJcbiAgICAgICAgdGhpcy5lYXNpbmdGdW5jdGlvbkFscGhhID0gZWFzZTtcclxuICAgICAgICB0aGlzLmVhc2luZ0Z1bmN0aW9uU2NhbGUgPSBlYXNlO1xyXG4gICAgICAgIHRoaXMuZWFzaW5nRnVuY3Rpb25Sb3RhdGlvbiA9IGVhc2U7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBbHBoYUVhc2U6IGZ1bmN0aW9uIChlYXNlTmFtZSwgZWFzZVBhcmFtKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZWFzaW5nRnVuY3Rpb25BbHBoYSA9IEdldEVhc2VGdW5jdGlvbihlYXNlTmFtZSwgZWFzZVBhcmFtKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjYWxlRWFzZTogZnVuY3Rpb24gKGVhc2VOYW1lLCBlYXNlUGFyYW0pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5lYXNpbmdGdW5jdGlvblNjYWxlID0gR2V0RWFzZUZ1bmN0aW9uKGVhc2VOYW1lLCBlYXNlUGFyYW0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Um90YXRpb25FYXNlOiBmdW5jdGlvbiAoZWFzZU5hbWUsIGVhc2VQYXJhbSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmVhc2luZ0Z1bmN0aW9uUm90YXRpb24gPSBHZXRFYXNlRnVuY3Rpb24oZWFzZU5hbWUsIGVhc2VQYXJhbSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTcGVlZDogZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkgeyBtYXggPSBtaW47IH1cclxuXHJcbiAgICAgICAgdGhpcy5taW5TcGVlZCA9IG1pbjtcclxuICAgICAgICB0aGlzLm1heFNwZWVkID0gbWF4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RW1pdEFuZ2xlOiBmdW5jdGlvbiAobWluLCBtYXgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7IG1heCA9IG1pbjsgfVxyXG5cclxuICAgICAgICB0aGlzLm1pbkVtaXRBbmdsZSA9IG1pbjtcclxuICAgICAgICB0aGlzLm1heEVtaXRBbmdsZSA9IG1heDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoc3RhcnQsIGVuZClcclxuICAgIHtcclxuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHsgZW5kID0gc3RhcnQ7IH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGFydFNjYWxlID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmRTY2FsZSA9IGVuZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEFscGhhOiBmdW5jdGlvbiAoc3RhcnQsIGVuZClcclxuICAgIHtcclxuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHsgZW5kID0gc3RhcnQ7IH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGFydEFscGhhID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmRBbHBoYSA9IGVuZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEFuZ2xlOiBmdW5jdGlvbiAoc3RhcnQsIGVuZClcclxuICAgIHtcclxuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHsgZW5kID0gc3RhcnQ7IH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmRBbmdsZSA9IGVuZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEdyYXZpdHk6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy5ncmF2aXR5WCA9IHg7XHJcbiAgICAgICAgdGhpcy5ncmF2aXR5WSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRFbWl0dGVyRGVsYXk6IGZ1bmN0aW9uIChkZWxheSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2VydmU6IGZ1bmN0aW9uIChwYXJ0aWNsZUNvdW50KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkZWFkID0gdGhpcy5kZWFkO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBjb3VudCA9IDA7IGNvdW50IDwgcGFydGljbGVDb3VudDsgKytjb3VudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlYWQucHVzaChuZXcgUGFydGljbGUodGhpcy54LCB0aGlzLnkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBbGl2ZVBhcnRpY2xlQ291bnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpdmUubGVuZ3RoO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXREZWFkUGFydGljbGVDb3VudDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWFkLmxlbmd0aDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UGFydGljbGVDb3VudDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGl2ZVBhcnRpY2xlQ291bnQoKSArIHRoaXMuZ2V0RGVhZFBhcnRpY2xlQ291bnQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25QYXJ0aWNsZURlYXRoOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVhdGhDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGtpbGxBbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRlYWQgPSB0aGlzLmRlYWQ7XHJcbiAgICAgICAgdmFyIGFsaXZlID0gdGhpcy5hbGl2ZTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGFsaXZlLmxlbmd0aCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWFkLnB1c2goYWxpdmUucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGZvckVhY2hBbGl2ZTogZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhbGl2ZSA9IHRoaXMuYWxpdmU7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFsaXZlLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgKytpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgYWxpdmVbaW5kZXhdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBmb3JFYWNoRGVhZDogZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkZWFkID0gdGhpcy5kZWFkO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBkZWFkLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgKytpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZGVhZFtpbmRleF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc3VtZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGV4cGxvZGU6IGZ1bmN0aW9uIChjb3VudClcclxuICAgIHtcclxuICAgICAgICBpZiAoIWNvdW50KSBjb3VudCA9IDEwMDtcclxuICAgICAgICB0aGlzLmVtaXRQYXJ0aWNsZSgxMDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbWl0UGFydGljbGU6IGZ1bmN0aW9uKGNvdW50KVxyXG4gICAge1xyXG4gICAgICAgIGNvdW50ID0gY291bnQgfHwgMTtcclxuXHJcbiAgICAgICAgdmFyIHBhcnRpY2xlID0gbnVsbDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNvdW50OyArK2luZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJhZCA9IERlZ1RvUmFkKEJldHdlZW4odGhpcy5taW5FbWl0QW5nbGUsIHRoaXMubWF4RW1pdEFuZ2xlKSk7XHJcbiAgICAgICAgICAgIHZhciBzcGVlZCA9IEJldHdlZW4odGhpcy5taW5TcGVlZCwgdGhpcy5tYXhTcGVlZCk7XHJcbiAgICAgICAgICAgIHZhciB2eCA9IE1hdGguY29zKHJhZCkgKiBzcGVlZDtcclxuICAgICAgICAgICAgdmFyIHZ5ID0gTWF0aC5zaW4ocmFkKSAqIHNwZWVkO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVhZC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZSA9IHRoaXMuZGVhZC5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnJlc2V0KHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFsbG93Q3JlYXRpb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBhcnRpY2xlID0gbmV3IFBhcnRpY2xlKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eVggPSB2eDtcclxuICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHlZID0gdnk7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLmxpZmUgPSBNYXRoLm1heCh0aGlzLmxpZmUsIE51bWJlci5NSU5fVkFMVUUpO1xyXG4gICAgICAgICAgICBwYXJ0aWNsZS5saWZlU3RlcCA9IHBhcnRpY2xlLmxpZmU7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLnN0YXJ0LnNjYWxlID0gdGhpcy5zdGFydFNjYWxlO1xyXG4gICAgICAgICAgICBwYXJ0aWNsZS5lbmQuc2NhbGUgPSB0aGlzLmVuZFNjYWxlO1xyXG4gICAgICAgICAgICBwYXJ0aWNsZS5zY2FsZVggPSB0aGlzLnN0YXJ0U2NhbGU7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLnNjYWxlWSA9IHRoaXMuc3RhcnRTY2FsZTtcclxuICAgICAgICAgICAgcGFydGljbGUuc3RhcnQuYWxwaGEgPSB0aGlzLnN0YXJ0QWxwaGE7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLmVuZC5hbHBoYSA9IHRoaXMuZW5kQWxwaGE7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLnN0YXJ0LnJvdGF0aW9uID0gdGhpcy5zdGFydEFuZ2xlICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICAgICAgcGFydGljbGUuZW5kLnJvdGF0aW9uID0gdGhpcy5lbmRBbmdsZSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLmNvbG9yID0gKHBhcnRpY2xlLmNvbG9yICYgMHgwMEZGRkZGRikgfCAoKCh0aGlzLnN0YXJ0QWxwaGEgKiAweEZGKXwwKSA8PCAyNCk7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLmluZGV4ID0gdGhpcy5hbGl2ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuYWxpdmUucHVzaChwYXJ0aWNsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJ0aWNsZTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJlVXBkYXRlOiBmdW5jdGlvbiAodGltZSwgZGVsdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRlYWQgPSB0aGlzLmRlYWQ7XHJcbiAgICAgICAgdmFyIHBhcnRpY2xlcyA9IHRoaXMuYWxpdmU7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpY2xlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGVtaXR0ZXJTdGVwID0gKGRlbHRhIC8gMTAwMCk7XHJcbiAgICAgICAgdmFyIGdyYXZpdHlYID0gdGhpcy5ncmF2aXR5WCAqIGVtaXR0ZXJTdGVwO1xyXG4gICAgICAgIHZhciBncmF2aXR5WSA9IHRoaXMuZ3Jhdml0eVkgKiBlbWl0dGVyU3RlcDtcclxuICAgICAgICB2YXIgZGVhdGhDYWxsYmFjayA9IHRoaXMuZGVhdGhDYWxsYmFjaztcclxuXHJcbiAgICAgICAgLyogU2ltdWxhdGlvbiAqL1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcGFydGljbGUgPSBwYXJ0aWNsZXNbaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHlYICs9IGdyYXZpdHlYO1xyXG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eVkgKz0gZ3Jhdml0eVk7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLnggKz0gcGFydGljbGUudmVsb2NpdHlYICogZW1pdHRlclN0ZXA7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLnkgKz0gcGFydGljbGUudmVsb2NpdHlZICogZW1pdHRlclN0ZXA7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLm5vcm1MaWZlU3RlcCA9IHBhcnRpY2xlLmxpZmVTdGVwIC8gcGFydGljbGUubGlmZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtID0gMS4wIC0gcGFydGljbGUubm9ybUxpZmVTdGVwO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGFFYXNlID0gdGhpcy5lYXNpbmdGdW5jdGlvbkFscGhhKG5vcm0pO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVFYXNlID0gdGhpcy5lYXNpbmdGdW5jdGlvblNjYWxlKG5vcm0pO1xyXG4gICAgICAgICAgICB2YXIgcm90YXRpb25FYXNlID0gdGhpcy5lYXNpbmdGdW5jdGlvblJvdGF0aW9uKG5vcm0pO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGFmID0gKHBhcnRpY2xlLmVuZC5hbHBoYSAtIHBhcnRpY2xlLnN0YXJ0LmFscGhhKSAqIGFscGhhRWFzZSArIHBhcnRpY2xlLnN0YXJ0LmFscGhhO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAocGFydGljbGUuZW5kLnNjYWxlIC0gcGFydGljbGUuc3RhcnQuc2NhbGUpICogc2NhbGVFYXNlICsgcGFydGljbGUuc3RhcnQuc2NhbGU7XHJcbiAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IChwYXJ0aWNsZS5lbmQucm90YXRpb24gLSBwYXJ0aWNsZS5zdGFydC5yb3RhdGlvbikgKiByb3RhdGlvbkVhc2UgKyBwYXJ0aWNsZS5zdGFydC5yb3RhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIHBhcnRpY2xlLnNjYWxlWCA9IHBhcnRpY2xlLnNjYWxlWSA9IHNjYWxlO1xyXG4gICAgICAgICAgICBwYXJ0aWNsZS5jb2xvciA9IChwYXJ0aWNsZS5jb2xvciAmIDB4MDBGRkZGRkYpIHwgKCgoYWxwaGFmICogMHhGRil8MCkgPDwgMjQpO1xyXG4gICAgICAgICAgICBwYXJ0aWNsZS5yb3RhdGlvbiA9IHJvdGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLmxpZmVTdGVwIDw9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gcGFydGljbGVzW2xlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgcGFydGljbGVzW2xlbmd0aCAtIDFdID0gcGFydGljbGU7XHJcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZXNbaW5kZXhdID0gbGFzdDtcclxuICAgICAgICAgICAgICAgIGluZGV4IC09IDE7XHJcbiAgICAgICAgICAgICAgICBsZW5ndGggLT0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVhdGhDYWxsYmFjaylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWF0aENhbGxiYWNrKHBhcnRpY2xlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGFydGljbGUubGlmZVN0ZXAgLT0gZW1pdHRlclN0ZXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBDbGVhbnVwICovXHJcbiAgICAgICAgdmFyIGRlYWRMZW5ndGggPSBwYXJ0aWNsZXMubGVuZ3RoIC0gbGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoZGVhZExlbmd0aCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWFkLnB1c2guYXBwbHkoZGVhZCwgcGFydGljbGVzLnNwbGljZShwYXJ0aWNsZXMubGVuZ3RoIC0gZGVhZExlbmd0aCwgZGVhZExlbmd0aCkpO1xyXG4gICAgICAgICAgICBTdGFibGVTb3J0KHBhcnRpY2xlcywgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4OyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGVsYXlDb3VudGVyIC09IGVtaXR0ZXJTdGVwO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kZWxheUNvdW50ZXIgPD0gMCAmJiB0aGlzLmVuYWJsZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXRQYXJ0aWNsZSh0aGlzLmVtaXRDb3VudCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXlDb3VudGVyID0gdGhpcy5kZWxheTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGVFbWl0dGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VtaXR0ZXIvUGFydGljbGVFbWl0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEFSQzogMCxcclxuICAgIEJFR0lOX1BBVEg6IDEsXHJcbiAgICBDTE9TRV9QQVRIOiAyLFxyXG4gICAgRklMTF9SRUNUOiAzLFxyXG4gICAgTElORV9UTzogNCxcclxuICAgIE1PVkVfVE86IDUsXHJcbiAgICBMSU5FX1NUWUxFOiA2LFxyXG4gICAgRklMTF9TVFlMRTogNyxcclxuICAgIEZJTExfUEFUSDogOCxcclxuICAgIFNUUk9LRV9QQVRIOiA5LFxyXG4gICAgRklMTF9UUklBTkdMRTogMTAsXHJcbiAgICBTVFJPS0VfVFJJQU5HTEU6IDExLFxyXG4gICAgTElORV9GWF9UTzogMTIsXHJcbiAgICBNT1ZFX0ZYX1RPOiAxMyxcclxuICAgIFNBVkU6IDE0LFxyXG4gICAgUkVTVE9SRTogMTUsXHJcbiAgICBUUkFOU0xBVEU6IDE2LFxyXG4gICAgU0NBTEU6IDE3LFxyXG4gICAgUk9UQVRFOiAxOFxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2dyYXBoaWNzL0NvbW1hbmRzLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FtZXJhID0gcmVxdWlyZSgnLi4vLi4vY2FtZXJhLzJkL0NhbWVyYS5qcycpO1xyXG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uLy4uL2RvbS9DYW52YXNQb29sJyk7XHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxudmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBSZW5kZXIgPSByZXF1aXJlKCcuL0dyYXBoaWNzUmVuZGVyJyk7XHJcblxyXG52YXIgR3JhcGhpY3MgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR3JhcGhpY3MgKHNjZW5lLCBvcHRpb25zKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gR2V0VmFsdWUob3B0aW9ucywgJ3gnLCAwKTtcclxuICAgICAgICB2YXIgeSA9IEdldFZhbHVlKG9wdGlvbnMsICd5JywgMCk7XHJcblxyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzY2VuZSwgJ0dyYXBoaWNzJyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGxheU9yaWdpblggPSAwO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheU9yaWdpblkgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0RmlsbENvbG9yID0gLTE7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0RmlsbEFscGhhID0gMTtcclxuXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0U3Ryb2tlV2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFN0cm9rZUNvbG9yID0gLTE7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0U3Ryb2tlQWxwaGEgPSAxO1xyXG5cclxuICAgICAgICB0aGlzLnNldERlZmF1bHRTdHlsZXMob3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHZhciByZXNvdXJjZU1hbmFnZXIgPSBzY2VuZS5zeXMuZ2FtZS5yZW5kZXJlci5yZXNvdXJjZU1hbmFnZXI7XHJcblxyXG4gICAgICAgIGlmIChyZXNvdXJjZU1hbmFnZXIgIT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gcmVzb3VyY2VNYW5hZ2VyO1xyXG4gICAgICAgICAgICB0aGlzLmdsID0gc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU1RZTEVTXHJcblxyXG4gICAgc2V0RGVmYXVsdFN0eWxlczogZnVuY3Rpb24gKG9wdGlvbnMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEdldFZhbHVlKG9wdGlvbnMsICdsaW5lU3R5bGUnLCBudWxsKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFN0cm9rZVdpZHRoID0gR2V0VmFsdWUob3B0aW9ucywgJ2xpbmVTdHlsZS53aWR0aCcsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTdHJva2VDb2xvciA9IEdldFZhbHVlKG9wdGlvbnMsICdsaW5lU3R5bGUuY29sb3InLCAweGZmZmZmZik7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFN0cm9rZUFscGhhID0gR2V0VmFsdWUob3B0aW9ucywgJ2xpbmVTdHlsZS5hbHBoYScsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saW5lU3R5bGUodGhpcy5kZWZhdWx0U3Ryb2tlV2lkdGgsIHRoaXMuZGVmYXVsdFN0cm9rZUNvbG9yLCB0aGlzLmRlZmF1bHRTdHJva2VBbHBoYSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoR2V0VmFsdWUob3B0aW9ucywgJ2ZpbGxTdHlsZScsIG51bGwpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0RmlsbENvbG9yID0gR2V0VmFsdWUob3B0aW9ucywgJ2ZpbGxTdHlsZS5jb2xvcicsIDB4ZmZmZmZmKTtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0RmlsbEFscGhhID0gR2V0VmFsdWUob3B0aW9ucywgJ2ZpbGxTdHlsZS5hbHBoYScsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5maWxsU3R5bGUodGhpcy5kZWZhdWx0RmlsbENvbG9yLCB0aGlzLmRlZmF1bHRGaWxsQWxwaGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGxpbmVTdHlsZTogZnVuY3Rpb24gKGxpbmVXaWR0aCwgY29sb3IsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7IGFscGhhID0gMTsgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuTElORV9TVFlMRSxcclxuICAgICAgICAgICAgbGluZVdpZHRoLCBjb2xvciwgYWxwaGFcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZmlsbFN0eWxlOiBmdW5jdGlvbiAoY29sb3IsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7IGFscGhhID0gMTsgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9TVFlMRSxcclxuICAgICAgICAgICAgY29sb3IsIGFscGhhXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBQQVRIXHJcblxyXG4gICAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5CRUdJTl9QQVRIXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsb3NlUGF0aDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuQ0xPU0VfUEFUSFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaWxsUGF0aDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9QQVRIXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0cm9rZVBhdGg6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLlNUUk9LRV9QQVRIXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDSVJDTEVcclxuXHJcbiAgICBmaWxsQ2lyY2xlU2hhcGU6IGZ1bmN0aW9uIChjaXJjbGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbENpcmNsZShjaXJjbGUueCwgY2lyY2xlLnksIGNpcmNsZS5yYWRpdXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdHJva2VDaXJjbGVTaGFwZTogZnVuY3Rpb24gKGNpcmNsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2VDaXJjbGUoY2lyY2xlLngsIGNpcmNsZS55LCBjaXJjbGUucmFkaXVzKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmlsbENpcmNsZTogZnVuY3Rpb24gKHgsIHksIHJhZGl1cylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuYXJjKHgsIHksIHJhZGl1cywgMCwgTUFUSF9DT05TVC5QSTIpO1xyXG4gICAgICAgIHRoaXMuZmlsbFBhdGgoKTtcclxuICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc3Ryb2tlQ2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNQVRIX0NPTlNULlBJMik7XHJcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLnN0cm9rZVBhdGgoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBSRUNUQU5HTEVcclxuXHJcbiAgICBmaWxsUmVjdFNoYXBlOiBmdW5jdGlvbiAocmVjdClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxsUmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdHJva2VSZWN0U2hhcGU6IGZ1bmN0aW9uIChyZWN0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cm9rZVJlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgZmlsbFJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5GSUxMX1JFQ1QsXHJcbiAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc3Ryb2tlUmVjdDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcclxuICAgICAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgsIHkpO1xyXG4gICAgICAgIHRoaXMubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5saW5lVG8oeCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5zdHJva2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBQT0lOVFxyXG5cclxuICAgIGZpbGxQb2ludFNoYXBlOiBmdW5jdGlvbiAocG9pbnQsIHNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbFBvaW50KHBvaW50LngsIHBvaW50LnksIHNpemUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaWxsUG9pbnQ6IGZ1bmN0aW9uICh4LCB5LCBzaXplKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5GSUxMX1JFQ1QsXHJcbiAgICAgICAgICAgIHgsIHksIHNpemUsIHNpemVcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFRSSUFOR0xFXHJcblxyXG4gICAgZmlsbFRyaWFuZ2xlU2hhcGU6IGZ1bmN0aW9uICh0cmlhbmdsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxsVHJpYW5nbGUodHJpYW5nbGUueDEsIHRyaWFuZ2xlLnkxLCB0cmlhbmdsZS54MiwgdHJpYW5nbGUueTIsIHRyaWFuZ2xlLngzLCB0cmlhbmdsZS55Myk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0cm9rZVRyaWFuZ2xlU2hhcGU6IGZ1bmN0aW9uICh0cmlhbmdsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2VUcmlhbmdsZSh0cmlhbmdsZS54MSwgdHJpYW5nbGUueTEsIHRyaWFuZ2xlLngyLCB0cmlhbmdsZS55MiwgdHJpYW5nbGUueDMsIHRyaWFuZ2xlLnkzKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmlsbFRyaWFuZ2xlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9UUklBTkdMRSxcclxuICAgICAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdHJva2VUcmlhbmdsZTogZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLlNUUk9LRV9UUklBTkdMRSxcclxuICAgICAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgTElORVxyXG5cclxuICAgIHN0cm9rZUxpbmVTaGFwZTogZnVuY3Rpb24gKGxpbmUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUJldHdlZW4obGluZS54MSwgbGluZS55MSwgbGluZS54MiwgbGluZS55Mik7XHJcbiAgICB9LFxyXG5cclxuICAgIGxpbmVCZXR3ZWVuOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLm1vdmVUbyh4MSwgeTEpO1xyXG4gICAgICAgIHRoaXMubGluZVRvKHgyLCB5Mik7XHJcbiAgICAgICAgdGhpcy5zdHJva2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLkxJTkVfVE8sXHJcbiAgICAgICAgICAgIHgsIHlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuTU9WRV9UTyxcclxuICAgICAgICAgICAgeCwgeVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBsaW5lRnhUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCByZ2IpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLkxJTkVfRlhfVE8sXHJcbiAgICAgICAgICAgIHgsIHksIHdpZHRoLCByZ2IsIDFcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZUZ4VG86IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgcmdiKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5NT1ZFX0ZYX1RPLFxyXG4gICAgICAgICAgICB4LCB5LCB3aWR0aCwgcmdiLCAxXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBBUkNcclxuXHJcbiAgICBhcmM6IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5BUkMsXHJcbiAgICAgICAgICAgIHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2VcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2F2ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuU0FWRVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXN0b3JlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5SRVNUT1JFXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLlRSQU5TTEFURSxcclxuICAgICAgICAgICAgeCwgeVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZTogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLlNDQUxFLFxyXG4gICAgICAgICAgICB4LCB5XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZTogZnVuY3Rpb24gKHJhZGlhbilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuUk9UQVRFLFxyXG4gICAgICAgICAgICByYWRpYW5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRGaWxsQ29sb3IgPiAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFN0eWxlKHRoaXMuZGVmYXVsdEZpbGxDb2xvciwgdGhpcy5kZWZhdWx0RmlsbEFscGhhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRTdHJva2VDb2xvciA+IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lU3R5bGUodGhpcy5kZWZhdWx0U3Ryb2tlV2lkdGgsIHRoaXMuZGVmYXVsdFN0cm9rZUNvbG9yLCB0aGlzLmRlZmF1bHRTdHJva2VBbHBoYSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIElmIGtleSBpcyBhIHN0cmluZyBpdCdsbCBnZW5lcmF0ZSBhIG5ldyB0ZXh0dXJlIHVzaW5nIGl0IGFuZCBhZGQgaXQgaW50byB0aGUgXHJcbiAgICAvLyAgVGV4dHVyZSBNYW5hZ2VyIChhc3N1bWluZyBubyBrZXkgY29uZmxpY3QgaGFwcGVucykuXHJcbiAgICAvLyAgXHJcbiAgICAvLyAgSWYga2V5IGlzIGEgQ2FudmFzIGl0IHdpbGwgZHJhdyB0aGUgdGV4dHVyZSB0byB0aGF0IGNhbnZhcyBjb250ZXh0LiBOb3RlIHRoYXQgaXQgd2lsbCBOT1RcclxuICAgIC8vICBhdXRvbWF0aWNhbGx5IHVwbG9hZCBpdCB0byB0aGUgR1BVIGluIFdlYkdMIG1vZGUuXHJcblxyXG4gICAgZ2VuZXJhdGVUZXh0dXJlOiBmdW5jdGlvbiAoa2V5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzeXMgPSB0aGlzLnNjZW5lLnN5cztcclxuXHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSBzeXMuZ2FtZS5jb25maWcud2lkdGg7IH1cclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gc3lzLmdhbWUuY29uZmlnLmhlaWdodDsgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIEdyYXBoaWNzLlRhcmdldENhbWVyYS5zZXRWaWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBHcmFwaGljcy5UYXJnZXRDYW1lcmEuc2Nyb2xsWCA9IHRoaXMueDtcclxuICAgICAgICBHcmFwaGljcy5UYXJnZXRDYW1lcmEuc2Nyb2xsWSA9IHRoaXMueTtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmU7XHJcbiAgICAgICAgdmFyIGN0eDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHN5cy50ZXh0dXJlcy5leGlzdHMoa2V5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIEtleSBpcyBhIHN0cmluZywgaXQgRE9FUyBleGlzdCBpbiB0aGUgVGV4dHVyZSBNYW5hZ2VyIEFORCBpcyBhIGNhbnZhcywgc28gZHJhdyB0byBpdFxyXG5cclxuICAgICAgICAgICAgICAgIHRleHR1cmUgPSBzeXMudGV4dHVyZXMuZ2V0KGtleSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNyYyA9IHRleHR1cmUuZ2V0U291cmNlSW1hZ2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3JjIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gc3JjLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgS2V5IGlzIGEgc3RyaW5nIGFuZCBkb2Vzbid0IGV4aXN0IGluIHRoZSBUZXh0dXJlIE1hbmFnZXIsIHNvIGdlbmVyYXRlIGFuZCBzYXZlIGl0XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZSA9IHN5cy50ZXh0dXJlcy5jcmVhdGVDYW52YXMoa2V5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjdHggPSB0ZXh0dXJlLmdldFNvdXJjZUltYWdlKCkuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBLZXkgaXMgYSBDYW52YXMsIHNvIGRyYXcgdG8gaXRcclxuXHJcbiAgICAgICAgICAgIGN0eCA9IGtleS5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGN0eClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKHN5cy5nYW1lLnJlbmRlcmVyLCB0aGlzLCAwLCBHcmFwaGljcy5UYXJnZXRDYW1lcmEsIGN0eCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5nbCAmJiB0ZXh0dXJlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzeXMuZ2FtZS5yZW5kZXJlci51cGxvYWRDYW52YXNUb0dQVShjdHguY2FudmFzLCB0ZXh0dXJlLnNvdXJjZVswXS5nbFRleHR1cmUsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuR3JhcGhpY3MuVGFyZ2V0Q2FtZXJhID0gbmV3IENhbWVyYSgwLCAwLCAwLCAwKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3M7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3MuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgU2V0ID0gcmVxdWlyZSgnLi4vLi4vc3RydWN0cy9TZXQnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBSYW5nZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5L1JhbmdlJyk7XHJcbnZhciBBY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vYWN0aW9ucy8nKTtcclxudmFyIFNwcml0ZSA9IHJlcXVpcmUoJy4uL3Nwcml0ZS9TcHJpdGUnKTtcclxuXHJcbnZhciBHcm91cCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBHcm91cCAoc2NlbmUsIGNoaWxkcmVuLCBjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldChjaGlsZHJlbik7XHJcblxyXG4gICAgICAgIHRoaXMuY2xhc3NUeXBlID0gU3ByaXRlO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVNdWx0aXBsZShjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAodGltZSwgZGVsdGEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEJlY2F1c2UgYSBHcm91cCBjaGlsZCBtYXkgbWVzcyB3aXRoIHRoZSBsZW5ndGggb2YgdGhlIEdyb3VwIGR1cmluZyBpdHMgdXBkYXRlXHJcbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmNoaWxkcmVuLmVudHJpZXMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRlbXBbaV0udXBkYXRlKHRpbWUsIGRlbHRhKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgR3JvdXAgbWFuYWdlbWVudCBtZXRob2RzOlxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc2V0KGNoaWxkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZE11bHRpcGxlOiBmdW5jdGlvbiAoY2hpbGRyZW4pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zZXQoY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoeCwgeSwga2V5LCBmcmFtZSwgdmlzaWJsZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB7IHZpc2libGUgPSB0cnVlOyB9XHJcblxyXG4gICAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNsYXNzVHlwZSh0aGlzLnNjZW5lLCB4LCB5LCBrZXksIGZyYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5zY2VuZS5zeXMuZGlzcGxheUxpc3QuYWRkKGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGNoaWxkLnByZVVwZGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuc3lzLnVwZGF0ZUxpc3QuYWRkKGNoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoaWxkLnZpc2libGUgPSB2aXNpYmxlO1xyXG5cclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNldChjaGlsZCk7XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlRnJvbUNvbmZpZzogZnVuY3Rpb24gKG9wdGlvbnMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jbGFzc1R5cGUgPSBHZXRWYWx1ZShvcHRpb25zLCAnY2xhc3NUeXBlJywgdGhpcy5jbGFzc1R5cGUpO1xyXG5cclxuICAgICAgICB2YXIga2V5ID0gR2V0VmFsdWUob3B0aW9ucywgJ2tleScsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gR2V0VmFsdWUob3B0aW9ucywgJ2ZyYW1lJywgbnVsbCk7XHJcbiAgICAgICAgdmFyIHZpc2libGUgPSBHZXRWYWx1ZShvcHRpb25zLCAndmlzaWJsZScsIHRydWUpO1xyXG5cclxuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xyXG5cclxuICAgICAgICAvLyAgQ2FuJ3QgZG8gYW55dGhpbmcgd2l0aG91dCBhdCBsZWFzdCBhIGtleVxyXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5ID0gWyBrZXkgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyYW1lKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZnJhbWUgPSBbIGZyYW1lIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBCdWlsZCBhbiBhcnJheSBvZiBrZXkgZnJhbWUgcGFpcnMgdG8gbG9vcCB0aHJvdWdoXHJcblxyXG4gICAgICAgIHZhciByZXBlYXQgPSBHZXRWYWx1ZShvcHRpb25zLCAncmVwZWF0JywgMCk7XHJcbiAgICAgICAgdmFyIHJhbmRvbUtleSA9IEdldFZhbHVlKG9wdGlvbnMsICdyYW5kb21LZXknLCBmYWxzZSk7XHJcbiAgICAgICAgdmFyIHJhbmRvbUZyYW1lID0gR2V0VmFsdWUob3B0aW9ucywgJ3JhbmRvbUZyYW1lJywgZmFsc2UpO1xyXG4gICAgICAgIHZhciB5b3lvID0gR2V0VmFsdWUob3B0aW9ucywgJ3lveW8nLCBmYWxzZSk7XHJcbiAgICAgICAgdmFyIHF1YW50aXR5ID0gR2V0VmFsdWUob3B0aW9ucywgJ2ZyYW1lUXVhbnRpdHknLCAxKTtcclxuICAgICAgICB2YXIgbWF4ID0gR2V0VmFsdWUob3B0aW9ucywgJ21heCcsIDApO1xyXG5cclxuICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZShrZXksIGZyYW1lLCB7XHJcbiAgICAgICAgICAgIG1heDogbWF4LFxyXG4gICAgICAgICAgICBxdHk6IHF1YW50aXR5LFxyXG4gICAgICAgICAgICByYW5kb206IHJhbmRvbUtleSxcclxuICAgICAgICAgICAgcmFuZG9tQjogcmFuZG9tRnJhbWUsXHJcbiAgICAgICAgICAgIHJlcGVhdDogcmVwZWF0LFxyXG4gICAgICAgICAgICB5b3lvOiB5b3lvXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgcmFuZ2UubGVuZ3RoOyBjKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2godGhpcy5jcmVhdGUoMCwgMCwgcmFuZ2VbY10uYSwgcmFuZ2VbY10uYiwgdmlzaWJsZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFBvc3QtY3JlYXRpb24gb3B0aW9ucyAoYXBwbGllZCBvbmx5IHRvIHRob3NlIGl0ZW1zIGNyZWF0ZWQgaW4gdGhpcyBjYWxsKTpcclxuXHJcbiAgICAgICAgdmFyIHggPSBHZXRWYWx1ZShvcHRpb25zLCAnc2V0WFkueCcsIDApO1xyXG4gICAgICAgIHZhciB5ID0gR2V0VmFsdWUob3B0aW9ucywgJ3NldFhZLnknLCAwKTtcclxuICAgICAgICB2YXIgc3RlcFggPSBHZXRWYWx1ZShvcHRpb25zLCAnc2V0WFkuc3RlcFgnLCAwKTtcclxuICAgICAgICB2YXIgc3RlcFkgPSBHZXRWYWx1ZShvcHRpb25zLCAnc2V0WFkuc3RlcFknLCAwKTtcclxuXHJcbiAgICAgICAgQWN0aW9ucy5TZXRYWShlbnRyaWVzLCB4LCB5LCBzdGVwWCwgc3RlcFkpO1xyXG5cclxuICAgICAgICB2YXIgcm90YXRpb24gPSBHZXRWYWx1ZShvcHRpb25zLCAnc2V0Um90YXRpb24udmFsdWUnLCAwKTtcclxuICAgICAgICB2YXIgc3RlcFJvdGF0aW9uID0gR2V0VmFsdWUob3B0aW9ucywgJ3NldFJvdGF0aW9uLnN0ZXAnLCAwKTtcclxuXHJcbiAgICAgICAgQWN0aW9ucy5TZXRSb3RhdGlvbihlbnRyaWVzLCByb3RhdGlvbiwgc3RlcFJvdGF0aW9uKTtcclxuXHJcbiAgICAgICAgdmFyIHNjYWxlWCA9IEdldFZhbHVlKG9wdGlvbnMsICdzZXRTY2FsZS54JywgMSk7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IEdldFZhbHVlKG9wdGlvbnMsICdzZXRTY2FsZS55Jywgc2NhbGVYKTtcclxuICAgICAgICB2YXIgc3RlcFNjYWxlWCA9IEdldFZhbHVlKG9wdGlvbnMsICdzZXRTY2FsZS5zdGVwWCcsIDApO1xyXG4gICAgICAgIHZhciBzdGVwU2NhbGVZID0gR2V0VmFsdWUob3B0aW9ucywgJ3NldFNjYWxlLnN0ZXBZJywgMCk7XHJcblxyXG4gICAgICAgIEFjdGlvbnMuU2V0U2NhbGUoZW50cmllcywgc2NhbGVYLCBzY2FsZVksIHN0ZXBTY2FsZVgsIHN0ZXBTY2FsZVkpO1xyXG5cclxuICAgICAgICB2YXIgYWxwaGEgPSBHZXRWYWx1ZShvcHRpb25zLCAnc2V0QWxwaGEudmFsdWUnLCAxKTtcclxuICAgICAgICB2YXIgc3RlcEFscGhhID0gR2V0VmFsdWUob3B0aW9ucywgJ3NldEFscGhhLnN0ZXAnLCAwKTtcclxuXHJcbiAgICAgICAgQWN0aW9ucy5TZXRBbHBoYShlbnRyaWVzLCBhbHBoYSwgc3RlcEFscGhhKTtcclxuXHJcbiAgICAgICAgdmFyIGhpdEFyZWEgPSBHZXRWYWx1ZShvcHRpb25zLCAnaGl0QXJlYScsIG51bGwpO1xyXG4gICAgICAgIHZhciBoaXRBcmVhQ2FsbGJhY2sgPSBHZXRWYWx1ZShvcHRpb25zLCAnaGl0QXJlYUNhbGxiYWNrJywgbnVsbCk7XHJcblxyXG4gICAgICAgIGlmIChoaXRBcmVhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQWN0aW9ucy5TZXRIaXRBcmVhKGVudHJpZXMsIGhpdEFyZWEsIGhpdEFyZWFDYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ3JpZCA9IEdldFZhbHVlKG9wdGlvbnMsICdncmlkQWxpZ24nLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIGlmIChncmlkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQWN0aW9ucy5HcmlkQWxpZ24oZW50cmllcywgZ3JpZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZW50cmllcztcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlTXVsdGlwbGU6IGZ1bmN0aW9uIChjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25maWcgPSBbIGNvbmZpZyBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5jcmVhdGVGcm9tQ29uZmlnKGNvbmZpZ1tpXSk7XHJcblxyXG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuY29uY2F0KGVudHJpZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5jbGVhcigpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZW50cmllcztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnNpemU7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZpcnN0OiBmdW5jdGlvbiAoY29tcGFyZSwgaW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XHJcblxyXG4gICAgICAgIHJldHVybiBBY3Rpb25zLkdldEZpcnN0KHRoaXMuY2hpbGRyZW4uZW50cmllcywgY29tcGFyZSwgaW5kZXgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2hpbGQgcmVsYXRlZCBtZXRob2RzXHJcblxyXG4gICAgYW5nbGU6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLkFuZ2xlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZ3JpZEFsaWduOiBmdW5jdGlvbiAob3B0aW9ucylcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLkdyaWRBbGlnbih0aGlzLmNoaWxkcmVuLmVudHJpZXMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaW5jQWxwaGE6IGZ1bmN0aW9uICh2YWx1ZSwgc3RlcClcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLkluY0FscGhhKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUsIHN0ZXApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaW5jWDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuSW5jWCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGluY1hZOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLkluY1hZKHRoaXMuY2hpbGRyZW4uZW50cmllcywgeCwgeSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbmNZOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5JbmNZKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcGxhY2VPbkNpcmNsZTogZnVuY3Rpb24gKGNpcmNsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5QbGFjZU9uQ2lyY2xlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgY2lyY2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBwbGFjZU9uRWxsaXBzZTogZnVuY3Rpb24gKGVsbGlwc2UsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUGxhY2VPbkVsbGlwc2UodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBlbGxpcHNlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBwbGFjZU9uTGluZTogZnVuY3Rpb24gKGxpbmUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5QbGFjZU9uTGluZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIGxpbmUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcGxhY2VPblJlY3RhbmdsZTogZnVuY3Rpb24gKHJlY3QsIHNoaWZ0KVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUGxhY2VPblJlY3RhbmdsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHJlY3QsIHNoaWZ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHBsYWNlT25UcmlhbmdsZTogZnVuY3Rpb24gKHRyaWFuZ2xlLCBzdGVwUmF0ZSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlBsYWNlT25UcmlhbmdsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHRyaWFuZ2xlLCBzdGVwUmF0ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBwbGF5QW5pbWF0aW9uOiBmdW5jdGlvbiAoa2V5LCBzdGFydEZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUGxheUFuaW1hdGlvbih0aGlzLmNoaWxkcmVuLmVudHJpZXMsIGtleSwgc3RhcnRGcmFtZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByYW5kb21DaXJjbGU6IGZ1bmN0aW9uIChjaXJjbGUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5SYW5kb21DaXJjbGUodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBjaXJjbGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmFuZG9tRWxsaXBzZTogZnVuY3Rpb24gKGVsbGlwc2UpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5SYW5kb21FbGxpcHNlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgZWxsaXBzZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByYW5kb21MaW5lOiBmdW5jdGlvbiAobGluZSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlJhbmRvbUxpbmUodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBsaW5lKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJhbmRvbVJlY3RhbmdsZTogZnVuY3Rpb24gKHJlY3QpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5SYW5kb21SZWN0YW5nbGUodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCByZWN0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJhbmRvbVRyaWFuZ2xlOiBmdW5jdGlvbiAodHJpYW5nbGUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5SYW5kb21UcmlhbmdsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHRyaWFuZ2xlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZTogZnVuY3Rpb24gKHZhbHVlLCBzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUm90YXRlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUsIHN0ZXApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRlQXJvdW5kOiBmdW5jdGlvbiAocG9pbnQsIGFuZ2xlKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUm90YXRlQXJvdW5kKHRoaXMuY2hpbGRyZW4uZW50cmllcywgcG9pbnQsIGFuZ2xlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZUFyb3VuZERpc3RhbmNlOiBmdW5jdGlvbiAocG9pbnQsIGFuZ2xlLCBkaXN0YW5jZSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlJvdGF0ZUFyb3VuZERpc3RhbmNlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgcG9pbnQsIGFuZ2xlLCBkaXN0YW5jZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBbHBoYTogZnVuY3Rpb24gKHZhbHVlLCBzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2V0QWxwaGEodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSwgc3RlcCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRPcmlnaW46IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2V0T3JpZ2luKHRoaXMuY2hpbGRyZW4uZW50cmllcywgeCwgeSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZVg6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNjYWxlWCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlWFk6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2NhbGVYWSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHgsIHkpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGVZOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5TY2FsZVkodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSb3RhdGlvbjogZnVuY3Rpb24gKHZhbHVlLCBzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2V0Um90YXRpb24odGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSwgc3RlcCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTY2FsZTogZnVuY3Rpb24gKHgsIHksIHN0ZXBYLCBzdGVwWSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNldFNjYWxlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgeCwgeSwgc3RlcFgsIHN0ZXBZKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjYWxlWDogZnVuY3Rpb24gKHZhbHVlLCBzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2V0U2NhbGVYKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUsIHN0ZXApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2NhbGVZOiBmdW5jdGlvbiAodmFsdWUsIHN0ZXApXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5TZXRTY2FsZVkodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSwgc3RlcCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5TZXRWaXNpYmxlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0WDogZnVuY3Rpb24gKHZhbHVlLCBzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2V0WCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlLCBzdGVwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFhZOiBmdW5jdGlvbiAoeCwgeSwgc3RlcFgsIHN0ZXBZKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2V0WFkodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB4LCB5LCBzdGVwWCwgc3RlcFkpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0WTogZnVuY3Rpb24gKHZhbHVlLCBzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2V0WSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlLCBzdGVwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldERlcHRoOiBmdW5jdGlvbiAodmFsdWUsIHN0ZXApXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5TZXREZXB0aCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlLCBzdGVwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNoaWZ0UG9zaXRpb246IGZ1bmN0aW9uICh4LCB5LCBkaXJlY3Rpb24sIG91dHB1dClcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNoaWZ0UG9zaXRpb24odGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB4LCB5LCBkaXJlY3Rpb24sIG91dHB1dCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzbW9vdGhlclN0ZXA6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgbWluLCBtYXgsIGluYylcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNtb290aGVyU3RlcCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHByb3BlcnR5LCBtaW4sIG1heCwgaW5jKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNtb290aFN0ZXA6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgbWluLCBtYXgsIGluYylcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNtb290aFN0ZXAodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBwcm9wZXJ0eSwgbWluLCBtYXgsIGluYyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzcHJlYWQ6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgbWluLCBtYXgsIGluYylcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNwcmVhZCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHByb3BlcnR5LCBtaW4sIG1heCwgaW5jKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvZ2dsZVZpc2libGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5Ub2dnbGVWaXNpYmxlKHRoaXMuY2hpbGRyZW4uZW50cmllcyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2dyb3VwL0dyb3VwLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzJyk7XHJcbnZhciBDb25zdCA9IHJlcXVpcmUoJy4vQ29uc3QnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBHQnVmZmVyU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9HQnVmZmVyU2hhZGVyJyk7XHJcbnZhciBMaWdodCA9IHJlcXVpcmUoJy4vTGlnaHQnKTtcclxudmFyIExpZ2h0RnJhZ21lbnRTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0xpZ2h0RnJhZ21lbnRTaGFkZXInKTtcclxudmFyIFBob25nMkRTaGFkZXJEZWZlcnJlZCA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvUGhvbmcyRFNoYWRlckRlZmVycmVkJyk7XHJcbnZhciBSZW5kZXIgPSByZXF1aXJlKCcuL0xpZ2h0TGF5ZXJSZW5kZXInKTtcclxudmFyIFNwcml0ZU5vcm1hbFBhaXIgPSByZXF1aXJlKCcuL1Nwcml0ZU5vcm1hbFBhaXInKTtcclxudmFyIFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyJyk7XHJcbnZhciBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvVmVydGV4QnVmZmVyJyk7XHJcbnZhciBXZWJHTFN1cHBvcnRlZEV4dGVuc2lvbnMgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlci93ZWJnbC9XZWJHTFN1cHBvcnRlZEV4dGVuc2lvbnMnKTtcclxuXHJcbi8vIGh0dHA6Ly9jcGV0cnkuZ2l0aHViLmlvL05vcm1hbE1hcC1PbmxpbmUvXHJcblxyXG52YXIgTGlnaHRMYXllciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuT3JpZ2luLFxyXG4gICAgICAgIENvbXBvbmVudHMuUmVuZGVyVGFyZ2V0LFxyXG4gICAgICAgIENvbXBvbmVudHMuU2Nyb2xsRmFjdG9yLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBMaWdodExheWVyIChzY2VuZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc2NlbmUsICdMaWdodExheWVyJyk7XHJcblxyXG4gICAgICAgIHRoaXMucGFzc1NoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvclIgPSAwLjA7XHJcbiAgICAgICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvckcgPSAwLjA7XHJcbiAgICAgICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvckIgPSAwLjA7XHJcbiAgICAgICAgdGhpcy5saWdodFBvb2wgPSBbXTtcclxuICAgICAgICB0aGlzLnNwcml0ZVBvb2wgPSBbXTtcclxuICAgICAgICB0aGlzLmxpZ2h0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3ByaXRlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3ogPSAwO1xyXG4gICAgICAgIHRoaXMuc2V0T3JpZ2luKDAsIDApO1xyXG5cclxuICAgICAgICBzY2VuZS5zeXMuZ2FtZS5yZW5kZXJlci5hZGRDb250ZXh0UmVzdG9yZWRDYWxsYmFjayhmdW5jdGlvbiAocmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMub25Db250ZXh0UmVzdG9yZWQocmVuZGVyZXIpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmluaXQoc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIsIFdlYkdMU3VwcG9ydGVkRXh0ZW5zaW9ucy5oYXMoJ1dFQkdMX2RyYXdfYnVmZmVycycpKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Db250ZXh0UmVzdG9yZWQ6IGZ1bmN0aW9uIChyZW5kZXJlcilcclxuICAgIHtcclxuICAgICAgICAvKiBJdCB3b24ndCBhbGxvdyB0aGUgdXNlIG9mIGRyYXdCdWZmZXJzIG9uIHJlc3RvcmVkIGNvbnRleHQgKi9cclxuICAgICAgICB0aGlzLmluaXQocmVuZGVyZXIsIGZhbHNlKTsgXHJcbiAgICAgICAgdGhpcy5yZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4vRm9yd2FyZFJlbmRlcmVyJyk7XHJcbiAgICAgICAgdGhpcy5saWdodHMubGVuZ3RoID0gTWF0aC5taW4odGhpcy5saWdodHMubGVuZ3RoLCBDb25zdC5NQVhfTElHSFRTKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKHJlbmRlcmVyLCBkZWZlcnJlZClcclxuICAgIHtcclxuICAgICAgICB2YXIgcmVzb3VyY2VNYW5hZ2VyID0gcmVuZGVyZXIucmVzb3VyY2VNYW5hZ2VyO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2lzRGVmZXJyZWQgPSBkZWZlcnJlZDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5saWdodHNMb2NhdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKHJlc291cmNlTWFuYWdlciAhPT0gdW5kZWZpbmVkICYmICF0aGlzLl9pc0RlZmVycmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nbCA9IHJlbmRlcmVyLmdsO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wYXNzU2hhZGVyID0gcmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVNoYWRlcignUGhvbmcyRFNoYWRlckZvcndhcmQnLCB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0OiBUZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIudmVydCxcclxuICAgICAgICAgICAgICAgIGZyYWc6IExpZ2h0RnJhZ21lbnRTaGFkZXIoQ29uc3QuTUFYX0xJR0hUUylcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFtYmllbnRMaWdodENvbG9yTG9jID0gdGhpcy5wYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndUFtYmllbnRMaWdodENvbG9yJyk7XHJcbiAgICAgICAgICAgIHRoaXMudU1haW5UZXh0dXJlTG9jID0gdGhpcy5wYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndU1haW5UZXh0dXJlJyk7XHJcbiAgICAgICAgICAgIHRoaXMudU5vcm1UZXh0dXJlTG9jID0gdGhpcy5wYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndU5vcm1UZXh0dXJlJyk7XHJcbiAgICAgICAgICAgIHRoaXMudVJlc29sdXRpb25Mb2MgPSB0aGlzLnBhc3NTaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1UmVzb2x1dGlvbicpO1xyXG4gICAgICAgICAgICB0aGlzLnVDYW1lcmFMb2MgPSB0aGlzLnBhc3NTaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1Q2FtZXJhJyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBhc3NTaGFkZXIuc2V0Q29uc3RhbnRJbnQxKHRoaXMudU1haW5UZXh0dXJlTG9jLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5wYXNzU2hhZGVyLnNldENvbnN0YW50SW50MSh0aGlzLnVOb3JtVGV4dHVyZUxvYywgMSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgQ29uc3QuTUFYX0xJR0hUUzsgKytpbmRleClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saWdodHNMb2NhdGlvbnNbaW5kZXhdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBhc3NTaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1TGlnaHRzWycgKyBpbmRleCArICddLnBvc2l0aW9uJyksXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMucGFzc1NoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3VMaWdodHNbJyArIGluZGV4ICsgJ10uY29sb3InKSxcclxuICAgICAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbjogdGhpcy5wYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndUxpZ2h0c1snICsgaW5kZXggKyAnXS5hdHRlbnVhdGlvbicpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogdGhpcy5wYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndUxpZ2h0c1snICsgaW5kZXggKyAnXS5yYWRpdXMnKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsID0gcmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV4dCA9IHJlbmRlcmVyLmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdCdWZmZXJTaGFkZXJQYXNzID0gcmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVNoYWRlcignR0J1ZmZlclNoYWRlcicsIHtcclxuICAgICAgICAgICAgICAgIHZlcnQ6IFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlci52ZXJ0LFxyXG4gICAgICAgICAgICAgICAgZnJhZzogR0J1ZmZlclNoYWRlcigpXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBob25nU2hhZGVyID0gUGhvbmcyRFNoYWRlckRlZmVycmVkKENvbnN0LkRFRkVSUkVEX01BWF9MSUdIVFMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saWdodFBhc3NTaGFkZXIgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlU2hhZGVyKCdQaG9uZzJEU2hhZGVyRGVmZXJyZWQnLCB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0OiBwaG9uZ1NoYWRlci52ZXJ0LFxyXG4gICAgICAgICAgICAgICAgZnJhZzogcGhvbmdTaGFkZXIuZnJhZ1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRQYXNzVkJPID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmxpZ2h0UGFzc1ZCTyk7XHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFsgLTEsIDcsIC0xLCAtMSwgNywgLTEgXSksIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMudU1haW5UZXh0dXJlTG9jID0gdGhpcy5nQnVmZmVyU2hhZGVyUGFzcy5nZXRVbmlmb3JtTG9jYXRpb24oJ3VNYWluVGV4dHVyZScpO1xyXG4gICAgICAgICAgICB0aGlzLnVOb3JtVGV4dHVyZUxvYyA9IHRoaXMuZ0J1ZmZlclNoYWRlclBhc3MuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1Tm9ybVRleHR1cmUnKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ0J1ZmZlclNoYWRlclBhc3Muc2V0Q29uc3RhbnRJbnQxKHRoaXMudU1haW5UZXh0dXJlTG9jLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5nQnVmZmVyU2hhZGVyUGFzcy5zZXRDb25zdGFudEludDEodGhpcy51Tm9ybVRleHR1cmVMb2MsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvckxvYyA9IHRoaXMubGlnaHRQYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndUFtYmllbnRMaWdodENvbG9yJyk7XHJcbiAgICAgICAgICAgIHRoaXMudVJlc29sdXRpb25Mb2MgPSB0aGlzLmxpZ2h0UGFzc1NoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3VSZXNvbHV0aW9uJyk7XHJcbiAgICAgICAgICAgIHRoaXMudUdidWZmZXJDb2xvckxvYyA9IHRoaXMubGlnaHRQYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndUdidWZmZXJDb2xvcicpO1xyXG4gICAgICAgICAgICB0aGlzLnVHYnVmZmVyTm9ybWFsTG9jID0gdGhpcy5saWdodFBhc3NTaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1R2J1ZmZlck5vcm1hbCcpO1xyXG4gICAgICAgICAgICB0aGlzLnVDYW1lcmFMb2MgPSB0aGlzLmxpZ2h0UGFzc1NoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3VDYW1lcmEnKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRQYXNzU2hhZGVyLnNldENvbnN0YW50SW50MSh0aGlzLnVHYnVmZmVyQ29sb3JMb2MsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0UGFzc1NoYWRlci5zZXRDb25zdGFudEludDEodGhpcy51R2J1ZmZlck5vcm1hbExvYywgMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdCdWZmZXJTaGFkZXJQYXNzLmJpbmRBdHRyaWJMb2NhdGlvbigwLCAndl90ZXhfY29vcmQnKTtcclxuICAgICAgICAgICAgdGhpcy5nQnVmZmVyU2hhZGVyUGFzcy5iaW5kQXR0cmliTG9jYXRpb24oMSwgJ3ZfY29sb3InKTtcclxuICAgICAgICAgICAgdGhpcy5nQnVmZmVyU2hhZGVyUGFzcy5iaW5kQXR0cmliTG9jYXRpb24oMiwgJ3ZfYWxwaGEnKTtcclxuICAgICAgICAgICAgdGhpcy5saWdodFBhc3NTaGFkZXIuYmluZEF0dHJpYkxvY2F0aW9uKDAsICd2ZXJ0ZXhQb3NpdGlvbicpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IENvbnN0LkRFRkVSUkVEX01BWF9MSUdIVFM7ICsraW5kZXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlnaHRzTG9jYXRpb25zW2luZGV4XSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5saWdodFBhc3NTaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1TGlnaHRzWycgKyBpbmRleCArICddLnBvc2l0aW9uJyksXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMubGlnaHRQYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndUxpZ2h0c1snICsgaW5kZXggKyAnXS5jb2xvcicpLFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uOiB0aGlzLmxpZ2h0UGFzc1NoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3VMaWdodHNbJyArIGluZGV4ICsgJ10uYXR0ZW51YXRpb24nKSxcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHRoaXMubGlnaHRQYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndUxpZ2h0c1snICsgaW5kZXggKyAnXS5yYWRpdXMnKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyogU2V0dXAgcmVuZGVyIHRhcmdldHMgKi9cclxuICAgICAgICAgICAgdGhpcy5nQnVmZmVyRmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5nQnVmZmVyQ29sb3JUZXggPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ0J1ZmZlck5vcm1hbFRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5nQnVmZmVyRmJvKTtcclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5nQnVmZmVyQ29sb3JUZXgpO1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHJlbmRlcmVyLndpZHRoLCByZW5kZXJlci5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG5cclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5nQnVmZmVyTm9ybWFsVGV4KTtcclxuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCByZW5kZXJlci53aWR0aCwgcmVuZGVyZXIuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmV4dC5DT0xPUl9BVFRBQ0hNRU5UMF9XRUJHTCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5nQnVmZmVyQ29sb3JUZXgsIDApO1xyXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgdGhpcy5leHQuQ09MT1JfQVRUQUNITUVOVDFfV0VCR0wsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ0J1ZmZlck5vcm1hbFRleCwgMCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV4dC5kcmF3QnVmZmVyc1dFQkdMKFsgdGhpcy5leHQuQ09MT1JfQVRUQUNITUVOVDBfV0VCR0wsIHRoaXMuZXh0LkNPTE9SX0FUVEFDSE1FTlQxX1dFQkdMIF0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29tcGxldGUgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIDM2MDU0OiAnSW5jb21wbGV0ZSBBdHRhY2htZW50JyxcclxuICAgICAgICAgICAgICAgICAgICAzNjA1NTogJ01pc3NpbmcgQXR0YWNobWVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgMzYwNTc6ICdJbmNvbXBsZXRlIERpbWVuc2lvbnMnLFxyXG4gICAgICAgICAgICAgICAgICAgIDM2MDYxOiAnRnJhbWVidWZmZXIgVW5zdXBwb3J0ZWQnXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFtZWJ1ZmZlciBpbmNvbXBsZXRlLiBGcmFtZWJ1ZmZlciBzdGF0dXM6ICcgKyBlcnJvcnNbY29tcGxldGVdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICAgICAgVmVydGV4QnVmZmVyLlNldERpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBmb3JFYWNoTGlnaHQ6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxpZ2h0cyA9IHRoaXMubGlnaHRzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBsaWdodHMubGVuZ3RoO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhsaWdodHNbaW5kZXhdKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldCB6ICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3o7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldCB6IChuZXdaKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3ogPSBuZXdaO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBbWJpZW50TGlnaHRDb2xvcjogZnVuY3Rpb24gKHIsIGcsIGIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hbWJpZW50TGlnaHRDb2xvclIgPSByO1xyXG4gICAgICAgIHRoaXMuYW1iaWVudExpZ2h0Q29sb3JHID0gZztcclxuICAgICAgICB0aGlzLmFtYmllbnRMaWdodENvbG9yQiA9IGI7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1heExpZ2h0czogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2lzRGVmZXJyZWQpID8gQ29uc3QuREVGRVJSRURfTUFYX0xJR0hUUyA6IENvbnN0Lk1BWF9MSUdIVFM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldExpZ2h0Q291bnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlnaHRzLmxlbmd0aDtcclxuICAgIH0sXHJcblxyXG4gICAgaXNEZWZlcnJlZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEZWZlcnJlZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyogVGhpcyB3aWxsIHByb2JhYmx5IGJlIHJlbW92ZWQgbGF0ZXIgKi8gXHJcbiAgICBhZGRTcHJpdGU6IGZ1bmN0aW9uIChzcHJpdGUsIG5vcm1hbFRleHR1cmUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHNwcml0ZU5vcm1hbFBhaXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNwcml0ZVBvb2wubGVuZ3RoID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNwcml0ZU5vcm1hbFBhaXIgPSB0aGlzLnNwcml0ZVBvb2wucG9wKCk7XHJcbiAgICAgICAgICAgIHNwcml0ZU5vcm1hbFBhaXIuc2V0KHNwcml0ZSwgbm9ybWFsVGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNwcml0ZU5vcm1hbFBhaXIgPSBuZXcgU3ByaXRlTm9ybWFsUGFpcihzcHJpdGUsIG5vcm1hbFRleHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjZW5lLnN5cy5kaXNwbGF5TGlzdC5yZW1vdmUoc3ByaXRlKTtcclxuICAgICAgICB0aGlzLnNwcml0ZXMucHVzaChzcHJpdGVOb3JtYWxQYWlyKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlU3ByaXRlOiBmdW5jdGlvbiAoc3ByaXRlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnNwcml0ZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zcHJpdGVzW2luZGV4XS5zcHJpdGVSZWYgPT09IHNwcml0ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVQb29sLnB1c2godGhpcy5zcHJpdGVzW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzcHJpdGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZExpZ2h0OiBmdW5jdGlvbiAoeCwgeSwgeiwgcmFkaXVzLCByLCBnLCBiLCBhdHRlbnVhdGlvbilcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5saWdodHMubGVuZ3RoIDwgdGhpcy5nZXRNYXhMaWdodHMoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBsaWdodCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpZ2h0UG9vbC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaWdodCA9IHRoaXMubGlnaHRQb29sLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgbGlnaHQuc2V0KHgsIHksIHosIHJhZGl1cywgciwgZywgYiwgYXR0ZW51YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGlnaHQgPSBuZXcgTGlnaHQoeCwgeSwgeiwgcmFkaXVzLCByLCBnLCBiLCBhdHRlbnVhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5saWdodHMucHVzaChsaWdodCk7XHJcbiAgICAgICAgICAgIHJldHVybiBsaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUxpZ2h0OiBmdW5jdGlvbiAobGlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5saWdodHMuaW5kZXhPZihsaWdodCk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5saWdodFBvb2wucHVzaChsaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVMaWdodHM6IGZ1bmN0aW9uIChyZW5kZXJlciwgY2FtZXJhLCBzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2wgIT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbG9jYXRpb25zID0gdGhpcy5saWdodHNMb2NhdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciBsaWdodHMgPSB0aGlzLmxpZ2h0cztcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGxpZ2h0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHt4OiAwLCB5OiAwfTtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJlbmRlcmVyLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXg7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHRoaXMudVJlc29sdXRpb25Mb2MsIHJlbmRlcmVyLndpZHRoLCByZW5kZXJlci5oZWlnaHQpO1xyXG4gICAgICAgICAgICBnbC51bmlmb3JtM2YodGhpcy5hbWJpZW50TGlnaHRDb2xvckxvYywgdGhpcy5hbWJpZW50TGlnaHRDb2xvclIsIHRoaXMuYW1iaWVudExpZ2h0Q29sb3JHLCB0aGlzLmFtYmllbnRMaWdodENvbG9yQik7XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm00Zih0aGlzLnVDYW1lcmFMb2MsIGNhbWVyYS54LCBjYW1lcmEueSwgY2FtZXJhLnJvdGF0aW9uLCBjYW1lcmEuem9vbSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyArK2luZGV4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlnaHQgPSBsaWdodHNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhTWF0cml4LnRyYW5zZm9ybVBvaW50KGxpZ2h0LngsIGxpZ2h0LnksIHBvaW50KTtcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbnNbaW5kZXhdLmF0dGVudWF0aW9uLCBsaWdodC5hdHRlbnVhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYobG9jYXRpb25zW2luZGV4XS5yYWRpdXMsIGxpZ2h0LnJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2YobG9jYXRpb25zW2luZGV4XS5wb3NpdGlvbiwgcG9pbnQueCAtIChjYW1lcmEuc2Nyb2xsWCAqIGxpZ2h0LnNjcm9sbEZhY3RvclggKiBjYW1lcmEuem9vbSksIGhlaWdodCAtIChwb2ludC55IC0gKGNhbWVyYS5zY3JvbGxZICogbGlnaHQuc2Nyb2xsRmFjdG9yWSkgKiBjYW1lcmEuem9vbSksIGxpZ2h0LnopO1xyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmKGxvY2F0aW9uc1tpbmRleF0uY29sb3IsIGxpZ2h0LnIsIGxpZ2h0LmcsIGxpZ2h0LmIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0TGF5ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvbGlnaHRsYXllci9MaWdodExheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdhbWVPYmplY3RzLk9iamVjdFBvb2xcclxuXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcblxyXG4vLyAgQW4gT2JqZWN0IFBvb2xcclxuXHJcbnZhciBPYmplY3RQb29sID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIE9iamVjdFBvb2wgKG1hbmFnZXIsIGNsYXNzVHlwZSwgbWF4U2l6ZSwgY3JlYXRlQ2FsbGJhY2ssIGNhbGxiYWNrU2NvcGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG1heFNpemUgPT09IHVuZGVmaW5lZCkgeyBtYXhTaXplID0gLTE7IH1cclxuICAgICAgICBpZiAoY3JlYXRlQ2FsbGJhY2sgPT09IHVuZGVmaW5lZCkgeyBjcmVhdGVDYWxsYmFjayA9IHRoaXMubWFrZUdhbWVPYmplY3Q7IH1cclxuICAgICAgICBpZiAoY2FsbGJhY2tTY29wZSA9PT0gdW5kZWZpbmVkKSB7IGNhbGxiYWNrU2NvcGUgPSB0aGlzOyB9XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IG1hbmFnZXIuc2NlbmU7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGxheUxpc3QgPSB0aGlzLnNjZW5lLnN5cy5kaXNwbGF5TGlzdDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxpc3QgPSB0aGlzLnNjZW5lLnN5cy51cGRhdGVMaXN0O1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZUNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja1Njb3BlID0gY2FsbGJhY2tTY29wZTtcclxuXHJcbiAgICAgICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZTtcclxuXHJcbiAgICAgICAgdGhpcy5jbGFzc1R5cGUgPSBjbGFzc1R5cGU7XHJcblxyXG4gICAgICAgIHRoaXMuX2xpc3QgPSBbXTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZUdhbWVPYmplY3Q6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdhbWVPYmplY3QgPSBuZXcgdGhpcy5jbGFzc1R5cGUodGhpcy5zY2VuZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGxheUxpc3QuYWRkKGdhbWVPYmplY3QpO1xyXG5cclxuICAgICAgICBnYW1lT2JqZWN0LnNldEFjdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgZ2FtZU9iamVjdC5zZXRWaXNpYmxlKGZhbHNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBBZGQgYW4gZXhpc3RpbmcgR2FtZU9iamVjdCwgb3IgQXJyYXkgb3IgR3JvdXAgb2YgR2FtZU9iamVjdHMgaW50byB0aGlzIFBvb2xcclxuICAgIGFkZDogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbjtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQuaGFzT3duUHJvcGVydHkoJ2NoaWxkcmVuJykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkLmNoaWxkcmVuLmdldEFycmF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gWyBjaGlsZCBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubWF4U2l6ZSA+IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGZyZWUgPSB0aGlzLm1heFNpemUgLSB0aGlzLl9saXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW4gPiBmcmVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZW4gPSBmcmVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdC5wdXNoKGNoaWxkcmVuW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ3JlYXRlIFggbmV3IEdhbWVPYmplY3RzIGluIHRoaXMgUG9vbCBpZiB0aGVyZSBpcyBjYXBhY2l0eSB0byBkbyBzb1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAocXVhbnRpdHkpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFudGl0eTsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRnVsbCgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LnB1c2godGhpcy5jcmVhdGVDYWxsYmFjay5jYWxsKHRoaXMuY2FsbGJhY2tTY29wZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFByb3h5IG1ldGhvZCBmb3Igc3ViLWNsYXNzZXMgdG8gb3ZlcnJpZGVcclxuICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGcmVlR2FtZU9iamVjdCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRGcmVlR2FtZU9iamVjdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2FtZU9iamVjdCA9IHRoaXMuX2xpc3RbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWdhbWVPYmplY3QuYWN0aXZlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBnYW1lT2JqZWN0LnNldEFjdGl2ZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGdhbWVPYmplY3Quc2V0VmlzaWJsZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRnVsbCgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2FtZU9iamVjdCA9IHRoaXMuY3JlYXRlQ2FsbGJhY2suY2FsbCh0aGlzLmNhbGxiYWNrU2NvcGUpO1xyXG5cclxuICAgICAgICAgICAgZ2FtZU9iamVjdC5zZXRBY3RpdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3Quc2V0VmlzaWJsZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3QucHVzaChnYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIGtpbGw6IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLl9saXN0LmluZGV4T2YoZ2FtZU9iamVjdCkgPiAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3Quc2V0QWN0aXZlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGtpbGxBbmRIaWRlOiBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5fbGlzdC5pbmRleE9mKGdhbWVPYmplY3QpID4gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnYW1lT2JqZWN0LnNldEFjdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3Quc2V0VmlzaWJsZShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwdXJnZTogZnVuY3Rpb24gKGRlc3Ryb3lDaGlsZHJlbilcclxuICAgIHtcclxuICAgICAgICBpZiAoZGVzdHJveUNoaWxkcmVuID09PSB1bmRlZmluZWQpIHsgZGVzdHJveUNoaWxkcmVuID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgICBpZiAoZGVzdHJveUNoaWxkcmVuKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0W2ldLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9saXN0Lmxlbmd0aCA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5tYXhTaXplID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9saXN0Lmxlbmd0aCA9PT0gdGhpcy5tYXhTaXplKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWUsIGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBnYW1lT2JqZWN0ID0gdGhpcy5fbGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChnYW1lT2JqZWN0LmFjdGl2ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdC51cGRhdGUodGltZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3RhbFVzZWQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpc3RbaV0uYWN0aXZlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG90YWw7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRvdGFsRnJlZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgdXNlZCA9IHRoaXMuZ2V0VG90YWxVc2VkKCk7XHJcbiAgICAgICAgdmFyIGNhcGFjaXR5ID0gKHRoaXMubWF4U2l6ZSA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5tYXhTaXplO1xyXG5cclxuICAgICAgICByZXR1cm4gKGNhcGFjaXR5IC0gdXNlZCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGxheUxpc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVMaXN0ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tTY29wZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdGhpcy5fbGlzdC5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdFBvb2w7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvcG9vbC9PYmplY3RQb29sLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIE1lc2ggPSByZXF1aXJlKCcuLi9tZXNoL01lc2gnKTtcclxuXHJcbnZhciBRdWFkID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBNZXNoLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gUXVhZCAoc2NlbmUsIHgsIHksIHRleHR1cmUsIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIC8vICAwLS0tLTNcclxuICAgICAgICAvLyAgfFxcICBCfFxyXG4gICAgICAgIC8vICB8IFxcICB8XHJcbiAgICAgICAgLy8gIHwgIFxcIHxcclxuICAgICAgICAvLyAgfCBBIFxcfFxyXG4gICAgICAgIC8vICB8ICAgIFxcXHJcbiAgICAgICAgLy8gIDEtLS0tMlxyXG5cclxuICAgICAgICAvLyAgQXJyYXkgc2VxdWVuY2U6IHRsLCBibCwgYnIsIHRyXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gWyAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwIF07XHJcbiAgICAgICAgdmFyIHV2ID0gWyAwLCAwLCAwLCAxLCAxLCAxLCAxLCAwIF07XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBbIDAsIDEsIDIsIDAsIDIsIDMgXTtcclxuICAgICAgICB2YXIgY29sb3JzID0gWyAweGZmZmZmZiwgMHhmZmZmZmYsIDB4ZmZmZmZmLCAweGZmZmZmZiBdO1xyXG4gICAgICAgIHZhciBhbHBoYXMgPSBbIDEsIDEsIDEsIDEgXTtcclxuXHJcbiAgICAgICAgTWVzaC5jYWxsKHRoaXMsIHNjZW5lLCB4LCB5LCB2ZXJ0aWNlcywgdXYsIGluZGljZXMsIGNvbG9ycywgYWxwaGFzLCB0ZXh0dXJlLCBmcmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVzZXRQb3NpdGlvbigpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b3BMZWZ0WDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy52ZXJ0aWNlc1swXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbMF0gPSB2YWx1ZSAtIHRoaXMueDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3BMZWZ0WToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy52ZXJ0aWNlc1sxXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbMV0gPSB2YWx1ZSAtIHRoaXMueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3BSaWdodFg6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMudmVydGljZXNbNl07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzWzZdID0gdmFsdWUgLSB0aGlzLng7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9wUmlnaHRZOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLnZlcnRpY2VzWzddO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1s3XSA9IHZhbHVlIC0gdGhpcy55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbUxlZnRYOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLnZlcnRpY2VzWzJdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1syXSA9IHZhbHVlIC0gdGhpcy54O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbUxlZnRZOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLnZlcnRpY2VzWzNdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1szXSA9IHZhbHVlIC0gdGhpcy55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbVJpZ2h0WDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy52ZXJ0aWNlc1s0XTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbNF0gPSB2YWx1ZSAtIHRoaXMueDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b21SaWdodFk6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMudmVydGljZXNbNV07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzWzVdID0gdmFsdWUgLSB0aGlzLnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgICAgIC8vICB0bCwgYmwsIGJyLCB0clxyXG5cclxuICAgIHRvcExlZnRBbHBoYToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbHBoYXNbMF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFscGhhc1swXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcFJpZ2h0QWxwaGE6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGFzWzNdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hbHBoYXNbM10gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b21MZWZ0QWxwaGE6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGFzWzFdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hbHBoYXNbMV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b21SaWdodEFscGhhOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFscGhhc1syXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxwaGFzWzJdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9wTGVmdENvbG9yOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yc1swXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JzWzBdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9wUmlnaHRDb2xvcjoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvcnNbM107XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yc1szXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbUxlZnRDb2xvcjoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvcnNbMV07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yc1sxXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbVJpZ2h0Q29sb3I6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JzWzJdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xvcnNbMl0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUb3BMZWZ0OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRvcExlZnRYID0geDtcclxuICAgICAgICB0aGlzLnRvcExlZnRZID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRvcFJpZ2h0OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRvcFJpZ2h0WCA9IHg7XHJcbiAgICAgICAgdGhpcy50b3BSaWdodFkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib3R0b21MZWZ0WCA9IHg7XHJcbiAgICAgICAgdGhpcy5ib3R0b21MZWZ0WSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib3R0b21SaWdodFggPSB4O1xyXG4gICAgICAgIHRoaXMuYm90dG9tUmlnaHRZID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0UG9zaXRpb246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIGhhbGZXaWR0aCA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAvIDIpO1xyXG4gICAgICAgIHZhciBoYWxmSGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLmhlaWdodCAvIDIpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRvcExlZnQoeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuc2V0VG9wUmlnaHQoeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuc2V0Qm90dG9tTGVmdCh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5zZXRCb3R0b21SaWdodCh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldEFscGhhOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhbHBoYXMgPSB0aGlzLmFscGhhcztcclxuXHJcbiAgICAgICAgYWxwaGFzWzBdID0gMTtcclxuICAgICAgICBhbHBoYXNbMV0gPSAxO1xyXG4gICAgICAgIGFscGhhc1syXSA9IDE7XHJcbiAgICAgICAgYWxwaGFzWzNdID0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0Q29sb3JzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuXHJcbiAgICAgICAgY29sb3JzWzBdID0gMHhmZmZmZmY7XHJcbiAgICAgICAgY29sb3JzWzFdID0gMHhmZmZmZmY7XHJcbiAgICAgICAgY29sb3JzWzJdID0gMHhmZmZmZmY7XHJcbiAgICAgICAgY29sb3JzWzNdID0gMHhmZmZmZmY7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0UG9zaXRpb24oKTtcclxuICAgICAgICB0aGlzLnJlc2V0QWxwaGEoKTtcclxuICAgICAgICB0aGlzLnJlc2V0Q29sb3JzKCk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUXVhZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9xdWFkL1F1YWQuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFJlbmRlclBhc3MgV2lsbCBvbmx5IHdvcmsgd2l0aCBTcHJpdGUgYW5kIEltYWdlIEdhbWVPYmplY3RzLlxyXG5cclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cycpO1xyXG52YXIgUmVuZGVyID0gcmVxdWlyZSgnLi9SZW5kZXJQYXNzUmVuZGVyJyk7XHJcbnZhciBUZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1RleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlcicpO1xyXG5cclxuLy8gICBSZW5kZXJQYXNzIC0gdGhlIHVzZXIgaGFzIGEgaGlnaGVyIGNvbnRyb2wgb24gdGhlIHJlbmRlcmluZyBzaW5jZSB5b3UgZXhwbGljaXRseVxyXG4vLyAgIGluZGljYXRlIHdoYXQgaXMgcmVuZGVyZWQuIFJlbmRlclBhc3MgYWxzbyBoYXMgYSByZW5kZXIgdGFyZ2V0IGJ1dCB0aGUgZGlmZmVyZW5jZVxyXG4vLyAgIGlzIHRoYXQgd2hlbiBleHBsaWNpdGx5IHJlbmRlcmluZyBhbiBvYmplY3QgdG8gdGhlIHJlbmRlciBwYXNzIHRoZSBzaGFkZXIgZnJvbSB0aGF0XHJcbi8vICAgcmVuZGVyIHBhc3MgaXMgYXBwbGllZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGFkZGl0aXZlIHBhc3NlcyBhbmQgc3BlY2lmaWMgb2JqZWN0IGVmZmVjdHMuXHJcblxyXG52YXIgUmVuZGVyUGFzcyA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuRmxpcCxcclxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNjcm9sbEZhY3RvcixcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UaW50LFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBSZW5kZXJQYXNzIChzY2VuZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc2hhZGVyTmFtZSwgZnJhZ21lbnRTaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHNjZW5lLCAnUmVuZGVyUGFzcycpO1xyXG4gICAgICAgXHJcbiAgICAgICAgdmFyIHJlc291cmNlTWFuYWdlciA9IHNjZW5lLnN5cy5nYW1lLnJlbmRlcmVyLnJlc291cmNlTWFuYWdlcjtcclxuICAgICAgICB2YXIgcG90ID0gKCh3aWR0aCAmICh3aWR0aCAtIDEpKSA9PSAwICYmIChoZWlnaHQgJiAoaGVpZ2h0IC0gMSkpID09IDApO1xyXG4gICAgICAgIHZhciBnbDtcclxuICAgICAgICB2YXIgd3JhcDtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gc2NlbmUuc3lzLmdhbWUucmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5wYXNzUmVuZGVyVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFzc1NoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9O1xyXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKHJlc291cmNlTWFuYWdlciAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wgPSBzY2VuZS5zeXMuZ2FtZS5yZW5kZXJlci5nbDtcclxuICAgICAgICAgICAgd3JhcCA9IHBvdCA/IGdsLlJFUEVBVCA6IGdsLkNMQU1QX1RPX0VER0U7XHJcbiAgICAgICAgICAgIHRoaXMucGFzc1NoYWRlciA9IHJlc291cmNlTWFuYWdlci5jcmVhdGVTaGFkZXIoc2hhZGVyTmFtZSwge3ZlcnQ6IFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlci52ZXJ0LCBmcmFnOiBmcmFnbWVudFNoYWRlcn0pO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlVGV4dHVyZSgwLCBnbC5MSU5FQVIsIGdsLkxJTkVBUiwgd3JhcCwgd3JhcCwgZ2wuUkdCQSwgbnVsbCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFzc1JlbmRlclRhcmdldCA9IHJlc291cmNlTWFuYWdlci5jcmVhdGVSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgdGhpcy5yZW5kZXJUZXh0dXJlLCBudWxsKTtcclxuICAgICAgICAgICAgc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIuY3VycmVudFRleHR1cmVbMF0gPSBudWxsOyAvLyBmb3JjZSByZWJpbmRpbmcgb2YgcHJldiB0ZXh0dXJlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZsaXBZID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigwLCAwKTtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBzY2VuZS5zeXMuZ2FtZS5yZW5kZXJlci5hZGRDb250ZXh0UmVzdG9yZWRDYWxsYmFjayhmdW5jdGlvbiAocmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgICAgIHZhciB3cmFwID0gcG90ID8gZ2wuUkVQRUFUIDogZ2wuQ0xBTVBfVE9fRURHRTtcclxuICAgICAgICAgICAgX3RoaXMucGFzc1NoYWRlciA9IHJlc291cmNlTWFuYWdlci5jcmVhdGVTaGFkZXIoc2hhZGVyTmFtZSwge3ZlcnQ6IFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlci52ZXJ0LCBmcmFnOiBmcmFnbWVudFNoYWRlcn0pO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJUZXh0dXJlID0gcmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVRleHR1cmUoMCwgZ2wuTElORUFSLCBnbC5MSU5FQVIsIHdyYXAsIHdyYXAsIGdsLlJHQkEsIG51bGwsIF90aGlzLndpZHRoLCBfdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICBfdGhpcy5wYXNzUmVuZGVyVGFyZ2V0ID0gcmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVJlbmRlclRhcmdldChfdGhpcy53aWR0aCwgX3RoaXMuaGVpZ2h0LCBfdGhpcy5yZW5kZXJUZXh0dXJlLCBudWxsKTtcclxuICAgICAgICAgICAgX3RoaXMudW5pZm9ybXMgPSB7fTtcclxuICAgICAgICAgICAgX3RoaXMudGV4dHVyZXMgPSB7fTtcclxuICAgICAgICAgICAgc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIuY3VycmVudFRleHR1cmVbMF0gPSBudWxsOyAvLyBmb3JjZSByZWJpbmRpbmcgb2YgcHJldiB0ZXh0dXJlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyQ29sb3JCdWZmZXI6IGZ1bmN0aW9uIChyLCBnLCBiLCBhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgICAgIGlmIChnbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5wYXNzUmVuZGVyVGFyZ2V0LmZyYW1lYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcclxuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhckRlcHRoU3RlbmNpbEJ1ZmZlcnM6IGZ1bmN0aW9uIChkZXB0aCwgc3RlbmNpbClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgICAgICBpZiAoZ2wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMucGFzc1JlbmRlclRhcmdldC5mcmFtZWJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyRGVwdGgoZGVwdGgpO1xyXG4gICAgICAgICAgICBnbC5jbGVhclN0ZW5jaWwoc3RlbmNpbCk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkRFUFRIX0JVRkZFUl9CSVQgfCBnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXJBbGxCdWZmZXJzOiBmdW5jdGlvbiAociwgZywgYiwgYSwgZGVwdGgsIHN0ZW5jaWwpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuXHJcbiAgICAgICAgaWYgKGdsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLnBhc3NSZW5kZXJUYXJnZXQuZnJhbWVidWZmZXJPYmplY3QpO1xyXG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKHIsIGcsIGIsIGEpO1xyXG4gICAgICAgICAgICBnbC5jbGVhckRlcHRoKGRlcHRoKTtcclxuICAgICAgICAgICAgZ2wuY2xlYXJTdGVuY2lsKHN0ZW5jaWwpO1xyXG4gICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcclxuXHJcbiAgICAgICAgaWYgKGdsICYmICFyZW5kZXJlci5jb250ZXh0TG9zdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFJlbmRlcmVyKHRoaXMucmVuZGVyZXIuc3ByaXRlQmF0Y2gsIG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICByZW5kZXJlci5zcHJpdGVCYXRjaC5hZGRTcHJpdGUoZ2FtZU9iamVjdCwgY2FtZXJhKTtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMudGV4dHVyZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlRGF0YSA9IHRoaXMudGV4dHVyZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50KGtleSwgdGV4dHVyZURhdGEudW5pdCk7XHJcbiAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZURhdGEudW5pdCk7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlRGF0YS50ZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNwcml0ZUJhdGNoLmZsdXNoKHRoaXMucGFzc1NoYWRlciwgdGhpcy5wYXNzUmVuZGVyVGFyZ2V0LmZyYW1lYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmRlclJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcclxuXHJcbiAgICAgICAgaWYgKGdsICYmICFyZW5kZXJlci5jb250ZXh0TG9zdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFJlbmRlcmVyKHRoaXMucmVuZGVyZXIuc3ByaXRlQmF0Y2gsIG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICByZW5kZXJlci5zcHJpdGVCYXRjaC5hZGRUaWxlVGV4dHVyZVJlY3QoXHJcbiAgICAgICAgICAgICAgICBudWxsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxLjAsIDB4RkZGRkZGRkYsIHRoaXMuc2Nyb2xsRmFjdG9yWCwgdGhpcy5zY3JvbGxGYWN0b3JZLFxyXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgY2FtZXJhLCBudWxsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnRleHR1cmVzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZURhdGEgPSB0aGlzLnRleHR1cmVzW2tleV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludChrZXksIHRleHR1cmVEYXRhLnVuaXQpO1xyXG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVEYXRhLnVuaXQpO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZURhdGEudGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZW5kZXJlci5zcHJpdGVCYXRjaC5mbHVzaCh0aGlzLnBhc3NTaGFkZXIsIHRoaXMucGFzc1JlbmRlclRhcmdldC5mcmFtZWJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSZW5kZXJUZXh0dXJlQXQ6IGZ1bmN0aW9uIChyZW5kZXJUZXh0dXJlLCBzYW1wbGVyTmFtZSwgdW5pdClcclxuICAgIHtcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG5cclxuICAgICAgICBpZiAoZ2wgJiYgIXJlbmRlcmVyLmNvbnRleHRMb3N0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLyogVGV4dHVyZSAxIGlzIHJlc2VydmVkIGZvciBQaGFzZXJzIE1haW4gUmVuZGVyZXIgKi9cclxuICAgICAgICAgICAgdW5pdCA9ICh1bml0ID4gMCkgPyB1bml0IDogMTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlc1tzYW1wbGVyTmFtZV0gPSB7IHRleHR1cmU6IHJlbmRlclRleHR1cmUudGV4dHVyZSwgdW5pdDogdW5pdCB9O1xyXG4gICAgICAgICAgICAvL3RoaXMuc2V0SW50KHNhbXBsZXJOYW1lLCB1bml0KTtcclxuICAgICAgICAgICAgLy9nbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdW5pdCk7XHJcbiAgICAgICAgICAgIC8vZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGV4dHVyZS50ZXh0dXJlKTtcclxuICAgICAgICAgICAgLy9nbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVuaWZvcm1Mb2NhdGlvbjogZnVuY3Rpb24gKHVuaWZvcm1OYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYXNzU2hhZGVyID0gdGhpcy5wYXNzU2hhZGVyO1xyXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XHJcbiAgICAgICAgdmFyIGxvY2F0aW9uO1xyXG5cclxuICAgICAgICBpZiAodW5pZm9ybU5hbWUgaW4gdW5pZm9ybXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsb2NhdGlvbiA9IHVuaWZvcm1zW3VuaWZvcm1OYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbG9jYXRpb24gPSBwYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zW3VuaWZvcm1OYW1lXSA9IGxvY2F0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGbG9hdDogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYXNzU2hhZGVyID0gdGhpcy5wYXNzU2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAocGFzc1NoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhc3NTaGFkZXIuc2V0Q29uc3RhbnRGbG9hdDEodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RmxvYXQyOiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHBhc3NTaGFkZXIgPSB0aGlzLnBhc3NTaGFkZXI7XHJcblxyXG4gICAgICAgIGlmIChwYXNzU2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFzc1NoYWRlci5zZXRDb25zdGFudEZsb2F0Mih0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSksIHgsIHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGbG9hdDM6IGZ1bmN0aW9uICh1bmlmb3JtTmFtZSwgeCwgeSwgeilcclxuICAgIHtcclxuICAgICAgICB2YXIgcGFzc1NoYWRlciA9IHRoaXMucGFzc1NoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKHBhc3NTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXNzU2hhZGVyLnNldENvbnN0YW50RmxvYXQzKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgeCwgeSwgeik7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZsb2F0NDogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5LCB6LCB3KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYXNzU2hhZGVyID0gdGhpcy5wYXNzU2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAocGFzc1NoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhc3NTaGFkZXIuc2V0Q29uc3RhbnRGbG9hdDQodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5LCB6LCB3KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW50OiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIHgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHBhc3NTaGFkZXIgPSB0aGlzLnBhc3NTaGFkZXI7XHJcblxyXG4gICAgICAgIGlmIChwYXNzU2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFzc1NoYWRlci5zZXRDb25zdGFudEludDEodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW50MjogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYXNzU2hhZGVyID0gdGhpcy5wYXNzU2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAocGFzc1NoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhc3NTaGFkZXIuc2V0Q29uc3RhbnRJbnQyKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgeCwgeSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEludDM6IGZ1bmN0aW9uICh1bmlmb3JtTmFtZSwgeCwgeSwgeilcclxuICAgIHtcclxuICAgICAgICB2YXIgcGFzc1NoYWRlciA9IHRoaXMucGFzc1NoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKHBhc3NTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXNzU2hhZGVyLnNldENvbnN0YW50SW50Myh0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSksIHgsIHksIHopO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRJbnQ0OiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIHgsIHksIHosIHcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHBhc3NTaGFkZXIgPSB0aGlzLnBhc3NTaGFkZXI7XHJcblxyXG4gICAgICAgIGlmIChwYXNzU2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFzc1NoYWRlci5zZXRDb25zdGFudEludDQodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5LCB6LCB3KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TWF0cml4MngyOiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIG1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgcGFzc1NoYWRlciA9IHRoaXMucGFzc1NoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKHBhc3NTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXNzU2hhZGVyLnNldENvbnN0YW50TWF0cml4MngyKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgbWF0cml4KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TWF0cml4M3gzOiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIG1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgcGFzc1NoYWRlciA9IHRoaXMucGFzc1NoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKHBhc3NTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXNzU2hhZGVyLnNldENvbnN0YW50TWF0cml4M3gzKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgbWF0cml4KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TWF0cml4NHg0OiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIG1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgcGFzc1NoYWRlciA9IHRoaXMucGFzc1NoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKHBhc3NTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXNzU2hhZGVyLnNldENvbnN0YW50TWF0cml4NHg0KHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgbWF0cml4KTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJQYXNzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3JlbmRlcnBhc3MvUmVuZGVyUGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi8uLi8uLi9kb20vQ2FudmFzUG9vbCcpO1xyXG52YXIgVGV4dFJlbmRlciA9IHJlcXVpcmUoJy4vVGV4dFJlbmRlcicpO1xyXG52YXIgVGV4dFN0eWxlID0gcmVxdWlyZSgnLi4vVGV4dFN0eWxlJyk7XHJcbnZhciBHZXRUZXh0U2l6ZSA9IHJlcXVpcmUoJy4uL0dldFRleHRTaXplJyk7XHJcblxyXG52YXIgVGV4dCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuRmxpcCxcclxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNjcm9sbEZhY3RvcixcclxuICAgICAgICBDb21wb25lbnRzLlRpbnQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIFRleHRSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBUZXh0IChzY2VuZSwgeCwgeSwgdGV4dCwgc3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cclxuICAgICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSB7IHRleHQgPSAnICc7IH1cclxuXHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHNjZW5lLCAnVGV4dCcpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuc2V0T3JpZ2luKDAsIDApO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJvcGVydHkge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCB0aGUgdGV4dCBpcyByZW5kZXJlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKHRoaXMpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJvcGVydHkge0hUTUxDYW52YXNFbGVtZW50fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgb2YgdGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgdGhlIHRleHQgaXMgcmVuZGVyZWQgdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdHlsZSA9IG5ldyBUZXh0U3R5bGUodGhpcywgc3R5bGUpO1xyXG5cclxuICAgICAgICB0aGlzLmF1dG9Sb3VuZCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdGhhdCBpcyB1c2VkIHRvIHNwbGl0IHRoZSB0ZXh0IHVwIGludG8gbGluZXMsIGluXHJcbiAgICAgICAgICogbXVsdGktbGluZSB0ZXh0LiBCeSBkZWZhdWx0IHRoaXMgaXMgYC8oPzpcXHJcXG58XFxyfFxcbikvYC5cclxuICAgICAgICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIFJlZ0V4cCB0byBiZSBhbnl0aGluZyBlbHNlIHRoYXQgeW91IG1heSBuZWVkLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzcGxpdFJlZ0V4cFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3BsaXRSZWdFeHAgPSAvKD86XFxyXFxufFxccnxcXG4pLztcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0ID0gKEFycmF5LmlzQXJyYXkodGV4dCkpID8gdGV4dC5qb2luKCdcXG4nKSA6IHRleHQ7XHJcblxyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogU3BlY2lmeSBhIHBhZGRpbmcgdmFsdWUgd2hpY2ggaXMgYWRkZWQgdG8gdGhlIGxpbmUgd2lkdGggYW5kIGhlaWdodCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBUZXh0IHNpemUuXHJcbiAgICAgICAgKiBBbGxvd3MgeW91IHRvIGFkZCBleHRyYSBzcGFjaW5nIGlmIFBoYXNlciBpcyB1bmFibGUgdG8gYWNjdXJhdGVseSBkZXRlcm1pbmUgdGhlIHRydWUgZm9udCBkaW1lbnNpb25zLlxyXG4gICAgICAgICogQHByb3BlcnR5IHtQaGFzZXIuUG9pbnR9IHBhZGRpbmdcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gMTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDE7XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzVGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGV4dCAhPT0gJycpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIuYWRkQ29udGV4dFJlc3RvcmVkQ2FsbGJhY2soZnVuY3Rpb24gKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNhbnZhc1RleHR1cmUgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnRleHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRTdHlsZShzdHlsZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZvbnQ6IGZ1bmN0aW9uIChmb250KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldEZvbnQoZm9udCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZpeGVkU2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0Rml4ZWRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uIChjb2xvcilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3IpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGaWxsOiBmdW5jdGlvbiAoY29sb3IpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0RmlsbChjb2xvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFN0cm9rZTogZnVuY3Rpb24gKGNvbG9yLCB0aGlja25lc3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0U3Ryb2tlKGNvbG9yLCB0aGlja25lc3MpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaGFkb3c6IGZ1bmN0aW9uICh4LCB5LCBjb2xvciwgYmx1ciwgc2hhZG93U3Ryb2tlLCBzaGFkb3dGaWxsKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldFNoYWRvdyh4LCB5LCBjb2xvciwgYmx1ciwgc2hhZG93U3Ryb2tlLCBzaGFkb3dGaWxsKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZG93T2Zmc2V0OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRTaGFkb3dPZmZzZXQoeCwgeSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRvd0NvbG9yOiBmdW5jdGlvbiAoY29sb3IpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0U2hhZG93Q29sb3IoY29sb3IpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaGFkb3dCbHVyOiBmdW5jdGlvbiAoYmx1cilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRTaGFkb3dCbHVyKGJsdXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaGFkb3dTdHJva2U6IGZ1bmN0aW9uIChlbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldFNoYWRvd1N0cm9rZShlbmFibGVkKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZG93RmlsbDogZnVuY3Rpb24gKGVuYWJsZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0U2hhZG93RmlsbChlbmFibGVkKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0QWxpZ246IGZ1bmN0aW9uIChhbGlnbilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRBbGlnbihhbGlnbik7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldE1heExpbmVzOiBmdW5jdGlvbiAobWF4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldE1heExpbmVzKG1heCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVRleHQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgdmFyIHNpemUgPSBzdHlsZS5tZXRyaWNzO1xyXG5cclxuICAgICAgICB2YXIgb3V0cHV0VGV4dCA9IHRoaXMudGV4dDtcclxuXHJcbiAgICAgICAgLy8gaWYgKHN0eWxlLndvcmRXcmFwKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgb3V0cHV0VGV4dCA9IHRoaXMucnVuV29yZFdyYXAodGhpcy50ZXh0KTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIC8vICBTcGxpdCB0ZXh0IGludG8gbGluZXNcclxuICAgICAgICB2YXIgbGluZXMgPSBvdXRwdXRUZXh0LnNwbGl0KHRoaXMuc3BsaXRSZWdFeHApO1xyXG5cclxuICAgICAgICB2YXIgdGV4dFNpemUgPSBHZXRUZXh0U2l6ZSh0aGlzLCBzaXplLCBsaW5lcyk7XHJcblxyXG4gICAgICAgIGlmICghc3R5bGUuZml4ZWRXaWR0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0ZXh0U2l6ZS53aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghc3R5bGUuZml4ZWRIZWlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplLmhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlT3JpZ2luKCk7XHJcblxyXG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5wYWRkaW5nO1xyXG5cclxuICAgICAgICB2YXIgdyA9ICh0ZXh0U2l6ZS53aWR0aCArIChwYWRkaW5nLnggKiAyKSkgKiB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgdmFyIGggPSAodGV4dFNpemUuaGVpZ2h0ICsgKHBhZGRpbmcueSAqIDIpKSAqIHRoaXMucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gdyB8fCBjYW52YXMuaGVpZ2h0ICE9PSBoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdztcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0eWxlLmJhY2tncm91bmRDb2xvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3R5bGUuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3R5bGUuc3luY0ZvbnQoY2FudmFzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XHJcblxyXG4gICAgICAgIC8vICBBcHBseSBwYWRkaW5nXHJcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUocGFkZGluZy54LCBwYWRkaW5nLnkpO1xyXG5cclxuICAgICAgICB2YXIgbGluZVBvc2l0aW9uWDtcclxuICAgICAgICB2YXIgbGluZVBvc2l0aW9uWTtcclxuXHJcbiAgICAgICAgLy8gIERyYXcgdGV4dCBsaW5lIGJ5IGxpbmVcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRTaXplLmxpbmVzOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcclxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSA9IChzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyICsgaSAqIHRleHRTaXplLmxpbmVIZWlnaHQpICsgc2l6ZS5hc2NlbnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgKz0gKHRleHRTaXplLmxpbmVTcGFjaW5nICogaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0JylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSB0ZXh0U2l6ZS53aWR0aCAtIHRleHRTaXplLmxpbmVXaWR0aHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09ICdjZW50ZXInKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9ICh0ZXh0U2l6ZS53aWR0aCAtIHRleHRTaXplLmxpbmVXaWR0aHNbaV0pIC8gMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JvdW5kKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YID0gTWF0aC5yb3VuZChsaW5lUG9zaXRpb25YKTtcclxuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgPSBNYXRoLnJvdW5kKGxpbmVQb3NpdGlvblkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLnN5bmNTaGFkb3coY29udGV4dCwgc3R5bGUuc2hhZG93U3Ryb2tlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQobGluZXNbaV0sIGxpbmVQb3NpdGlvblgsIGxpbmVQb3NpdGlvblkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3R5bGUuZmlsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5zeW5jU2hhZG93KGNvbnRleHQsIHN0eWxlLnNoYWRvd0ZpbGwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbaV0sIGxpbmVQb3NpdGlvblgsIGxpbmVQb3NpdGlvblkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRleHRNZXRyaWNzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldFRleHRNZXRyaWNzKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgb3V0ID0gQ29tcG9uZW50cy5Ub0pTT04odGhpcyk7XHJcblxyXG4gICAgICAgIC8vICBFeHRyYSBUZXh0IGRhdGEgaXMgYWRkZWQgaGVyZVxyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICAgICAgYXV0b1JvdW5kOiB0aGlzLmF1dG9Sb3VuZCxcclxuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxyXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5zdHlsZS50b0pTT04oKSxcclxuICAgICAgICAgICAgcmVzb2x1dGlvbjogdGhpcy5yZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiB7XHJcbiAgICAgICAgICAgICAgICB4OiB0aGlzLnBhZGRpbmcueCxcclxuICAgICAgICAgICAgICAgIHk6IHRoaXMucGFkZGluZy55XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBvdXQuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIFRpbGVtYXBSZW5kZXIgPSByZXF1aXJlKCcuL1RpbGVtYXBSZW5kZXInKTtcclxudmFyIFRpbGUgPSByZXF1aXJlKCcuL1RpbGUnKTtcclxuXHJcbnZhciBUaWxlbWFwID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBHYW1lT2JqZWN0LFxyXG5cclxuICAgIE1peGluczogW1xyXG4gICAgICAgIENvbXBvbmVudHMuQWxwaGEsXHJcbiAgICAgICAgQ29tcG9uZW50cy5CbGVuZE1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5GbGlwLFxyXG4gICAgICAgIENvbXBvbmVudHMuR2V0Qm91bmRzLFxyXG4gICAgICAgIENvbXBvbmVudHMuT3JpZ2luLFxyXG4gICAgICAgIENvbXBvbmVudHMuUmVuZGVyVGFyZ2V0LFxyXG4gICAgICAgIENvbXBvbmVudHMuU2NhbGVNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcclxuICAgICAgICBDb21wb25lbnRzLlRleHR1cmUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2Nyb2xsRmFjdG9yLFxyXG4gICAgICAgIFRpbGVtYXBSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBUaWxlbWFwIChzY2VuZSwgbWFwRGF0YSwgeCwgeSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCBtYXBXaWR0aCwgbWFwSGVpZ2h0LCB0aWxlQm9yZGVyLCB0ZXh0dXJlLCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc2NlbmUsICdUaWxlbWFwJyk7XHJcblxyXG4gICAgICAgIHRoaXMubWFwRGF0YSA9IChtYXBEYXRhICE9PSBudWxsKSA/IG5ldyBVaW50MzJBcnJheShtYXBEYXRhKSA6IG5ldyBVaW50MzJBcnJheShtYXBXaWR0aCAqIG1hcEhlaWdodCk7XHJcbiAgICAgICAgdGhpcy50aWxlV2lkdGggPSB0aWxlV2lkdGg7XHJcbiAgICAgICAgdGhpcy50aWxlSGVpZ2h0ID0gdGlsZUhlaWdodDtcclxuICAgICAgICB0aGlzLm1hcFdpZHRoID0gbWFwV2lkdGg7XHJcbiAgICAgICAgdGhpcy5tYXBIZWlnaHQgPSBtYXBIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy50aWxlQXJyYXkgPSBbXTtcclxuICAgICAgICB0aGlzLmN1bGxlZFRpbGVzID0gW107XHJcbiAgICAgICAgdGhpcy50aWxlQm9yZGVyID0gdGlsZUJvcmRlcjtcclxuICAgICAgICB0aGlzLnNldFRleHR1cmUodGV4dHVyZSwgZnJhbWUpO1xyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5zZXRTaXplVG9GcmFtZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0T3JpZ2luKCk7XHJcbiAgICAgICAgdGhpcy5zZXRTaXplKHRpbGVXaWR0aCAqIG1hcFdpZHRoLCB0aWxlSGVpZ2h0ICogbWFwSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmJ1aWxkVGlsZW1hcCghIXNjZW5lLnN5cy5nYW1lLnJlbmRlcmVyLmdsKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG90YWxUaWxlQ291bnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZUFycmF5Lmxlbmd0aDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VmlzaWJsZVRpbGVDb3VudDogZnVuY3Rpb24gKGNhbWVyYSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdWxsKGNhbWVyYSkubGVuZ3RoO1xyXG4gICAgfSxcclxuXHJcbiAgICBidWlsZFRpbGVtYXA6IGZ1bmN0aW9uIChjZW50ZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRpbGVBcnJheSA9IHRoaXMudGlsZUFycmF5O1xyXG4gICAgICAgIHZhciBtYXBEYXRhID0gdGhpcy5tYXBEYXRhO1xyXG4gICAgICAgIHZhciBib3JkZXIgPSB0aGlzLnRpbGVCb3JkZXI7XHJcbiAgICAgICAgdmFyIHRpbGVXaWR0aCA9IHRoaXMudGlsZVdpZHRoO1xyXG4gICAgICAgIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy50aWxlSGVpZ2h0O1xyXG4gICAgICAgIHZhciB0aWxlV2lkdGhCb3JkZXIgPSB0aWxlV2lkdGggKyBib3JkZXIgKiAyO1xyXG4gICAgICAgIHZhciB0aWxlSGVpZ2h0Qm9yZGVyID0gdGlsZUhlaWdodCArIGJvcmRlciAqIDI7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy50ZXh0dXJlLnNvdXJjZVswXS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy50ZXh0dXJlLnNvdXJjZVswXS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIG1hcFdpZHRoID0gdGhpcy5tYXBXaWR0aDtcclxuICAgICAgICB2YXIgbWFwSGVpZ2h0ID0gdGhpcy5tYXBIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHNldFdpZHRoID0gd2lkdGggLyB0aWxlV2lkdGg7XHJcbiAgICAgICAgdmFyIHRpbGVXaWR0aEJvcmRlckhhbGYgPSB0aWxlV2lkdGhCb3JkZXIgKiAwLjU7XHJcbiAgICAgICAgdmFyIHRpbGVIZWlnaHRCb3JkZXJIYWxmID0gdGlsZUhlaWdodEJvcmRlciAqIDAuNTtcclxuXHJcbiAgICAgICAgaWYgKCFjZW50ZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aWxlV2lkdGhCb3JkZXJIYWxmID0gMDtcclxuICAgICAgICAgICAgdGlsZUhlaWdodEJvcmRlckhhbGYgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGlsZUFycmF5Lmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgbWFwSGVpZ2h0OyArK3kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1hcFdpZHRoOyArK3gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aWxlSWQgPSBtYXBEYXRhW3kgKiBtYXBXaWR0aCArIHhdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3R4ID0gKCgodGlsZUlkICUgc2V0V2lkdGgpfDApICogdGlsZVdpZHRoQm9yZGVyKSArIHRpbGVXaWR0aEJvcmRlckhhbGY7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdHkgPSAoKCh0aWxlSWQgLyBzZXRXaWR0aCl8MCkgKiB0aWxlSGVpZ2h0Qm9yZGVyKSArIHRpbGVIZWlnaHRCb3JkZXJIYWxmO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR4ID0geCAqIHRpbGVXaWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciB0eSA9IHkgKiB0aWxlSGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIHRpbGVBcnJheS5wdXNoKG5ldyBUaWxlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogeCArIHksXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRpbGVJZCxcclxuICAgICAgICAgICAgICAgICAgICB4OiB0eCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB0eSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGlsZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGlsZUhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZVg6IHJlY3R4LFxyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lWTogcmVjdHksXHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVXaWR0aDogdGlsZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSGVpZ2h0OiB0aWxlSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVXaWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZUhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcjogYm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcjogY2VudGVyXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGN1bGw6IGZ1bmN0aW9uIChjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGN1bGxlZFRpbGVzID0gdGhpcy5jdWxsZWRUaWxlcztcclxuICAgICAgICB2YXIgdGlsZXMgPSB0aGlzLnRpbGVBcnJheTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGlsZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzY3JvbGxYID0gY2FtZXJhLnNjcm9sbFggKiB0aGlzLnNjcm9sbEZhY3Rvclg7XHJcbiAgICAgICAgdmFyIHNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWSAqIHRoaXMuc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICB2YXIgY2FtZXJhVyA9IGNhbWVyYS53aWR0aDtcclxuICAgICAgICB2YXIgY2FtZXJhSCA9IGNhbWVyYS5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGN1bGxlZFRpbGVzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRpbGVzW2luZGV4XTtcclxuICAgICAgICAgICAgdmFyIHRpbGVYID0gdGlsZS54IC0gc2Nyb2xsWDtcclxuICAgICAgICAgICAgdmFyIHRpbGVZID0gdGlsZS55IC0gc2Nyb2xsWTtcclxuICAgICAgICAgICAgdmFyIHRpbGVXID0gdGlsZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIHRpbGVIID0gdGlsZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBjdWxsVyA9IGNhbWVyYVcgKyB0aWxlVztcclxuICAgICAgICAgICAgdmFyIGN1bGxIID0gY2FtZXJhSCArIHRpbGVIO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRpbGUudmlzaWJsZSAmJlxyXG4gICAgICAgICAgICAgICAgdGlsZVggPiAtdGlsZVcgJiYgdGlsZVkgPiAtdGlsZUggJiZcclxuICAgICAgICAgICAgICAgIHRpbGVYIDwgY3VsbFcgJiYgdGlsZVkgPCBjdWxsSClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3VsbGVkVGlsZXMucHVzaCh0aWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGN1bGxlZFRpbGVzO1xyXG4gICAgfSxcclxuXHJcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50aWxlQXJyYXkuZm9yRWFjaChjYWxsYmFjayk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBSZXR1cm5zIE9iamVjdCBjb250YWluaW5nOlxyXG4gICAgLy8gIHtcclxuICAgIC8vICAgICAgYWxwaGFcclxuICAgIC8vICAgICAgZnJhbWVXaWR0aCxcclxuICAgIC8vICAgICAgZnJhbWVIZWlnaHQsXHJcbiAgICAvLyAgICAgIGZyYW1lWFxyXG4gICAgLy8gICAgICBmcmFtZVlcclxuICAgIC8vICAgICAgaWRcclxuICAgIC8vICAgICAgaW5kZXggPSB0aGUgdGlsZSBpbiB0aGUgdGlsc2V0IHRvIHJlbmRlclxyXG4gICAgLy8gICAgICB0ZXh0dXJlV2lkdGggPSB0aWxlc2V0IHRleHR1cmUgc2l6ZVxyXG4gICAgLy8gICAgICB0ZXh0dXJlSGVpZ2h0XHJcbiAgICAvLyAgICAgIHRpbnRcclxuICAgIC8vICAgICAgdmlzaWJsZVxyXG4gICAgLy8gICAgICB3aWR0aFxyXG4gICAgLy8gICAgICB4XHJcbiAgICAvLyAgICAgIHlcclxuICAgIC8vICB9XHJcblxyXG4gICAgZ2V0VGlsZUF0OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaXggPSAoeHwwKTtcclxuICAgICAgICB2YXIgaXkgPSAoeXwwKTtcclxuICAgICAgICB2YXIgdGlsZXMgPSB0aGlzLnRpbGVBcnJheTtcclxuICAgICAgICB2YXIgaW5kZXggPSBpeSAqIHRoaXMubWFwV2lkdGggKyBpeDtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4IDwgdGlsZXMubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRpbGVzW2luZGV4XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUaWxlQXRJbmRleDogZnVuY3Rpb24gKGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0aWxlcyA9IHRoaXMudGlsZUFycmF5O1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPCB0aWxlcy5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGlsZXNbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZW1hcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL2R5bmFtaWMvVGlsZW1hcC5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cycpO1xyXG52YXIgU3RhdGljVGlsZW1hcFJlbmRlciA9IHJlcXVpcmUoJy4vU3RhdGljVGlsZW1hcFJlbmRlcicpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvdGlsZW1hcHJlbmRlcmVyL2NvbnN0Jyk7XHJcblxyXG52YXIgU3RhdGljVGlsZW1hcCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuRmxpcCxcclxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBDb21wb25lbnRzLlNjcm9sbEZhY3RvcixcclxuICAgICAgICBTdGF0aWNUaWxlbWFwUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gU3RhdGljVGlsZW1hcCAoc2NlbmUsIG1hcERhdGEsIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgbWFwV2lkdGgsIG1hcEhlaWdodCwgdGlsZUJvcmRlciwgdGV4dHVyZSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHNjZW5lLCAnU3RhdGljVGlsZW1hcCcpO1xyXG5cclxuICAgICAgICB0aGlzLnZibyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5nbCA9IHNjZW5lLnN5cy5nYW1lLnJlbmRlcmVyLmdsID8gc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIuZ2wgOiBudWxsO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyID0gc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIudGlsZW1hcFJlbmRlcmVyID8gc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIudGlsZW1hcFJlbmRlcmVyIDogbnVsbDtcclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IHRoaXMuZ2wgPyBzY2VuZS5zeXMuZ2FtZS5yZW5kZXJlci5yZXNvdXJjZU1hbmFnZXIgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tYXBEYXRhID0gbWFwRGF0YTtcclxuICAgICAgICB0aGlzLnRpbGVXaWR0aCA9IHRpbGVXaWR0aDtcclxuICAgICAgICB0aGlzLnRpbGVIZWlnaHQgPSB0aWxlSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMubWFwV2lkdGggPSBtYXBXaWR0aDtcclxuICAgICAgICB0aGlzLm1hcEhlaWdodCA9IG1hcEhlaWdodDtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmN1bGxTdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdWxsRW5kID0gMDtcclxuICAgICAgICB0aGlzLnRpbGVCb3JkZXIgPSB0aWxlQm9yZGVyO1xyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZSh0ZXh0dXJlLCBmcmFtZSk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgICAgICB0aGlzLnNldFNpemVUb0ZyYW1lKCk7XHJcbiAgICAgICAgdGhpcy5zZXRPcmlnaW4oKTtcclxuICAgICAgICB0aGlzLnNldFNpemUodGlsZVdpZHRoICogbWFwV2lkdGgsIHRpbGVIZWlnaHQgKiBtYXBIZWlnaHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgc2NlbmUuc3lzLmdhbWUucmVuZGVyZXIuYWRkQ29udGV4dFJlc3RvcmVkQ2FsbGJhY2soZnVuY3Rpb24gKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRpbGVUZXh0dXJlID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBfdGhpcy52Ym8gPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5nbCA9IHJlbmRlcmVyLmdsO1xyXG4gICAgICAgICAgICBfdGhpcy50aWxlbWFwUmVuZGVyZXIgPSByZW5kZXJlci50aWxlbWFwUmVuZGVyZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwbG9hZDogZnVuY3Rpb24gKGNhbWVyYSkgXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICAgICAgICAgIHZhciB2Ym8gPSB0aGlzLnZibztcclxuICAgICAgICAgICAgICAgIHZhciBtYXBXaWR0aCA9IHRoaXMubWFwV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFwSGVpZ2h0ID0gdGhpcy5tYXBIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9yZGVyID0gdGhpcy50aWxlQm9yZGVyO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVXaWR0aCA9IHRoaXMudGlsZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVIZWlnaHQgPSB0aGlzLnRpbGVIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlsZVdpZHRoQm9yZGVyID0gdGlsZVdpZHRoICsgYm9yZGVyICogMjtcclxuICAgICAgICAgICAgICAgIHZhciB0aWxlSGVpZ2h0Qm9yZGVyID0gdGlsZUhlaWdodCArIGJvcmRlciAqIDI7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyRGF0YSA9IHRoaXMuYnVmZmVyRGF0YTtcclxuICAgICAgICAgICAgICAgIHZhciBidWZmZXJGMzIsIGJ1ZmZlclUzMjtcclxuICAgICAgICAgICAgICAgIHZhciB2b2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnRleHR1cmUuc291cmNlWzBdLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMudGV4dHVyZS5zb3VyY2VbMF0uaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNldFdpZHRoID0gd2lkdGggLyB0aWxlV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFwRGF0YSA9IHRoaXMubWFwRGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52Ym8gPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmJvID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgKDQgKiA2ICogKG1hcFdpZHRoICogbWFwSGVpZ2h0KSkgKiA0LCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmJvLmFkZEF0dHJpYnV0ZSh0aGlzLnRpbGVtYXBSZW5kZXJlci5zaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfcG9zaXRpb24nKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmJvLmFkZEF0dHJpYnV0ZSh0aGlzLnRpbGVtYXBSZW5kZXJlci5zaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfdGV4X2Nvb3JkJyksIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckRhdGEgPSB0aGlzLmJ1ZmZlckRhdGEgPSBuZXcgQXJyYXlCdWZmZXIoKDQgKiA2ICogKG1hcFdpZHRoICogbWFwSGVpZ2h0KSkgKiA0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZibyA9IHZibztcclxuICAgICAgICAgICAgICAgICAgICB2Ym8uYmluZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJ1ZmZlckYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyRGF0YSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBtYXBIZWlnaHQ7ICsreSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1hcFdpZHRoOyArK3gpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGlsZUlkID0gbWFwRGF0YVt5ICogbWFwV2lkdGggKyB4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbGZUaWxlV2lkdGggPSAodGlsZVdpZHRoQm9yZGVyKSAqIDAuNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbGZUaWxlSGVpZ2h0ID0gKHRpbGVIZWlnaHRCb3JkZXIpICogMC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdHggPSAoKCh0aWxlSWQgJSBzZXRXaWR0aCl8MCkgKiB0aWxlV2lkdGhCb3JkZXIpICsgaGFsZlRpbGVXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3R5ID0gKCgodGlsZUlkIC8gc2V0V2lkdGgpfDApICogdGlsZUhlaWdodEJvcmRlcikgKyBoYWxmVGlsZUhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4ID0geCAqIHRpbGVXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5ID0geSAqIHRpbGVIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eHcgPSB0eCArIHRpbGVXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5aCA9IHR5ICsgdGlsZUhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUwID0gKHJlY3R4IC0gKGhhbGZUaWxlV2lkdGggLSAwLjUpKSAvIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdjAgPSAocmVjdHkgLSAoaGFsZlRpbGVIZWlnaHQgLSAwLjUpKSAvIGhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUxID0gKHJlY3R4ICsgKGhhbGZUaWxlV2lkdGggLSAwLjUpKSAvIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdjEgPSAocmVjdHkgKyAoaGFsZlRpbGVIZWlnaHQgLSAwLjUpKSAvIGhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4MCA9IHR4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHkwID0gdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eDEgPSB0eDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5MSA9IHR5aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4MiA9IHR4dztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5MiA9IHR5aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4MyA9IHR4dztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5MyA9IHR5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyAwXSA9IHR4MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyAxXSA9IHR5MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyAyXSA9IHUwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDNdID0gdjA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDRdID0gdHgxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDVdID0gdHkxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDZdID0gdTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgN10gPSB2MTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgOF0gPSB0eDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgOV0gPSB0eTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMTBdID0gdTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMTFdID0gdjE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDEyXSA9IHR4MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyAxM10gPSB0eTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMTRdID0gdTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMTVdID0gdjA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDE2XSA9IHR4MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyAxN10gPSB0eTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMThdID0gdTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMTldID0gdjE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDIwXSA9IHR4MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyAyMV0gPSB0eTM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMjJdID0gdTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMjNdID0gdjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2Zmc2V0ICs9IDI0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhDb3VudCArPSA2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4Q291bnQgPSB2ZXJ0ZXhDb3VudDtcclxuICAgICAgICAgICAgICAgIHZiby51cGRhdGVSZXNvdXJjZShidWZmZXJEYXRhLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIuc2hhZGVyLnNldENvbnN0YW50RmxvYXQyKHRoaXMudGlsZW1hcFJlbmRlcmVyLnNjcm9sbExvY2F0aW9uLCAtY2FtZXJhLnNjcm9sbFgsIC1jYW1lcmEuc2Nyb2xsWSk7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyLnNoYWRlci5zZXRDb25zdGFudEZsb2F0Mih0aGlzLnRpbGVtYXBSZW5kZXJlci5zY3JvbGxGYWN0b3JMb2NhdGlvbiwgdGhpcy5zY3JvbGxGYWN0b3JYLCB0aGlzLnNjcm9sbEZhY3RvclkpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlci5zaGFkZXIuc2V0Q29uc3RhbnRGbG9hdDIodGhpcy50aWxlbWFwUmVuZGVyZXIudGlsZW1hcFBvc2l0aW9uTG9jYXRpb24sIHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJ0eSAmJiAhdGhpcy5nbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBtYXBXaWR0aCA9IHRoaXMubWFwV2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBtYXBIZWlnaHQgPSB0aGlzLm1hcEhlaWdodDtcclxuICAgICAgICAgICAgdmFyIGJvcmRlciA9IHRoaXMudGlsZUJvcmRlcjtcclxuICAgICAgICAgICAgdmFyIHRpbGVXaWR0aCA9IHRoaXMudGlsZVdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgdGlsZUhlaWdodCA9IHRoaXMudGlsZUhlaWdodDtcclxuICAgICAgICAgICAgdmFyIHRpbGVXaWR0aEJvcmRlciA9IHRpbGVXaWR0aCArIGJvcmRlciAqIDI7XHJcbiAgICAgICAgICAgIHZhciB0aWxlSGVpZ2h0Qm9yZGVyID0gdGlsZUhlaWdodCArIGJvcmRlciAqIDI7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMudGV4dHVyZS5zb3VyY2VbMF0ud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnRleHR1cmUuc291cmNlWzBdLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIHNldFdpZHRoID0gd2lkdGggLyB0aWxlV2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBtYXBEYXRhID0gdGhpcy5tYXBEYXRhO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50aWxlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBtYXBIZWlnaHQ7ICsreSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtYXBXaWR0aDsgKyt4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aWxlSWQgPSBtYXBEYXRhW3kgKiBtYXBXaWR0aCArIHhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVggPSAoKCh0aWxlSWQgJSBzZXRXaWR0aCl8MCkgKiB0aWxlV2lkdGhCb3JkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVkgPSAoKCh0aWxlSWQgLyBzZXRXaWR0aCl8MCkgKiB0aWxlSGVpZ2h0Qm9yZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHggPSB4ICogdGlsZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eSA9IHkgKiB0aWxlSGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0eCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lWDogZnJhbWVYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZVk6IGZyYW1lWVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG90YWxUaWxlQ291bnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRGF0YS5sZW5ndGg7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFZpc2libGVUaWxlQ291bnQ6IGZ1bmN0aW9uIChjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdWxsKGNhbWVyYSk7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmN1bGxFbmQgLSB0aGlzLmN1bGxTdGFydCkgLyA2O1xyXG4gICAgfSxcclxuXHJcbiAgICBjdWxsOiBmdW5jdGlvbiAoY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VsbFN0YXJ0ID0gMDtcclxuICAgICAgICB0aGlzLmN1bGxFbmQgPSAwO1xyXG4gICAgICAgIHZhciB0aWxlV2lkdGggPSB0aGlzLnRpbGVXaWR0aDtcclxuICAgICAgICB2YXIgdGlsZUhlaWdodCA9IHRoaXMudGlsZUhlaWdodDtcclxuICAgICAgICB2YXIgcGl4ZWxYID0gdGhpcy54IC0gKGNhbWVyYS5zY3JvbGxYICogdGhpcy5zY3JvbGxGYWN0b3JYKTtcclxuICAgICAgICB2YXIgcGl4ZWxZID0gdGhpcy55IC0gKGNhbWVyYS5zY3JvbGxZICogdGhpcy5zY3JvbGxGYWN0b3JZKTtcclxuICAgICAgICB2YXIgcGl4ZWxXaWR0aCA9IHRoaXMubWFwV2lkdGggKiB0aWxlV2lkdGg7XHJcbiAgICAgICAgdmFyIHBpeGVsSGVpZ2h0ID0gdGhpcy5tYXBIZWlnaHQgKiB0aWxlSGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAocGl4ZWxYIDwgY2FtZXJhLnggKyBjYW1lcmEud2lkdGggKyAodGlsZVdpZHRoICogMikgJiZcclxuICAgICAgICAgICAgcGl4ZWxYICsgcGl4ZWxXaWR0aCA+IGNhbWVyYS54ICsgLSh0aWxlV2lkdGggKiAyKSAmJlxyXG4gICAgICAgICAgICBwaXhlbFkgPCBjYW1lcmEueSArIGNhbWVyYS5oZWlnaHQgKyAodGlsZUhlaWdodCAqIDIpICYmXHJcbiAgICAgICAgICAgIHBpeGVsWSArIHBpeGVsSGVpZ2h0ID4gY2FtZXJhLnkgKyAtKHRpbGVIZWlnaHQgKiAyKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpbnRlclggPSBNYXRoLm1heChwaXhlbFgsIGNhbWVyYS54ICsgLSh0aWxlV2lkdGggKiAyKSk7XHJcbiAgICAgICAgICAgIHZhciBpbnRlclkgPSBNYXRoLm1heChwaXhlbFksIGNhbWVyYS55ICsgLSh0aWxlSGVpZ2h0ICogMikpO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJXaWR0aCA9IE1hdGgubWluKHBpeGVsWCArIHBpeGVsV2lkdGgsIGNhbWVyYS54ICsgY2FtZXJhLndpZHRoICsgKHRpbGVXaWR0aCAqIDIpKSAtIGludGVyWDtcclxuICAgICAgICAgICAgdmFyIGludGVySGVpZ2h0ID0gTWF0aC5taW4ocGl4ZWxZICsgcGl4ZWxIZWlnaHQsIGNhbWVyYS55ICsgY2FtZXJhLmhlaWdodCArICh0aWxlSGVpZ2h0ICogMikpIC0gaW50ZXJZO1xyXG5cclxuICAgICAgICAgICAgaW50ZXJYID0gKChpbnRlclggKyAoY2FtZXJhLnNjcm9sbFggKiB0aGlzLnNjcm9sbEZhY3RvclgpKSAvIHRpbGVXaWR0aCl8MDtcclxuICAgICAgICAgICAgaW50ZXJZID0gKChpbnRlclkgKyAoY2FtZXJhLnNjcm9sbFkgKiB0aGlzLnNjcm9sbEZhY3RvclkpKSAvIHRpbGVIZWlnaHQpfDA7XHJcbiAgICAgICAgICAgIGludGVyV2lkdGggPSAoaW50ZXJXaWR0aCAvIHRpbGVXaWR0aCl8MDtcclxuICAgICAgICAgICAgaW50ZXJIZWlnaHQgPSAoaW50ZXJIZWlnaHQgLyB0aWxlSGVpZ2h0KXwwO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdWxsU3RhcnQgPSAoaW50ZXJZICogdGhpcy5tYXBXaWR0aCArIGludGVyWCkgKiA2O1xyXG4gICAgICAgICAgICB0aGlzLmN1bGxFbmQgPSAoKGludGVyWSArIGludGVySGVpZ2h0KSAqIHRoaXMubWFwV2lkdGggKyBpbnRlclgpICogNjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RhdGljVGlsZW1hcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uLy4uL2RvbS9DYW52YXNQb29sJyk7XHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cycpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxudmFyIEdldFBvd2VyT2ZUd28gPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvdzIvR2V0UG93ZXJPZlR3bycpO1xyXG52YXIgVGlsZVNwcml0ZVJlbmRlciA9IHJlcXVpcmUoJy4vVGlsZVNwcml0ZVJlbmRlcicpO1xyXG5cclxudmFyIFRpbGVTcHJpdGUgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLkZsaXAsXHJcbiAgICAgICAgQ29tcG9uZW50cy5HZXRCb3VuZHMsXHJcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXHJcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJUYXJnZXQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TaXplLFxyXG4gICAgICAgIENvbXBvbmVudHMuVGV4dHVyZSxcclxuICAgICAgICBDb21wb25lbnRzLlRpbnQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIFRpbGVTcHJpdGVSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBUaWxlU3ByaXRlIChzY2VuZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgdGV4dHVyZSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlc291cmNlTWFuYWdlciA9IHNjZW5lLnN5cy5nYW1lLnJlbmRlcmVyLnJlc291cmNlTWFuYWdlcjtcclxuXHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHNjZW5lLCAnVGlsZVNwcml0ZScpO1xyXG5cclxuICAgICAgICB0aGlzLnRpbGVQb3NpdGlvblggPSAwO1xyXG4gICAgICAgIHRoaXMudGlsZVBvc2l0aW9uWSA9IDA7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50aWxlVGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZSh0ZXh0dXJlLCBmcmFtZSk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgICAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5zZXRPcmlnaW4oKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb3RXaWR0aCA9IEdldFBvd2VyT2ZUd28odGhpcy5mcmFtZS53aWR0aCk7XHJcbiAgICAgICAgdGhpcy5wb3RIZWlnaHQgPSBHZXRQb3dlck9mVHdvKHRoaXMuZnJhbWUuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmNhbnZhc1BhdHRlcm4gPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAocmVzb3VyY2VNYW5hZ2VyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IHNjZW5lLnN5cy5nYW1lLnJlbmRlcmVyO1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSBzY2VuZS5zeXMuZ2FtZS5yZW5kZXJlci5nbDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudGlsZVRleHR1cmUgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlVGV4dHVyZSgwLCBnbC5MSU5FQVIsIGdsLkxJTkVBUiwgZ2wuUkVQRUFULCBnbC5SRVBFQVQsIGdsLlJHQkEsIHRoaXMuY2FudmFzQnVmZmVyLCB0aGlzLnBvdFdpZHRoLCB0aGlzLnBvdEhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNhbnZhc0J1ZmZlciA9IENhbnZhc1Bvb2wuY3JlYXRlMkQobnVsbCwgdGhpcy5wb3RXaWR0aCwgdGhpcy5wb3RIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzQnVmZmVyQ3R4ID0gdGhpcy5jYW52YXNCdWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVUaWxlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHNjZW5lLnN5cy5nYW1lLnJlbmRlcmVyLmFkZENvbnRleHRSZXN0b3JlZENhbGxiYWNrKGZ1bmN0aW9uIChyZW5kZXJlcikge1xyXG4gICAgICAgICAgICBfdGhpcy50aWxlVGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgX3RoaXMudGlsZVRleHR1cmUgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlVGV4dHVyZSgwLCBnbC5MSU5FQVIsIGdsLkxJTkVBUiwgZ2wuUkVQRUFULCBnbC5SRVBFQVQsIGdsLlJHQkEsIF90aGlzLmNhbnZhc0J1ZmZlciwgX3RoaXMucG90V2lkdGgsIF90aGlzLnBvdEhlaWdodCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVRpbGVUZXh0dXJlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5kaXJ0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzQnVmZmVyQ3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgdGhpcy5mcmFtZS5zb3VyY2UuaW1hZ2UsXHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWUuY3V0WCwgdGhpcy5mcmFtZS5jdXRZLFxyXG4gICAgICAgICAgICB0aGlzLmZyYW1lLmN1dFdpZHRoLCB0aGlzLmZyYW1lLmN1dEhlaWdodCxcclxuICAgICAgICAgICAgMCwgMCxcclxuICAgICAgICAgICAgdGhpcy5wb3RXaWR0aCwgdGhpcy5wb3RIZWlnaHRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBsb2FkQ2FudmFzVG9HUFUodGhpcy5jYW52YXNCdWZmZXIsIHRoaXMudGlsZVRleHR1cmUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jYW52YXNQYXR0ZXJuID0gdGhpcy5jYW52YXNCdWZmZXJDdHguY3JlYXRlUGF0dGVybih0aGlzLmNhbnZhc0J1ZmZlciwgJ3JlcGVhdCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5nbC5kZWxldGVUZXh0dXJlKHRoaXMudGlsZVRleHR1cmUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQ2FudmFzUG9vbC5yZW1vdmUodGhpcy5jYW52YXNCdWZmZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbnZhc1BhdHRlcm4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2FudmFzQnVmZmVyQ3R4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNhbnZhc0J1ZmZlciA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVTcHJpdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZXNwcml0ZS9UaWxlU3ByaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIEVsbGlwc2UgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gRWxsaXBzZSAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7IHdpZHRoID0gMDsgfVxyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSAwOyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRvOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VG8oMCwgMCwgMCwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSB3aWR0aDsgfVxyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQUtBIFNlbWkgTWlub3IgQXhpc1xyXG4gICAgZ2V0TWlub3JSYWRpdXM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSAvIDI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBBS0EgU2VtaSBNYWpvciBBeGlzXHJcbiAgICBnZXRNYWpvclJhZGl1czogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpIC8gMjtcclxuICAgIH0sXHJcblxyXG4gICAgbGVmdDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMucmlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy54KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB2YWx1ZSAtIHRoaXMueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMuYm90dG9tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gKHRoaXMuYm90dG9tIC0gdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLnkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdmFsdWUgLSB0aGlzLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVsbGlwc2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9lbGxpcHNlL0VsbGlwc2UuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFVzaW5nIEJyZXNlbmhhbSdzIGxpbmUgYWxnb3JpdGhtIHRoaXMgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIGNvb3JkaW5hdGVzIG9uIHRoaXMgbGluZS5cclxuKiBUaGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIHJvdW5kZWQgYmVmb3JlIHRoaXMgcnVucyBhcyB0aGUgYWxnb3JpdGhtIHdvcmtzIG9uIGludGVnZXJzLlxyXG4qL1xyXG52YXIgR2V0UG9pbnRzT25MaW5lID0gZnVuY3Rpb24gKGxpbmUsIHN0ZXBSYXRlLCByZXN1bHRzKVxyXG57XHJcbiAgICBpZiAoc3RlcFJhdGUgPT09IHVuZGVmaW5lZCkgeyBzdGVwUmF0ZSA9IDE7IH1cclxuICAgIGlmIChyZXN1bHRzID09PSB1bmRlZmluZWQpIHsgcmVzdWx0cyA9IFtdOyB9XHJcblxyXG4gICAgdmFyIHgxID0gTWF0aC5yb3VuZChsaW5lLngxKTtcclxuICAgIHZhciB5MSA9IE1hdGgucm91bmQobGluZS55MSk7XHJcbiAgICB2YXIgeDIgPSBNYXRoLnJvdW5kKGxpbmUueDIpO1xyXG4gICAgdmFyIHkyID0gTWF0aC5yb3VuZChsaW5lLnkyKTtcclxuXHJcbiAgICB2YXIgZHggPSBNYXRoLmFicyh4MiAtIHgxKTtcclxuICAgIHZhciBkeSA9IE1hdGguYWJzKHkyIC0geTEpO1xyXG4gICAgdmFyIHN4ID0gKHgxIDwgeDIpID8gMSA6IC0xO1xyXG4gICAgdmFyIHN5ID0gKHkxIDwgeTIpID8gMSA6IC0xO1xyXG4gICAgdmFyIGVyciA9IGR4IC0gZHk7XHJcblxyXG4gICAgcmVzdWx0cy5wdXNoKFsgeDEsIHkxIF0pO1xyXG5cclxuICAgIHZhciBpID0gMTtcclxuXHJcbiAgICB3aGlsZSAoISgoeDEgPT09IHgyKSAmJiAoeTEgPT09IHkyKSkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGUyID0gZXJyIDw8IDE7XHJcblxyXG4gICAgICAgIGlmIChlMiA+IC1keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGVyciAtPSBkeTtcclxuICAgICAgICAgICAgeDEgKz0gc3g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZTIgPCBkeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGVyciArPSBkeDtcclxuICAgICAgICAgICAgeTEgKz0gc3k7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSAlIHN0ZXBSYXRlID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFsgeDEsIHkxIF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRQb2ludHNPbkxpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL0dldFBvaW50c09uTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBSb3RhdGVBcm91bmRYWSA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5LCBhbmdsZSlcclxue1xyXG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICB2YXIgdHggPSBsaW5lLngxIC0geDtcclxuICAgIHZhciB0eSA9IGxpbmUueTEgLSB5O1xyXG5cclxuICAgIGxpbmUueDEgPSB0eCAqIGMgLSB0eSAqIHMgKyB4O1xyXG4gICAgbGluZS55MSA9IHR4ICogcyArIHR5ICogYyArIHk7XHJcblxyXG4gICAgdHggPSBsaW5lLngyIC0geDtcclxuICAgIHR5ID0gbGluZS55MiAtIHk7XHJcblxyXG4gICAgbGluZS54MiA9IHR4ICogYyAtIHR5ICogcyArIHg7XHJcbiAgICBsaW5lLnkyID0gdHggKiBzICsgdHkgKiBjICsgeTtcclxuXHJcbiAgICByZXR1cm4gbGluZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kWFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL1JvdGF0ZUFyb3VuZFhZLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRG90ID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCKVxyXG57XHJcbiAgICByZXR1cm4gKChwb2ludEEueCAqIHBvaW50Qi54KSArIChwb2ludEEueSAqIHBvaW50Qi55KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERvdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0RvdC5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEFzcGVjdFJhdGlvID0gZnVuY3Rpb24gKHJlY3QpXHJcbntcclxuICAgIHJldHVybiAocmVjdC5oZWlnaHQgPT09IDApID8gTmFOIDogcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBc3BlY3RSYXRpbztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9HZXRBc3BlY3RSYXRpby5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9cclxuXHJcbi8vICBwb2ludHMgaXMgYW4gYXJyYXkgb2YgUG9pbnQtbGlrZSBvYmplY3RzIHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXHJcbi8vICByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHBvaW50cyB0aGF0IGFyZSB3aXRoaW4gdGhlIHRyaWFuZ2xlLCBvciBhbiBlbXB0eSBhcnJheSBpZiBub25lXHJcbi8vICBpZiAncmV0dXJuRmlyc3QnIGlzIHRydWUgaXQgd2lsbCByZXR1cm4gYWZ0ZXIgdGhlIGZpcnN0IHBvaW50IHdpdGhpbiB0aGUgdHJpYW5nbGUgaXMgZm91bmRcclxuXHJcbnZhciBDb250YWluc0FycmF5ID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBwb2ludHMsIHJldHVybkZpcnN0LCBvdXQpXHJcbntcclxuICAgIGlmIChyZXR1cm5GaXJzdCA9PT0gdW5kZWZpbmVkKSB7IHJldHVybkZpcnN0ID0gZmFsc2U7IH1cclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBbXTsgfVxyXG5cclxuICAgIHZhciB2MHggPSB0cmlhbmdsZS54MyAtIHRyaWFuZ2xlLngxO1xyXG4gICAgdmFyIHYweSA9IHRyaWFuZ2xlLnkzIC0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgdmFyIHYxeCA9IHRyaWFuZ2xlLngyIC0gdHJpYW5nbGUueDE7XHJcbiAgICB2YXIgdjF5ID0gdHJpYW5nbGUueTIgLSB0cmlhbmdsZS55MTtcclxuXHJcbiAgICB2YXIgZG90MDAgPSAodjB4ICogdjB4KSArICh2MHkgKiB2MHkpO1xyXG4gICAgdmFyIGRvdDAxID0gKHYweCAqIHYxeCkgKyAodjB5ICogdjF5KTtcclxuICAgIHZhciBkb3QxMSA9ICh2MXggKiB2MXgpICsgKHYxeSAqIHYxeSk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xyXG4gICAgdmFyIGIgPSAoKGRvdDAwICogZG90MTEpIC0gKGRvdDAxICogZG90MDEpKTtcclxuICAgIHZhciBpbnYgPSAoYiA9PT0gMCkgPyAwIDogKDEgLyBiKTtcclxuXHJcbiAgICB2YXIgdTtcclxuICAgIHZhciB2O1xyXG4gICAgdmFyIHYyeDtcclxuICAgIHZhciB2Mnk7XHJcbiAgICB2YXIgZG90MDI7XHJcbiAgICB2YXIgZG90MTI7XHJcblxyXG4gICAgdmFyIHgxID0gdHJpYW5nbGUueDE7XHJcbiAgICB2YXIgeTEgPSB0cmlhbmdsZS55MTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2MnggPSBwb2ludHNbaV0ueCAtIHgxO1xyXG4gICAgICAgIHYyeSA9IHBvaW50c1tpXS55IC0geTE7XHJcblxyXG4gICAgICAgIGRvdDAyID0gKHYweCAqIHYyeCkgKyAodjB5ICogdjJ5KTtcclxuICAgICAgICBkb3QxMiA9ICh2MXggKiB2MngpICsgKHYxeSAqIHYyeSk7XHJcblxyXG4gICAgICAgIHUgPSAoKGRvdDExICogZG90MDIpIC0gKGRvdDAxICogZG90MTIpKSAqIGludjtcclxuICAgICAgICB2ID0gKChkb3QwMCAqIGRvdDEyKSAtIChkb3QwMSAqIGRvdDAyKSkgKiBpbnY7XHJcbiAgICBcclxuICAgICAgICBpZiAodSA+PSAwICYmIHYgPj0gMCAmJiAodSArIHYgPCAxKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dC5wdXNoKHsgeDogcG9pbnRzW2ldLngsIHk6IHBvaW50c1tpXS55IH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJldHVybkZpcnN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc0FycmF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQ29udGFpbnNBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBSb3RhdGVBcm91bmRYWSA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgeCwgeSwgYW5nbGUpXHJcbntcclxuICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgdmFyIHR4ID0gdHJpYW5nbGUueDEgLSB4O1xyXG4gICAgdmFyIHR5ID0gdHJpYW5nbGUueTEgLSB5O1xyXG5cclxuICAgIHRyaWFuZ2xlLngxID0gdHggKiBjIC0gdHkgKiBzICsgeDtcclxuICAgIHRyaWFuZ2xlLnkxID0gdHggKiBzICsgdHkgKiBjICsgeTtcclxuXHJcbiAgICB0eCA9IHRyaWFuZ2xlLngyIC0geDtcclxuICAgIHR5ID0gdHJpYW5nbGUueTIgLSB5O1xyXG5cclxuICAgIHRyaWFuZ2xlLngyID0gdHggKiBjIC0gdHkgKiBzICsgeDtcclxuICAgIHRyaWFuZ2xlLnkyID0gdHggKiBzICsgdHkgKiBjICsgeTtcclxuXHJcbiAgICB0eCA9IHRyaWFuZ2xlLngzIC0geDtcclxuICAgIHR5ID0gdHJpYW5nbGUueTMgLSB5O1xyXG5cclxuICAgIHRyaWFuZ2xlLngzID0gdHggKiBjIC0gdHkgKiBzICsgeDtcclxuICAgIHRyaWFuZ2xlLnkzID0gdHggKiBzICsgdHkgKiBjICsgeTtcclxuXHJcbiAgICByZXR1cm4gdHJpYW5nbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZFhZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvUm90YXRlQXJvdW5kWFkuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBHaXZlbiAzIGNvbG9yIHZhbHVlcyB0aGlzIHdpbGwgcmV0dXJuIGFuIGludGVnZXIgcmVwcmVzZW50YXRpb24gb2YgaXQuXHJcbiAqL1xyXG52YXIgR2V0Q29sb3IgPSBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSlcclxue1xyXG4gICAgcmV0dXJuIHJlZCA8PCAxNiB8IGdyZWVuIDw8IDggfCBibHVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRDb2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9jb2xvci9HZXRDb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoaXMgd2lsbCByZXR1cm4gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBzcGVjaWZpZWQgZGlzcGxheU9iamVjdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gUG9pbnRlci5cclxuKi9cclxudmFyIEdldFRyYW5zZm9ybWVkUG9pbnQgPSBmdW5jdGlvbiAobWF0cml4LCBnYW1lT2JqZWN0LCB4LCB5LCBvdXRwdXQpXHJcbntcclxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIG1hdHJpeC5hcHBseUlUUlMoZ2FtZU9iamVjdC54LCBnYW1lT2JqZWN0LnksIC1nYW1lT2JqZWN0LnJvdGF0aW9uLCBnYW1lT2JqZWN0LnNjYWxlWCwgZ2FtZU9iamVjdC5zY2FsZVkpO1xyXG5cclxuICAgIG1hdHJpeC5pbnZlcnQoKTtcclxuXHJcbiAgICByZXR1cm4gbWF0cml4LnRyYW5zZm9ybVBvaW50KHgsIHksIG91dHB1dCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFRyYW5zZm9ybWVkUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvZ2xvYmFsL2luYy9HZXRUcmFuc2Zvcm1lZFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBCQUNLU1BBQ0U6IDgsXHJcbiAgICBUQUI6IDksXHJcbiAgICBFTlRFUjogMTMsXHJcblxyXG4gICAgU0hJRlQ6IDE2LFxyXG4gICAgQ1RSTDogMTcsXHJcbiAgICBBTFQ6IDE4LFxyXG5cclxuICAgIFBBVVNFOiAxOSxcclxuICAgIENBUFNfTE9DSzogMjAsXHJcbiAgICBFU0M6IDI3LFxyXG4gICAgU1BBQ0U6IDMyLFxyXG5cclxuICAgIFBBR0VfVVA6IDMzLFxyXG4gICAgUEFHRV9ET1dOOiAzNCxcclxuICAgIEVORDogMzUsXHJcbiAgICBIT01FOiAzNixcclxuXHJcbiAgICBMRUZUOiAzNyxcclxuICAgIFVQOiAzOCxcclxuICAgIFJJR0hUOiAzOSxcclxuICAgIERPV046IDQwLFxyXG5cclxuICAgIFBSSU5UX1NDUkVFTjogNDIsXHJcbiAgICBJTlNFUlQ6IDQ1LFxyXG4gICAgREVMRVRFOiA0NixcclxuXHJcbiAgICBaRVJPOiA0OCxcclxuICAgIE9ORTogNDksXHJcbiAgICBUV086IDUwLFxyXG4gICAgVEhSRUU6IDUxLFxyXG4gICAgRk9VUjogNTIsXHJcbiAgICBGSVZFOiA1MyxcclxuICAgIFNJWDogNTQsXHJcbiAgICBTRVZFTjogNTUsXHJcbiAgICBFSUdIVDogNTYsXHJcbiAgICBOSU5FOiA1NyxcclxuXHJcbiAgICBBOiA2NSxcclxuICAgIEI6IDY2LFxyXG4gICAgQzogNjcsXHJcbiAgICBEOiA2OCxcclxuICAgIEU6IDY5LFxyXG4gICAgRjogNzAsXHJcbiAgICBHOiA3MSxcclxuICAgIEg6IDcyLFxyXG4gICAgSTogNzMsXHJcbiAgICBKOiA3NCxcclxuICAgIEs6IDc1LFxyXG4gICAgTDogNzYsXHJcbiAgICBNOiA3NyxcclxuICAgIE46IDc4LFxyXG4gICAgTzogNzksXHJcbiAgICBQOiA4MCxcclxuICAgIFE6IDgxLFxyXG4gICAgUjogODIsXHJcbiAgICBTOiA4MyxcclxuICAgIFQ6IDg0LFxyXG4gICAgVTogODUsXHJcbiAgICBWOiA4NixcclxuICAgIFc6IDg3LFxyXG4gICAgWDogODgsXHJcbiAgICBZOiA4OSxcclxuICAgIFo6IDkwLFxyXG5cclxuICAgIEYxOiAxMTIsXHJcbiAgICBGMjogMTEzLFxyXG4gICAgRjM6IDExNCxcclxuICAgIEY0OiAxMTUsXHJcbiAgICBGNTogMTE2LFxyXG4gICAgRjY6IDExNyxcclxuICAgIEY3OiAxMTgsXHJcbiAgICBGODogMTE5LFxyXG4gICAgRjk6IDEyMCxcclxuICAgIEYxMDogMTIxLFxyXG4gICAgRjExOiAxMjIsXHJcbiAgICBGMTI6IDEyMyxcclxuXHJcbiAgICBTRU1JQ09MT046IDE4NixcclxuICAgIFBMVVM6IDE4NyxcclxuICAgIENPTU1BOiAxODgsXHJcbiAgICBNSU5VUzogMTg5LFxyXG4gICAgUEVSSU9EOiAxOTAsXHJcbiAgICBGT1JXQURfU0xBU0g6IDE5MSxcclxuICAgIEJBQ0tfU0xBU0g6IDIyMCxcclxuICAgIFFVT1RFUzogMjIyXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQva2V5Ym9hcmQva2V5cy9LZXlDb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBDcmVhdGVzIGFuIFhIUlNldHRpbmdzIE9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcblxyXG52YXIgWEhSU2V0dGluZ3MgPSBmdW5jdGlvbiAocmVzcG9uc2VUeXBlLCBhc3luYywgdXNlciwgcGFzc3dvcmQsIHRpbWVvdXQpXHJcbntcclxuICAgIGlmIChyZXNwb25zZVR5cGUgPT09IHVuZGVmaW5lZCkgeyByZXNwb25zZVR5cGUgPSAnJzsgfVxyXG4gICAgaWYgKGFzeW5jID09PSB1bmRlZmluZWQpIHsgYXN5bmMgPSB0cnVlOyB9XHJcbiAgICBpZiAodXNlciA9PT0gdW5kZWZpbmVkKSB7IHVzZXIgPSAnJzsgfVxyXG4gICAgaWYgKHBhc3N3b3JkID09PSB1bmRlZmluZWQpIHsgcGFzc3dvcmQgPSAnJzsgfVxyXG4gICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkgeyB0aW1lb3V0ID0gMDsgfVxyXG5cclxuICAgIC8vIEJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCwgc2V0IHRoZSB4aHIucmVzcG9uc2VUeXBlIHRvIFwidGV4dFwiLCBcclxuICAgIC8vIFwiYXJyYXlidWZmZXJcIiwgXCJibG9iXCIsIG9yIFwiZG9jdW1lbnRcIiwgZGVwZW5kaW5nIG9uIHlvdXIgZGF0YSBuZWVkcy4gXHJcbiAgICAvLyBOb3RlLCBzZXR0aW5nIHhoci5yZXNwb25zZVR5cGUgPSAnJyAob3Igb21pdHRpbmcpIHdpbGwgZGVmYXVsdCB0aGUgcmVzcG9uc2UgdG8gXCJ0ZXh0XCIuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgLy8gIElnbm9yZWQgYnkgdGhlIExvYWRlciwgb25seSB1c2VkIGJ5IEZpbGUuXHJcbiAgICAgICAgcmVzcG9uc2VUeXBlOiByZXNwb25zZVR5cGUsXHJcblxyXG4gICAgICAgIGFzeW5jOiBhc3luYyxcclxuXHJcbiAgICAgICAgLy8gIGNyZWRlbnRpYWxzXHJcbiAgICAgICAgdXNlcjogdXNlcixcclxuICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXHJcblxyXG4gICAgICAgIC8vICB0aW1lb3V0IGluIG1zICgwID0gbm8gdGltZW91dClcclxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxyXG5cclxuICAgICAgICAvLyAgc2V0UmVxdWVzdEhlYWRlclxyXG4gICAgICAgIGhlYWRlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgIGhlYWRlclZhbHVlOiB1bmRlZmluZWQsXHJcblxyXG4gICAgICAgIC8vICBvdmVycmlkZU1pbWVUeXBlXHJcbiAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogdW5kZWZpbmVkXHJcblxyXG4gICAgfTtcclxuICAgIFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYSFJTZXR0aW5ncztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvWEhSU2V0dGluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxudmFyIEdldEZhc3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRGYXN0VmFsdWUnKTtcclxuXHJcbi8vICBQaGFzZXIuTG9hZGVyLkZpbGVUeXBlcy5KU09ORmlsZVxyXG5cclxudmFyIEpTT05GaWxlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBGaWxlLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gSlNPTkZpbGUgKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxuICAgIHtcclxuICAgICAgICB2YXIgZmlsZUtleSA9ICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykgPyBrZXkgOiBHZXRGYXN0VmFsdWUoa2V5LCAna2V5JywgJycpO1xyXG5cclxuICAgICAgICB2YXIgZmlsZUNvbmZpZyA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBleHRlbnNpb246IEdldEZhc3RWYWx1ZShrZXksICdleHRlbnNpb24nLCAnanNvbicpLFxyXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgICAga2V5OiBmaWxlS2V5LFxyXG4gICAgICAgICAgICB1cmw6IEdldEZhc3RWYWx1ZShrZXksICdmaWxlJywgdXJsKSxcclxuICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgeGhyU2V0dGluZ3M6IEdldEZhc3RWYWx1ZShrZXksICd4aHInLCB4aHJTZXR0aW5ncylcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBGaWxlLmNhbGwodGhpcywgZmlsZUNvbmZpZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uUHJvY2VzczogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IEpTT04ucGFyc2UodGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0KTtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKHRoaXMpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5KU09ORmlsZS5jcmVhdGUgPSBmdW5jdGlvbiAobG9hZGVyLCBrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSWYgaXQncyBhbiBhcnJheSBpdCBoYXMgdG8gYmUgYW4gYXJyYXkgb2YgT2JqZWN0cywgc28gd2UgZ2V0IGV2ZXJ5dGhpbmcgb3V0IG9mIHRoZSAna2V5JyBvYmplY3RcclxuICAgICAgICAgICAgbG9hZGVyLmFkZEZpbGUobmV3IEpTT05GaWxlKGtleVtpXSwgdXJsLCBsb2FkZXIucGF0aCwgeGhyU2V0dGluZ3MpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgbG9hZGVyLmFkZEZpbGUobmV3IEpTT05GaWxlKGtleSwgdXJsLCBsb2FkZXIucGF0aCwgeGhyU2V0dGluZ3MpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRm9yIG1ldGhvZCBjaGFpbmluZ1xyXG4gICAgcmV0dXJuIGxvYWRlcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSlNPTkZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYXRtdWxsUm9tID0gZnVuY3Rpb24gKHQsIHAwLCBwMSwgcDIsIHAzKVxyXG57XHJcbiAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XHJcbiAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XHJcbiAgICB2YXIgdDIgPSB0ICogdDtcclxuICAgIHZhciB0MyA9IHQgKiB0MjtcclxuXHJcbiAgICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhdG11bGxSb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9DYXRtdWxsUm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIERlZ1RvUmFkID0gZnVuY3Rpb24gKGRlZ3JlZXMpXHJcbntcclxuICAgIHJldHVybiBkZWdyZWVzICogQ09OU1QuREVHX1RPX1JBRDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGVnVG9SYWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9EZWdUb1JhZC5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBwID0gUG9pbnQgb3IgYW55IG9iamVjdCB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllcywgdGhlIGl0ZW0gdG8gYmUgcm90YXRlZFxyXG4vLyAgeC95ID0gdGhlIGNvb3JkaW5hdGUgdG8gcm90YXRlIGFyb3VuZFxyXG4vLyAgYW5nbGUgPSByYWRpYW5zXHJcbi8vICBkaXN0YW5jZSA9IGluIHB4XHJcblxyXG52YXIgUm90YXRlQXJvdW5kRGlzdGFuY2UgPSBmdW5jdGlvbiAocG9pbnQsIHgsIHksIGFuZ2xlLCBkaXN0YW5jZSlcclxue1xyXG4gICAgdmFyIHQgPSBhbmdsZSArIE1hdGguYXRhbjIocG9pbnQueSAtIHksIHBvaW50LnggLSB4KTtcclxuXHJcbiAgICBwb2ludC54ID0geCArIChkaXN0YW5jZSAqIE1hdGguY29zKHQpKTtcclxuICAgIHBvaW50LnkgPSB5ICsgKGRpc3RhbmNlICogTWF0aC5zaW4odCkpO1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kRGlzdGFuY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9Sb3RhdGVBcm91bmREaXN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBtYWtlIGEgcG93ZXIgb2YgdHdvIHRleHR1cmUuXHJcbiogXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHRvIGNoZWNrLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IHRvIGNoZWNrLlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGEgcG93ZXIgb2YgdHdvLlxyXG4qL1xyXG52YXIgSXNTaXplUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICByZXR1cm4gKHdpZHRoID4gMCAmJiAod2lkdGggJiAod2lkdGggLSAxKSkgPT09IDAgJiYgaGVpZ2h0ID4gMCAmJiAoaGVpZ2h0ICYgKGhlaWdodCAtIDEpKSA9PT0gMCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElzU2l6ZVBvd2VyT2ZUd287XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9wb3cyL0lzU2l6ZVBvd2VyT2ZUd28uanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlBoeXNpY3MuSW1wYWN0LkJvZHkuQ29tcG9uZW50c1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQWNjZWxlcmF0aW9uOiByZXF1aXJlKCcuL0FjY2VsZXJhdGlvbicpLFxyXG4gICAgQm9keVNjYWxlOiByZXF1aXJlKCcuL0JvZHlTY2FsZScpLFxyXG4gICAgQm9keVR5cGU6IHJlcXVpcmUoJy4vQm9keVR5cGUnKSxcclxuICAgIEJvdW5jZTogcmVxdWlyZSgnLi9Cb3VuY2UnKSxcclxuICAgIENoZWNrQWdhaW5zdDogcmVxdWlyZSgnLi9DaGVja0FnYWluc3QnKSxcclxuICAgIENvbGxpZGVzOiByZXF1aXJlKCcuL0NvbGxpZGVzJyksXHJcbiAgICBEZWJ1ZzogcmVxdWlyZSgnLi9EZWJ1ZycpLFxyXG4gICAgRnJpY3Rpb246IHJlcXVpcmUoJy4vRnJpY3Rpb24nKSxcclxuICAgIEdyYXZpdHk6IHJlcXVpcmUoJy4vR3Jhdml0eScpLFxyXG4gICAgT2Zmc2V0OiByZXF1aXJlKCcuL09mZnNldCcpLFxyXG4gICAgU2V0R2FtZU9iamVjdDogcmVxdWlyZSgnLi9TZXRHYW1lT2JqZWN0JyksXHJcbiAgICBWZWxvY2l0eTogcmVxdWlyZSgnLi9WZWxvY2l0eScpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ3VycmVudFZlcnRleEJ1ZmZlciA9IG51bGw7XHJcbnZhciBWZXJ0ZXhCdWZmZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gVmVydGV4QnVmZmVyIChnbCwgYnVmZmVyT2JqZWN0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLmJ1ZmZlclRhcmdldCA9IGdsLkFSUkFZX0JVRkZFUjtcclxuICAgICAgICB0aGlzLmJ1ZmZlck9iamVjdCA9IGJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXR0cmlidXRlOiBmdW5jdGlvbiAoaW5kZXgsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHtcclxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICBzaXplOiBzaXplLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBub3JtYWxpemVkLFxyXG4gICAgICAgICAgICBzdHJpZGU6IHN0cmlkZSxcclxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVJlc291cmNlOiBmdW5jdGlvbiAoYnVmZmVyRGF0YSwgb2Zmc2V0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgIGlmIChDdXJyZW50VmVydGV4QnVmZmVyICE9PSB0aGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ3VycmVudFZlcnRleEJ1ZmZlciA9IHRoaXM7XHJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBvZmZzZXQsIGJ1ZmZlckRhdGEpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBidWZmZXJPYmplY3QgPSB0aGlzLmJ1ZmZlck9iamVjdDtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuICAgICAgICB2YXIgYXR0cmlidXRlc0xlbmd0aCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoQ3VycmVudFZlcnRleEJ1ZmZlciAhPT0gdGhpcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEN1cnJlbnRWZXJ0ZXhCdWZmZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyT2JqZWN0KTtcclxuICAgIFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYXR0cmlidXRlc0xlbmd0aDsgKytpbmRleClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBhdHRyaWJ1dGVzW2luZGV4XTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50ICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGVsZW1lbnQuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm5vcm1hbGl6ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3RyaWRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgXHJcbn0pO1xyXG5cclxuVmVydGV4QnVmZmVyLlNldERpcnR5ID0gZnVuY3Rpb24gKCkgXHJcbntcclxuICAgIEN1cnJlbnRWZXJ0ZXhCdWZmZXIgPSBudWxsO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWZXJ0ZXhCdWZmZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVzb3VyY2VzL1ZlcnRleEJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTb3J0U2NlbmVzID0gZnVuY3Rpb24gKHNjZW5lQSwgc2NlbmVCKVxyXG57XHJcbiAgICAvLyAgU29ydCBkZXNjZW5kaW5nXHJcbiAgICBpZiAoc2NlbmVBLmluZGV4IDwgc2NlbmVCLmluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjZW5lQS5pbmRleCA+IHNjZW5lQi5pbmRleClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU29ydFNjZW5lcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL1NvcnRTY2VuZXMuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvRXZlbnQnKTtcclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBEYXRhIENvbXBvbmVudCBmZWF0dXJlcyBhIG1lYW5zIHRvIHN0b3JlIHBpZWNlcyBvZiBkYXRhIHNwZWNpZmljIHRvIGEgR2FtZSBPYmplY3QsXHJcbiogc2VhcmNoIGl0LCBxdWVyeSBpdCwgYW5kIHJldHJpZXZlIGl0LlxyXG4qL1xyXG52YXIgRGF0YSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBEYXRhIChwYXJlbnQsIGV2ZW50RGlzcGF0Y2hlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSAoZXZlbnREaXNwYXRjaGVyKSA/IGV2ZW50RGlzcGF0Y2hlciA6IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0ID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuX2JlZm9yZUNhbGxiYWNrcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2FmdGVyQ2FsbGJhY2tzID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuX2Zyb3plbiA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUmV0cmlldmVzIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSwgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtrZXldO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHRoaXMubGlzdFtrZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9LFxyXG5cclxuICAgIHF1ZXJ5OiBmdW5jdGlvbiAoc2VhcmNoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoa2V5Lm1hdGNoKHNlYXJjaCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHRoaXMubGlzdFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoa2V5LCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLl9mcm96ZW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsaXN0ZW5lcjtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG5cclxuICAgICAgICAvLyAgSWYgdGhlcmUgaXMgYSAnYmVmb3JlJyBjYWxsYmFjaywgdGhlbiBjaGVjayBpdCBmb3IgYSByZXN1bHRcclxuICAgICAgICAvLyAgVGhpcyBtZWFucyBhIHByb3BlcnR5IGNhbiBvbmx5IGV2ZXIgaGF2ZSAxIGNhbGxiYWNrLCB3aGljaCBpc24ndCByaWdodCAtIHdlIG1heSBuZWVkIG1vcmVcclxuICAgICAgICAvLyAgRGlzcGF0Y2ggZXZlbnQgaW5zdGVhZD9cclxuICAgICAgICBpZiAodGhpcy5fYmVmb3JlQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMuX2JlZm9yZUNhbGxiYWNrc1trZXldO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIuY2FsbGJhY2suY2FsbChsaXN0ZW5lci5zY29wZSwgdGhpcy5wYXJlbnQsIGtleSwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5MT0FERVJfU1RBUlRfRVZFTlQodGhpcykpO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3Rba2V5XSA9IGRhdGE7XHJcblxyXG4gICAgICAgIC8vICBJZiB0aGVyZSBpcyBhICdhZnRlcicgY2FsbGJhY2ssIHRoZW4gY2hlY2sgaXQgZm9yIGEgcmVzdWx0XHJcbiAgICAgICAgaWYgKHRoaXMuX2FmdGVyQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMuX2FmdGVyQ2FsbGJhY2tzW2tleV07XHJcblxyXG4gICAgICAgICAgICByZXN1bHQgPSBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKGxpc3RlbmVyLnNjb3BlLCB0aGlzLnBhcmVudCwga2V5LCBkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2tleV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCBzY29wZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBSZW1vdmUgZW50cnlcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JlZm9yZUNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUgfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFmdGVyOiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaywgc2NvcGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUmVtb3ZlIGVudHJ5XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldID0geyBjYWxsYmFjazogY2FsbGJhY2ssIHNjb3BlOiBzY29wZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFBhc3NlcyBhbGwgZGF0YSBlbnRyaWVzIHRvIHRoZSBnaXZlbiBjYWxsYmFjay4gU3RvcmVzIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIGVhY2hcclxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cclxuICAgICogQHBhcmFtIHtvYmplY3R9IFtzY29wZV0gLSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAgKiBAcGFyYW0gey4uLip9IFthcmd1bWVudHNdIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIGFmdGVyIHRoZSBnYW1lIG9iamVjdCwga2V5LCBhbmQgZGF0YS5cclxuICAgICovXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhcmdzID0gWyB0aGlzLnBhcmVudCwgbnVsbCwgdW5kZWZpbmVkIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJnc1sxXSA9IGtleTtcclxuICAgICAgICAgICAgYXJnc1syXSA9IHRoaXMubGlzdFtrZXldO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWVyZ2U6IGZ1bmN0aW9uIChkYXRhLCBvdmVyd3JpdGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkKSB7IG92ZXJ3cml0ZSA9IHRydWU7IH1cclxuXHJcbiAgICAgICAgLy8gIE1lcmdlIGRhdGEgZnJvbSBhbm90aGVyIGNvbXBvbmVudCBpbnRvIHRoaXMgb25lXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlIHx8ICghb3ZlcndyaXRlICYmICF0aGlzLmhhcyhrZXkpKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2tleV0gPSBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mcm96ZW4gJiYgdGhpcy5oYXMoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JlZm9yZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JlZm9yZUNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2FmdGVyQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBHZXRzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gJ2tleScsIGRlbGV0ZXMgaXQgZnJvbSB0aGlzIERhdGEgc3RvcmUsIHRoZW4gcmV0dXJucyBpdC5cclxuICAgIHBvcDogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9mcm96ZW4gJiYgdGhpcy5oYXMoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKGtleSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgaGFzOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX2JlZm9yZUNhbGxiYWNrcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX2FmdGVyQ2FsbGJhY2tzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2FmdGVyQ2FsbGJhY2tzW2tleV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9mcm96ZW4gPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogRnJlZXplIHRoaXMgRGF0YSBjb21wb25lbnQsIHNvIG5vIGNoYW5nZXMgY2FuIGJlIHdyaXR0ZW4gdG8gaXQuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIGZyZWV6ZVxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZyZWV6ZVxyXG4gICAgKi9cclxuICAgIGZyZWV6ZToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJvemVuO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fZnJvemVuID0gKHZhbHVlKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3VudDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0W2tleV0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9wbHVnaW5zL0RhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRWFzZU1hcCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvZWFzaW5nL0Vhc2VNYXAnKTtcclxuXHJcbnZhciBHZXRFYXNlRnVuY3Rpb24gPSBmdW5jdGlvbiAoZWFzZSwgZWFzZVBhcmFtcylcclxue1xyXG4gICAgaWYgKHR5cGVvZiBlYXNlID09PSAnc3RyaW5nJyAmJiBFYXNlTWFwLmhhc093blByb3BlcnR5KGVhc2UpKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChlYXNlUGFyYW1zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNsb25lUGFyYW1zID0gZWFzZVBhcmFtcy5zbGljZSgwKTtcclxuXHJcbiAgICAgICAgICAgIGNsb25lUGFyYW1zLnVuc2hpZnQoMCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNsb25lUGFyYW1zWzBdID0gdjtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRWFzZU1hcFtlYXNlXS5hcHBseSh0aGlzLCBjbG9uZVBhcmFtcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBTdHJpbmcgYmFzZWQgbG9vay11cFxyXG4gICAgICAgICAgICByZXR1cm4gRWFzZU1hcFtlYXNlXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZWFzZSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgIHtcclxuICAgICAgICAvLyAgQ3VzdG9tIGZ1bmN0aW9uXHJcbiAgICAgICAgcmV0dXJuIGVhc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVhc2UpICYmIGVhc2UubGVuZ3RoID09PSA0KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBCZXppZXIgZnVuY3Rpb24gKFRPRE8pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEVhc2VNYXAuUG93ZXIwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRFYXNlRnVuY3Rpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vYnVpbGRlci9HZXRFYXNlRnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGVmYXVsdHMgPSByZXF1aXJlKCcuLi90d2Vlbi9EZWZhdWx0cycpO1xyXG52YXIgR2V0QWR2YW5jZWRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRBZHZhbmNlZFZhbHVlJyk7XHJcbnZhciBHZXRCb29sZWFuID0gcmVxdWlyZSgnLi9HZXRCb29sZWFuJyk7XHJcbnZhciBHZXRFYXNlRnVuY3Rpb24gPSByZXF1aXJlKCcuL0dldEVhc2VGdW5jdGlvbicpO1xyXG52YXIgR2V0TmV3VmFsdWUgPSByZXF1aXJlKCcuL0dldE5ld1ZhbHVlJyk7XHJcbnZhciBHZXRQcm9wcyA9IHJlcXVpcmUoJy4vR2V0UHJvcHMnKTtcclxudmFyIEdldFRhcmdldHMgPSByZXF1aXJlKCcuL0dldFRhcmdldHMnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBHZXRWYWx1ZU9wID0gcmVxdWlyZSgnLi9HZXRWYWx1ZU9wJyk7XHJcbnZhciBUd2VlbiA9IHJlcXVpcmUoJy4uL3R3ZWVuL1R3ZWVuJyk7XHJcbnZhciBUd2VlbkRhdGEgPSByZXF1aXJlKCcuLi90d2Vlbi9Ud2VlbkRhdGEnKTtcclxuXHJcbnZhciBUd2VlbkJ1aWxkZXIgPSBmdW5jdGlvbiAocGFyZW50LCBjb25maWcsIGRlZmF1bHRzKVxyXG57XHJcbiAgICBpZiAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICBkZWZhdWx0cyA9IERlZmF1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBDcmVhdGUgYXJyYXlzIG9mIHRoZSBUYXJnZXRzIGFuZCB0aGUgUHJvcGVydGllc1xyXG4gICAgdmFyIHRhcmdldHMgPSAoZGVmYXVsdHMudGFyZ2V0cykgPyBkZWZhdWx0cy50YXJnZXRzIDogR2V0VGFyZ2V0cyhjb25maWcpO1xyXG5cclxuICAgIC8vIHZhciBwcm9wcyA9IChkZWZhdWx0cy5wcm9wcykgPyBkZWZhdWx0cy5wcm9wcyA6IEdldFByb3BzKGNvbmZpZyk7XHJcbiAgICB2YXIgcHJvcHMgPSBHZXRQcm9wcyhjb25maWcpO1xyXG5cclxuICAgIC8vICBEZWZhdWx0IFR3ZWVuIHZhbHVlc1xyXG4gICAgdmFyIGRlbGF5ID0gR2V0TmV3VmFsdWUoY29uZmlnLCAnZGVsYXknLCBkZWZhdWx0cy5kZWxheSk7XHJcbiAgICB2YXIgZHVyYXRpb24gPSBHZXROZXdWYWx1ZShjb25maWcsICdkdXJhdGlvbicsIGRlZmF1bHRzLmR1cmF0aW9uKTtcclxuICAgIHZhciBlYXNlUGFyYW1zID0gR2V0VmFsdWUoY29uZmlnLCAnZWFzZVBhcmFtcycsIGRlZmF1bHRzLmVhc2VQYXJhbXMpO1xyXG4gICAgdmFyIGVhc2UgPSBHZXRFYXNlRnVuY3Rpb24oR2V0VmFsdWUoY29uZmlnLCAnZWFzZScsIGRlZmF1bHRzLmVhc2UpLCBlYXNlUGFyYW1zKTtcclxuICAgIHZhciBob2xkID0gR2V0TmV3VmFsdWUoY29uZmlnLCAnaG9sZCcsIGRlZmF1bHRzLmhvbGQpO1xyXG4gICAgdmFyIHJlcGVhdCA9IEdldE5ld1ZhbHVlKGNvbmZpZywgJ3JlcGVhdCcsIGRlZmF1bHRzLnJlcGVhdCk7XHJcbiAgICB2YXIgcmVwZWF0RGVsYXkgPSBHZXROZXdWYWx1ZShjb25maWcsICdyZXBlYXREZWxheScsIGRlZmF1bHRzLnJlcGVhdERlbGF5KTtcclxuICAgIHZhciB5b3lvID0gR2V0Qm9vbGVhbihjb25maWcsICd5b3lvJywgZGVmYXVsdHMueW95byk7XHJcbiAgICB2YXIgZmxpcFggPSBHZXRCb29sZWFuKGNvbmZpZywgJ2ZsaXBYJywgZGVmYXVsdHMuZmxpcFgpO1xyXG4gICAgdmFyIGZsaXBZID0gR2V0Qm9vbGVhbihjb25maWcsICdmbGlwWScsIGRlZmF1bHRzLmZsaXBZKTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IFtdO1xyXG5cclxuICAgIC8vICBMb29wIHRocm91Z2ggZXZlcnkgcHJvcGVydHkgZGVmaW5lZCBpbiB0aGUgVHdlZW4sIGkuZS46IHByb3BzIHsgeCwgeSwgYWxwaGEgfVxyXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKylcclxuICAgIHtcclxuICAgICAgICB2YXIga2V5ID0gcHJvcHNbcF0ua2V5O1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW3BdLnZhbHVlO1xyXG5cclxuICAgICAgICAvLyAgQ3JlYXRlIDEgVHdlZW5EYXRhIHBlciB0YXJnZXQsIHBlciBwcm9wZXJ0eVxyXG4gICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGFyZ2V0cy5sZW5ndGg7IHQrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBvcHMgPSBHZXRWYWx1ZU9wKGtleSwgdmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHR3ZWVuRGF0YSA9IFR3ZWVuRGF0YShcclxuICAgICAgICAgICAgICAgIHRhcmdldHNbdF0sXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICBvcHMuZ2V0RW5kLFxyXG4gICAgICAgICAgICAgICAgb3BzLmdldFN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgR2V0RWFzZUZ1bmN0aW9uKEdldFZhbHVlKHZhbHVlLCAnZWFzZScsIGVhc2UpLCBlYXNlUGFyYW1zKSxcclxuICAgICAgICAgICAgICAgIEdldE5ld1ZhbHVlKHZhbHVlLCAnZGVsYXknLCBkZWxheSksXHJcbiAgICAgICAgICAgICAgICBHZXROZXdWYWx1ZSh2YWx1ZSwgJ2R1cmF0aW9uJywgZHVyYXRpb24pLFxyXG4gICAgICAgICAgICAgICAgR2V0Qm9vbGVhbih2YWx1ZSwgJ3lveW8nLCB5b3lvKSxcclxuICAgICAgICAgICAgICAgIEdldE5ld1ZhbHVlKHZhbHVlLCAnaG9sZCcsIGhvbGQpLFxyXG4gICAgICAgICAgICAgICAgR2V0TmV3VmFsdWUodmFsdWUsICdyZXBlYXQnLCByZXBlYXQpLFxyXG4gICAgICAgICAgICAgICAgR2V0TmV3VmFsdWUodmFsdWUsICdyZXBlYXREZWxheScsIHJlcGVhdERlbGF5KSxcclxuICAgICAgICAgICAgICAgIEdldEJvb2xlYW4odmFsdWUsICdmbGlwWCcsIGZsaXBYKSxcclxuICAgICAgICAgICAgICAgIEdldEJvb2xlYW4odmFsdWUsICdmbGlwWScsIGZsaXBZKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZGF0YS5wdXNoKHR3ZWVuRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0d2VlbiA9IG5ldyBUd2VlbihwYXJlbnQsIGRhdGEsIHRhcmdldHMpO1xyXG5cclxuICAgIHR3ZWVuLm9mZnNldCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnb2Zmc2V0JywgbnVsbCk7XHJcbiAgICB0d2Vlbi5jb21wbGV0ZURlbGF5ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdjb21wbGV0ZURlbGF5JywgMCk7XHJcbiAgICB0d2Vlbi5sb29wID0gTWF0aC5yb3VuZChHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2xvb3AnLCAwKSk7XHJcbiAgICB0d2Vlbi5sb29wRGVsYXkgPSBNYXRoLnJvdW5kKEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnbG9vcERlbGF5JywgMCkpO1xyXG4gICAgdHdlZW4ucGF1c2VkID0gR2V0Qm9vbGVhbihjb25maWcsICdwYXVzZWQnLCBmYWxzZSk7XHJcbiAgICB0d2Vlbi51c2VGcmFtZXMgPSBHZXRCb29sZWFuKGNvbmZpZywgJ3VzZUZyYW1lcycsIGZhbHNlKTtcclxuXHJcbiAgICAvLyAgU2V0IHRoZSBDYWxsYmFja3NcclxuICAgIHZhciBzY29wZSA9IEdldFZhbHVlKGNvbmZpZywgJ2NhbGxiYWNrU2NvcGUnLCB0d2Vlbik7XHJcblxyXG4gICAgLy8gIENhbGxiYWNrIHBhcmFtZXRlcnM6IDAgPSBhIHJlZmVyZW5jZSB0byB0aGUgVHdlZW4gaXRzZWxmLCAxID0gdGhlIHRhcmdldC9zIG9mIHRoZSBUd2VlbiwgLi4uIHlvdXIgb3duIHBhcmFtc1xyXG4gICAgdmFyIHR3ZWVuQXJyYXkgPSBbIHR3ZWVuLCBudWxsIF07XHJcblxyXG4gICAgdmFyIGNhbGxiYWNrcyA9IFR3ZWVuLlRZUEVTO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0eXBlID0gY2FsbGJhY2tzW2ldO1xyXG5cclxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBHZXRWYWx1ZShjb25maWcsIHR5cGUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrU2NvcGUgPSBHZXRWYWx1ZShjb25maWcsIHR5cGUgKyAnU2NvcGUnLCBzY29wZSk7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFja1BhcmFtcyA9IEdldFZhbHVlKGNvbmZpZywgdHlwZSArICdQYXJhbXMnLCBbXSk7XHJcblxyXG4gICAgICAgICAgICAvLyAgVGhlIG51bGwgaXMgcmVzZXQgdG8gYmUgdGhlIFR3ZWVuIHRhcmdldFxyXG4gICAgICAgICAgICB0d2Vlbi5zZXRDYWxsYmFjayh0eXBlLCBjYWxsYmFjaywgdHdlZW5BcnJheS5jb25jYXQoY2FsbGJhY2tQYXJhbXMpLCBjYWxsYmFja1Njb3BlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR3ZWVuO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUd2VlbkJ1aWxkZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vYnVpbGRlci9Ud2VlbkJ1aWxkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQ3JlYXRlcyBhIG5ldyBPYmplY3QgdXNpbmcgYWxsIHZhbHVlcyBmcm9tIG9iajEgYW5kIG9iajIuXHJcbi8vICBJZiBhIHZhbHVlIGV4aXN0cyBpbiBib3RoIG9iajEgYW5kIG9iajIsIHRoZSB2YWx1ZSBpbiBvYmoxIGlzIHVzZWQuXHJcblxyXG52YXIgQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcblxyXG52YXIgTWVyZ2UgPSBmdW5jdGlvbiAob2JqMSwgb2JqMilcclxue1xyXG4gICAgdmFyIGNsb25lID0gQ2xvbmUob2JqMSk7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIG9iajIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFjbG9uZS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2xvbmVba2V5XSA9IG9iajJba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNsb25lO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9vYmplY3QvTWVyZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkFjdGlvbnNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEFuZ2xlOiByZXF1aXJlKCcuL0FuZ2xlJyksXHJcbiAgICBDYWxsOiByZXF1aXJlKCcuL0NhbGwnKSxcclxuICAgIEdldEZpcnN0OiByZXF1aXJlKCcuL0dldEZpcnN0JyksXHJcbiAgICBHcmlkQWxpZ246IHJlcXVpcmUoJy4vR3JpZEFsaWduJyksXHJcbiAgICBJbmNBbHBoYTogcmVxdWlyZSgnLi9JbmNBbHBoYScpLFxyXG4gICAgSW5jWDogcmVxdWlyZSgnLi9JbmNYJyksXHJcbiAgICBJbmNYWTogcmVxdWlyZSgnLi9JbmNYWScpLFxyXG4gICAgSW5jWTogcmVxdWlyZSgnLi9JbmNZJyksXHJcbiAgICBQbGFjZU9uQ2lyY2xlOiByZXF1aXJlKCcuL1BsYWNlT25DaXJjbGUnKSxcclxuICAgIFBsYWNlT25FbGxpcHNlOiByZXF1aXJlKCcuL1BsYWNlT25FbGxpcHNlJyksXHJcbiAgICBQbGFjZU9uTGluZTogcmVxdWlyZSgnLi9QbGFjZU9uTGluZScpLFxyXG4gICAgUGxhY2VPblJlY3RhbmdsZTogcmVxdWlyZSgnLi9QbGFjZU9uUmVjdGFuZ2xlJyksXHJcbiAgICBQbGFjZU9uVHJpYW5nbGU6IHJlcXVpcmUoJy4vUGxhY2VPblRyaWFuZ2xlJyksXHJcbiAgICBQbGF5QW5pbWF0aW9uOiByZXF1aXJlKCcuL1BsYXlBbmltYXRpb24nKSxcclxuICAgIFJhbmRvbUNpcmNsZTogcmVxdWlyZSgnLi9SYW5kb21DaXJjbGUnKSxcclxuICAgIFJhbmRvbUVsbGlwc2U6IHJlcXVpcmUoJy4vUmFuZG9tRWxsaXBzZScpLFxyXG4gICAgUmFuZG9tTGluZTogcmVxdWlyZSgnLi9SYW5kb21MaW5lJyksXHJcbiAgICBSYW5kb21SZWN0YW5nbGU6IHJlcXVpcmUoJy4vUmFuZG9tUmVjdGFuZ2xlJyksXHJcbiAgICBSYW5kb21UcmlhbmdsZTogcmVxdWlyZSgnLi9SYW5kb21UcmlhbmdsZScpLFxyXG4gICAgUm90YXRlOiByZXF1aXJlKCcuL1JvdGF0ZScpLFxyXG4gICAgUm90YXRlQXJvdW5kOiByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZCcpLFxyXG4gICAgUm90YXRlQXJvdW5kRGlzdGFuY2U6IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kRGlzdGFuY2UnKSxcclxuICAgIFNjYWxlWDogcmVxdWlyZSgnLi9TY2FsZVgnKSxcclxuICAgIFNjYWxlWFk6IHJlcXVpcmUoJy4vU2NhbGVYWScpLFxyXG4gICAgU2NhbGVZOiByZXF1aXJlKCcuL1NjYWxlWScpLFxyXG4gICAgU2V0QWxwaGE6IHJlcXVpcmUoJy4vU2V0QWxwaGEnKSxcclxuICAgIFNldEJsZW5kTW9kZTogcmVxdWlyZSgnLi9TZXRCbGVuZE1vZGUnKSxcclxuICAgIFNldERlcHRoOiByZXF1aXJlKCcuL1NldERlcHRoJyksXHJcbiAgICBTZXRIaXRBcmVhOiByZXF1aXJlKCcuL1NldEhpdEFyZWEnKSxcclxuICAgIFNldE9yaWdpbjogcmVxdWlyZSgnLi9TZXRPcmlnaW4nKSxcclxuICAgIFNldFJvdGF0aW9uOiByZXF1aXJlKCcuL1NldFJvdGF0aW9uJyksXHJcbiAgICBTZXRTY2FsZTogcmVxdWlyZSgnLi9TZXRTY2FsZScpLFxyXG4gICAgU2V0U2NhbGVYOiByZXF1aXJlKCcuL1NldFNjYWxlWCcpLFxyXG4gICAgU2V0U2NhbGVZOiByZXF1aXJlKCcuL1NldFNjYWxlWScpLFxyXG4gICAgU2V0VmlzaWJsZTogcmVxdWlyZSgnLi9TZXRWaXNpYmxlJyksXHJcbiAgICBTZXRYOiByZXF1aXJlKCcuL1NldFgnKSxcclxuICAgIFNldFhZOiByZXF1aXJlKCcuL1NldFhZJyksXHJcbiAgICBTZXRZOiByZXF1aXJlKCcuL1NldFknKSxcclxuICAgIFNoaWZ0UG9zaXRpb246IHJlcXVpcmUoJy4vU2hpZnRQb3NpdGlvbicpLFxyXG4gICAgU21vb3RoZXJTdGVwOiByZXF1aXJlKCcuL1Ntb290aGVyU3RlcCcpLFxyXG4gICAgU21vb3RoU3RlcDogcmVxdWlyZSgnLi9TbW9vdGhTdGVwJyksXHJcbiAgICBTcHJlYWQ6IHJlcXVpcmUoJy4vU3ByZWFkJyksXHJcbiAgICBUb2dnbGVWaXNpYmxlOiByZXF1aXJlKCcuL1RvZ2dsZVZpc2libGUnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZyYW1lID0gcmVxdWlyZSgnLi9GcmFtZScpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxuXHJcbnZhciBHZXRGcmFtZXMgPSBmdW5jdGlvbiAodGV4dHVyZU1hbmFnZXIsIGZyYW1lcylcclxue1xyXG4gICAgLy8gICAgICBmcmFtZXM6IFtcclxuICAgIC8vICAgICAgICAgIHsga2V5OiB0ZXh0dXJlS2V5LCBmcmFtZTogdGV4dHVyZUZyYW1lIH0sXHJcbiAgICAvLyAgICAgICAgICB7IGtleTogdGV4dHVyZUtleSwgZnJhbWU6IHRleHR1cmVGcmFtZSwgZHVyYXRpb246IGZsb2F0IH0sXHJcbiAgICAvLyAgICAgICAgICB7IGtleTogdGV4dHVyZUtleSwgZnJhbWU6IHRleHR1cmVGcmFtZSwgb25VcGRhdGU6IGZ1bmN0aW9uIH1cclxuICAgIC8vICAgICAgICAgIHsga2V5OiB0ZXh0dXJlS2V5LCBmcmFtZTogdGV4dHVyZUZyYW1lLCB2aXNpYmxlOiBib29sZWFuIH1cclxuICAgIC8vICAgICAgXSxcclxuXHJcbiAgICB2YXIgb3V0ID0gW107XHJcbiAgICB2YXIgcHJldjtcclxuICAgIHZhciBhbmltYXRpb25GcmFtZTtcclxuICAgIHZhciBpbmRleCA9IDE7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciB0ZXh0dXJlS2V5O1xyXG5cclxuICAgIC8vICBpZiBmcmFtZXMgaXMgYSBzdHJpbmcsIHdlJ2xsIGdldCBhbGwgdGhlIGZyYW1lcyBmcm9tIHRoZSB0ZXh0dXJlIG1hbmFnZXIgYXMgaWYgaXQncyBhIHNwcml0ZSBzaGVldFxyXG4gICAgaWYgKHR5cGVvZiBmcmFtZXMgPT09ICdzdHJpbmcnKVxyXG4gICAge1xyXG4gICAgICAgIHRleHR1cmVLZXkgPSBmcmFtZXM7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZU1hbmFnZXIuZ2V0KHRleHR1cmVLZXkpO1xyXG4gICAgICAgIHZhciBmcmFtZUtleXMgPSB0ZXh0dXJlLmdldEZyYW1lTmFtZXMoKTtcclxuXHJcbiAgICAgICAgZnJhbWVzID0gW107XHJcblxyXG4gICAgICAgIGZyYW1lS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGZyYW1lcy5wdXNoKHsga2V5OiB0ZXh0dXJlS2V5LCBmcmFtZTogdmFsdWUgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc29sZS50YWJsZShmcmFtZXMpO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShmcmFtZXMpIHx8IGZyYW1lcy5sZW5ndGggPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpdGVtID0gZnJhbWVzW2ldO1xyXG5cclxuICAgICAgICB2YXIga2V5ID0gR2V0VmFsdWUoaXRlbSwgJ2tleScsIG51bGwpO1xyXG5cclxuICAgICAgICBpZiAoIWtleSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZyYW1lID0gR2V0VmFsdWUoaXRlbSwgJ2ZyYW1lJywgMCk7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0dXJlRnJhbWUgPSB0ZXh0dXJlTWFuYWdlci5nZXRGcmFtZShrZXksIGZyYW1lKTtcclxuXHJcbiAgICAgICAgYW5pbWF0aW9uRnJhbWUgPSBuZXcgRnJhbWUoa2V5LCBmcmFtZSwgaW5kZXgsIHRleHR1cmVGcmFtZSk7XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbkZyYW1lLmR1cmF0aW9uID0gR2V0VmFsdWUoaXRlbSwgJ2R1cmF0aW9uJywgMCk7XHJcbiAgICAgICAgYW5pbWF0aW9uRnJhbWUub25VcGRhdGUgPSBHZXRWYWx1ZShpdGVtLCAnb25VcGRhdGUnLCBudWxsKTtcclxuXHJcbiAgICAgICAgdmFyIHZpc2libGUgPSBHZXRWYWx1ZShpdGVtLCAndmlzaWJsZScsIG51bGwpO1xyXG5cclxuICAgICAgICBpZiAodmlzaWJsZSAhPT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkZyYW1lLnNldFZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBhbmltYXRpb25GcmFtZS52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFuaW1hdGlvbkZyYW1lLmlzRmlyc3QgPSAoIXByZXYpO1xyXG5cclxuICAgICAgICAvLyAgVGhlIHByZXZpb3VzbHkgY3JlYXRlZCBhbmltYXRpb25GcmFtZVxyXG4gICAgICAgIGlmIChwcmV2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHJldi5uZXh0RnJhbWUgPSBhbmltYXRpb25GcmFtZTtcclxuXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkZyYW1lLnByZXZGcmFtZSA9IHByZXY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdXQucHVzaChhbmltYXRpb25GcmFtZSk7XHJcblxyXG4gICAgICAgIHByZXYgPSBhbmltYXRpb25GcmFtZTtcclxuXHJcbiAgICAgICAgaW5kZXgrKztcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3V0Lmxlbmd0aCA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgYW5pbWF0aW9uRnJhbWUuaXNMYXN0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gIExpbmsgdGhlbSBlbmQtdG8tZW5kLCBzbyB0aGV5IGxvb3BcclxuICAgICAgICBhbmltYXRpb25GcmFtZS5uZXh0RnJhbWUgPSBvdXRbMF07XHJcblxyXG4gICAgICAgIG91dFswXS5wcmV2RnJhbWUgPSBhbmltYXRpb25GcmFtZTtcclxuXHJcbiAgICAgICAgLy8gIEdlbmVyYXRlIHRoZSBwcm9ncmVzcyBkYXRhXHJcblxyXG4gICAgICAgIHZhciBzbGljZSA9IDEgLyAob3V0Lmxlbmd0aCAtIDEpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3V0W2ldLnByb2dyZXNzID0gaSAqIHNsaWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRGcmFtZXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL2luYy9HZXRGcmFtZXMuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgTWF0cml4NCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvTWF0cml4NCcpO1xyXG52YXIgUmFuZG9tWFlaID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9SYW5kb21YWVonKTtcclxudmFyIFJhbmRvbVhZWlcgPSByZXF1aXJlKCcuLi8uLi9tYXRoL1JhbmRvbVhZWlcnKTtcclxudmFyIFJvdGF0ZVZlYzMgPSByZXF1aXJlKCcuLi8uLi9tYXRoL1JvdGF0ZVZlYzMnKTtcclxudmFyIFNldCA9IHJlcXVpcmUoJy4uLy4uL3N0cnVjdHMvU2V0Jyk7XHJcbnZhciBTcHJpdGUzRCA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL3Nwcml0ZTNkL1Nwcml0ZTNEJyk7XHJcbnZhciBWZWN0b3IyID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWN0b3IyJyk7XHJcbnZhciBWZWN0b3IzID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWN0b3IzJyk7XHJcbnZhciBWZWN0b3I0ID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9WZWN0b3I0Jyk7XHJcblxyXG4vLyAgTG9jYWwgY2FjaGUgdmFyc1xyXG52YXIgdG1wVmVjMyA9IG5ldyBWZWN0b3IzKCk7XHJcbnZhciB0bXBWZWM0ID0gbmV3IFZlY3RvcjQoKTtcclxudmFyIGRpcnZlYyA9IG5ldyBWZWN0b3IzKCk7XHJcbnZhciByaWdodHZlYyA9IG5ldyBWZWN0b3IzKCk7XHJcbnZhciBiaWxsYm9hcmRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cclxudmFyIENhbWVyYTNEID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoc2NlbmUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuICAgICAgICB0aGlzLmRpc3BsYXlMaXN0ID0gc2NlbmUuc3lzLmRpc3BsYXlMaXN0O1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGlzdCA9IHNjZW5lLnN5cy51cGRhdGVMaXN0O1xyXG5cclxuICAgICAgICB0aGlzLm5hbWUgPSAnJztcclxuXHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAtMSk7XHJcbiAgICAgICAgdGhpcy51cCA9IG5ldyBWZWN0b3IzKDAsIDEsIDApO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAvLyAgVGhlIG1hcHBpbmcgZnJvbSAzRCBzaXplIHVuaXRzIHRvIHBpeGVscy5cclxuICAgICAgICAvLyAgSW4gdGhlIGRlZmF1bHQgY2FzZSAxIDNEIHVuaXQgPSAxMjggcGl4ZWxzLiBTbyBhIHNwcml0ZSB0aGF0IGlzXHJcbiAgICAgICAgLy8gIDI1NiB4IDEyOCBweCBpbiBzaXplIHdpbGwgYmUgMiB4IDEgdW5pdHMuXHJcbiAgICAgICAgLy8gIENoYW5nZSB0byB3aGF0ZXZlciBiZXN0IGZpdHMgeW91ciBnYW1lIGFzc2V0cy5cclxuICAgICAgICB0aGlzLnBpeGVsU2NhbGUgPSAxMjg7XHJcblxyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbiA9IG5ldyBNYXRyaXg0KCk7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICB0aGlzLmNvbWJpbmVkID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICB0aGlzLmludlByb2plY3Rpb25WaWV3ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5uZWFyID0gMTtcclxuICAgICAgICB0aGlzLmZhciA9IDEwMDtcclxuXHJcbiAgICAgICAgdGhpcy5yYXkgPSB7XHJcbiAgICAgICAgICAgIG9yaWdpbjogbmV3IFZlY3RvcjMoKSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy52aWV3cG9ydFdpZHRoID0gMDtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0SGVpZ2h0ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5iaWxsYm9hcmRNYXRyaXhEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSwgeilcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLnNldCh4LCB5LCB6KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjZW5lOiBmdW5jdGlvbiAoc2NlbmUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UGl4ZWxTY2FsZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGl4ZWxTY2FsZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoc3ByaXRlM0QpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zZXQoc3ByaXRlM0QpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBzcHJpdGUzRDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5TGlzdC5yZW1vdmUoY2hpbGQuZ2FtZU9iamVjdCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVMaXN0LnJlbW92ZShjaGlsZC5nYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGRyZW5baV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldENoaWxkcmVuOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmVudHJpZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKHgsIHksIHosIGtleSwgZnJhbWUsIHZpc2libGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHZpc2libGUgPT09IHVuZGVmaW5lZCkgeyB2aXNpYmxlID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgICB2YXIgY2hpbGQgPSBuZXcgU3ByaXRlM0QodGhpcy5zY2VuZSwgeCwgeSwgeiwga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGxheUxpc3QuYWRkKGNoaWxkLmdhbWVPYmplY3QpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGlzdC5hZGQoY2hpbGQuZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIGNoaWxkLnZpc2libGUgPSB2aXNpYmxlO1xyXG5cclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNldChjaGlsZCk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVNdWx0aXBsZTogZnVuY3Rpb24gKHF1YW50aXR5LCBrZXksIGZyYW1lLCB2aXNpYmxlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHsgdmlzaWJsZSA9IHRydWU7IH1cclxuXHJcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1YW50aXR5OyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBuZXcgU3ByaXRlM0QodGhpcy5zY2VuZSwgMCwgMCwgMCwga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlMaXN0LmFkZChjaGlsZC5nYW1lT2JqZWN0KTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaXN0LmFkZChjaGlsZC5nYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkLnZpc2libGUgPSB2aXNpYmxlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zZXQoY2hpbGQpO1xyXG5cclxuICAgICAgICAgICAgb3V0cHV0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENyZWF0ZSBhIGJ1bmNoIG9mIFNwcml0ZTNEIG9iamVjdHMgaW4gYSByZWN0YW5nbGVcclxuICAgIC8vICBzaXplIGFuZCBzcGFjaW5nIGFyZSBWZWMzcyAob3IgaWYgaW50ZWdlcnMgYXJlIGNvbnZlcnRlZCB0byB2ZWMzcylcclxuICAgIGNyZWF0ZVJlY3Q6IGZ1bmN0aW9uIChzaXplLCBzcGFjaW5nLCBrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHsgc2l6ZSA9IHsgeDogc2l6ZSwgeTogc2l6ZSwgejogc2l6ZSB9OyB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzcGFjaW5nID09PSAnbnVtYmVyJykgeyBzcGFjaW5nID0geyB4OiBzcGFjaW5nLCB5OiBzcGFjaW5nLCB6OiBzcGFjaW5nIH07IH1cclxuXHJcbiAgICAgICAgdmFyIHF1YW50aXR5ID0gc2l6ZS54ICogc2l6ZS55ICogc2l6ZS56O1xyXG5cclxuICAgICAgICB2YXIgc3ByaXRlcyA9IHRoaXMuY3JlYXRlTXVsdGlwbGUocXVhbnRpdHksIGtleSwgZnJhbWUpO1xyXG5cclxuICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHogPSAwLjUgLSAoc2l6ZS56IC8gMik7IHogPCAoc2l6ZS56IC8gMik7IHorKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwLjUgLSAoc2l6ZS55IC8gMik7IHkgPCAoc2l6ZS55IC8gMik7IHkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAuNSAtIChzaXplLnggLyAyKTsgeCA8IChzaXplLnggLyAyKTsgeCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBieCA9ICh4ICogc3BhY2luZy54KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnkgPSAoeSAqIHNwYWNpbmcueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ6ID0gKHogKiBzcGFjaW5nLnopO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVzW2ldLnBvc2l0aW9uLnNldChieCwgYnksIGJ6KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gc3ByaXRlcztcclxuICAgIH0sXHJcblxyXG4gICAgcmFuZG9tU3BoZXJlOiBmdW5jdGlvbiAocmFkaXVzLCBzcHJpdGVzKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChzcHJpdGVzID09PSB1bmRlZmluZWQpIHsgc3ByaXRlcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTsgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwcml0ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBSYW5kb21YWVooc3ByaXRlc1tpXS5wb3NpdGlvbiwgcmFkaXVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICByYW5kb21DdWJlOiBmdW5jdGlvbiAoc2NhbGUsIHNwcml0ZXMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNwcml0ZXMgPT09IHVuZGVmaW5lZCkgeyBzcHJpdGVzID0gdGhpcy5nZXRDaGlsZHJlbigpOyB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ByaXRlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFJhbmRvbVhZWlcoc3ByaXRlc1tpXS5wb3NpdGlvbiwgc2NhbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zbGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAodmVjMywgc3ByaXRlcylcclxuICAgIHtcclxuICAgICAgICBpZiAoc3ByaXRlcyA9PT0gdW5kZWZpbmVkKSB7IHNwcml0ZXMgPSB0aGlzLmdldENoaWxkcmVuKCk7IH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHJpdGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3ByaXRlc1tpXS5wb3NpdGlvbi5hZGQodmVjMyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNmb3JtQ2hpbGRyZW46IGZ1bmN0aW9uIChtYXQ0LCBzcHJpdGVzKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChzcHJpdGVzID09PSB1bmRlZmluZWQpIHsgc3ByaXRlcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTsgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwcml0ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzcHJpdGVzW2ldLnBvc2l0aW9uLnRyYW5zZm9ybU1hdDQobWF0NCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC4gRG9lcyBub3RcclxuICAgICAqIHVwZGF0ZSBhbnkgbWF0cmljZXMuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZXRob2QgIHNldFZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggIHRoZSB2aWV3cG9ydCB3aWR0aFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCB0aGUgdmlld3BvcnQgaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIHNldFZpZXdwb3J0OiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0V2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0SGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGVzIHRoaXMgY2FtZXJhIGJ5IGEgc3BlY2lmaWVkIFZlY3RvcjMgb2JqZWN0XHJcbiAgICAgKiBvciB4LCB5LCB6IHBhcmFtZXRlcnMuIEFueSB1bmRlZmluZWQgeCB5IHogdmFsdWVzIHdpbGxcclxuICAgICAqIGRlZmF1bHQgdG8gemVybywgbGVhdmluZyB0aGF0IGNvbXBvbmVudCB1bmFmZmVjdGVkLlxyXG4gICAgICogSWYgeW91IHdpc2ggdG8gc2V0IHRoZSBjYW1lcmEgcG9zaXRpb24gZGlyZWN0bHkgY2FsbCBzZXRQb3NpdGlvbiBpbnN0ZWFkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdmVjIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSwgeilcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi54ICs9IHgueCB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgKz0geC55IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueiArPSB4LnogfHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi54ICs9IHggfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ICs9IHkgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi56ICs9IHogfHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBsb29rQXQ6IGZ1bmN0aW9uICh4LCB5LCB6KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkaXIgPSB0aGlzLmRpcmVjdGlvbjtcclxuICAgICAgICB2YXIgdXAgPSB0aGlzLnVwO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGlyLmNvcHkoeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRpci5zZXQoeCwgeSwgeik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkaXIuc3ViKHRoaXMucG9zaXRpb24pLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAvLyAgQ2FsY3VsYXRlIHJpZ2h0IHZlY3RvclxyXG4gICAgICAgIHRtcFZlYzMuY29weShkaXIpLmNyb3NzKHVwKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgLy8gIENhbGN1bGF0ZSB1cCB2ZWN0b3JcclxuICAgICAgICB1cC5jb3B5KHRtcFZlYzMpLmNyb3NzKGRpcikubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGU6IGZ1bmN0aW9uIChyYWRpYW5zLCBheGlzKVxyXG4gICAge1xyXG4gICAgICAgIFJvdGF0ZVZlYzModGhpcy5kaXJlY3Rpb24sIGF4aXMsIHJhZGlhbnMpO1xyXG4gICAgICAgIFJvdGF0ZVZlYzModGhpcy51cCwgYXhpcywgcmFkaWFucyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVBcm91bmQ6IGZ1bmN0aW9uIChwb2ludCwgcmFkaWFucywgYXhpcylcclxuICAgIHtcclxuICAgICAgICB0bXBWZWMzLmNvcHkocG9pbnQpLnN1Yih0aGlzLnBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGUodG1wVmVjMyk7XHJcbiAgICAgICAgdGhpcy5yb3RhdGUocmFkaWFucywgYXhpcyk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGUodG1wVmVjMy5uZWdhdGUoKSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcm9qZWN0OiBmdW5jdGlvbiAodmVjLCBvdXQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBWZWN0b3I0KCk7IH1cclxuXHJcbiAgICAgICAgLy8gIFRPRE86IHN1cHBvcnQgdmlld3BvcnQgWFlcclxuICAgICAgICB2YXIgdmlld3BvcnRXaWR0aCA9IHRoaXMudmlld3BvcnRXaWR0aDtcclxuICAgICAgICB2YXIgdmlld3BvcnRIZWlnaHQgPSB0aGlzLnZpZXdwb3J0SGVpZ2h0O1xyXG4gICAgICAgIHZhciBuID0gQ2FtZXJhM0QuTkVBUl9SQU5HRTtcclxuICAgICAgICB2YXIgZiA9IENhbWVyYTNELkZBUl9SQU5HRTtcclxuXHJcbiAgICAgICAgLy8gIEZvciB1c2VmdWwgWiBhbmQgVyB2YWx1ZXMgd2Ugc2hvdWxkIGRvIHRoZSB1c3VhbCBzdGVwczogY2xpcCBzcGFjZSAtPiBOREMgLT4gd2luZG93IGNvb3Jkc1xyXG5cclxuICAgICAgICAvLyAgSW1wbGljaXQgMS4wIGZvciB3IGNvbXBvbmVudFxyXG4gICAgICAgIHRtcFZlYzQuc2V0KHZlYy54LCB2ZWMueSwgdmVjLnosIDEuMCk7XHJcblxyXG4gICAgICAgIC8vICBUcmFuc2Zvcm0gaW50byBjbGlwIHNwYWNlXHJcbiAgICAgICAgdG1wVmVjNC50cmFuc2Zvcm1NYXQ0KHRoaXMuY29tYmluZWQpO1xyXG5cclxuICAgICAgICAvLyAgQXZvaWQgZGl2aWRlIGJ5IHplcm8gd2hlbiAweDB4MCBjYW1lcmEgcHJvamVjdHMgdG8gYSAweDB4MCB2ZWMzXHJcbiAgICAgICAgaWYgKHRtcFZlYzQudyA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRtcFZlYzQudyA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgTm93IGludG8gTkRDXHJcbiAgICAgICAgdG1wVmVjNC54ID0gdG1wVmVjNC54IC8gdG1wVmVjNC53O1xyXG4gICAgICAgIHRtcFZlYzQueSA9IHRtcFZlYzQueSAvIHRtcFZlYzQudztcclxuICAgICAgICB0bXBWZWM0LnogPSB0bXBWZWM0LnogLyB0bXBWZWM0Lnc7XHJcblxyXG4gICAgICAgIC8vICBBbmQgZmluYWxseSBpbnRvIHdpbmRvdyBjb29yZGluYXRlc1xyXG4gICAgICAgIG91dC54ID0gdmlld3BvcnRXaWR0aCAvIDIgKiB0bXBWZWM0LnggKyAoMCArIHZpZXdwb3J0V2lkdGggLyAyKTtcclxuICAgICAgICBvdXQueSA9IHZpZXdwb3J0SGVpZ2h0IC8gMiAqIHRtcFZlYzQueSArICgwICsgdmlld3BvcnRIZWlnaHQgLyAyKTtcclxuICAgICAgICBvdXQueiA9IChmIC0gbikgLyAyICogdG1wVmVjNC56ICsgKGYgKyBuKSAvIDI7XHJcblxyXG4gICAgICAgIC8vICBJZiB0aGUgb3V0IHZlY3RvciBoYXMgYSBmb3VydGggY29tcG9uZW50LCB3ZSBhbHNvIHN0b3JlICgxL2NsaXAudyksIHNhbWUgaWRlYSBhcyBnbF9GcmFnQ29vcmQud1xyXG4gICAgICAgIGlmIChvdXQudyA9PT0gMCB8fCBvdXQudylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dC53ID0gMSAvIHRtcFZlYzQudztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHVucHJvamVjdDogZnVuY3Rpb24gKHZlYywgb3V0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgVmVjdG9yMygpOyB9XHJcblxyXG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHRtcFZlYzQuc2V0KDAsIDAsIHRoaXMudmlld3BvcnRXaWR0aCwgdGhpcy52aWV3cG9ydEhlaWdodCk7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXQuY29weSh2ZWMpLnVucHJvamVjdCh2aWV3cG9ydCwgdGhpcy5pbnZQcm9qZWN0aW9uVmlldyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBpY2tSYXk6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLnJheS5vcmlnaW4uc2V0KHgsIHksIDApO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLnJheS5kaXJlY3Rpb24uc2V0KHgsIHksIDEpO1xyXG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHRtcFZlYzQuc2V0KDAsIDAsIHRoaXMudmlld3BvcnRXaWR0aCwgdGhpcy52aWV3cG9ydEhlaWdodCk7XHJcbiAgICAgICAgdmFyIG10eCA9IHRoaXMuaW52UHJvamVjdGlvblZpZXc7XHJcblxyXG4gICAgICAgIG9yaWdpbi51bnByb2plY3Qodmlld3BvcnQsIG10eCk7XHJcblxyXG4gICAgICAgIGRpcmVjdGlvbi51bnByb2plY3Qodmlld3BvcnQsIG10eCk7XHJcblxyXG4gICAgICAgIGRpcmVjdGlvbi5zdWIob3JpZ2luKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmF5O1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmVudHJpZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGlsZHJlbltpXS5wcm9qZWN0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBPdmVycmlkZW4gYnkgc3ViY2xhc3Nlc1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNoaWxkcmVuKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUJpbGxib2FyZE1hdHJpeDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZGlyID0gZGlydmVjLnNldCh0aGlzLmRpcmVjdGlvbikubmVnYXRlKCk7XHJcblxyXG4gICAgICAgIC8vIEJldHRlciB2aWV3LWFsaWduZWQgYmlsbGJvYXJkcyBtaWdodCB1c2UgdGhpczpcclxuICAgICAgICAvLyB2YXIgZGlyID0gdG1wLnNldChjYW1lcmEucG9zaXRpb24pLnN1YihwKS5ub3JtYWxpemUoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmlnaHQgPSByaWdodHZlYy5zZXQodGhpcy51cCkuY3Jvc3MoZGlyKS5ub3JtYWxpemUoKTtcclxuICAgICAgICB2YXIgdXAgPSB0bXBWZWMzLnNldChkaXIpLmNyb3NzKHJpZ2h0KS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgdmFyIG91dCA9IGJpbGxib2FyZE1hdHJpeC52YWw7XHJcblxyXG4gICAgICAgIG91dFswXSA9IHJpZ2h0Lng7XHJcbiAgICAgICAgb3V0WzFdID0gcmlnaHQueTtcclxuICAgICAgICBvdXRbMl0gPSByaWdodC56O1xyXG4gICAgICAgIG91dFszXSA9IDA7XHJcblxyXG4gICAgICAgIG91dFs0XSA9IHVwLng7XHJcbiAgICAgICAgb3V0WzVdID0gdXAueTtcclxuICAgICAgICBvdXRbNl0gPSB1cC56O1xyXG4gICAgICAgIG91dFs3XSA9IDA7XHJcblxyXG4gICAgICAgIG91dFs4XSA9IGRpci54O1xyXG4gICAgICAgIG91dFs5XSA9IGRpci55O1xyXG4gICAgICAgIG91dFsxMF0gPSBkaXIuejtcclxuICAgICAgICBvdXRbMTFdID0gMDtcclxuXHJcbiAgICAgICAgb3V0WzEyXSA9IDA7XHJcbiAgICAgICAgb3V0WzEzXSA9IDA7XHJcbiAgICAgICAgb3V0WzE0XSA9IDA7XHJcbiAgICAgICAgb3V0WzE1XSA9IDE7XHJcblxyXG4gICAgICAgIHRoaXMuYmlsbGJvYXJkTWF0cml4RGlydHkgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gZm9yIGNhbnZhcyAzRCByZW5kZXJpbmcsIFxyXG4gICAgICogd2hpY2ggZGV0ZXJtaW5lcyB0aGUgXCJwb2ludCBzaXplXCIgb2YgYSBjYW1lcmEtZmFjaW5nXHJcbiAgICAgKiBzcHJpdGUgYmlsbGJvYXJkIGdpdmVuIGl0cyAzRCB3b3JsZCBwb3NpdGlvbiBcclxuICAgICAqIChvcmlnaW4gYXQgY2VudGVyIG9mIHNwcml0ZSkgYW5kIGl0cyB3b3JsZCB3aWR0aFxyXG4gICAgICogYW5kIGhlaWdodCBpbiB4L3kuIFxyXG4gICAgICpcclxuICAgICAqIFdlIHBsYWNlIGludG8gdGhlIG91dHB1dCBWZWN0b3IyIHRoZSBzY2FsZWQgd2lkdGhcclxuICAgICAqIGFuZCBoZWlnaHQuIElmIG5vIGBvdXRgIGlzIHNwZWNpZmllZCwgYSBuZXcgVmVjdG9yMlxyXG4gICAgICogd2lsbCBiZSBjcmVhdGVkIGZvciBjb252ZW5pZW5jZSAodGhpcyBzaG91bGQgYmUgYXZvaWRlZCBcclxuICAgICAqIGluIHRpZ2h0IGxvb3BzKS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtICB7VmVjdG9yM30gdmVjIHRoZSBwb3NpdGlvbiBvZiB0aGUgM0Qgc3ByaXRlXHJcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBzaXplIHRoZSB4IGFuZCB5IGRpbWVuc2lvbnMgb2YgdGhlIHNwcml0ZVxyXG4gICAgICogQHBhcmFtICB7VmVjdG9yMn0gb3V0IHRoZSByZXN1bHQsIHNjYWxlZCB4IGFuZCB5IGRpbWVuc2lvbnMgaW4gM0Qgc3BhY2VcclxuICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9IHJldHVybnMgdGhlIG91dCBwYXJhbWV0ZXIsIG9yIGEgbmV3IFZlY3RvcjIgaWYgbm9uZSB3YXMgZ2l2ZW5cclxuICAgICAqL1xyXG4gICAgZ2V0UG9pbnRTaXplOiBmdW5jdGlvbiAodmVjLCBzaXplLCBvdXQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBWZWN0b3IyKCk7IH1cclxuXHJcbiAgICAgICAgLy9UT0RPOiBvcHRpbWl6ZSB0aGlzIHdpdGggYSBzaW1wbGUgZGlzdGFuY2UgY2FsY3VsYXRpb246XHJcbiAgICAgICAgLy9odHRwczovL2RldmVsb3Blci52YWx2ZXNvZnR3YXJlLmNvbS93aWtpL0ZpZWxkX29mX1ZpZXdcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYmlsbGJvYXJkTWF0cml4RGlydHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJpbGxib2FyZE1hdHJpeCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRtcCA9IHRtcFZlYzM7XHJcblxyXG4gICAgICAgIHZhciBkeCA9IChzaXplLnggLyB0aGlzLnBpeGVsU2NhbGUpIC8gMjtcclxuICAgICAgICB2YXIgZHkgPSAoc2l6ZS55IC8gdGhpcy5waXhlbFNjYWxlKSAvIDI7XHJcblxyXG4gICAgICAgIHRtcC5zZXQoLWR4LCAtZHksIDApLnRyYW5zZm9ybU1hdDQoYmlsbGJvYXJkTWF0cml4KS5hZGQodmVjKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9qZWN0KHRtcCwgdG1wKTtcclxuXHJcbiAgICAgICAgdmFyIHRseCA9IHRtcC54O1xyXG4gICAgICAgIHZhciB0bHkgPSB0bXAueTtcclxuXHJcbiAgICAgICAgdG1wLnNldChkeCwgZHksIDApLnRyYW5zZm9ybU1hdDQoYmlsbGJvYXJkTWF0cml4KS5hZGQodmVjKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9qZWN0KHRtcCwgdG1wKTtcclxuXHJcbiAgICAgICAgdmFyIGJyeCA9IHRtcC54O1xyXG4gICAgICAgIHZhciBicnkgPSB0bXAueTtcclxuXHJcbiAgICAgICAgLy8gdmFyIHcgPSBNYXRoLmFicyhicnggLSB0bHgpO1xyXG4gICAgICAgIC8vIHZhciBoID0gTWF0aC5hYnMoYnJ5IC0gdGx5KTtcclxuXHJcbiAgICAgICAgLy8gIEFsbG93IHRoZSBwcm9qZWN0aW9uIHRvIGdldCBuZWdhdGl2ZSAuLi5cclxuICAgICAgICB2YXIgdyA9IGJyeCAtIHRseDtcclxuICAgICAgICB2YXIgaCA9IGJyeSAtIHRseTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dC5zZXQodywgaCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLnNjZW5lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFg6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFk6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFo6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLnogPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHg6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB5OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgejoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLno7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnogPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbkNhbWVyYTNELkZBUl9SQU5HRSA9IDEuMDtcclxuQ2FtZXJhM0QuTkVBUl9SQU5HRSA9IDAuMDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FtZXJhM0Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzNkL0NhbWVyYTNELmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhbWVyYTNEID0gcmVxdWlyZSgnLi9DYW1lcmEzRCcpO1xyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgTWF0cml4NCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvTWF0cml4NCcpO1xyXG52YXIgVmVjdG9yMyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvVmVjdG9yMycpO1xyXG52YXIgVmVjdG9yNCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvVmVjdG9yNCcpO1xyXG5cclxuLy8gIExvY2FsIGNhY2hlIHZhcnNcclxudmFyIHRtcFZlYzMgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxudmFyIE9ydGhvZ3JhcGhpY0NhbWVyYSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogQ2FtZXJhM0QsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHNjZW5lLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAodmlld3BvcnRXaWR0aCA9PT0gdW5kZWZpbmVkKSB7IHZpZXdwb3J0V2lkdGggPSAwOyB9XHJcbiAgICAgICAgaWYgKHZpZXdwb3J0SGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgdmlld3BvcnRIZWlnaHQgPSAwOyB9XHJcblxyXG4gICAgICAgIENhbWVyYTNELmNhbGwodGhpcywgc2NlbmUpO1xyXG5cclxuICAgICAgICB0aGlzLnZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy5fem9vbSA9IDEuMDtcclxuXHJcbiAgICAgICAgdGhpcy5uZWFyID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VG9PcnRobzogZnVuY3Rpb24gKHlEb3duLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAodmlld3BvcnRXaWR0aCA9PT0gdW5kZWZpbmVkKSB7IHZpZXdwb3J0V2lkdGggPSB0aGlzLnZpZXdwb3J0V2lkdGg7IH1cclxuICAgICAgICBpZiAodmlld3BvcnRIZWlnaHQgPT09IHVuZGVmaW5lZCkgeyB2aWV3cG9ydEhlaWdodCA9IHRoaXMudmlld3BvcnRIZWlnaHQ7IH1cclxuXHJcbiAgICAgICAgdmFyIHpvb20gPSB0aGlzLnpvb207XHJcblxyXG4gICAgICAgIHRoaXMudXAuc2V0KDAsICh5RG93bikgPyAtMSA6IDEsIDApO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldCgwLCAwLCAoeURvd24pID8gMSA6IC0xKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLnNldCh6b29tICogdmlld3BvcnRXaWR0aCAvIDIsIHpvb20gKiB2aWV3cG9ydEhlaWdodCAvIDIsIDApO1xyXG5cclxuICAgICAgICB0aGlzLnZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvL1RPRE86IHN1cHBvcnQgeC95IG9mZnNldFxyXG4gICAgICAgIHZhciB3ID0gdGhpcy52aWV3cG9ydFdpZHRoO1xyXG4gICAgICAgIHZhciBoID0gdGhpcy52aWV3cG9ydEhlaWdodDtcclxuICAgICAgICB2YXIgbmVhciA9IE1hdGguYWJzKHRoaXMubmVhcik7XHJcbiAgICAgICAgdmFyIGZhciA9IE1hdGguYWJzKHRoaXMuZmFyKTtcclxuICAgICAgICB2YXIgem9vbSA9IHRoaXMuem9vbTtcclxuXHJcbiAgICAgICAgaWYgKHcgPT09IDAgfHwgaCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBXaGF0IHRvIGRvIGhlcmUuLi4gaG1tP1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbi5vcnRobyhcclxuICAgICAgICAgICAgem9vbSAqIC13IC8gMiwgem9vbSAqIHcgLyAyLFxyXG4gICAgICAgICAgICB6b29tICogLWggLyAyLCB6b29tICogaCAvIDIsXHJcbiAgICAgICAgICAgIG5lYXIsXHJcbiAgICAgICAgICAgIGZhclxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vICBCdWlsZCB0aGUgdmlldyBtYXRyaXggXHJcbiAgICAgICAgdG1wVmVjMy5jb3B5KHRoaXMucG9zaXRpb24pLmFkZCh0aGlzLmRpcmVjdGlvbik7XHJcblxyXG4gICAgICAgIHRoaXMudmlldy5sb29rQXQodGhpcy5wb3NpdGlvbiwgdG1wVmVjMywgdGhpcy51cCk7XHJcblxyXG4gICAgICAgIC8vICBQcm9qZWN0aW9uICogdmlldyBtYXRyaXhcclxuICAgICAgICB0aGlzLmNvbWJpbmVkLmNvcHkodGhpcy5wcm9qZWN0aW9uKS5tdWwodGhpcy52aWV3KTtcclxuXHJcbiAgICAgICAgLy8gIEludmVydCBjb21iaW5lZCBtYXRyaXgsIHVzZWQgZm9yIHVucHJvamVjdFxyXG4gICAgICAgIHRoaXMuaW52UHJvamVjdGlvblZpZXcuY29weSh0aGlzLmNvbWJpbmVkKS5pbnZlcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iaWxsYm9hcmRNYXRyaXhEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHpvb206IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvb207XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl96b29tID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9ydGhvZ3JhcGhpY0NhbWVyYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvM2QvT3J0aG9ncmFwaGljQ2FtZXJhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhbWVyYTNEID0gcmVxdWlyZSgnLi9DYW1lcmEzRCcpO1xyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgVmVjdG9yMyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvVmVjdG9yMycpO1xyXG5cclxuLy8gIExvY2FsIGNhY2hlIHZhcnNcclxudmFyIHRtcFZlYzMgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxudmFyIFBlcnNwZWN0aXZlQ2FtZXJhID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBDYW1lcmEzRCxcclxuXHJcbiAgICAvLyAgRk9WIGlzIGNvbnZlcnRlZCB0byByYWRpYW5zIGF1dG9tYXRpY2FsbHlcclxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChzY2VuZSwgZmllbGRPZlZpZXcsIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChmaWVsZE9mVmlldyA9PT0gdW5kZWZpbmVkKSB7IGZpZWxkT2ZWaWV3ID0gODA7IH1cclxuICAgICAgICBpZiAodmlld3BvcnRXaWR0aCA9PT0gdW5kZWZpbmVkKSB7IHZpZXdwb3J0V2lkdGggPSAwOyB9XHJcbiAgICAgICAgaWYgKHZpZXdwb3J0SGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgdmlld3BvcnRIZWlnaHQgPSAwOyB9XHJcblxyXG4gICAgICAgIENhbWVyYTNELmNhbGwodGhpcywgc2NlbmUpO1xyXG5cclxuICAgICAgICB0aGlzLnZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEhlaWdodDtcclxuICAgICAgICB0aGlzLmZpZWxkT2ZWaWV3ID0gZmllbGRPZlZpZXcgKiBNYXRoLlBJIC8gMTgwO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGT1Y6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZpZWxkT2ZWaWV3ID0gdmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhc3BlY3QgPSB0aGlzLnZpZXdwb3J0V2lkdGggLyB0aGlzLnZpZXdwb3J0SGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyAgQ3JlYXRlIGEgcGVyc3BlY3RpdmUgbWF0cml4IGZvciBvdXIgY2FtZXJhXHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uLnBlcnNwZWN0aXZlKFxyXG4gICAgICAgICAgICB0aGlzLmZpZWxkT2ZWaWV3LFxyXG4gICAgICAgICAgICBhc3BlY3QsXHJcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMubmVhciksXHJcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZmFyKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vICBCdWlsZCB0aGUgdmlldyBtYXRyaXggXHJcbiAgICAgICAgdG1wVmVjMy5jb3B5KHRoaXMucG9zaXRpb24pLmFkZCh0aGlzLmRpcmVjdGlvbik7XHJcblxyXG4gICAgICAgIHRoaXMudmlldy5sb29rQXQodGhpcy5wb3NpdGlvbiwgdG1wVmVjMywgdGhpcy51cCk7XHJcblxyXG4gICAgICAgIC8vICBQcm9qZWN0aW9uICogdmlldyBtYXRyaXhcclxuICAgICAgICB0aGlzLmNvbWJpbmVkLmNvcHkodGhpcy5wcm9qZWN0aW9uKS5tdWwodGhpcy52aWV3KTtcclxuXHJcbiAgICAgICAgLy8gIEludmVydCBjb21iaW5lZCBtYXRyaXgsIHVzZWQgZm9yIHVucHJvamVjdFxyXG4gICAgICAgIHRoaXMuaW52UHJvamVjdGlvblZpZXcuY29weSh0aGlzLmNvbWJpbmVkKS5pbnZlcnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iaWxsYm9hcmRNYXRyaXhEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGVyc3BlY3RpdmVDYW1lcmE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzNkL1BlcnNwZWN0aXZlQ2FtZXJhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcblxyXG4vLyAgdmFyIGNhbUNvbnRyb2wgPSBuZXcgQ2FtZXJhQ29udHJvbCh7XHJcbi8vICAgICAgY2FtZXJhOiB0aGlzLmNhbWVyYXMubWFpbixcclxuLy8gICAgICBsZWZ0OiBjdXJzb3JzLmxlZnQsXHJcbi8vICAgICAgcmlnaHQ6IGN1cnNvcnMucmlnaHQsXHJcbi8vICAgICAgc3BlZWQ6IGZsb2F0IE9SIHsgeDogMCwgeTogMCB9XHJcbi8vICB9KVxyXG5cclxudmFyIEtleUNvbnRyb2wgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gS2V5Q29udHJvbCAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gR2V0VmFsdWUoY29uZmlnLCAnY2FtZXJhJywgbnVsbCk7XHJcblxyXG4gICAgICAgIHRoaXMubGVmdCA9IEdldFZhbHVlKGNvbmZpZywgJ2xlZnQnLCBudWxsKTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gR2V0VmFsdWUoY29uZmlnLCAncmlnaHQnLCBudWxsKTtcclxuICAgICAgICB0aGlzLnVwID0gR2V0VmFsdWUoY29uZmlnLCAndXAnLCBudWxsKTtcclxuICAgICAgICB0aGlzLmRvd24gPSBHZXRWYWx1ZShjb25maWcsICdkb3duJywgbnVsbCk7XHJcblxyXG4gICAgICAgIHRoaXMuem9vbUluID0gR2V0VmFsdWUoY29uZmlnLCAnem9vbUluJywgbnVsbCk7XHJcbiAgICAgICAgdGhpcy56b29tT3V0ID0gR2V0VmFsdWUoY29uZmlnLCAnem9vbU91dCcsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuem9vbVNwZWVkID0gR2V0VmFsdWUoY29uZmlnLCAnem9vbVNwZWVkJywgMC4wMSk7XHJcblxyXG4gICAgICAgIHZhciBzcGVlZCA9IEdldFZhbHVlKGNvbmZpZywgJ3NwZWVkJywgbnVsbCk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygc3BlZWQgPT09ICdudW1iZXInKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zcGVlZFggPSBzcGVlZDtcclxuICAgICAgICAgICAgdGhpcy5zcGVlZFkgPSBzcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zcGVlZFggPSBHZXRWYWx1ZShjb25maWcsICdzcGVlZC54JywgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWRZID0gR2V0VmFsdWUoY29uZmlnLCAnc3BlZWQueScsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fem9vbSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gKHRoaXMuY2FtZXJhICE9PSBudWxsKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAodGhpcy5jYW1lcmEgIT09IG51bGwpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVsdGEgPT09IHVuZGVmaW5lZCkgeyBkZWx0YSA9IDE7IH1cclxuXHJcbiAgICAgICAgdmFyIGNhbSA9IHRoaXMuY2FtZXJhO1xyXG5cclxuICAgICAgICBpZiAodGhpcy51cCAmJiB0aGlzLnVwLmlzRG93bilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbS5zY3JvbGxZIC09ICgodGhpcy5zcGVlZFkgKiBkZWx0YSkgfCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb3duICYmIHRoaXMuZG93bi5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW0uc2Nyb2xsWSArPSAoKHRoaXMuc3BlZWRZICogZGVsdGEpIHwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW0uc2Nyb2xsWCAtPSAoKHRoaXMuc3BlZWRYICogZGVsdGEpIHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmlnaHQgJiYgdGhpcy5yaWdodC5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW0uc2Nyb2xsWCArPSAoKHRoaXMuc3BlZWRYICogZGVsdGEpIHwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQ2FtZXJhIHpvb21cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuem9vbUluICYmIHRoaXMuem9vbUluLmlzRG93bilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbS56b29tIC09IHRoaXMuem9vbVNwZWVkO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNhbS56b29tIDwgMC4xKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYW0uem9vbSA9IDAuMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnpvb21PdXQgJiYgdGhpcy56b29tT3V0LmlzRG93bilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbS56b29tICs9IHRoaXMuem9vbVNwZWVkO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMubGVmdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51cCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kb3duID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy56b29tSW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuem9vbU91dCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS2V5Q29udHJvbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvY29udHJvbHMvS2V5Q29udHJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG5cclxuLy8gdmFyIGNvbnRyb2xDb25maWcgPSB7XHJcbi8vICAgICBjYW1lcmE6IHRoaXMuY2FtZXJhcy5tYWluLFxyXG4vLyAgICAgbGVmdDogY3Vyc29ycy5sZWZ0LFxyXG4vLyAgICAgcmlnaHQ6IGN1cnNvcnMucmlnaHQsXHJcbi8vICAgICB1cDogY3Vyc29ycy51cCxcclxuLy8gICAgIGRvd246IGN1cnNvcnMuZG93bixcclxuLy8gICAgIHpvb21JbjogdGhpcy5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLklucHV0LktleWJvYXJkLktleUNvZGVzLlEpLFxyXG4vLyAgICAgem9vbU91dDogdGhpcy5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLklucHV0LktleWJvYXJkLktleUNvZGVzLkUpLFxyXG4vLyAgICAgem9vbVNwZWVkOiAwLjAyLFxyXG4vLyAgICAgYWNjZWxlcmF0aW9uOiAwLjA2LFxyXG4vLyAgICAgZHJhZzogMC4wMDA1LFxyXG4vLyAgICAgbWF4U3BlZWQ6IDEuMFxyXG4vLyB9O1xyXG5cclxudmFyIFNtb290aGVkS2V5Q29udHJvbCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBTbW9vdGhlZEtleUNvbnRyb2wgKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IEdldFZhbHVlKGNvbmZpZywgJ2NhbWVyYScsIG51bGwpO1xyXG5cclxuICAgICAgICB0aGlzLmxlZnQgPSBHZXRWYWx1ZShjb25maWcsICdsZWZ0JywgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IEdldFZhbHVlKGNvbmZpZywgJ3JpZ2h0JywgbnVsbCk7XHJcbiAgICAgICAgdGhpcy51cCA9IEdldFZhbHVlKGNvbmZpZywgJ3VwJywgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5kb3duID0gR2V0VmFsdWUoY29uZmlnLCAnZG93bicsIG51bGwpO1xyXG5cclxuICAgICAgICB0aGlzLnpvb21JbiA9IEdldFZhbHVlKGNvbmZpZywgJ3pvb21JbicsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuem9vbU91dCA9IEdldFZhbHVlKGNvbmZpZywgJ3pvb21PdXQnLCBudWxsKTtcclxuICAgICAgICB0aGlzLnpvb21TcGVlZCA9IEdldFZhbHVlKGNvbmZpZywgJ3pvb21TcGVlZCcsIDAuMDEpO1xyXG5cclxuICAgICAgICB2YXIgYWNjZWwgPSBHZXRWYWx1ZShjb25maWcsICdhY2NlbGVyYXRpb24nLCBudWxsKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBhY2NlbCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFjY2VsWCA9IGFjY2VsO1xyXG4gICAgICAgICAgICB0aGlzLmFjY2VsWSA9IGFjY2VsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFjY2VsWCA9IEdldFZhbHVlKGNvbmZpZywgJ2FjY2VsZXJhdGlvbi54JywgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWNjZWxZID0gR2V0VmFsdWUoY29uZmlnLCAnYWNjZWxlcmF0aW9uLnknLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkcmFnID0gR2V0VmFsdWUoY29uZmlnLCAnZHJhZycsIG51bGwpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGRyYWcgPT09ICdudW1iZXInKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnWCA9IGRyYWc7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1kgPSBkcmFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdYID0gR2V0VmFsdWUoY29uZmlnLCAnZHJhZy54JywgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1kgPSBHZXRWYWx1ZShjb25maWcsICdkcmFnLnknLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtYXhTcGVlZCA9IEdldFZhbHVlKGNvbmZpZywgJ21heFNwZWVkJywgbnVsbCk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbWF4U3BlZWQgPT09ICdudW1iZXInKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhTcGVlZFggPSBtYXhTcGVlZDtcclxuICAgICAgICAgICAgdGhpcy5tYXhTcGVlZFkgPSBtYXhTcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhTcGVlZFggPSBHZXRWYWx1ZShjb25maWcsICdtYXhTcGVlZC54JywgMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4U3BlZWRZID0gR2V0VmFsdWUoY29uZmlnLCAnbWF4U3BlZWQueScsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc3BlZWRYID0gMDtcclxuICAgICAgICB0aGlzLl9zcGVlZFkgPSAwO1xyXG4gICAgICAgIHRoaXMuX3pvb20gPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmFjdGl2ZSA9ICh0aGlzLmNhbWVyYSAhPT0gbnVsbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gKHRoaXMuY2FtZXJhICE9PSBudWxsKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkZWx0YSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlbHRhID09PSB1bmRlZmluZWQpIHsgZGVsdGEgPSAxOyB9XHJcblxyXG4gICAgICAgIHZhciBjYW0gPSB0aGlzLmNhbWVyYTtcclxuXHJcbiAgICAgICAgLy8gIEFwcGx5IERlY2VsZXJhdGlvblxyXG5cclxuICAgICAgICBpZiAodGhpcy5fc3BlZWRYID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWCAtPSB0aGlzLmRyYWdYICogZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3BlZWRYIDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRYID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zcGVlZFggPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRYICs9IHRoaXMuZHJhZ1ggKiBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGVlZFggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZFggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fc3BlZWRZID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWSAtPSB0aGlzLmRyYWdZICogZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3BlZWRZIDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRZID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zcGVlZFkgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRZICs9IHRoaXMuZHJhZ1kgKiBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGVlZFkgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZFkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQ2hlY2sgZm9yIGtleXNcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudXAgJiYgdGhpcy51cC5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFkgKz0gdGhpcy5hY2NlbFk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3BlZWRZID4gdGhpcy5tYXhTcGVlZFkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkWSA9IHRoaXMubWF4U3BlZWRZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG93biAmJiB0aGlzLmRvd24uaXNEb3duKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRZIC09IHRoaXMuYWNjZWxZO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NwZWVkWSA8IC10aGlzLm1heFNwZWVkWSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRZID0gLXRoaXMubWF4U3BlZWRZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFggKz0gdGhpcy5hY2NlbFg7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3BlZWRYID4gdGhpcy5tYXhTcGVlZFgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkWCA9IHRoaXMubWF4U3BlZWRYO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmlnaHQgJiYgdGhpcy5yaWdodC5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFggLT0gdGhpcy5hY2NlbFg7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3BlZWRYIDwgLXRoaXMubWF4U3BlZWRYKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZFggPSAtdGhpcy5tYXhTcGVlZFg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBDYW1lcmEgem9vbVxyXG5cclxuICAgICAgICBpZiAodGhpcy56b29tSW4gJiYgdGhpcy56b29tSW4uaXNEb3duKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fem9vbSA9IC10aGlzLnpvb21TcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy56b29tT3V0ICYmIHRoaXMuem9vbU91dC5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl96b29tID0gdGhpcy56b29tU3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb20gPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEFwcGx5IHRvIENhbWVyYVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fc3BlZWRYICE9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FtLnNjcm9sbFggLT0gKCh0aGlzLl9zcGVlZFggKiBkZWx0YSkgfCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9zcGVlZFkgIT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW0uc2Nyb2xsWSAtPSAoKHRoaXMuX3NwZWVkWSAqIGRlbHRhKSB8IDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3pvb20gIT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW0uem9vbSArPSB0aGlzLl96b29tO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNhbS56b29tIDwgMC4xKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYW0uem9vbSA9IDAuMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMubGVmdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51cCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kb3duID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy56b29tSW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuem9vbU91dCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU21vb3RoZWRLZXlDb250cm9sO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS9jb250cm9scy9TbW9vdGhlZEtleUNvbnRyb2wuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGVyc3BlY3RpdmVDYW1lcmEgPSByZXF1aXJlKCcuLi8uLi8zZC9QZXJzcGVjdGl2ZUNhbWVyYScpO1xyXG5cclxudmFyIEFkZFBlcnNwZWN0aXZlQ2FtZXJhID0gZnVuY3Rpb24gKGZpZWxkT2ZWaWV3LCB3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICB2YXIgY29uZmlnID0gdGhpcy5zY2VuZS5zeXMuZ2FtZS5jb25maWc7XHJcblxyXG4gICAgaWYgKGZpZWxkT2ZWaWV3ID09PSB1bmRlZmluZWQpIHsgZmllbGRPZlZpZXcgPSA4MDsgfVxyXG4gICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSBjb25maWcud2lkdGg7IH1cclxuICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSBjb25maWcuaGVpZ2h0OyB9XHJcblxyXG4gICAgdmFyIGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSh0aGlzLnNjZW5lLCBmaWVsZE9mVmlldywgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIGNhbWVyYTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkUGVyc3BlY3RpdmVDYW1lcmE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhL2xvY2FsL2luYy9BZGRQZXJzcGVjdGl2ZUNhbWVyYS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNhbnZhcywgb3B0aW9ucylcclxue1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCBvcHRpb25zKSB8fCBcclxuICAgICAgICBudWxsXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRDb250ZXh0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbnZhcy9HZXRDb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBBcm5lMTYgPSByZXF1aXJlKCcuL3BhbGV0dGVzL0FybmUxNicpO1xyXG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XHJcblxyXG52YXIgR2VuZXJhdGVUZXh0dXJlID0gZnVuY3Rpb24gKGNvbmZpZylcclxue1xyXG4gICAgdmFyIGRhdGEgPSBHZXRWYWx1ZShjb25maWcsICdkYXRhJywgW10pO1xyXG4gICAgdmFyIGNhbnZhcyA9IEdldFZhbHVlKGNvbmZpZywgJ2NhbnZhcycsIG51bGwpO1xyXG4gICAgdmFyIHBhbGV0dGUgPSBHZXRWYWx1ZShjb25maWcsICdwYWxldHRlJywgQXJuZTE2KTtcclxuICAgIHZhciBwaXhlbFdpZHRoID0gR2V0VmFsdWUoY29uZmlnLCAncGl4ZWxXaWR0aCcsIDEpO1xyXG4gICAgdmFyIHBpeGVsSGVpZ2h0ID0gR2V0VmFsdWUoY29uZmlnLCAncGl4ZWxIZWlnaHQnLCBwaXhlbFdpZHRoKTtcclxuICAgIHZhciByZXNpemVDYW52YXMgPSBHZXRWYWx1ZShjb25maWcsICdyZXNpemVDYW52YXMnLCB0cnVlKTtcclxuICAgIHZhciBjbGVhckNhbnZhcyA9IEdldFZhbHVlKGNvbmZpZywgJ2NsZWFyQ2FudmFzJywgdHJ1ZSk7XHJcbiAgICB2YXIgcHJlUmVuZGVyID0gR2V0VmFsdWUoY29uZmlnLCAncHJlUmVuZGVyJywgbnVsbCk7XHJcbiAgICB2YXIgcG9zdFJlbmRlciA9IEdldFZhbHVlKGNvbmZpZywgJ3Bvc3RSZW5kZXInLCBudWxsKTtcclxuXHJcbiAgICB2YXIgd2lkdGggPSBNYXRoLmZsb29yKE1hdGguYWJzKGRhdGFbMF0ubGVuZ3RoICogcGl4ZWxXaWR0aCkpO1xyXG4gICAgdmFyIGhlaWdodCA9IE1hdGguZmxvb3IoTWF0aC5hYnMoZGF0YS5sZW5ndGggKiBwaXhlbEhlaWdodCkpO1xyXG5cclxuICAgIGlmICghY2FudmFzKVxyXG4gICAge1xyXG4gICAgICAgIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlMkQodGhpcywgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmVzaXplQ2FudmFzID0gZmFsc2U7XHJcbiAgICAgICAgY2xlYXJDYW52YXMgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVzaXplQ2FudmFzKVxyXG4gICAge1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIGlmIChjbGVhckNhbnZhcylcclxuICAgIHtcclxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBwcmVSZW5kZXIgQ2FsbGJhY2s/XHJcbiAgICBpZiAocHJlUmVuZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHByZVJlbmRlcihjYW52YXMsIGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIERyYXcgaXRcclxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgZGF0YS5sZW5ndGg7IHkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgcm93ID0gZGF0YVt5XTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCByb3cubGVuZ3RoOyB4KyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZCA9IHJvd1t4XTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkICE9PSAnLicgJiYgZCAhPT0gJyAnKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcGFsZXR0ZVtkXTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4ICogcGl4ZWxXaWR0aCwgeSAqIHBpeGVsSGVpZ2h0LCBwaXhlbFdpZHRoLCBwaXhlbEhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIHBvc3RSZW5kZXIgQ2FsbGJhY2s/XHJcbiAgICBpZiAocG9zdFJlbmRlcilcclxuICAgIHtcclxuICAgICAgICBwb3N0UmVuZGVyKGNhbnZhcywgY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZW5lcmF0ZVRleHR1cmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY3JlYXRlL0dlbmVyYXRlVGV4dHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEEgMTYgY29sb3IgcGFsZXR0ZSBieSBbQXJuZV0oaHR0cDovL2FuZHJvaWRhcnRzLmNvbS9wYWxldHRlLzE2cGFsLmh0bSlcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgMDogJyMwMDAnLFxyXG4gICAgMTogJyM5RDlEOUQnLFxyXG4gICAgMjogJyNGRkYnLFxyXG4gICAgMzogJyNCRTI2MzMnLFxyXG4gICAgNDogJyNFMDZGOEInLFxyXG4gICAgNTogJyM0OTNDMkInLFxyXG4gICAgNjogJyNBNDY0MjInLFxyXG4gICAgNzogJyNFQjg5MzEnLFxyXG4gICAgODogJyNGN0UyNkInLFxyXG4gICAgOTogJyMyRjQ4NEUnLFxyXG4gICAgQTogJyM0NDg5MUEnLFxyXG4gICAgQjogJyNBM0NFMjcnLFxyXG4gICAgQzogJyMxQjI2MzInLFxyXG4gICAgRDogJyMwMDU3ODQnLFxyXG4gICAgRTogJyMzMUEyRjInLFxyXG4gICAgRjogJyNCMkRDRUYnXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY3JlYXRlL3BhbGV0dGVzL0FybmUxNi5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vZG9tL0NhbnZhc1Bvb2wnKTtcclxuXHJcbnZhciBDYW52YXNGZWF0dXJlcyA9IHtcclxuXHJcbiAgICBzdXBwb3J0TmV3QmxlbmRNb2RlczogZmFsc2UsXHJcblxyXG4gICAgc3VwcG9ydEludmVyc2VBbHBoYTogZmFsc2VcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBjaGVja0JsZW5kTW9kZSAoKVxyXG57XHJcbiAgICB2YXIgcG5nSGVhZCA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFRQUFBQUJBUU1BQUFERDhwMk9BQUFBQTFCTVZFWC8nO1xyXG4gICAgdmFyIHBuZ0VuZCA9ICdBQUFBQ2tsRVFWUUkxMk5nQUFBQUFnQUI0aUc4TXdBQUFBQkpSVTVFcmtKZ2dnPT0nO1xyXG5cclxuICAgIHZhciBtYWdlbnRhID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgbWFnZW50YS5vbmxvYWQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB5ZWxsb3cgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICAgICAgeWVsbG93Lm9ubG9hZCA9IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGUoeWVsbG93LCA2LCAxKTtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ211bHRpcGx5JztcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG1hZ2VudGEsIDAsIDApO1xyXG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh5ZWxsb3csIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LmdldEltYWdlRGF0YSgyLCAwLCAxLCAxKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDIsIDAsIDEsIDEpLmRhdGE7XHJcblxyXG4gICAgICAgICAgICBDYW52YXNQb29sLnJlbW92ZSh5ZWxsb3cpO1xyXG5cclxuICAgICAgICAgICAgQ2FudmFzRmVhdHVyZXMuc3VwcG9ydE5ld0JsZW5kTW9kZXMgPSAoZGF0YVswXSA9PT0gMjU1ICYmIGRhdGFbMV0gPT09IDAgJiYgZGF0YVsyXSA9PT0gMCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgeWVsbG93LnNyYyA9IHBuZ0hlYWQgKyAnL3dDS3h2UkYnICsgcG5nRW5kO1xyXG4gICAgfTtcclxuXHJcbiAgICBtYWdlbnRhLnNyYyA9IHBuZ0hlYWQgKyAnQVA4MDRPYTYnICsgcG5nRW5kO1xyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tJbnZlcnNlQWxwaGEgKClcclxue1xyXG4gICAgdmFyIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKHRoaXMsIDIsIDEpO1xyXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDEwLCAyMCwgMzAsIDAuNSknO1xyXG5cclxuICAgIC8vICBEcmF3IGEgc2luZ2xlIHBpeGVsXHJcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xyXG5cclxuICAgIC8vICBHZXQgdGhlIGNvbG9yIHZhbHVlc1xyXG4gICAgdmFyIHMxID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XHJcblxyXG4gICAgaWYgKHMxID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgUGxvdCB0aGVtIHRvIHgyXHJcbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShzMSwgMSwgMCk7XHJcblxyXG4gICAgLy8gIEdldCB0aG9zZSB2YWx1ZXNcclxuICAgIHZhciBzMiA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDEsIDAsIDEsIDEpO1xyXG5cclxuICAgIC8vICBDb21wYXJlIGFuZCByZXR1cm5cclxuICAgIHJldHVybiAoczIuZGF0YVswXSA9PT0gczEuZGF0YVswXSAmJiBzMi5kYXRhWzFdID09PSBzMS5kYXRhWzFdICYmIHMyLmRhdGFbMl0gPT09IHMxLmRhdGFbMl0gJiYgczIuZGF0YVszXSA9PT0gczEuZGF0YVszXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgaWYgKGRvY3VtZW50ICE9PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgQ2FudmFzRmVhdHVyZXMuc3VwcG9ydE5ld0JsZW5kTW9kZXMgPSBjaGVja0JsZW5kTW9kZSgpO1xyXG4gICAgICAgIENhbnZhc0ZlYXR1cmVzLnN1cHBvcnRJbnZlcnNlQWxwaGEgPSBjaGVja0ludmVyc2VBbHBoYSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBDYW52YXNGZWF0dXJlcztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGV2aWNlL0NhbnZhc0ZlYXR1cmVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xyXG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xyXG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XHJcblxyXG52YXIgRmVhdHVyZXMgPSB7XHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FudmFzIC0gSXMgY2FudmFzIGF2YWlsYWJsZT9cclxuICAgIGNhbnZhczogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGNhbnZhc0JpdEJsdFNoaWZ0IC0gVHJ1ZSBpZiBjYW52YXMgc3VwcG9ydHMgYSAnY29weScgYml0Ymx0IG9udG8gaXRzZWxmIHdoZW4gdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gcmVnaW9ucyBvdmVybGFwLlxyXG4gICAgY2FudmFzQml0Qmx0U2hpZnQ6IG51bGwsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2ViR0wgLSBJcyB3ZWJHTCBhdmFpbGFibGU/XHJcbiAgICB3ZWJHTDogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmlsZSAtIElzIGZpbGUgYXZhaWxhYmxlP1xyXG4gICAgZmlsZTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmlsZVN5c3RlbSAtIElzIGZpbGVTeXN0ZW0gYXZhaWxhYmxlP1xyXG4gICAgZmlsZVN5c3RlbTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbG9jYWxTdG9yYWdlIC0gSXMgbG9jYWxTdG9yYWdlIGF2YWlsYWJsZT9cclxuICAgIGxvY2FsU3RvcmFnZTogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd29ya2VyIC0gSXMgd29ya2VyIGF2YWlsYWJsZT9cclxuICAgIHdvcmtlcjogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcG9pbnRlckxvY2sgLSBJcyBQb2ludGVyIExvY2sgYXZhaWxhYmxlP1xyXG4gICAgcG9pbnRlckxvY2s6IGZhbHNlLFxyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IHZpYnJhdGlvbiAtIERvZXMgdGhlIGRldmljZSBzdXBwb3J0IHRoZSBWaWJyYXRpb24gQVBJP1xyXG4gICAgdmlicmF0aW9uOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBnZXRVc2VyTWVkaWEgLSBEb2VzIHRoZSBkZXZpY2Ugc3VwcG9ydCB0aGUgZ2V0VXNlck1lZGlhIEFQST9cclxuICAgIGdldFVzZXJNZWRpYTogdHJ1ZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBsaXR0bGVFbmRpYW4gLSBJcyB0aGUgZGV2aWNlIGJpZyBvciBsaXR0bGUgZW5kaWFuPyAob25seSBkZXRlY3RlZCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBUeXBlZEFycmF5cylcclxuICAgIGxpdHRsZUVuZGlhbjogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3VwcG9ydDMyYml0IC0gRG9lcyB0aGUgZGV2aWNlIGNvbnRleHQgc3VwcG9ydCAzMmJpdCBwaXhlbCBtYW5pcHVsYXRpb24gdXNpbmcgYXJyYXkgYnVmZmVyIHZpZXdzP1xyXG4gICAgc3VwcG9ydDMyYml0OiBmYWxzZVxyXG5cclxufTtcclxuXHJcbi8vIENoZWNrIExpdHRsZSBvciBCaWcgRW5kaWFuIHN5c3RlbS5cclxuLy8gQGF1dGhvciBNYXR0IERlc0xhdXJpZXJzIChAbWF0dGRlc2wpXHJcbmZ1bmN0aW9uIGNoZWNrSXNMaXR0bGVFbmRpYW4gKClcclxue1xyXG4gICAgdmFyIGEgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XHJcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGEpO1xyXG4gICAgdmFyIGMgPSBuZXcgVWludDMyQXJyYXkoYSk7XHJcblxyXG4gICAgYlswXSA9IDB4YTE7XHJcbiAgICBiWzFdID0gMHhiMjtcclxuICAgIGJbMl0gPSAweGMzO1xyXG4gICAgYlszXSA9IDB4ZDQ7XHJcblxyXG4gICAgaWYgKGNbMF0gPT09IDB4ZDRjM2IyYTEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNbMF0gPT09IDB4YTFiMmMzZDQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vICBDb3VsZCBub3QgZGV0ZXJtaW5lIGVuZGlhbm5lc3NcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdCAoKVxyXG57XHJcbiAgICBGZWF0dXJlcy5jYW52YXMgPSAhIXdpbmRvd1snQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEJ10gfHwgT1MuY29jb29uSlM7XHJcblxyXG4gICAgdHJ5XHJcbiAgICB7XHJcbiAgICAgICAgRmVhdHVyZXMubG9jYWxTdG9yYWdlID0gISFsb2NhbFN0b3JhZ2UuZ2V0SXRlbTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcilcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5sb2NhbFN0b3JhZ2UgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBGZWF0dXJlcy5maWxlID0gISF3aW5kb3dbJ0ZpbGUnXSAmJiAhIXdpbmRvd1snRmlsZVJlYWRlciddICYmICEhd2luZG93WydGaWxlTGlzdCddICYmICEhd2luZG93WydCbG9iJ107XHJcbiAgICBGZWF0dXJlcy5maWxlU3lzdGVtID0gISF3aW5kb3dbJ3JlcXVlc3RGaWxlU3lzdGVtJ107XHJcblxyXG4gICAgdmFyIGlzVWludDggPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgdGVzdFdlYkdMID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAod2luZG93WydXZWJHTFJlbmRlcmluZ0NvbnRleHQnXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRyeVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGVXZWJHTCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoT1MuY29jb29uSlMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnNjcmVlbmNhbnZhcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhczJEID0gQ2FudmFzUG9vbC5jcmVhdGUyRCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY3R4MkQgPSBjYW52YXMyRC5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICBDYW4ndCBiZSBkb25lIG9uIGEgd2ViZ2wgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gY3R4MkQuY3JlYXRlSW1hZ2VEYXRhKDEsIDEpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICogVGVzdCB0byBzZWUgaWYgSW1hZ2VEYXRhIHVzZXMgQ2FudmFzUGl4ZWxBcnJheSBvciBVaW50OENsYW1wZWRBcnJheS5cclxuICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICogQGF1dGhvciBNYXR0IERlc0xhdXJpZXJzIChAbWF0dGRlc2wpXHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaXNVaW50OCA9IGltYWdlLmRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheTtcclxuXHJcbiAgICAgICAgICAgICAgICBDYW52YXNQb29sLnJlbW92ZShjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgQ2FudmFzUG9vbC5yZW1vdmUoY2FudmFzMkQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAoY3R4ICE9PSBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgRmVhdHVyZXMud2ViR0wgPSB0cnVlOy8vdGVzdFdlYkdMKCk7XHJcblxyXG4gICAgRmVhdHVyZXMud29ya2VyID0gISF3aW5kb3dbJ1dvcmtlciddO1xyXG5cclxuICAgIEZlYXR1cmVzLnBvaW50ZXJMb2NrID0gJ3BvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQgfHwgJ21velBvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQgfHwgJ3dlYmtpdFBvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQ7XHJcblxyXG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iub0dldFVzZXJNZWRpYTtcclxuXHJcbiAgICB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xyXG5cclxuICAgIEZlYXR1cmVzLmdldFVzZXJNZWRpYSA9IEZlYXR1cmVzLmdldFVzZXJNZWRpYSAmJiAhIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgISF3aW5kb3cuVVJMO1xyXG5cclxuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIGZpcmVmb3ggKDwgMjEpIGFwcGFyZW50bHkgY2xhaW0gc3VwcG9ydCBidXQgdXNlciBtZWRpYSBkb2VzIG5vdCBhY3R1YWxseSB3b3JrXHJcbiAgICBpZiAoQnJvd3Nlci5maXJlZm94ICYmIEJyb3dzZXIuZmlyZWZveFZlcnNpb24gPCAyMSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5nZXRVc2VyTWVkaWEgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeGNsdWRlcyBpT1MgdmVyc2lvbnMgYXMgdGhleSBnZW5lcmFsbHkgd3JhcCBVSVdlYlZpZXcgKGVnLiBTYWZhcmkgV2ViS2l0KSBhbmQgaXRcclxuICAgIC8vIGlzIHNhZmVyIHRvIG5vdCB0cnkgYW5kIHVzZSB0aGUgZmFzdCBjb3B5LW92ZXIgbWV0aG9kLlxyXG4gICAgaWYgKCFPUy5pT1MgJiYgKEJyb3dzZXIuaWUgfHwgQnJvd3Nlci5maXJlZm94IHx8IEJyb3dzZXIuY2hyb21lKSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5jYW52YXNCaXRCbHRTaGlmdCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gS25vd24gbm90IHRvIHdvcmtcclxuICAgIGlmIChCcm93c2VyLnNhZmFyaSB8fCBCcm93c2VyLm1vYmlsZVNhZmFyaSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5jYW52YXNCaXRCbHRTaGlmdCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIG5hdmlnYXRvci52aWJyYXRlID0gbmF2aWdhdG9yLnZpYnJhdGUgfHwgbmF2aWdhdG9yLndlYmtpdFZpYnJhdGUgfHwgbmF2aWdhdG9yLm1velZpYnJhdGUgfHwgbmF2aWdhdG9yLm1zVmlicmF0ZTtcclxuXHJcbiAgICBpZiAobmF2aWdhdG9yLnZpYnJhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgRmVhdHVyZXMudmlicmF0aW9uID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJylcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5saXR0bGVFbmRpYW4gPSBjaGVja0lzTGl0dGxlRW5kaWFuKCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmVhdHVyZXMuc3VwcG9ydDMyYml0ID0gKFxyXG4gICAgICAgIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgdHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgRmVhdHVyZXMubGl0dGxlRW5kaWFuICE9PSBudWxsICYmXHJcbiAgICAgICAgaXNVaW50OFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gRmVhdHVyZXM7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RldmljZS9GZWF0dXJlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBZGRUb0RPTSA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQsIG92ZXJmbG93SGlkZGVuKVxyXG57XHJcbiAgICBpZiAob3ZlcmZsb3dIaWRkZW4gPT09IHVuZGVmaW5lZCkgeyBvdmVyZmxvd0hpZGRlbiA9IHRydWU7IH1cclxuXHJcbiAgICB2YXIgdGFyZ2V0O1xyXG5cclxuICAgIGlmIChwYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEhvcGVmdWxseSBhbiBlbGVtZW50IElEXHJcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdvYmplY3QnICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBRdWljayB0ZXN0IGZvciBhIEhUTUxlbGVtZW50XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZhbGxiYWNrLCBjb3ZlcnMgYW4gaW52YWxpZCBJRCBhbmQgYSBub24gSFRNTGVsZW1lbnQgb2JqZWN0XHJcbiAgICBpZiAoIXRhcmdldClcclxuICAgIHtcclxuICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvdmVyZmxvd0hpZGRlbiAmJiB0YXJnZXQuc3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGRUb0RPTTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vQWRkVG9ET00uanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT1MgPSByZXF1aXJlKCcuLi9kZXZpY2UvT1MnKTtcclxuXHJcbnZhciBpc0Jvb3RlZCA9IGZhbHNlO1xyXG5cclxudmFyIERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIGlmIChpc0Jvb3RlZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJylcclxuICAgIHtcclxuICAgICAgICBpc0Jvb3RlZCA9IHRydWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaXNCb290ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGNoZWNrLCB0cnVlKTtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2hlY2ssIHRydWUpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgY2hlY2ssIHRydWUpO1xyXG5cclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIWRvY3VtZW50LmJvZHkpXHJcbiAgICB7XHJcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2ssIDIwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKE9TLmNvcmRvdmEgJiYgIU9TLmNvY29vbkpTKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBSZWYuIGh0dHA6Ly9kb2NzLnBob25lZ2FwLmNvbS9lbi8zLjUuMC9jb3Jkb3ZhX2V2ZW50c19ldmVudHMubWQuaHRtbCNkZXZpY2VyZWFkeVxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgY2hlY2ssIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2hlY2ssIHRydWUpO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY2hlY2ssIHRydWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBET01Db250ZW50TG9hZGVkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RvbS9ET01Db250ZW50TG9hZGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhcnNlWE1MID0gZnVuY3Rpb24gKGRhdGEpXHJcbntcclxuICAgIHZhciB4bWwgPSAnJztcclxuXHJcbiAgICB0cnlcclxuICAgIHtcclxuICAgICAgICBpZiAod2luZG93WydET01QYXJzZXInXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkb21wYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XHJcbiAgICAgICAgICAgIHhtbCA9IGRvbXBhcnNlci5wYXJzZUZyb21TdHJpbmcoZGF0YSwgJ3RleHQveG1sJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XHJcbiAgICAgICAgICAgIHhtbC5sb2FkWE1MKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKVxyXG4gICAge1xyXG4gICAgICAgIHhtbCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF4bWwgfHwgIXhtbC5kb2N1bWVudEVsZW1lbnQgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpLmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4geG1sO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZVhNTDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vUGFyc2VYTUwuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTk9PUCA9IHJlcXVpcmUoJy4uL3V0aWxzL05PT1AnKTtcclxuXHJcbi8vIEFic3RyYWN0cyBhd2F5IHRoZSB1c2Ugb2YgUkFGIG9yIHNldFRpbWVPdXQgZm9yIHRoZSBjb3JlIGdhbWUgdXBkYXRlIGxvb3AuXHJcbnZhciBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvLyBAcHJvcGVydHkge2Jvb2xlYW59IGlzUnVubmluZyAtIHRydWUgaWYgUmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlzIHJ1bm5pbmcsIG90aGVyd2lzZSBmYWxzZS5cclxuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5jYWxsYmFjayA9IE5PT1A7XHJcblxyXG4gICAgdGhpcy50aWNrID0gMDtcclxuXHJcbiAgICAvLyBAcHJvcGVydHkge2Jvb2xlYW59IGlzU2V0VGltZU91dCAgLSBUcnVlIGlmIHRoZSBicm93c2VyIGlzIHVzaW5nIHNldFRpbWVvdXQgaW5zdGVhZCBvZiByQWYuXHJcbiAgICB0aGlzLmlzU2V0VGltZU91dCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lT3V0SUQgLSBUaGUgY2FsbGJhY2sgc2V0VGltZW91dCBvciByQWYgY2FsbGJhY2sgSUQgdXNlZCB3aGVuIGNhbGxpbmcgY2FuY2VsLlxyXG4gICAgdGhpcy50aW1lT3V0SUQgPSBudWxsO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgLy8gIHRpbWVzdGFtcCA9IERPTUhpZ2hSZXNUaW1lU3RhbXBcclxuICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKHRpbWVzdGFtcClcclxuICAgIHtcclxuICAgICAgICBfdGhpcy50aWNrID0gdGltZXN0YW1wO1xyXG5cclxuICAgICAgICBfdGhpcy5jYWxsYmFjayh0aW1lc3RhbXApO1xyXG5cclxuICAgICAgICBfdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3RlcFRpbWVvdXQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgX3RoaXMudGljayA9IGQ7XHJcblxyXG4gICAgICAgIF90aGlzLmNhbGxiYWNrKGQpO1xyXG5cclxuICAgICAgICBfdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cuc2V0VGltZW91dChzdGVwVGltZW91dCwgX3RoaXMudGltZVRvQ2FsbCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3RlcCA9IHN0ZXA7XHJcbiAgICB0aGlzLnN0ZXBUaW1lb3V0ID0gc3RlcFRpbWVvdXQ7XHJcbn07XHJcblxyXG5SZXF1ZXN0QW5pbWF0aW9uRnJhbWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuUmVxdWVzdEFuaW1hdGlvbkZyYW1lLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvLyBTdGFydHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBydW5uaW5nIG9yIHNldFRpbWVvdXQgaWYgdW5hdmFpbGFibGUgaW4gYnJvd3NlclxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgZm9yY2VTZXRUaW1lT3V0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgdGhpcy5pc1NldFRpbWVPdXQgPSBmb3JjZVNldFRpbWVPdXQ7XHJcblxyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy50aW1lT3V0SUQgPSAoZm9yY2VTZXRUaW1lT3V0KSA/IHdpbmRvdy5zZXRUaW1lb3V0KF90aGlzLnN0ZXBUaW1lb3V0LCAwKSA6IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMuc3RlcCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFN0b3BzIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJvbSBydW5uaW5nLlxyXG4gICAgc3RvcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc1NldFRpbWVPdXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lT3V0SUQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy50aW1lT3V0SUQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IE5PT1A7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9tL1JlcXVlc3RBbmltYXRpb25GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFVkVOVF9DT05TVCA9IHtcclxuXHJcbiAgICBESVNQQVRDSEVSX0lETEU6IDAsXHJcbiAgICBESVNQQVRDSEVSX0RJU1BBVENISU5HOiAxLFxyXG4gICAgRElTUEFUQ0hFUl9SRU1PVklORzogMixcclxuICAgIERJU1BBVENIRVJfREVTVFJPWUVEOiAzLFxyXG5cclxuICAgIExJU1RFTkVSX1BFTkRJTkc6IDQsXHJcbiAgICBMSVNURU5FUl9BQ1RJVkU6IDUsXHJcbiAgICBMSVNURU5FUl9SRU1PVklORzogNlxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRVZFTlRfQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZXZlbnRzL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG5cclxudmFyIEJ1aWxkR2FtZU9iamVjdEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChzcHJpdGUsIGNvbmZpZylcclxue1xyXG4gICAgdmFyIGFuaW1Db25maWcgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2FuaW1zJywgbnVsbCk7XHJcblxyXG4gICAgaWYgKGFuaW1Db25maWcgPT09IG51bGwpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHNwcml0ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGFuaW1Db25maWcgPT09ICdzdHJpbmcnKVxyXG4gICAge1xyXG4gICAgICAgIC8vICB7IGFuaW1zOiAna2V5JyB9XHJcbiAgICAgICAgc3ByaXRlLmFuaW1zLnBsYXkoYW5pbUNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgYW5pbUNvbmZpZyA9PT0gJ29iamVjdCcpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIHsgYW5pbXM6IHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAga2V5OiBzdHJpbmdcclxuICAgICAgICAvLyAgICAgICAgICAgICAgc3RhcnRGcmFtZTogW3N0cmluZ3xpbnRlZ2VyXVxyXG4gICAgICAgIC8vICAgICAgICAgICAgICBkZWxheTogW2Zsb2F0XVxyXG4gICAgICAgIC8vICAgICAgICAgICAgICByZXBlYXQ6IFtpbnRlZ2VyXVxyXG4gICAgICAgIC8vICAgICAgICAgICAgICByZXBlYXREZWxheTogW2Zsb2F0XVxyXG4gICAgICAgIC8vICAgICAgICAgICAgICB5b3lvOiBbYm9vbGVhbl1cclxuICAgICAgICAvLyAgICAgICAgICAgICAgcGxheTogW2Jvb2xlYW5dXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgIGRlbGF5ZWRQbGF5OiBbYm9vbGVhbl1cclxuICAgICAgICAvLyAgICAgICAgICAgfVxyXG4gICAgICAgIC8vICB9XHJcblxyXG4gICAgICAgIHZhciBhbmltcyA9IHNwcml0ZS5hbmltcztcclxuXHJcbiAgICAgICAgdmFyIGtleSA9IEdldEFkdmFuY2VkVmFsdWUoYW5pbUNvbmZpZywgJ2tleScsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdmFyIHN0YXJ0RnJhbWUgPSBHZXRBZHZhbmNlZFZhbHVlKGFuaW1Db25maWcsICdzdGFydEZyYW1lJywgdW5kZWZpbmVkKTtcclxuXHJcbiAgICAgICAgdmFyIGRlbGF5ID0gR2V0QWR2YW5jZWRWYWx1ZShhbmltQ29uZmlnLCAnZGVsYXknLCAwKTtcclxuICAgICAgICB2YXIgcmVwZWF0ID0gR2V0QWR2YW5jZWRWYWx1ZShhbmltQ29uZmlnLCAncmVwZWF0JywgMCk7XHJcbiAgICAgICAgdmFyIHJlcGVhdERlbGF5ID0gR2V0QWR2YW5jZWRWYWx1ZShhbmltQ29uZmlnLCAncmVwZWF0RGVsYXknLCAwKTtcclxuICAgICAgICB2YXIgeW95byA9IEdldEFkdmFuY2VkVmFsdWUoYW5pbUNvbmZpZywgJ3lveW8nLCBmYWxzZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHBsYXkgPSBHZXRBZHZhbmNlZFZhbHVlKGFuaW1Db25maWcsICdwbGF5JywgZmFsc2UpO1xyXG4gICAgICAgIHZhciBkZWxheWVkUGxheSA9IEdldEFkdmFuY2VkVmFsdWUoYW5pbUNvbmZpZywgJ2RlbGF5ZWRQbGF5JywgMCk7XHJcblxyXG4gICAgICAgIGFuaW1zLmRlbGF5KGRlbGF5KTtcclxuICAgICAgICBhbmltcy5yZXBlYXQocmVwZWF0KTtcclxuICAgICAgICBhbmltcy5yZXBlYXREZWxheShyZXBlYXREZWxheSk7XHJcbiAgICAgICAgYW5pbXMueW95byh5b3lvKTtcclxuXHJcbiAgICAgICAgaWYgKHBsYXkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbmltcy5wbGF5KGtleSwgc3RhcnRGcmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRlbGF5ZWRQbGF5ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFuaW1zLmRlbGF5ZWRQbGF5KGRlbGF5ZWRQbGF5LCBrZXksIHN0YXJ0RnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbmltcy5sb2FkKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzcHJpdGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkR2FtZU9iamVjdEFuaW1hdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9CdWlsZEdhbWVPYmplY3RBbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIEdldEJpdG1hcFRleHRTaXplID0gZnVuY3Rpb24gKHNyYywgcm91bmQpXHJcbntcclxuICAgIHZhciB0ZXh0ID0gc3JjLnRleHQ7XHJcbiAgICB2YXIgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xyXG5cclxuICAgIHZhciBieCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICB2YXIgYnkgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgdmFyIGJ3ID0gMDtcclxuICAgIHZhciBiaCA9IDA7XHJcbiAgICBcclxuICAgIHZhciBjaGFycyA9IHNyYy5mb250RGF0YS5jaGFycztcclxuICAgIHZhciBsaW5lSGVpZ2h0ID0gc3JjLmZvbnREYXRhLmxpbmVIZWlnaHQ7XHJcblxyXG4gICAgdmFyIHhBZHZhbmNlID0gMDtcclxuICAgIHZhciB5QWR2YW5jZSA9IDA7XHJcblxyXG4gICAgdmFyIGluZGV4Q291bnQgPSAwO1xyXG4gICAgdmFyIGNoYXJDb2RlID0gMDtcclxuXHJcbiAgICB2YXIgZ2x5cGggPSBudWxsO1xyXG4gICAgdmFyIGdseXBoVyA9IDA7XHJcbiAgICB2YXIgZ2x5cGhIID0gMDtcclxuXHJcbiAgICB2YXIgeCA9IDA7XHJcbiAgICB2YXIgeSA9IDA7XHJcblxyXG4gICAgdmFyIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgbGFzdENoYXJDb2RlID0gMDtcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGV4dExlbmd0aDsgKytpbmRleClcclxuICAgIHtcclxuICAgICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpbmRleCk7XHJcblxyXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gMTApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4QWR2YW5jZSA9IDA7XHJcbiAgICAgICAgICAgIGluZGV4Q291bnQgPSAwO1xyXG4gICAgICAgICAgICB5QWR2YW5jZSArPSBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgICBsYXN0R2x5cGggPSBudWxsO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdseXBoID0gY2hhcnNbY2hhckNvZGVdO1xyXG5cclxuICAgICAgICBpZiAoIWdseXBoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbHlwaFcgPSBnbHlwaC53aWR0aDtcclxuICAgICAgICBnbHlwaEggPSBnbHlwaC5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHggPSBpbmRleENvdW50ICsgZ2x5cGgueE9mZnNldCArIHhBZHZhbmNlO1xyXG4gICAgICAgIHkgPSBnbHlwaC55T2Zmc2V0ICsgeUFkdmFuY2U7XHJcblxyXG4gICAgICAgIGlmIChsYXN0R2x5cGggIT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIga2VybmluZ09mZnNldCA9IGdseXBoLmtlcm5pbmdbbGFzdENoYXJDb2RlXTtcclxuICAgICAgICAgICAgeCArPSAoa2VybmluZ09mZnNldCAhPT0gdW5kZWZpbmVkKSA/IGtlcm5pbmdPZmZzZXQgOiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJ4ID4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJ4ID0geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChieSA+IHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBieSA9IHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ3cgPSB4ICsgZ2x5cGhXIC0gYng7XHJcbiAgICAgICAgdmFyIGdoID0geSArIGdseXBoSCAtIGJ5O1xyXG5cclxuICAgICAgICBpZiAoYncgPCBndylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJ3ID0gZ3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChiaCA8IGdoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmggPSBnaDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhBZHZhbmNlICs9IGdseXBoLnhBZHZhbmNlO1xyXG4gICAgICAgIGluZGV4Q291bnQgKz0gMTtcclxuICAgICAgICBsYXN0R2x5cGggPSBnbHlwaDtcclxuICAgICAgICBsYXN0Q2hhckNvZGUgPSBjaGFyQ29kZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2NhbGUgPSAoc3JjLmZvbnRTaXplIC8gc3JjLmZvbnREYXRhLnNpemUpO1xyXG4gICAgdmFyIHN4ID0gc2NhbGUgKiBzcmMuc2NhbGVYO1xyXG4gICAgdmFyIHN5ID0gc2NhbGUgKiBzcmMuc2NhbGVZO1xyXG5cclxuICAgIHZhciBvdXQgPSB7XHJcbiAgICAgICAgbG9jYWw6IHtcclxuICAgICAgICAgICAgeDogYnggKiBzY2FsZSxcclxuICAgICAgICAgICAgeTogYnkgKiBzY2FsZSxcclxuICAgICAgICAgICAgd2lkdGg6IGJ3ICogc2NhbGUsXHJcbiAgICAgICAgICAgIGhlaWdodDogYmggKiBzY2FsZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2xvYmFsOiB7XHJcbiAgICAgICAgICAgIHg6IHNyYy54ICsgKGJ4ICogc3gpLFxyXG4gICAgICAgICAgICB5OiBzcmMueSArIChieSAqIHN5KSxcclxuICAgICAgICAgICAgd2lkdGg6IGJ3ICogc3gsXHJcbiAgICAgICAgICAgIGhlaWdodDogYmggKiBzeVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHJvdW5kKVxyXG4gICAge1xyXG4gICAgICAgIG91dC5sb2NhbC54ID0gTWF0aC5yb3VuZChvdXQubG9jYWwueCk7XHJcbiAgICAgICAgb3V0LmxvY2FsLnkgPSBNYXRoLnJvdW5kKG91dC5sb2NhbC55KTtcclxuICAgICAgICBvdXQubG9jYWwud2lkdGggPSBNYXRoLnJvdW5kKG91dC5sb2NhbC53aWR0aCk7XHJcbiAgICAgICAgb3V0LmxvY2FsLmhlaWdodCA9IE1hdGgucm91bmQob3V0LmxvY2FsLmhlaWdodCk7XHJcblxyXG4gICAgICAgIG91dC5nbG9iYWwueCA9IE1hdGgucm91bmQob3V0Lmdsb2JhbC54KTtcclxuICAgICAgICBvdXQuZ2xvYmFsLnkgPSBNYXRoLnJvdW5kKG91dC5nbG9iYWwueSk7XHJcbiAgICAgICAgb3V0Lmdsb2JhbC53aWR0aCA9IE1hdGgucm91bmQob3V0Lmdsb2JhbC53aWR0aCk7XHJcbiAgICAgICAgb3V0Lmdsb2JhbC5oZWlnaHQgPSBNYXRoLnJvdW5kKG91dC5nbG9iYWwuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRCaXRtYXBUZXh0U2l6ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L0dldEJpdG1hcFRleHRTaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gZ2V0VmFsdWUgKG5vZGUsIGF0dHJpYnV0ZSlcclxue1xyXG4gICAgcmV0dXJuIHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSksIDEwKTtcclxufVxyXG5cclxudmFyIFBhcnNlWE1MQml0bWFwRm9udCA9IGZ1bmN0aW9uICh4bWwsIHhTcGFjaW5nLCB5U3BhY2luZywgZnJhbWUpXHJcbntcclxuICAgIGlmICh4U3BhY2luZyA9PT0gdW5kZWZpbmVkKSB7IHhTcGFjaW5nID0gMDsgfVxyXG4gICAgaWYgKHlTcGFjaW5nID09PSB1bmRlZmluZWQpIHsgeVNwYWNpbmcgPSAwOyB9XHJcblxyXG4gICAgdmFyIGRhdGEgPSB7fTtcclxuICAgIHZhciBpbmZvID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbmZvJylbMF07XHJcbiAgICB2YXIgY29tbW9uID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjb21tb24nKVswXTtcclxuXHJcbiAgICBkYXRhLmZvbnQgPSBpbmZvLmdldEF0dHJpYnV0ZSgnZmFjZScpO1xyXG4gICAgZGF0YS5zaXplID0gZ2V0VmFsdWUoaW5mbywgJ3NpemUnKTtcclxuICAgIGRhdGEubGluZUhlaWdodCA9IGdldFZhbHVlKGNvbW1vbiwgJ2xpbmVIZWlnaHQnKSArIHlTcGFjaW5nO1xyXG4gICAgZGF0YS5jaGFycyA9IHt9O1xyXG5cclxuICAgIHZhciBsZXR0ZXJzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjaGFyJyk7XHJcblxyXG4gICAgdmFyIHggPSAwO1xyXG4gICAgdmFyIHkgPSAwO1xyXG4gICAgdmFyIGN4ID0gMDtcclxuICAgIHZhciBjeSA9IDA7XHJcbiAgICB2YXIgYWRqdXN0Rm9yVHJpbSA9IChmcmFtZSAhPT0gdW5kZWZpbmVkICYmIGZyYW1lLnRyaW1tZWQpO1xyXG5cclxuICAgIGlmIChhZGp1c3RGb3JUcmltKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0b3AgPSBmcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBmcmFtZS53aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGlmZiA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXR0ZXJzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBub2RlID0gbGV0dGVyc1tpXTtcclxuXHJcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gZ2V0VmFsdWUobm9kZSwgJ2lkJyk7XHJcbiAgICAgICAgdmFyIGd4ID0gZ2V0VmFsdWUobm9kZSwgJ3gnKTtcclxuICAgICAgICB2YXIgZ3kgPSBnZXRWYWx1ZShub2RlLCAneScpO1xyXG4gICAgICAgIHZhciBndyA9IGdldFZhbHVlKG5vZGUsICd3aWR0aCcpO1xyXG4gICAgICAgIHZhciBnaCA9IGdldFZhbHVlKG5vZGUsICdoZWlnaHQnKTtcclxuXHJcbiAgICAgICAgLy8gIEhhbmRsZSBmcmFtZSB0cmltIGlzc3Vlc1xyXG5cclxuICAgICAgICBpZiAoYWRqdXN0Rm9yVHJpbSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGlmIChneCArIGd3ID4gZnJhbWUud2lkdGgpXHJcbiAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgLy8gICAgIGRpZmYgPSBmcmFtZS53aWR0aCAtIChneCArIGd3KTtcclxuICAgICAgICAgICAgICAgIC8vIGd3IC09IGRpZmY7XHJcbiAgICAgICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIChneSArIGdoID4gZnJhbWUuaGVpZ2h0KVxyXG4gICAgICAgICAgICAvLyB7XHJcbiAgICAgICAgICAgIC8vICAgICBkaWZmID0gZnJhbWUuaGVpZ2h0IC0gKGd5ICsgZ2gpO1xyXG4gICAgICAgICAgICAgICAgLy8gZ2ggLT0gZGlmZjtcclxuICAgICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgICAgaWYgKGd4IDwgbGVmdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGd4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZ3kgPCB0b3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRvcCA9IGd5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYXRhLmNoYXJzW2NoYXJDb2RlXSA9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4OiBneCxcclxuICAgICAgICAgICAgeTogZ3ksXHJcbiAgICAgICAgICAgIHdpZHRoOiBndyxcclxuICAgICAgICAgICAgaGVpZ2h0OiBnaCxcclxuICAgICAgICAgICAgY2VudGVyWDogTWF0aC5mbG9vcihndyAvIDIpLFxyXG4gICAgICAgICAgICBjZW50ZXJZOiBNYXRoLmZsb29yKGdoIC8gMiksXHJcbiAgICAgICAgICAgIHhPZmZzZXQ6IGdldFZhbHVlKG5vZGUsICd4b2Zmc2V0JyksXHJcbiAgICAgICAgICAgIHlPZmZzZXQ6IGdldFZhbHVlKG5vZGUsICd5b2Zmc2V0JyksXHJcbiAgICAgICAgICAgIHhBZHZhbmNlOiBnZXRWYWx1ZShub2RlLCAneGFkdmFuY2UnKSArIHhTcGFjaW5nLFxyXG4gICAgICAgICAgICBkYXRhOiB7fSxcclxuICAgICAgICAgICAga2VybmluZzoge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhZGp1c3RGb3JUcmltICYmIHRvcCAhPT0gMCAmJiBsZWZ0ICE9PSAwKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b3AgYW5kIGxlZnQnLCB0b3AsIGxlZnQsIGZyYW1lLngsIGZyYW1lLnkpO1xyXG5cclxuICAgICAgICAvLyAgTm93IHdlIGtub3cgdGhlIHRvcCBhbmQgbGVmdCBjb29yZGluYXRlcyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBvcmlnaW5hbCBkYXRhXHJcbiAgICAgICAgLy8gIHNvIHdlIGNhbiB3b3JrIG91dCBob3cgbXVjaCB0byBhZGp1c3QgdGhlIGdseXBocyBieVxyXG5cclxuICAgICAgICBmb3IgKHZhciBjb2RlIGluIGRhdGEuY2hhcnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBkYXRhLmNoYXJzW2NvZGVdO1xyXG5cclxuICAgICAgICAgICAgZ2x5cGgueCAtPSBmcmFtZS54O1xyXG4gICAgICAgICAgICBnbHlwaC55IC09IGZyYW1lLnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBrZXJuaW5ncyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgna2VybmluZycpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXJuaW5ncy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIga2VybiA9IGtlcm5pbmdzW2ldO1xyXG5cclxuICAgICAgICB2YXIgZmlyc3QgPSBnZXRWYWx1ZShrZXJuLCAnZmlyc3QnKTtcclxuICAgICAgICB2YXIgc2Vjb25kID0gZ2V0VmFsdWUoa2VybiwgJ3NlY29uZCcpO1xyXG4gICAgICAgIHZhciBhbW91bnQgPSBnZXRWYWx1ZShrZXJuLCAnYW1vdW50Jyk7XHJcblxyXG4gICAgICAgIGRhdGEuY2hhcnNbc2Vjb25kXS5rZXJuaW5nW2ZpcnN0XSA9IGFtb3VudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFyc2VYTUxCaXRtYXBGb250O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvUGFyc2VYTUxCaXRtYXBGb250LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi9Db21tYW5kcycpO1xyXG52YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgR3JhcGhpY3NDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhLCByZW5kZXJUYXJnZXRDdHgpXHJcbntcclxuICAgIGlmIChHYW1lT2JqZWN0LlJFTkRFUl9NQVNLICE9PSBzcmMucmVuZGVyRmxhZ3MgfHwgKHNyYy5jYW1lcmFGaWx0ZXIgPiAwICYmIChzcmMuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYICogc3JjLnNjcm9sbEZhY3Rvclg7XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWSA9IGNhbWVyYS5zY3JvbGxZICogc3JjLnNjcm9sbEZhY3Rvclk7XHJcbiAgICB2YXIgc3JjWCA9IHNyYy54O1xyXG4gICAgdmFyIHNyY1kgPSBzcmMueTtcclxuICAgIHZhciBzcmNTY2FsZVggPSBzcmMuc2NhbGVYO1xyXG4gICAgdmFyIHNyY1NjYWxlWSA9IHNyYy5zY2FsZVk7XHJcbiAgICB2YXIgc3JjUm90YXRpb24gPSBzcmMucm90YXRpb247XHJcbiAgICB2YXIgY29tbWFuZEJ1ZmZlciA9IHNyYy5jb21tYW5kQnVmZmVyO1xyXG4gICAgdmFyIGN0eCA9IHJlbmRlclRhcmdldEN0eCB8fCByZW5kZXJlci5jdXJyZW50Q29udGV4dDtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIHZhciBsaW5lQWxwaGEgPSAxLjA7XHJcbiAgICB2YXIgZmlsbEFscGhhID0gMS4wO1xyXG4gICAgdmFyIGxpbmVDb2xvciA9IDA7XHJcbiAgICB2YXIgZmlsbENvbG9yID0gMDtcclxuICAgIHZhciBsaW5lV2lkdGggPSAxLjA7XHJcbiAgICB2YXIgcmVkID0gMDtcclxuICAgIHZhciBncmVlbiA9IDA7XHJcbiAgICB2YXIgYmx1ZSA9IDA7XHJcblxyXG4gICAgLy8gIEJsZW5kIE1vZGVcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlICE9PSBzcmMuYmxlbmRNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgPSBzcmMuYmxlbmRNb2RlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3NyYy5ibGVuZE1vZGVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBbHBoYVxyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRBbHBoYSAhPT0gc3JjLmFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRBbHBoYSA9IHNyYy5hbHBoYTtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNtb290aGluZ1xyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgIT09IHNyYy5zY2FsZU1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSA9IHNyYy5zY2FsZU1vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC50cmFuc2xhdGUoc3JjWCAtIGNhbWVyYVNjcm9sbFgsIHNyY1kgLSBjYW1lcmFTY3JvbGxZKTtcclxuICAgIGN0eC5yb3RhdGUoc3JjUm90YXRpb24pO1xyXG4gICAgY3R4LnNjYWxlKHNyY1NjYWxlWCwgc3JjU2NhbGVZKTtcclxuICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmZic7XHJcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSBzcmMuYWxwaGE7XHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBjb21tYW5kQnVmZmVyLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNvbW1hbmRJRCA9IGNvbW1hbmRCdWZmZXJbaW5kZXhdO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGNvbW1hbmRJRClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQVJDOlxyXG4gICAgICAgICAgICAgICAgY3R4LmFyYyhcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAzXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDVdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyA2XVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTElORV9TVFlMRTpcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgIGxpbmVDb2xvciA9IGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXTtcclxuICAgICAgICAgICAgICAgIGxpbmVBbHBoYSA9IGNvbW1hbmRCdWZmZXJbaW5kZXggKyAzXTtcclxuICAgICAgICAgICAgICAgIHJlZCA9ICgobGluZUNvbG9yICYgMHhGRjAwMDApID4+PiAxNik7XHJcbiAgICAgICAgICAgICAgICBncmVlbiA9ICgobGluZUNvbG9yICYgMHhGRjAwKSA+Pj4gOCk7XHJcbiAgICAgICAgICAgICAgICBibHVlID0gKGxpbmVDb2xvciAmIDB4RkYpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHJlZCArICcsJyArIGdyZWVuICsgJywnICsgYmx1ZSArICcsJyArIGxpbmVBbHBoYSArICcpJztcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSAzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkZJTExfU1RZTEU6XHJcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3IgPSBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV07XHJcbiAgICAgICAgICAgICAgICBmaWxsQWxwaGEgPSBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl07XHJcbiAgICAgICAgICAgICAgICByZWQgPSAoKGZpbGxDb2xvciAmIDB4RkYwMDAwKSA+Pj4gMTYpO1xyXG4gICAgICAgICAgICAgICAgZ3JlZW4gPSAoKGZpbGxDb2xvciAmIDB4RkYwMCkgPj4+IDgpO1xyXG4gICAgICAgICAgICAgICAgYmx1ZSA9IChmaWxsQ29sb3IgJiAweEZGKTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgnICsgcmVkICsgJywnICsgZ3JlZW4gKyAnLCcgKyBibHVlICsgJywnICsgZmlsbEFscGhhICsgJyknO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5CRUdJTl9QQVRIOlxyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkNMT1NFX1BBVEg6XHJcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9QQVRIOlxyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TVFJPS0VfUEFUSDpcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1JFQ1Q6XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgM10sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDRdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1RSSUFOR0xFOlxyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXSk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyAzXSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDRdKTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDVdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgNl0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXSk7XHJcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TVFJPS0VfVFJJQU5HTEU6XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdKTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDNdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgNF0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjb21tYW5kQnVmZmVyW2luZGV4ICsgNV0sIGNvbW1hbmRCdWZmZXJbaW5kZXggKyA2XSk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdKTtcclxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTElORV9UTzpcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTU9WRV9UTzpcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTElORV9GWF9UTzpcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTU9WRV9GWF9UTzpcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuU0FWRTpcclxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuUkVTVE9SRTpcclxuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuVFJBTlNMQVRFOlxyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TQ0FMRTpcclxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5ST1RBVEU6XHJcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQaGFzZXI6IEludmFsaWQgR3JhcGhpY3MgQ29tbWFuZCBJRCAnICsgY29tbWFuZElEKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaGljc0NhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxuXHJcbnZhciBGb3J3YXJkUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGxpZ2h0TGF5ZXIsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIHZhciBzcHJpdGVMaXN0ID0gbGlnaHRMYXllci5zcHJpdGVzO1xyXG4gICAgdmFyIGxlbmd0aCA9IHNwcml0ZUxpc3QubGVuZ3RoO1xyXG4gICAgdmFyIGJhdGNoID0gcmVuZGVyZXIuc3ByaXRlQmF0Y2g7XHJcblxyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IGxpZ2h0TGF5ZXIucmVuZGVyRmxhZ3MgfHwgbGVuZ3RoID09PSAwICB8fCAobGlnaHRMYXllci5jYW1lcmFGaWx0ZXIgPiAwICYmIChsaWdodExheWVyLmNhbWVyYUZpbHRlciAmIGNhbWVyYS5faWQpKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJlciAhPT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuICAgIH1cclxuXHJcbiAgICBiYXRjaC5iaW5kKGxpZ2h0TGF5ZXIucGFzc1NoYWRlcik7XHJcbiAgICBiYXRjaC5pbmRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICBsaWdodExheWVyLnVwZGF0ZUxpZ2h0cyhyZW5kZXJlciwgY2FtZXJhLCBsaWdodExheWVyLnBhc3NTaGFkZXIpO1xyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHNwcml0ZU5vcm1hbFBhaXIgPSBzcHJpdGVMaXN0W2luZGV4XTtcclxuICAgICAgICB2YXIgZ2FtZU9iamVjdCA9IHNwcml0ZU5vcm1hbFBhaXIuc3ByaXRlUmVmO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8qIElubGluZWQgZnVuY3Rpb24gb2YgYWRkIHNwcml0ZSBtb2RpZmllZC4gKi9cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wTWF0cml4ID0gYmF0Y2gudGVtcE1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIGZyYW1lID0gZ2FtZU9iamVjdC5mcmFtZTtcclxuICAgICAgICAgICAgdmFyIGZvcmNlRmxpcFkgPSAoZnJhbWUudGV4dHVyZS5zb3VyY2VbZnJhbWUuc291cmNlSW5kZXhdLmdsVGV4dHVyZS5pc1JlbmRlclRleHR1cmUgPyB0cnVlIDogZmFsc2UpO1xyXG4gICAgICAgICAgICB2YXIgZmxpcFggPSBnYW1lT2JqZWN0LmZsaXBYO1xyXG4gICAgICAgICAgICB2YXIgZmxpcFkgPSBnYW1lT2JqZWN0LmZsaXBZIF4gZm9yY2VGbGlwWTtcclxuICAgICAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBiYXRjaC52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0RjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgdmFyIHV2cyA9IGZyYW1lLnV2cztcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGggKiAoZmxpcFggPyAtMSA6IDEpO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0ICogKGZsaXBZID8gLTEgOiAxKTtcclxuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVggPSBnYW1lT2JqZWN0LnggLSBjYW1lcmEuc2Nyb2xsWCAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICAgICAgdmFyIHNjYWxlWCA9IGdhbWVPYmplY3Quc2NhbGVYO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVZID0gZ2FtZU9iamVjdC5zY2FsZVk7XHJcbiAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IC1nYW1lT2JqZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB2YXIgdGVtcE1hdHJpeE1hdHJpeCA9IHRlbXBNYXRyaXgubWF0cml4O1xyXG4gICAgICAgICAgICB2YXIgeCA9IC1nYW1lT2JqZWN0LmRpc3BsYXlPcmlnaW5YICsgZnJhbWUueCArICgoZnJhbWUud2lkdGgpICogKGZsaXBYID8gMSA6IDAuMCkpO1xyXG4gICAgICAgICAgICB2YXIgeSA9IC1nYW1lT2JqZWN0LmRpc3BsYXlPcmlnaW5ZICsgZnJhbWUueSArICgoZnJhbWUuaGVpZ2h0KSAqIChmbGlwWSA/IDEgOiAwLjApKTtcclxuICAgICAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgeWggPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgICAgICAgICAgdmFyIHNyYSwgc3JiLCBzcmMsIHNyZCwgc3JlLCBzcmYsIGNtYSwgY21iLCBjbWMsIGNtZCwgY21lLCBjbWY7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYVRMID0gZ2FtZU9iamVjdC5fYWxwaGFUTDtcclxuICAgICAgICAgICAgdmFyIGFscGhhVFIgPSBnYW1lT2JqZWN0Ll9hbHBoYVRSO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGFCTCA9IGdhbWVPYmplY3QuX2FscGhhQkw7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYUJSID0gZ2FtZU9iamVjdC5fYWxwaGFCUjtcclxuICAgICAgICAgICAgdmFyIHRpbnRUTCA9IGdhbWVPYmplY3QuX3RpbnRUTDtcclxuICAgICAgICAgICAgdmFyIHRpbnRUUiA9IGdhbWVPYmplY3QuX3RpbnRUUjtcclxuICAgICAgICAgICAgdmFyIHRpbnRCTCA9IGdhbWVPYmplY3QuX3RpbnRCTDtcclxuICAgICAgICAgICAgdmFyIHRpbnRCUiA9IGdhbWVPYmplY3QuX3RpbnRCUjtcclxuXHJcbiAgICAgICAgICAgIHRlbXBNYXRyaXguYXBwbHlJVFJTKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSk7XHJcblxyXG4gICAgICAgICAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgICAgICAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xyXG4gICAgICAgICAgICBzcmMgPSB0ZW1wTWF0cml4TWF0cml4WzJdO1xyXG4gICAgICAgICAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgICAgICAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xyXG4gICAgICAgICAgICBzcmYgPSB0ZW1wTWF0cml4TWF0cml4WzVdO1xyXG5cclxuICAgICAgICAgICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgICAgICAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICAgICAgICAgIGNtYyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgICAgICAgICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgICAgICAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICAgICAgICAgIGNtZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgICAgICAgICAgbXZiID0gc3JhICogY21iICsgc3JiICogY21kO1xyXG4gICAgICAgICAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XHJcbiAgICAgICAgICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgICAgICAgICAgbXZlID0gc3JlICogY21hICsgc3JmICogY21jICsgY21lO1xyXG4gICAgICAgICAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0eDAgPSB4ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICAgICAgdHkwID0geCAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgICAgIHR4MSA9IHggKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICAgICAgdHkxID0geCAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgICAgICB0eDIgPSB4dyAqIG12YSArIHloICogbXZjICsgbXZlO1xyXG4gICAgICAgICAgICB0eTIgPSB4dyAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgICAgICB0eDMgPSB4dyAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgICAgIHR5MyA9IHh3ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuXHJcbiAgICBcclxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRUZXh0dXJlWzBdICE9PSBmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlIHx8XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5jdXJyZW50VGV4dHVyZVsxXSAhPT0gc3ByaXRlTm9ybWFsUGFpci5ub3JtYWxUZXh0dXJlUmVmLnNvdXJjZVtzcHJpdGVOb3JtYWxQYWlyLnNwcml0ZVJlZi5mcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlIHx8XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5zaG91bGRGbHVzaCgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5mbHVzaChsaWdodExheWVyLnBhc3NTaGFkZXIsIGxpZ2h0TGF5ZXIucmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFRleHR1cmUoZnJhbWUudGV4dHVyZS5zb3VyY2VbZnJhbWUuc291cmNlSW5kZXhdLmdsVGV4dHVyZSwgMCk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKHNwcml0ZU5vcm1hbFBhaXIubm9ybWFsVGV4dHVyZVJlZi5zb3VyY2Vbc3ByaXRlTm9ybWFsUGFpci5zcHJpdGVSZWYuZnJhbWUuc291cmNlSW5kZXhdLmdsVGV4dHVyZSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJhdGNoLmRyYXdJbmRleGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgYmF0Y2guZHJhd2luZ01lc2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyNCk7XHJcbiAgICAgICAgICAgIGJhdGNoLmVsZW1lbnRDb3VudCArPSA2O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gIFRvcCBMZWZ0XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDA7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTA7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50VEw7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYVRMO1xyXG5cclxuICAgICAgICAgICAgLy8gIEJvdHRvbSBMZWZ0XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDE7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTE7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50Qkw7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYUJMO1xyXG5cclxuICAgICAgICAgICAgLy8gIEJvdHRvbSBSaWdodFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngyO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkyO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludEJSO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGFCUjtcclxuXHJcbiAgICAgICAgICAgIC8vICBUb3AgUmlnaHRcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MztcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MztcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MztcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MztcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnRUUjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhVFI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGJhdGNoLmZsdXNoKGxpZ2h0TGF5ZXIucGFzc1NoYWRlciwgbGlnaHRMYXllci5yZW5kZXJUYXJnZXQpO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRm9yd2FyZFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2xpZ2h0bGF5ZXIvRm9yd2FyZFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbi8qKlxyXG4qIFJldHVybnMgYSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgcmFuZG9tIHBvaW50IGZyb20gYW55d2hlcmUgd2l0aGluIHRoaXMgQ2lyY2xlLlxyXG4qL1xyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGNpcmNsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgdCA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcclxuICAgIHZhciB1ID0gTWF0aC5yYW5kb20oKSArIE1hdGgucmFuZG9tKCk7XHJcbiAgICB2YXIgciA9ICh1ID4gMSkgPyAyIC0gdSA6IHU7XHJcbiAgICB2YXIgeCA9IHIgKiBNYXRoLmNvcyh0KTtcclxuICAgIHZhciB5ID0gciAqIE1hdGguc2luKHQpO1xyXG5cclxuICAgIG91dC54ID0gY2lyY2xlLnggKyAoeCAqIGNpcmNsZS5yYWRpdXMpO1xyXG4gICAgb3V0LnkgPSBjaXJjbGUueSArICh5ICogY2lyY2xlLnJhZGl1cyk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGVsbGlwc2UsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIHAgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XHJcbiAgICB2YXIgcyA9IE1hdGguc3FydChNYXRoLnJhbmRvbSgpKTtcclxuXHJcbiAgICBvdXQueCA9IGVsbGlwc2UueCArICgocyAqIE1hdGguY29zKHApKSAqIGVsbGlwc2Uud2lkdGggLyAyKTtcclxuICAgIG91dC55ID0gZWxsaXBzZS55ICsgKChzICogTWF0aC5zaW4ocCkpICogZWxsaXBzZS5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9lbGxpcHNlL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBCYXNlZCBvbiBjb2RlIGJ5IE1hdHQgRGVzTGF1cmllcnNcclxuLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9saW5lLWNpcmNsZS1jb2xsaXNpb24vYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxyXG5cclxudmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi4vY2lyY2xlL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgdG1wID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG52YXIgTGluZVRvQ2lyY2xlID0gZnVuY3Rpb24gKGxpbmUsIGNpcmNsZSwgbmVhcmVzdClcclxue1xyXG4gICAgaWYgKG5lYXJlc3QgPT09IHVuZGVmaW5lZCkgeyBuZWFyZXN0ID0gdG1wOyB9XHJcblxyXG4gICAgaWYgKENvbnRhaW5zKGNpcmNsZSwgbGluZS54MSwgbGluZS55MSkpXHJcbiAgICB7XHJcbiAgICAgICAgbmVhcmVzdC54ID0gbGluZS54MTtcclxuICAgICAgICBuZWFyZXN0LnkgPSBsaW5lLnkxO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQ29udGFpbnMoY2lyY2xlLCBsaW5lLngyLCBsaW5lLnkyKSlcclxuICAgIHtcclxuICAgICAgICBuZWFyZXN0LnggPSBsaW5lLngyO1xyXG4gICAgICAgIG5lYXJlc3QueSA9IGxpbmUueTI7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkeCA9IGxpbmUueDIgLSBsaW5lLngxO1xyXG4gICAgdmFyIGR5ID0gbGluZS55MiAtIGxpbmUueTE7XHJcblxyXG4gICAgdmFyIGxjeCA9IGNpcmNsZS54IC0gbGluZS54MTtcclxuICAgIHZhciBsY3kgPSBjaXJjbGUueSAtIGxpbmUueTE7XHJcblxyXG4gICAgLy8gIHByb2plY3QgbGMgb250byBkLCByZXN1bHRpbmcgaW4gdmVjdG9yIHBcclxuICAgIHZhciBkTGVuMiA9IChkeCAqIGR4KSArIChkeSAqIGR5KTtcclxuICAgIHZhciBweCA9IGR4O1xyXG4gICAgdmFyIHB5ID0gZHk7XHJcblxyXG4gICAgaWYgKGRMZW4yID4gMClcclxuICAgIHtcclxuICAgICAgICB2YXIgZHAgPSAoKGxjeCAqIGR4KSArIChsY3kgKiBkeSkpIC8gZExlbjI7XHJcblxyXG4gICAgICAgIHB4ICo9IGRwO1xyXG4gICAgICAgIHB5ICo9IGRwO1xyXG4gICAgfVxyXG5cclxuICAgIG5lYXJlc3QueCA9IGxpbmUueDEgKyBweDtcclxuICAgIG5lYXJlc3QueSA9IGxpbmUueTEgKyBweTtcclxuICAgIFxyXG4gICAgLy8gIGxlbjIgb2YgcFxyXG4gICAgdmFyIHBMZW4yID0gKHB4ICogcHgpICsgKHB5ICogcHkpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHBMZW4yIDw9IGRMZW4yICYmXHJcbiAgICAgICAgKChweCAqIGR4KSArIChweSAqIGR5KSkgPj0gMCAmJlxyXG4gICAgICAgIENvbnRhaW5zKGNpcmNsZSwgbmVhcmVzdC54LCBuZWFyZXN0LnkpXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVG9DaXJjbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludFRvTGluZSA9IGZ1bmN0aW9uIChwb2ludCwgbGluZSlcclxue1xyXG4gICAgcmV0dXJuICgocG9pbnQueCAtIGxpbmUueDEpICogKGxpbmUueTIgLSBsaW5lLnkxKSA9PT0gKGxpbmUueDIgLSBsaW5lLngxKSAqIChwb2ludC55IC0gbGluZS55MSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFRvTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlVG9SZWN0YW5nbGUgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCKVxyXG57XHJcbiAgICBpZiAocmVjdEEud2lkdGggPD0gMCB8fCByZWN0QS5oZWlnaHQgPD0gMCB8fCByZWN0Qi53aWR0aCA8PSAwIHx8IHJlY3RCLmhlaWdodCA8PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gIShyZWN0QS5yaWdodCA8IHJlY3RCLnggfHwgcmVjdEEuYm90dG9tIDwgcmVjdEIueSB8fCByZWN0QS54ID4gcmVjdEIucmlnaHQgfHwgcmVjdEEueSA+IHJlY3RCLmJvdHRvbSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZVRvUmVjdGFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcblxyXG4vLyAgRGVmaW5lcyBhIExpbmUgc2VnbWVudCwgYSBwYXJ0IG9mIGEgbGluZSBiZXR3ZWVuIHR3byBlbmRwb2ludHNcclxuXHJcbnZhciBMaW5lID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIExpbmUgKHgxLCB5MSwgeDIsIHkyKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueDEgPSAwO1xyXG4gICAgICAgIHRoaXMueTEgPSAwO1xyXG4gICAgICAgIHRoaXMueDIgPSAwO1xyXG4gICAgICAgIHRoaXMueTIgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRvKHgxLCB5MSwgeDIsIHkyKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MilcclxuICAgIHtcclxuICAgICAgICBpZiAoeDEgPT09IHVuZGVmaW5lZCkgeyB4MSA9IDA7IH1cclxuICAgICAgICBpZiAoeTEgPT09IHVuZGVmaW5lZCkgeyB5MSA9IDA7IH1cclxuICAgICAgICBpZiAoeDIgPT09IHVuZGVmaW5lZCkgeyB4MiA9IDA7IH1cclxuICAgICAgICBpZiAoeTIgPT09IHVuZGVmaW5lZCkgeyB5MiA9IDA7IH1cclxuXHJcbiAgICAgICAgdGhpcy54MSA9IHgxO1xyXG4gICAgICAgIHRoaXMueTEgPSB5MTtcclxuXHJcbiAgICAgICAgdGhpcy54MiA9IHgyO1xyXG4gICAgICAgIHRoaXMueTIgPSB5MjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBvaW50QTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4geyB4MTogdGhpcy54MSwgeTE6IHRoaXMueTEgfTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UG9pbnRCOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB7IHgxOiB0aGlzLngyLCB5MTogdGhpcy55MiB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBsZWZ0OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLngxLCB0aGlzLngyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLngxIDw9IHRoaXMueDIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueDEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueDIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLngxLCB0aGlzLngyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLngxID4gdGhpcy54MilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9wOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLnkxLCB0aGlzLnkyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnkxIDw9IHRoaXMueTIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueTEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueTIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy55MSwgdGhpcy55Mik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy55MSA+IHRoaXMueTIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueTEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueTIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgV3JhcCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvV3JhcCcpO1xyXG52YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XHJcblxyXG52YXIgTm9ybWFsQW5nbGUgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgdmFyIGFuZ2xlID0gQW5nbGUobGluZSkgLSBNQVRIX0NPTlNULlRBVTtcclxuXHJcbiAgICByZXR1cm4gV3JhcChhbmdsZSwgLU1hdGguUEksIE1hdGguUEkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxBbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xyXG5cclxudmFyIFJhbmRvbSA9IGZ1bmN0aW9uIChsaW5lLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gTWF0aC5yYW5kb20oKTtcclxuXHJcbiAgICBvdXQueCA9IGxpbmUueDEgKyB0ICogKGxpbmUueDIgLSBsaW5lLngxKTtcclxuICAgIG91dC55ID0gbGluZS55MSArIHQgKiAobGluZS55MiAtIGxpbmUueTEpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvUmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldE1hZ25pdHVkZSA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCgocG9pbnQueCAqIHBvaW50LngpICsgKHBvaW50LnkgKiBwb2ludC55KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE1hZ25pdHVkZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0dldE1hZ25pdHVkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRNYWduaXR1ZGVTcSA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIChwb2ludC54ICogcG9pbnQueCkgKyAocG9pbnQueSAqIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRNYWduaXR1ZGVTcTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0dldE1hZ25pdHVkZVNxLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE11bHRpcGx5ID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5KVxyXG57XHJcbiAgICBwb2ludC54ICo9IHg7XHJcbiAgICBwb2ludC55ICo9IHk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aXBseTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L011bHRpcGx5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldE1hZ25pdHVkZSA9IHJlcXVpcmUoJy4vR2V0TWFnbml0dWRlJyk7XHJcblxyXG52YXIgTm9ybWFsaXplID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICBpZiAocG9pbnQueCAhPT0gMCAmJiBwb2ludC55ICE9PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBtID0gR2V0TWFnbml0dWRlKHBvaW50KTtcclxuXHJcbiAgICAgICAgcG9pbnQueCAvPSBtO1xyXG4gICAgICAgIHBvaW50LnkgLz0gbTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbGl6ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L05vcm1hbGl6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgcG9seWdvbi5cclxuKi9cclxudmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKHBvbHlnb24sIHgsIHkpXHJcbntcclxuICAgIC8vICBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbCBieSBKb25hcyBSYW9uaSBTb2FyZXMgU2lsdmFcclxuXHJcbiAgICB2YXIgaW5zaWRlID0gZmFsc2U7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IC0xLCBqID0gcG9seWdvbi5wb2ludHMubGVuZ3RoIC0gMTsgKytpIDwgcG9seWdvbi5wb2ludHMubGVuZ3RoOyBqID0gaSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaXggPSBwb2x5Z29uLnBvaW50c1tpXS54O1xyXG4gICAgICAgIHZhciBpeSA9IHBvbHlnb24ucG9pbnRzW2ldLnk7XHJcblxyXG4gICAgICAgIHZhciBqeCA9IHBvbHlnb24ucG9pbnRzW2pdLng7XHJcbiAgICAgICAgdmFyIGp5ID0gcG9seWdvbi5wb2ludHNbal0ueTtcclxuXHJcbiAgICAgICAgaWYgKCgoaXkgPD0geSAmJiB5IDwgankpIHx8IChqeSA8PSB5ICYmIHkgPCBpeSkpICYmICh4IDwgKGp4IC0gaXgpICogKHkgLSBpeSkgLyAoankgLSBpeSkgKyBpeCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5zaWRlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWlucztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvbHlnb24vQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgMi4xLjEgKE1hciAxNywgMjAxNilcclxuXHJcbi8qXHJcbklTQyBMaWNlbnNlXHJcblxyXG5Db3B5cmlnaHQgKGMpIDIwMTYsIE1hcGJveFxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2Vcclxud2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZVxyXG5hbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxyXG5GSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1NcclxuT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSXHJcblRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0ZcclxuVEhJUyBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcclxuXHJcbi8qXHJcbnZlcnRpY2VzIGlzIGEgZmxhdCBhcnJheSBvZiB2ZXJ0aWNlIGNvb3JkaW5hdGVzIGxpa2UgW3gwLHkwLCB4MSx5MSwgeDIseTIsIC4uLl0uXHJcbmhvbGVzIGlzIGFuIGFycmF5IG9mIGhvbGUgaW5kaWNlcyBpZiBhbnkgKGUuZy4gWzUsIDhdIGZvciBhIDEyLXZlcnRpY2UgaW5wdXQgd291bGQgbWVhbiBvbmUgaG9sZSB3aXRoIHZlcnRpY2VzIDXigJM3IGFuZCBhbm90aGVyIHdpdGggOOKAkzExKS5cclxuZGltZW5zaW9ucyBpcyB0aGUgbnVtYmVyIG9mIGNvb3JkaW5hdGVzIHBlciB2ZXJ0aWNlIGluIHRoZSBpbnB1dCBhcnJheSAoMiBieSBkZWZhdWx0KS5cclxuRWFjaCBncm91cCBvZiB0aHJlZSB2ZXJ0aWNlIGluZGljZXMgaW4gdGhlIHJlc3VsdGluZyBhcnJheSBmb3JtcyBhIHRyaWFuZ2xlLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XHJcblxyXG4gICAgZGltID0gZGltIHx8IDI7XHJcblxyXG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoLFxyXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXHJcbiAgICAgICAgdHJpYW5nbGVzID0gW107XHJcblxyXG4gICAgaWYgKCFvdXRlck5vZGUpIHJldHVybiB0cmlhbmdsZXM7XHJcblxyXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIHNpemU7XHJcblxyXG4gICAgaWYgKGhhc0hvbGVzKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pO1xyXG5cclxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxyXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gODAgKiBkaW0pIHtcclxuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XHJcbiAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XHJcbiAgICAgICAgICAgIHggPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICB5ID0gZGF0YVtpICsgMV07XHJcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XHJcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XHJcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XHJcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBzaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxyXG4gICAgICAgIHNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xyXG4gICAgfVxyXG5cclxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcclxuXHJcbiAgICByZXR1cm4gdHJpYW5nbGVzO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xyXG4gICAgdmFyIGksIGxhc3Q7XHJcblxyXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XHJcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xyXG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XHJcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGFzdDtcclxufVxyXG5cclxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcclxuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcclxuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcclxuICAgIGlmICghZW5kKSBlbmQgPSBzdGFydDtcclxuXHJcbiAgICB2YXIgcCA9IHN0YXJ0LFxyXG4gICAgICAgIGFnYWluO1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGFnYWluID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcclxuICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcclxuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xyXG5cclxuICAgIHJldHVybiBlbmQ7XHJcbn1cclxuXHJcbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxyXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgcGFzcykge1xyXG4gICAgaWYgKCFlYXIpIHJldHVybjtcclxuXHJcbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXHJcbiAgICBpZiAoIXBhc3MgJiYgc2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIHNpemUpO1xyXG5cclxuICAgIHZhciBzdG9wID0gZWFyLFxyXG4gICAgICAgIHByZXYsIG5leHQ7XHJcblxyXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXHJcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XHJcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xyXG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcclxuXHJcbiAgICAgICAgaWYgKHNpemUgPyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIHNpemUpIDogaXNFYXIoZWFyKSkge1xyXG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxyXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0pO1xyXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSk7XHJcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSk7XHJcblxyXG4gICAgICAgICAgICByZW1vdmVOb2RlKGVhcik7XHJcblxyXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0aWNlIGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xyXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XHJcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XHJcblxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVhciA9IG5leHQ7XHJcblxyXG4gICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXHJcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xyXG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxyXG4gICAgICAgICAgICBpZiAoIXBhc3MpIHtcclxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGVhciwgdHJpYW5nbGVzLCBkaW0pO1xyXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIDIpO1xyXG5cclxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcclxuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XHJcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxyXG4gICAgICAgIGIgPSBlYXIsXHJcbiAgICAgICAgYyA9IGVhci5uZXh0O1xyXG5cclxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcclxuXHJcbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxyXG4gICAgdmFyIHAgPSBlYXIubmV4dC5uZXh0O1xyXG5cclxuICAgIHdoaWxlIChwICE9PSBlYXIucHJldikge1xyXG4gICAgICAgIGlmIChwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXHJcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcclxuICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIHNpemUpIHtcclxuICAgIHZhciBhID0gZWFyLnByZXYsXHJcbiAgICAgICAgYiA9IGVhcixcclxuICAgICAgICBjID0gZWFyLm5leHQ7XHJcblxyXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxyXG5cclxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXHJcbiAgICB2YXIgbWluVFggPSBhLnggPCBiLnggPyAoYS54IDwgYy54ID8gYS54IDogYy54KSA6IChiLnggPCBjLnggPyBiLnggOiBjLngpLFxyXG4gICAgICAgIG1pblRZID0gYS55IDwgYi55ID8gKGEueSA8IGMueSA/IGEueSA6IGMueSkgOiAoYi55IDwgYy55ID8gYi55IDogYy55KSxcclxuICAgICAgICBtYXhUWCA9IGEueCA+IGIueCA/IChhLnggPiBjLnggPyBhLnggOiBjLngpIDogKGIueCA+IGMueCA/IGIueCA6IGMueCksXHJcbiAgICAgICAgbWF4VFkgPSBhLnkgPiBiLnkgPyAoYS55ID4gYy55ID8gYS55IDogYy55KSA6IChiLnkgPiBjLnkgPyBiLnkgOiBjLnkpO1xyXG5cclxuICAgIC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XHJcbiAgICB2YXIgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIHNpemUpLFxyXG4gICAgICAgIG1heFogPSB6T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBzaXplKTtcclxuXHJcbiAgICAvLyBmaXJzdCBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBpbmNyZWFzaW5nIHotb3JkZXJcclxuICAgIHZhciBwID0gZWFyLm5leHRaO1xyXG5cclxuICAgIHdoaWxlIChwICYmIHAueiA8PSBtYXhaKSB7XHJcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXHJcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcclxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHAgPSBwLm5leHRaO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRoZW4gbG9vayBmb3IgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxyXG4gICAgcCA9IGVhci5wcmV2WjtcclxuXHJcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xyXG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxyXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXHJcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcclxuICAgICAgICBwID0gcC5wcmV2WjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcclxuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcclxuICAgIHZhciBwID0gc3RhcnQ7XHJcbiAgICBkbyB7XHJcbiAgICAgICAgdmFyIGEgPSBwLnByZXYsXHJcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcclxuXHJcbiAgICAgICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xyXG5cclxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltKTtcclxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltKTtcclxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xyXG5cclxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcCA9IHAubmV4dDtcclxuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcclxuXHJcbiAgICByZXR1cm4gcDtcclxufVxyXG5cclxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcclxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKSB7XHJcbiAgICAvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xyXG4gICAgdmFyIGEgPSBzdGFydDtcclxuICAgIGRvIHtcclxuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xyXG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcclxuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcclxuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcclxuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxyXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcclxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYiA9IGIubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYSA9IGEubmV4dDtcclxuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcclxufVxyXG5cclxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xyXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcclxuICAgIHZhciBxdWV1ZSA9IFtdLFxyXG4gICAgICAgIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XHJcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcclxuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcclxuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xyXG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xyXG5cclxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xyXG4gICAgICAgIG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyhvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XHJcbiAgICByZXR1cm4gYS54IC0gYi54O1xyXG59XHJcblxyXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcclxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcclxuICAgIG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XHJcbiAgICBpZiAob3V0ZXJOb2RlKSB7XHJcbiAgICAgICAgdmFyIGIgPSBzcGxpdFBvbHlnb24ob3V0ZXJOb2RlLCBob2xlKTtcclxuICAgICAgICBmaWx0ZXJQb2ludHMoYiwgYi5uZXh0KTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxyXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcclxuICAgIHZhciBwID0gb3V0ZXJOb2RlLFxyXG4gICAgICAgIGh4ID0gaG9sZS54LFxyXG4gICAgICAgIGh5ID0gaG9sZS55LFxyXG4gICAgICAgIHF4ID0gLUluZmluaXR5LFxyXG4gICAgICAgIG07XHJcblxyXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xyXG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxyXG4gICAgZG8ge1xyXG4gICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcclxuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XHJcbiAgICAgICAgICAgICAgICBxeCA9IHg7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcCA9IHAubmV4dDtcclxuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XHJcblxyXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBpZiAoaHggPT09IHF4KSByZXR1cm4gbS5wcmV2OyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsb3dlciBlbmRwb2ludFxyXG5cclxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcclxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xyXG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcclxuXHJcbiAgICB2YXIgc3RvcCA9IG0sXHJcbiAgICAgICAgbXggPSBtLngsXHJcbiAgICAgICAgbXkgPSBtLnksXHJcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXHJcbiAgICAgICAgdGFuO1xyXG5cclxuICAgIHAgPSBtLm5leHQ7XHJcblxyXG4gICAgd2hpbGUgKHAgIT09IHN0b3ApIHtcclxuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXHJcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XHJcblxyXG4gICAgICAgICAgICB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXHJcblxyXG4gICAgICAgICAgICBpZiAoKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgcC54ID4gbS54KSkgJiYgbG9jYWxseUluc2lkZShwLCBob2xlKSkge1xyXG4gICAgICAgICAgICAgICAgbSA9IHA7XHJcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG07XHJcbn1cclxuXHJcbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgc2l6ZSkge1xyXG4gICAgdmFyIHAgPSBzdGFydDtcclxuICAgIGRvIHtcclxuICAgICAgICBpZiAocC56ID09PSBudWxsKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIHNpemUpO1xyXG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XHJcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcclxuICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xyXG5cclxuICAgIHAucHJldloubmV4dFogPSBudWxsO1xyXG4gICAgcC5wcmV2WiA9IG51bGw7XHJcblxyXG4gICAgc29ydExpbmtlZChwKTtcclxufVxyXG5cclxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cclxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcclxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XHJcbiAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXHJcbiAgICAgICAgaW5TaXplID0gMTtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgICAgcCA9IGxpc3Q7XHJcbiAgICAgICAgbGlzdCA9IG51bGw7XHJcbiAgICAgICAgdGFpbCA9IG51bGw7XHJcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XHJcbiAgICAgICAgICAgIHEgPSBwO1xyXG4gICAgICAgICAgICBwU2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcFNpemUrKztcclxuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gcDtcclxuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcclxuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gcTtcclxuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcclxuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XHJcblxyXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XHJcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcCA9IHE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcclxuICAgICAgICBpblNpemUgKj0gMjtcclxuXHJcbiAgICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcclxuXHJcbiAgICByZXR1cm4gbGlzdDtcclxufVxyXG5cclxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgc2l6ZSBvZiB0aGUgZGF0YSBib3VuZGluZyBib3hcclxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIHNpemUpIHtcclxuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcclxuICAgIHggPSAzMjc2NyAqICh4IC0gbWluWCkgLyBzaXplO1xyXG4gICAgeSA9IDMyNzY3ICogKHkgLSBtaW5ZKSAvIHNpemU7XHJcblxyXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcclxuICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XHJcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xyXG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcclxuXHJcbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xyXG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcclxuICAgIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XHJcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xyXG5cclxuICAgIHJldHVybiB4IHwgKHkgPDwgMSk7XHJcbn1cclxuXHJcbi8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcclxuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcclxuICAgIHZhciBwID0gc3RhcnQsXHJcbiAgICAgICAgbGVmdG1vc3QgPSBzdGFydDtcclxuICAgIGRvIHtcclxuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCkgbGVmdG1vc3QgPSBwO1xyXG4gICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XHJcblxyXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXHJcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcclxuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgLSAoYXggLSBweCkgKiAoY3kgLSBweSkgPj0gMCAmJlxyXG4gICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSAtIChieCAtIHB4KSAqIChheSAtIHB5KSA+PSAwICYmXHJcbiAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpIC0gKGN4IC0gcHgpICogKGJ5IC0gcHkpID49IDA7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxyXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xyXG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiZcclxuICAgICAgICAgICBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpO1xyXG59XHJcblxyXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXHJcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xyXG4gICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxyXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XHJcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XHJcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcclxuICAgIGlmICgoZXF1YWxzKHAxLCBxMSkgJiYgZXF1YWxzKHAyLCBxMikpIHx8XHJcbiAgICAgICAgKGVxdWFscyhwMSwgcTIpICYmIGVxdWFscyhwMiwgcTEpKSkgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gYXJlYShwMSwgcTEsIHAyKSA+IDAgIT09IGFyZWEocDEsIHExLCBxMikgPiAwICYmXHJcbiAgICAgICAgICAgYXJlYShwMiwgcTIsIHAxKSA+IDAgIT09IGFyZWEocDIsIHEyLCBxMSkgPiAwO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xyXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XHJcbiAgICB2YXIgcCA9IGE7XHJcbiAgICBkbyB7XHJcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cclxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XHJcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cclxuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XHJcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cclxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcclxuICAgIHZhciBwID0gYSxcclxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcclxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcclxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcclxuICAgIGRvIHtcclxuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxyXG4gICAgICAgICAgICAgICAgKHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSlcclxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcclxuICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XHJcblxyXG4gICAgcmV0dXJuIGluc2lkZTtcclxufVxyXG5cclxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xyXG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcclxuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcclxuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxyXG4gICAgICAgIGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSksXHJcbiAgICAgICAgYW4gPSBhLm5leHQsXHJcbiAgICAgICAgYnAgPSBiLnByZXY7XHJcblxyXG4gICAgYS5uZXh0ID0gYjtcclxuICAgIGIucHJldiA9IGE7XHJcblxyXG4gICAgYTIubmV4dCA9IGFuO1xyXG4gICAgYW4ucHJldiA9IGEyO1xyXG5cclxuICAgIGIyLm5leHQgPSBhMjtcclxuICAgIGEyLnByZXYgPSBiMjtcclxuXHJcbiAgICBicC5uZXh0ID0gYjI7XHJcbiAgICBiMi5wcmV2ID0gYnA7XHJcblxyXG4gICAgcmV0dXJuIGIyO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxyXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcclxuICAgIHZhciBwID0gbmV3IE5vZGUoaSwgeCwgeSk7XHJcblxyXG4gICAgaWYgKCFsYXN0KSB7XHJcbiAgICAgICAgcC5wcmV2ID0gcDtcclxuICAgICAgICBwLm5leHQgPSBwO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xyXG4gICAgICAgIHAucHJldiA9IGxhc3Q7XHJcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBwO1xyXG4gICAgICAgIGxhc3QubmV4dCA9IHA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlTm9kZShwKSB7XHJcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcclxuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xyXG5cclxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcclxuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2WjtcclxufVxyXG5cclxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XHJcbiAgICAvLyB2ZXJ0aWNlIGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XHJcbiAgICB0aGlzLmkgPSBpO1xyXG5cclxuICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGljZSBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xyXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcclxuICAgIHRoaXMubmV4dCA9IG51bGw7XHJcblxyXG4gICAgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxyXG4gICAgdGhpcy56ID0gbnVsbDtcclxuXHJcbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXHJcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcclxuICAgIHRoaXMubmV4dFogPSBudWxsO1xyXG5cclxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XHJcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcclxuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxyXG5lYXJjdXQuZGV2aWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0sIHRyaWFuZ2xlcykge1xyXG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xyXG4gICAgdmFyIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xyXG5cclxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xyXG4gICAgaWYgKGhhc0hvbGVzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgIHZhciBhID0gdHJpYW5nbGVzW2ldICogZGltO1xyXG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcclxuICAgICAgICB2YXIgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XHJcbiAgICAgICAgdHJpYW5nbGVzQXJlYSArPSBNYXRoLmFicyhcclxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXHJcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XHJcbiAgICAgICAgTWF0aC5hYnMoKHRyaWFuZ2xlc0FyZWEgLSBwb2x5Z29uQXJlYSkgLyBwb2x5Z29uQXJlYSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xyXG4gICAgdmFyIHN1bSA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XHJcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XHJcbiAgICAgICAgaiA9IGk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VtO1xyXG59XHJcblxyXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcclxuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgdmFyIGRpbSA9IGRhdGFbMF1bMF0ubGVuZ3RoLFxyXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcclxuICAgICAgICBob2xlSW5kZXggPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSByZXN1bHQudmVydGljZXMucHVzaChkYXRhW2ldW2pdW2RdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgIGhvbGVJbmRleCArPSBkYXRhW2kgLSAxXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9seWdvbi9FYXJjdXQuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIFBvbHlnb24gPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gUG9seWdvbiAocG9pbnRzKVxyXG4gICAge1xyXG4gICAgICAgIC8vIEBwcm9wZXJ0eSB7bnVtYmVyfSBhcmVhIC0gVGhlIGFyZWEgb2YgdGhpcyBQb2x5Z29uLlxyXG4gICAgICAgIHRoaXMuYXJlYSA9IDA7XHJcblxyXG4gICAgICAgIC8vIEBwcm9wZXJ0eSB7YXJyYXl9IHBvaW50cyAtIEFuIGFycmF5IG9mIG51bWJlciBwYWlyIG9iamVjdHMgdGhhdCBtYWtlIHVwIHRoaXMgcG9seWdvbi4gSS5lLiBbIHt4LHl9LCB7eCx5fSwge3gseX0gXVxyXG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XHJcblxyXG4gICAgICAgIGlmIChwb2ludHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNldFRvKHBvaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhpcyBQb2x5Z29uIHRvIHRoZSBnaXZlbiBwb2ludHMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHBvaW50cyBjYW4gYmUgc2V0IGZyb20gYSB2YXJpZXR5IG9mIGZvcm1hdHM6XHJcbiAgICAgKlxyXG4gICAgICogLSBBbiBhcnJheSBvZiBQb2ludCBvYmplY3RzOiBgW25ldyBQaGFzZXIuUG9pbnQoeDEsIHkxKSwgLi4uXWBcclxuICAgICAqIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllczogYFtvYmoxLCBvYmoyLCAuLi5dYFxyXG4gICAgICogLSBBbiBhcnJheSBvZiBwYWlyZWQgbnVtYmVycyB0aGF0IHJlcHJlc2VudCBwb2ludCBjb29yZGluYXRlczogYFt4MSx5MSwgeDIseTIsIC4uLl1gXHJcbiAgICAgKiAtIEFuIGFycmF5IG9mIGFycmF5cyB3aXRoIHR3byBlbGVtZW50cyByZXByZXNlbnRpbmcgeC95IGNvb3JkaW5hdGVzOiBgW1t4MSwgeTFdLCBbeDIsIHkyXSwgLi4uXWBcclxuICAgICAqXHJcbiAgICAgKiBgc2V0VG9gIG1heSBhbHNvIGJlIGNhbGxlZCB3aXRob3V0IGFueSBhcmd1bWVudHMgdG8gcmVtb3ZlIGFsbCBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIHNldFRvOiBmdW5jdGlvbiAocG9pbnRzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IDA7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBlbnRyeTtcclxuICAgICAgICB2YXIgeTAgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHZhciBwO1xyXG5cclxuICAgICAgICAvLyAgVGhlIHBvaW50cyBhcmd1bWVudCBpcyBhbiBhcnJheSwgc28gaXRlcmF0ZSB0aHJvdWdoIGl0XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50c1tpXSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHAueCA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgICAgIHAueSA9IHBvaW50c1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBBbiBhcnJheSBvZiBhcnJheXM/XHJcbiAgICAgICAgICAgICAgICBwLnggPSBwb2ludHNbaV1bMF07XHJcbiAgICAgICAgICAgICAgICBwLnkgPSBwb2ludHNbaV1bMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwLnggPSBwb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgIHAueSA9IHBvaW50c1tpXS55O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBvaW50cy5wdXNoKHApO1xyXG5cclxuICAgICAgICAgICAgLy8gIExvd2VzdCBib3VuZGFyeVxyXG4gICAgICAgICAgICBpZiAocC55IDwgeTApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHkwID0gcC55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFyZWEoeTApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhcmVhIG9mIHRoZSBQb2x5Z29uLiBUaGlzIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvcGVydHkgUG9seWdvbi5hcmVhXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZUFyZWE6IGZ1bmN0aW9uICh5MClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoIDwgMylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJlYSA9IDA7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmVhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN1bSA9IDA7XHJcbiAgICAgICAgdmFyIHAxO1xyXG4gICAgICAgIHZhciBwMjtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwMSA9IHRoaXMucG9pbnRzW2ldO1xyXG4gICAgICAgICAgICBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXTtcclxuXHJcbiAgICAgICAgICAgIHN1bSArPSAocDIueCAtIHAxLngpICogKHAxLnkgKyBwMi55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHAxID0gdGhpcy5wb2ludHNbMF07XHJcbiAgICAgICAgcDIgPSB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgc3VtICs9IChwMS54IC0gcDIueCkgKiAocDIueSArIHAxLnkpO1xyXG5cclxuICAgICAgICB0aGlzLmFyZWEgPSAtc3VtICogMC41O1xyXG5cclxuICAgICAgICAvLyB2YXIgcDE7XHJcbiAgICAgICAgLy8gdmFyIHAyO1xyXG4gICAgICAgIC8vIHZhciBhdmdIZWlnaHQ7XHJcbiAgICAgICAgLy8gdmFyIHdpZHRoO1xyXG5cclxuICAgICAgICAvLyBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIC8vICAgICBwMSA9IHRoaXMucG9pbnRzW2ldO1xyXG5cclxuICAgICAgICAvLyAgICAgaWYgKGkgPT09IGxlbiAtIDEpXHJcbiAgICAgICAgLy8gICAgIHtcclxuICAgICAgICAvLyAgICAgICAgIHAyID0gdGhpcy5wb2ludHNbMF07XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgZWxzZVxyXG4gICAgICAgIC8vICAgICB7XHJcbiAgICAgICAgLy8gICAgICAgICBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXTtcclxuICAgICAgICAvLyAgICAgfVxyXG5cclxuICAgICAgICAvLyAgICAgYXZnSGVpZ2h0ID0gKChwMS55IC0geTApICsgKHAyLnkgLSB5MCkpIC8gMjtcclxuICAgICAgICAvLyAgICAgd2lkdGggPSBwMS54IC0gcDIueDtcclxuICAgICAgICAvLyAgICAgdGhpcy5hcmVhICs9IGF2Z0hlaWdodCAqIHdpZHRoO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJlYTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9seWdvbi9Qb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ2VudGVycyB0aGlzIFJlY3RhbmdsZSBzbyB0aGF0IHRoZSBjZW50ZXIgY29vcmRpbmF0ZXMgbWF0Y2ggdGhlIGdpdmVuIHggYW5kIHkgdmFsdWVzLlxyXG4qL1xyXG52YXIgQ2VudGVyT24gPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcclxue1xyXG4gICAgcmVjdC54ID0geCAtIChyZWN0LndpZHRoIC8gMik7XHJcbiAgICByZWN0LnkgPSB5IC0gKHJlY3QuaGVpZ2h0IC8gMik7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlbnRlck9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERlY29tcG9zZSA9IGZ1bmN0aW9uIChyZWN0LCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBbXTsgfVxyXG5cclxuICAgIG91dC5wdXNoKHsgeDogcmVjdC54LCB5OiByZWN0LnkgfSk7XHJcbiAgICBvdXQucHVzaCh7IHg6IHJlY3QucmlnaHQsIHk6IHJlY3QueSB9KTtcclxuICAgIG91dC5wdXNoKHsgeDogcmVjdC5yaWdodCwgeTogcmVjdC5ib3R0b20gfSk7XHJcbiAgICBvdXQucHVzaCh7IHg6IHJlY3QueCwgeTogcmVjdC5ib3R0b20gfSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGVjb21wb3NlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0RlY29tcG9zZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJpbWV0ZXIgPSByZXF1aXJlKCcuL1BlcmltZXRlcicpO1xyXG5cclxuLy8gIFJldHVybiBhbiBhcnJheSBvZiBwb2ludHMgZnJvbSB0aGUgcGVyaW1ldGVyIG9mIHRoZSByZWN0YW5nbGVcclxuLy8gIGVhY2ggc3BhY2VkIG91dCBiYXNlZCBvbiB0aGUgcXVhbnRpdHkgb3Igc3RlcCByZXF1aXJlZFxyXG5cclxudmFyIE1hcmNoaW5nQW50cyA9IGZ1bmN0aW9uIChyZWN0LCBzdGVwLCBxdWFudGl0eSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gW107IH1cclxuXHJcbiAgICBpZiAoIXN0ZXAgJiYgIXF1YW50aXR5KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBCYWlsIG91dFxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIElmIHN0ZXAgaXMgYSBmYWxzZXkgdmFsdWUgKGZhbHNlLCBudWxsLCAwLCB1bmRlZmluZWQsIGV0YykgdGhlbiB3ZSBjYWxjdWxhdGVcclxuICAgIC8vICBpdCBiYXNlZCBvbiB0aGUgcXVhbnRpdHkgaW5zdGVhZCwgb3RoZXJ3aXNlIHdlIGFsd2F5cyB1c2UgdGhlIHN0ZXAgdmFsdWVcclxuICAgIGlmICghc3RlcClcclxuICAgIHtcclxuICAgICAgICBzdGVwID0gUGVyaW1ldGVyKHJlY3QpIC8gcXVhbnRpdHk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcXVhbnRpdHkgPSBNYXRoLnJvdW5kKFBlcmltZXRlcihyZWN0KSAvIHN0ZXApO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4ID0gcmVjdC54O1xyXG4gICAgdmFyIHkgPSByZWN0Lnk7XHJcbiAgICB2YXIgZmFjZSA9IDA7XHJcblxyXG4gICAgLy8gIExvb3AgYWNyb3NzIGVhY2ggZmFjZSBvZiB0aGUgcmVjdGFuZ2xlXHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFudGl0eTsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG91dC5wdXNoKHsgeDogeCwgeTogeSB9KTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChmYWNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRvcCBmYWNlXHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHggKz0gc3RlcDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+PSByZWN0LnJpZ2h0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY2UgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgKz0gKHggLSByZWN0LnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gcmVjdC5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gIFJpZ2h0IGZhY2VcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgeSArPSBzdGVwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh5ID49IHJlY3QuYm90dG9tKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY2UgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHggLT0gKHkgLSByZWN0LmJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHJlY3QuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyAgQm90dG9tIGZhY2VcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgeCAtPSBzdGVwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh4IDw9IHJlY3QubGVmdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlID0gMztcclxuICAgICAgICAgICAgICAgICAgICB5IC09IChyZWN0LmxlZnQgLSB4KTtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gcmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyAgTGVmdCBmYWNlXHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIHkgLT0gc3RlcDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoeSA8PSByZWN0LnRvcClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gcmVjdC50b3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWFyY2hpbmdBbnRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL01hcmNoaW5nQW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJpbWV0ZXIgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmV0dXJuIDIgKiAocmVjdC53aWR0aCArIHJlY3QuaGVpZ2h0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGVyaW1ldGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL1BlcmltZXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKHJlY3QsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgb3V0LnggPSByZWN0LnggKyAoTWF0aC5yYW5kb20oKSAqIHJlY3Qud2lkdGgpO1xyXG4gICAgb3V0LnkgPSByZWN0LnkgKyAoTWF0aC5yYW5kb20oKSAqIHJlY3QuaGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFRoZSB0aHJlZSBtZWRpYW5zICh0aGUgbGluZXMgZHJhd24gZnJvbSB0aGUgdmVydGljZXMgdG8gdGhlIGJpc2VjdG9ycyBvZiB0aGUgb3Bwb3NpdGUgc2lkZXMpXHJcbi8vICBtZWV0IGluIHRoZSBjZW50cm9pZCBvciBjZW50ZXIgb2YgbWFzcyAoY2VudGVyIG9mIGdyYXZpdHkpLlxyXG4vLyAgVGhlIGNlbnRyb2lkIGRpdmlkZXMgZWFjaCBtZWRpYW4gaW4gYSByYXRpbyBvZiAyOjFcclxuXHJcbnZhciBDZW50cm9pZCA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuXHJcbiAgICBvdXQueCA9ICh0cmlhbmdsZS54MSArIHRyaWFuZ2xlLngyICsgdHJpYW5nbGUueDMpIC8gMztcclxuICAgIG91dC55ID0gKHRyaWFuZ2xlLnkxICsgdHJpYW5nbGUueTIgKyB0cmlhbmdsZS55MykgLyAzO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlbnRyb2lkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQ2VudHJvaWQuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGVjb21wb3NlID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBbXTsgfVxyXG5cclxuICAgIG91dC5wdXNoKHsgeDogdHJpYW5nbGUueDEsIHk6IHRyaWFuZ2xlLnkxIH0pO1xyXG4gICAgb3V0LnB1c2goeyB4OiB0cmlhbmdsZS54MiwgeTogdHJpYW5nbGUueTIgfSk7XHJcbiAgICBvdXQucHVzaCh7IHg6IHRyaWFuZ2xlLngzLCB5OiB0cmlhbmdsZS55MyB9KTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWNvbXBvc2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9EZWNvbXBvc2UuanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgdGhyZWUgYW5nbGUgYmlzZWN0b3JzIG9mIGEgdHJpYW5nbGUgbWVldCBpbiBvbmUgcG9pbnQgY2FsbGVkIHRoZSBpbmNlbnRlci5cclxuLy8gSXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgaW5jaXJjbGUsIHRoZSBjaXJjbGUgaW5zY3JpYmVkIGluIHRoZSB0cmlhbmdsZS5cclxuXHJcbmZ1bmN0aW9uIGdldExlbmd0aCAoeDEsIHkxLCB4MiwgeTIpXHJcbntcclxuICAgIHZhciB4ID0geDEgLSB4MjtcclxuICAgIHZhciB5ID0geTEgLSB5MjtcclxuICAgIHZhciBtYWduaXR1ZGUgPSAoeCAqIHgpICsgKHkgKiB5KTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KG1hZ25pdHVkZSk7XHJcbn1cclxuXHJcbnZhciBJbkNlbnRlciA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuXHJcbiAgICB2YXIgeDEgPSB0cmlhbmdsZS54MTtcclxuICAgIHZhciB5MSA9IHRyaWFuZ2xlLnkxO1xyXG5cclxuICAgIHZhciB4MiA9IHRyaWFuZ2xlLngyO1xyXG4gICAgdmFyIHkyID0gdHJpYW5nbGUueTI7XHJcblxyXG4gICAgdmFyIHgzID0gdHJpYW5nbGUueDM7XHJcbiAgICB2YXIgeTMgPSB0cmlhbmdsZS55MztcclxuXHJcbiAgICB2YXIgZDEgPSBnZXRMZW5ndGgoeDMsIHkzLCB4MiwgeTIpO1xyXG4gICAgdmFyIGQyID0gZ2V0TGVuZ3RoKHgxLCB5MSwgeDMsIHkzKTtcclxuICAgIHZhciBkMyA9IGdldExlbmd0aCh4MiwgeTIsIHgxLCB5MSk7XHJcblxyXG4gICAgdmFyIHAgPSBkMSArIGQyICsgZDM7XHJcblxyXG4gICAgb3V0LnggPSAoeDEgKiBkMSArIHgyICogZDIgKyB4MyAqIGQzKSAvIHA7XHJcbiAgICBvdXQueSA9ICh5MSAqIGQxICsgeTIgKiBkMiArIHkzICogZDMpIC8gcDtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbkNlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL0luQ2VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldCA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgeCwgeSlcclxue1xyXG4gICAgdHJpYW5nbGUueDEgKz0geDtcclxuICAgIHRyaWFuZ2xlLnkxICs9IHk7XHJcblxyXG4gICAgdHJpYW5nbGUueDIgKz0geDtcclxuICAgIHRyaWFuZ2xlLnkyICs9IHk7XHJcblxyXG4gICAgdHJpYW5nbGUueDMgKz0geDtcclxuICAgIHRyaWFuZ2xlLnkzICs9IHk7XHJcblxyXG4gICAgcmV0dXJuIHRyaWFuZ2xlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9PZmZzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFJhbmRvbSA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuXHJcbiAgICAvLyAgQmFzaXMgdmVjdG9yc1xyXG4gICAgdmFyIHV4ID0gdHJpYW5nbGUueDIgLSB0cmlhbmdsZS54MTtcclxuICAgIHZhciB1eSA9IHRyaWFuZ2xlLnkyIC0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgdmFyIHZ4ID0gdHJpYW5nbGUueDMgLSB0cmlhbmdsZS54MTtcclxuICAgIHZhciB2eSA9IHRyaWFuZ2xlLnkzIC0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgLy8gIFJhbmRvbSBwb2ludCB3aXRoaW4gdGhlIHVuaXQgc3F1YXJlXHJcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICB2YXIgcyA9IE1hdGgucmFuZG9tKCk7XHJcblxyXG4gICAgLy8gIFBvaW50IG91dHNpZGUgdGhlIHRyaWFuZ2xlPyBSZW1hcCBpdC5cclxuICAgIGlmIChyICsgcyA+PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHIgPSAxIC0gcjtcclxuICAgICAgICBzID0gMSAtIHM7XHJcbiAgICB9XHJcblxyXG4gICAgb3V0LnggPSB0cmlhbmdsZS54MSArICgodXggKiByKSArICh2eCAqIHMpKTtcclxuICAgIG91dC55ID0gdHJpYW5nbGUueTEgKyAoKHV5ICogcikgKyAodnkgKiBzKSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvUmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQWRkcyB0aGUgc291cmNlIGFuZCBiYWNrZHJvcCBjb2xvcnMgdG9nZXRoZXIgYW5kIHJldHVybnMgdGhlIHZhbHVlLCB1cCB0byBhIG1heGltdW0gb2YgMjU1LlxyXG4qL1xyXG52YXIgQWRkID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLm1pbigyNTUsIGEgKyBiKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvQWRkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogRGFya2VucyB0aGUgYmFja2Ryb3AgY29sb3IgdG8gcmVmbGVjdCB0aGUgc291cmNlIGNvbG9yLlxyXG4qIFBhaW50aW5nIHdpdGggd2hpdGUgcHJvZHVjZXMgbm8gY2hhbmdlLiBcclxuKi9cclxudmFyIENvbG9yQnVybiA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGIgPT09IDApID8gYiA6IE1hdGgubWF4KDAsICgyNTUgLSAoKDI1NSAtIGEpIDw8IDgpIC8gYikpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb2xvckJ1cm47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9Db2xvckJ1cm4uanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBCcmlnaHRlbnMgdGhlIGJhY2tkcm9wIGNvbG9yIHRvIHJlZmxlY3QgdGhlIHNvdXJjZSBjb2xvci4gXHJcbiogUGFpbnRpbmcgd2l0aCBibGFjayBwcm9kdWNlcyBubyBjaGFuZ2UuXHJcbiovXHJcbnZhciBDb2xvckRvZGdlID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoYiA9PT0gMjU1KSA/IGIgOiBNYXRoLm1pbigyNTUsICgoYSA8PCA4KSAvICgyNTUgLSBiKSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb2xvckRvZGdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvQ29sb3JEb2RnZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFNlbGVjdHMgdGhlIGRhcmtlciBvZiB0aGUgYmFja2Ryb3AgYW5kIHNvdXJjZSBjb2xvcnMuXHJcbiovXHJcbnZhciBEYXJrZW4gPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiID4gYSkgPyBhIDogYjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGFya2VuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvRGFya2VuLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU2VsZWN0cyB0aGUgbGlnaHRlciBvZiB0aGUgYmFja2Ryb3AgYW5kIHNvdXJjZSBjb2xvcnMuXHJcbiovXHJcbnZhciBMaWdodGVuID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoYiA+IGEpID8gYiA6IGE7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0ZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaWdodGVuLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN1YnRyYWN0ID0gcmVxdWlyZSgnLi9TdWJ0cmFjdCcpO1xyXG5cclxuLyoqXHJcbiogQW4gYWxpYXMgZm9yIGJsZW5kU3VidHJhY3QsIGl0IHNpbXBseSBzdW1zIHRoZSB2YWx1ZXMgb2YgdGhlIHR3byBjb2xvcnMgYW5kIHN1YnRyYWN0cyAyNTUuXHJcbiovXHJcbnZhciBMaW5lYXJCdXJuID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBTdWJ0cmFjdChhLCBiKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZWFyQnVybjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckJ1cm4uanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQWRkID0gcmVxdWlyZSgnLi9BZGQnKTtcclxuXHJcbi8qKlxyXG4qIEFuIGFsaWFzIGZvciBibGVuZEFkZCwgaXQgc2ltcGx5IHN1bXMgdGhlIHZhbHVlcyBvZiB0aGUgdHdvIGNvbG9ycy5cclxuKi9cclxudmFyIExpbmVhckRvZGdlID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBBZGQoYSwgYik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhckRvZGdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyRG9kZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBNdWx0aXBsaWVzIG9yIHNjcmVlbnMgdGhlIGNvbG9ycywgZGVwZW5kaW5nIG9uIHRoZSBiYWNrZHJvcCBjb2xvci5cclxuKiBTb3VyY2UgY29sb3JzIG92ZXJsYXkgdGhlIGJhY2tkcm9wIHdoaWxlIHByZXNlcnZpbmcgaXRzIGhpZ2hsaWdodHMgYW5kIHNoYWRvd3MuIFxyXG4qIFRoZSBiYWNrZHJvcCBjb2xvciBpcyBub3QgcmVwbGFjZWQsIGJ1dCBpcyBtaXhlZCB3aXRoIHRoZSBzb3VyY2UgY29sb3IgdG8gcmVmbGVjdCB0aGUgbGlnaHRuZXNzIG9yIGRhcmtuZXNzIG9mIHRoZSBiYWNrZHJvcC5cclxuKi9cclxudmFyIE92ZXJsYXkgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiIDwgMTI4KSA/ICgyICogYSAqIGIgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gYSkgKiAoMjU1IC0gYikgLyAyNTUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPdmVybGF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvT3ZlcmxheS5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFJlZmxlY3QgYmxlbmQgbW9kZS4gVGhpcyBtb2RlIGlzIHVzZWZ1bCB3aGVuIGFkZGluZyBzaGluaW5nIG9iamVjdHMgb3IgbGlnaHQgem9uZXMgdG8gaW1hZ2VzLiBcclxuKi9cclxudmFyIFJlZmxlY3QgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiID09PSAyNTUpID8gYiA6IE1hdGgubWluKDI1NSwgKGEgKiBhIC8gKDI1NSAtIGIpKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9SZWZsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ29tYmluZXMgdGhlIHNvdXJjZSBhbmQgYmFja2Ryb3AgY29sb3JzIGFuZCByZXR1cm5zIHRoZWlyIHZhbHVlIG1pbnVzIDI1NS5cclxuKi9cclxudmFyIFN1YnRyYWN0ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLm1heCgwLCBhICsgYiAtIDI1NSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN1YnRyYWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvU3VidHJhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29sb3JCdXJuID0gcmVxdWlyZSgnLi9Db2xvckJ1cm4nKTtcclxudmFyIENvbG9yRG9kZ2UgPSByZXF1aXJlKCcuL0NvbG9yRG9kZ2UnKTtcclxuXHJcbi8qKlxyXG4qIFRoaXMgYmxlbmQgbW9kZSBjb21iaW5lcyBDb2xvciBEb2RnZSBhbmQgQ29sb3IgQnVybiAocmVzY2FsZWQgc28gdGhhdCBuZXV0cmFsIGNvbG9ycyBiZWNvbWUgbWlkZGxlIGdyYXkpLlxyXG4qIERvZGdlIGFwcGxpZXMgd2hlbiB2YWx1ZXMgaW4gdGhlIHRvcCBsYXllciBhcmUgbGlnaHRlciB0aGFuIG1pZGRsZSBncmF5LCBhbmQgYnVybiB0byBkYXJrZXIgdmFsdWVzLlxyXG4qIFRoZSBtaWRkbGUgZ3JheSBpcyB0aGUgbmV1dHJhbCBjb2xvci4gV2hlbiBjb2xvciBpcyBsaWdodGVyIHRoYW4gdGhpcywgdGhpcyBlZmZlY3RpdmVseSBtb3ZlcyB0aGUgd2hpdGUgcG9pbnQgb2YgdGhlIGJvdHRvbSBcclxuKiBsYXllciBkb3duIGJ5IHR3aWNlIHRoZSBkaWZmZXJlbmNlOyB3aGVuIGl0IGlzIGRhcmtlciwgdGhlIGJsYWNrIHBvaW50IGlzIG1vdmVkIHVwIGJ5IHR3aWNlIHRoZSBkaWZmZXJlbmNlLiBUaGUgcGVyY2VpdmVkIGNvbnRyYXN0IGluY3JlYXNlcy5cclxuKi9cclxudmFyIFZpdmlkTGlnaHQgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiIDwgMTI4KSA/IENvbG9yQnVybihhLCAyICogYikgOiBDb2xvckRvZGdlKGEsICgyICogKGIgLSAxMjgpKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZpdmlkTGlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9WaXZpZExpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFJldHVybiBhIHN0cmluZyBjb250YWluaW5nIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBjb2xvciBjb21wb25lbnQuXHJcbi8vICBAcGFyYW0ge2ludGVnZXJ9IGNvbG9yIC0gVGhlIGNvbG9yIGNoYW5uZWwgdG8gZ2V0IHRoZSBoZXggdmFsdWUgZm9yLCBtdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUuXHJcbi8vICBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIG9mIGxlbmd0aCAyIGNoYXJhY3RlcnMsIGkuZS4gMjU1ID0gZmYsIDEwMCA9IDY0LlxyXG52YXIgQ29tcG9uZW50VG9IZXggPSBmdW5jdGlvbiAoY29sb3IpXHJcbntcclxuICAgIHZhciBoZXggPSBjb2xvci50b1N0cmluZygxNik7XHJcblxyXG4gICAgcmV0dXJuIChoZXgubGVuZ3RoID09PSAxKSA/ICcwJyArIGhleCA6IGhleDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50VG9IZXg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvQ29tcG9uZW50VG9IZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogR2l2ZW4gYW4gYWxwaGEgYW5kIDMgY29sb3IgdmFsdWVzIHRoaXMgd2lsbCByZXR1cm4gYW4gaW50ZWdlciByZXByZXNlbnRhdGlvbiBvZiBpdC5cclxuICovXHJcbnZhciBHZXRDb2xvcjMyID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxyXG57XHJcbiAgICByZXR1cm4gYWxwaGEgPDwgMjQgfCByZWQgPDwgMTYgfCBncmVlbiA8PCA4IHwgYmx1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Q29sb3IzMjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9jb2xvci9HZXRDb2xvcjMyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENvbG9yID0gcmVxdWlyZSgnLi9HZXRDb2xvcicpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIEhTViAoaHVlLCBzYXR1cmF0aW9uIGFuZCB2YWx1ZSkgY29sb3IgdmFsdWUgdG8gUkdCLlxyXG4gKiBDb252ZXJzaW9uIGZvcm11bGEgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9jb2xvcl9zcGFjZS5cclxuICogQXNzdW1lcyBIU1YgdmFsdWVzIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMV0gYW5kIHJldHVybnMgciwgZyBhbmQgYiB2YWx1ZXMgaW4gdGhlIHNldCBbMCwgMjU1XS5cclxuICogQmFzZWQgb24gY29kZSBieSBNaWNoYWVsIEphY2tzb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uKVxyXG4gKi9cclxudmFyIEhTVlRvUkdCID0gZnVuY3Rpb24gKGgsIHMsIHYpXHJcbntcclxuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHsgcyA9IDE7IH1cclxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHsgdiA9IDE7IH1cclxuXHJcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xyXG4gICAgdmFyIGYgPSBoICogNiAtIGk7XHJcblxyXG4gICAgdmFyIHAgPSBNYXRoLmZsb29yKCh2ICogKDEgLSBzKSkgKiAyNTUpO1xyXG4gICAgdmFyIHEgPSBNYXRoLmZsb29yKCh2ICogKDEgLSBmICogcykpICogMjU1KTtcclxuICAgIHZhciB0ID0gTWF0aC5mbG9vcigodiAqICgxIC0gKDEgLSBmKSAqIHMpKSAqIDI1NSk7XHJcblxyXG4gICAgdiA9IE1hdGguZmxvb3IodiAqPSAyNTUpO1xyXG5cclxuICAgIHZhciBvdXRwdXQgPSB7IHI6IHYsIGc6IHYsIGI6IHYsIGNvbG9yOiAwIH07XHJcblxyXG4gICAgdmFyIHIgPSBpICUgNjtcclxuXHJcbiAgICBpZiAociA9PT0gMClcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQuZyA9IHQ7XHJcbiAgICAgICAgb3V0cHV0LmIgPSBwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAociA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQuciA9IHE7XHJcbiAgICAgICAgb3V0cHV0LmIgPSBwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAociA9PT0gMilcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQuciA9IHA7XHJcbiAgICAgICAgb3V0cHV0LmIgPSB0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAociA9PT0gMylcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQuciA9IHA7XHJcbiAgICAgICAgb3V0cHV0LmcgPSBxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAociA9PT0gNClcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQuciA9IHQ7XHJcbiAgICAgICAgb3V0cHV0LmcgPSBwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAociA9PT0gNSlcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQuZyA9IHA7XHJcbiAgICAgICAgb3V0cHV0LmIgPSBxO1xyXG4gICAgfVxyXG5cclxuICAgIG91dHB1dC5jb2xvciA9IEdldENvbG9yKG91dHB1dC5yLCBvdXRwdXQuZywgb3V0cHV0LmIpO1xyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhTVlRvUkdCO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL0hTVlRvUkdCLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbG9yID0gcmVxdWlyZSgnLi9Db2xvcicpO1xyXG5cclxuLyoqXHJcbiogQ29udmVydHMgYSBoZXggc3RyaW5nIGludG8gYSBQaGFzZXIgQ29sb3Igb2JqZWN0LlxyXG4qXHJcbiogVGhlIGhleCBzdHJpbmcgY2FuIHN1cHBsaWVkIGFzIGAnIzAwMzNmZidgIG9yIHRoZSBzaG9ydC1oYW5kIGZvcm1hdCBvZiBgJyMwM2YnYDsgaXQgY2FuIGJlZ2luIHdpdGggYW4gb3B0aW9uYWwgXCIjXCIgb3IgXCIweFwiLCBvciBiZSB1bnByZWZpeGVkLiAgICBcclxuKlxyXG4qIEFuIGFscGhhIGNoYW5uZWwgaXMgX25vdF8gc3VwcG9ydGVkLlxyXG4qL1xyXG52YXIgSGV4U3RyaW5nVG9Db2xvciA9IGZ1bmN0aW9uIChoZXgpXHJcbntcclxuICAgIHZhciBjb2xvciA9IG5ldyBDb2xvcigpO1xyXG5cclxuICAgIC8vIEV4cGFuZCBzaG9ydGhhbmQgZm9ybSAoZS5nLiBcIjAzRlwiKSB0byBmdWxsIGZvcm0gKGUuZy4gXCIwMDMzRkZcIilcclxuICAgIGhleCA9IGhleC5yZXBsYWNlKC9eKD86I3wweCk/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pLCBmdW5jdGlvbihtLCByLCBnLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYjtcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSAvXig/OiN8MHgpPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XHJcblxyXG4gICAgaWYgKHJlc3VsdClcclxuICAgIHtcclxuICAgICAgICB2YXIgciA9IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpO1xyXG4gICAgICAgIHZhciBnID0gcGFyc2VJbnQocmVzdWx0WzJdLCAxNik7XHJcbiAgICAgICAgdmFyIGIgPSBwYXJzZUludChyZXN1bHRbM10sIDE2KTtcclxuXHJcbiAgICAgICAgY29sb3Iuc2V0VG8ociwgZywgYik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbG9yO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIZXhTdHJpbmdUb0NvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL0hleFN0cmluZ1RvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb252ZXJ0cyBhIGh1ZSB0byBhbiBSR0IgY29sb3IuXHJcbiogQmFzZWQgb24gY29kZSBieSBNaWNoYWVsIEphY2tzb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uKVxyXG4qL1xyXG52YXIgSHVlVG9Db21wb25lbnQgPSBmdW5jdGlvbiAocCwgcSwgdClcclxue1xyXG4gICAgaWYgKHQgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIHQgKz0gMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodCA+IDEpXHJcbiAgICB7XHJcbiAgICAgICAgdCAtPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0IDwgMSAvIDYpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHQgPCAxIC8gMilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gcTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodCA8IDIgLyAzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnQgPSBIdWVUb0NvbXBvbmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9jb2xvci9IdWVUb0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3InKTtcclxudmFyIEludGVnZXJUb1JHQiA9IHJlcXVpcmUoJy4vSW50ZWdlclRvUkdCJyk7XHJcblxyXG52YXIgSW50ZWdlclRvQ29sb3IgPSBmdW5jdGlvbiAoaW5wdXQpXHJcbntcclxuICAgIHZhciByZ2IgPSBJbnRlZ2VyVG9SR0IoaW5wdXQpO1xyXG5cclxuICAgIHJldHVybiBuZXcgQ29sb3IocmdiLnIsIHJnYi5nLCByZ2IuYiwgcmdiLmEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnRlZ2VyVG9Db2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9jb2xvci9JbnRlZ2VyVG9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFJldHVybiB0aGUgY29tcG9uZW50IHBhcnRzIG9mIGEgY29sb3IgYXMgYW4gT2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgYWxwaGEsIHJlZCwgZ3JlZW4sIGJsdWUuXHJcbipcclxuKiBBbHBoYSB3aWxsIG9ubHkgYmUgc2V0IGlmIGl0IGV4aXN0cyBpbiB0aGUgZ2l2ZW4gY29sb3IgKDB4QUFSUkdHQkIpXHJcbiovXHJcbnZhciBJbnRlZ2VyVG9SR0IgPSBmdW5jdGlvbiAoY29sb3IpXHJcbntcclxuICAgIGlmIChjb2xvciA+IDE2Nzc3MjE1KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUaGUgY29sb3IgdmFsdWUgaGFzIGFuIGFscGhhIGNvbXBvbmVudFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGE6IGNvbG9yID4+PiAyNCxcclxuICAgICAgICAgICAgcjogY29sb3IgPj4gMTYgJiAweEZGLFxyXG4gICAgICAgICAgICBnOiBjb2xvciA+PiA4ICYgMHhGRixcclxuICAgICAgICAgICAgYjogY29sb3IgJiAweEZGXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhOiAyNTUsXHJcbiAgICAgICAgICAgIHI6IGNvbG9yID4+IDE2ICYgMHhGRixcclxuICAgICAgICAgICAgZzogY29sb3IgPj4gOCAmIDB4RkYsXHJcbiAgICAgICAgICAgIGI6IGNvbG9yICYgMHhGRlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludGVnZXJUb1JHQjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9jb2xvci9JbnRlZ2VyVG9SR0IuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29sb3IgPSByZXF1aXJlKCcuL0NvbG9yJyk7XHJcblxyXG4vKipcclxuKiBDb252ZXJ0cyBhIENTUyAnd2ViJyBzdHJpbmcgaW50byBhIFBoYXNlciBDb2xvciBvYmplY3QuXHJcbipcclxuKiBUaGUgd2ViIHN0cmluZyBjYW4gYmUgaW4gdGhlIGZvcm1hdCBgJ3JnYihyLGcsYiknYCBvciBgJ3JnYmEocixnLGIsYSknYCB3aGVyZSByL2cvYiBhcmUgaW4gdGhlIHJhbmdlIFswLi4yNTVdIGFuZCBhIGlzIGluIHRoZSByYW5nZSBbMC4uMV0uXHJcbiovXHJcbnZhciBSR0JTdHJpbmdUb0NvbG9yID0gZnVuY3Rpb24gKHJnYilcclxue1xyXG4gICAgdmFyIGNvbG9yID0gbmV3IENvbG9yKCk7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IC9ecmdiYT9cXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKig/OixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pKT9cXHMqXFwpJC8uZXhlYyhyZ2IudG9Mb3dlckNhc2UoKSk7XHJcblxyXG4gICAgaWYgKHJlc3VsdClcclxuICAgIHtcclxuICAgICAgICB2YXIgciA9IHBhcnNlSW50KHJlc3VsdFsxXSwgMTApO1xyXG4gICAgICAgIHZhciBnID0gcGFyc2VJbnQocmVzdWx0WzJdLCAxMCk7XHJcbiAgICAgICAgdmFyIGIgPSBwYXJzZUludChyZXN1bHRbM10sIDEwKTtcclxuICAgICAgICB2YXIgYSA9IChyZXN1bHRbNF0gIT09IHVuZGVmaW5lZCkgPyBwYXJzZUZsb2F0KHJlc3VsdFs0XSkgOiAxO1xyXG5cclxuICAgICAgICBjb2xvci5zZXRUbyhyLCBnLCBiLCBhICogMjU1KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29sb3I7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJHQlN0cmluZ1RvQ29sb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvUkdCU3RyaW5nVG9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBOT09QID0gcmVxdWlyZSgnLi4vdXRpbHMvTk9PUCcpO1xyXG5cclxuLy8gIFBoYXNlci5JbnB1dC5JbnRlcmFjdGl2ZU9iamVjdFxyXG5cclxudmFyIEludGVyYWN0aXZlT2JqZWN0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIGhpdEFyZWEsIGhpdEFyZWFDYWxsYmFjaylcclxue1xyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgZ2FtZU9iamVjdDogZ2FtZU9iamVjdCxcclxuXHJcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgIGRyb3Bab25lOiBmYWxzZSxcclxuXHJcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxyXG5cclxuICAgICAgICBjYW1lcmE6IG51bGwsXHJcblxyXG4gICAgICAgIGhpdEFyZWE6IGhpdEFyZWEsXHJcbiAgICAgICAgaGl0QXJlYUNhbGxiYWNrOiBoaXRBcmVhQ2FsbGJhY2ssXHJcblxyXG4gICAgICAgIGxvY2FsWDogMCxcclxuICAgICAgICBsb2NhbFk6IDAsXHJcblxyXG4gICAgICAgIC8vICAwID0gTm90IGJlaW5nIGRyYWdnZWRcclxuICAgICAgICAvLyAgMSA9IEJlaW5nIGNoZWNrZWQgZm9yIGRyYWdnaW5nXHJcbiAgICAgICAgLy8gIDIgPSBCZWluZyBkcmFnZ2VkXHJcbiAgICAgICAgZHJhZ1N0YXRlOiAwLFxyXG5cclxuICAgICAgICBkcmFnU3RhcnRYOiAwLFxyXG4gICAgICAgIGRyYWdTdGFydFk6IDAsXHJcblxyXG4gICAgICAgIGRyYWdYOiAwLFxyXG4gICAgICAgIGRyYWdZOiAwLFxyXG5cclxuICAgICAgICAvLyAgQ2FsbGJhY2tzXHJcblxyXG4gICAgICAgIGNhbGxiYWNrQ29udGV4dDogZ2FtZU9iamVjdCxcclxuXHJcbiAgICAgICAgLy8gIGdhbWVPYmplY3QsIHBvaW50ZXIsIHgsIHlcclxuICAgICAgICBvblVwOiBOT09QLFxyXG5cclxuICAgICAgICAvLyAgZ2FtZU9iamVjdCwgcG9pbnRlciwgeCwgeVxyXG4gICAgICAgIG9uRG93bjogTk9PUCxcclxuXHJcbiAgICAgICAgLy8gIGdhbWVPYmplY3QsIHBvaW50ZXIsIHgsIHlcclxuICAgICAgICBvbk92ZXI6IE5PT1AsXHJcblxyXG4gICAgICAgIC8vICBnYW1lT2JqZWN0LCBwb2ludGVyXHJcbiAgICAgICAgb25PdXQ6IE5PT1AsXHJcblxyXG4gICAgICAgIC8vICBnYW1lT2JqZWN0LCBwb2ludGVyLCB4LCB5XHJcbiAgICAgICAgb25Nb3ZlOiBOT09QLFxyXG5cclxuICAgICAgICBvbkRyYWdTdGFydDogTk9PUCxcclxuICAgICAgICBvbkRyYWc6IE5PT1AsXHJcbiAgICAgICAgb25EcmFnRW5kOiBOT09QXHJcblxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW50ZXJhY3RpdmVPYmplY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvSW50ZXJhY3RpdmVPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLklucHV0LkdhbWVwYWQuQXhpc1xyXG5cclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVwYWRFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnRzLycpO1xyXG5cclxudmFyIEF4aXMgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQXhpcyAocGFkLCBpbmRleClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBhZCA9IHBhZDtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBwYWQuZXZlbnRzO1xyXG5cclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcblxyXG4gICAgICAgIC8vICBCZXR3ZWVuIC0xIGFuZCAxIHdpdGggMCBiZWluZyBkZWFkIGNlbnRlclxyXG4gICAgICAgIHRoaXMudmFsdWUgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnRocmVzaG9sZCA9IDAuMDU7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEFwcGxpZXMgdGhyZXNob2xkIHRvIHRoZSB2YWx1ZSBhbmQgcmV0dXJucyBpdFxyXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSAoTWF0aC5hYnModGhpcy52YWx1ZSkgLSB0aGlzLnRocmVzaG9sZCkgLyAoMSAtIHRoaXMudGhyZXNob2xkKTtcclxuXHJcbiAgICAgICAgaWYgKHBlcmNlbnRhZ2UgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcGVyY2VudGFnZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIHJldHVybiBwZXJjZW50YWdlICogKHRoaXMudmFsdWUgPiAwID8gMSA6IC0xKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBeGlzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2dhbWVwYWQvQXhpcy5qc1xuLy8gbW9kdWxlIGlkID0gMTg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuSW5wdXQuR2FtZXBhZC5CdXR0b25cclxuXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lcGFkRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50cy8nKTtcclxuXHJcbnZhciBCdXR0b24gPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQnV0dG9uIChwYWQsIGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGFkID0gcGFkO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cyA9IHBhZC5ldmVudHM7XHJcblxyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAgICAgLy8gIEJldHdlZW4gMCBhbmQgMVxyXG4gICAgICAgIHRoaXMudmFsdWUgPSAwO1xyXG5cclxuICAgICAgICAvLyAgQ2FuIGJlIHNldCBmb3IgQW5hbG9ndWUgYnV0dG9ucyB0byBlbmFibGUgYSAncHJlc3N1cmUnIHRocmVzaG9sZCBiZWZvcmUgY29uc2lkZXJlZCBhcyAncHJlc3NlZCdcclxuICAgICAgICB0aGlzLnRocmVzaG9sZCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBkYXRhLnZhbHVlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy52YWx1ZSA+PSB0aGlzLnRocmVzaG9sZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVzc2VkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IEdhbWVwYWRFdmVudC5ET1dOKHRoaXMucGFkLCB0aGlzLCB0aGlzLnZhbHVlLCBkYXRhKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJlc3NlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgR2FtZXBhZEV2ZW50LlVQKHRoaXMucGFkLCB0aGlzLCB0aGlzLnZhbHVlLCBkYXRhKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQnV0dG9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2dhbWVwYWQvQnV0dG9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5JbnB1dC5HYW1lcGFkLkdhbWVwYWRcclxuXHJcbnZhciBBeGlzID0gcmVxdWlyZSgnLi9BeGlzJyk7XHJcbnZhciBCdXR0b24gPSByZXF1aXJlKCcuL0J1dHRvbicpO1xyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZXBhZEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudHMvJyk7XHJcblxyXG52YXIgR2FtZXBhZCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBHYW1lcGFkIChtYW5hZ2VyLCBpZCwgaW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBtYW5hZ2VyLmV2ZW50cztcclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmJ1dHRvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmF4ZXMgPSBbXTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IGRhdGEudGltZXN0YW1wO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZGF0YS5jb25uZWN0ZWQ7XHJcblxyXG4gICAgICAgIC8vICBCdXR0b25zXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5idXR0b25zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvbkRhdGEgPSBkYXRhLmJ1dHRvbnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5idXR0b25zW2ldID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uc1tpXSA9IG5ldyBCdXR0b24odGhpcywgaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uc1tpXS51cGRhdGUoYnV0dG9uRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQXhlc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5heGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGF4aXNEYXRhID0gZGF0YS5heGVzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXhlc1tpXSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF4ZXNbaV0gPSBuZXcgQXhpcyh0aGlzLCBpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5heGVzW2ldLnVwZGF0ZShheGlzRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVwYWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvZ2FtZXBhZC9HYW1lcGFkLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5JbnB1dC5HYW1lcGFkLkdhbWVwYWRNYW5hZ2VyXHJcblxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZXBhZCA9IHJlcXVpcmUoJy4vR2FtZXBhZCcpO1xyXG52YXIgR2FtZXBhZEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudHMvJyk7XHJcblxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2FtZXBhZF9BUElcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0dhbWVwYWRfQVBJL1VzaW5nX3RoZV9HYW1lcGFkX0FQSVxyXG4vLyBodHRwczovL3d3dy5zbWFzaGluZ21hZ2F6aW5lLmNvbS8yMDE1LzExL2dhbWVwYWQtYXBpLWluLXdlYi1nYW1lcy9cclxuLy8gaHR0cDovL2h0bWw1Z2FtZXBhZC5jb20vXHJcblxyXG52YXIgR2FtZXBhZE1hbmFnZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR2FtZXBhZE1hbmFnZXIgKGlucHV0TWFuYWdlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBpbnB1dE1hbmFnZXI7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gaW5wdXRNYW5hZ2VyLmV2ZW50cztcclxuXHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMudGFyZ2V0O1xyXG5cclxuICAgICAgICB0aGlzLmhhbmRsZXI7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZXBhZHMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gICBTdGFuZGFyZCBGSUZPIHF1ZXVlXHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG4gICAgfSxcclxuXHJcbiAgICBib290OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLm1hbmFnZXIuY29uZmlnO1xyXG5cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBjb25maWcuaW5wdXRHYW1lcGFkICYmIHRoaXMubWFuYWdlci5nYW1lLmRldmljZS5JbnB1dC5nYW1lcGFkcztcclxuXHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB3aW5kb3c7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydExpc3RlbmVyczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xyXG5cclxuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdGVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGV2ZW50IGFscmVhZHkgaGFuZGxlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGV2ZW50KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdnYW1lcGFkY29ubmVjdGVkJywgaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2dhbWVwYWRkaXNjb25uZWN0ZWQnLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vICBGRiBvbmx5IGZvciBub3c6XHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGJ1dHRvbmRvd24nLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGJ1dHRvbnVwJywgaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2dhbWVwYWRheGlzbW92ZScsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcExpc3RlbmVyczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdnYW1lcGFkY29ubmVjdGVkJywgdGhpcy5oYW5kbGVyKTtcclxuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdnYW1lcGFkZGlzY29ubmVjdGVkJywgdGhpcy5oYW5kbGVyKTtcclxuXHJcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGJ1dHRvbmRvd24nLCB0aGlzLmhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dhbWVwYWRidXR0b251cCcsIHRoaXMuaGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2FtZXBhZGF4aXNtb3ZlJywgdGhpcy5oYW5kbGVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGlzY29ubmVjdEFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2FtZXBhZHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmdhbWVwYWRzLmNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWRkUGFkOiBmdW5jdGlvbiAocGFkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnYW1lcGFkID0gbmV3IEdhbWVwYWQodGhpcywgcGFkLmlkLCBwYWQuaW5kZXgpO1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVwYWRzW3BhZC5pbmRleF0gPSBnYW1lcGFkO1xyXG5cclxuICAgICAgICByZXR1cm4gZ2FtZXBhZDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlUGFkOiBmdW5jdGlvbiAoaW5kZXgsIHBhZClcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgcmVmcmVzaFBhZHM6IGZ1bmN0aW9uIChwYWRzKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghcGFkcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYWQgPSBwYWRzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghcGFkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICByZW1vdmVQYWQ/XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2FtZXBhZHNbcGFkLmluZGV4XSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFkKHBhZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lcGFkc1twYWQuaW5kZXhdLnVwZGF0ZShwYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG91dCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2FtZXBhZHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nYW1lcGFkc1tpXSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb3V0LnB1c2godGhpcy5nYW1lcGFkc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBhZDogZnVuY3Rpb24gKGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nYW1lcGFkcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdhbWVwYWRzW2ldLmluZGV4ID09PSBpbmRleClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2FtZXBhZHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVmcmVzaFBhZHMobmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpO1xyXG5cclxuICAgICAgICB2YXIgbGVuID0gdGhpcy5xdWV1ZS5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChsZW4gPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlLnNwbGljZSgwLCBsZW4pO1xyXG5cclxuICAgICAgICAvLyAgUHJvY2VzcyB0aGUgZXZlbnQgcXVldWUsIGRpc3BhdGNoaW5nIGFsbCBvZiB0aGUgZXZlbnRzIHRoYXQgaGF2ZSBzdG9yZWQgdXBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gcXVldWVbaV07XHJcbiAgICAgICAgICAgIHZhciBwYWQ7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2dhbWVwYWRjb25uZWN0ZWQnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYWQgPSB0aGlzLmdldFBhZChldmVudC5nYW1lcGFkLmluZGV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IEdhbWVwYWRFdmVudC5DT05ORUNURUQocGFkLCBldmVudCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdnYW1lcGFkZGlzY29ubmVjdGVkJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcGFkID0gdGhpcy5nZXRQYWQoZXZlbnQuZ2FtZXBhZC5pbmRleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBHYW1lcGFkRXZlbnQuRElTQ09OTkVDVEVEKHBhZCwgZXZlbnQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHRvdGFsOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdhbWVwYWRzLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVwYWRNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2dhbWVwYWQvR2FtZXBhZE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgeC95IE1VU1QgYmUgdHJhbnNsYXRlZCBiZWZvcmUgYmVpbmcgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIHVubGVzcyB0aGUgZ2FtZU9iamVjdCBpcyBndWFybmF0ZWVkIHRvXHJcbi8vICBiZSBub3Qgcm90YXRlZCBvciBzY2FsZWQgaW4gYW55IHdheVxyXG5cclxudmFyIFBvaW50V2l0aGluR2FtZU9iamVjdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB4LCB5KVxyXG57XHJcbiAgICBpZiAoIWdhbWVPYmplY3QuaGl0QXJlYSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIE5vcm1hbGl6ZSB0aGUgb3JpZ2luXHJcbiAgICB4ICs9IGdhbWVPYmplY3QuZGlzcGxheU9yaWdpblg7XHJcbiAgICB5ICs9IGdhbWVPYmplY3QuZGlzcGxheU9yaWdpblk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3QuaGl0QXJlYUNhbGxiYWNrKGdhbWVPYmplY3QuaGl0QXJlYSwgeCwgeSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50V2l0aGluR2FtZU9iamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9nbG9iYWwvaW5jL1BvaW50V2l0aGluR2FtZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XHJcbnZhciBLZXkgPSByZXF1aXJlKCcuL2tleXMvS2V5Jyk7XHJcbnZhciBLZXlDb2RlcyA9IHJlcXVpcmUoJy4va2V5cy9LZXlDb2RlcycpO1xyXG52YXIgS2V5Q29tYm8gPSByZXF1aXJlKCcuL2NvbWJvL0tleUNvbWJvJyk7XHJcbnZhciBQcm9jZXNzS2V5Q29tYm8gPSByZXF1aXJlKCcuL2NvbWJvL1Byb2Nlc3NLZXlDb21ibycpO1xyXG52YXIgUHJvY2Vzc0tleURvd24gPSByZXF1aXJlKCcuL2tleXMvUHJvY2Vzc0tleURvd24nKTtcclxudmFyIFByb2Nlc3NLZXlVcCA9IHJlcXVpcmUoJy4va2V5cy9Qcm9jZXNzS2V5VXAnKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBLZXlib2FyZCBjbGFzcyBtb25pdG9ycyBrZXlib2FyZCBpbnB1dCBhbmQgZGlzcGF0Y2hlcyBrZXlib2FyZCBldmVudHMuXHJcbipcclxuKiBfTm90ZV86IG1hbnkga2V5Ym9hcmRzIGFyZSB1bmFibGUgdG8gcHJvY2VzcyBjZXJ0YWluIGNvbWJpbmF0aW9ucyBvZiBrZXlzIGR1ZSB0byBoYXJkd2FyZSBsaW1pdGF0aW9ucyBrbm93biBhcyBnaG9zdGluZy5cclxuKiBTZWUgaHR0cDovL3d3dy5odG1sNWdhbWVkZXZzLmNvbS90b3BpYy80ODc2LWltcG9zc2libGUtdG8tdXNlLW1vcmUtdGhhbi0yLWtleWJvYXJkLWlucHV0LWJ1dHRvbnMtYXQtdGhlLXNhbWUtdGltZS8gZm9yIG1vcmUgZGV0YWlscy5cclxuKlxyXG4qIEFsc28gcGxlYXNlIGJlIGF3YXJlIHRoYXQgY2VydGFpbiBicm93c2VyIGV4dGVuc2lvbnMgY2FuIGRpc2FibGUgb3Igb3ZlcnJpZGUgUGhhc2VyIGtleWJvYXJkIGhhbmRsaW5nLlxyXG4qIEZvciBleGFtcGxlIHRoZSBDaHJvbWUgZXh0ZW5zaW9uIHZpbWl1bSBpcyBrbm93biB0byBkaXNhYmxlIFBoYXNlciBmcm9tIHVzaW5nIHRoZSBEIGtleS4gQW5kIHRoZXJlIGFyZSBvdGhlcnMuXHJcbiogU28gcGxlYXNlIGNoZWNrIHlvdXIgZXh0ZW5zaW9ucyBiZWZvcmUgb3BlbmluZyBQaGFzZXIgaXNzdWVzLlxyXG4qL1xyXG5cclxudmFyIEtleWJvYXJkTWFuYWdlciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBLZXlib2FyZE1hbmFnZXIgKGlucHV0TWFuYWdlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBpbnB1dE1hbmFnZXI7XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLnRhcmdldDtcclxuXHJcbiAgICAgICAgdGhpcy5rZXlzID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuY29tYm9zID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuY2FwdHVyZXMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gICBTdGFuZGFyZCBGSUZPIHF1ZXVlXHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLmhhbmRsZXI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgQm9vdCBoYW5kbGVyIGlzIGNhbGxlZCBieSBQaGFzZXIuR2FtZSB3aGVuIGl0IGZpcnN0IHN0YXJ0cyB1cC5cclxuICAgICogVGhlIHJlbmRlcmVyIGlzIGF2YWlsYWJsZSBieSBub3cuXHJcbiAgICAqL1xyXG4gICAgYm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5tYW5hZ2VyLmNvbmZpZztcclxuXHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gY29uZmlnLmlucHV0S2V5Ym9hcmQ7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBjb25maWcuaW5wdXRLZXlib2FyZEV2ZW50VGFyZ2V0O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydExpc3RlbmVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcclxuICAgICAgICB2YXIgY2FwdHVyZXMgPSB0aGlzLmNhcHR1cmVzO1xyXG5cclxuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdGVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGV2ZW50IGFscmVhZHkgaGFuZGxlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjYXB0dXJlc1tldmVudC5rZXlDb2RlXSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3BMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmhhbmRsZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyA0IGhvdGtleXMgZm9yIFVwLCBEb3duLCBMZWZ0IGFuZCBSaWdodCBhbmQgYWxzbyBzcGFjZSBhbmQgc2hpZnQuXHJcbiAgICAqL1xyXG4gICAgY3JlYXRlQ3Vyc29yS2V5czogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRLZXlzKHtcclxuICAgICAgICAgICAgdXA6IEtleUNvZGVzLlVQLFxyXG4gICAgICAgICAgICBkb3duOiBLZXlDb2Rlcy5ET1dOLFxyXG4gICAgICAgICAgICBsZWZ0OiBLZXlDb2Rlcy5MRUZULFxyXG4gICAgICAgICAgICByaWdodDogS2V5Q29kZXMuUklHSFQsXHJcbiAgICAgICAgICAgIHNwYWNlOiBLZXlDb2Rlcy5TUEFDRSxcclxuICAgICAgICAgICAgc2hpZnQ6IEtleUNvZGVzLlNISUZUXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIHByYWN0aWNhbCB3YXkgdG8gY3JlYXRlIGFuIG9iamVjdCBjb250YWluaW5nIHVzZXIgc2VsZWN0ZWQgaG90a2V5cy5cclxuICAgICpcclxuICAgICogRm9yIGV4YW1wbGUsXHJcbiAgICAqXHJcbiAgICAqICAgICBhZGRLZXlzKCB7ICd1cCc6IFBoYXNlci5LZXlDb2RlLlcsICdkb3duJzogUGhhc2VyLktleUNvZGUuUywgJ2xlZnQnOiBQaGFzZXIuS2V5Q29kZS5BLCAncmlnaHQnOiBQaGFzZXIuS2V5Q29kZS5EIH0gKTtcclxuICAgICpcclxuICAgICogd291bGQgcmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgKGB1cGAsIGBkb3duYCwgYGxlZnRgIGFuZCBgcmlnaHRgKSByZWZlcnJpbmcgdG8ge0BsaW5rIFBoYXNlci5LZXl9IG9iamVjdC5cclxuICAgICovXHJcbiAgICBhZGRLZXlzOiBmdW5jdGlvbiAoa2V5cylcclxuICAgIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0ge307XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSB0aGlzLmFkZEtleShrZXlzW2tleV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIElmIHlvdSBuZWVkIG1vcmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciBhIEtleSB5b3UgY2FuIGNyZWF0ZSBhIG5ldyBQaGFzZXIuS2V5IG9iamVjdCB2aWEgdGhpcyBtZXRob2QuXHJcbiAgICAqIFRoZSBLZXkgb2JqZWN0IGNhbiB0aGVuIGJlIHBvbGxlZCwgaGF2ZSBldmVudHMgYXR0YWNoZWQgdG8gaXQsIGV0Yy5cclxuICAgICovXHJcbiAgICBhZGRLZXk6IGZ1bmN0aW9uIChrZXlDb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xyXG5cclxuICAgICAgICBpZiAoIWtleXNba2V5Q29kZV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXlzW2tleUNvZGVdID0gbmV3IEtleShrZXlDb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlc1trZXlDb2RlXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ga2V5c1trZXlDb2RlXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJlbW92ZXMgYSBLZXkgb2JqZWN0IGZyb20gdGhlIEtleWJvYXJkIG1hbmFnZXIuXHJcbiAgICAqL1xyXG4gICAgcmVtb3ZlS2V5OiBmdW5jdGlvbiAoa2V5Q29kZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5rZXlzW2tleUNvZGVdKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlzW2tleUNvZGVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVzW2tleUNvZGVdID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRLZXlDYXB0dXJlOiBmdW5jdGlvbiAoa2V5Q29kZXMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleUNvZGVzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleUNvZGVzID0gWyBrZXlDb2RlcyBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlDb2Rlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZXNba2V5Q29kZXNbaV1dID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUtleUNhcHR1cmU6IGZ1bmN0aW9uIChrZXlDb2RlcylcclxuICAgIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5Q29kZXMgPSBbIGtleUNvZGVzIF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvZGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlc1trZXlDb2Rlc1tpXV0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUNvbWJvOiBmdW5jdGlvbiAoa2V5cywgY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgS2V5Q29tYm8odGhpcywga2V5cywgY29uZmlnKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L0tleWJvYXJkRXZlbnRcclxuICAgIC8vICB0eXBlID0gJ2tleWRvd24nLCAna2V5dXAnXHJcbiAgICAvLyAga2V5Q29kZSA9IGludGVnZXJcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucXVldWUubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCBsZW4gPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQ2xlYXJzIHRoZSBxdWV1ZSBhcnJheSwgYW5kIGFsc28gbWVhbnMgd2UgZG9uJ3Qgd29yayBvbiBhcnJheSBkYXRhIHRoYXQgY291bGQgcG90ZW50aWFsbHlcclxuICAgICAgICAvLyAgYmUgbW9kaWZpZWQgZHVyaW5nIHRoZSBwcm9jZXNzaW5nIHBoYXNlXHJcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZS5zcGxpY2UoMCwgbGVuKTtcclxuXHJcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XHJcbiAgICAgICAgdmFyIHNpbmdsZUtleTtcclxuXHJcbiAgICAgICAgLy8gIFByb2Nlc3MgdGhlIGV2ZW50IHF1ZXVlLCBkaXNwYXRjaGluZyBhbGwgb2YgdGhlIGV2ZW50cyB0aGF0IGhhdmUgc3RvcmVkIHVwXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBldmVudCA9IHF1ZXVlW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuS0VZX0RPV05fRVZFTlQoZXZlbnQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVLZXkgPSBFdmVudC5fRE9XTltldmVudC5rZXlDb2RlXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlS2V5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5ldmVudHMuZGlzcGF0Y2gobmV3IHNpbmdsZUtleShldmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChrZXlzW2V2ZW50LmtleUNvZGVdKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb2Nlc3NLZXlEb3duKGtleXNbZXZlbnQua2V5Q29kZV0sIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5ldmVudHMuZGlzcGF0Y2gobmV3IEV2ZW50LktFWV9VUF9FVkVOVChldmVudCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNpbmdsZUtleSA9IEV2ZW50Ll9VUFtldmVudC5rZXlDb2RlXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlS2V5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5ldmVudHMuZGlzcGF0Y2gobmV3IHNpbmdsZUtleShldmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChrZXlzW2V2ZW50LmtleUNvZGVdKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb2Nlc3NLZXlVcChrZXlzW2V2ZW50LmtleUNvZGVdLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS2V5Ym9hcmRNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL0tleWJvYXJkTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHZXRGYXN0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QvR2V0RmFzdFZhbHVlJyk7XHJcbnZhciBLZXlDb21ib01hdGNoRXZlbnQgPSByZXF1aXJlKCcuL0tleUNvbWJvTWF0Y2hFdmVudCcpO1xyXG52YXIgUHJvY2Vzc0tleUNvbWJvID0gcmVxdWlyZSgnLi9Qcm9jZXNzS2V5Q29tYm8nKTtcclxudmFyIFJlc2V0S2V5Q29tYm8gPSByZXF1aXJlKCcuL1Jlc2V0S2V5Q29tYm8nKTtcclxuXHJcbi8vICBLZXlzIGNhbiBiZSBlaXRoZXI6XHJcbi8vXHJcbi8vICBBIHN0cmluZyAoQVRBUkkpXHJcbi8vICBBbiBhcnJheSBvZiBlaXRoZXIgaW50ZWdlcnMgKGtleSBjb2Rlcykgb3Igc3RyaW5ncywgb3IgYSBtaXh0dXJlIG9mIGJvdGhcclxuLy8gIEFuIGFycmF5IG9mIG9iamVjdHMgKHN1Y2ggYXMgS2V5IG9iamVjdHMpIHdpdGggYSBwdWJsaWMgJ2tleUNvZGUnIHByb3BlcnR5XHJcblxyXG52YXIgS2V5Q29tYm8gPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gS2V5Q29tYm8gKGtleWJvYXJkTWFuYWdlciwga2V5cywgY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkgeyBjb25maWcgPSB7fTsgfVxyXG5cclxuICAgICAgICAvLyAgQ2FuJ3QgaGF2ZSBhIHplcm8gb3Igc2luZ2xlIGxlbmd0aCBjb21ibyAoc3RyaW5nIG9yIGFycmF5IGJhc2VkKVxyXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA8IDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBrZXlib2FyZE1hbmFnZXI7XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMua2V5Q29kZXMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gIGlmICdrZXlzJyBpcyBhIHN0cmluZyB3ZSBuZWVkIHRvIGdldCB0aGUga2V5Y29kZSBvZiBlYWNoIGNoYXJhY3RlciBpbiBpdFxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2hhciA9IGtleXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYXIgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleUNvZGVzLnB1c2goY2hhci50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGFyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlDb2Rlcy5wdXNoKGNoYXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIuaGFzT3duUHJvcGVydHkoJ2tleUNvZGUnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlDb2Rlcy5wdXNoKGNoYXIua2V5Q29kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBUaGUgY3VycmVudCBrZXlDb2RlIHRoZSBjb21ibyBpcyB3YWl0aW5nIGZvclxyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMua2V5Q29kZXNbMF07XHJcblxyXG4gICAgICAgIC8vICBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUga2V5IGJlaW5nIHdhaXRlZCBmb3IgaW4gdGhlICdrZXlzJyBzdHJpbmdcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBsZW5ndGggb2YgdGhpcyBjb21ibyAoaW4ga2V5Y29kZXMpXHJcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5rZXlDb2Rlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vICBUaGUgdGltZSB0aGUgcHJldmlvdXMga2V5IGluIHRoZSBjb21ibyB3YXMgbWF0Y2hlZFxyXG4gICAgICAgIHRoaXMudGltZUxhc3RNYXRjaGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gIEhhcyB0aGlzIEtleSBDb21ibyBiZWVuIG1hdGNoZWQgeWV0P1xyXG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyAgVGhlIHRpbWUgdGhlIGVudGlyZSBjb21ibyB3YXMgbWF0Y2hlZFxyXG4gICAgICAgIHRoaXMudGltZU1hdGNoZWQgPSAwO1xyXG5cclxuICAgICAgICAvLyAgQ3VzdG9tIG9wdGlvbnMgLi4uXHJcblxyXG4gICAgICAgIC8vICBJZiB0aGV5IHByZXNzIHRoZSB3cm9uZyBrZXkgZG8gd2UgcmVzZXQgdGhlIGNvbWJvP1xyXG4gICAgICAgIHRoaXMucmVzZXRPbldyb25nS2V5ID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ3Jlc2V0T25Xcm9uZ0tleScsIHRydWUpO1xyXG5cclxuICAgICAgICAvLyAgVGhlIG1heCBkZWxheSBpbiBtcyBiZXR3ZWVuIGVhY2gga2V5IHByZXNzLiBBYm92ZSB0aGlzIHRoZSBjb21ibyBpcyByZXNldC4gMCBtZWFucyBkaXNhYmxlZC5cclxuICAgICAgICB0aGlzLm1heEtleURlbGF5ID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ21heEtleURlbGF5JywgMCk7XHJcblxyXG4gICAgICAgIC8vICBJZiBwcmV2aW91c2x5IG1hdGNoZWQgYW5kIHRoZXkgcHJlc3MgS2V5IDEgYWdhaW4sIHdpbGwgaXQgcmVzZXQ/XHJcbiAgICAgICAgdGhpcy5yZXNldE9uTWF0Y2ggPSBHZXRGYXN0VmFsdWUoY29uZmlnLCAncmVzZXRPbk1hdGNoJywgZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyAgSWYgdGhlIGNvbWJvIG1hdGNoZXMsIHdpbGwgaXQgZGVsZXRlIGl0c2VsZj9cclxuICAgICAgICB0aGlzLmRlbGV0ZU9uTWF0Y2ggPSBHZXRGYXN0VmFsdWUoY29uZmlnLCAnZGVsZXRlT25NYXRjaCcsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG9uS2V5RG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMubWF0Y2hlZCB8fCAhX3RoaXMuZW5hYmxlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IFByb2Nlc3NLZXlDb21ibyhldmVudC5kYXRhLCBfdGhpcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAobWF0Y2hlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubWFuYWdlci5ldmVudHMuZGlzcGF0Y2gobmV3IEtleUNvbWJvTWF0Y2hFdmVudChfdGhpcywgZXZlbnQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzZXRPbk1hdGNoKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFJlc2V0S2V5Q29tYm8oX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuZGVsZXRlT25NYXRjaClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLm9uS2V5RG93biA9IG9uS2V5RG93bkhhbmRsZXI7XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5ldmVudHMub24oJ0tFWV9ET1dOX0VWRU5UJywgb25LZXlEb3duSGFuZGxlcik7XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2dyZXNzOiB7XHJcblxyXG4gICAgICAgIC8vICBIb3cgZmFyIGNvbXBsZXRlIGlzIHRoaXMgY29tYm8/IEEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4IC8gdGhpcy5zaXplO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5rZXlDb2RlcyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIuZXZlbnRzLm9mZignS0VZX0RPV04nLCB0aGlzLm9uS2V5RG93bik7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleUNvbWJvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2NvbWJvL0tleUNvbWJvLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEFkdmFuY2VLZXlDb21ibyA9IHJlcXVpcmUoJy4vQWR2YW5jZUtleUNvbWJvJyk7XHJcblxyXG52YXIgUHJvY2Vzc0tleUNvbWJvID0gZnVuY3Rpb24gKGV2ZW50LCBjb21ibylcclxue1xyXG4gICAgaWYgKGNvbWJvLm1hdGNoZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbWJvTWF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgdmFyIGtleU1hdGNoZWQgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gY29tYm8uY3VycmVudClcclxuICAgIHtcclxuICAgICAgICAvLyAgS2V5IHdhcyBjb3JyZWN0XHJcblxyXG4gICAgICAgIGlmIChjb21iby5pbmRleCA+IDAgJiYgY29tYm8ubWF4S2V5RGVsYXkgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFdlIGhhdmUgdG8gY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWxheSBiZXR3ZWVuXHJcbiAgICAgICAgICAgIC8vICB0aGUgbmV3IGtleSBhbmQgdGhlIG9sZCBvbmUgd2FzIHRvbyBsb25nIChpZiBlbmFibGVkKVxyXG5cclxuICAgICAgICAgICAgdmFyIHRpbWVMaW1pdCA9IGNvbWJvLnRpbWVMYXN0TWF0Y2hlZCArIGNvbWJvLm1heEtleURlbGF5O1xyXG5cclxuICAgICAgICAgICAgLy8gIENoZWNrIGlmIHRoZXkgcHJlc3NlZCBpdCBpbiB0aW1lIG9yIG5vdFxyXG4gICAgICAgICAgICBpZiAoZXZlbnQudGltZVN0YW1wIDw9IHRpbWVMaW1pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5TWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb21ib01hdGNoZWQgPSBBZHZhbmNlS2V5Q29tYm8oZXZlbnQsIGNvbWJvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXlNYXRjaGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vICBXZSBkb24ndCBjaGVjayB0aGUgdGltZSBmb3IgdGhlIGZpcnN0IGtleSBwcmVzc2VkLCBzbyBqdXN0IGFkdmFuY2UgaXRcclxuICAgICAgICAgICAgY29tYm9NYXRjaGVkID0gQWR2YW5jZUtleUNvbWJvKGV2ZW50LCBjb21ibyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgha2V5TWF0Y2hlZCAmJiBjb21iby5yZXNldE9uV3JvbmdLZXkpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFdyb25nIGtleSB3YXMgcHJlc3NlZFxyXG4gICAgICAgIGNvbWJvLmluZGV4ID0gMDtcclxuICAgICAgICBjb21iby5jdXJyZW50ID0gY29tYm8ua2V5Q29kZXNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbWJvTWF0Y2hlZClcclxuICAgIHtcclxuICAgICAgICBjb21iby50aW1lTGFzdE1hdGNoZWQgPSBldmVudC50aW1lU3RhbXA7XHJcbiAgICAgICAgY29tYm8ubWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgY29tYm8udGltZU1hdGNoZWQgPSBldmVudC50aW1lU3RhbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbWJvTWF0Y2hlZDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc0tleUNvbWJvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2NvbWJvL1Byb2Nlc3NLZXlDb21iby5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcblxyXG4vLyAgUGhhc2VyLklucHV0LktleWJvYXJkLktleVxyXG5cclxuLy8gIEEgZ2VuZXJpYyBLZXkgb2JqZWN0IHdoaWNoIGNhbiBiZSBwYXNzZWQgdG8gdGhlIFByb2Nlc3MgZnVuY3Rpb25zIChhbmQgc28gb24pXHJcbi8vICBrZXljb2RlIG11c3QgYmUgYW4gaW50ZWdlclxyXG5cclxudmFyIEtleSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBLZXkgKGtleUNvZGUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEBwcm9wZXJ0eSB7aW50ZWdlcn0ga2V5Q29kZSAtIFRoZSBrZXljb2RlIG9mIHRoaXMga2V5LlxyXG4gICAgICAgIHRoaXMua2V5Q29kZSA9IGtleUNvZGU7XHJcblxyXG4gICAgICAgIC8vICBAcHJvcGVydHkge0tleWJvYXJkRXZlbnR9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxyXG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcHJldmVudERlZmF1bHQgLSBTaG91bGQgdGhpcyBLZXkgcHJldmVudCBldmVudCBwcm9wYWdhdGlvbj9cclxuICAgICAgICAvLyAgQGRlZmF1bHRcclxuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5hYmxlZCAtIENhbiB0aGlzIEtleSBiZSBwcm9jZXNzZWQ/XHJcbiAgICAgICAgLy8gIEBkZWZhdWx0XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNEb3duIC0gVGhlIFwiZG93blwiIHN0YXRlIG9mIHRoZSBrZXkuIFRoaXMgd2lsbCByZW1haW4gYHRydWVgIGZvciBhcyBsb25nIGFzIHRoZSBrZXlib2FyZCB0aGlua3MgdGhpcyBrZXkgaXMgaGVsZCBkb3duLlxyXG4gICAgICAgIC8vICBAZGVmYXVsdFxyXG4gICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IGlzVXAgLSBUaGUgXCJ1cFwiIHN0YXRlIG9mIHRoZSBrZXkuIFRoaXMgd2lsbCByZW1haW4gYHRydWVgIGZvciBhcyBsb25nIGFzIHRoZSBrZXlib2FyZCB0aGlua3MgdGhpcyBrZXkgaXMgdXAuXHJcbiAgICAgICAgLy8gIEBkZWZhdWx0XHJcbiAgICAgICAgdGhpcy5pc1VwID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWx0S2V5IC0gVGhlIGRvd24gc3RhdGUgb2YgdGhlIEFMVCBrZXksIGlmIHByZXNzZWQgYXQgdGhlIHNhbWUgdGltZSBhcyB0aGlzIGtleS5cclxuICAgICAgICAvLyAgQGRlZmF1bHRcclxuICAgICAgICB0aGlzLmFsdEtleSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBjdHJsS2V5IC0gVGhlIGRvd24gc3RhdGUgb2YgdGhlIENUUkwga2V5LCBpZiBwcmVzc2VkIGF0IHRoZSBzYW1lIHRpbWUgYXMgdGhpcyBrZXkuXHJcbiAgICAgICAgLy8gIEBkZWZhdWx0XHJcbiAgICAgICAgdGhpcy5jdHJsS2V5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IHNoaWZ0S2V5IC0gVGhlIGRvd24gc3RhdGUgb2YgdGhlIFNISUZUIGtleSwgaWYgcHJlc3NlZCBhdCB0aGUgc2FtZSB0aW1lIGFzIHRoaXMga2V5LlxyXG4gICAgICAgIC8vICBAZGVmYXVsdFxyXG4gICAgICAgIHRoaXMuc2hpZnRLZXkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gIEBwcm9wZXJ0eSB7aW50ZWdlcn0gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gb2YgdGhlIG1vZGlmaWVyIGtleS4gMCBmb3Igc3RhbmRhcmQgKG9yIHVua25vd24pLCAxIGZvciBsZWZ0LCAyIGZvciByaWdodCwgMyBmb3IgbnVtcGFkLlxyXG4gICAgICAgIC8vICBAZGVmYXVsdFxyXG4gICAgICAgIHRoaXMubG9jYXRpb24gPSAwO1xyXG5cclxuICAgICAgICAvLyAgQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVEb3duIC0gVGhlIHRpbWVzdGFtcCB3aGVuIHRoZSBrZXkgd2FzIGxhc3QgcHJlc3NlZCBkb3duLiBUaGlzIGlzIGJhc2VkIG9uIEdhbWUudGltZS5ub3cuXHJcbiAgICAgICAgdGhpcy50aW1lRG93biA9IDA7XHJcblxyXG4gICAgICAgIC8vICBJZiB0aGUga2V5IGlzIGRvd24gdGhpcyB2YWx1ZSBob2xkcyB0aGUgZHVyYXRpb24gb2YgdGhhdCBrZXkgcHJlc3MgYW5kIGlzIGNvbnN0YW50bHkgdXBkYXRlZC5cclxuICAgICAgICAvLyAgSWYgdGhlIGtleSBpcyB1cCBpdCBob2xkcyB0aGUgZHVyYXRpb24gb2YgdGhlIHByZXZpb3VzIGRvd24gc2Vzc2lvbi5cclxuICAgICAgICAvLyAgQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhpcyBrZXkgaGFzIGJlZW4gaGVsZCBkb3duIGZvci5cclxuICAgICAgICAvLyAgQGRlZmF1bHRcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMDtcclxuXHJcbiAgICAgICAgLy8gIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lVXAgLSBUaGUgdGltZXN0YW1wIHdoZW4gdGhlIGtleSB3YXMgbGFzdCByZWxlYXNlZC4gVGhpcyBpcyBiYXNlZCBvbiBHYW1lLnRpbWUubm93LlxyXG4gICAgICAgIC8vICBAZGVmYXVsdFxyXG4gICAgICAgIHRoaXMudGltZVVwID0gMDtcclxuXHJcbiAgICAgICAgLy8gIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXBlYXRzIC0gSWYgYSBrZXkgaXMgaGVsZCBkb3duIHRoaXMgaG9sZHMgZG93biB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgaGFzICdyZXBlYXRlZCcuXHJcbiAgICAgICAgLy8gIEBkZWZhdWx0XHJcbiAgICAgICAgdGhpcy5yZXBlYXRzID0gMDtcclxuXHJcbiAgICAgICAgIC8vIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gX2p1c3REb3duIC0gVHJ1ZSBpZiB0aGUga2V5IGhhcyBqdXN0IGJlZW4gcHJlc3NlZCAoTk9URTogcmVxdWlyZXMgdG8gYmUgcmVzZXQsIHNlZSBqdXN0RG93biBnZXR0ZXIpXHJcbiAgICAgICAgIC8vIEBwcml2YXRlXHJcbiAgICAgICAgIHRoaXMuX2p1c3REb3duID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAvLyBAcHJvcGVydHkge2Jvb2xlYW59IF9qdXN0VXAgLSBUcnVlIGlmIHRoZSBrZXkgaGFzIGp1c3QgYmVlbiBwcmVzc2VkIChOT1RFOiByZXF1aXJlcyB0byBiZSByZXNldCwgc2VlIGp1c3REb3duIGdldHRlcilcclxuICAgICAgICAgLy8gQHByaXZhdGVcclxuICAgICAgICAgdGhpcy5fanVzdFVwID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS2V5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2tleXMvS2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbi8vICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudFxyXG4vLyAgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWRcclxuXHJcbnZhciBNb3VzZU1hbmFnZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gTW91c2VNYW5hZ2VyIChpbnB1dE1hbmFnZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gaW5wdXRNYW5hZ2VyO1xyXG5cclxuICAgICAgICAvLyBAcHJvcGVydHkge2Jvb2xlYW59IGNhcHR1cmUgLSBJZiB0cnVlIHRoZSBET00gbW91c2UgZXZlbnRzIHdpbGwgaGF2ZSBldmVudC5wcmV2ZW50RGVmYXVsdCBhcHBsaWVkIHRvIHRoZW0sIGlmIGZhbHNlIHRoZXkgd2lsbCBwcm9wYWdhdGUgZnVsbHkuXHJcbiAgICAgICAgdGhpcy5jYXB0dXJlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLnRhcmdldDtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVyO1xyXG4gICAgfSxcclxuXHJcbiAgICBib290OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLm1hbmFnZXIuY29uZmlnO1xyXG5cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBjb25maWcuaW5wdXRNb3VzZTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGNvbmZpZy5pbnB1dE1vdXNlRXZlbnRUYXJnZXQ7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy50YXJnZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMubWFuYWdlci5nYW1lLmNhbnZhcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuZGlzYWJsZUNvbnRleHRNZW51KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlQ29udGV4dE1lbnUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNhYmxlQ29udGV4dE1lbnU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChldmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0TGlzdGVuZXJzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBxdWV1ZSA9IHRoaXMubWFuYWdlci5xdWV1ZTtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHRlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBldmVudCBhbHJlYWR5IGhhbmRsZWRcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcXVldWUucHVzaChldmVudCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY2FwdHVyZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcExpc3RlbmVyczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2VNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L21vdXNlL01vdXNlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vWEhSU2V0dGluZ3MnKTtcclxuXHJcbi8vICBUYWtlcyB0d28gWEhSIE9iamVjdHMgYW5kIGNyZWF0ZXMgYSBuZXcgb2JqZWN0XHJcblxyXG4vLyAgVGhlIG5ldyBvYmplY3QgaXMgYmFzZWQgb24gZ2xvYmFsIGluaXRpYWxseSwgYnV0IGFueSBzZXR0aW5nIGluXHJcbi8vICBsb2NhbCBvdmVycmlkZXMgdGhlIGdsb2JhbCB2YWx1ZS5cclxuXHJcbnZhciBNZXJnZVhIUlNldHRpbmdzID0gZnVuY3Rpb24gKGdsb2JhbCwgbG9jYWwpXHJcbntcclxuICAgIHZhciBvdXRwdXQgPSAoZ2xvYmFsID09PSB1bmRlZmluZWQpID8gWEhSU2V0dGluZ3MoKSA6IE9iamVjdC5hc3NpZ24oZ2xvYmFsKTtcclxuXHJcbiAgICBpZiAobG9jYWwpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgc2V0dGluZyBpbiBsb2NhbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbFtzZXR0aW5nXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRbc2V0dGluZ10gPSBsb2NhbFtzZXR0aW5nXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVhIUlNldHRpbmdzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9NZXJnZVhIUlNldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcblxyXG4vLyAgUGhhc2VyLkxvYWRlci5GaWxlVHlwZXMuVGV4dEZpbGVcclxuXHJcbnZhciBUZXh0RmlsZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRmlsZSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFRleHRGaWxlIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZpbGVDb25maWcgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uOiAndHh0JyxcclxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXHJcbiAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgeGhyU2V0dGluZ3M6IHhoclNldHRpbmdzXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgRmlsZS5jYWxsKHRoaXMsIGZpbGVDb25maWcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblByb2Nlc3M6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQ7XHJcblxyXG4gICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgICAgICBjYWxsYmFjayh0aGlzKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuVGV4dEZpbGUuY3JlYXRlID0gZnVuY3Rpb24gKGxvYWRlciwga2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIElmIGl0J3MgYW4gYXJyYXkgaXQgaGFzIHRvIGJlIGFuIGFycmF5IG9mIE9iamVjdHMsIHNvIHdlIGdldCBldmVyeXRoaW5nIG91dCBvZiB0aGUgJ2tleScgb2JqZWN0XHJcbiAgICAgICAgICAgIGxvYWRlci5hZGRGaWxlKG5ldyBUZXh0RmlsZShrZXlbaV0sIHVybCwgbG9hZGVyLnBhdGgsIHhoclNldHRpbmdzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGxvYWRlci5hZGRGaWxlKG5ldyBUZXh0RmlsZShrZXksIHVybCwgbG9hZGVyLnBhdGgsIHhoclNldHRpbmdzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZvciBtZXRob2QgY2hhaW5pbmdcclxuICAgIHJldHVybiBsb2FkZXI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9maWxldHlwZXMvVGV4dEZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxudmFyIEdldEZhc3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRGYXN0VmFsdWUnKTtcclxudmFyIFBhcnNlWE1MID0gcmVxdWlyZSgnLi4vLi4vZG9tL1BhcnNlWE1MJyk7XHJcblxyXG4vLyAgUGhhc2VyLkxvYWRlci5GaWxlVHlwZXMuWE1MRmlsZVxyXG5cclxudmFyIFhNTEZpbGUgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEZpbGUsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBYTUxGaWxlIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZpbGVLZXkgPSAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpID8ga2V5IDogR2V0RmFzdFZhbHVlKGtleSwgJ2tleScsICcnKTtcclxuXHJcbiAgICAgICAgdmFyIGZpbGVDb25maWcgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICd4bWwnLFxyXG4gICAgICAgICAgICBleHRlbnNpb246IEdldEZhc3RWYWx1ZShrZXksICdleHRlbnNpb24nLCAneG1sJyksXHJcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxyXG4gICAgICAgICAgICBrZXk6IGZpbGVLZXksXHJcbiAgICAgICAgICAgIHVybDogR2V0RmFzdFZhbHVlKGtleSwgJ2ZpbGUnLCB1cmwpLFxyXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgICAgICB4aHJTZXR0aW5nczogR2V0RmFzdFZhbHVlKGtleSwgJ3hocicsIHhoclNldHRpbmdzKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIEZpbGUuY2FsbCh0aGlzLCBmaWxlQ29uZmlnKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Qcm9jZXNzOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhID0gUGFyc2VYTUwodGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE1MRmlsZTogSW52YWxpZCBYTUwnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgICAgICBjYWxsYmFjayh0aGlzKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuWE1MRmlsZS5jcmVhdGUgPSBmdW5jdGlvbiAobG9hZGVyLCBrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSWYgaXQncyBhbiBhcnJheSBpdCBoYXMgdG8gYmUgYW4gYXJyYXkgb2YgT2JqZWN0cywgc28gd2UgZ2V0IGV2ZXJ5dGhpbmcgb3V0IG9mIHRoZSAna2V5JyBvYmplY3RcclxuICAgICAgICAgICAgbG9hZGVyLmFkZEZpbGUobmV3IFhNTEZpbGUoa2V5W2ldLCB1cmwsIGxvYWRlci5wYXRoLCB4aHJTZXR0aW5ncykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBsb2FkZXIuYWRkRmlsZShuZXcgWE1MRmlsZShrZXksIHVybCwgbG9hZGVyLnBhdGgsIHhoclNldHRpbmdzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZvciBtZXRob2QgY2hhaW5pbmdcclxuICAgIHJldHVybiBsb2FkZXI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhNTEZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZhY3RvcmlhbCA9IHJlcXVpcmUoJy4vRmFjdG9yaWFsJyk7XHJcblxyXG52YXIgQmVybnN0ZWluID0gZnVuY3Rpb24gKG4sIGkpXHJcbntcclxuICAgIHJldHVybiBGYWN0b3JpYWwobikgLyBGYWN0b3JpYWwoaSkgLyBGYWN0b3JpYWwobiAtIGkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCZXJuc3RlaW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9CZXJuc3RlaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmFjdG9yaWFsID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlcyA9IHZhbHVlO1xyXG5cclxuICAgIHdoaWxlICgtLXZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJlcyAqPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3JpYWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9GYWN0b3JpYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGluZWFyID0gZnVuY3Rpb24gKHAwLCBwMSwgdClcclxue1xyXG4gICAgcmV0dXJuIChwMSAtIHAwKSAqIHQgKyBwMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZWFyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvTGluZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEFkYXB0ZWQgZnJvbSBbZ2wtbWF0cml4XShodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgpIGJ5IHRvamkgXHJcbi8vICBhbmQgW3ZlY21hdGhdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC92ZWNtYXRoKSBieSBtYXR0ZGVzbFxyXG5cclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBNYXRyaXgzID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIE1hdHJpeDMgKG0pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy52YWwgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xyXG5cclxuICAgICAgICBpZiAobSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBBc3N1bWUgTWF0cml4MyB3aXRoIHZhbDpcclxuICAgICAgICAgICAgdGhpcy5jb3B5KG0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgRGVmYXVsdCB0byBpZGVudGl0eVxyXG4gICAgICAgICAgICB0aGlzLmlkZW50aXR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeDModGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKHNyYylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KHNyYyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uIChzcmMpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG91dCA9IHRoaXMudmFsO1xyXG4gICAgICAgIHZhciBhID0gc3JjLnZhbDtcclxuXHJcbiAgICAgICAgb3V0WzBdID0gYVswXTtcclxuICAgICAgICBvdXRbMV0gPSBhWzFdO1xyXG4gICAgICAgIG91dFsyXSA9IGFbMl07XHJcbiAgICAgICAgb3V0WzNdID0gYVszXTtcclxuICAgICAgICBvdXRbNF0gPSBhWzRdO1xyXG4gICAgICAgIG91dFs1XSA9IGFbNV07XHJcbiAgICAgICAgb3V0WzZdID0gYVs2XTtcclxuICAgICAgICBvdXRbN10gPSBhWzddO1xyXG4gICAgICAgIG91dFs4XSA9IGFbOF07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBmcm9tTWF0NDogZnVuY3Rpb24gKG0pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSBtLnZhbDtcclxuICAgICAgICB2YXIgb3V0ID0gdGhpcy52YWw7XHJcblxyXG4gICAgICAgIG91dFswXSA9IGFbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXTtcclxuICAgICAgICBvdXRbMl0gPSBhWzJdO1xyXG4gICAgICAgIG91dFszXSA9IGFbNF07XHJcbiAgICAgICAgb3V0WzRdID0gYVs1XTtcclxuICAgICAgICBvdXRbNV0gPSBhWzZdO1xyXG4gICAgICAgIG91dFs2XSA9IGFbOF07XHJcbiAgICAgICAgb3V0WzddID0gYVs5XTtcclxuICAgICAgICBvdXRbOF0gPSBhWzEwXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21BcnJheTogZnVuY3Rpb24gKGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG91dCA9IHRoaXMudmFsO1xyXG5cclxuICAgICAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICAgICAgb3V0WzJdID0gYVsyXTtcclxuICAgICAgICBvdXRbM10gPSBhWzNdO1xyXG4gICAgICAgIG91dFs0XSA9IGFbNF07XHJcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcclxuICAgICAgICBvdXRbNl0gPSBhWzZdO1xyXG4gICAgICAgIG91dFs3XSA9IGFbN107XHJcbiAgICAgICAgb3V0WzhdID0gYVs4XTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGlkZW50aXR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXQgPSB0aGlzLnZhbDtcclxuXHJcbiAgICAgICAgb3V0WzBdID0gMTtcclxuICAgICAgICBvdXRbMV0gPSAwO1xyXG4gICAgICAgIG91dFsyXSA9IDA7XHJcbiAgICAgICAgb3V0WzNdID0gMDtcclxuICAgICAgICBvdXRbNF0gPSAxO1xyXG4gICAgICAgIG91dFs1XSA9IDA7XHJcbiAgICAgICAgb3V0WzZdID0gMDtcclxuICAgICAgICBvdXRbN10gPSAwO1xyXG4gICAgICAgIG91dFs4XSA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbDtcclxuICAgICAgICB2YXIgYTAxID0gYVsxXTtcclxuICAgICAgICB2YXIgYTAyID0gYVsyXTtcclxuICAgICAgICB2YXIgYTEyID0gYVs1XTtcclxuXHJcbiAgICAgICAgYVsxXSA9IGFbM107XHJcbiAgICAgICAgYVsyXSA9IGFbNl07XHJcbiAgICAgICAgYVszXSA9IGEwMTtcclxuICAgICAgICBhWzVdID0gYVs3XTtcclxuICAgICAgICBhWzZdID0gYTAyO1xyXG4gICAgICAgIGFbN10gPSBhMTI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbnZlcnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbDtcclxuXHJcbiAgICAgICAgdmFyIGEwMCA9IGFbMF07XHJcbiAgICAgICAgdmFyIGEwMSA9IGFbMV07XHJcbiAgICAgICAgdmFyIGEwMiA9IGFbMl07XHJcbiAgICAgICAgdmFyIGExMCA9IGFbM107XHJcbiAgICAgICAgdmFyIGExMSA9IGFbNF07XHJcbiAgICAgICAgdmFyIGExMiA9IGFbNV07XHJcbiAgICAgICAgdmFyIGEyMCA9IGFbNl07XHJcbiAgICAgICAgdmFyIGEyMSA9IGFbN107XHJcbiAgICAgICAgdmFyIGEyMiA9IGFbOF07XHJcblxyXG4gICAgICAgIHZhciBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7XHJcbiAgICAgICAgdmFyIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XHJcbiAgICAgICAgdmFyIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMDtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxyXG4gICAgICAgIHZhciBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XHJcblxyXG4gICAgICAgIGlmICghZGV0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZXQgPSAxIC8gZGV0O1xyXG5cclxuICAgICAgICBhWzBdID0gYjAxICogZGV0O1xyXG4gICAgICAgIGFbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XHJcbiAgICAgICAgYVsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xyXG4gICAgICAgIGFbM10gPSBiMTEgKiBkZXQ7XHJcbiAgICAgICAgYVs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xyXG4gICAgICAgIGFbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XHJcbiAgICAgICAgYVs2XSA9IGIyMSAqIGRldDtcclxuICAgICAgICBhWzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xyXG4gICAgICAgIGFbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkam9pbnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbDtcclxuXHJcbiAgICAgICAgdmFyIGEwMCA9IGFbMF07XHJcbiAgICAgICAgdmFyIGEwMSA9IGFbMV07XHJcbiAgICAgICAgdmFyIGEwMiA9IGFbMl07XHJcbiAgICAgICAgdmFyIGExMCA9IGFbM107XHJcbiAgICAgICAgdmFyIGExMSA9IGFbNF07XHJcbiAgICAgICAgdmFyIGExMiA9IGFbNV07XHJcbiAgICAgICAgdmFyIGEyMCA9IGFbNl07XHJcbiAgICAgICAgdmFyIGEyMSA9IGFbN107XHJcbiAgICAgICAgdmFyIGEyMiA9IGFbOF07XHJcblxyXG4gICAgICAgIGFbMF0gPSAoYTExICogYTIyIC0gYTEyICogYTIxKTtcclxuICAgICAgICBhWzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XHJcbiAgICAgICAgYVsyXSA9IChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xyXG4gICAgICAgIGFbM10gPSAoYTEyICogYTIwIC0gYTEwICogYTIyKTtcclxuICAgICAgICBhWzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XHJcbiAgICAgICAgYVs1XSA9IChhMDIgKiBhMTAgLSBhMDAgKiBhMTIpO1xyXG4gICAgICAgIGFbNl0gPSAoYTEwICogYTIxIC0gYTExICogYTIwKTtcclxuICAgICAgICBhWzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XHJcbiAgICAgICAgYVs4XSA9IChhMDAgKiBhMTEgLSBhMDEgKiBhMTApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbDtcclxuXHJcbiAgICAgICAgdmFyIGEwMCA9IGFbMF07XHJcbiAgICAgICAgdmFyIGEwMSA9IGFbMV07XHJcbiAgICAgICAgdmFyIGEwMiA9IGFbMl07XHJcbiAgICAgICAgdmFyIGExMCA9IGFbM107XHJcbiAgICAgICAgdmFyIGExMSA9IGFbNF07XHJcbiAgICAgICAgdmFyIGExMiA9IGFbNV07XHJcbiAgICAgICAgdmFyIGEyMCA9IGFbNl07XHJcbiAgICAgICAgdmFyIGEyMSA9IGFbN107XHJcbiAgICAgICAgdmFyIGEyMiA9IGFbOF07XHJcblxyXG4gICAgICAgIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKHNyYylcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsO1xyXG5cclxuICAgICAgICB2YXIgYTAwID0gYVswXTtcclxuICAgICAgICB2YXIgYTAxID0gYVsxXTtcclxuICAgICAgICB2YXIgYTAyID0gYVsyXTtcclxuICAgICAgICB2YXIgYTEwID0gYVszXTtcclxuICAgICAgICB2YXIgYTExID0gYVs0XTtcclxuICAgICAgICB2YXIgYTEyID0gYVs1XTtcclxuICAgICAgICB2YXIgYTIwID0gYVs2XTtcclxuICAgICAgICB2YXIgYTIxID0gYVs3XTtcclxuICAgICAgICB2YXIgYTIyID0gYVs4XTtcclxuXHJcbiAgICAgICAgdmFyIGIgPSBzcmMudmFsO1xyXG5cclxuICAgICAgICB2YXIgYjAwID0gYlswXTtcclxuICAgICAgICB2YXIgYjAxID0gYlsxXTtcclxuICAgICAgICB2YXIgYjAyID0gYlsyXTtcclxuICAgICAgICB2YXIgYjEwID0gYlszXTtcclxuICAgICAgICB2YXIgYjExID0gYls0XTtcclxuICAgICAgICB2YXIgYjEyID0gYls1XTtcclxuICAgICAgICB2YXIgYjIwID0gYls2XTtcclxuICAgICAgICB2YXIgYjIxID0gYls3XTtcclxuICAgICAgICB2YXIgYjIyID0gYls4XTtcclxuXHJcbiAgICAgICAgYVswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcclxuICAgICAgICBhWzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xyXG4gICAgICAgIGFbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XHJcblxyXG4gICAgICAgIGFbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XHJcbiAgICAgICAgYVs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcclxuICAgICAgICBhWzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xyXG5cclxuICAgICAgICBhWzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xyXG4gICAgICAgIGFbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XHJcbiAgICAgICAgYVs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKHYpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbDtcclxuICAgICAgICB2YXIgeCA9IHYueDtcclxuICAgICAgICB2YXIgeSA9IHYueTtcclxuXHJcbiAgICAgICAgYVs2XSA9IHggKiBhWzBdICsgeSAqIGFbM10gKyBhWzZdO1xyXG4gICAgICAgIGFbN10gPSB4ICogYVsxXSArIHkgKiBhWzRdICsgYVs3XTtcclxuICAgICAgICBhWzhdID0geCAqIGFbMl0gKyB5ICogYVs1XSArIGFbOF07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGU6IGZ1bmN0aW9uIChyYWQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbDtcclxuXHJcbiAgICAgICAgdmFyIGEwMCA9IGFbMF07XHJcbiAgICAgICAgdmFyIGEwMSA9IGFbMV07XHJcbiAgICAgICAgdmFyIGEwMiA9IGFbMl07XHJcbiAgICAgICAgdmFyIGExMCA9IGFbM107XHJcbiAgICAgICAgdmFyIGExMSA9IGFbNF07XHJcbiAgICAgICAgdmFyIGExMiA9IGFbNV07XHJcblxyXG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XHJcblxyXG4gICAgICAgIGFbMF0gPSBjICogYTAwICsgcyAqIGExMDtcclxuICAgICAgICBhWzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XHJcbiAgICAgICAgYVsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xyXG5cclxuICAgICAgICBhWzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XHJcbiAgICAgICAgYVs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xyXG4gICAgICAgIGFbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlOiBmdW5jdGlvbiAodilcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsO1xyXG4gICAgICAgIHZhciB4ID0gdi54O1xyXG4gICAgICAgIHZhciB5ID0gdi55O1xyXG5cclxuICAgICAgICBhWzBdID0geCAqIGFbMF07XHJcbiAgICAgICAgYVsxXSA9IHggKiBhWzFdO1xyXG4gICAgICAgIGFbMl0gPSB4ICogYVsyXTtcclxuXHJcbiAgICAgICAgYVszXSA9IHkgKiBhWzNdO1xyXG4gICAgICAgIGFbNF0gPSB5ICogYVs0XTtcclxuICAgICAgICBhWzVdID0geSAqIGFbNV07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBmcm9tUXVhdDogZnVuY3Rpb24gKHEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHggPSBxLng7XHJcbiAgICAgICAgdmFyIHkgPSBxLnk7XHJcbiAgICAgICAgdmFyIHogPSBxLno7XHJcbiAgICAgICAgdmFyIHcgPSBxLnc7XHJcblxyXG4gICAgICAgIHZhciB4MiA9IHggKyB4O1xyXG4gICAgICAgIHZhciB5MiA9IHkgKyB5O1xyXG4gICAgICAgIHZhciB6MiA9IHogKyB6O1xyXG5cclxuICAgICAgICB2YXIgeHggPSB4ICogeDI7XHJcbiAgICAgICAgdmFyIHh5ID0geCAqIHkyO1xyXG4gICAgICAgIHZhciB4eiA9IHggKiB6MjtcclxuXHJcbiAgICAgICAgdmFyIHl5ID0geSAqIHkyO1xyXG4gICAgICAgIHZhciB5eiA9IHkgKiB6MjtcclxuICAgICAgICB2YXIgenogPSB6ICogejI7XHJcblxyXG4gICAgICAgIHZhciB3eCA9IHcgKiB4MjtcclxuICAgICAgICB2YXIgd3kgPSB3ICogeTI7XHJcbiAgICAgICAgdmFyIHd6ID0gdyAqIHoyO1xyXG5cclxuICAgICAgICB2YXIgb3V0ID0gdGhpcy52YWw7XHJcblxyXG4gICAgICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XHJcbiAgICAgICAgb3V0WzNdID0geHkgKyB3ejtcclxuICAgICAgICBvdXRbNl0gPSB4eiAtIHd5O1xyXG5cclxuICAgICAgICBvdXRbMV0gPSB4eSAtIHd6O1xyXG4gICAgICAgIG91dFs0XSA9IDEgLSAoeHggKyB6eik7XHJcbiAgICAgICAgb3V0WzddID0geXogKyB3eDtcclxuXHJcbiAgICAgICAgb3V0WzJdID0geHogKyB3eTtcclxuICAgICAgICBvdXRbNV0gPSB5eiAtIHd4O1xyXG4gICAgICAgIG91dFs4XSA9IDEgLSAoeHggKyB5eSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBub3JtYWxGcm9tTWF0NDogZnVuY3Rpb24gKG0pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSBtLnZhbDtcclxuICAgICAgICB2YXIgb3V0ID0gdGhpcy52YWw7XHJcblxyXG4gICAgICAgIHZhciBhMDAgPSBhWzBdO1xyXG4gICAgICAgIHZhciBhMDEgPSBhWzFdO1xyXG4gICAgICAgIHZhciBhMDIgPSBhWzJdO1xyXG4gICAgICAgIHZhciBhMDMgPSBhWzNdO1xyXG5cclxuICAgICAgICB2YXIgYTEwID0gYVs0XTtcclxuICAgICAgICB2YXIgYTExID0gYVs1XTtcclxuICAgICAgICB2YXIgYTEyID0gYVs2XTtcclxuICAgICAgICB2YXIgYTEzID0gYVs3XTtcclxuXHJcbiAgICAgICAgdmFyIGEyMCA9IGFbOF07XHJcbiAgICAgICAgdmFyIGEyMSA9IGFbOV07XHJcbiAgICAgICAgdmFyIGEyMiA9IGFbMTBdO1xyXG4gICAgICAgIHZhciBhMjMgPSBhWzExXTtcclxuXHJcbiAgICAgICAgdmFyIGEzMCA9IGFbMTJdO1xyXG4gICAgICAgIHZhciBhMzEgPSBhWzEzXTtcclxuICAgICAgICB2YXIgYTMyID0gYVsxNF07XHJcbiAgICAgICAgdmFyIGEzMyA9IGFbMTVdO1xyXG5cclxuICAgICAgICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xyXG4gICAgICAgIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XHJcbiAgICAgICAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcclxuICAgICAgICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xyXG5cclxuICAgICAgICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xyXG4gICAgICAgIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XHJcbiAgICAgICAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcclxuICAgICAgICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xyXG5cclxuICAgICAgICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xyXG4gICAgICAgIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XHJcbiAgICAgICAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcclxuICAgICAgICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XHJcbiAgICAgICAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcclxuXHJcbiAgICAgICAgaWYgKCFkZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRldCA9IDEgLyBkZXQ7XHJcblxyXG4gICAgICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xyXG4gICAgICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xyXG4gICAgICAgIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xyXG5cclxuICAgICAgICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcclxuICAgICAgICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcclxuICAgICAgICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcclxuXHJcbiAgICAgICAgb3V0WzZdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XHJcbiAgICAgICAgb3V0WzddID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XHJcbiAgICAgICAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5NYXRyaXgzLnByb3RvdHlwZS5tdWwgPSBNYXRyaXgzLnByb3RvdHlwZS5tdWx0aXBseTtcclxuTWF0cml4My5wcm90b3R5cGUuaWR0ID0gTWF0cml4My5wcm90b3R5cGUuaWRlbnRpdHk7XHJcbk1hdHJpeDMucHJvdG90eXBlLnJlc2V0ID0gTWF0cml4My5wcm90b3R5cGUuaWRlbnRpdHk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1hdHJpeDM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9NYXRyaXgzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEFkYXB0ZWQgZnJvbSBbZ2wtbWF0cml4XShodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgpIGJ5IHRvamkgXHJcbi8vICBhbmQgW3ZlY21hdGhdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC92ZWNtYXRoKSBieSBtYXR0ZGVzbFxyXG5cclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIFZlY3RvcjMgPSByZXF1aXJlKCcuL1ZlY3RvcjMnKTtcclxudmFyIE1hdHJpeDMgPSByZXF1aXJlKCcuL01hdHJpeDMnKTtcclxuXHJcbnZhciBFUFNJTE9OID0gMC4wMDAwMDE7XHJcblxyXG4vLyAgU29tZSBzaGFyZWQgJ3ByaXZhdGUnIGFycmF5c1xyXG52YXIgc2lOZXh0ID0gbmV3IEludDhBcnJheShbIDEsIDIsIDAgXSk7XHJcbnZhciB0bXAgPSBuZXcgRmxvYXQzMkFycmF5KFsgMCwgMCwgMCBdKTtcclxuXHJcbnZhciB4VW5pdFZlYzMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKTtcclxudmFyIHlVbml0VmVjMyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApO1xyXG5cclxudmFyIHRtcHZlYyA9IG5ldyBWZWN0b3IzKCk7XHJcbnZhciB0bXBNYXQzID0gbmV3IE1hdHJpeDMoKTtcclxuXHJcbnZhciBRdWF0ZXJuaW9uID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFF1YXRlcm5pb24gKHgsIHksIHosIHcpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHgueCB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB4LnkgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy56ID0geC56IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IHgudyB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHkgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy56ID0geiB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLncgPSB3IHx8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAoc3JjKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IHNyYy54O1xyXG4gICAgICAgIHRoaXMueSA9IHNyYy55O1xyXG4gICAgICAgIHRoaXMueiA9IHNyYy56O1xyXG4gICAgICAgIHRoaXMudyA9IHNyYy53O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoeCwgeSwgeiwgdylcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geC54IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHgueSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnogPSB4LnogfHwgMDtcclxuICAgICAgICAgICAgdGhpcy53ID0geC53IHx8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHggfHwgMDtcclxuICAgICAgICAgICAgdGhpcy55ID0geSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnogPSB6IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IHcgfHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh2KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCArPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ICs9IHYueTtcclxuICAgICAgICB0aGlzLnogKz0gdi56O1xyXG4gICAgICAgIHRoaXMudyArPSB2Lnc7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKHYpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54IC09IHYueDtcclxuICAgICAgICB0aGlzLnkgLT0gdi55O1xyXG4gICAgICAgIHRoaXMueiAtPSB2Lno7XHJcbiAgICAgICAgdGhpcy53IC09IHYudztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlOiBmdW5jdGlvbiAoc2NhbGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ICo9IHNjYWxlO1xyXG4gICAgICAgIHRoaXMueSAqPSBzY2FsZTtcclxuICAgICAgICB0aGlzLnogKj0gc2NhbGU7XHJcbiAgICAgICAgdGhpcy53ICo9IHNjYWxlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciB6ID0gdGhpcy56O1xyXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3KTtcclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoU3E6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIHogPSB0aGlzLno7XHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLnc7XHJcblxyXG4gICAgICAgIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcclxuICAgIH0sXHJcblxyXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciB6ID0gdGhpcy56O1xyXG4gICAgICAgIHZhciB3ID0gdGhpcy53O1xyXG4gICAgICAgIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcclxuXHJcbiAgICAgICAgaWYgKGxlbiA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnggPSB4ICogbGVuO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5ICogbGVuO1xyXG4gICAgICAgICAgICB0aGlzLnogPSB6ICogbGVuO1xyXG4gICAgICAgICAgICB0aGlzLncgPSB3ICogbGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGRvdDogZnVuY3Rpb24gKHYpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYueiArIHRoaXMudyAqIHYudztcclxuICAgIH0sXHJcblxyXG4gICAgbGVycDogZnVuY3Rpb24gKHYsIHQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgeyB0ID0gMDsgfVxyXG5cclxuICAgICAgICB2YXIgYXggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIGF5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciBheiA9IHRoaXMuejtcclxuICAgICAgICB2YXIgYXcgPSB0aGlzLnc7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGF4ICsgdCAqICh2LnggLSBheCk7XHJcbiAgICAgICAgdGhpcy55ID0gYXkgKyB0ICogKHYueSAtIGF5KTtcclxuICAgICAgICB0aGlzLnogPSBheiArIHQgKiAodi56IC0gYXopO1xyXG4gICAgICAgIHRoaXMudyA9IGF3ICsgdCAqICh2LncgLSBhdyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGlvblRvOiBmdW5jdGlvbiAoYSwgYilcclxuICAgIHtcclxuICAgICAgICB2YXIgZG90ID0gYS54ICogYi54ICsgYS55ICogYi55ICsgYS56ICogYi56O1xyXG5cclxuICAgICAgICBpZiAoZG90IDwgLTAuOTk5OTk5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRtcHZlYy5jb3B5KHhVbml0VmVjMykuY3Jvc3MoYSkubGVuKCkgPCBFUFNJTE9OKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0bXB2ZWMuY29weSh5VW5pdFZlYzMpLmNyb3NzKGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0bXB2ZWMubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRBeGlzQW5nbGUodG1wdmVjLCBNYXRoLlBJKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy56ID0gMDtcclxuICAgICAgICAgICAgdGhpcy53ID0gMTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0bXB2ZWMuY29weShhKS5jcm9zcyhiKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMueCA9IHRtcHZlYy54O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB0bXB2ZWMueTtcclxuICAgICAgICAgICAgdGhpcy56ID0gdG1wdmVjLno7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IDEgKyBkb3Q7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEF4ZXM6IGZ1bmN0aW9uICh2aWV3LCByaWdodCwgdXApXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG0gPSB0bXBNYXQzLnZhbDtcclxuXHJcbiAgICAgICAgbVswXSA9IHJpZ2h0Lng7XHJcbiAgICAgICAgbVszXSA9IHJpZ2h0Lnk7XHJcbiAgICAgICAgbVs2XSA9IHJpZ2h0Lno7XHJcblxyXG4gICAgICAgIG1bMV0gPSB1cC54O1xyXG4gICAgICAgIG1bNF0gPSB1cC55O1xyXG4gICAgICAgIG1bN10gPSB1cC56O1xyXG5cclxuICAgICAgICBtWzJdID0gLXZpZXcueDtcclxuICAgICAgICBtWzVdID0gLXZpZXcueTtcclxuICAgICAgICBtWzhdID0gLXZpZXcuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbU1hdDModG1wTWF0Mykubm9ybWFsaXplKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlkZW50aXR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICB0aGlzLnogPSAwO1xyXG4gICAgICAgIHRoaXMudyA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBeGlzQW5nbGU6IGZ1bmN0aW9uIChheGlzLCByYWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmFkID0gcmFkICogMC41O1xyXG5cclxuICAgICAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHMgKiBheGlzLng7XHJcbiAgICAgICAgdGhpcy55ID0gcyAqIGF4aXMueTtcclxuICAgICAgICB0aGlzLnogPSBzICogYXhpcy56O1xyXG4gICAgICAgIHRoaXMudyA9IE1hdGguY29zKHJhZCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKGIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGF4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciBheSA9IHRoaXMueTtcclxuICAgICAgICB2YXIgYXogPSB0aGlzLno7XHJcbiAgICAgICAgdmFyIGF3ID0gdGhpcy53O1xyXG5cclxuICAgICAgICB2YXIgYnggPSBiLng7XHJcbiAgICAgICAgdmFyIGJ5ID0gYi55O1xyXG4gICAgICAgIHZhciBieiA9IGIuejtcclxuICAgICAgICB2YXIgYncgPSBiLnc7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XHJcbiAgICAgICAgdGhpcy55ID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcclxuICAgICAgICB0aGlzLnogPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xyXG4gICAgICAgIHRoaXMudyA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzbGVycDogZnVuY3Rpb24gKGIsIHQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcclxuXHJcbiAgICAgICAgdmFyIGF4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciBheSA9IHRoaXMueTtcclxuICAgICAgICB2YXIgYXogPSB0aGlzLno7XHJcbiAgICAgICAgdmFyIGF3ID0gdGhpcy53O1xyXG5cclxuICAgICAgICB2YXIgYnggPSBiLng7XHJcbiAgICAgICAgdmFyIGJ5ID0gYi55O1xyXG4gICAgICAgIHZhciBieiA9IGIuejtcclxuICAgICAgICB2YXIgYncgPSBiLnc7XHJcblxyXG4gICAgICAgIC8vIGNhbGMgY29zaW5lXHJcbiAgICAgICAgdmFyIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcclxuXHJcbiAgICAgICAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXHJcbiAgICAgICAgaWYgKGNvc29tIDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvc29tID0gLWNvc29tO1xyXG4gICAgICAgICAgICBieCA9IC0gYng7XHJcbiAgICAgICAgICAgIGJ5ID0gLSBieTtcclxuICAgICAgICAgICAgYnogPSAtIGJ6O1xyXG4gICAgICAgICAgICBidyA9IC0gYnc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlIFxyXG4gICAgICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cclxuICAgICAgICB2YXIgc2NhbGUwID0gMSAtIHQ7XHJcbiAgICAgICAgdmFyIHNjYWxlMSA9IHQ7XHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcclxuICAgICAgICBpZiAoKDEgLSBjb3NvbSkgPiBFUFNJTE9OKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXHJcbiAgICAgICAgICAgIHZhciBvbWVnYSA9IE1hdGguYWNvcyhjb3NvbSk7XHJcbiAgICAgICAgICAgIHZhciBzaW5vbSA9IE1hdGguc2luKG9tZWdhKTtcclxuXHJcbiAgICAgICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xyXG4gICAgICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXHJcbiAgICAgICAgdGhpcy54ID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcclxuICAgICAgICB0aGlzLnkgPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xyXG4gICAgICAgIHRoaXMueiA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XHJcbiAgICAgICAgdGhpcy53ID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGludmVydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYTAgPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIGExID0gdGhpcy55O1xyXG4gICAgICAgIHZhciBhMiA9IHRoaXMuejtcclxuICAgICAgICB2YXIgYTMgPSB0aGlzLnc7XHJcblxyXG4gICAgICAgIHZhciBkb3QgPSBhMCAqIGEwICsgYTEgKiBhMSArIGEyICogYTIgKyBhMyAqIGEzO1xyXG4gICAgICAgIHZhciBpbnZEb3QgPSAoZG90KSA/IDEgLyBkb3QgOiAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXHJcblxyXG4gICAgICAgIHRoaXMueCA9IC1hMCAqIGludkRvdDtcclxuICAgICAgICB0aGlzLnkgPSAtYTEgKiBpbnZEb3Q7XHJcbiAgICAgICAgdGhpcy56ID0gLWEyICogaW52RG90O1xyXG4gICAgICAgIHRoaXMudyA9IGEzICogaW52RG90O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY29uanVnYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IC10aGlzLng7XHJcbiAgICAgICAgdGhpcy55ID0gLXRoaXMueTtcclxuICAgICAgICB0aGlzLnogPSAtdGhpcy56O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRlWDogZnVuY3Rpb24gKHJhZClcclxuICAgIHtcclxuICAgICAgICByYWQgKj0gMC41O1xyXG5cclxuICAgICAgICB2YXIgYXggPSB0aGlzLng7XHJcbiAgICAgICAgdmFyIGF5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciBheiA9IHRoaXMuejtcclxuICAgICAgICB2YXIgYXcgPSB0aGlzLnc7XHJcblxyXG4gICAgICAgIHZhciBieCA9IE1hdGguc2luKHJhZCk7XHJcbiAgICAgICAgdmFyIGJ3ID0gTWF0aC5jb3MocmFkKTtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gYXggKiBidyArIGF3ICogYng7XHJcbiAgICAgICAgdGhpcy55ID0gYXkgKiBidyArIGF6ICogYng7XHJcbiAgICAgICAgdGhpcy56ID0gYXogKiBidyAtIGF5ICogYng7XHJcbiAgICAgICAgdGhpcy53ID0gYXcgKiBidyAtIGF4ICogYng7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVZOiBmdW5jdGlvbiAocmFkKVxyXG4gICAge1xyXG4gICAgICAgIHJhZCAqPSAwLjU7XHJcblxyXG4gICAgICAgIHZhciBheCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgYXkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIGF6ID0gdGhpcy56O1xyXG4gICAgICAgIHZhciBhdyA9IHRoaXMudztcclxuXHJcbiAgICAgICAgdmFyIGJ5ID0gTWF0aC5zaW4ocmFkKTtcclxuICAgICAgICB2YXIgYncgPSBNYXRoLmNvcyhyYWQpO1xyXG5cclxuICAgICAgICB0aGlzLnggPSBheCAqIGJ3IC0gYXogKiBieTtcclxuICAgICAgICB0aGlzLnkgPSBheSAqIGJ3ICsgYXcgKiBieTtcclxuICAgICAgICB0aGlzLnogPSBheiAqIGJ3ICsgYXggKiBieTtcclxuICAgICAgICB0aGlzLncgPSBhdyAqIGJ3IC0gYXkgKiBieTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZVo6IGZ1bmN0aW9uIChyYWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmFkICo9IDAuNTtcclxuXHJcbiAgICAgICAgdmFyIGF4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciBheSA9IHRoaXMueTtcclxuICAgICAgICB2YXIgYXogPSB0aGlzLno7XHJcbiAgICAgICAgdmFyIGF3ID0gdGhpcy53O1xyXG5cclxuICAgICAgICB2YXIgYnogPSBNYXRoLnNpbihyYWQpO1xyXG4gICAgICAgIHZhciBidyA9IE1hdGguY29zKHJhZCk7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IGF4ICogYncgKyBheSAqIGJ6O1xyXG4gICAgICAgIHRoaXMueSA9IGF5ICogYncgLSBheCAqIGJ6O1xyXG4gICAgICAgIHRoaXMueiA9IGF6ICogYncgKyBhdyAqIGJ6O1xyXG4gICAgICAgIHRoaXMudyA9IGF3ICogYncgLSBheiAqIGJ6O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2FsY3VsYXRlVzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuICAgICAgICB2YXIgeiA9IHRoaXMuejtcclxuXHJcbiAgICAgICAgdGhpcy53ID0gLU1hdGguc3FydChNYXRoLmFicygxLjAgLSB4ICogeCAtIHkgKiB5IC0geiAqIHopKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGZyb21NYXQzOiBmdW5jdGlvbiAobWF0KVxyXG4gICAge1xyXG4gICAgICAgIC8vIGJlbmNobWFya3M6XHJcbiAgICAgICAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vdHlwZWQtYXJyYXktYWNjZXNzLXNwZWVkXHJcbiAgICAgICAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vY29udmVyc2lvbi1vZi0zeDMtbWF0cml4LXRvLXF1YXRlcm5pb25cclxuXHJcbiAgICAgICAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcclxuICAgICAgICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cclxuICAgICAgICB2YXIgbSA9IG1hdC52YWw7XHJcbiAgICAgICAgdmFyIGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcclxuICAgICAgICB2YXIgZlJvb3Q7XHJcblxyXG4gICAgICAgIGlmIChmVHJhY2UgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxyXG4gICAgICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAvLyAyd1xyXG5cclxuICAgICAgICAgICAgdGhpcy53ID0gMC41ICogZlJvb3Q7XHJcblxyXG4gICAgICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290OyAvLyAxLyg0dylcclxuXHJcbiAgICAgICAgICAgIHRoaXMueCA9IChtWzddIC0gbVs1XSkgKiBmUm9vdDtcclxuICAgICAgICAgICAgdGhpcy55ID0gKG1bMl0gLSBtWzZdKSAqIGZSb290O1xyXG4gICAgICAgICAgICB0aGlzLnogPSAobVszXSAtIG1bMV0pICogZlJvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIHx3fCA8PSAxLzJcclxuICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1bNF0gPiBtWzBdKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpID0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG1bOF0gPiBtW2kgKiAzICsgaV0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGkgPSAyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaiA9IHNpTmV4dFtpXTtcclxuICAgICAgICAgICAgdmFyIGsgPSBzaU5leHRbal07XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gIFRoaXMgaXNuJ3QgcXVpdGUgYXMgY2xlYW4gd2l0aG91dCBhcnJheSBhY2Nlc3NcclxuICAgICAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpICogMyArIGldIC0gbVtqICogMyArIGpdIC0gbVtrICogMyArIGtdICsgMSk7XHJcbiAgICAgICAgICAgIHRtcFtpXSA9IDAuNSAqIGZSb290O1xyXG5cclxuICAgICAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcclxuXHJcbiAgICAgICAgICAgIHRtcFtqXSA9IChtW2ogKiAzICsgaV0gKyBtW2kgKiAzICsgal0pICogZlJvb3Q7XHJcbiAgICAgICAgICAgIHRtcFtrXSA9IChtW2sgKiAzICsgaV0gKyBtW2kgKiAzICsga10pICogZlJvb3Q7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnggPSB0bXBbMF07XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRtcFsxXTtcclxuICAgICAgICAgICAgdGhpcy56ID0gdG1wWzJdO1xyXG4gICAgICAgICAgICB0aGlzLncgPSAobVtrICogMyArIGpdIC0gbVtqICogMyArIGtdKSAqIGZSb290O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuUXVhdGVybmlvbi5wcm90b3R5cGUuaWR0ID0gUXVhdGVybmlvbi5wcm90b3R5cGUuaWRlbnRpdHk7XHJcblF1YXRlcm5pb24ucHJvdG90eXBlLnN1YiA9IFF1YXRlcm5pb24ucHJvdG90eXBlLnN1YnRyYWN0O1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5tdWwgPSBRdWF0ZXJuaW9uLnByb3RvdHlwZS5tdWx0aXBseTtcclxuUXVhdGVybmlvbi5wcm90b3R5cGUubGVuID0gUXVhdGVybmlvbi5wcm90b3R5cGUubGVuZ3RoO1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5sZW5TcSA9IFF1YXRlcm5pb24ucHJvdG90eXBlLmxlbmd0aFNxO1xyXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5yZXNldCA9IFF1YXRlcm5pb24ucHJvdG90eXBlLmlkdDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUXVhdGVybmlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL1F1YXRlcm5pb24uanNcbi8vIG1vZHVsZSBpZCA9IDIwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUG9zaXRpb24gVmVjdG9yIHJhbmRvbWx5IGluIGEgc3BoZXJpY2FsIGFyZWEgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gcmFkaXVzXHJcbnZhciBSYW5kb21YWVogPSBmdW5jdGlvbiAodmVjdG9yLCByYWRpdXMpXHJcbntcclxuICAgIGlmIChyYWRpdXMgPT09IHVuZGVmaW5lZCkgeyByYWRpdXMgPSAxOyB9XHJcblxyXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XHJcbiAgICB2YXIgeiA9IChNYXRoLnJhbmRvbSgpICogMikgLSAxO1xyXG4gICAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxIC0geiAqIHopICogcmFkaXVzO1xyXG4gICAgXHJcbiAgICB2ZWN0b3IueCA9IE1hdGguY29zKHIpICogelNjYWxlO1xyXG4gICAgdmVjdG9yLnkgPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcclxuICAgIHZlY3Rvci56ID0geiAqIHJhZGl1cztcclxuXHJcbiAgICByZXR1cm4gdmVjdG9yO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21YWVo7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9SYW5kb21YWVouanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmFuZG9tWFlaVyA9IGZ1bmN0aW9uICh2ZWN0b3IsIHNjYWxlKVxyXG57XHJcbiAgICBpZiAoc2NhbGUgPT09IHVuZGVmaW5lZCkgeyBzY2FsZSA9IDE7IH1cclxuXHJcbiAgICAvLyBOb3Qgc3BoZXJpY2FsOyBzaG91bGQgZml4IHRoaXMgZm9yIG1vcmUgdW5pZm9ybSBkaXN0cmlidXRpb25cclxuICAgIHZlY3Rvci54ID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBzY2FsZTtcclxuICAgIHZlY3Rvci55ID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBzY2FsZTtcclxuICAgIHZlY3Rvci56ID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBzY2FsZTtcclxuICAgIHZlY3Rvci53ID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBzY2FsZTtcclxuXHJcbiAgICByZXR1cm4gdmVjdG9yO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21YWVpXO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvUmFuZG9tWFlaVy5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBWZWN0b3IzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWN0b3IzJyk7XHJcbnZhciBNYXRyaXg0ID0gcmVxdWlyZSgnLi4vbWF0aC9NYXRyaXg0Jyk7XHJcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XHJcblxyXG52YXIgdG1wTWF0NCA9IG5ldyBNYXRyaXg0KCk7XHJcbnZhciB0bXBRdWF0ID0gbmV3IFF1YXRlcm5pb24oKTtcclxudmFyIHRtcFZlYzMgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSB2ZWN0b3IgaW4gcGxhY2UgYnkgYXhpcyBhbmdsZS5cclxuICpcclxuICogVGhpcyBpcyB0aGUgc2FtZSBhcyB0cmFuc2Zvcm1pbmcgYSBwb2ludCBieSBhbiBcclxuICogYXhpcy1hbmdsZSBxdWF0ZXJuaW9uLCBidXQgaXQgaGFzIGhpZ2hlciBwcmVjaXNpb24uXHJcbiAqIFxyXG4gKiBAcGFyYW0gIHtWZWN0b3IzfSB2ZWMgICAgIFtkZXNjcmlwdGlvbl1cclxuICogQHBhcmFtICB7VmVjdG9yM30gYXhpcyAgICBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSAge2Zsb2F0fSByYWRpYW5zIFtkZXNjcmlwdGlvbl1cclxuICogQHJldHVybiB7VmVjdG9yM30gICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAqL1xyXG52YXIgUm90YXRlVmVjMyA9IGZ1bmN0aW9uKHZlYywgYXhpcywgcmFkaWFucylcclxue1xyXG4gICAgLy8gIFNldCB0aGUgcXVhdGVybmlvbiB0byBvdXIgYXhpcyBhbmdsZVxyXG4gICAgdG1wUXVhdC5zZXRBeGlzQW5nbGUoYXhpcywgcmFkaWFucyk7XHJcblxyXG4gICAgLy8gIENyZWF0ZSBhIHJvdGF0aW9uIG1hdHJpeCBmcm9tIHRoZSBheGlzIGFuZ2xlXHJcbiAgICB0bXBNYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKHRtcFF1YXQsIHRtcFZlYzMuc2V0KDAsIDAsIDApKTtcclxuXHJcbiAgICAvLyAgTXVsdGlwbHkgb3VyIHZlY3RvciBieSB0aGUgcm90YXRpb24gbWF0cml4XHJcbiAgICByZXR1cm4gdmVjLnRyYW5zZm9ybU1hdDQodG1wTWF0NCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZVZlYzM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9Sb3RhdGVWZWMzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJvdW5kQXdheUZyb21aZXJvID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICAvLyBcIk9wcG9zaXRlXCIgb2YgdHJ1bmNhdGUuXHJcbiAgICByZXR1cm4gKHZhbHVlID4gMCkgPyBNYXRoLmNlaWwodmFsdWUpIDogTWF0aC5mbG9vcih2YWx1ZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kQXdheUZyb21aZXJvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvUm91bmRBd2F5RnJvbVplcm8uanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU21vb3RoU3RlcCA9IGZ1bmN0aW9uICh4LCBtaW4sIG1heClcclxue1xyXG4gICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gbWluKSAvIChtYXggLSBtaW4pKSk7XHJcblxyXG4gICAgcmV0dXJuIHggKiB4ICogKDMgLSAyICogeCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNtb290aFN0ZXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9TbW9vdGhTdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNtb290aGVyU3RlcCA9IGZ1bmN0aW9uICh4LCBtaW4sIG1heClcclxue1xyXG4gICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gbWluKSAvIChtYXggLSBtaW4pKSk7XHJcblxyXG4gICAgcmV0dXJuIHggKiB4ICogeCAqICh4ICogKHggKiA2IC0gMTUpICsgMTApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbW9vdGhlclN0ZXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9TbW9vdGhlclN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDIwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTm9ybWFsaXplID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICBhbmdsZSA9IGFuZ2xlICUgKDIgKiBNYXRoLlBJKTtcclxuXHJcbiAgICBpZiAoYW5nbGUgPj0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlICsgMiAqIE1hdGguUEk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbGl6ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2FuZ2xlL05vcm1hbGl6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXRoV3JhcCA9IHJlcXVpcmUoJy4uL1dyYXAnKTtcclxuXHJcbnZhciBXcmFwID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aFdyYXAoYW5nbGUsIC1NYXRoLlBJLCBNYXRoLlBJKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV3JhcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2FuZ2xlL1dyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgV3JhcCA9IHJlcXVpcmUoJy4uL1dyYXAnKTtcclxuXHJcbnZhciBXcmFwRGVncmVlcyA9IGZ1bmN0aW9uIChhbmdsZSlcclxue1xyXG4gICAgcmV0dXJuIFdyYXAoYW5nbGUsIC0xODAsIDE4MCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXBEZWdyZWVzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodiwgb3ZlcnNob290KVxyXG57XHJcbiAgICBpZiAob3ZlcnNob290ID09PSB1bmRlZmluZWQpIHsgb3ZlcnNob290ID0gMS43MDE1ODsgfVxyXG5cclxuICAgIHJldHVybiB2ICogdiAqICgob3ZlcnNob290ICsgMSkgKiB2IC0gb3ZlcnNob290KTtcclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2LCBvdmVyc2hvb3QpXHJcbntcclxuICAgIGlmIChvdmVyc2hvb3QgPT09IHVuZGVmaW5lZCkgeyBvdmVyc2hvb3QgPSAxLjcwMTU4OyB9XHJcblxyXG4gICAgcmV0dXJuIC0tdiAqIHYgKiAoKG92ZXJzaG9vdCArIDEpICogdiArIG92ZXJzaG9vdCkgKyAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodiwgb3ZlcnNob290KVxyXG57XHJcbiAgICBpZiAob3ZlcnNob290ID09PSB1bmRlZmluZWQpIHsgb3ZlcnNob290ID0gMS43MDE1ODsgfVxyXG5cclxuICAgIHZhciBzID0gb3ZlcnNob290ICogMS41MjU7XHJcblxyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogKHYgKiB2ICogKChzICsgMSkgKiB2IC0gcykpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiAoKHYgLT0gMikgKiB2ICogKChzICsgMSkgKiB2ICsgcykgKyAyKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9lYXNpbmcvQmFjay5qc1xuLy8gbW9kdWxlIGlkID0gMjEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICB2ID0gMSAtIHY7XHJcblxyXG4gICAgaWYgKHYgPCAxIC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiB2ICogdik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2IDwgMiAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSAoNy41NjI1ICogKHYgLT0gMS41IC8gMi43NSkgKiB2ICsgMC43NSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2IDwgMi41IC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiAodiAtPSAyLjI1IC8gMi43NSkgKiB2ICsgMC45Mzc1KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiAodiAtPSAyLjYyNSAvIDIuNzUpICogdiArIDAuOTg0Mzc1KTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICBpZiAodiA8IDEgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiA3LjU2MjUgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPCAyIC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gNy41NjI1ICogKHYgLT0gMS41IC8gMi43NSkgKiB2ICsgMC43NTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPCAyLjUgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiA3LjU2MjUgKiAodiAtPSAyLjI1IC8gMi43NSkgKiB2ICsgMC45Mzc1O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiA3LjU2MjUgKiAodiAtPSAyLjYyNSAvIDIuNzUpICogdiArIDAuOTg0Mzc1O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgdmFyIHJldmVyc2UgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAodiA8IDAuNSlcclxuICAgIHtcclxuICAgICAgICB2ID0gMSAtICh2ICogMik7XHJcbiAgICAgICAgcmV2ZXJzZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdiA9ICh2ICogMikgLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2IDwgMSAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgdiA9IDcuNTYyNSAqIHYgKiB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA8IDIgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHYgPSA3LjU2MjUgKiAodiAtPSAxLjUgLyAyLjc1KSAqIHYgKyAwLjc1O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA8IDIuNSAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgdiA9IDcuNTYyNSAqICh2IC09IDIuMjUgLyAyLjc1KSAqIHYgKyAwLjkzNzU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdiA9IDcuNTYyNSAqICh2IC09IDIuNjI1IC8gMi43NSkgKiB2ICsgMC45ODQzNzU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJldmVyc2UpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICgxIC0gdikgKiAwLjU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHYgKiAwLjUgKyAwLjU7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZWFzaW5nL0JvdW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdiAqIHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLXYgKiB2KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdiAqIHYpIC0gMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh2IC09IDIpICogdikgKyAxKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9lYXNpbmcvQ2lyY3VsYXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgcmV0dXJuIHYgKiB2ICogdjtcclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICByZXR1cm4gLS12ICogdiAqIHYgKyAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogdiAqIHYgKiB2O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiAoKHYgLT0gMikgKiB2ICogdiArIDIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Vhc2luZy9DdWJpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2LCBhbXBsaXR1ZGUsIHBlcmlvZClcclxue1xyXG4gICAgaWYgKGFtcGxpdHVkZSA9PT0gdW5kZWZpbmVkKSB7IGFtcGxpdHVkZSA9IDAuMTsgfVxyXG4gICAgaWYgKHBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7IHBlcmlvZCA9IDAuMTsgfVxyXG5cclxuICAgIGlmICh2ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgcyA9IHBlcmlvZCAvIDQ7XHJcblxyXG4gICAgICAgIGlmIChhbXBsaXR1ZGUgPCAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYW1wbGl0dWRlID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcyA9IHBlcmlvZCAqIE1hdGguYXNpbigxIC8gYW1wbGl0dWRlKSAvICgyICogTWF0aC5QSSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLShhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAxMCAqICh2IC09IDEpKSAqIE1hdGguc2luKCh2IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcGVyaW9kKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodiwgYW1wbGl0dWRlLCBwZXJpb2QpXHJcbntcclxuICAgIGlmIChhbXBsaXR1ZGUgPT09IHVuZGVmaW5lZCkgeyBhbXBsaXR1ZGUgPSAwLjE7IH1cclxuICAgIGlmIChwZXJpb2QgPT09IHVuZGVmaW5lZCkgeyBwZXJpb2QgPSAwLjE7IH1cclxuXHJcbiAgICBpZiAodiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHMgPSBwZXJpb2QgLyA0O1xyXG5cclxuICAgICAgICBpZiAoYW1wbGl0dWRlIDwgMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFtcGxpdHVkZSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHMgPSBwZXJpb2QgKiBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSkgLyAoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAtMTAgKiB2KSAqIE1hdGguc2luKCh2IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcGVyaW9kKSArIDEpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodiwgYW1wbGl0dWRlLCBwZXJpb2QpXHJcbntcclxuICAgIGlmIChhbXBsaXR1ZGUgPT09IHVuZGVmaW5lZCkgeyBhbXBsaXR1ZGUgPSAwLjE7IH1cclxuICAgIGlmIChwZXJpb2QgPT09IHVuZGVmaW5lZCkgeyBwZXJpb2QgPSAwLjE7IH1cclxuXHJcbiAgICBpZiAodiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHMgPSBwZXJpb2QgLyA0O1xyXG5cclxuICAgICAgICBpZiAoYW1wbGl0dWRlIDwgMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFtcGxpdHVkZSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHMgPSBwZXJpb2QgKiBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSkgLyAoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIDEwICogKHYgLT0gMSkpICogTWF0aC5zaW4oKHYgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwZXJpb2QpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIC0xMCAqICh2IC09IDEpKSAqIE1hdGguc2luKCh2IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcGVyaW9kKSAqIDAuNSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Vhc2luZy9FbGFzdGljLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqICh2IC0gMSkpIC0gMC4wMDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiB2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIDEwICogKHYgLSAxKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHYgLSAxKSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Vhc2luZy9FeHBvLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogTGluZWFyIEVhc2luZyAobm8gdmFyaWF0aW9uKS5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuRWFzaW5nLkxpbmVhciNOb25lXHJcbiogQHBhcmFtIHtudW1iZXJ9IHYgLSBUaGUgdmFsdWUgdG8gYmUgdHdlZW5lZC5cclxuKiBAcmV0dXJucyB7bnVtYmVyfSB2LlxyXG4qL1xyXG52YXIgTGluZWFyID0gZnVuY3Rpb24gKHYpXHJcbntcclxuICAgIHJldHVybiB2O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lYXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9lYXNpbmcvTGluZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHJldHVybiB2ICogdjtcclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICByZXR1cm4gdiAqICgyIC0gdik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gLTAuNSAqICgtLXYgKiAodiAtIDIpIC0gMSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZWFzaW5nL1F1YWRyYXRpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gdiAqIHYgKiB2ICogdjtcclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICByZXR1cm4gMSAtICgtLXYgKiB2ICogdiAqIHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogdiAqIHYgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gLTAuNSAqICgodiAtPSAyKSAqIHYgKiB2ICogdiAtIDIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Vhc2luZy9RdWFydGljLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHJldHVybiB2ICogdiAqIHYgKiB2ICogdjtcclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICByZXR1cm4gLS12ICogdiAqIHYgKiB2ICogdiArIDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiB2ICogdiAqIHYgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogKCh2IC09IDIpICogdiAqIHYgKiB2ICogdiArIDIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Vhc2luZy9RdWludGljLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIGlmICh2ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKHYgKiBNYXRoLlBJIC8gMik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgaWYgKHYgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNpbih2ICogTWF0aC5QSSAvIDIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKHYgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiB2KSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZWFzaW5nL1NpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBCYWNrOiByZXF1aXJlKCcuL0JhY2snKSxcclxuICAgIEJvdW5jZTogcmVxdWlyZSgnLi9Cb3VuY2UnKSxcclxuICAgIENpcmN1bGFyOiByZXF1aXJlKCcuL0NpcmN1bGFyJyksXHJcbiAgICBDdWJpYzogcmVxdWlyZSgnLi9DdWJpYycpLFxyXG4gICAgRWxhc3RpYzogcmVxdWlyZSgnLi9FbGFzdGljJyksXHJcbiAgICBFeHBvOiByZXF1aXJlKCcuL0V4cG8nKSxcclxuICAgIExpbmVhcjogcmVxdWlyZSgnLi9MaW5lYXInKSxcclxuICAgIFF1YWRyYXRpYzogcmVxdWlyZSgnLi9RdWFkcmF0aWMnKSxcclxuICAgIFF1YXJ0aWM6IHJlcXVpcmUoJy4vUXVhcnRpYycpLFxyXG4gICAgUXVpbnRpYzogcmVxdWlyZSgnLi9RdWludGljJyksXHJcbiAgICBTaW5lOiByZXF1aXJlKCcuL1NpbmUnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Vhc2luZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIFAwICh0LCBwKVxyXG57XHJcbiAgICB2YXIgayA9IDEgLSB0O1xyXG5cclxuICAgIHJldHVybiBrICogayAqIGsgKiBwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBQMSAodCwgcClcclxue1xyXG4gICAgdmFyIGsgPSAxIC0gdDtcclxuXHJcbiAgICByZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFAyICh0LCBwKVxyXG57XHJcbiAgICByZXR1cm4gMyAqICggMSAtIHQgKSAqIHQgKiB0ICogcDtcclxufVxyXG5cclxuZnVuY3Rpb24gUDMgKHQsIHApXHJcbntcclxuICAgIHJldHVybiB0ICogdCAqIHQgKiBwO1xyXG59XHJcblxyXG4vLyAgcDAgPSBzdGFydCBwb2ludFxyXG4vLyAgcDEgPSBjb250cm9sIHBvaW50IDFcclxuLy8gIHAyID0gY29udHJvbCBwb2ludCAyXHJcbi8vICBwMyA9IGVuZCBwb2ludFxyXG5cclxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BhZHJpYW5fY29vbmV5L2Jlemllci1pbnRlcnBvbGF0aW9uLTEzYjY4NTYzMzEzYVxyXG5cclxudmFyIEN1YmljQmV6aWVySW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh0LCBwMCwgcDEsIHAyLCBwMylcclxue1xyXG4gICAgcmV0dXJuIFAwKHQsIHAwKSArIFAxKHQsIHAxKSArIFAyKHQsIHAyKSArIFAzKHQsIHAzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3ViaWNCZXppZXJJbnRlcnBvbGF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvaW50ZXJwb2xhdGlvbi9DdWJpY0JlemllckludGVycG9sYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGluZWFyID0gcmVxdWlyZSgnLi4vTGluZWFyJyk7XHJcblxyXG52YXIgTGluZWFySW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2LCBrKVxyXG57XHJcbiAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcclxuICAgIHZhciBmID0gbSAqIGs7XHJcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XHJcblxyXG4gICAgaWYgKGsgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBMaW5lYXIodlswXSwgdlsxXSwgZik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGsgPiAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBMaW5lYXIodlttXSwgdlttIC0gMV0sIG0gLSBmKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTGluZWFyKHZbaV0sIHZbKGkgKyAxID4gbSkgPyBtIDogaSArIDFdLCBmIC0gaSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhckludGVycG9sYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9pbnRlcnBvbGF0aW9uL0xpbmVhckludGVycG9sYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgVGFrZXMgdmFsdWUgYW5kIHJldHVybnMgdGhlIG5lYXJlc3QgcG93ZXIgb2YgMlxyXG5cclxudmFyIEdldFBvd2VyT2ZUd28gPSBmdW5jdGlvbiAodmFsdWUpXHJcbntcclxuICAgIC8vICBNYXRoLmxvZygyKVxyXG4gICAgdmFyIGluZGV4ID0gTWF0aC5sb2codmFsdWUpIC8gMC42OTMxNDcxODA1NTk5NDUzO1xyXG5cclxuICAgIHJldHVybiAoMSA8PCBNYXRoLmNlaWwoaW5kZXgpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UG93ZXJPZlR3bztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL3BvdzIvR2V0UG93ZXJPZlR3by5qc1xuLy8gbW9kdWxlIGlkID0gMjI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcblxyXG52YXIgUmFuZG9tRGF0YUdlbmVyYXRvciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBSYW5kb21EYXRhR2VuZXJhdG9yIChzZWVkcylcclxuICAgIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjIC0gSW50ZXJuYWwgdmFyLlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYyA9IDE7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHMwIC0gSW50ZXJuYWwgdmFyLlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuczAgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzMSAtIEludGVybmFsIHZhci5cclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnMxID0gMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gczIgLSBJbnRlcm5hbCB2YXIuXHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zMiA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gc2lnbiAtIEludGVybmFsIHZhci5cclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNpZ24gPSBbIC0xLCAxIF07XHJcblxyXG4gICAgICAgIGlmIChzZWVkcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdChzZWVkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUHJpdmF0ZSByYW5kb20gaGVscGVyLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3JuZFxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAqL1xyXG4gICAgcm5kOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ID0gMjA5MTYzOSAqIHRoaXMuczAgKyB0aGlzLmMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxyXG5cclxuICAgICAgICB0aGlzLmMgPSB0IHwgMDtcclxuICAgICAgICB0aGlzLnMwID0gdGhpcy5zMTtcclxuICAgICAgICB0aGlzLnMxID0gdGhpcy5zMjtcclxuICAgICAgICB0aGlzLnMyID0gdCAtIHRoaXMuYztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuczI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBJbnRlcm5hbCBtZXRob2QgdGhhdCBjcmVhdGVzIGEgc2VlZCBoYXNoLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2hhc2hcclxuICAgICogQHByaXZhdGVcclxuICAgICogQHBhcmFtIHthbnl9IGRhdGFcclxuICAgICogQHJldHVybiB7bnVtYmVyfSBoYXNoZWQgdmFsdWUuXHJcbiAgICAqL1xyXG4gICAgaGFzaDogZnVuY3Rpb24gKGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgdmFyIG4gPSAweGVmYzgyNDlkO1xyXG5cclxuICAgICAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuICs9IGRhdGEuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xyXG4gICAgICAgICAgICBuID0gaCA+Pj4gMDtcclxuICAgICAgICAgICAgaCAtPSBuO1xyXG4gICAgICAgICAgICBoICo9IG47XHJcbiAgICAgICAgICAgIG4gPSBoID4+PiAwO1xyXG4gICAgICAgICAgICBoIC09IG47XHJcbiAgICAgICAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOy8vIDJeMzJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOy8vIDJeLTMyXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChzZWVkcylcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNlZWRzID09PSAnc3RyaW5nJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUoc2VlZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNvdyhzZWVkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmVzZXQgdGhlIHNlZWQgb2YgdGhlIHJhbmRvbSBkYXRhIGdlbmVyYXRvci5cclxuICAgICpcclxuICAgICogX05vdGVfOiB0aGUgc2VlZCBhcnJheSBpcyBvbmx5IHByb2Nlc3NlZCB1cCB0byB0aGUgZmlyc3QgYHVuZGVmaW5lZGAgKG9yIGBudWxsYCkgdmFsdWUsIHNob3VsZCBzdWNoIGJlIHByZXNlbnQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijc293XHJcbiAgICAqIEBwYXJhbSB7YW55W119IHNlZWRzIC0gVGhlIGFycmF5IG9mIHNlZWRzOiB0aGUgYHRvU3RyaW5nKClgIG9mIGVhY2ggdmFsdWUgaXMgdXNlZC5cclxuICAgICovXHJcbiAgICBzb3c6IGZ1bmN0aW9uIChzZWVkcylcclxuICAgIHtcclxuICAgICAgICAvLyBBbHdheXMgcmVzZXQgdG8gZGVmYXVsdCBzZWVkXHJcbiAgICAgICAgdGhpcy5zMCA9IHRoaXMuaGFzaCgnICcpO1xyXG4gICAgICAgIHRoaXMuczEgPSB0aGlzLmhhc2godGhpcy5zMCk7XHJcbiAgICAgICAgdGhpcy5zMiA9IHRoaXMuaGFzaCh0aGlzLnMxKTtcclxuICAgICAgICB0aGlzLmMgPSAxO1xyXG5cclxuICAgICAgICBpZiAoIXNlZWRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgYW55IHNlZWRzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWVkcy5sZW5ndGggJiYgKHNlZWRzW2ldICE9IG51bGwpOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc2VlZCA9IHNlZWRzW2ldO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zMCAtPSB0aGlzLmhhc2goc2VlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuczAgKz0gfn4odGhpcy5zMCA8IDApO1xyXG4gICAgICAgICAgICB0aGlzLnMxIC09IHRoaXMuaGFzaChzZWVkKTtcclxuICAgICAgICAgICAgdGhpcy5zMSArPSB+fih0aGlzLnMxIDwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuczIgLT0gdGhpcy5oYXNoKHNlZWQpO1xyXG4gICAgICAgICAgICB0aGlzLnMyICs9IH5+KHRoaXMuczIgPCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiAwIGFuZCAyXjMyLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2ludGVnZXJcclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMl4zMi5cclxuICAgICovXHJcbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIDJeMzJcclxuICAgICAgICByZXR1cm4gdGhpcy5ybmQoKSAqIDB4MTAwMDAwMDAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjZnJhY1xyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICovXHJcbiAgICBmcmFjOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIDJeLTUzXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm5kKCkgKyAodGhpcy5ybmQoKSAqIDB4MjAwMDAwIHwgMCkgKiAxLjExMDIyMzAyNDYyNTE1NjVlLTE2O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIDAgYW5kIDJeMzIuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjcmVhbFxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMl4zMi5cclxuICAgICovXHJcbiAgICByZWFsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoKSArIHRoaXMuZnJhYygpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gYW5kIGluY2x1ZGluZyBtaW4gYW5kIG1heC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNpbnRlZ2VySW5SYW5nZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxyXG4gICAgKi9cclxuICAgIGludGVnZXJJblJhbmdlOiBmdW5jdGlvbiAobWluLCBtYXgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5yZWFsSW5SYW5nZSgwLCBtYXggLSBtaW4gKyAxKSArIG1pbik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBhbmQgaW5jbHVkaW5nIG1pbiBhbmQgbWF4LlxyXG4gICAgKiBUaGlzIG1ldGhvZCBpcyBhbiBhbGlhcyBmb3IgUmFuZG9tRGF0YUdlbmVyYXRvci5pbnRlZ2VySW5SYW5nZS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNiZXR3ZWVuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXguXHJcbiAgICAqL1xyXG4gICAgYmV0d2VlbjogZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXJJblJhbmdlKG1pbiwgbWF4KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNyZWFsSW5SYW5nZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxyXG4gICAgKi9cclxuICAgIHJlYWxJblJhbmdlOiBmdW5jdGlvbiAobWluLCBtYXgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhYygpICogKG1heCAtIG1pbikgKyBtaW47XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gLTEgYW5kIDEuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijbm9ybWFsXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAtMSBhbmQgMS5cclxuICAgICovXHJcbiAgICBub3JtYWw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSAoMiAqIHRoaXMuZnJhYygpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSB2YWxpZCBSRkM0MTIyIHZlcnNpb240IElEIGhleCBzdHJpbmcgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMzA4MzY4XHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjdXVpZFxyXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgdmFsaWQgUkZDNDEyMiB2ZXJzaW9uNCBJRCBoZXggc3RyaW5nXHJcbiAgICAqL1xyXG4gICAgdXVpZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9ICcnO1xyXG4gICAgICAgIHZhciBiID0gJyc7XHJcblxyXG4gICAgICAgIGZvciAoYiA9IGEgPSAnJzsgYSsrIDwgMzY7IGIgKz1+YSAlIDUgfCBhKjMgJiA0ID8gKGFeMTUgPyA4IF4gdGhpcy5mcmFjKCkqKGFeMjAgPyAxNiA6IDQpIDogNCkudG9TdHJpbmcoMTYpIDogJy0nKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBiO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBtZW1iZXIgb2YgYGFycmF5YC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNwaWNrXHJcbiAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gQW4gQXJyYXkgdG8gcGljayBhIHJhbmRvbSBtZW1iZXIgb2YuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gQSByYW5kb20gbWVtYmVyIG9mIHRoZSBhcnJheS5cclxuICAgICovXHJcbiAgICBwaWNrOiBmdW5jdGlvbiAoYXJyYXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5W3RoaXMuaW50ZWdlckluUmFuZ2UoMCwgYXJyYXkubGVuZ3RoIC0gMSldO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHNpZ24gdG8gYmUgdXNlZCB3aXRoIG11bHRpcGxpY2F0aW9uIG9wZXJhdG9yLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3NpZ25cclxuICAgICogQHJldHVybiB7bnVtYmVyfSAtMSBvciArMS5cclxuICAgICovXHJcbiAgICBzaWduOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpY2sodGhpcy5zaWduKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gbWVtYmVyIG9mIGBhcnJheWAsIGZhdm9yaW5nIHRoZSBlYXJsaWVyIGVudHJpZXMuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijd2VpZ2h0ZWRQaWNrXHJcbiAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gQW4gQXJyYXkgdG8gcGljayBhIHJhbmRvbSBtZW1iZXIgb2YuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gQSByYW5kb20gbWVtYmVyIG9mIHRoZSBhcnJheS5cclxuICAgICovXHJcbiAgICB3ZWlnaHRlZFBpY2s6IGZ1bmN0aW9uIChhcnJheSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlbfn4oTWF0aC5wb3codGhpcy5mcmFjKCksIDIpICogKGFycmF5Lmxlbmd0aCAtIDEpICsgMC41KV07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHRpbWVzdGFtcCBiZXR3ZWVuIG1pbiBhbmQgbWF4LCBvciBiZXR3ZWVuIHRoZSBiZWdpbm5pbmcgb2YgMjAwMCBhbmQgdGhlIGVuZCBvZiAyMDIwIGlmIG1pbiBhbmQgbWF4IGFyZW4ndCBzcGVjaWZpZWQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjdGltZXN0YW1wXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gdGltZXN0YW1wIGJldHdlZW4gbWluIGFuZCBtYXguXHJcbiAgICAqL1xyXG4gICAgdGltZXN0YW1wOiBmdW5jdGlvbiAobWluLCBtYXgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbEluUmFuZ2UobWluIHx8IDk0NjY4NDgwMDAwMCwgbWF4IHx8IDE1Nzc4NjIwMDAwMDApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBhbmdsZSBiZXR3ZWVuIC0xODAgYW5kIDE4MC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNhbmdsZVxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIC0xODAgYW5kIDE4MC5cclxuICAgICovXHJcbiAgICBhbmdsZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VySW5SYW5nZSgtMTgwLCAxODApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSByb3RhdGlvbiBpbiByYWRpYW5zLCBiZXR3ZWVuIC0zLjE0MSBhbmQgMy4xNDFcclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNyb3RhdGlvblxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIC0zLjE0MSBhbmQgMy4xNDFcclxuICAgICovXHJcbiAgICByb3RhdGlvbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFsSW5SYW5nZSgtMy4xNDE1OTI2NTM1ODk3OTMsIDMuMTQxNTkyNjUzNTg5NzkzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgb3IgU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci4gVGhpcyBhbGxvd3MgeW91IHRvIHJldGFpbiB0aGUgdmFsdWVzXHJcbiAgICAqIHRoYXQgdGhlIGdlbmVyYXRvciBpcyB1c2luZyBiZXR3ZWVuIGdhbWVzLCBpLmUuIGluIGEgZ2FtZSBzYXZlIGZpbGUuXHJcbiAgICAqXHJcbiAgICAqIFRvIHNlZWQgdGhpcyBnZW5lcmF0b3Igd2l0aCBhIHByZXZpb3VzbHkgc2F2ZWQgc3RhdGUgeW91IGNhbiBwYXNzIGl0IGFzIHRoZVxyXG4gICAgKiBgc2VlZGAgdmFsdWUgaW4geW91ciBnYW1lIGNvbmZpZywgb3IgY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseSBhZnRlciBQaGFzZXIgaGFzIGJvb3RlZC5cclxuICAgICpcclxuICAgICogQ2FsbCB0aGlzIG1ldGhvZCB3aXRoIG5vIHBhcmFtZXRlcnMgdG8gcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAgKlxyXG4gICAgKiBJZiBwcm92aWRpbmcgYSBzdGF0ZSBpdCBzaG91bGQgbWF0Y2ggdGhlIHNhbWUgZm9ybWF0IHRoYXQgdGhpcyBtZXRob2RcclxuICAgICogcmV0dXJucywgd2hpY2ggaXMgYSBzdHJpbmcgd2l0aCBhIGhlYWRlciBgIXJuZGAgZm9sbG93ZWQgYnkgdGhlIGBjYCxcclxuICAgICogYHMwYCwgYHMxYCBhbmQgYHMyYCB2YWx1ZXMgcmVzcGVjdGl2ZWx5LCBlYWNoIGNvbW1hLWRlbGltaXRlZC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNzdGF0ZVxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YXRlXSAtIEdlbmVyYXRvciBzdGF0ZSB0byBiZSBzZXQuXHJcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci5cclxuICAgICovXHJcbiAgICBzdGF0ZTogZnVuY3Rpb24gKHN0YXRlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnICYmIHN0YXRlLm1hdGNoKC9eIXJuZC8pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5zcGxpdCgnLCcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jID0gcGFyc2VGbG9hdChzdGF0ZVsxXSk7XHJcbiAgICAgICAgICAgIHRoaXMuczAgPSBwYXJzZUZsb2F0KHN0YXRlWzJdKTtcclxuICAgICAgICAgICAgdGhpcy5zMSA9IHBhcnNlRmxvYXQoc3RhdGVbM10pO1xyXG4gICAgICAgICAgICB0aGlzLnMyID0gcGFyc2VGbG9hdChzdGF0ZVs0XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gWyAnIXJuZCcsIHRoaXMuYywgdGhpcy5zMCwgdGhpcy5zMSwgdGhpcy5zMiBdLmpvaW4oJywnKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21EYXRhR2VuZXJhdG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvcmFuZG9tLWRhdGEtZ2VuZXJhdG9yL1JhbmRvbURhdGFHZW5lcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQmFzZWQgb24gdGhlIHRocmVlLmpzIEN1cnZlIGNsYXNzZXMgY3JlYXRlZCBieSBbeno4NV0oaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZylcclxuXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDdXJ2ZSA9IHJlcXVpcmUoJy4uL0N1cnZlJyk7XHJcbnZhciBWZWN0b3IyID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aC9WZWN0b3IyJyk7XHJcblxyXG4vLyAgUGhhc2VyLkN1cnZlcy5MaW5lXHJcblxyXG52YXIgdG1wVmVjMiA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG52YXIgTGluZUN1cnZlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBDdXJ2ZSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIC8vICB2ZWMyc1xyXG4gICAgZnVuY3Rpb24gTGluZUN1cnZlICh2MSwgdjIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodjEpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdjIgPSBuZXcgVmVjdG9yMih2MVsyXSwgdjFbM10pO1xyXG4gICAgICAgICAgICB2MSA9IG5ldyBWZWN0b3IyKHYxWzBdLCB2MVsxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBDdXJ2ZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLnYxID0gdjE7XHJcbiAgICAgICAgdGhpcy52MiA9IHYyO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbiAoZGl2aXNpb25zKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQb2ludDogZnVuY3Rpb24gKHQsIG91dClcclxuICAgIHtcclxuICAgICAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFZlY3RvcjIoKTsgfVxyXG5cclxuICAgICAgICBpZiAodCA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuY29weSh0aGlzLnYyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG91dC5jb3B5KHRoaXMudjIpLnN1Yih0aGlzLnYxKS5zY2FsZSh0KS5hZGQodGhpcy52MSk7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxyXG4gICAgZ2V0UG9pbnRBdDogZnVuY3Rpb24gKHUsIG91dClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2ludCh1LCBvdXQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUYW5nZW50OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0YW5nZW50ID0gdG1wVmVjMi5jb3B5KHRoaXMudjIpLnN1Yih0aGlzLnYxKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZUN1cnZlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhdGhzL2N1cnZlcy9saW5lL0xpbmVDdXJ2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXZWJHTFN1cHBvcnRlZEV4dGVuc2lvbnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgXHJcbiAgICB2YXIgZ2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCd3ZWJnbCcpO1xyXG4gICAgdmFyIGV4dGVuc2lvbkxpc3QgPSBnbCA/IGdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKSA6IFtdO1xyXG5cclxuICAgIHJldHVybiB7XHJcblxyXG4gICAgICAgIGhhczogZnVuY3Rpb24gKG5hbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uTGlzdC5pbmRleE9mKG5hbWUpID49IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfTtcclxufSgpKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2ViR0xTdXBwb3J0ZWRFeHRlbnNpb25zO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL1dlYkdMU3VwcG9ydGVkRXh0ZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMjI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHtcclxuXHJcbiAgICAvLyBWRVJURVhfU0laRSA9IHNpemVvZih2ZWMyKSArIHNpemVvZih2ZWMyKVxyXG4gICAgVkVSVEVYX1NJWkU6IDE2LFxyXG4gICAgSU5ERVhfU0laRTogMixcclxuICAgIFRJTEVNQVBfVkVSVEVYX0NPVU5UOiA0LFxyXG4gICAgVElMRU1BUF9JTkRFWF9DT1VOVDogNixcclxuXHJcbiAgICAvLyBIb3cgbWFueSAzMi1iaXQgY29tcG9uZW50cyBkb2VzIHRoZSB2ZXJ0ZXggaGF2ZS5cclxuICAgIFRJTEVNQVBfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVDogNCxcclxuICAgIE1BWF9USUxFTUFQOiAyMDAwLFxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3RpbGVtYXByZW5kZXJlci9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluZGV4QnVmZmVyOiByZXF1aXJlKCcuL0luZGV4QnVmZmVyJyksXHJcbiAgICBSZW5kZXJUYXJnZXQ6IHJlcXVpcmUoJy4vUmVuZGVyVGFyZ2V0JyksXHJcbiAgICBTaGFkZXI6IHJlcXVpcmUoJy4vU2hhZGVyJyksXHJcbiAgICBUZXh0dXJlOiByZXF1aXJlKCcuL1RleHR1cmUnKSxcclxuICAgIFZlcnRleEJ1ZmZlcjogcmVxdWlyZSgnLi9WZXJ0ZXhCdWZmZXInKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FtZXJhTWFuYWdlciA9IHJlcXVpcmUoJy4uLy4uL2NhbWVyYS9sb2NhbC9DYW1lcmFNYW5hZ2VyJyk7XHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDbG9jayA9IHJlcXVpcmUoJy4uLy4uL3RpbWUvQ2xvY2snKTtcclxudmFyIERhdGEgPSByZXF1aXJlKCcuLi9wbHVnaW5zL0RhdGEnKTtcclxudmFyIERhdGFTdG9yZSA9IHJlcXVpcmUoJy4uL3BsdWdpbnMvRGF0YVN0b3JlJyk7XHJcbnZhciBEaXNwbGF5TGlzdCA9IHJlcXVpcmUoJy4uL3BsdWdpbnMvRGlzcGxheUxpc3QnKTtcclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxudmFyIEdhbWVPYmplY3RDcmVhdG9yID0gcmVxdWlyZSgnLi4vcGx1Z2lucy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSByZXF1aXJlKCcuLi9wbHVnaW5zL0dhbWVPYmplY3RGYWN0b3J5Jyk7XHJcbnZhciBJbnB1dE1hbmFnZXIgPSByZXF1aXJlKCcuLi9wbHVnaW5zL0lucHV0TWFuYWdlcicpO1xyXG52YXIgTG9hZGVyID0gcmVxdWlyZSgnLi4vcGx1Z2lucy9Mb2FkZXInKTtcclxudmFyIFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi4vcGx1Z2lucy9QaHlzaWNzTWFuYWdlcicpO1xyXG52YXIgUG9vbE1hbmFnZXIgPSByZXF1aXJlKCcuLi9wbHVnaW5zL1Bvb2xNYW5hZ2VyJyk7XHJcbnZhciBTY2VuZU1hbmFnZXIgPSByZXF1aXJlKCcuLi9wbHVnaW5zL1NjZW5lTWFuYWdlcicpO1xyXG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKCcuL1NldHRpbmdzJyk7XHJcbnZhciBTdGFibGVTb3J0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXkvU3RhYmxlU29ydCcpO1xyXG52YXIgVHdlZW5NYW5hZ2VyID0gcmVxdWlyZSgnLi4vLi4vdHdlZW4vbWFuYWdlci9Ud2Vlbk1hbmFnZXInKTtcclxudmFyIFVwZGF0ZUxpc3QgPSByZXF1aXJlKCcuLi9wbHVnaW5zL1VwZGF0ZUxpc3QnKTtcclxuXHJcbnZhciBTeXN0ZW1zID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFN5c3RlbXMgKHNjZW5lLCBjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gU2V0dGluZ3MuY3JlYXRlKGNvbmZpZyk7XHJcblxyXG4gICAgICAgIHRoaXMuc29ydENoaWxkcmVuRmxhZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyAgU2V0IGJ5IHRoZSBHbG9iYWxTY2VuZU1hbmFnZXJcclxuICAgICAgICB0aGlzLmNhbnZhcztcclxuICAgICAgICB0aGlzLmNvbnRleHQ7XHJcblxyXG4gICAgICAgIC8vICBDT1JFIChHTE9CQUwpIFNZU1RFTVMgLyBQUk9QRVJUSUVTXHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZTtcclxuXHJcbiAgICAgICAgdGhpcy5hbmltcztcclxuICAgICAgICB0aGlzLmNhY2hlO1xyXG4gICAgICAgIHRoaXMucmVnaXN0cnk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlcztcclxuXHJcbiAgICAgICAgLy8gIFJlZmVyZW5jZSB0byBTY2VuZSBzcGVjaWZpYyBtYW5hZ2VycyAoRmFjdG9yeSwgVHdlZW5zLCBMb2FkZXIsIFBoeXNpY3MsIGV0YylcclxuICAgICAgICB0aGlzLmFkZDtcclxuICAgICAgICB0aGlzLmNhbWVyYXM7XHJcbiAgICAgICAgdGhpcy5kYXRhO1xyXG4gICAgICAgIHRoaXMuZGF0YVN0b3JlO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheUxpc3Q7XHJcbiAgICAgICAgdGhpcy5ldmVudHM7XHJcbiAgICAgICAgdGhpcy5pbnB1dE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5sb2FkO1xyXG4gICAgICAgIHRoaXMubWFrZTtcclxuICAgICAgICB0aGlzLnBoeXNpY3NNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMucG9vbDtcclxuICAgICAgICB0aGlzLnNjZW5lTWFuYWdlcjtcclxuICAgICAgICB0aGlzLnRpbWU7XHJcbiAgICAgICAgdGhpcy50d2VlbnM7XHJcbiAgICAgICAgdGhpcy51cGRhdGVMaXN0O1xyXG4gICAgfSxcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZ2FtZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgc2NlbmUgPSB0aGlzLnNjZW5lO1xyXG5cclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG5cclxuICAgICAgICAvLyAgR2FtZSAoR2xvYmFsKSBsZXZlbCBtYW5hZ2Vyc1xyXG5cclxuICAgICAgICB0aGlzLmFuaW1zID0gZ2FtZS5hbmltcztcclxuICAgICAgICB0aGlzLmNhY2hlID0gZ2FtZS5jYWNoZTtcclxuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gZ2FtZS5yZWdpc3RyeTtcclxuICAgICAgICB0aGlzLnRleHR1cmVzID0gZ2FtZS50ZXh0dXJlcztcclxuXHJcbiAgICAgICAgLy8gIFNjZW5lIHNwZWNpZmljIG1hbmFnZXJzIChGYWN0b3J5LCBUd2VlbnMsIExvYWRlciwgUGh5c2ljcywgZXRjKVxyXG5cclxuICAgICAgICB0aGlzLmFkZCA9IG5ldyBHYW1lT2JqZWN0RmFjdG9yeShzY2VuZSk7XHJcbiAgICAgICAgdGhpcy5jYW1lcmFzID0gbmV3IENhbWVyYU1hbmFnZXIoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhKHNjZW5lKTtcclxuICAgICAgICB0aGlzLmRhdGFTdG9yZSA9IG5ldyBEYXRhU3RvcmUoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheUxpc3QgPSBuZXcgRGlzcGxheUxpc3Qoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRNYW5hZ2VyID0gbmV3IElucHV0TWFuYWdlcihzY2VuZSk7XHJcbiAgICAgICAgdGhpcy5sb2FkID0gbmV3IExvYWRlcihzY2VuZSk7XHJcbiAgICAgICAgdGhpcy5tYWtlID0gbmV3IEdhbWVPYmplY3RDcmVhdG9yKHNjZW5lKTtcclxuICAgICAgICB0aGlzLnBoeXNpY3NNYW5hZ2VyID0gbmV3IFBoeXNpY3NNYW5hZ2VyKHNjZW5lKTtcclxuICAgICAgICB0aGlzLnBvb2wgPSBuZXcgUG9vbE1hbmFnZXIoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyID0gbmV3IFNjZW5lTWFuYWdlcihzY2VuZSk7XHJcbiAgICAgICAgdGhpcy50aW1lID0gbmV3IENsb2NrKHNjZW5lKTtcclxuICAgICAgICB0aGlzLnR3ZWVucyA9IG5ldyBUd2Vlbk1hbmFnZXIoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGlzdCA9IG5ldyBVcGRhdGVMaXN0KHNjZW5lKTtcclxuXHJcbiAgICAgICAgLy8gIFNvbWV0aW1lcyB0aGUgbWFuYWdlcnMgbmVlZCBhY2Nlc3MgdG8gYSBzeXN0ZW0gY3JlYXRlZCBhZnRlciB0aGVtXHJcbiAgICAgICAgdGhpcy5hZGQuYm9vdCh0aGlzKTtcclxuICAgICAgICB0aGlzLmlucHV0TWFuYWdlci5ib290KCk7XHJcbiAgICAgICAgdGhpcy5waHlzaWNzTWFuYWdlci5ib290KCk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5qZWN0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGluamVjdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgbWFwID0gdGhpcy5zZXR0aW5ncy5tYXA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtYXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc3lzJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVbbWFwW2tleV1dID0gdGhpc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3RlcDogZnVuY3Rpb24gKHRpbWUsIGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBBcmUgdGhlcmUgYW55IHBlbmRpbmcgU2NlbmVNYW5hZ2VyIGFjdGlvbnM/XHJcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIudXBkYXRlKCk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5hY3RpdmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBvb2wuYmVnaW4odGltZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVMaXN0LmJlZ2luKHRpbWUpO1xyXG4gICAgICAgIHRoaXMudGltZS5iZWdpbih0aW1lKTtcclxuICAgICAgICB0aGlzLnR3ZWVucy5iZWdpbih0aW1lKTtcclxuICAgICAgICB0aGlzLmlucHV0TWFuYWdlci5iZWdpbih0aW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5waHlzaWNzTWFuYWdlci51cGRhdGUodGltZSwgZGVsdGEpO1xyXG5cclxuICAgICAgICB0aGlzLnBvb2wudXBkYXRlKHRpbWUsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxpc3QudXBkYXRlKHRpbWUsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLnRpbWUudXBkYXRlKHRpbWUsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLnR3ZWVucy51cGRhdGUodGltZSwgZGVsdGEpO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhcy51cGRhdGUodGltZSwgZGVsdGEpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRNYW5hZ2VyLnVwZGF0ZSh0aW1lLCBkZWx0YSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2NlbmUudXBkYXRlLmNhbGwodGhpcy5zY2VuZSwgdGltZSwgZGVsdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uLCByZW5kZXJlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MudmlzaWJsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGVwdGhTb3J0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMuZGlzcGxheUxpc3QsIGludGVycG9sYXRpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgRm9yY2UgYSBzb3J0IG9mIHRoZSBkaXNwbGF5IGxpc3Qgb24gdGhlIG5leHQgcmVuZGVyXHJcbiAgICBxdWV1ZURlcHRoU29ydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNvcnRDaGlsZHJlbkZsYWcgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgSW1tZWRpYXRlbHkgc29ydHMgdGhlIGRpc3BsYXkgbGlzdCBpZiB0aGUgZmxhZyBpcyBzZXRcclxuICAgIGRlcHRoU29ydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5zb3J0Q2hpbGRyZW5GbGFnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU3RhYmxlU29ydC5pbnBsYWNlKHRoaXMuZGlzcGxheUxpc3QubGlzdCwgdGhpcy5zb3J0Wik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNvcnRDaGlsZHJlbkZsYWcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNvcnRaOiBmdW5jdGlvbiAoY2hpbGRBLCBjaGlsZEIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkQS5fZGVwdGggLSBjaGlsZEIuX2RlcHRoO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQSBwYXVzZWQgU2NlbmUgc3RpbGwgcmVuZGVycywgaXQganVzdCBkb2Vzbid0IHJ1biBBTlkgb2YgaXRzIHVwZGF0ZSBoYW5kbGVycyBvciBzeXN0ZW1zXHJcbiAgICBwYXVzZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgV2FzIHBhdXNlZCBieSB0aGUgR2xvYmFsU2NlbmVNYW5hZ2VyXHJcblxyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuYWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNjZW5lLnBhdXNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5wYXVzZS5jYWxsKHRoaXMuc2NlbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVzdW1lOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBXYXMgcmVzdW1lZCBieSB0aGUgR2xvYmFsU2NlbmVNYW5hZ2VyXHJcblxyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuYWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2NlbmUucmVzdW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5yZXN1bWUuY2FsbCh0aGlzLnNjZW5lKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNsZWVwOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBXYXMgc2VudCB0byBzbGVlcCBieSB0aGUgR2xvYmFsU2NlbmVNYW5hZ2VyXHJcblxyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncy52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNjZW5lLnNsZWVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5zbGVlcC5jYWxsKHRoaXMuc2NlbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgd2FrZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgV2FzIHdva2VuIHVwIGJ5IHRoZSBHbG9iYWxTY2VuZU1hbmFnZXJcclxuXHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNjZW5lLndha2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLndha2UuY2FsbCh0aGlzLnNjZW5lKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoZGF0YSlcclxuICAgIHtcclxuICAgICAgICAvLyAgV2FzIHN0YXJ0ZWQgYnkgdGhlIEdsb2JhbFNjZW5lTWFuYWdlclxyXG5cclxuICAgICAgICB0aGlzLnNldHRpbmdzLmRhdGEgPSBkYXRhO1xyXG5cclxuICAgICAgICB0aGlzLnNldHRpbmdzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncy52aXNpYmxlID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2h1dGRvd246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFdhcyBzdG9wcGVkIGJ5IHRoZSBHbG9iYWxTY2VuZU1hbmFnZXJcclxuXHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNldHRpbmdzLnZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5wb29sLnNodXRkb3duKCk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5TGlzdC5zaHV0ZG93bigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGlzdC5zaHV0ZG93bigpO1xyXG4gICAgICAgIHRoaXMudGltZS5zaHV0ZG93bigpO1xyXG4gICAgICAgIHRoaXMudHdlZW5zLnNodXRkb3duKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNjZW5lLnNodXRkb3duKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5zaHV0ZG93bi5jYWxsKHRoaXMuc2NlbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEdhbWUgbGV2ZWwgbnVrZVxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgVE9ET1xyXG5cclxuICAgICAgICB0aGlzLmFkZC5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5wb29sLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnRpbWUuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMudHdlZW5zLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgLy8gIGV0Y1xyXG4gICAgICAgIGlmICh0aGlzLnNjZW5lLmRlc3Ryb3kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLmRlc3Ryb3kuY2FsbCh0aGlzLnNjZW5lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3lzdGVtcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9sb2NhbC9TeXN0ZW1zLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBEaXNwbGF5TGlzdCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBEaXNwbGF5TGlzdCAoc2NlbmUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRoZSBTY2VuZSB0aGF0IG93bnMgdGhpcyBwbHVnaW5cclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcblxyXG4gICAgICAgIC8vICBUaGUgb2JqZWN0cyB0aGF0IGJlbG9uZyB0byB0aGlzIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgLy8gIFRoZSBlcXVpdmFsZW50IG9mIHRoZSBvbGQgYFNwcml0ZS5jaGlsZHJlbmAgYXJyYXkuXHJcbiAgICAgICAgdGhpcy5saXN0ID0gW107XHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICAvLyAgSXMgY2hpbGQgYWxyZWFkeSBpbiB0aGlzIGRpc3BsYXkgbGlzdD9cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0SW5kZXgoY2hpbGQpID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdC5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXQ6IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxpc3QubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGNoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDw9IHRoaXMubGlzdC5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJbmRleChjaGlsZCkgPT09IC0xKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkTXVsdGlwbGU6IGZ1bmN0aW9uIChjaGlsZHJlbilcclxuICAgIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChjaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0QXQ6IGZ1bmN0aW9uIChpbmRleClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0W2luZGV4XTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICAvLyAgUmV0dXJuIC0xIGlmIGdpdmVuIGNoaWxkIGlzbid0IGEgY2hpbGQgb2YgdGhpcyBkaXNwbGF5IGxpc3RcclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0LmluZGV4T2YoY2hpbGQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgR2l2ZW4gYW4gYXJyYXkgb2YgR2FtZSBPYmplY3RzLCBzb3J0IHRoZSBhcnJheSBhbmQgcmV0dXJuIGl0LFxyXG4gICAgLy8gIHNvIHRoYXQgdGhlIG9iamVjdHMgYXJlIGluIGluZGV4IG9yZGVyIHdpdGggdGhlIGxvd2VzdCBhdCB0aGUgYm90dG9tLlxyXG4gICAgc29ydEdhbWVPYmplY3RzOiBmdW5jdGlvbiAoZ2FtZU9iamVjdHMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGdhbWVPYmplY3RzID09PSB1bmRlZmluZWQpIHsgZ2FtZU9iamVjdHMgPSB0aGlzLmxpc3Q7IH1cclxuXHJcbiAgICAgICAgdGhpcy5zY2VuZS5zeXMuZGVwdGhTb3J0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBnYW1lT2JqZWN0cy5zb3J0KHRoaXMuc29ydEluZGV4SGFuZGxlci5iaW5kKHRoaXMpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIE5vdGUgdGhhdCB0aGUgZ2l2ZW4gYXJyYXkgaXMgc29ydGVkIGluIHBsYWNlLCBldmVuIHRob3VnaCBpdCBpc24ndCByZXR1cm5lZCBkaXJlY3RseSBpdCB3aWxsIHN0aWxsIGJlIHVwZGF0ZWQuXHJcbiAgICBnZXRUb3BHYW1lT2JqZWN0OiBmdW5jdGlvbiAoZ2FtZU9iamVjdHMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zb3J0R2FtZU9iamVjdHMoZ2FtZU9iamVjdHMpO1xyXG5cclxuICAgICAgICByZXR1cm4gZ2FtZU9iamVjdHNbZ2FtZU9iamVjdHMubGVuZ3RoIC0gMV07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBSZXR1cm4gdGhlIGNoaWxkIGxvd2VzdCBkb3duIHRoZSBkaXNwbGF5IGxpc3QgKHdpdGggdGhlIHNtYWxsZXN0IGluZGV4KVxyXG4gICAgc29ydEluZGV4SGFuZGxlcjogZnVuY3Rpb24gKGNoaWxkQSwgY2hpbGRCKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUaGUgbG93ZXIgdGhlIGluZGV4LCB0aGUgbG93ZXIgZG93biB0aGUgZGlzcGxheSBsaXN0IHRoZXkgYXJlXHJcbiAgICAgICAgdmFyIGluZGV4QSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGRBKTtcclxuICAgICAgICB2YXIgaW5kZXhCID0gdGhpcy5nZXRJbmRleChjaGlsZEIpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXhBIDwgaW5kZXhCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbmRleEEgPiBpbmRleEIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBUZWNobmljYWxseSB0aGlzIHNob3VsZG4ndCBoYXBwZW4sIGJ1dCBpZiB0aGUgR08gd2Fzbid0IHBhcnQgb2YgdGhpcyBkaXNwbGF5IGxpc3QgdGhlbiBpdCdsbFxyXG4gICAgICAgIC8vICBoYXZlIGFuIGluZGV4IG9mIC0xLCBzbyBpbiBzb21lIGNhc2VzIGl0IGNhblxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogR2V0cyB0aGUgZmlyc3QgaXRlbSBmcm9tIHRoZSBzZXQgYmFzZWQgb24gdGhlIHByb3BlcnR5IHN0cmljdGx5IGVxdWFsaW5nIHRoZSB2YWx1ZSBnaXZlbi5cclxuICAgICogUmV0dXJucyBudWxsIGlmIG5vdCBmb3VuZC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjZ2V0QnlLZXlcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHRvIGNoZWNrIGFnYWluc3QgdGhlIHZhbHVlLlxyXG4gICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2sgaWYgdGhlIHByb3BlcnR5IHN0cmljdGx5IGVxdWFscy5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgaXRlbSB0aGF0IHdhcyBmb3VuZCwgb3IgbnVsbCBpZiBub3RoaW5nIG1hdGNoZWQuXHJcbiAgICAqL1xyXG4gICAgZ2V0QnlLZXk6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXN0W2ldW3Byb3BlcnR5XSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogU2VhcmNoZXMgdGhlIEdyb3VwIGZvciB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYSBjaGlsZCB3aXRoIHRoZSBgbmFtZWBcclxuICAgICogcHJvcGVydHkgbWF0Y2hpbmcgdGhlIGdpdmVuIGFyZ3VtZW50LiBTaG91bGQgbW9yZSB0aGFuIG9uZSBjaGlsZCBoYXZlXHJcbiAgICAqIHRoZSBzYW1lIG5hbWUgb25seSB0aGUgZmlyc3QgaW5zdGFuY2UgaXMgcmV0dXJuZWQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI2dldEJ5TmFtZVxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIHRvIHNlYXJjaCBmb3IuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGZpcnN0IGNoaWxkIHdpdGggYSBtYXRjaGluZyBuYW1lLCBvciBudWxsIGlmIG5vbmUgd2VyZSBmb3VuZC5cclxuICAgICovXHJcbiAgICBnZXRCeU5hbWU6IGZ1bmN0aW9uIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ5S2V5KCduYW1lJywgbmFtZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGNoaWxkIGZyb20gdGhlIGdyb3VwLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNnZXRSYW5kb21cclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnRJbmRleD0wXSAtIE9mZnNldCBmcm9tIHRoZSBmcm9udCBvZiB0aGUgZ3JvdXAgKGxvd2VzdCBjaGlsZCkuXHJcbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbmd0aD0odG8gdG9wKV0gLSBSZXN0cmljdGlvbiBvbiB0aGUgbnVtYmVyIG9mIHZhbHVlcyB5b3Ugd2FudCB0byByYW5kb21seSBzZWxlY3QgZnJvbS5cclxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBjaGlsZCBvZiB0aGlzIEdyb3VwLlxyXG4gICAgKi9cclxuICAgIGdldFJhbmRvbTogZnVuY3Rpb24gKHN0YXJ0SW5kZXgsIGxlbmd0aClcclxuICAgIHtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0SW5kZXggPSAwOyB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IHRoaXMubGlzdC5sZW5ndGg7IH1cclxuXHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggPiB0aGlzLmxpc3QubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmFuZG9tSW5kZXggPSBzdGFydEluZGV4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuZ3RoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtyYW5kb21JbmRleF07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZpcnN0OiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlLCBzdGFydEluZGV4LCBlbmRJbmRleClcclxuICAgIHtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0SW5kZXggPSAwOyB9XHJcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgZW5kSW5kZXggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMubGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZFtwcm9wZXJ0eV0gPT09IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhbGwgY2hpbGRyZW4gaW4gdGhpcyBHcm91cC5cclxuICAgICpcclxuICAgICogWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgYSBtYXRjaGluZyBjcml0ZXJpYSB1c2luZyB0aGUgYHByb3BlcnR5YCBhbmQgYHZhbHVlYCBhcmd1bWVudHMuXHJcbiAgICAqXHJcbiAgICAqIEZvciBleGFtcGxlOiBgZ2V0QWxsKCdleGlzdHMnLCB0cnVlKWAgd291bGQgcmV0dXJuIG9ubHkgY2hpbGRyZW4gdGhhdCBoYXZlIHRoZWlyIGV4aXN0cyBwcm9wZXJ0eSBzZXQuXHJcbiAgICAqXHJcbiAgICAqIE9wdGlvbmFsbHkgeW91IGNhbiBzcGVjaWZ5IGEgc3RhcnQgYW5kIGVuZCBpbmRleC4gRm9yIGV4YW1wbGUgaWYgdGhpcyBHcm91cCBoYWQgMTAwIGNoaWxkcmVuLFxyXG4gICAgKiBhbmQgeW91IHNldCBgc3RhcnRJbmRleGAgdG8gMCBhbmQgYGVuZEluZGV4YCB0byA1MCwgaXQgd291bGQgcmV0dXJuIG1hdGNoZXMgZnJvbSBvbmx5XHJcbiAgICAqIHRoZSBmaXJzdCA1MCBjaGlsZHJlbiBpbiB0aGUgR3JvdXAuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI2dldEFsbFxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIEFuIG9wdGlvbmFsIHByb3BlcnR5IHRvIHRlc3QgYWdhaW5zdCB0aGUgdmFsdWUgYXJndW1lbnQuXHJcbiAgICAqIEBwYXJhbSB7YW55fSBbdmFsdWVdIC0gSWYgcHJvcGVydHkgaXMgc2V0IHRoZW4gQ2hpbGQucHJvcGVydHkgbXVzdCBzdHJpY3RseSBlcXVhbCB0aGlzIHZhbHVlIHRvIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRzLlxyXG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydEluZGV4PTBdIC0gVGhlIGZpcnN0IGNoaWxkIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggZnJvbS5cclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kSW5kZXhdIC0gVGhlIGxhc3QgY2hpbGQgaW5kZXggdG8gc2VhcmNoIHVwIHVudGlsLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IEEgcmFuZG9tIGV4aXN0aW5nIGNoaWxkIG9mIHRoaXMgR3JvdXAuXHJcbiAgICAqL1xyXG4gICAgZ2V0QWxsOiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlLCBzdGFydEluZGV4LCBlbmRJbmRleClcclxuICAgIHtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0SW5kZXggPSAwOyB9XHJcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgZW5kSW5kZXggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XHJcblxyXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5saXN0W2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRbcHJvcGVydHldID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHN3YXA6IGZ1bmN0aW9uIChjaGlsZDEsIGNoaWxkMilcclxuICAgIHtcclxuICAgICAgICBpZiAoY2hpbGQxID09PSBjaGlsZDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRJbmRleChjaGlsZDEpO1xyXG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLmdldEluZGV4KGNoaWxkMik7XHJcblxyXG4gICAgICAgIGlmIChpbmRleDEgPCAwIHx8IGluZGV4MiA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc3BsYXlMaXN0LnN3YXA6IFN1cHBsaWVkIG9iamVjdHMgbXVzdCBiZSBjaGlsZHJlbiBvZiB0aGUgc2FtZSBsaXN0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxpc3RbaW5kZXgxXSA9IGNoaWxkMjtcclxuICAgICAgICB0aGlzLmxpc3RbaW5kZXgyXSA9IGNoaWxkMTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gICB3YXMgc2V0SW5kZXhcclxuICAgIG1vdmVUbzogZnVuY3Rpb24gKGNoaWxkLCBpbmRleClcclxuICAgIHtcclxuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5nZXRJbmRleChjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxpc3QubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaXNwbGF5TGlzdC5tb3ZlVG86IFRoZSBzdXBwbGllZCBpbmRleCBpcyBvdXQgb2YgYm91bmRzJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgUmVtb3ZlXHJcbiAgICAgICAgdGhpcy5saXN0LnNwbGljZShjdXJyZW50SW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAvLyAgQWRkIGluIG5ldyBsb2NhdGlvblxyXG4gICAgICAgIHRoaXMubGlzdC5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxpc3QuaW5kZXhPZihjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVBdDogZnVuY3Rpb24gKGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMubGlzdFtpbmRleF07XHJcblxyXG4gICAgICAgIGlmIChjaGlsZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQmV0d2VlbjogZnVuY3Rpb24gKGJlZ2luSW5kZXgsIGVuZEluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChiZWdpbkluZGV4ID09PSB1bmRlZmluZWQpIHsgYmVnaW5JbmRleCA9IDA7IH1cclxuICAgICAgICBpZiAoZW5kSW5kZXggPT09IHVuZGVmaW5lZCkgeyBlbmRJbmRleCA9IHRoaXMubGlzdC5sZW5ndGg7IH1cclxuXHJcbiAgICAgICAgdmFyIHJhbmdlID0gZW5kSW5kZXggLSBiZWdpbkluZGV4O1xyXG5cclxuICAgICAgICBpZiAocmFuZ2UgPiAwICYmIHJhbmdlIDw9IGVuZEluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLmxpc3Quc3BsaWNlKGJlZ2luSW5kZXgsIHJhbmdlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyYW5nZSA9PT0gMCAmJiB0aGlzLmxpc3QubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc3BsYXlMaXN0LnJlbW92ZUJldHdlZW46IFJhbmdlIEVycm9yLCBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJlbW92ZXMgYWxsIHRoZSBpdGVtcy5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjcmVtb3ZlQWxsXHJcbiAgICAqL1xyXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5saXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRoaXMubGlzdFtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2h1dGRvd246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEJyaW5ncyB0aGUgZ2l2ZW4gY2hpbGQgdG8gdGhlIHRvcCBvZiB0aGlzIGdyb3VwIHNvIGl0IHJlbmRlcnMgYWJvdmUgYWxsIG90aGVyIGNoaWxkcmVuLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNicmluZ1RvVG9wXHJcbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBicmluZyB0byB0aGUgdG9wIG9mIHRoaXMgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGNoaWxkIHRoYXQgd2FzIG1vdmVkLlxyXG4gICAgKi9cclxuICAgIGJyaW5nVG9Ub3A6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5nZXRJbmRleChjaGlsZCkgPCB0aGlzLmxpc3QubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTZW5kcyB0aGUgZ2l2ZW4gY2hpbGQgdG8gdGhlIGJvdHRvbSBvZiB0aGlzIGdyb3VwIHNvIGl0IHJlbmRlcnMgYmVsb3cgYWxsIG90aGVyIGNoaWxkcmVuLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNzZW5kVG9CYWNrXHJcbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBzZW5kIHRvIHRoZSBib3R0b20gb2YgdGhpcyBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmdldEluZGV4KGNoaWxkKSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXQoY2hpbGQsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogTW92ZXMgdGhlIGdpdmVuIGNoaWxkIHVwIG9uZSBwbGFjZSBpbiB0aGlzIGdyb3VwIHVubGVzcyBpdCdzIGFscmVhZHkgYXQgdGhlIHRvcC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjbW92ZVVwXHJcbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBtb3ZlIHVwIGluIHRoZSBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgbW92ZVVwOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldEluZGV4KGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGEgIT09IC0xICYmIGEgPCB0aGlzLmxpc3QubGVuZ3RoIC0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5nZXRBdChhICsgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zd2FwKGNoaWxkLCBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogTW92ZXMgdGhlIGdpdmVuIGNoaWxkIGRvd24gb25lIHBsYWNlIGluIHRoaXMgZ3JvdXAgdW5sZXNzIGl0J3MgYWxyZWFkeSBhdCB0aGUgYm90dG9tLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNtb3ZlRG93blxyXG4gICAgKiBAcGFyYW0ge2FueX0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gbW92ZSBkb3duIGluIHRoZSBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgbW92ZURvd246IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQpO1xyXG5cclxuICAgICAgICBpZiAoYSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0QXQoYSAtIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3dhcChjaGlsZCwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldmVyc2VzIGFsbCBjaGlsZHJlbiBpbiB0aGlzIGdyb3VwLlxyXG4gICAgKlxyXG4gICAgKiBUaGlzIG9wZXJhdGlvbiBhcHBsaWVzIG9ubHkgdG8gaW1tZWRpYXRlIGNoaWxkcmVuIGFuZCBkb2VzIG5vdCBwcm9wYWdhdGUgdG8gc3ViZ3JvdXBzLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNyZXZlcnNlXHJcbiAgICAqL1xyXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmxpc3QucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5saXN0Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMubGlzdFtpXTtcclxuICAgICAgICAgICAgdGhpcy5saXN0W2ldID0gdGhpcy5saXN0W2pdO1xyXG4gICAgICAgICAgICB0aGlzLmxpc3Rbal0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXBsYWNlcyBhIGNoaWxkIG9mIHRoaXMgR3JvdXAgd2l0aCB0aGUgZ2l2ZW4gbmV3Q2hpbGQuIFRoZSBuZXdDaGlsZCBjYW5ub3QgYmUgYSBtZW1iZXIgb2YgdGhpcyBHcm91cC5cclxuICAgICpcclxuICAgICogSWYgYEdyb3VwLmVuYWJsZUJvZHlgIGlzIHNldCwgdGhlbiBhIHBoeXNpY3MgYm9keSB3aWxsIGJlIGNyZWF0ZWQgb24gdGhlIG9iamVjdCwgc28gbG9uZyBhcyBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cclxuICAgICpcclxuICAgICogSWYgYEdyb3VwLmlucHV0RW5hYmxlQ2hpbGRyZW5gIGlzIHNldCwgdGhlbiBhbiBJbnB1dCBIYW5kbGVyIHdpbGwgYmUgY3JlYXRlZCBvbiB0aGUgb2JqZWN0LCBzbyBsb25nIGFzIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNyZXBsYWNlXHJcbiAgICAqIEBwYXJhbSB7YW55fSBvbGRDaGlsZCAtIFRoZSBjaGlsZCBpbiB0aGlzIGdyb3VwIHRoYXQgd2lsbCBiZSByZXBsYWNlZC5cclxuICAgICogQHBhcmFtIHthbnl9IG5ld0NoaWxkIC0gVGhlIGNoaWxkIHRvIGJlIGluc2VydGVkIGludG8gdGhpcyBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBSZXR1cm5zIHRoZSBvbGRDaGlsZCB0aGF0IHdhcyByZXBsYWNlZCB3aXRoaW4gdGhpcyBncm91cC5cclxuICAgICovXHJcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG5ld0NoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgob2xkQ2hpbGQpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3Q2hpbGQuc2NlbmUuc3lzLmRpc3BsYXlMaXN0LnJlbW92ZShuZXdDaGlsZCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShvbGRDaGlsZCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZEF0KG5ld0NoaWxkLCBpbmRleCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb2xkQ2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU3dhcHMgYSBjaGlsZCBmcm9tIGFub3RoZXIgcGFyZW50LCB3aXRoIG9uZSBmcm9tIHRoaXMgcGFyZW50LlxyXG4gICAgLy8gIGNoaWxkMSA9IHRoZSBjaGlsZCBvZiBUSElTIHBhcmVudFxyXG4gICAgLy8gIGNoaWxkMiA9IHRoZSBjaGlsZCBvZiB0aGUgT1RIRVIgcGFyZW50XHJcbiAgICBleGNoYW5nZTogZnVuY3Rpb24gKGNoaWxkMSwgY2hpbGQyKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjaGlsZDEgPT09IGNoaWxkMiB8fCBjaGlsZDEuc2NlbmUgPT09IGNoaWxkMi5zY2VuZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjaGlsZDJQYXJlbnQgPSBjaGlsZDIuc2NlbmUuc3lzLmRpc3BsYXlMaXN0O1xyXG5cclxuICAgICAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRJbmRleChjaGlsZDEpO1xyXG4gICAgICAgIHZhciBpbmRleDIgPSBjaGlsZDJQYXJlbnQuZ2V0SW5kZXgoY2hpbGQyKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4MSA8IDAgfHwgaW5kZXgyIDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGRyZW4uc3dhcDogU3VwcGxpZWQgb2JqZWN0cyBtdXN0IGJlIGNoaWxkcmVuIG9mIHBhcmVudHMnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVtb3ZlKGNoaWxkMSk7XHJcblxyXG4gICAgICAgIGNoaWxkMlBhcmVudC5yZW1vdmUoY2hpbGQyKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRBdChjaGlsZDIsIGluZGV4MSk7XHJcblxyXG4gICAgICAgIGNoaWxkMlBhcmVudC5hZGRBdChjaGlsZDEsIGluZGV4Mik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDaGVja3MgZm9yIHRoZSBpdGVtIHdpdGhpbiB0aGlzIGxpc3QuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkFycmF5U2V0I2V4aXN0c1xyXG4gICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBlbGVtZW50IHRvIGdldCB0aGUgbGlzdCBpbmRleCBmb3IuXHJcbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGl0ZW0gaXMgZm91bmQgaW4gdGhlIGxpc3QsIG90aGVyd2lzZSBmYWxzZS5cclxuICAgICovXHJcbiAgICBleGlzdHM6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubGlzdC5pbmRleE9mKGNoaWxkKSA+IC0xKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBrZXlgIHRvIHRoZSBnaXZlbiB2YWx1ZSBvbiBhbGwgbWVtYmVycyBvZiB0aGlzIGxpc3QuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkFycmF5U2V0I3NldEFsbFxyXG4gICAgKiBAcGFyYW0ge2FueX0ga2V5IC0gVGhlIHByb3BlcnR5IG9mIHRoZSBpdGVtIHRvIHNldC5cclxuICAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG8uXHJcbiAgICAqL1xyXG4gICAgc2V0QWxsOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RbaV0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdFtpXVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBQYXNzZXMgYWxsIGNoaWxkcmVuIHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBlYWNoXHJcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAgKiBAcGFyYW0gey4uLip9IFthcmd1bWVudHNdIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIGFmdGVyIHRoZSBjaGlsZC5cclxuICAgICovXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbIG51bGwgXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhcmdzWzBdID0gdGhpcy5saXN0W2ldO1xyXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBNb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGlzIEdyb3VwIHRvIHRoZSBHcm91cCBnaXZlbi5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjbW92ZUFsbFxyXG4gICAgKiBAcGFyYW0ge1BoYXNlci5Hcm91cH0gZ3JvdXAgLSBUaGUgbmV3IEdyb3VwIHRvIHdoaWNoIHRoZSBjaGlsZHJlbiB3aWxsIGJlIG1vdmVkIHRvLlxyXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIC0gSWYgdHJ1ZSB0aGUgY2hpbGRyZW4gd2lsbCBub3QgZGlzcGF0Y2ggdGhlIGBvbkFkZGVkVG9Hcm91cGAgZXZlbnQgZm9yIHRoZSBuZXcgR3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge1BoYXNlci5Hcm91cH0gVGhlIEdyb3VwIHRvIHdoaWNoIGFsbCB0aGUgY2hpbGRyZW4gd2VyZSBtb3ZlZC5cclxuICAgICovXHJcbiAgICByZXBhcmVudDogZnVuY3Rpb24gKG5ld1BhcmVudClcclxuICAgIHtcclxuICAgICAgICBpZiAobmV3UGFyZW50ICE9PSB0aGlzLnNjZW5lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMucmVtb3ZlKHRoaXMubGlzdFtpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LnN5cy5kaXNwbGF5TGlzdC5hZGQoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3UGFyZW50O1xyXG4gICAgfSxcclxuXHJcbiAgICBsZW5ndGg6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZmlyc3Q6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5saXN0Lmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxhc3Q6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5saXN0Lmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFt0aGlzLnBvc2l0aW9uXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbmV4dDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA8IHRoaXMubGlzdC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24rKztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W3RoaXMucG9zaXRpb25dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwcmV2aW91czoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24tLTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W3RoaXMucG9zaXRpb25dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BsYXlMaXN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL3BsdWdpbnMvRGlzcGxheUxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDIzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG5cclxuLy8gVGhlIGtleXMgb2YgYSBNYXAgY2FuIGJlIGFyYml0cmFyeSB2YWx1ZXMuXHJcblxyXG4vKlxyXG52YXIgbWFwID0gbmV3IE1hcChbXHJcbiAgICBbIDEsICdvbmUnIF0sXHJcbiAgICBbIDIsICd0d28nIF0sXHJcbiAgICBbIDMsICd0aHJlZScgXVxyXG5dKTtcclxuKi9cclxuXHJcbnZhciBNYXAgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gTWFwIChlbGVtZW50cylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmVudHJpZXMgPSB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZWxlbWVudHNbaV1bMF0sIGVsZW1lbnRzW2ldWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGFzKGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmVudHJpZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnNpemUrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBcnJheTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gW107XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBlbnRyaWVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2goZW50cmllc1trZXldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhczogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZW50cmllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVsZXRlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZW50cmllc1trZXldO1xyXG4gICAgICAgICAgICB0aGlzLnNpemUtLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmVudHJpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lbnRyaWVzW3Byb3BdO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAga2V5czogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5lbnRyaWVzKTtcclxuICAgIH0sXHJcblxyXG4gICAgdmFsdWVzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcclxuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGVudHJpZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChlbnRyaWVzW2tleV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0sXHJcblxyXG4gICAgZHVtcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcclxuXHJcbiAgICAgICAgY29uc29sZS5ncm91cCgnTWFwJyk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBlbnRyaWVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coa2V5LCBlbnRyaWVzW2tleV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZW50cmllcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhrZXksIGVudHJpZXNba2V5XSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBlbnRyaWVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGVudHJpZXNba2V5XSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBNZXJnZXMgYWxsIG5ldyBrZXlzIGZyb20gdGhlIGdpdmVuIE1hcCBpbnRvIHRoaXMgb25lXHJcbiAgICAvLyAgSWYgaXQgZW5jb3VudGVycyBhIGtleSB0aGF0IGFscmVhZHkgZXhpc3RzIGl0IHdpbGwgYmUgc2tpcHBlZFxyXG4gICAgLy8gIHVubGVzcyBvdmVycmlkZSA9IHRydWVcclxuICAgIG1lcmdlOiBmdW5jdGlvbiAobWFwLCBvdmVycmlkZSlcclxuICAgIHtcclxuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHVuZGVmaW5lZCkgeyBvdmVycmlkZSA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIHZhciBsb2NhbCA9IHRoaXMuZW50cmllcztcclxuICAgICAgICB2YXIgc291cmNlID0gbWFwLmVudHJpZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobG9jYWwuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvdmVycmlkZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBzb3VyY2Vba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdHJ1Y3RzL01hcC5qc1xuLy8gbW9kdWxlIGlkID0gMjM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRCb29sZWFuID0gZnVuY3Rpb24gKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpXHJcbntcclxuICAgIGlmICghc291cmNlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gc291cmNlW2tleV07XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qm9vbGVhbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9idWlsZGVyL0dldEJvb2xlYW4uanNcbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSlcclxue1xyXG4gICAgdmFyIHZhbHVlQ2FsbGJhY2s7XHJcblxyXG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ID0gdHlwZW9mKHNvdXJjZVtrZXldKTtcclxuXHJcbiAgICAgICAgaWYgKHQgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKGluZGV4LCB0b3RhbFRhcmdldHMsIHRhcmdldClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVtrZXldKGluZGV4LCB0b3RhbFRhcmdldHMsIHRhcmdldCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlW2tleV07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgIHtcclxuICAgICAgICB2YWx1ZUNhbGxiYWNrID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZUNhbGxiYWNrO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXROZXdWYWx1ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9idWlsZGVyL0dldE5ld1ZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcblxyXG52YXIgR2V0VGFyZ2V0cyA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHZhciB0YXJnZXRzID0gR2V0VmFsdWUoY29uZmlnLCAndGFyZ2V0cycsIG51bGwpO1xyXG5cclxuICAgIGlmICh0YXJnZXRzID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdGFyZ2V0cyA9PT0gJ2Z1bmN0aW9uJylcclxuICAgIHtcclxuICAgICAgICB0YXJnZXRzID0gdGFyZ2V0cy5jYWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldHMpKVxyXG4gICAge1xyXG4gICAgICAgIHRhcmdldHMgPSBbIHRhcmdldHMgXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0cztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VGFyZ2V0cztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9idWlsZGVyL0dldFRhcmdldHMuanNcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVFdFRU5fREVGQVVMVFMgPSB7XHJcbiAgICB0YXJnZXRzOiBudWxsLFxyXG4gICAgZGVsYXk6IDAsXHJcbiAgICBkdXJhdGlvbjogMTAwMCxcclxuICAgIGVhc2U6ICdQb3dlcjAnLFxyXG4gICAgZWFzZVBhcmFtczogbnVsbCxcclxuICAgIGhvbGQ6IDAsXHJcbiAgICByZXBlYXQ6IDAsXHJcbiAgICByZXBlYXREZWxheTogMCxcclxuICAgIHlveW86IGZhbHNlLFxyXG4gICAgZmxpcFg6IGZhbHNlLFxyXG4gICAgZmxpcFk6IGZhbHNlXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRXRUVOX0RFRkFVTFRTO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL3R3ZWVuL0RlZmF1bHRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xyXG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xyXG52YXIgU2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRDZW50ZXJYJyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgSW5Cb3R0b21DZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0Q2VudGVyWChnYW1lT2JqZWN0LCBHZXRDZW50ZXJYKGNvbnRhaW5lcikgKyBvZmZzZXRYKTtcclxuICAgIFNldEJvdHRvbShnYW1lT2JqZWN0LCBHZXRCb3R0b20oY29udGFpbmVyKSArIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbkJvdHRvbUNlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JbkJvdHRvbUNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldEJvdHRvbScpO1xyXG5cclxudmFyIEluQm90dG9tTGVmdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldExlZnQoY29udGFpbmVyKSAtIG9mZnNldFgpO1xyXG4gICAgU2V0Qm90dG9tKGdhbWVPYmplY3QsIEdldEJvdHRvbShjb250YWluZXIpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluQm90dG9tTGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JbkJvdHRvbUxlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgSW5Cb3R0b21SaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChjb250YWluZXIpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0Qm90dG9tKGNvbnRhaW5lcikgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5Cb3R0b21SaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JbkJvdHRvbVJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xyXG52YXIgR2V0Q2VudGVyWSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJZJyk7XHJcbnZhciBDZW50ZXJPbiA9IHJlcXVpcmUoJy4uL2JvdW5kcy9DZW50ZXJPbicpO1xyXG5cclxudmFyIEluQ2VudGVyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNvbnRhaW5lciwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIENlbnRlck9uKGdhbWVPYmplY3QsIEdldENlbnRlclgoY29udGFpbmVyKSArIG9mZnNldFgsIEdldENlbnRlclkoY29udGFpbmVyKSArIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbkNlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JbkNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWScpO1xyXG52YXIgU2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRMZWZ0Jyk7XHJcbnZhciBTZXRDZW50ZXJZID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclknKTtcclxuXHJcbnZhciBJbkxlZnRDZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0TGVmdChnYW1lT2JqZWN0LCBHZXRMZWZ0KGNvbnRhaW5lcikgLSBvZmZzZXRYKTtcclxuICAgIFNldENlbnRlclkoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWShjb250YWluZXIpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluTGVmdENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JbkxlZnRDZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWScpO1xyXG52YXIgU2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0UmlnaHQnKTtcclxudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWScpO1xyXG5cclxudmFyIEluUmlnaHRDZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0UmlnaHQoZ2FtZU9iamVjdCwgR2V0UmlnaHQoY29udGFpbmVyKSArIG9mZnNldFgpO1xyXG4gICAgU2V0Q2VudGVyWShnYW1lT2JqZWN0LCBHZXRDZW50ZXJZKGNvbnRhaW5lcikgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5SaWdodENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JblJpZ2h0Q2VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xyXG52YXIgR2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFRvcCcpO1xyXG52YXIgU2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRDZW50ZXJYJyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgSW5Ub3BDZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0Q2VudGVyWChnYW1lT2JqZWN0LCBHZXRDZW50ZXJYKGNvbnRhaW5lcikgKyBvZmZzZXRYKTtcclxuICAgIFNldFRvcChnYW1lT2JqZWN0LCBHZXRUb3AoY29udGFpbmVyKSAtIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJblRvcENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JblRvcENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFRvcCcpO1xyXG5cclxudmFyIEluVG9wTGVmdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldExlZnQoY29udGFpbmVyKSAtIG9mZnNldFgpO1xyXG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldFRvcChjb250YWluZXIpIC0gb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluVG9wTGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JblRvcExlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgSW5Ub3BSaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChjb250YWluZXIpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0VG9wKGNvbnRhaW5lcikgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5Ub3BSaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JblRvcFJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHRvcC1sZWZ0IGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIFRPUF9MRUZUOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHRvcC1jZW50ZXIgYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxyXG4gICAgKiBAY29uc3RhbnRcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgVE9QX0NFTlRFUjogMSxcclxuXHJcbiAgICAvKipcclxuICAgICogQSBjb25zdGFudCByZXByZXNlbnRpbmcgYSB0b3AtcmlnaHQgYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxyXG4gICAgKiBAY29uc3RhbnRcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgVE9QX1JJR0hUOiAyLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGxlZnQtdG9wIGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIExFRlRfVE9QOiAzLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGxlZnQtY2VudGVyIGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIExFRlRfQ0VOVEVSOiA0LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGxlZnQtYm90dG9tIGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIExFRlRfQk9UVE9NOiA1LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGNlbnRlciBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXHJcbiAgICAqIEBjb25zdGFudFxyXG4gICAgKiBAdHlwZSB7aW50ZWdlcn1cclxuICAgICovXHJcbiAgICBDRU5URVI6IDYsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGEgcmlnaHQtdG9wIGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIFJJR0hUX1RPUDogNyxcclxuXHJcbiAgICAvKipcclxuICAgICogQSBjb25zdGFudCByZXByZXNlbnRpbmcgYSByaWdodC1jZW50ZXIgYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxyXG4gICAgKiBAY29uc3RhbnRcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgUklHSFRfQ0VOVEVSOiA4LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHJpZ2h0LWJvdHRvbSBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXHJcbiAgICAqIEBjb25zdGFudFxyXG4gICAgKiBAdHlwZSB7aW50ZWdlcn1cclxuICAgICovXHJcbiAgICBSSUdIVF9CT1RUT006IDksXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGEgYm90dG9tLWxlZnQgYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxyXG4gICAgKiBAY29uc3RhbnRcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgQk9UVE9NX0xFRlQ6IDEwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGJvdHRvbS1jZW50ZXIgYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxyXG4gICAgKiBAY29uc3RhbnRcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgQk9UVE9NX0NFTlRFUjogMTEsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGEgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIEJPVFRPTV9SSUdIVDogMTJcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FsaWduL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ3JlYXRlIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcmFuZ2Ugb2YgbnVtYmVycyAodXN1YWxseSBpbnRlZ2VycyksIGJldHdlZW4sIGFuZCBpbmNsdXNpdmUgb2YsXHJcbiogdGhlIGdpdmVuIGBzdGFydGAgYW5kIGBlbmRgIGFyZ3VtZW50cy4gRm9yIGV4YW1wbGU6XHJcbipcclxuKiBgdmFyIGFycmF5ID0gbnVtYmVyQXJyYXkoMiwgNCk7IC8vIGFycmF5ID0gWzIsIDMsIDRdYFxyXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgwLCA5KTsgLy8gYXJyYXkgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV1gXHJcbiogXHJcbiogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBudW1iZXJBcnJheVN0ZXAoc3RhcnQsIGVuZCwgMSlgLlxyXG4qIFxyXG4qIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgcHJlZml4IGFuZCAvIG9yIHN1ZmZpeCBzdHJpbmcuIElmIGdpdmVuIHRoZSBhcnJheSB3aWxsIGNvbnRhaW5cclxuKiBzdHJpbmdzLCBub3QgaW50ZWdlcnMuIEZvciBleGFtcGxlOlxyXG4qIFxyXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgxLCA0LCAnTGV2ZWwgJyk7IC8vIGFycmF5ID0gW1wiTGV2ZWwgMVwiLCBcIkxldmVsIDJcIiwgXCJMZXZlbCAzXCIsIFwiTGV2ZWwgNFwiXWBcclxuKiBgdmFyIGFycmF5ID0gbnVtYmVyQXJyYXkoNSwgNywgJ0hELScsICcucG5nJyk7IC8vIGFycmF5ID0gW1wiSEQtNS5wbmdcIiwgXCJIRC02LnBuZ1wiLCBcIkhELTcucG5nXCJdYFxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQXJyYXlVdGlscyNudW1iZXJBcnJheVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFRoZSBtaW5pbXVtIHZhbHVlIHRoZSBhcnJheSBzdGFydHMgd2l0aC5cclxuKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gVGhlIG1heGltdW0gdmFsdWUgdGhlIGFycmF5IGNvbnRhaW5zLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSAtIE9wdGlvbmFsIHByZWZpeCB0byBwbGFjZSBiZWZvcmUgdGhlIG51bWJlci4gSWYgcHJvdmlkZWQgdGhlIGFycmF5IHdpbGwgY29udGFpbiBzdHJpbmdzLCBub3QgaW50ZWdlcnMuXHJcbiogQHBhcmFtIHtzdHJpbmd9IFtzdWZmaXhdIC0gT3B0aW9uYWwgc3VmZml4IHRvIHBsYWNlIGFmdGVyIHRoZSBudW1iZXIuIElmIHByb3ZpZGVkIHRoZSBhcnJheSB3aWxsIGNvbnRhaW4gc3RyaW5ncywgbm90IGludGVnZXJzLlxyXG4qIEByZXR1cm4ge251bWJlcltdfHN0cmluZ1tdfSBUaGUgYXJyYXkgb2YgbnVtYmVyIHZhbHVlcywgb3Igc3RyaW5ncyBpZiBhIHByZWZpeCBvciBzdWZmaXggd2FzIHByb3ZpZGVkLlxyXG4qL1xyXG52YXIgTnVtYmVyQXJyYXkgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcHJlZml4LCBzdWZmaXgpXHJcbntcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHByZWZpeCB8fCBzdWZmaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gKHByZWZpeCkgPyBwcmVmaXggKyBpLnRvU3RyaW5nKCkgOiBpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3VmZml4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkuY29uY2F0KHN1ZmZpeCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJBcnJheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9OdW1iZXJBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGlzIGlzIGZyb20gdGhlIHF1aWNrc2VsZWN0IG5wbSBwYWNrYWdlOiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9xdWlja3NlbGVjdFxyXG4vLyAgQ29kZWQgYnkgaHR0cHM6Ly93d3cubnBtanMuY29tL35tb3VybmVyIChWbGFkaW1pciBBZ2Fmb25raW4pXHJcblxyXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZCVFMiU4MCU5M1JpdmVzdF9hbGdvcml0aG1cclxuXHJcbi8vIEZsb3lkLVJpdmVzdCBzZWxlY3Rpb24gYWxnb3JpdGhtOlxyXG4vLyBSZWFycmFuZ2UgaXRlbXMgc28gdGhhdCBhbGwgaXRlbXMgaW4gdGhlIFtsZWZ0LCBrXSByYW5nZSBhcmUgc21hbGxlciB0aGFuIGFsbCBpdGVtcyBpbiAoaywgcmlnaHRdO1xyXG4vLyBUaGUgay10aCBlbGVtZW50IHdpbGwgaGF2ZSB0aGUgKGsgLSBsZWZ0ICsgMSl0aCBzbWFsbGVzdCB2YWx1ZSBpbiBbbGVmdCwgcmlnaHRdXHJcblxyXG52YXIgUXVpY2tTZWxlY3QgPSBmdW5jdGlvbiAoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSlcclxue1xyXG4gICAgbGVmdCA9IGxlZnQgfHwgMDtcclxuICAgIHJpZ2h0ID0gcmlnaHQgfHwgKGFyci5sZW5ndGggLSAxKTtcclxuICAgIGNvbXBhcmUgPSBjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlO1xyXG5cclxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcclxuICAgICAgICAgICAgdmFyIG0gPSBrIC0gbGVmdCArIDE7XHJcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XHJcbiAgICAgICAgICAgIHZhciBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcclxuICAgICAgICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xyXG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XHJcbiAgICAgICAgICAgIHZhciBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xyXG5cclxuICAgICAgICAgICAgUXVpY2tTZWxlY3QoYXJyLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdCA9IGFycltrXTtcclxuICAgICAgICB2YXIgaSA9IGxlZnQ7XHJcbiAgICAgICAgdmFyIGogPSByaWdodDtcclxuXHJcbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xyXG5cclxuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzd2FwKGFyciwgbGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUgKGkgPCBqKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xyXG5cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICBqLS07XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dhcChhcnIsIGxlZnQsIGopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaiA8PSBrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGVmdCA9IGogKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGsgPD0gailcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gaiAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gc3dhcCAoYXJyLCBpLCBqKVxyXG57XHJcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xyXG4gICAgYXJyW2ldID0gYXJyW2pdO1xyXG4gICAgYXJyW2pdID0gdG1wO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZSAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFF1aWNrU2VsZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FycmF5L1F1aWNrU2VsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNodWZmbGUgPSByZXF1aXJlKCcuL1NodWZmbGUnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vb2JqZWN0L0dldFZhbHVlJyk7XHJcblxyXG52YXIgQnVpbGRDaHVuayA9IGZ1bmN0aW9uIChhLCBiLCBxdHkpXHJcbntcclxuICAgIHZhciBvdXQgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBhSW5kZXggPSAwOyBhSW5kZXggPCBhLmxlbmd0aDsgYUluZGV4KyspXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgYkluZGV4ID0gMDsgYkluZGV4IDwgYi5sZW5ndGg7IGJJbmRleCsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdHk7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBhOiBhW2FJbmRleF0sIGI6IGJbYkluZGV4XSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLy8gIG9wdGlvbnMgPSByZXBlYXQsIHJhbmRvbSwgcmFuZG9tQiwgeW95bywgbWF4LCBxdHlcclxuXHJcbi8vICBSYW5nZSAoW2EsYixjXSwgWzEsMiwzXSkgPVxyXG4vLyAgYTEsIGEyLCBhMywgYjEsIGIyLCBiMywgYzEsIGMyLCBjM1xyXG5cclxuLy8gIFJhbmdlIChbYSxiXSwgWzEsMiwzXSwgcXR5ID0gMykgPVxyXG4vLyAgYTEsIGExLCBhMSwgYTIsIGEyLCBhMiwgYTMsIGEzLCBhMywgYjEsIGIxLCBiMSwgYjIsIGIyLCBiMiwgYjMsIGIzLCBiM1xyXG5cclxuLy8gIFJhbmdlIChbYSxiLGNdLCBbMSwyLDNdLCByZXBlYXQgeDEpID1cclxuLy8gIGExLCBhMiwgYTMsIGIxLCBiMiwgYjMsIGMxLCBjMiwgYzMsIGExLCBhMiwgYTMsIGIxLCBiMiwgYjMsIGMxLCBjMiwgYzNcclxuXHJcbi8vICBSYW5nZSAoW2EsYl0sIFsxLDJdLCByZXBlYXQgLTEgPSBlbmRsZXNzLCBtYXggPSAxNCkgPVxyXG4vLyAgTWF5YmUgaWYgbWF4IGlzIHNldCB0aGVuIHJlcGVhdCBnb2VzIHRvIC0xIGF1dG9tYXRpY2FsbHk/XHJcbi8vICBhMSwgYTIsIGIxLCBiMiwgYTEsIGEyLCBiMSwgYjIsIGExLCBhMiwgYjEsIGIyLCBhMSwgYTIgKGNhcHBlZCBhdCAxNCBlbGVtZW50cylcclxuXHJcbi8vICBSYW5nZSAoW2FdLCBbMSwyLDMsNCw1XSwgcmFuZG9tID0gdHJ1ZSkgPVxyXG4vLyAgYTQsIGExLCBhNSwgYTIsIGEzXHJcblxyXG4vLyAgUmFuZ2UgKFthLCBiXSwgWzEsMiwzXSwgcmFuZG9tID0gdHJ1ZSkgPVxyXG4vLyAgYjMsIGEyLCBhMSwgYjEsIGEzLCBiMlxyXG5cclxuLy8gIFJhbmdlIChbYSwgYiwgY10sIFsxLDIsM10sIHJhbmRvbUIgPSB0cnVlKSA9XHJcbi8vICBhMywgYTEsIGEyLCBiMiwgYjMsIGIxLCBjMSwgYzMsIGMyXHJcblxyXG4vLyAgUmFuZ2UgKFthXSwgWzEsMiwzLDQsNV0sIHlveW8gPSB0cnVlKSA9XHJcbi8vICBhMSwgYTIsIGEzLCBhNCwgYTUsIGE1LCBhNCwgYTMsIGEyLCBhMVxyXG5cclxuLy8gIFJhbmdlIChbYSwgYl0sIFsxLDIsM10sIHlveW8gPSB0cnVlKSA9XHJcbi8vICBhMSwgYTIsIGEzLCBiMSwgYjIsIGIzLCBiMywgYjIsIGIxLCBhMywgYTIsIGExXHJcblxyXG52YXIgUmFuZ2UgPSBmdW5jdGlvbiAoYSwgYiwgb3B0aW9ucylcclxue1xyXG4gICAgdmFyIG1heCA9IEdldFZhbHVlKG9wdGlvbnMsICdtYXgnLCAwKTtcclxuICAgIHZhciBxdHkgPSBHZXRWYWx1ZShvcHRpb25zLCAncXR5JywgMSk7XHJcbiAgICB2YXIgcmFuZG9tID0gR2V0VmFsdWUob3B0aW9ucywgJ3JhbmRvbScsIGZhbHNlKTtcclxuICAgIHZhciByYW5kb21CID0gR2V0VmFsdWUob3B0aW9ucywgJ3JhbmRvbUInLCBmYWxzZSk7XHJcbiAgICB2YXIgcmVwZWF0ID0gR2V0VmFsdWUob3B0aW9ucywgJ3JlcGVhdCcsIDApO1xyXG4gICAgdmFyIHlveW8gPSBHZXRWYWx1ZShvcHRpb25zLCAneW95bycsIGZhbHNlKTtcclxuXHJcbiAgICB2YXIgb3V0ID0gW107XHJcblxyXG4gICAgaWYgKHJhbmRvbUIpXHJcbiAgICB7XHJcbiAgICAgICAgU2h1ZmZsZShiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRW5kbGVzcyByZXBlYXQsIHNvIGxpbWl0IGJ5IG1heFxyXG4gICAgaWYgKHJlcGVhdCA9PT0gLTEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG1heCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlcGVhdCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBXb3JrIG91dCBob3cgbWFueSByZXBlYXRzIHdlIG5lZWRcclxuICAgICAgICAgICAgdmFyIHRvdGFsID0gKGEubGVuZ3RoICogYi5sZW5ndGgpICogcXR5O1xyXG5cclxuICAgICAgICAgICAgaWYgKHlveW8pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsICo9IDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlcGVhdCA9IE1hdGguY2VpbChtYXggLyB0b3RhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHJlcGVhdDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjaHVuayA9IEJ1aWxkQ2h1bmsoYSwgYiwgcXR5KTtcclxuXHJcbiAgICAgICAgaWYgKHJhbmRvbSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNodWZmbGUoY2h1bmspO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChjaHVuayk7XHJcblxyXG4gICAgICAgIGlmICh5b3lvKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2h1bmsucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChjaHVuayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChtYXgpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0LnNwbGljZShtYXgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FycmF5L1JhbmdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogTW92ZXMgdGhlIGVsZW1lbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheSB0byB0aGUgZW5kLCBzaGlmdGluZyBhbGwgaXRlbXMgaW4gdGhlIHByb2Nlc3MuXHJcbiogVGhlIFwicm90YXRpb25cIiBoYXBwZW5zIHRvIHRoZSBsZWZ0LlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQXJyYXlVdGlscy5yb3RhdGVcclxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaGlmdC9yb3RhdGUuIFRoZSBhcnJheSBpcyBtb2RpZmllZC5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IFt0b3RhbD0xXSAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gc2hpZnQgdGhlIGFycmF5LiBPbmx5IHRoZSBtb3N0IHJlY2VudGx5IHNoaWZ0ZWQgZWxlbWVudCBpcyByZXR1cm5lZC5cclxuKiBAcmV0dXJuIHthbnl9IFRoZSBzaGlmdGVkIHZhbHVlLlxyXG4qL1xyXG52YXIgUm90YXRlTGVmdCA9IGZ1bmN0aW9uIChhcnJheSwgdG90YWwpXHJcbntcclxuICAgIGlmICh0b3RhbCA9PT0gdW5kZWZpbmVkKSB7IHRvdGFsID0gMTsgfVxyXG5cclxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgZWxlbWVudCA9IGFycmF5LnNoaWZ0KCk7XHJcbiAgICAgICAgYXJyYXkucHVzaChlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlTGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9Sb3RhdGVMZWZ0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogTW92ZXMgdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gdGhlIHN0YXJ0LCBzaGlmdGluZyBhbGwgaXRlbXMgaW4gdGhlIHByb2Nlc3MuXHJcbiogVGhlIFwicm90YXRpb25cIiBoYXBwZW5zIHRvIHRoZSByaWdodC5cclxuKlxyXG4qIEBwYXJhbSB7YW55W119IGFycmF5IC0gVGhlIGFycmF5IHRvIHNoaWZ0L3JvdGF0ZS4gVGhlIGFycmF5IGlzIG1vZGlmaWVkLlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gW3RvdGFsPTFdIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBzaGlmdCB0aGUgYXJyYXkuIE9ubHkgdGhlIG1vc3QgcmVjZW50bHkgc2hpZnRlZCBlbGVtZW50IGlzIHJldHVybmVkLlxyXG4qIEByZXR1cm4ge2FueX0gVGhlIHNoaWZ0ZWQgdmFsdWUuXHJcbiovXHJcbnZhciBSb3RhdGVSaWdodCA9IGZ1bmN0aW9uIChhcnJheSwgdG90YWwpXHJcbntcclxuICAgIGlmICh0b3RhbCA9PT0gdW5kZWZpbmVkKSB7IHRvdGFsID0gMTsgfVxyXG5cclxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgZWxlbWVudCA9IGFycmF5LnBvcCgpO1xyXG4gICAgICAgIGFycmF5LnVuc2hpZnQoZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZVJpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FycmF5L1JvdGF0ZVJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQSBzdGFuZGFyZCBGaXNoZXItWWF0ZXMgQXJyYXkgc2h1ZmZsZSBpbXBsZW1lbnRhdGlvbiB3aGljaCBtb2RpZmllcyB0aGUgYXJyYXkgaW4gcGxhY2UuXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHthbnlbXX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cclxuKiBAcmV0dXJuIHthbnlbXX0gVGhlIG9yaWdpbmFsIGFycmF5LCBub3cgc2h1ZmZsZWQuXHJcbiovXHJcbnZhciBTaHVmZmxlID0gZnVuY3Rpb24gKGFycmF5KVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xyXG4gICAgICAgIHZhciB0ZW1wID0gYXJyYXlbaV07XHJcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcclxuICAgICAgICBhcnJheVtqXSA9IHRlbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaHVmZmxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FycmF5L1NodWZmbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUmVtb3ZlcyBhIHNpbmdsZSBpdGVtIGZyb20gYW4gYXJyYXkgYW5kIHJldHVybnMgaXRcclxuLy8gIHdpdGhvdXQgY3JlYXRpbmcgZ2MgKGxpa2UgdGhlIG5hdGl2ZSBzcGxpY2UgZG9lcylcclxuLy8gIEJhc2VkIG9uIGNvZGUgYnkgTWlrZSBSZWluc3RlaW5cclxuXHJcbnZhciBTcGxpY2VPbmUgPSBmdW5jdGlvbiAoYXJyYXksIGluZGV4KVxyXG57XHJcbiAgICBpZiAoaW5kZXggPj0gYXJyYXkubGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoIC0gMTtcclxuXHJcbiAgICB2YXIgaXRlbSA9IGFycmF5W2luZGV4XTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPCBsZW47IGkrKylcclxuICAgIHtcclxuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgKyAxXTtcclxuICAgIH1cclxuXHJcbiAgICBhcnJheS5sZW5ndGggPSBsZW47XHJcblxyXG4gICAgcmV0dXJuIGl0ZW07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwbGljZU9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9TcGxpY2VPbmUuanNcbi8vIG1vZHVsZSBpZCA9IDI1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyEgc3RhYmxlLmpzIDAuMS42LCBodHRwczovL2dpdGh1Yi5jb20vVHdvLVNjcmVlbi9zdGFibGVcclxuLy8hIMKpIDIwMTcgQW5ncnkgQnl0ZXMgYW5kIGNvbnRyaWJ1dG9ycy4gTUlUIGxpY2Vuc2VkLlxyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuLy8gQSBzdGFibGUgYXJyYXkgc29ydCwgYmVjYXVzZSBgQXJyYXkjc29ydCgpYCBpcyBub3QgZ3VhcmFudGVlZCBzdGFibGUuXHJcbi8vIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgbWVyZ2Ugc29ydCwgd2l0aG91dCByZWN1cnNpb24uXHJcblxyXG52YXIgc3RhYmxlID0gZnVuY3Rpb24oYXJyLCBjb21wKSB7XHJcbiAgICByZXR1cm4gZXhlYyhhcnIuc2xpY2UoKSwgY29tcCk7XHJcbn07XHJcblxyXG5zdGFibGUuaW5wbGFjZSA9IGZ1bmN0aW9uKGFyciwgY29tcCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IGV4ZWMoYXJyLCBjb21wKTtcclxuXHJcbiAgICAvLyBUaGlzIHNpbXBseSBjb3BpZXMgYmFjayBpZiB0aGUgcmVzdWx0IGlzbid0IGluIHRoZSBvcmlnaW5hbCBhcnJheSxcclxuICAgIC8vIHdoaWNoIGhhcHBlbnMgb24gYW4gb2RkIG51bWJlciBvZiBwYXNzZXMuXHJcbiAgICBpZiAocmVzdWx0ICE9PSBhcnIpIHtcclxuICAgICAgICBwYXNzKHJlc3VsdCwgbnVsbCwgYXJyLmxlbmd0aCwgYXJyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXJyO1xyXG59O1xyXG5cclxuLy8gRXhlY3V0ZSB0aGUgc29ydCB1c2luZyB0aGUgaW5wdXQgYXJyYXkgYW5kIGEgc2Vjb25kIGJ1ZmZlciBhcyB3b3JrIHNwYWNlLlxyXG4vLyBSZXR1cm5zIG9uZSBvZiB0aG9zZSB0d28sIGNvbnRhaW5pbmcgdGhlIGZpbmFsIHJlc3VsdC5cclxuZnVuY3Rpb24gZXhlYyhhcnIsIGNvbXApIHtcclxuICAgIGlmICh0eXBlb2YoY29tcCkgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjb21wID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoYik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaG9ydC1jaXJjdWl0IHdoZW4gdGhlcmUncyBub3RoaW5nIHRvIHNvcnQuXHJcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgIGlmIChsZW4gPD0gMSkge1xyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmF0aGVyIHRoYW4gZGl2aWRpbmcgaW5wdXQsIHNpbXBseSBpdGVyYXRlIGNodW5rcyBvZiAxLCAyLCA0LCA4LCBldGMuXHJcbiAgICAvLyBDaHVua3MgYXJlIHRoZSBzaXplIG9mIHRoZSBsZWZ0IG9yIHJpZ2h0IGhhbmQgaW4gbWVyZ2Ugc29ydC5cclxuICAgIC8vIFN0b3Agd2hlbiB0aGUgbGVmdC1oYW5kIGNvdmVycyBhbGwgb2YgdGhlIGFycmF5LlxyXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsZW4pO1xyXG4gICAgZm9yICh2YXIgY2hrID0gMTsgY2hrIDwgbGVuOyBjaGsgKj0gMikge1xyXG4gICAgICAgIHBhc3MoYXJyLCBjb21wLCBjaGssIGJ1ZmZlcik7XHJcblxyXG4gICAgICAgIHZhciB0bXAgPSBhcnI7XHJcbiAgICAgICAgYXJyID0gYnVmZmVyO1xyXG4gICAgICAgIGJ1ZmZlciA9IHRtcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXJyO1xyXG59XHJcblxyXG4vLyBSdW4gYSBzaW5nbGUgcGFzcyB3aXRoIHRoZSBnaXZlbiBjaHVuayBzaXplLlxyXG52YXIgcGFzcyA9IGZ1bmN0aW9uKGFyciwgY29tcCwgY2hrLCByZXN1bHQpIHtcclxuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgLy8gU3RlcCBzaXplIC8gZG91YmxlIGNodW5rIHNpemUuXHJcbiAgICB2YXIgZGJsID0gY2hrICogMjtcclxuICAgIC8vIEJvdW5kcyBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgY2h1bmtzLlxyXG4gICAgdmFyIGwsIHIsIGU7XHJcbiAgICAvLyBJdGVyYXRvcnMgb3ZlciB0aGUgbGVmdCBhbmQgcmlnaHQgY2h1bmsuXHJcbiAgICB2YXIgbGksIHJpO1xyXG5cclxuICAgIC8vIEl0ZXJhdGUgb3ZlciBwYWlycyBvZiBjaHVua3MuXHJcbiAgICBmb3IgKGwgPSAwOyBsIDwgbGVuOyBsICs9IGRibCkge1xyXG4gICAgICAgIHIgPSBsICsgY2hrO1xyXG4gICAgICAgIGUgPSByICsgY2hrO1xyXG4gICAgICAgIGlmIChyID4gbGVuKSByID0gbGVuO1xyXG4gICAgICAgIGlmIChlID4gbGVuKSBlID0gbGVuO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXRlIGJvdGggY2h1bmtzIGluIHBhcmFsbGVsLlxyXG4gICAgICAgIGxpID0gbDtcclxuICAgICAgICByaSA9IHI7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgLy8gQ29tcGFyZSB0aGUgY2h1bmtzLlxyXG4gICAgICAgICAgICBpZiAobGkgPCByICYmIHJpIDwgZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3b3JrcyBmb3IgYSByZWd1bGFyIGBzb3J0KClgIGNvbXBhdGlibGUgY29tcGFyYXRvcixcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBhbHNvIGZvciBhIHNpbXBsZSBjb21wYXJhdG9yIGxpa2U6IGBhID4gYmBcclxuICAgICAgICAgICAgICAgIGlmIChjb21wKGFycltsaV0sIGFycltyaV0pIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IGFycltsaSsrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW3JpKytdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gY29tcGFyZSwganVzdCBmbHVzaCB3aGF0J3MgbGVmdC5cclxuICAgICAgICAgICAgZWxzZSBpZiAobGkgPCByKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IGFycltsaSsrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyaSA8IGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW3JpKytdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEJvdGggaXRlcmF0b3JzIGFyZSBhdCB0aGUgY2h1bmsgZW5kcy5cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8vIEV4cG9ydCB1c2luZyBDb21tb25KUyBvciB0byB0aGUgd2luZG93LlxyXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0YWJsZTtcclxufVxyXG5lbHNlIHtcclxuICAgIHdpbmRvdy5zdGFibGUgPSBzdGFibGU7XHJcbn1cclxuXHJcbn0pKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9TdGFibGVTb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldENlbnRlclggPSByZXF1aXJlKCcuL1NldENlbnRlclgnKTtcclxudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuL1NldENlbnRlclknKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBjZW50ZXIgeCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGAoeCAtIG9mZnNldFgpICsgKHdpZHRoIC8gMilgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGNlbnRlclhcclxuKi9cclxuXHJcbnZhciBDZW50ZXJPbiA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB4LCB5KVxyXG57XHJcbiAgICBTZXRDZW50ZXJYKGdhbWVPYmplY3QsIHgpO1xyXG5cclxuICAgIHJldHVybiBTZXRDZW50ZXJZKGdhbWVPYmplY3QsIHkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9ib3VuZHMvQ2VudGVyT24uanNcbi8vIG1vZHVsZSBpZCA9IDI1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGlzIGlzIGEgc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBqUXVlcnkuaXNQbGFpbk9iamVjdC5cclxuKiBBIHBsYWluIG9iamVjdCBpcyBhbiBvYmplY3Qgd2hvc2UgaW50ZXJuYWwgY2xhc3MgcHJvcGVydHkgaXMgW29iamVjdCBPYmplY3RdLlxyXG4qIEBtZXRob2QgUGhhc2VyLlV0aWxzLmlzUGxhaW5PYmplY3RcclxuKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byBpbnNwZWN0LlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIHBsYWluLCBvdGhlcndpc2UgZmFsc2UuXHJcbiovXHJcbnZhciBJc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKG9iailcclxue1xyXG4gICAgLy8gTm90IHBsYWluIG9iamVjdHM6XHJcbiAgICAvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXHJcbiAgICAvLyAtIERPTSBub2Rlc1xyXG4gICAgLy8gLSB3aW5kb3dcclxuICAgIGlmICh0eXBlb2Yob2JqKSAhPT0gJ29iamVjdCcgfHwgb2JqLm5vZGVUeXBlIHx8IG9iaiA9PT0gb2JqLndpbmRvdylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3VwcG9ydDogRmlyZWZveCA8MjBcclxuICAgIC8vIFRoZSB0cnkvY2F0Y2ggc3VwcHJlc3NlcyBleGNlcHRpb25zIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYWNjZXNzXHJcbiAgICAvLyB0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IG9mIGNlcnRhaW4gaG9zdCBvYmplY3RzLCBpZS4gfHdpbmRvdy5sb2NhdGlvbnxcclxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTgxNDYyMlxyXG4gICAgdHJ5XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG9iai5jb25zdHJ1Y3RvciAmJiAhKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICdpc1Byb3RvdHlwZU9mJykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgcmV0dXJuZWQgYWxyZWFkeSwgd2UncmUgY29uZmlkZW50IHRoYXRcclxuICAgIC8vIHxvYmp8IGlzIGEgcGxhaW4gb2JqZWN0LCBjcmVhdGVkIGJ5IHt9IG9yIGNvbnN0cnVjdGVkIHdpdGggbmV3IE9iamVjdFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElzUGxhaW5PYmplY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvb2JqZWN0L0lzUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDI1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUYWtlcyB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCBwYWRzIGl0IG91dCwgdG8gdGhlIGxlbmd0aCByZXF1aXJlZCwgdXNpbmcgdGhlIGNoYXJhY3RlclxyXG4qIHNwZWNpZmllZC4gRm9yIGV4YW1wbGUgaWYgeW91IG5lZWQgYSBzdHJpbmcgdG8gYmUgNiBjaGFyYWN0ZXJzIGxvbmcsIHlvdSBjYW4gY2FsbDpcclxuKlxyXG4qIGBwYWQoJ2JvYicsIDYsICctJywgMilgXHJcbipcclxuKiBUaGlzIHdvdWxkIHJldHVybjogYGJvYi0tLWAgYXMgaXQgaGFzIHBhZGRlZCBpdCBvdXQgdG8gNiBjaGFyYWN0ZXJzLCB1c2luZyB0aGUgYC1gIG9uIHRoZSByaWdodC5cclxuKlxyXG4qIFlvdSBjYW4gYWxzbyB1c2UgaXQgdG8gcGFkIG51bWJlcnMgKHRoZXkgYXJlIGFsd2F5cyByZXR1cm5lZCBhcyBzdHJpbmdzKTpcclxuKiBcclxuKiBgcGFkKDUxMiwgNiwgJzAnLCAxKWBcclxuKlxyXG4qIFdvdWxkIHJldHVybjogYDAwMDUxMmAgd2l0aCB0aGUgc3RyaW5nIHBhZGRlZCB0byB0aGUgbGVmdC5cclxuKlxyXG4qIElmIHlvdSBkb24ndCBzcGVjaWZ5IGEgZGlyZWN0aW9uIGl0J2xsIHBhZCB0byBib3RoIHNpZGVzOlxyXG4qIFxyXG4qIGBwYWQoJ2M2NCcsIDcsICcqJylgXHJcbipcclxuKiBXb3VsZCByZXR1cm46IGAqKmM2NCoqYFxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuVXRpbHMucGFkXHJcbiogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSB0YXJnZXQgc3RyaW5nLiBgdG9TdHJpbmcoKWAgd2lsbCBiZSBjYWxsZWQgb24gdGhlIHN0cmluZywgd2hpY2ggbWVhbnMgeW91IGNhbiBhbHNvIHBhc3MgaW4gY29tbW9uIGRhdGEgdHlwZXMgbGlrZSBudW1iZXJzLlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gW2xlbj0wXSAtIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBiZSBhZGRlZC5cclxuKiBAcGFyYW0ge3N0cmluZ30gW3BhZD1cIiBcIl0gLSBUaGUgc3RyaW5nIHRvIHBhZCBpdCBvdXQgd2l0aCAoZGVmYXVsdHMgdG8gYSBzcGFjZSkuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBbZGlyPTNdIC0gVGhlIGRpcmVjdGlvbiBkaXIgPSAxIChsZWZ0KSwgMiAocmlnaHQpLCAzIChib3RoKS5cclxuKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYWRkZWQgc3RyaW5nLlxyXG4qL1xyXG52YXIgUGFkID0gZnVuY3Rpb24gKHN0ciwgbGVuLCBwYWQsIGRpcilcclxue1xyXG4gICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB7IGxlbiA9IDA7IH1cclxuICAgIGlmIChwYWQgPT09IHVuZGVmaW5lZCkgeyBwYWQgPSAnICc7IH1cclxuICAgIGlmIChkaXIgPT09IHVuZGVmaW5lZCkgeyBkaXIgPSAzOyB9XHJcblxyXG4gICAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgdmFyIHBhZGxlbiA9IDA7XHJcblxyXG4gICAgaWYgKGxlbiArIDEgPj0gc3RyLmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICBzd2l0Y2ggKGRpcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHN0ciA9IG5ldyBBcnJheShsZW4gKyAxIC0gc3RyLmxlbmd0aCkuam9pbihwYWQpICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBNYXRoLmNlaWwoKHBhZGxlbiA9IGxlbiAtIHN0ci5sZW5ndGgpIC8gMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHBhZGxlbiAtIHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgc3RyID0gbmV3IEFycmF5KGxlZnQgKyAxKS5qb2luKHBhZCkgKyBzdHIgKyBuZXcgQXJyYXkocmlnaHQgKyAxKS5qb2luKHBhZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIgKyBuZXcgQXJyYXkobGVuICsgMSAtIHN0ci5sZW5ndGgpLmpvaW4ocGFkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvc3RyaW5nL1BhZC5qc1xuLy8gbW9kdWxlIGlkID0gMjU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDb25maWcgPSByZXF1aXJlKCcuL0NvbmZpZycpO1xyXG52YXIgRGVidWdIZWFkZXIgPSByZXF1aXJlKCcuL0RlYnVnSGVhZGVyJyk7XHJcbnZhciBEZXZpY2UgPSByZXF1aXJlKCcuLi9kZXZpY2UnKTtcclxudmFyIE5PT1AgPSByZXF1aXJlKCcuLi91dGlscy9OT09QJyk7XHJcblxyXG52YXIgQWRkVG9ET00gPSByZXF1aXJlKCcuLi9kb20vQWRkVG9ET00nKTtcclxudmFyIERPTUNvbnRlbnRMb2FkZWQgPSByZXF1aXJlKCcuLi9kb20vRE9NQ29udGVudExvYWRlZCcpO1xyXG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xyXG52YXIgVmlzaWJpbGl0eUhhbmRsZXIgPSByZXF1aXJlKCcuL1Zpc2liaWxpdHlIYW5kbGVyJyk7XHJcblxyXG52YXIgQW5pbWF0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4uL2FuaW1hdGlvbi9tYW5hZ2VyL0FuaW1hdGlvbk1hbmFnZXInKTtcclxudmFyIENyZWF0ZVJlbmRlcmVyID0gcmVxdWlyZSgnLi9DcmVhdGVSZW5kZXJlcicpO1xyXG52YXIgRGF0YSA9IHJlcXVpcmUoJy4uL3NjZW5lL3BsdWdpbnMvRGF0YScpO1xyXG52YXIgR2xvYmFsQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZS9HbG9iYWxDYWNoZScpO1xyXG52YXIgR2xvYmFsSW5wdXRNYW5hZ2VyID0gcmVxdWlyZSgnLi4vaW5wdXQvZ2xvYmFsL0dsb2JhbElucHV0TWFuYWdlcicpO1xyXG52YXIgR2xvYmFsU2NlbmVNYW5hZ2VyID0gcmVxdWlyZSgnLi4vc2NlbmUvZ2xvYmFsL0dsb2JhbFNjZW5lTWFuYWdlcicpO1xyXG52YXIgVGV4dHVyZU1hbmFnZXIgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlcicpO1xyXG52YXIgVGltZVN0ZXAgPSByZXF1aXJlKCcuL1RpbWVTdGVwJyk7XHJcblxyXG52YXIgR2FtZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBHYW1lIChjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKGNvbmZpZyk7XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLmlzQm9vdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbXMgPSBuZXcgQW5pbWF0aW9uTWFuYWdlcih0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IG5ldyBUZXh0dXJlTWFuYWdlcih0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBHbG9iYWxDYWNoZSh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IG5ldyBEYXRhKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLmlucHV0ID0gbmV3IEdsb2JhbElucHV0TWFuYWdlcih0aGlzLCB0aGlzLmNvbmZpZyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBuZXcgR2xvYmFsU2NlbmVNYW5hZ2VyKHRoaXMsIHRoaXMuY29uZmlnLnNjZW5lQ29uZmlnKTtcclxuXHJcbiAgICAgICAgdGhpcy5kZXZpY2UgPSBEZXZpY2U7XHJcblxyXG4gICAgICAgIHRoaXMubG9vcCA9IG5ldyBUaW1lU3RlcCh0aGlzLCB0aGlzLmNvbmZpZy5mcHMpO1xyXG5cclxuICAgICAgICB0aGlzLm9uU3RlcENhbGxiYWNrID0gTk9PUDtcclxuXHJcbiAgICAgICAgLy8gIFdhaXQgZm9yIHRoZSBET00gUmVhZHkgZXZlbnQsIHRoZW4gY2FsbCBib290LlxyXG4gICAgICAgIERPTUNvbnRlbnRMb2FkZWQodGhpcy5ib290LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAvLyAgRm9yIGRlYnVnZ2luZyBvbmx5XHJcbiAgICAgICAgd2luZG93LmdhbWUgPSB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBib290OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaXNCb290ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZy5wcmVCb290KCk7XHJcblxyXG4gICAgICAgIENyZWF0ZVJlbmRlcmVyKHRoaXMpO1xyXG5cclxuICAgICAgICBEZWJ1Z0hlYWRlcih0aGlzKTtcclxuXHJcbiAgICAgICAgQWRkVG9ET00odGhpcy5jYW52YXMsIHRoaXMuY29uZmlnLnBhcmVudCk7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZXMuYm9vdCgpO1xyXG5cclxuICAgICAgICB0aGlzLmFuaW1zLmJvb3QodGhpcy50ZXh0dXJlcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2NlbmUuYm9vdCgpO1xyXG5cclxuICAgICAgICB0aGlzLmlucHV0LmJvb3QoKTtcclxuXHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZy5wb3N0Qm9vdCgpO1xyXG5cclxuICAgICAgICB0aGlzLmxvb3Auc3RhcnQodGhpcy5zdGVwLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICBWaXNpYmlsaXR5SGFuZGxlcih0aGlzLmV2ZW50cyk7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdISURERU4nLCB0aGlzLm9uSGlkZGVuLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdWSVNJQkxFJywgdGhpcy5vblZpc2libGUuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ09OX0JMVVInLCB0aGlzLm9uQmx1ci5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLmV2ZW50cy5vbignT05fRk9DVVMnLCB0aGlzLm9uRm9jdXMuYmluZCh0aGlzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0ZXA6IGZ1bmN0aW9uICh0aW1lLCBkZWx0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYWN0aXZlID0gdGhpcy5zY2VuZS5hY3RpdmU7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuXHJcbiAgICAgICAgLy8gIEdsb2JhbCBNYW5hZ2VycyAoVGltZSwgSW5wdXQsIGV0YylcclxuXHJcbiAgICAgICAgdGhpcy5pbnB1dC51cGRhdGUodGltZSwgZGVsdGEpO1xyXG5cclxuICAgICAgICAvLyAgU2NlbmVzXHJcblxyXG4gICAgICAgIHRoaXMub25TdGVwQ2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhY3RpdmVbaV0uc2NlbmUuc3lzLnN0ZXAodGltZSwgZGVsdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFJlbmRlclxyXG5cclxuICAgICAgICAvLyB2YXIgaW50ZXJwb2xhdGlvbiA9IHRoaXMuZnJhbWVEZWx0YSAvIHRoaXMudGltZXN0ZXA7XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnByZVJlbmRlcigpO1xyXG5cclxuICAgICAgICAvLyAgVGhpcyB1c2VzIGFjdGl2ZS5sZW5ndGgsIGluIGNhc2Ugc2NlbmUudXBkYXRlIHJlbW92ZWQgdGhlIHNjZW5lIGZyb20gdGhlIGFjdGl2ZSBsaXN0XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVtpXS5zY2VuZS5zeXMucmVuZGVyKDAsIHJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnBvc3RSZW5kZXIoKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25IaWRkZW46IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5sb29wLnBhdXNlKCk7XHJcblxyXG4gICAgICAgIC8vIHZhciBhY3RpdmUgPSB0aGlzLnNjZW5lLmFjdGl2ZTtcclxuXHJcbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIC8vICAgICBhY3RpdmVbaV0uc2NlbmUuc3lzLnBhdXNlKCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfSxcclxuXHJcbiAgICBvblZpc2libGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5sb29wLnJlc3VtZSgpO1xyXG5cclxuICAgICAgICAvLyB2YXIgYWN0aXZlID0gdGhpcy5zY2VuZS5hY3RpdmU7XHJcblxyXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgYWN0aXZlW2ldLnNjZW5lLnN5cy5yZXN1bWUoKTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9LFxyXG5cclxuICAgIG9uQmx1cjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmxvb3AuYmx1cigpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkZvY3VzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubG9vcC5mb2N1cygpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYm9vdC9HYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5DYW1lcmFzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBDYW1lcmE6IHJlcXVpcmUoJy4vMmQvQ2FtZXJhJyksXHJcbiAgICBQZXJzcGVjdGl2ZUNhbWVyYTogcmVxdWlyZSgnLi8zZC9QZXJzcGVjdGl2ZUNhbWVyYScpLFxyXG4gICAgT3J0aG9ncmFwaGljQ2FtZXJhOiByZXF1aXJlKCcuLzNkL09ydGhvZ3JhcGhpY0NhbWVyYScpLFxyXG5cclxuICAgIEtleUNvbnRyb2w6IHJlcXVpcmUoJy4vY29udHJvbHMvS2V5Q29udHJvbCcpLFxyXG4gICAgU21vb3RoZWRLZXlDb250cm9sOiByZXF1aXJlKCcuL2NvbnRyb2xzL1Ntb290aGVkS2V5Q29udHJvbCcpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuQ3JlYXRlXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBcclxuICAgIEdlbmVyYXRlVGV4dHVyZTogcmVxdWlyZSgnLi9HZW5lcmF0ZVRleHR1cmUnKSxcclxuICAgIEdyaWQ6IHJlcXVpcmUoJy4vR3JpZCcpLFxyXG4gICAgUGFsZXR0ZXM6IHJlcXVpcmUoJy4vcGFsZXR0ZXMnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jcmVhdGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkRPTVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQWRkRXZlbnRMaXN0ZW5lcjogcmVxdWlyZSgnLi9BZGRFdmVudExpc3RlbmVyJyksXHJcbiAgICBBZGRUb0RPTTogcmVxdWlyZSgnLi9BZGRUb0RPTScpLFxyXG4gICAgQ2FudmFzSW50ZXJwb2xhdGlvbjogcmVxdWlyZSgnLi9DYW52YXNJbnRlcnBvbGF0aW9uJyksXHJcbiAgICBDYW52YXNQb29sOiByZXF1aXJlKCcuL0NhbnZhc1Bvb2wnKSxcclxuICAgIERPTUNvbnRlbnRMb2FkZWQ6IHJlcXVpcmUoJy4vRE9NQ29udGVudExvYWRlZCcpLFxyXG4gICAgUGFyc2VYTUw6IHJlcXVpcmUoJy4vUGFyc2VYTUwnKSxcclxuICAgIFJlbW92ZUV2ZW50TGlzdGVuZXI6IHJlcXVpcmUoJy4vUmVtb3ZlRXZlbnRMaXN0ZW5lcicpLFxyXG4gICAgUmVtb3ZlRnJvbURPTTogcmVxdWlyZSgnLi9SZW1vdmVGcm9tRE9NJyksXHJcbiAgICBSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHJlcXVpcmUoJy4vUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyksXHJcbiAgICBTbW9vdGhpbmc6IHJlcXVpcmUoJy4vU21vb3RoaW5nJyksXHJcbiAgICBUb3VjaEFjdGlvbjogcmVxdWlyZSgnLi9Ub3VjaEFjdGlvbicpLFxyXG4gICAgVXNlclNlbGVjdDogcmVxdWlyZSgnLi9Vc2VyU2VsZWN0JylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9tL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HYW1lT2JqZWN0c1xyXG5cclxudmFyIEdhbWVPYmplY3RzID0ge1xyXG5cclxuICAgIENvbXBvbmVudHM6IHJlcXVpcmUoJy4vY29tcG9uZW50cycpLFxyXG5cclxuICAgIEJpdG1hcFRleHQ6IHJlcXVpcmUoJy4vYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dCcpLFxyXG4gICAgQmxpdHRlcjogcmVxdWlyZSgnLi9ibGl0dGVyL0JsaXR0ZXInKSxcclxuICAgIER5bmFtaWNCaXRtYXBUZXh0OiByZXF1aXJlKCcuL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dCcpLFxyXG4gICAgR3JhcGhpY3M6IHJlcXVpcmUoJy4vZ3JhcGhpY3MvR3JhcGhpY3MuanMnKSxcclxuICAgIEdyb3VwOiByZXF1aXJlKCcuL2dyb3VwL0dyb3VwJyksXHJcbiAgICBJbWFnZTogcmVxdWlyZSgnLi9pbWFnZS9JbWFnZScpLFxyXG4gICAgT2JqZWN0UG9vbDogcmVxdWlyZSgnLi9wb29sL09iamVjdFBvb2wuanMnKSxcclxuICAgIFBhcnRpY2xlRW1pdHRlcjogcmVxdWlyZSgnLi9lbWl0dGVyL1BhcnRpY2xlRW1pdHRlcicpLFxyXG4gICAgU3ByaXRlOiByZXF1aXJlKCcuL3Nwcml0ZS9TcHJpdGUnKSxcclxuICAgIFNwcml0ZTNEOiByZXF1aXJlKCcuL3Nwcml0ZTNkL1Nwcml0ZTNEJyksXHJcbiAgICBTdGF0aWNUaWxlbWFwOiByZXF1aXJlKCcuL3RpbGVtYXAvc3RhdGljL1N0YXRpY1RpbGVtYXAnKSxcclxuICAgIFRleHQ6IHJlcXVpcmUoJy4vdGV4dC9zdGF0aWMvVGV4dCcpLFxyXG4gICAgVGlsZW1hcDogcmVxdWlyZSgnLi90aWxlbWFwL2R5bmFtaWMvVGlsZW1hcCcpLFxyXG4gICAgVGlsZVNwcml0ZTogcmVxdWlyZSgnLi90aWxlc3ByaXRlL1RpbGVTcHJpdGUnKSxcclxuICAgIFpvbmU6IHJlcXVpcmUoJy4vem9uZS9ab25lJyksXHJcblxyXG4gICAgLy8gIEdhbWUgT2JqZWN0IEZhY3Rvcmllc1xyXG5cclxuICAgIEZhY3Rvcmllczoge1xyXG4gICAgICAgIEJsaXR0ZXI6IHJlcXVpcmUoJy4vYmxpdHRlci9CbGl0dGVyRmFjdG9yeScpLFxyXG4gICAgICAgIER5bmFtaWNCaXRtYXBUZXh0OiByZXF1aXJlKCcuL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dEZhY3RvcnknKSxcclxuICAgICAgICBEeW5hbWljVGlsZW1hcDogcmVxdWlyZSgnLi90aWxlbWFwL2R5bmFtaWMvVGlsZW1hcEZhY3RvcnknKSxcclxuICAgICAgICBHcmFwaGljczogcmVxdWlyZSgnLi9ncmFwaGljcy9HcmFwaGljc0ZhY3RvcnknKSxcclxuICAgICAgICBHcm91cDogcmVxdWlyZSgnLi9ncm91cC9Hcm91cEZhY3RvcnknKSxcclxuICAgICAgICBJbWFnZTogcmVxdWlyZSgnLi9pbWFnZS9JbWFnZUZhY3RvcnknKSxcclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXI6IHJlcXVpcmUoJy4vZW1pdHRlci9QYXJ0aWNsZUVtaXR0ZXJGYWN0b3J5JyksXHJcbiAgICAgICAgU3ByaXRlOiByZXF1aXJlKCcuL3Nwcml0ZS9TcHJpdGVGYWN0b3J5JyksXHJcbiAgICAgICAgU3ByaXRlM0Q6IHJlcXVpcmUoJy4vc3ByaXRlM2QvU3ByaXRlM0RGYWN0b3J5JyksXHJcbiAgICAgICAgU3RhdGljQml0bWFwVGV4dDogcmVxdWlyZSgnLi9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0RmFjdG9yeScpLFxyXG4gICAgICAgIFN0YXRpY1RpbGVtYXA6IHJlcXVpcmUoJy4vdGlsZW1hcC9zdGF0aWMvU3RhdGljVGlsZW1hcEZhY3RvcnknKSxcclxuICAgICAgICBUZXh0OiByZXF1aXJlKCcuL3RleHQvc3RhdGljL1RleHRGYWN0b3J5JyksXHJcbiAgICAgICAgVGlsZVNwcml0ZTogcmVxdWlyZSgnLi90aWxlc3ByaXRlL1RpbGVTcHJpdGVGYWN0b3J5JyksXHJcbiAgICAgICAgWm9uZTogcmVxdWlyZSgnLi96b25lL1pvbmVGYWN0b3J5JyksXHJcbiAgICB9LFxyXG5cclxuICAgIENyZWF0b3JzOiB7XHJcbiAgICAgICAgQmxpdHRlcjogcmVxdWlyZSgnLi9ibGl0dGVyL0JsaXR0ZXJDcmVhdG9yJyksXHJcbiAgICAgICAgRHluYW1pY0JpdG1hcFRleHQ6IHJlcXVpcmUoJy4vYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0Q3JlYXRvcicpLFxyXG4gICAgICAgIER5bmFtaWNUaWxlbWFwOiByZXF1aXJlKCcuL3RpbGVtYXAvZHluYW1pYy9UaWxlbWFwQ3JlYXRvcicpLFxyXG4gICAgICAgIEdyYXBoaWNzOiByZXF1aXJlKCcuL2dyYXBoaWNzL0dyYXBoaWNzQ3JlYXRvcicpLFxyXG4gICAgICAgIEdyb3VwOiByZXF1aXJlKCcuL2dyb3VwL0dyb3VwQ3JlYXRvcicpLFxyXG4gICAgICAgIEltYWdlOiByZXF1aXJlKCcuL2ltYWdlL0ltYWdlQ3JlYXRvcicpLFxyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlcjogcmVxdWlyZSgnLi9lbWl0dGVyL1BhcnRpY2xlRW1pdHRlckNyZWF0b3InKSxcclxuICAgICAgICBTcHJpdGU6IHJlcXVpcmUoJy4vc3ByaXRlL1Nwcml0ZUNyZWF0b3InKSxcclxuICAgICAgICBTcHJpdGUzRDogcmVxdWlyZSgnLi9zcHJpdGUzZC9TcHJpdGUzRENyZWF0b3InKSxcclxuICAgICAgICBTdGF0aWNCaXRtYXBUZXh0OiByZXF1aXJlKCcuL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRDcmVhdG9yJyksXHJcbiAgICAgICAgU3RhdGljVGlsZW1hcDogcmVxdWlyZSgnLi90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwQ3JlYXRvcicpLFxyXG4gICAgICAgIFRleHQ6IHJlcXVpcmUoJy4vdGV4dC9zdGF0aWMvVGV4dENyZWF0b3InKSxcclxuICAgICAgICBUaWxlU3ByaXRlOiByZXF1aXJlKCcuL3RpbGVzcHJpdGUvVGlsZVNwcml0ZUNyZWF0b3InKSxcclxuICAgICAgICBab25lOiByZXF1aXJlKCcuL3pvbmUvWm9uZUNyZWF0b3InKSxcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5pZiAoV0VCR0xfUkVOREVSRVIpXHJcbntcclxuICAgIC8vICBXZWJHTCBvbmx5IEdhbWUgT2JqZWN0c1xyXG4gICAgR2FtZU9iamVjdHMuRWZmZWN0TGF5ZXIgPSByZXF1aXJlKCcuL2VmZmVjdGxheWVyL0VmZmVjdExheWVyJyk7XHJcbiAgICBHYW1lT2JqZWN0cy5MaWdodExheWVyID0gcmVxdWlyZSgnLi9saWdodGxheWVyL0xpZ2h0TGF5ZXInKTtcclxuICAgIEdhbWVPYmplY3RzLk1lc2ggPSByZXF1aXJlKCcuL21lc2gvTWVzaCcpO1xyXG4gICAgR2FtZU9iamVjdHMuUXVhZCA9IHJlcXVpcmUoJy4vcXVhZC9RdWFkJyk7XHJcbiAgICBHYW1lT2JqZWN0cy5SZW5kZXJQYXNzID0gcmVxdWlyZSgnLi9yZW5kZXJwYXNzL1JlbmRlclBhc3MuanMnKTtcclxuXHJcbiAgICBHYW1lT2JqZWN0cy5GYWN0b3JpZXMuRWZmZWN0TGF5ZXIgPSByZXF1aXJlKCcuL2VmZmVjdGxheWVyL0VmZmVjdExheWVyRmFjdG9yeScpO1xyXG4gICAgR2FtZU9iamVjdHMuRmFjdG9yaWVzLkxpZ2h0TGF5ZXIgPSByZXF1aXJlKCcuL2xpZ2h0bGF5ZXIvTGlnaHRMYXllckZhY3RvcnknKTtcclxuICAgIEdhbWVPYmplY3RzLkZhY3Rvcmllcy5NZXNoID0gcmVxdWlyZSgnLi9tZXNoL01lc2hGYWN0b3J5Jyk7XHJcbiAgICBHYW1lT2JqZWN0cy5GYWN0b3JpZXMuUXVhZCA9IHJlcXVpcmUoJy4vcXVhZC9RdWFkRmFjdG9yeScpO1xyXG4gICAgR2FtZU9iamVjdHMuRmFjdG9yaWVzLlJlbmRlclBhc3MgPSByZXF1aXJlKCcuL3JlbmRlcnBhc3MvUmVuZGVyUGFzc0ZhY3RvcnknKTtcclxuXHJcbiAgICBHYW1lT2JqZWN0cy5DcmVhdG9ycy5FZmZlY3RMYXllciA9IHJlcXVpcmUoJy4vZWZmZWN0bGF5ZXIvRWZmZWN0TGF5ZXJDcmVhdG9yJyk7XHJcbiAgICBHYW1lT2JqZWN0cy5DcmVhdG9ycy5MaWdodExheWVyID0gcmVxdWlyZSgnLi9saWdodGxheWVyL0xpZ2h0TGF5ZXJDcmVhdG9yJyk7XHJcbiAgICBHYW1lT2JqZWN0cy5DcmVhdG9ycy5NZXNoID0gcmVxdWlyZSgnLi9tZXNoL01lc2hDcmVhdG9yJyk7XHJcbiAgICBHYW1lT2JqZWN0cy5DcmVhdG9ycy5RdWFkID0gcmVxdWlyZSgnLi9xdWFkL1F1YWRDcmVhdG9yJyk7XHJcbiAgICBHYW1lT2JqZWN0cy5DcmVhdG9ycy5SZW5kZXJQYXNzID0gcmVxdWlyZSgnLi9yZW5kZXJwYXNzL1JlbmRlclBhc3NDcmVhdG9yJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZU9iamVjdHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdlb21cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXHJcbiAgICBDaXJjbGU6IHJlcXVpcmUoJy4vY2lyY2xlJyksXHJcbiAgICBFbGxpcHNlOiByZXF1aXJlKCcuL2VsbGlwc2UnKSxcclxuICAgIEludGVyc2VjdHM6IHJlcXVpcmUoJy4vaW50ZXJzZWN0cycpLFxyXG4gICAgTGluZTogcmVxdWlyZSgnLi9saW5lJyksXHJcbiAgICBQb2ludDogcmVxdWlyZSgnLi9wb2ludCcpLFxyXG4gICAgUG9seWdvbjogcmVxdWlyZSgnLi9wb2x5Z29uJyksXHJcbiAgICBSZWN0YW5nbGU6IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJyksXHJcbiAgICBUcmlhbmdsZTogcmVxdWlyZSgnLi90cmlhbmdsZScpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdyYXBoaWNzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBCbGVuZE1vZGVzOiByZXF1aXJlKCcuL2JsZW5kbW9kZXMnKSxcclxuICAgIENvbG9yOiByZXF1aXJlKCcuL2NvbG9yJylcclxuICBcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuSW5wdXRcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEdhbWVwYWQ6IHJlcXVpcmUoJy4vZ2FtZXBhZCcpLFxyXG4gICAgS2V5Ym9hcmQ6IHJlcXVpcmUoJy4va2V5Ym9hcmQnKSxcclxuICAgIE1vdXNlOiByZXF1aXJlKCcuL21vdXNlJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUk5EID0gcmVxdWlyZSgnLi9yYW5kb20tZGF0YS1nZW5lcmF0b3IvUmFuZG9tRGF0YUdlbmVyYXRvcicpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgLy8gIENvbnN0c1xyXG4gICAgUEkyOiBNYXRoLlBJICogMixcclxuICAgIFRBVTogTWF0aC5QSSAqIDAuNSxcclxuICAgIEVQU0lMT046IDEuMGUtNixcclxuICAgIERFR19UT19SQUQ6IE1hdGguUEkgLyAxODAsXHJcbiAgICBSQURfVE9fREVHOiAxODAgLyBNYXRoLlBJLFxyXG5cclxuICAgIC8vICBSYW5kb20gRGF0YSBHZW5lcmF0b3JcclxuICAgIFJORDogbmV3IFJORCgpLFxyXG5cclxuICAgIC8vICBDb2xsZWN0aW9ucyBvZiBmdW5jdGlvbnNcclxuICAgIEFuZ2xlOiByZXF1aXJlKCcuL2FuZ2xlLycpLFxyXG4gICAgRGlzdGFuY2U6IHJlcXVpcmUoJy4vZGlzdGFuY2UvJyksXHJcbiAgICBFYXNpbmc6IHJlcXVpcmUoJy4vZWFzaW5nLycpLFxyXG4gICAgRnV6enk6IHJlcXVpcmUoJy4vZnV6enkvJyksXHJcbiAgICBJbnRlcnBvbGF0aW9uOiByZXF1aXJlKCcuL2ludGVycG9sYXRpb24vJyksXHJcbiAgICBQb3cyOiByZXF1aXJlKCcuL3BvdzIvJyksXHJcbiAgICBTbmFwOiByZXF1aXJlKCcuL3NuYXAvJyksXHJcblxyXG4gICAgLy8gIFNpbmdsZSBmdW5jdGlvbnNcclxuICAgIEF2ZXJhZ2U6IHJlcXVpcmUoJy4vQXZlcmFnZScpLFxyXG4gICAgQmVybnN0ZWluOiByZXF1aXJlKCcuL0Jlcm5zdGVpbicpLFxyXG4gICAgQmV0d2VlbjogcmVxdWlyZSgnLi9CZXR3ZWVuJyksXHJcbiAgICBDYXRtdWxsUm9tOiByZXF1aXJlKCcuL0NhdG11bGxSb20nKSxcclxuICAgIENlaWxUbzogcmVxdWlyZSgnLi9DZWlsVG8nKSxcclxuICAgIENsYW1wOiByZXF1aXJlKCcuL0NsYW1wJyksXHJcbiAgICBEZWdUb1JhZDogcmVxdWlyZSgnLi9EZWdUb1JhZCcpLFxyXG4gICAgRGlmZmVyZW5jZTogcmVxdWlyZSgnLi9EaWZmZXJlbmNlJyksXHJcbiAgICBGYWN0b3JpYWw6IHJlcXVpcmUoJy4vRmFjdG9yaWFsJyksXHJcbiAgICBGbG9hdEJldHdlZW46IHJlcXVpcmUoJy4vRmxvYXRCZXR3ZWVuJyksXHJcbiAgICBGbG9vclRvOiByZXF1aXJlKCcuL0Zsb29yVG8nKSxcclxuICAgIEdldFNwZWVkOiByZXF1aXJlKCcuL0dldFNwZWVkJyksXHJcbiAgICBJc0V2ZW46IHJlcXVpcmUoJy4vSXNFdmVuJyksXHJcbiAgICBJc0V2ZW5TdHJpY3Q6IHJlcXVpcmUoJy4vSXNFdmVuU3RyaWN0JyksXHJcbiAgICBMaW5lYXI6IHJlcXVpcmUoJy4vTGluZWFyJyksXHJcbiAgICBNYXhBZGQ6IHJlcXVpcmUoJy4vTWF4QWRkJyksXHJcbiAgICBNaW5TdWI6IHJlcXVpcmUoJy4vTWluU3ViJyksXHJcbiAgICBQZXJjZW50OiByZXF1aXJlKCcuL1BlcmNlbnQnKSxcclxuICAgIFJhZFRvRGVnOiByZXF1aXJlKCcuL1JhZFRvRGVnJyksXHJcbiAgICBSYW5kb21YWTogcmVxdWlyZSgnLi9SYW5kb21YWScpLFxyXG4gICAgUmFuZG9tWFlaOiByZXF1aXJlKCcuL1JhbmRvbVhZWicpLFxyXG4gICAgUmFuZG9tWFlaVzogcmVxdWlyZSgnLi9SYW5kb21YWVpXJyksXHJcbiAgICBSb3RhdGU6IHJlcXVpcmUoJy4vUm90YXRlJyksXHJcbiAgICBSb3RhdGVBcm91bmQ6IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kJyksXHJcbiAgICBSb3RhdGVBcm91bmREaXN0YW5jZTogcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmREaXN0YW5jZScpLFxyXG4gICAgUm91bmRBd2F5RnJvbVplcm86IHJlcXVpcmUoJy4vUm91bmRBd2F5RnJvbVplcm8nKSxcclxuICAgIFJvdW5kVG86IHJlcXVpcmUoJy4vUm91bmRUbycpLFxyXG4gICAgU2luQ29zVGFibGVHZW5lcmF0b3I6IHJlcXVpcmUoJy4vU2luQ29zVGFibGVHZW5lcmF0b3InKSxcclxuICAgIFNtb290aGVyU3RlcDogcmVxdWlyZSgnLi9TbW9vdGhlclN0ZXAnKSxcclxuICAgIFNtb290aFN0ZXA6IHJlcXVpcmUoJy4vU21vb3RoU3RlcCcpLFxyXG4gICAgV2l0aGluOiByZXF1aXJlKCcuL1dpdGhpbicpLFxyXG4gICAgV3JhcDogcmVxdWlyZSgnLi9XcmFwJyksXHJcblxyXG4gICAgLy8gIFZlY3RvciBjbGFzc2VzXHJcbiAgICBWZWN0b3IyOiByZXF1aXJlKCcuL1ZlY3RvcjInKSxcclxuICAgIFZlY3RvcjM6IHJlcXVpcmUoJy4vVmVjdG9yMycpLFxyXG4gICAgVmVjdG9yNDogcmVxdWlyZSgnLi9WZWN0b3I0JyksXHJcbiAgICBNYXRyaXgzOiByZXF1aXJlKCcuL01hdHJpeDMnKSxcclxuICAgIE1hdHJpeDQ6IHJlcXVpcmUoJy4vTWF0cml4NCcpLFxyXG4gICAgUXVhdGVybmlvbjogcmVxdWlyZSgnLi9RdWF0ZXJuaW9uJyksXHJcbiAgICBSb3RhdGVWZWMzOiByZXF1aXJlKCcuL1JvdGF0ZVZlYzMnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5DdXJ2ZXNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXHJcbiAgICBDdWJpY0JlemllcjogcmVxdWlyZSgnLi9jdWJpY2Jlemllci9DdWJpY0JlemllckN1cnZlJyksXHJcbiAgICBFbGxpcHNlOiByZXF1aXJlKCcuL2VsbGlwc2UvRWxsaXBzZUN1cnZlJyksXHJcbiAgICBMaW5lOiByZXF1aXJlKCcuL2xpbmUvTGluZUN1cnZlJyksXHJcbiAgICBTcGxpbmU6IHJlcXVpcmUoJy4vc3BsaW5lL1NwbGluZUN1cnZlJylcclxuXHJcbn07XHJcblxyXG4vLyAgICAgSGVybWl0ZTogcmVxdWlyZSgnLi9jdXJ2ZXMvaGVybWl0ZScpXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGF0aHMvY3VydmVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5QYXRoc1xyXG5cclxuLy8gIFBoYXNlci5DdXJ2ZXMuUGF0aCA/IG9yIC4uLlxyXG4vLyAgUGhhc2VyLlBhdGhzLlBhdGggP1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgUGF0aDogcmVxdWlyZSgnLi9QYXRoJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGF0aHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL0FycmF5LmZvckVhY2gnKTtcclxucmVxdWlyZSgnLi9BcnJheS5pc0FycmF5Jyk7XHJcbnJlcXVpcmUoJy4vQXVkaW9Db250ZXh0TW9ua2V5UGF0Y2gnKTtcclxucmVxdWlyZSgnLi9jb25zb2xlJyk7XHJcbnJlcXVpcmUoJy4vRnVuY3Rpb24uYmluZCcpO1xyXG5yZXF1aXJlKCcuL01hdGgudHJ1bmMnKTtcclxucmVxdWlyZSgnLi9wZXJmb3JtYW5jZS5ub3cnKTtcclxucmVxdWlyZSgnLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcclxucmVxdWlyZSgnLi9VaW50MzJBcnJheScpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BvbHlmaWxscy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuU291bmRcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIER5bmFtaWM6IHJlcXVpcmUoJy4vZHluYW1pYycpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdW5kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5TdHJ1Y3RzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBNYXA6IHJlcXVpcmUoJy4vTWFwJyksXHJcbiAgICBSVHJlZTogcmVxdWlyZSgnLi9SVHJlZScpLFxyXG4gICAgU2V0OiByZXF1aXJlKCcuL1NldCcpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0cnVjdHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlV0aWxzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBBbGlnbjogcmVxdWlyZSgnLi9hbGlnbi8nKSxcclxuICAgIEFycmF5OiByZXF1aXJlKCcuL2FycmF5LycpLFxyXG4gICAgQm91bmRzOiByZXF1aXJlKCcuL2JvdW5kcy8nKSxcclxuICAgIE9iamVjdHM6IHJlcXVpcmUoJy4vb2JqZWN0LycpLFxyXG4gICAgU3RyaW5nOiByZXF1aXJlKCcuL3N0cmluZy8nKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBbmdsZSA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0uYW5nbGUgKz0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL0FuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhbGwgPSBmdW5jdGlvbiAoaXRlbXMsIGNhbGxiYWNrLCB0aGlzQXJnKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XHJcblxyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWxsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvQ2FsbC5qc1xuLy8gbW9kdWxlIGlkID0gMjc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBjb21wYXJlID0gT2JqZWN0OlxyXG4vLyAge1xyXG4vLyAgICAgIHNjYWxlWDogMC41LFxyXG4vLyAgICAgIHNjYWxlWTogMVxyXG4vLyAgfVxyXG5cclxudmFyIEdldEZpcnN0ID0gZnVuY3Rpb24gKGl0ZW1zLCBjb21wYXJlLCBpbmRleClcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcclxuXHJcbiAgICAgICAgdmFyIG1hdGNoID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gY29tcGFyZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtW3Byb3BlcnR5XSAhPT0gY29tcGFyZVtwcm9wZXJ0eV0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXRjaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Rmlyc3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9HZXRGaXJzdC5qc1xuLy8gbW9kdWxlIGlkID0gMjc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uL3V0aWxzL2FsaWduL2NvbnN0Jyk7XHJcbnZhciBBbGlnbkluID0gcmVxdWlyZSgnLi4vdXRpbHMvYWxpZ24vQWxpZ25JbicpO1xyXG52YXIgWm9uZSA9IHJlcXVpcmUoJy4uL2dhbWVvYmplY3RzL3pvbmUvWm9uZScpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxuXHJcbnZhciB0ZW1wWm9uZSA9IG5ldyBab25lKHsgc3lzOiB7IHNvcnRDaGlsZHJlbkZsYWc6IGZhbHNlIH19LCAwLCAwLCAxLCAxKTtcclxuXHJcbnZhciBHcmlkQWxpZ24gPSBmdW5jdGlvbiAoaXRlbXMsIG9wdGlvbnMpXHJcbntcclxuICAgIHZhciB3aWR0aCA9IEdldFZhbHVlKG9wdGlvbnMsICd3aWR0aCcsIC0xKTtcclxuICAgIHZhciBoZWlnaHQgPSBHZXRWYWx1ZShvcHRpb25zLCAnaGVpZ2h0JywgLTEpO1xyXG4gICAgdmFyIGNlbGxXaWR0aCA9IEdldFZhbHVlKG9wdGlvbnMsICdjZWxsV2lkdGgnLCAxKTtcclxuICAgIHZhciBjZWxsSGVpZ2h0ID0gR2V0VmFsdWUob3B0aW9ucywgJ2NlbGxIZWlnaHQnLCBjZWxsV2lkdGgpO1xyXG4gICAgdmFyIHBvc2l0aW9uID0gR2V0VmFsdWUob3B0aW9ucywgJ3Bvc2l0aW9uJywgQ09OU1QuVE9QX0xFRlQpO1xyXG4gICAgdmFyIHggPSBHZXRWYWx1ZShvcHRpb25zLCAneCcsIDApO1xyXG4gICAgdmFyIHkgPSBHZXRWYWx1ZShvcHRpb25zLCAneScsIDApO1xyXG4gICAgLy8gdmFyIGNlbnRlclggPSBHZXRWYWx1ZShvcHRpb25zLCAnY2VudGVyWCcsIG51bGwpO1xyXG4gICAgLy8gdmFyIGNlbnRlclkgPSBHZXRWYWx1ZShvcHRpb25zLCAnY2VudGVyWScsIG51bGwpO1xyXG5cclxuICAgIHZhciBjeCA9IDA7XHJcbiAgICB2YXIgY3kgPSAwO1xyXG4gICAgdmFyIHcgPSAod2lkdGggKiBjZWxsV2lkdGgpO1xyXG4gICAgdmFyIGggPSAoaGVpZ2h0ICogY2VsbEhlaWdodCk7XHJcblxyXG4gICAgLy8gIElmIHRoZSBHcmlkIGlzIGNlbnRlcmVkIG9uIGEgcG9zaXRpb24gdGhlbiB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBpdCBub3dcclxuICAgIC8vIGlmIChjZW50ZXJYICE9PSBudWxsICYmIGNlbnRlclkgIT09IG51bGwpXHJcbiAgICAvLyB7XHJcbiAgICAgICAgLy8gXHJcbiAgICAvLyB9XHJcblxyXG4gICAgdGVtcFpvbmUuc2V0UG9zaXRpb24oeCwgeSk7XHJcbiAgICB0ZW1wWm9uZS5zZXRTaXplKGNlbGxXaWR0aCwgY2VsbEhlaWdodCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBBbGlnbkluKGl0ZW1zW2ldLCB0ZW1wWm9uZSwgcG9zaXRpb24pO1xyXG5cclxuICAgICAgICBpZiAod2lkdGggPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFdlIGtlZXAgbGF5aW5nIHRoZW0gb3V0IGhvcml6b250YWxseSB1bnRpbCB3ZSd2ZSBkb25lIHRoZW0gYWxsXHJcbiAgICAgICAgICAgIGN5ICs9IGNlbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRlbXBab25lLnkgKz0gY2VsbEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGlmIChjeSA9PT0gaClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3kgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGVtcFpvbmUueCArPSBjZWxsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0ZW1wWm9uZS55ID0geTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoZWlnaHQgPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFdlIGtlZXAgbGF5aW5nIHRoZW0gb3V0IHZlcnRpY2FsbHkgdW50aWwgd2UndmUgZG9uZSB0aGVtIGFsbFxyXG4gICAgICAgICAgICBjeCArPSBjZWxsV2lkdGg7XHJcbiAgICAgICAgICAgIHRlbXBab25lLnggKz0gY2VsbFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgaWYgKGN4ID09PSB3KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0ZW1wWm9uZS54ID0geDtcclxuICAgICAgICAgICAgICAgIHRlbXBab25lLnkgKz0gY2VsbEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgV2Uga2VlcCBsYXlpbmcgdGhlbSBvdXQgdW50aWwgd2UgaGl0IHRoZSBjb2x1bW4gbGltaXRcclxuICAgICAgICAgICAgY3ggKz0gY2VsbFdpZHRoO1xyXG4gICAgICAgICAgICB0ZW1wWm9uZS54ICs9IGNlbGxXaWR0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChjeCA9PT0gdylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3ggPSAwO1xyXG4gICAgICAgICAgICAgICAgY3kgKz0gY2VsbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHRlbXBab25lLnggPSB4O1xyXG4gICAgICAgICAgICAgICAgdGVtcFpvbmUueSArPSBjZWxsSGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjeSA9PT0gaClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgV2UndmUgaGl0IHRoZSBjb2x1bW4gbGltaXQsIHNvIHJldHVybiwgZXZlbiBpZiB0aGVyZSBhcmUgaXRlbXMgbGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JpZEFsaWduO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvR3JpZEFsaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAyODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEluY0FscGhhID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSlcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5hbHBoYSArPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluY0FscGhhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvSW5jQWxwaGEuanNcbi8vIG1vZHVsZSBpZCA9IDI4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW5jWCA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0ueCArPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluY1g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9JbmNYLmpzXG4vLyBtb2R1bGUgaWQgPSAyODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEluY1hZID0gZnVuY3Rpb24gKGl0ZW1zLCB4LCB5KVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnggKz0geDtcclxuICAgICAgICBpdGVtc1tpXS55ICs9IHk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmNYWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL0luY1hZLmpzXG4vLyBtb2R1bGUgaWQgPSAyODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEluY1kgPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnkgKz0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmNZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvSW5jWS5qc1xuLy8gbW9kdWxlIGlkID0gMjg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQbGFjZU9uQ2lyY2xlID0gZnVuY3Rpb24gKGl0ZW1zLCBjaXJjbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKVxyXG57XHJcbiAgICBpZiAoc3RhcnRBbmdsZSA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0QW5nbGUgPSAwOyB9XHJcbiAgICBpZiAoZW5kQW5nbGUgPT09IHVuZGVmaW5lZCkgeyBlbmRBbmdsZSA9IDYuMjg7IH1cclxuXHJcbiAgICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlO1xyXG4gICAgdmFyIGFuZ2xlU3RlcCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gaXRlbXMubGVuZ3RoO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0ueCA9IGNpcmNsZS54ICsgKGNpcmNsZS5yYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkpO1xyXG4gICAgICAgIGl0ZW1zW2ldLnkgPSBjaXJjbGUueSArIChjaXJjbGUucmFkaXVzICogTWF0aC5zaW4oYW5nbGUpKTtcclxuXHJcbiAgICAgICAgYW5nbGUgKz0gYW5nbGVTdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGxhY2VPbkNpcmNsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1BsYWNlT25DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGxhY2VPbkVsbGlwc2UgPSBmdW5jdGlvbiAoaXRlbXMsIGVsbGlwc2UsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKVxyXG57XHJcbiAgICBpZiAoc3RhcnRBbmdsZSA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0QW5nbGUgPSAwOyB9XHJcbiAgICBpZiAoZW5kQW5nbGUgPT09IHVuZGVmaW5lZCkgeyBlbmRBbmdsZSA9IDYuMjg7IH1cclxuXHJcbiAgICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlO1xyXG4gICAgdmFyIGFuZ2xlU3RlcCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gaXRlbXMubGVuZ3RoO1xyXG5cclxuICAgIHZhciBhID0gZWxsaXBzZS53aWR0aCAvIDI7XHJcbiAgICB2YXIgYiA9IGVsbGlwc2UuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnggPSBlbGxpcHNlLnggKyBhICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIGl0ZW1zW2ldLnkgPSBlbGxpcHNlLnkgKyBiICogTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgICAgICBhbmdsZSArPSBhbmdsZVN0ZXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQbGFjZU9uRWxsaXBzZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1BsYWNlT25FbGxpcHNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFBvaW50c09uTGluZSA9IHJlcXVpcmUoJy4uL2dlb20vbGluZS9HZXRQb2ludHNPbkxpbmUnKTtcclxuXHJcbnZhciBQbGFjZU9uTGluZSA9IGZ1bmN0aW9uIChpdGVtcywgbGluZSlcclxue1xyXG4gICAgdmFyIHBvaW50cyA9IEdldFBvaW50c09uTGluZShsaW5lKTtcclxuICAgIHZhciBzdGVwID0gcG9pbnRzLmxlbmd0aCAvIGl0ZW1zLmxlbmd0aDtcclxuICAgIHZhciBwID0gMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XHJcbiAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW01hdGguZmxvb3IocCldO1xyXG5cclxuICAgICAgICBpdGVtLnggPSBwb2ludFswXTtcclxuICAgICAgICBpdGVtLnkgPSBwb2ludFsxXTtcclxuXHJcbiAgICAgICAgcCArPSBzdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGxhY2VPbkxpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9QbGFjZU9uTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMjg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXJjaGluZ0FudHMgPSByZXF1aXJlKCcuLi9nZW9tL3JlY3RhbmdsZS9NYXJjaGluZ0FudHMnKTtcclxudmFyIFJvdGF0ZUxlZnQgPSByZXF1aXJlKCcuLi91dGlscy9hcnJheS9Sb3RhdGVMZWZ0Jyk7XHJcbnZhciBSb3RhdGVSaWdodCA9IHJlcXVpcmUoJy4uL3V0aWxzL2FycmF5L1JvdGF0ZVJpZ2h0Jyk7XHJcblxyXG4vLyAgUGxhY2UgdGhlIGl0ZW1zIGluIHRoZSBhcnJheSBhcm91bmQgdGhlIHBlcmltZXRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxyXG5cclxuLy8gIFBsYWNlbWVudCBzdGFydHMgZnJvbSB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZSwgYW5kIHByb2NlZWRzIGluIGFcclxuLy8gIGNsb2Nrd2lzZSBkaXJlY3Rpb24uIElmIHRoZSBzaGlmdCBwYXJhbWV0ZXIgaXMgZ2l2ZW4geW91IGNhbiBvZmZzZXQgd2hlcmVcclxuLy8gIHBsYWNlbWVudCBiZWdpbnMuXHJcblxyXG52YXIgUGxhY2VPblJlY3RhbmdsZSA9IGZ1bmN0aW9uIChpdGVtcywgcmVjdCwgc2hpZnQpXHJcbntcclxuICAgIGlmIChzaGlmdCA9PT0gdW5kZWZpbmVkKSB7IHNoaWZ0ID0gMDsgfVxyXG5cclxuICAgIHZhciBwb2ludHMgPSBNYXJjaGluZ0FudHMocmVjdCwgZmFsc2UsIGl0ZW1zLmxlbmd0aCk7XHJcblxyXG4gICAgaWYgKHNoaWZ0ID4gMClcclxuICAgIHtcclxuICAgICAgICBSb3RhdGVMZWZ0KHBvaW50cywgc2hpZnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2hpZnQgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIFJvdGF0ZVJpZ2h0KHBvaW50cywgTWF0aC5hYnMoc2hpZnQpKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnggPSBwb2ludHNbaV0ueDtcclxuICAgICAgICBpdGVtc1tpXS55ID0gcG9pbnRzW2ldLnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQbGFjZU9uUmVjdGFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvUGxhY2VPblJlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRQb2ludHNPbkxpbmUgPSByZXF1aXJlKCcuLi9nZW9tL2xpbmUvR2V0UG9pbnRzT25MaW5lJyk7XHJcblxyXG52YXIgUGxhY2VPblRyaWFuZ2xlID0gZnVuY3Rpb24gKGl0ZW1zLCB0cmlhbmdsZSwgc3RlcFJhdGUpXHJcbntcclxuICAgIHZhciBwMSA9IEdldFBvaW50c09uTGluZSh7IHgxOiB0cmlhbmdsZS54MSwgeTE6IHRyaWFuZ2xlLnkxLCB4MjogdHJpYW5nbGUueDIsIHkyOiB0cmlhbmdsZS55MiB9LCBzdGVwUmF0ZSk7XHJcbiAgICB2YXIgcDIgPSBHZXRQb2ludHNPbkxpbmUoeyB4MTogdHJpYW5nbGUueDIsIHkxOiB0cmlhbmdsZS55MiwgeDI6IHRyaWFuZ2xlLngzLCB5MjogdHJpYW5nbGUueTMgfSwgc3RlcFJhdGUpO1xyXG4gICAgdmFyIHAzID0gR2V0UG9pbnRzT25MaW5lKHsgeDE6IHRyaWFuZ2xlLngzLCB5MTogdHJpYW5nbGUueTMsIHgyOiB0cmlhbmdsZS54MSwgeTI6IHRyaWFuZ2xlLnkxIH0sIHN0ZXBSYXRlKTtcclxuXHJcbiAgICAvLyAgUmVtb3ZlIG92ZXJsYXBzXHJcbiAgICBwMS5wb3AoKTtcclxuICAgIHAyLnBvcCgpO1xyXG4gICAgcDMucG9wKCk7XHJcblxyXG4gICAgcDEgPSBwMS5jb25jYXQocDIsIHAzKTtcclxuXHJcbiAgICB2YXIgc3RlcCA9IHAxLmxlbmd0aCAvIGl0ZW1zLmxlbmd0aDtcclxuICAgIHZhciBwID0gMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XHJcbiAgICAgICAgdmFyIHBvaW50ID0gcDFbTWF0aC5mbG9vcihwKV07XHJcblxyXG4gICAgICAgIGl0ZW0ueCA9IHBvaW50WzBdO1xyXG4gICAgICAgIGl0ZW0ueSA9IHBvaW50WzFdO1xyXG5cclxuICAgICAgICBwICs9IHN0ZXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQbGFjZU9uVHJpYW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9QbGFjZU9uVHJpYW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChpdGVtcywga2V5LCBzdGFydEZyYW1lKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLmFuaW1zLnBsYXkoa2V5LCBzdGFydEZyYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsYXlBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9QbGF5QW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJhbmRvbSA9IHJlcXVpcmUoJy4uL2dlb20vY2lyY2xlL1JhbmRvbScpO1xyXG5cclxudmFyIFJhbmRvbUNpcmNsZSA9IGZ1bmN0aW9uIChpdGVtcywgY2lyY2xlKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIFJhbmRvbShjaXJjbGUsIGl0ZW1zW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbUNpcmNsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1JhbmRvbUNpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSYW5kb20gPSByZXF1aXJlKCcuLi9nZW9tL2VsbGlwc2UvUmFuZG9tJyk7XHJcblxyXG52YXIgUmFuZG9tRWxsaXBzZSA9IGZ1bmN0aW9uIChpdGVtcywgZWxsaXBzZSlcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBSYW5kb20oZWxsaXBzZSwgaXRlbXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tRWxsaXBzZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1JhbmRvbUVsbGlwc2UuanNcbi8vIG1vZHVsZSBpZCA9IDI5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmFuZG9tID0gcmVxdWlyZSgnLi4vZ2VvbS9saW5lL1JhbmRvbScpO1xyXG5cclxudmFyIFJhbmRvbUxpbmUgPSBmdW5jdGlvbiAoaXRlbXMsIGxpbmUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgUmFuZG9tKGxpbmUsIGl0ZW1zW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbUxpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9SYW5kb21MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJhbmRvbSA9IHJlcXVpcmUoJy4uL2dlb20vcmVjdGFuZ2xlL1JhbmRvbScpO1xyXG5cclxudmFyIFJhbmRvbVJlY3RhbmdsZSA9IGZ1bmN0aW9uIChpdGVtcywgcmVjdClcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBSYW5kb20ocmVjdCwgaXRlbXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tUmVjdGFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvUmFuZG9tUmVjdGFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJhbmRvbSA9IHJlcXVpcmUoJy4uL2dlb20vdHJpYW5nbGUvUmFuZG9tJyk7XHJcblxyXG52YXIgUmFuZG9tVHJpYW5nbGUgPSBmdW5jdGlvbiAoaXRlbXMsIHRyaWFuZ2xlKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIFJhbmRvbSh0cmlhbmdsZSwgaXRlbXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tVHJpYW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9SYW5kb21UcmlhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3RhdGUgPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlLCBzdGVwKVxyXG57XHJcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXAgPSAwOyB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5yb3RhdGlvbiArPSB2YWx1ZSArIChpICogc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9Sb3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm90YXRlQXJvdW5kRGlzdGFuY2UgPSByZXF1aXJlKCcuLi9tYXRoL1JvdGF0ZUFyb3VuZERpc3RhbmNlJyk7XHJcbnZhciBEaXN0YW5jZUJldHdlZW4gPSByZXF1aXJlKCcuLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlQmV0d2VlbicpO1xyXG5cclxuLy8gIHBvaW50ID0gYW55IG9iamVjdCB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllc1xyXG5cclxudmFyIFJvdGF0ZUFyb3VuZCA9IGZ1bmN0aW9uIChpdGVtcywgcG9pbnQsIGFuZ2xlKVxyXG57XHJcbiAgICB2YXIgeCA9IHBvaW50Lng7XHJcbiAgICB2YXIgeSA9IHBvaW50Lnk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xyXG5cclxuICAgICAgICBSb3RhdGVBcm91bmREaXN0YW5jZShpdGVtLCB4LCB5LCBhbmdsZSwgTWF0aC5tYXgoMSwgRGlzdGFuY2VCZXR3ZWVuKGl0ZW0ueCwgaXRlbS55LCB4LCB5KSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvUm90YXRlQXJvdW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1hdGhSb3RhdGVBcm91bmREaXN0YW5jZSA9IHJlcXVpcmUoJy4uL21hdGgvUm90YXRlQXJvdW5kRGlzdGFuY2UnKTtcclxuXHJcbi8vICBwb2ludCA9IGFueSBvYmplY3Qgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXNcclxuLy8gIGFuZ2xlID0gcmFkaWFuc1xyXG4vLyAgZGlzdGFuY2UgPSBweFxyXG5cclxudmFyIFJvdGF0ZUFyb3VuZERpc3RhbmNlID0gZnVuY3Rpb24gKGl0ZW1zLCBwb2ludCwgYW5nbGUsIGRpc3RhbmNlKVxyXG57XHJcbiAgICB2YXIgeCA9IHBvaW50Lng7XHJcbiAgICB2YXIgeSA9IHBvaW50Lnk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBNYXRoUm90YXRlQXJvdW5kRGlzdGFuY2UoaXRlbXNbaV0sIHgsIHksIGFuZ2xlLCBkaXN0YW5jZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmREaXN0YW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1JvdGF0ZUFyb3VuZERpc3RhbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNjYWxlWCA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0uc2NhbGVYICs9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NhbGVYO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvU2NhbGVYLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNjYWxlWFkgPSBmdW5jdGlvbiAoaXRlbXMsIHgsIHkpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0uc2NhbGVYICs9IHg7XHJcbiAgICAgICAgaXRlbXNbaV0uc2NhbGVZICs9IHk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTY2FsZVhZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvU2NhbGVYWS5qc1xuLy8gbW9kdWxlIGlkID0gMzAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTY2FsZVkgPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnNjYWxlWSArPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1NjYWxlWS5qc1xuLy8gbW9kdWxlIGlkID0gMzAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRBbHBoYSA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUsIHN0ZXApXHJcbntcclxuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDA7IH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLmFscGhhID0gdmFsdWUgKyAoaSAqIHN0ZXApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0QWxwaGE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRBbHBoYS5qc1xuLy8gbW9kdWxlIGlkID0gMzAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRCbGVuZE1vZGUgPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnNldEJsZW5kTW9kZSh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRCbGVuZE1vZGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRCbGVuZE1vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0RGVwdGggPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlLCBzdGVwKVxyXG57XHJcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXAgPSAwOyB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5kZXB0aCA9IHZhbHVlICsgKGkgKiBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldERlcHRoO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvU2V0RGVwdGguanNcbi8vIG1vZHVsZSBpZCA9IDMwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0SGl0QXJlYSA9IGZ1bmN0aW9uIChpdGVtcywgaGl0QXJlYSwgaGl0QXJlYUNhbGxiYWNrKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnNldEhpdEFyZWEoaGl0QXJlYSwgaGl0QXJlYUNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldEhpdEFyZWE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRIaXRBcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldE9yaWdpbiA9IGZ1bmN0aW9uIChpdGVtcywgeCwgeSlcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5zZXRPcmlnaW4oeCwgeSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRPcmlnaW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRPcmlnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDMwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0Um90YXRpb24gPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlLCBzdGVwKVxyXG57XHJcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXAgPSAwOyB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5yb3RhdGlvbiA9IHZhbHVlICsgKGkgKiBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFJvdGF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvU2V0Um90YXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0U2NhbGUgPSBmdW5jdGlvbiAoaXRlbXMsIHgsIHksIHN0ZXBYLCBzdGVwWSlcclxue1xyXG4gICAgaWYgKHN0ZXBYID09PSB1bmRlZmluZWQpIHsgc3RlcFggPSAwOyB9XHJcbiAgICBpZiAoc3RlcFkgPT09IHVuZGVmaW5lZCkgeyBzdGVwWSA9IDA7IH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnNldFNjYWxlKFxyXG4gICAgICAgICAgICB4ICsgKGkgKiBzdGVwWCksXHJcbiAgICAgICAgICAgIHkgKyAoaSAqIHN0ZXBZKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRTY2FsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1NldFNjYWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFNjYWxlWCA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUsIHN0ZXApXHJcbntcclxuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDA7IH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnNjYWxlWCA9IHZhbHVlICsgKGkgKiBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFNjYWxlWDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1NldFNjYWxlWC5qc1xuLy8gbW9kdWxlIGlkID0gMzA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRTY2FsZVkgPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlLCBzdGVwKVxyXG57XHJcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXAgPSAwOyB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5zY2FsZVkgPSB2YWx1ZSArIChpICogc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRTY2FsZVk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRTY2FsZVkuanNcbi8vIG1vZHVsZSBpZCA9IDMxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0VmlzaWJsZSA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0udmlzaWJsZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0VmlzaWJsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1NldFZpc2libGUuanNcbi8vIG1vZHVsZSBpZCA9IDMxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0WCA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUsIHN0ZXApXHJcbntcclxuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDA7IH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnggPSB2YWx1ZSArIChpICogc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRYO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvU2V0WC5qc1xuLy8gbW9kdWxlIGlkID0gMzEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRYWSA9IGZ1bmN0aW9uIChpdGVtcywgeCwgeSwgc3RlcFgsIHN0ZXBZKVxyXG57XHJcbiAgICBpZiAoc3RlcFggPT09IHVuZGVmaW5lZCkgeyBzdGVwWCA9IDA7IH1cclxuICAgIGlmIChzdGVwWSA9PT0gdW5kZWZpbmVkKSB7IHN0ZXBZID0gMDsgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0ueCA9IHggKyAoaSAqIHN0ZXBYKTtcclxuICAgICAgICBpdGVtc1tpXS55ID0geSArIChpICogc3RlcFkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0WFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRYWS5qc1xuLy8gbW9kdWxlIGlkID0gMzEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRZID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSwgc3RlcClcclxue1xyXG4gICAgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCkgeyBzdGVwID0gMDsgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0ueSA9IHZhbHVlICsgKGkgKiBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRZLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEl0ZXJhdGUgdGhyb3VnaCBpdGVtcyBjaGFuZ2luZyB0aGUgcG9zaXRpb24gb2YgZWFjaCBlbGVtZW50IHRvXHJcbi8vICBiZSB0aGF0IG9mIHRoZSBlbGVtZW50IHRoYXQgY2FtZSBiZWZvcmUgaXQgaW4gdGhlIGFycmF5IChvciBhZnRlciBpdCBpZiBkaXJlY3Rpb24gPSAxKVxyXG4vLyAgVGhlIGZpcnN0IGl0ZW1zIHBvc2l0aW9uIGlzIHNldCB0byB4L3kuXHJcbi8vICBUaGUgZmluYWwgeC95IGNvb3JkcyBhcmUgcmV0dXJuZWRcclxuXHJcbnZhciBTaGlmdFBvc2l0aW9uID0gZnVuY3Rpb24gKGl0ZW1zLCB4LCB5LCBkaXJlY3Rpb24sIG91dHB1dClcclxue1xyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7IGRpcmVjdGlvbiA9IDA7IH1cclxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIHZhciBweDtcclxuICAgIHZhciBweTtcclxuXHJcbiAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgY3g7XHJcbiAgICAgICAgdmFyIGN5O1xyXG4gICAgICAgIHZhciBjdXI7XHJcblxyXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQm90dG9tIHRvIFRvcFxyXG5cclxuICAgICAgICAgICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICBweCA9IGl0ZW1zW2xlbl0ueDtcclxuICAgICAgICAgICAgcHkgPSBpdGVtc1tsZW5dLnk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIEN1cnJlbnQgaXRlbVxyXG4gICAgICAgICAgICAgICAgY3VyID0gaXRlbXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIEdldCBjdXJyZW50IGl0ZW0geC95LCB0byBiZSBwYXNzZWQgdG8gdGhlIG5leHQgaXRlbSBpbiB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgY3ggPSBjdXIueDtcclxuICAgICAgICAgICAgICAgIGN5ID0gY3VyLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFNldCBjdXJyZW50IGl0ZW0gdG8gdGhlIHByZXZpb3VzIGl0ZW1zIHgveVxyXG4gICAgICAgICAgICAgICAgY3VyLnggPSBweDtcclxuICAgICAgICAgICAgICAgIGN1ci55ID0gcHk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFNldCBjdXJyZW50IGFzIHByZXZpb3VzXHJcbiAgICAgICAgICAgICAgICBweCA9IGN4O1xyXG4gICAgICAgICAgICAgICAgcHkgPSBjeTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIFVwZGF0ZSB0aGUgaGVhZCBpdGVtIHRvIHRoZSBuZXcgeC95IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGl0ZW1zW2xlbl0ueCA9IHg7XHJcbiAgICAgICAgICAgIGl0ZW1zW2xlbl0ueSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUb3AgdG8gQm90dG9tXHJcblxyXG4gICAgICAgICAgICBweCA9IGl0ZW1zWzBdLng7XHJcbiAgICAgICAgICAgIHB5ID0gaXRlbXNbMF0ueTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIEN1cnJlbnQgaXRlbVxyXG4gICAgICAgICAgICAgICAgY3VyID0gaXRlbXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIEdldCBjdXJyZW50IGl0ZW0geC95LCB0byBiZSBwYXNzZWQgdG8gdGhlIG5leHQgaXRlbSBpbiB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgY3ggPSBjdXIueDtcclxuICAgICAgICAgICAgICAgIGN5ID0gY3VyLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFNldCBjdXJyZW50IGl0ZW0gdG8gdGhlIHByZXZpb3VzIGl0ZW1zIHgveVxyXG4gICAgICAgICAgICAgICAgY3VyLnggPSBweDtcclxuICAgICAgICAgICAgICAgIGN1ci55ID0gcHk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFNldCBjdXJyZW50IGFzIHByZXZpb3VzXHJcbiAgICAgICAgICAgICAgICBweCA9IGN4O1xyXG4gICAgICAgICAgICAgICAgcHkgPSBjeTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIFVwZGF0ZSB0aGUgaGVhZCBpdGVtIHRvIHRoZSBuZXcgeC95IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGl0ZW1zWzBdLnggPSB4O1xyXG4gICAgICAgICAgICBpdGVtc1swXS55ID0geTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcHggPSBpdGVtc1swXS54O1xyXG4gICAgICAgIHB5ID0gaXRlbXNbMF0ueTtcclxuXHJcbiAgICAgICAgaXRlbXNbMF0ueCA9IHg7XHJcbiAgICAgICAgaXRlbXNbMF0ueSA9IHk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFJldHVybiB0aGUgZmluYWwgc2V0IG9mIGNvb3JkaW5hdGVzIGFzIHRoZXkncmUgZWZmZWN0aXZlbHkgbG9zdCBmcm9tIHRoZSBzaGlmdCBhbmQgbWF5IGJlIG5lZWRlZFxyXG5cclxuICAgIG91dHB1dC54ID0gcHg7XHJcbiAgICBvdXRwdXQueSA9IHB5O1xyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoaWZ0UG9zaXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TaGlmdFBvc2l0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1hdGhTbW9vdGhTdGVwID0gcmVxdWlyZSgnLi4vbWF0aC9TbW9vdGhTdGVwJyk7XHJcblxyXG52YXIgU21vb3RoU3RlcCA9IGZ1bmN0aW9uIChpdGVtcywgcHJvcGVydHksIG1pbiwgbWF4LCBpbmMpXHJcbntcclxuICAgIGlmIChpbmMgPT09IHVuZGVmaW5lZCkgeyBpbmMgPSBmYWxzZTsgfVxyXG5cclxuICAgIHZhciBzdGVwID0gTWF0aC5hYnMobWF4IC0gbWluKSAvIGl0ZW1zLmxlbmd0aDtcclxuICAgIHZhciBpO1xyXG5cclxuICAgIGlmIChpbmMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaXRlbXNbaV1bcHJvcGVydHldICs9IE1hdGhTbW9vdGhTdGVwKGkgKiBzdGVwLCBtaW4sIG1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGl0ZW1zW2ldW3Byb3BlcnR5XSA9IE1hdGhTbW9vdGhTdGVwKGkgKiBzdGVwLCBtaW4sIG1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU21vb3RoU3RlcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1Ntb290aFN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDMxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWF0aFNtb290aGVyU3RlcCA9IHJlcXVpcmUoJy4uL21hdGgvU21vb3RoZXJTdGVwJyk7XHJcblxyXG52YXIgU21vb3RoZXJTdGVwID0gZnVuY3Rpb24gKGl0ZW1zLCBwcm9wZXJ0eSwgbWluLCBtYXgsIGluYylcclxue1xyXG4gICAgaWYgKGluYyA9PT0gdW5kZWZpbmVkKSB7IGluYyA9IGZhbHNlOyB9XHJcblxyXG4gICAgdmFyIHN0ZXAgPSBNYXRoLmFicyhtYXggLSBtaW4pIC8gaXRlbXMubGVuZ3RoO1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgaWYgKGluYylcclxuICAgIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpdGVtc1tpXVtwcm9wZXJ0eV0gKz0gTWF0aFNtb290aGVyU3RlcChpICogc3RlcCwgbWluLCBtYXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpdGVtc1tpXVtwcm9wZXJ0eV0gPSBNYXRoU21vb3RoZXJTdGVwKGkgKiBzdGVwLCBtaW4sIG1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU21vb3RoZXJTdGVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvU21vb3RoZXJTdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNwcmVhZCA9IGZ1bmN0aW9uIChpdGVtcywgcHJvcGVydHksIG1pbiwgbWF4LCBpbmMpXHJcbntcclxuICAgIGlmIChpbmMgPT09IHVuZGVmaW5lZCkgeyBpbmMgPSBmYWxzZTsgfVxyXG5cclxuICAgIHZhciBzdGVwID0gTWF0aC5hYnMobWF4IC0gbWluKSAvIGl0ZW1zLmxlbmd0aDtcclxuICAgIHZhciBpO1xyXG5cclxuICAgIGlmIChpbmMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaXRlbXNbaV1bcHJvcGVydHldICs9IGkgKiBzdGVwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpdGVtc1tpXVtwcm9wZXJ0eV0gPSBpICogc3RlcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcHJlYWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TcHJlYWQuanNcbi8vIG1vZHVsZSBpZCA9IDMxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVG9nZ2xlVmlzaWJsZSA9IGZ1bmN0aW9uIChpdGVtcylcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS52aXNpYmxlID0gIWl0ZW1zW2ldLnZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb2dnbGVWaXNpYmxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvVG9nZ2xlVmlzaWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgR2V0RnJhbWVzID0gcmVxdWlyZSgnLi9pbmMvR2V0RnJhbWVzJyk7XHJcblxyXG4vLyAgQSBGcmFtZSBiYXNlZCBBbmltYXRpb25cclxuLy8gIFRoaXMgY29uc2lzdHMgb2YgYSBrZXksIHNvbWUgZGVmYXVsdCB2YWx1ZXMgKGxpa2UgdGhlIGZyYW1lIHJhdGUpIGFuZCBhIGJ1bmNoIG9mIEZyYW1lIG9iamVjdHMuXHJcbi8vICBUaGUgQW5pbWF0aW9uIE1hbmFnZXIgY3JlYXRlcyB0aGVzZVxyXG4vLyAgR2FtZSBPYmplY3RzIGRvbid0IG93biBhbiBpbnN0YW5jZSBvZiB0aGVzZSBkaXJlY3RseVxyXG4vLyAgR2FtZSBPYmplY3RzIGhhdmUgdGhlIEFuaW1hdGlvbiBDb21wb25lbnQsIHdoaWNoIGFyZSBsaWtlIHBsYXloZWFkcyB0byBnbG9iYWwgQW5pbWF0aW9ucyAodGhlc2Ugb2JqZWN0cylcclxuLy8gIFNvIG11bHRpcGxlIEdhbWUgT2JqZWN0cyBjYW4gaGF2ZSBwbGF5aGVhZHMgYWxsIHBvaW50aW5nIHRvIHRoaXMgb25lIEFuaW1hdGlvbiBpbnN0YW5jZVxyXG5cclxudmFyIEFuaW1hdGlvbiA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBBbmltYXRpb24gKG1hbmFnZXIsIGtleSwgY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XHJcblxyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cclxuICAgICAgICAvLyAgQSBmcmFtZSBiYXNlZCBhbmltYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBib25lIGJhc2VkIGFuaW1hdGlvbilcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZnJhbWUnO1xyXG5cclxuICAgICAgICAvLyAgRXh0cmFjdCBhbGwgdGhlIGZyYW1lIGRhdGEgaW50byB0aGUgZnJhbWVzIGFycmF5XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBHZXRGcmFtZXMobWFuYWdlci50ZXh0dXJlTWFuYWdlciwgR2V0VmFsdWUoY29uZmlnLCAnZnJhbWVzJywgW10pKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBmcmFtZSByYXRlIG9mIHBsYXliYWNrIGluIGZyYW1lcyBwZXIgc2Vjb25kIChkZWZhdWx0IDI0IGlmIGR1cmF0aW9uIGlzIG51bGwpXHJcbiAgICAgICAgdGhpcy5mcmFtZVJhdGUgPSBHZXRWYWx1ZShjb25maWcsICdmcmFtZVJhdGUnLCBudWxsKTtcclxuXHJcbiAgICAgICAgLy8gIEhvdyBsb25nIHRoZSBhbmltYXRpb24gc2hvdWxkIHBsYXkgZm9yLiBJZiBmcmFtZVJhdGUgaXMgc2V0IGl0IG92ZXJyaWRlcyB0aGlzIHZhbHVlXHJcbiAgICAgICAgLy8gIG90aGVyd2lzZSBmcmFtZVJhdGUgaXMgZGVyaXZlZCBmcm9tIGR1cmF0aW9uXHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IEdldFZhbHVlKGNvbmZpZywgJ2R1cmF0aW9uJywgbnVsbCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmR1cmF0aW9uID09PSBudWxsICYmIHRoaXMuZnJhbWVSYXRlID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIE5vIGR1cmF0aW9uIG9yIGZyYW1lUmF0ZSBnaXZlbiwgdXNlIGRlZmF1bHQgZnJhbWVSYXRlIG9mIDI0ZnBzXHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVSYXRlID0gMjQ7XHJcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSB0aGlzLmZyYW1lUmF0ZSAvIHRoaXMuZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kdXJhdGlvbiAmJiB0aGlzLmZyYW1lUmF0ZSA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBEdXJhdGlvbiBnaXZlbiBidXQgbm8gZnJhbWVSYXRlLCBzbyBzZXQgdGhlIGZyYW1lUmF0ZSBiYXNlZCBvbiBkdXJhdGlvblxyXG4gICAgICAgICAgICAvLyAgSS5lLiAxMiBmcmFtZXMgaW4gdGhlIGFuaW1hdGlvbiwgZHVyYXRpb24gPSA0ICg0MDAwIG1zKVxyXG4gICAgICAgICAgICAvLyAgU28gZnJhbWVSYXRlIGlzIDEyIC8gNCA9IDMgZnBzXHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVSYXRlID0gdGhpcy5mcmFtZXMubGVuZ3RoIC8gdGhpcy5kdXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIGZyYW1lUmF0ZSBnaXZlbiwgZGVyaXZlIGR1cmF0aW9uIGZyb20gaXQgKGV2ZW4gaWYgZHVyYXRpb24gYWxzbyBzcGVjaWZpZWQpXHJcbiAgICAgICAgICAgIC8vICBJLmUuIDE1IGZyYW1lcyBpbiB0aGUgYW5pbWF0aW9uLCBmcmFtZVJhdGUgPSAzMCBmcHNcclxuICAgICAgICAgICAgLy8gIFNvIGR1cmF0aW9uIGlzIDE1IC8gMzAgPSAwLjUgKGhhbGYgYSBzZWNvbmQpXHJcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSB0aGlzLmZyYW1lcy5sZW5ndGggLyB0aGlzLmZyYW1lUmF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBtcyBwZXIgZnJhbWUgKHdpdGhvdXQgaW5jbHVkaW5nIGZyYW1lIHNwZWNpZmljIG1vZGlmaWVycylcclxuICAgICAgICB0aGlzLm1zUGVyRnJhbWUgPSAxMDAwIC8gdGhpcy5mcmFtZVJhdGU7XHJcblxyXG4gICAgICAgIC8vICBTa2lwIGZyYW1lcyBpZiB0aGUgdGltZSBsYWdzLCBvciBhbHdheXMgYWR2YW5jZWQgYW55d2F5P1xyXG4gICAgICAgIHRoaXMuc2tpcE1pc3NlZEZyYW1lcyA9IEdldFZhbHVlKGNvbmZpZywgJ3NraXBNaXNzZWRGcmFtZXMnLCB0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gIERlbGF5IGJlZm9yZSBzdGFydGluZyBwbGF5YmFjayAoaW4gc2Vjb25kcylcclxuICAgICAgICB0aGlzLmRlbGF5ID0gR2V0VmFsdWUoY29uZmlnLCAnZGVsYXknLCAwKTtcclxuXHJcbiAgICAgICAgLy8gIE51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIGFuaW1hdGlvbiAoLTEgZm9yIGluZmluaXR5KVxyXG4gICAgICAgIHRoaXMucmVwZWF0ID0gR2V0VmFsdWUoY29uZmlnLCAncmVwZWF0JywgMCk7XHJcblxyXG4gICAgICAgIC8vICBEZWxheSBiZWZvcmUgdGhlIHJlcGVhdCBzdGFydHMgKGluIHNlY29uZHMpXHJcbiAgICAgICAgdGhpcy5yZXBlYXREZWxheSA9IEdldFZhbHVlKGNvbmZpZywgJ3JlcGVhdERlbGF5JywgMCk7XHJcblxyXG4gICAgICAgIC8vICBTaG91bGQgdGhlIGFuaW1hdGlvbiB5b3lvPyAocmV2ZXJzZSBiYWNrIGRvd24gdG8gdGhlIHN0YXJ0KSBiZWZvcmUgcmVwZWF0aW5nP1xyXG4gICAgICAgIHRoaXMueW95byA9IEdldFZhbHVlKGNvbmZpZywgJ3lveW8nLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vICBTaG91bGQgc3ByaXRlLnZpc2libGUgPSB0cnVlIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHMgdG8gcGxheT9cclxuICAgICAgICB0aGlzLnNob3dPblN0YXJ0ID0gR2V0VmFsdWUoY29uZmlnLCAnc2hvd09uU3RhcnQnLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vICBTaG91bGQgc3ByaXRlLnZpc2libGUgPSBmYWxzZSB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXM/XHJcbiAgICAgICAgdGhpcy5oaWRlT25Db21wbGV0ZSA9IEdldFZhbHVlKGNvbmZpZywgJ2hpZGVPbkNvbXBsZXRlJywgZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyAgQ2FsbGJhY2tzXHJcbiAgICAgICAgdGhpcy5jYWxsYmFja1Njb3BlID0gR2V0VmFsdWUoY29uZmlnLCAnY2FsbGJhY2tTY29wZScsIHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLm9uU3RhcnQgPSBHZXRWYWx1ZShjb25maWcsICdvblN0YXJ0JywgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMub25TdGFydFBhcmFtcyA9IEdldFZhbHVlKGNvbmZpZywgJ29uU3RhcnRQYXJhbXMnLCBbXSk7XHJcblxyXG4gICAgICAgIHRoaXMub25SZXBlYXQgPSBHZXRWYWx1ZShjb25maWcsICdvblJlcGVhdCcsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLm9uUmVwZWF0UGFyYW1zID0gR2V0VmFsdWUoY29uZmlnLCAnb25SZXBlYXRQYXJhbXMnLCBbXSk7XHJcblxyXG4gICAgICAgIC8vICBDYWxsZWQgZm9yIEVWRVJZIGZyYW1lIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgLy8gIFNlZSBBbmltYXRpb25GcmFtZS5vblVwZGF0ZSBmb3IgYSBmcmFtZSBzcGVjaWZpYyBjYWxsYmFjay5cclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gR2V0VmFsdWUoY29uZmlnLCAnb25VcGRhdGUnLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZVBhcmFtcyA9IEdldFZhbHVlKGNvbmZpZywgJ29uVXBkYXRlUGFyYW1zJywgW10pO1xyXG5cclxuICAgICAgICB0aGlzLm9uQ29tcGxldGUgPSBHZXRWYWx1ZShjb25maWcsICdvbkNvbXBsZXRlJywgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMub25Db21wbGV0ZVBhcmFtcyA9IEdldFZhbHVlKGNvbmZpZywgJ29uQ29tcGxldGVQYXJhbXMnLCBbXSk7XHJcblxyXG4gICAgICAgIC8vICBHbG9iYWwgcGF1c2UsIGVmZmVjdHMgYWxsIEdhbWUgT2JqZWN0cyB1c2luZyB0aGlzIEFuaW1hdGlvbiBpbnN0YW5jZVxyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5ldmVudHMub24oJ1BBVVNFX0FMTF9BTklNQVRJT05fRVZFTlQnLCB0aGlzLnBhdXNlLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5ldmVudHMub24oJ1JFU1VNRV9BTExfQU5JTUFUSU9OX0VWRU5UJywgdGhpcy5yZXN1bWUuYmluZCh0aGlzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEZyYW1lOiByZXF1aXJlKCcuL2luYy9BZGRGcmFtZScpLFxyXG4gICAgYWRkRnJhbWVBdDogcmVxdWlyZSgnLi9pbmMvQWRkRnJhbWVBdCcpLFxyXG4gICAgY2hlY2tGcmFtZTogcmVxdWlyZSgnLi9pbmMvQ2hlY2tGcmFtZScpLFxyXG4gICAgY29tcGxldGVBbmltYXRpb246IHJlcXVpcmUoJy4vaW5jL0NvbXBsZXRlQW5pbWF0aW9uJyksXHJcbiAgICBnZXRGaXJzdFRpY2s6IHJlcXVpcmUoJy4vaW5jL0dldEZpcnN0VGljaycpLFxyXG4gICAgZ2V0RnJhbWVBdDogcmVxdWlyZSgnLi9pbmMvR2V0RnJhbWVBdCcpLFxyXG4gICAgZ2V0TmV4dFRpY2s6IHJlcXVpcmUoJy4vaW5jL0dldE5leHRUaWNrJyksXHJcbiAgICBsb2FkOiByZXF1aXJlKCcuL2luYy9Mb2FkJyksXHJcbiAgICBuZXh0RnJhbWU6IHJlcXVpcmUoJy4vaW5jL05leHRGcmFtZScpLFxyXG4gICAgcHJldmlvdXNGcmFtZTogcmVxdWlyZSgnLi9pbmMvUHJldmlvdXNGcmFtZScpLFxyXG4gICAgcmVtb3ZlRnJhbWU6IHJlcXVpcmUoJy4vaW5jL1JlbW92ZUZyYW1lJyksXHJcbiAgICByZW1vdmVGcmFtZUF0OiByZXF1aXJlKCcuL2luYy9SZW1vdmVGcmFtZUF0JyksXHJcbiAgICByZXBlYXRBbmltYXRpb246IHJlcXVpcmUoJy4vaW5jL1JlcGVhdEFuaW1hdGlvbicpLFxyXG4gICAgc2V0RnJhbWU6IHJlcXVpcmUoJy4vaW5jL1NldEZyYW1lJyksXHJcbiAgICB0b0pTT046IHJlcXVpcmUoJy4vaW5jL1RvSlNPTicpLFxyXG4gICAgdXBkYXRlRnJhbWVTZXF1ZW5jZTogcmVxdWlyZSgnLi9pbmMvVXBkYXRlRnJhbWVTZXF1ZW5jZScpLFxyXG5cclxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzdW1lOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvQW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIGNvbmZpZyA9IEFycmF5IG9mIEFuaW1hdGlvbiBjb25maWcgb2JqZWN0cywgbGlrZTpcclxuLy8gIFtcclxuLy8gICAgICB7IGtleTogJ2dlbXMnLCBmcmFtZTogJ2RpYW1vbmQwMDAxJywgW2R1cmF0aW9uXSwgW3Zpc2libGVdLCBbb25VcGRhdGVdIH1cclxuLy8gIF1cclxuXHJcbi8vICBBZGQgZnJhbWVzIHRvIHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvblxyXG52YXIgQWRkRnJhbWUgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5hZGRGcmFtZUF0KHRoaXMuZnJhbWVzLmxlbmd0aCwgY29uZmlnKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkRnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL2luYy9BZGRGcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMzIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRGcmFtZXMgPSByZXF1aXJlKCcuL0dldEZyYW1lcycpO1xyXG5cclxuLy8gIGNvbmZpZyA9IEFycmF5IG9mIEFuaW1hdGlvbiBjb25maWcgb2JqZWN0cywgbGlrZTpcclxuLy8gIFtcclxuLy8gICAgICB7IGtleTogJ2dlbXMnLCBmcmFtZTogJ2RpYW1vbmQwMDAxJywgW2R1cmF0aW9uXSwgW3Zpc2libGVdLCBbb25VcGRhdGVdIH1cclxuLy8gIF1cclxuXHJcbi8vICBBZGQgZnJhbWUvcyBpbnRvIHRoZSBhbmltYXRpb25cclxudmFyIEFkZEZyYW1lQXQgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbmZpZylcclxue1xyXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XHJcblxyXG4gICAgdmFyIG5ld0ZyYW1lcyA9IEdldEZyYW1lcyh0aGlzLm1hbmFnZXIudGV4dHVyZU1hbmFnZXIsIGNvbmZpZyk7XHJcblxyXG4gICAgaWYgKG5ld0ZyYW1lcy5sZW5ndGggPiAwKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gbmV3RnJhbWVzLmNvbmNhdCh0aGlzLmZyYW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLmZyYW1lcy5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lcyA9IHRoaXMuZnJhbWVzLmNvbmNhdChuZXdGcmFtZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcHJlID0gdGhpcy5mcmFtZXMuc2xpY2UoMCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB2YXIgcG9zdCA9IHRoaXMuZnJhbWVzLnNsaWNlKGluZGV4KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gcHJlLmNvbmNhdChuZXdGcmFtZXMsIHBvc3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVGcmFtZVNlcXVlbmNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZEZyYW1lQXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL2luYy9BZGRGcmFtZUF0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENoZWNrRnJhbWUgPSBmdW5jdGlvbiAoaW5kZXgpXHJcbntcclxuICAgIHJldHVybiAoaW5kZXggPCB0aGlzLmZyYW1lcy5sZW5ndGgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaGVja0ZyYW1lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9pbmMvQ2hlY2tGcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMzIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb21wbGV0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChjb21wb25lbnQpXHJcbntcclxuICAgIGlmICh0aGlzLmhpZGVPbkNvbXBsZXRlKVxyXG4gICAge1xyXG4gICAgICAgIGNvbXBvbmVudC5wYXJlbnQudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudC5zdG9wKHRydWUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb21wbGV0ZUFuaW1hdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvaW5jL0NvbXBsZXRlQW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZyYW1lID0gZnVuY3Rpb24gKHRleHR1cmVLZXksIHRleHR1cmVGcmFtZSwgaW5kZXgsIGZyYW1lKVxyXG57XHJcbiAgICAvLyAgVGhlIGtleXMgaW50byB0aGUgVGV4dHVyZSBNYW5hZ2VyIG9mIHRoZSB0ZXh0dXJlICsgZnJhbWUgdGhpcyB1c2VzXHJcbiAgICB0aGlzLnRleHR1cmVLZXkgPSB0ZXh0dXJlS2V5O1xyXG4gICAgdGhpcy50ZXh0dXJlRnJhbWUgPSB0ZXh0dXJlRnJhbWU7XHJcblxyXG4gICAgLy8gIFRoZSBpbmRleCBvZiB0aGlzIGZyYW1lIHdpdGhpbiB0aGUgQW5pbWF0aW9uLmZyYW1lcyBhcnJheVxyXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuICAgIC8vICBUZXh0dXJlIEZyYW1lXHJcbiAgICB0aGlzLmZyYW1lID0gZnJhbWU7XHJcblxyXG4gICAgLy8gIFJlYWQtb25seVxyXG4gICAgdGhpcy5pc0ZpcnN0ID0gZmFsc2U7XHJcblxyXG4gICAgLy8gIFJlYWQtb25seVxyXG4gICAgdGhpcy5pc0xhc3QgPSBmYWxzZTtcclxuXHJcbiAgICAvLyAgVGhlIGZyYW1lIHRoYXQgY29tZXMgYmVmb3JlIHRoaXMgb25lIGluIHRoZSBhbmltYXRpb24gKGlmIGFueSlcclxuICAgIC8vICBSZWFkLW9ubHlcclxuICAgIHRoaXMucHJldkZyYW1lID0gbnVsbDtcclxuXHJcbiAgICAvLyAgVGhlIGZyYW1lIHRoYXQgY29tZXMgYWZ0ZXIgdGhpcyBvbmUgaW4gdGhlIGFuaW1hdGlvbiAoaWYgYW55KVxyXG4gICAgLy8gIFJlYWQtb25seVxyXG4gICAgdGhpcy5uZXh0RnJhbWUgPSBudWxsO1xyXG5cclxuICAgIC8vICAgQWRkaXRpb25hbCB0aW1lIChpbiBtcykgdGhpcyBmcmFtZSBzaG91bGQgYXBwZWFyIGZvciAtIGFkZGVkIG9udG8gdGhlIG1zUGVyRnJhbWVcclxuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xyXG5cclxuICAgIC8vICAgV2hhdCAlIHRocm91Z2ggdGhlIGFuaW1hdGlvbiBwcm9ncmVzcyBpcyB0aGlzIGZyYW1lP1xyXG4gICAgLy8gIFJlYWQtb25seVxyXG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XHJcblxyXG4gICAgLy8gIENhbGxiYWNrIGlmIHRoaXMgZnJhbWUgZ2V0cyBkaXNwbGF5ZWRcclxuICAgIHRoaXMub25VcGRhdGUgPSBudWxsO1xyXG5cclxuICAgIC8vICBXaGVuIHRoaXMgZnJhbWUgaGl0cywgc2V0IHNwcml0ZS52aXNpYmxlIHRvIHRoaXNcclxuICAgIHRoaXMuc2V0VmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG59O1xyXG5cclxuRnJhbWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJhbWU7XHJcblxyXG5GcmFtZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtleTogdGhpcy50ZXh0dXJlS2V5LFxyXG4gICAgICAgICAgICBmcmFtZTogdGhpcy50ZXh0dXJlRnJhbWUsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGVcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZnJhbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9pbmMvRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDMyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0Rmlyc3RUaWNrID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5jbHVkZURlbGF5KVxyXG57XHJcbiAgICBpZiAoaW5jbHVkZURlbGF5ID09PSB1bmRlZmluZWQpIHsgaW5jbHVkZURlbGF5ID0gdHJ1ZTsgfVxyXG5cclxuICAgIC8vICBXaGVuIGlzIHRoZSBmaXJzdCB1cGRhdGUgZHVlP1xyXG4gICAgY29tcG9uZW50LmFjY3VtdWxhdG9yID0gMDtcclxuICAgIGNvbXBvbmVudC5uZXh0VGljayA9IGNvbXBvbmVudC5tc1BlckZyYW1lICsgY29tcG9uZW50LmN1cnJlbnRGcmFtZS5kdXJhdGlvbjtcclxuXHJcbiAgICBpZiAoaW5jbHVkZURlbGF5KVxyXG4gICAge1xyXG4gICAgICAgIGNvbXBvbmVudC5uZXh0VGljayArPSAoY29tcG9uZW50Ll9kZWxheSAqIDEwMDApO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRGaXJzdFRpY2s7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL2luYy9HZXRGaXJzdFRpY2suanNcbi8vIG1vZHVsZSBpZCA9IDMyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0RnJhbWVBdCA9IGZ1bmN0aW9uIChpbmRleClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuZnJhbWVzW2luZGV4XTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0RnJhbWVBdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvaW5jL0dldEZyYW1lQXQuanNcbi8vIG1vZHVsZSBpZCA9IDMyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TmV4dFRpY2sgPSBmdW5jdGlvbiAoY29tcG9uZW50KVxyXG57XHJcbiAgICAvLyBhY2N1bXVsYXRvciArPSBkZWx0YSAqIF90aW1lU2NhbGVcclxuICAgIC8vIGFmdGVyIGEgbGFyZ2UgZGVsdGEgc3VyZ2UgKHBlcmYgaXNzdWUgZm9yIGV4YW1wbGUpIHdlIG5lZWQgdG8gYWRqdXN0IGZvciBpdCBoZXJlXHJcblxyXG4gICAgLy8gIFdoZW4gaXMgdGhlIG5leHQgdXBkYXRlIGR1ZT9cclxuICAgIGNvbXBvbmVudC5hY2N1bXVsYXRvciAtPSBjb21wb25lbnQubmV4dFRpY2s7XHJcblxyXG4gICAgY29tcG9uZW50Lm5leHRUaWNrID0gY29tcG9uZW50Lm1zUGVyRnJhbWUgKyBjb21wb25lbnQuY3VycmVudEZyYW1lLmR1cmF0aW9uO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXROZXh0VGljaztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvaW5jL0dldE5leHRUaWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExvYWQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBzdGFydEZyYW1lKVxyXG57XHJcbiAgICBpZiAoc3RhcnRGcmFtZSA+PSB0aGlzLmZyYW1lcy5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgc3RhcnRGcmFtZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbXBvbmVudC5jdXJyZW50QW5pbSAhPT0gdGhpcylcclxuICAgIHtcclxuICAgICAgICBjb21wb25lbnQuY3VycmVudEFuaW0gPSB0aGlzO1xyXG5cclxuICAgICAgICBjb21wb25lbnQuX3RpbWVTY2FsZSA9IDE7XHJcbiAgICAgICAgY29tcG9uZW50LmZyYW1lUmF0ZSA9IHRoaXMuZnJhbWVSYXRlO1xyXG4gICAgICAgIGNvbXBvbmVudC5kdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XHJcbiAgICAgICAgY29tcG9uZW50Lm1zUGVyRnJhbWUgPSB0aGlzLm1zUGVyRnJhbWU7XHJcbiAgICAgICAgY29tcG9uZW50LnNraXBNaXNzZWRGcmFtZXMgPSB0aGlzLnNraXBNaXNzZWRGcmFtZXM7XHJcbiAgICAgICAgY29tcG9uZW50Ll9kZWxheSA9IHRoaXMuZGVsYXk7XHJcbiAgICAgICAgY29tcG9uZW50Ll9yZXBlYXQgPSB0aGlzLnJlcGVhdDtcclxuICAgICAgICBjb21wb25lbnQuX3JlcGVhdERlbGF5ID0gdGhpcy5yZXBlYXREZWxheTtcclxuICAgICAgICBjb21wb25lbnQuX3lveW8gPSB0aGlzLnlveW87XHJcbiAgICAgICAgY29tcG9uZW50Ll9jYWxsYmFja0FyZ3NbMV0gPSB0aGlzO1xyXG4gICAgICAgIGNvbXBvbmVudC5fdXBkYXRlUGFyYW1zID0gY29tcG9uZW50Ll9jYWxsYmFja0FyZ3MuY29uY2F0KHRoaXMub25VcGRhdGVQYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudC51cGRhdGVGcmFtZSh0aGlzLmZyYW1lc1tzdGFydEZyYW1lXSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL2luYy9Mb2FkLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE5leHRGcmFtZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpXHJcbntcclxuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudC5jdXJyZW50RnJhbWU7XHJcblxyXG4gICAgLy8gIFRPRE86IEFkZCBmcmFtZSBza2lwIHN1cHBvcnRcclxuXHJcbiAgICBpZiAoZnJhbWUuaXNMYXN0KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBXZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb25cclxuXHJcbiAgICAgICAgLy8gIFlveW8/IChoYXBwZW5zIGJlZm9yZSByZXBlYXQpXHJcbiAgICAgICAgaWYgKHRoaXMueW95bylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5mb3J3YXJkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBjb21wb25lbnQudXBkYXRlRnJhbWUoZnJhbWUucHJldkZyYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBEZWxheSBmb3IgdGhlIGN1cnJlbnQgZnJhbWVcclxuICAgICAgICAgICAgdGhpcy5nZXROZXh0VGljayhjb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQucmVwZWF0Q291bnRlciA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUmVwZWF0IChoYXBwZW5zIGJlZm9yZSBjb21wbGV0ZSlcclxuICAgICAgICAgICAgdGhpcy5yZXBlYXRBbmltYXRpb24oY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbihjb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBjb21wb25lbnQudXBkYXRlRnJhbWUoZnJhbWUubmV4dEZyYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXROZXh0VGljayhjb21wb25lbnQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOZXh0RnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL2luYy9OZXh0RnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDMzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUHJldmlvdXNGcmFtZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpXHJcbntcclxuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudC5jdXJyZW50RnJhbWU7XHJcblxyXG4gICAgLy8gIFRPRE86IEFkZCBmcmFtZSBza2lwIHN1cHBvcnRcclxuXHJcbiAgICBpZiAoZnJhbWUuaXNGaXJzdClcclxuICAgIHtcclxuICAgICAgICAvLyAgV2UncmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhbmltYXRpb25cclxuXHJcbiAgICAgICAgaWYgKGNvbXBvbmVudC5yZXBlYXRDb3VudGVyID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBSZXBlYXQgKGhhcHBlbnMgYmVmb3JlIGNvbXBsZXRlKVxyXG4gICAgICAgICAgICB0aGlzLnJlcGVhdEFuaW1hdGlvbihjb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlQW5pbWF0aW9uKGNvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGNvbXBvbmVudC51cGRhdGVGcmFtZShmcmFtZS5wcmV2RnJhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmdldE5leHRUaWNrKGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByZXZpb3VzRnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL2luYy9QcmV2aW91c0ZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFJlbW92ZSBmcmFtZSBpZiBpdCBtYXRjaGVzIHRoZSBnaXZlbiBmcmFtZVxyXG52YXIgUmVtb3ZlRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWUpXHJcbntcclxuICAgIHZhciBpbmRleCA9IHRoaXMuZnJhbWVzLmluZGV4T2YoZnJhbWUpO1xyXG5cclxuICAgIGlmIChpbmRleCAhPT0gLTEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVGcmFtZUF0KGluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlRnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL2luYy9SZW1vdmVGcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMzMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZW1vdmVGcmFtZUF0ID0gZnVuY3Rpb24gKGluZGV4KVxyXG57XHJcbiAgICB0aGlzLmZyYW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlRnJhbWVTZXF1ZW5jZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVGcmFtZUF0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9pbmMvUmVtb3ZlRnJhbWVBdC5qc1xuLy8gbW9kdWxlIGlkID0gMzMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZXBlYXRBbmltYXRpb24gPSBmdW5jdGlvbiAoY29tcG9uZW50KVxyXG57XHJcbiAgICBpZiAoY29tcG9uZW50Ll9yZXBlYXREZWxheSA+IDAgJiYgY29tcG9uZW50LnBlbmRpbmdSZXBlYXQgPT09IGZhbHNlKVxyXG4gICAge1xyXG4gICAgICAgIGNvbXBvbmVudC5wZW5kaW5nUmVwZWF0ID0gdHJ1ZTtcclxuICAgICAgICBjb21wb25lbnQuYWNjdW11bGF0b3IgLT0gY29tcG9uZW50Lm5leHRUaWNrO1xyXG4gICAgICAgIGNvbXBvbmVudC5uZXh0VGljayArPSAoY29tcG9uZW50Ll9yZXBlYXREZWxheSAqIDEwMDApO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGNvbXBvbmVudC5yZXBlYXRDb3VudGVyLS07XHJcblxyXG4gICAgICAgIGNvbXBvbmVudC5mb3J3YXJkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgY29tcG9uZW50LnVwZGF0ZUZyYW1lKGNvbXBvbmVudC5jdXJyZW50RnJhbWUubmV4dEZyYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXROZXh0VGljayhjb21wb25lbnQpO1xyXG5cclxuICAgICAgICBjb21wb25lbnQucGVuZGluZ1JlcGVhdCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5vblJlcGVhdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMub25SZXBlYXQuYXBwbHkodGhpcy5jYWxsYmFja1Njb3BlLCBjb21wb25lbnQuX2NhbGxiYWNrQXJncy5jb25jYXQodGhpcy5vblJlcGVhdFBhcmFtcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVwZWF0QW5pbWF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9pbmMvUmVwZWF0QW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldEZyYW1lID0gZnVuY3Rpb24gKGNvbXBvbmVudClcclxue1xyXG4gICAgLy8gIFdvcmsgb3V0IHdoaWNoIGZyYW1lIHNob3VsZCBiZSBzZXQgbmV4dCBvbiB0aGUgY2hpbGQsIGFuZCBzZXQgaXRcclxuICAgIGlmIChjb21wb25lbnQuZm9yd2FyZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm5leHRGcmFtZShjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNGcmFtZShjb21wb25lbnQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRGcmFtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvaW5jL1NldEZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRvSlNPTiA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBvdXRwdXQgPSB7XHJcbiAgICAgICAga2V5OiB0aGlzLmtleSxcclxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgZnJhbWVzOiBbXSxcclxuICAgICAgICBmcmFtZVJhdGU6IHRoaXMuZnJhbWVSYXRlLFxyXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgIHNraXBNaXNzZWRGcmFtZXM6IHRoaXMuc2tpcE1pc3NlZEZyYW1lcyxcclxuICAgICAgICBkZWxheTogdGhpcy5kZWxheSxcclxuICAgICAgICByZXBlYXQ6IHRoaXMucmVwZWF0LFxyXG4gICAgICAgIHJlcGVhdERlbGF5OiB0aGlzLnJlcGVhdERlbGF5LFxyXG4gICAgICAgIHlveW86IHRoaXMueW95byxcclxuICAgICAgICBzaG93T25TdGFydDogdGhpcy5zaG93T25TdGFydCxcclxuICAgICAgICBoaWRlT25Db21wbGV0ZTogdGhpcy5oaWRlT25Db21wbGV0ZVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQuZnJhbWVzLnB1c2goZnJhbWUudG9KU09OKCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9KU09OO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9pbmMvVG9KU09OLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFVwZGF0ZUZyYW1lU2VxdWVuY2UgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgbGVuID0gdGhpcy5mcmFtZXMubGVuZ3RoO1xyXG4gICAgdmFyIHNsaWNlID0gMSAvIChsZW4gLSAxKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVzW2ldO1xyXG5cclxuICAgICAgICBmcmFtZS5pbmRleCA9IGkgKyAxO1xyXG4gICAgICAgIGZyYW1lLmlzRmlyc3QgPSBmYWxzZTtcclxuICAgICAgICBmcmFtZS5pc0xhc3QgPSBmYWxzZTtcclxuICAgICAgICBmcmFtZS5wcm9ncmVzcyA9IGkgKiBzbGljZTtcclxuXHJcbiAgICAgICAgaWYgKGkgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmcmFtZS5pc0ZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgZnJhbWUuaXNMYXN0ID0gKGxlbiA9PT0gMSk7XHJcbiAgICAgICAgICAgIGZyYW1lLnByZXZGcmFtZSA9IHRoaXMuZnJhbWVzW2xlbiAtIDFdO1xyXG4gICAgICAgICAgICBmcmFtZS5uZXh0RnJhbWUgPSB0aGlzLmZyYW1lc1tpICsgMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGkgPT09IGxlbiAtIDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmcmFtZS5pc0xhc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBmcmFtZS5wcmV2RnJhbWUgPSB0aGlzLmZyYW1lc1tsZW4gLSAyXTtcclxuICAgICAgICAgICAgZnJhbWUubmV4dEZyYW1lID0gdGhpcy5mcmFtZXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmcmFtZS5wcmV2RnJhbWUgPSB0aGlzLmZyYW1lc1tpIC0gMV07XHJcbiAgICAgICAgICAgIGZyYW1lLm5leHRGcmFtZSA9IHRoaXMuZnJhbWVzW2kgKyAxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVwZGF0ZUZyYW1lU2VxdWVuY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL2luYy9VcGRhdGVGcmFtZVNlcXVlbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxudmFyIE1hcCA9IHJlcXVpcmUoJy4uLy4uL3N0cnVjdHMvTWFwJyk7XHJcblxyXG4vLyBBbmltYXRpb25zIGFyZSBtYW5hZ2VkIGJ5IHRoZSBnbG9iYWwgQW5pbWF0aW9uTWFuYWdlci4gVGhpcyBpcyBhIHNpbmdsZXRvbiBjbGFzcyB0aGF0IGlzXHJcbi8vIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgZGVsaXZlcmluZyBhbmltYXRpb25zIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGRhdGEgdG8gR2FtZSBPYmplY3RzLlxyXG4vLyBTcHJpdGVzIGFuZCBvdGhlciBHYW1lIE9iamVjdHMgZ2V0IHRoZSBkYXRhIHRoZXkgbmVlZCBmcm9tIHRoZSBBbmltYXRpb25NYW5hZ2VyLlxyXG4vLyBBY2Nlc3MgaXQgdmlhIGBzY2VuZS5hbmltc2AuXHJcblxyXG52YXIgQW5pbWF0aW9uTWFuYWdlciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBBbmltYXRpb25NYW5hZ2VyIChnYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nbG9iYWxUaW1lU2NhbGUgPSAxO1xyXG5cclxuICAgICAgICB0aGlzLmFuaW1zID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBib290OiBmdW5jdGlvbiAodGV4dHVyZU1hbmFnZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlciA9IHRleHR1cmVNYW5hZ2VyO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IHJlcXVpcmUoJy4vaW5jL0FkZEFuaW1hdGlvbicpLFxyXG4gICAgY3JlYXRlOiByZXF1aXJlKCcuL2luYy9DcmVhdGVGcmFtZUFuaW1hdGlvbicpLFxyXG4gICAgZnJvbUpTT046IHJlcXVpcmUoJy4vaW5jL0Zyb21KU09OJyksXHJcbiAgICBnZW5lcmF0ZUZyYW1lTmFtZXM6IHJlcXVpcmUoJy4vaW5jL0dlbmVyYXRlRnJhbWVOYW1lcycpLFxyXG4gICAgZ2VuZXJhdGVGcmFtZU51bWJlcnM6IHJlcXVpcmUoJy4vaW5jL0dlbmVyYXRlRnJhbWVOdW1iZXJzJyksXHJcbiAgICBnZXQ6IHJlcXVpcmUoJy4vaW5jL0dldEFuaW1hdGlvbicpLFxyXG4gICAgbG9hZDogcmVxdWlyZSgnLi9pbmMvTG9hZEFuaW1hdGlvblRvR2FtZU9iamVjdCcpLFxyXG4gICAgcGF1c2VBbGw6IHJlcXVpcmUoJy4vaW5jL1BhdXNlQWxsJyksXHJcbiAgICBwbGF5OiByZXF1aXJlKCcuL2luYy9QbGF5QW5pbWF0aW9uJyksXHJcbiAgICByZW1vdmU6IHJlcXVpcmUoJy4vaW5jL1JlbW92ZUFuaW1hdGlvbicpLFxyXG4gICAgcmVzdW1lQWxsOiByZXF1aXJlKCcuL2luYy9SZXN1bWVBbGwnKSxcclxuICAgIHN0YWdnZXJQbGF5OiByZXF1aXJlKCcuL2luYy9TdGFnZ2VyUGxheUFuaW1hdGlvbicpLFxyXG4gICAgdG9KU09OOiByZXF1aXJlKCcuL2luYy9Ub0pTT04nKSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUT0RPXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0aW9uTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9BbmltYXRpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgQWRkQW5pbWF0aW9uRXZlbnQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEV2ZW50LFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQWRkQW5pbWF0aW9uRXZlbnQgKGtleSwgYW5pbWF0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ0FERF9BTklNQVRJT05fRVZFTlQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkQW5pbWF0aW9uRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvZXZlbnRzL0FkZEFuaW1hdGlvbkV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgUGF1c2VBbGxBbmltYXRpb25FdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBQYXVzZUFsbEFuaW1hdGlvbkV2ZW50ICgpXHJcbiAgICB7XHJcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCAnUEFVU0VfQUxMX0FOSU1BVElPTl9FVkVOVCcpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhdXNlQWxsQW5pbWF0aW9uRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvZXZlbnRzL1BhdXNlQWxsQW5pbWF0aW9uRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDM0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBSZW1vdmVBbmltYXRpb25FdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBSZW1vdmVBbmltYXRpb25FdmVudCAoa2V5LCBhbmltYXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCAnUkVNT1ZFX0FOSU1BVElPTl9FVkVOVCcpO1xyXG5cclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVBbmltYXRpb25FdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9ldmVudHMvUmVtb3ZlQW5pbWF0aW9uRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDM0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBSZXN1bWVBbGxBbmltYXRpb25FdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBSZXN1bWVBbGxBbmltYXRpb25FdmVudCAoKVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ1JFU1VNRV9BTExfQU5JTUFUSU9OX0VWRU5UJyk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzdW1lQWxsQW5pbWF0aW9uRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvZXZlbnRzL1Jlc3VtZUFsbEFuaW1hdGlvbkV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnRzLycpO1xyXG5cclxudmFyIEFkZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChrZXksIGFuaW1hdGlvbilcclxue1xyXG4gICAgaWYgKHRoaXMuYW5pbXMuaGFzKGtleSkpXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignQW5pbWF0aW9uIHdpdGgga2V5Jywga2V5LCAnYWxyZWFkeSBleGlzdHMnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgYW5pbWF0aW9uLmtleSA9IGtleTtcclxuXHJcbiAgICB0aGlzLmFuaW1zLnNldChrZXksIGFuaW1hdGlvbik7XHJcblxyXG4gICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IEV2ZW50LkFERF9BTklNQVRJT05fRVZFTlQoa2V5LCBhbmltYXRpb24pKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkQW5pbWF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2luYy9BZGRBbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi9ldmVudHMvJyk7XHJcbnZhciBBbmltYXRpb24gPSByZXF1aXJlKCcuLi8uLi9mcmFtZS9BbmltYXRpb24nKTtcclxuXHJcbnZhciBDcmVhdGVGcmFtZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHZhciBrZXkgPSBjb25maWcua2V5O1xyXG5cclxuICAgIGlmICgha2V5IHx8IHRoaXMuYW5pbXMuaGFzKGtleSkpXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIEFuaW1hdGlvbiBLZXksIG9yIEtleSBhbHJlYWR5IGluIHVzZTogJyArIGtleSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhbmltID0gbmV3IEFuaW1hdGlvbih0aGlzLCBrZXksIGNvbmZpZyk7XHJcblxyXG4gICAgdGhpcy5hbmltcy5zZXQoa2V5LCBhbmltKTtcclxuXHJcbiAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuQUREX0FOSU1BVElPTl9FVkVOVChrZXksIGFuaW0pKTtcclxuXHJcbiAgICByZXR1cm4gYW5pbTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlRnJhbWVBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvaW5jL0NyZWF0ZUZyYW1lQW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZyb21KU09OID0gZnVuY3Rpb24gKGRhdGEsIGNsZWFyQ3VycmVudEFuaW1hdGlvbnMpXHJcbntcclxuICAgIGlmIChjbGVhckN1cnJlbnRBbmltYXRpb25zID09PSB1bmRlZmluZWQpIHsgY2xlYXJDdXJyZW50QW5pbWF0aW9ucyA9IGZhbHNlOyB9XHJcblxyXG4gICAgaWYgKGNsZWFyQ3VycmVudEFuaW1hdGlvbnMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hbmltcy5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBEbyB3ZSBoYXZlIGEgU3RyaW5nIChpLmUuIGZyb20gSlNPTiwgb3IgYW4gT2JqZWN0PylcclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXHJcbiAgICB7XHJcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG91dHB1dCA9IFtdO1xyXG5cclxuICAgIC8vICBBcnJheSBvZiBhbmltYXRpb25zLCBvciBhIHNpbmdsZSBhbmltYXRpb24/XHJcbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnYW5pbXMnKSAmJiBBcnJheS5pc0FycmF5KGRhdGEuYW5pbXMpKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5hbmltcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHRoaXMuY3JlYXRlKGRhdGEuYW5pbXNbaV0pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdnbG9iYWxUaW1lU2NhbGUnKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsVGltZVNjYWxlID0gZGF0YS5nbG9iYWxUaW1lU2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgna2V5JykgJiYgZGF0YS50eXBlID09PSAnZnJhbWUnKVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5wdXNoKHRoaXMuY3JlYXRlKGRhdGEpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGcm9tSlNPTjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9pbmMvRnJvbUpTT04uanNcbi8vIG1vZHVsZSBpZCA9IDM0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxudmFyIFBhZCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL3N0cmluZy9QYWQnKTtcclxuXHJcbnZhciBHZW5lcmF0ZUZyYW1lTmFtZXMgPSBmdW5jdGlvbiAoa2V5LCBjb25maWcpXHJcbntcclxuICAgIHZhciBwcmVmaXggPSBHZXRWYWx1ZShjb25maWcsICdwcmVmaXgnLCAnJyk7XHJcbiAgICB2YXIgc3RhcnQgPSBHZXRWYWx1ZShjb25maWcsICdzdGFydCcsIDApO1xyXG4gICAgdmFyIGVuZCA9IEdldFZhbHVlKGNvbmZpZywgJ2VuZCcsIDApO1xyXG4gICAgdmFyIHN1ZmZpeCA9IEdldFZhbHVlKGNvbmZpZywgJ3N1ZmZpeCcsICcnKTtcclxuICAgIHZhciB6ZXJvUGFkID0gR2V0VmFsdWUoY29uZmlnLCAnemVyb1BhZCcsIDApO1xyXG4gICAgdmFyIG91dCA9IEdldFZhbHVlKGNvbmZpZywgJ291dHB1dEFycmF5JywgW10pO1xyXG4gICAgdmFyIGZyYW1lcyA9IEdldFZhbHVlKGNvbmZpZywgJ2ZyYW1lcycsIGZhbHNlKTtcclxuXHJcbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMudGV4dHVyZU1hbmFnZXIuZ2V0KGtleSk7XHJcblxyXG4gICAgaWYgKCF0ZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRpZmYgPSAoc3RhcnQgPCBlbmQpID8gMSA6IC0xO1xyXG5cclxuICAgIC8vICBBZGp1c3QgYmVjYXVzZSB3ZSB1c2UgaSAhPT0gZW5kIGluIHRoZSBmb3IgbG9vcFxyXG4gICAgZW5kICs9IGRpZmY7XHJcblxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgZnJhbWU7XHJcblxyXG4gICAgLy8gIEhhdmUgdGhleSBwcm92aWRlZCB0aGVpciBvd24gY3VzdG9tIGZyYW1lIHNlcXVlbmNlIGFycmF5P1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZnJhbWVzKSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZnJhbWUgPSBwcmVmaXggKyBQYWQoZnJhbWVzW2ldLCB6ZXJvUGFkLCAnMCcsIDEpICsgc3VmZml4O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRleHR1cmUuaGFzKGZyYW1lKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6IGtleSwgZnJhbWU6IGZyYW1lIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpICE9PSBlbmQ7IGkgKz0gZGlmZilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZyYW1lID0gcHJlZml4ICsgUGFkKGksIHplcm9QYWQsICcwJywgMSkgKyBzdWZmaXg7XHJcblxyXG4gICAgICAgICAgICBpZiAodGV4dHVyZS5oYXMoZnJhbWUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleToga2V5LCBmcmFtZTogZnJhbWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2VuZXJhdGVGcmFtZU5hbWVzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2luYy9HZW5lcmF0ZUZyYW1lTmFtZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxuXHJcbnZhciBHZW5lcmF0ZUZyYW1lTnVtYmVycyA9IGZ1bmN0aW9uIChrZXksIGNvbmZpZylcclxue1xyXG4gICAgdmFyIHN0YXJ0RnJhbWUgPSBHZXRWYWx1ZShjb25maWcsICdzdGFydCcsIDApO1xyXG4gICAgdmFyIGVuZEZyYW1lID0gR2V0VmFsdWUoY29uZmlnLCAnZW5kJywgLTEpO1xyXG4gICAgdmFyIGZpcnN0RnJhbWUgPSBHZXRWYWx1ZShjb25maWcsICdmaXJzdCcsIGZhbHNlKTtcclxuICAgIHZhciBvdXQgPSBHZXRWYWx1ZShjb25maWcsICdvdXRwdXRBcnJheScsIFtdKTtcclxuICAgIHZhciBmcmFtZXMgPSBHZXRWYWx1ZShjb25maWcsICdmcmFtZXMnLCBmYWxzZSk7XHJcblxyXG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmdldChrZXkpO1xyXG5cclxuICAgIGlmICghdGV4dHVyZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChmaXJzdEZyYW1lICYmIHRleHR1cmUuaGFzKGZpcnN0RnJhbWUpKVxyXG4gICAge1xyXG4gICAgICAgIG91dC5wdXNoKHsga2V5OiBrZXksIGZyYW1lOiBmaXJzdEZyYW1lIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpO1xyXG5cclxuICAgIC8vICBIYXZlIHRoZXkgcHJvdmlkZWQgdGhlaXIgb3duIGN1c3RvbSBmcmFtZSBzZXF1ZW5jZSBhcnJheT9cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGZyYW1lcykpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLmhhcyhmcmFtZXNbaV0pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleToga2V5LCBmcmFtZTogZnJhbWVzW2ldIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vICBObyBlbmRGcmFtZSB0aGVuIHNlZSBpZiB3ZSBjYW4gZ2V0IGl0XHJcblxyXG4gICAgICAgIGlmIChlbmRGcmFtZSA9PT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBlbmRGcmFtZSA9IHRleHR1cmUuZnJhbWVUb3RhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IHN0YXJ0RnJhbWU7IGkgPD0gZW5kRnJhbWU7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLmhhcyhpKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6IGtleSwgZnJhbWU6IGkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2VuZXJhdGVGcmFtZU51bWJlcnM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvaW5jL0dlbmVyYXRlRnJhbWVOdW1iZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChrZXkpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmFuaW1zLmdldChrZXkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvaW5jL0dldEFuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBMb2FkIGFuIEFuaW1hdGlvbiBpbnRvIGEgR2FtZSBPYmplY3RzIEFuaW1hdGlvbiBDb21wb25lbnRcclxudmFyIExvYWRBbmltYXRpb25Ub0dhbWVPYmplY3QgPSBmdW5jdGlvbiAoY2hpbGQsIGtleSwgc3RhcnRGcmFtZSlcclxue1xyXG4gICAgdmFyIGFuaW0gPSB0aGlzLmdldChrZXkpO1xyXG5cclxuICAgIGlmIChhbmltKVxyXG4gICAge1xyXG4gICAgICAgIGFuaW0ubG9hZChjaGlsZCwgc3RhcnRGcmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNoaWxkO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMb2FkQW5pbWF0aW9uVG9HYW1lT2JqZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2luYy9Mb2FkQW5pbWF0aW9uVG9HYW1lT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnRzLycpO1xyXG5cclxudmFyIFBhdXNlQWxsID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKCF0aGlzLnBhdXNlZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5QQVVTRV9BTExfQU5JTUFUSU9OX0VWRU5UKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXVzZUFsbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9pbmMvUGF1c2VBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDM1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChrZXksIGNoaWxkKVxyXG57XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGQpKVxyXG4gICAge1xyXG4gICAgICAgIGNoaWxkID0gWyBjaGlsZCBdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhbmltID0gdGhpcy5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAoIWFuaW0pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGQubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgY2hpbGRbaV0uYW5pbXMucGxheShrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQbGF5QW5pbWF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2luYy9QbGF5QW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnRzLycpO1xyXG5cclxudmFyIFJlbW92ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChrZXkpXHJcbntcclxuICAgIHZhciBhbmltID0gdGhpcy5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAoYW5pbSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuUkVNT1ZFX0FOSU1BVElPTl9FVkVOVChrZXksIGFuaW0pKTtcclxuXHJcbiAgICAgICAgdGhpcy5hbmltcy5kZWxldGUoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYW5pbTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlQW5pbWF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2luYy9SZW1vdmVBbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi9ldmVudHMvJyk7XHJcblxyXG52YXIgUmVzdW1lQWxsID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKHRoaXMucGF1c2VkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5SRVNVTUVfQUxMX0FOSU1BVElPTl9FVkVOVCgpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzdW1lQWxsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2luYy9SZXN1bWVBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDM1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3RhZ2dlclBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoa2V5LCBjaGlsZCwgc3RhZ2dlcilcclxue1xyXG4gICAgaWYgKHN0YWdnZXIgPT09IHVuZGVmaW5lZCkgeyBzdGFnZ2VyID0gMDsgfVxyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShjaGlsZCkpXHJcbiAgICB7XHJcbiAgICAgICAgY2hpbGQgPSBbIGNoaWxkIF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFuaW0gPSB0aGlzLmdldChrZXkpO1xyXG5cclxuICAgIGlmICghYW5pbSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZC5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBjaGlsZFtpXS5hbmltcy5kZWxheWVkUGxheShzdGFnZ2VyICogaSwga2V5KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RhZ2dlclBsYXlBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvaW5jL1N0YWdnZXJQbGF5QW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpXHJcbntcclxuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCAmJiBrZXkgIT09ICcnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1zLmdldChrZXkpLnRvSlNPTigpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIGFuaW1zOiBbXSxcclxuICAgICAgICAgICAgZ2xvYmFsVGltZVNjYWxlOiB0aGlzLmdsb2JhbFRpbWVTY2FsZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbXMuZWFjaChmdW5jdGlvbiAoYW5pbWF0aW9uS2V5LCBhbmltYXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXRwdXQuYW5pbXMucHVzaChhbmltYXRpb24udG9KU09OKCkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb0pTT047XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvaW5jL1RvSlNPTi5qc1xuLy8gbW9kdWxlIGlkID0gMzU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgTUFUSCA9IHJlcXVpcmUoJy4uL21hdGgvY29uc3QnKTtcclxudmFyIE5PT1AgPSByZXF1aXJlKCcuLi91dGlscy9OT09QJyk7XHJcbnZhciBWYWx1ZVRvQ29sb3IgPSByZXF1aXJlKCcuLi9ncmFwaGljcy9jb2xvci9WYWx1ZVRvQ29sb3InKTtcclxuXHJcbnZhciBDb25maWcgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQ29uZmlnIChjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7IGNvbmZpZyA9IHt9OyB9XHJcblxyXG4gICAgICAgIHZhciBkZWZhdWx0QmFubmVyQ29sb3IgPSBbXHJcbiAgICAgICAgICAgICcjZmYwMDAwJyxcclxuICAgICAgICAgICAgJyNmZmZmMDAnLFxyXG4gICAgICAgICAgICAnIzAwZmYwMCcsXHJcbiAgICAgICAgICAgICcjMDBmZmZmJyxcclxuICAgICAgICAgICAgJyMwMDAwMDAnXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdmFyIGRlZmF1bHRCYW5uZXJUZXh0Q29sb3IgPSAnI2ZmZmZmZic7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSBHZXRWYWx1ZShjb25maWcsICd3aWR0aCcsIDEwMjQpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gR2V0VmFsdWUoY29uZmlnLCAnaGVpZ2h0JywgNzY4KTtcclxuICAgICAgICB0aGlzLnpvb20gPSBHZXRWYWx1ZShjb25maWcsICd6b29tJywgMSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IEdldFZhbHVlKGNvbmZpZywgJ3Jlc29sdXRpb24nLCAxKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJUeXBlID0gR2V0VmFsdWUoY29uZmlnLCAndHlwZScsIENPTlNULkFVVE8pO1xyXG5cclxuICAgICAgICB0aGlzLnBhcmVudCA9IEdldFZhbHVlKGNvbmZpZywgJ3BhcmVudCcsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzID0gR2V0VmFsdWUoY29uZmlnLCAnY2FudmFzJywgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXNTdHlsZSA9IEdldFZhbHVlKGNvbmZpZywgJ2NhbnZhc1N0eWxlJywgbnVsbCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2NlbmVDb25maWcgPSBHZXRWYWx1ZShjb25maWcsICdzY2VuZScsIG51bGwpO1xyXG5cclxuICAgICAgICB0aGlzLnNlZWQgPSBHZXRWYWx1ZShjb25maWcsICdzZWVkJywgWyAoRGF0ZS5ub3coKSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCkgXSk7XHJcblxyXG4gICAgICAgIE1BVEguUk5ELmluaXQodGhpcy5zZWVkKTtcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lVGl0bGUgPSBHZXRWYWx1ZShjb25maWcsICd0aXRsZScsICcnKTtcclxuICAgICAgICB0aGlzLmdhbWVVUkwgPSBHZXRWYWx1ZShjb25maWcsICd1cmwnLCAnaHR0cDovL3BoYXNlci5pbycpO1xyXG4gICAgICAgIHRoaXMuZ2FtZVZlcnNpb24gPSBHZXRWYWx1ZShjb25maWcsICd2ZXJzaW9uJywgJycpO1xyXG5cclxuICAgICAgICAvLyAgSW5wdXRcclxuICAgICAgICB0aGlzLmlucHV0S2V5Ym9hcmQgPSBHZXRWYWx1ZShjb25maWcsICdpbnB1dC5rZXlib2FyZCcsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRLZXlib2FyZEV2ZW50VGFyZ2V0ID0gR2V0VmFsdWUoY29uZmlnLCAnaW5wdXQua2V5Ym9hcmQudGFyZ2V0Jywgd2luZG93KTtcclxuXHJcbiAgICAgICAgdGhpcy5pbnB1dE1vdXNlID0gR2V0VmFsdWUoY29uZmlnLCAnaW5wdXQubW91c2UnLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmlucHV0TW91c2VFdmVudFRhcmdldCA9IEdldFZhbHVlKGNvbmZpZywgJ2lucHV0Lm1vdXNlLnRhcmdldCcsIG51bGwpO1xyXG5cclxuICAgICAgICB0aGlzLmlucHV0VG91Y2ggPSBHZXRWYWx1ZShjb25maWcsICdpbnB1dC50b3VjaCcsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRUb3VjaEV2ZW50VGFyZ2V0ID0gR2V0VmFsdWUoY29uZmlnLCAnaW5wdXQudG91Y2gudGFyZ2V0JywgbnVsbCk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5wdXRHYW1lcGFkID0gR2V0VmFsdWUoY29uZmlnLCAnaW5wdXQuZ2FtZXBhZCcsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNhYmxlQ29udGV4dE1lbnUgPSBHZXRWYWx1ZShjb25maWcsICdkaXNhYmxlQ29udGV4dE1lbnUnLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vICBJZiB5b3UgZG86IHsgYmFubmVyOiBmYWxzZSB9IGl0IHdvbid0IGRpc3BsYXkgYW55IGJhbm5lciBhdCBhbGxcclxuICAgICAgICB0aGlzLmhpZGVCYW5uZXIgPSAoR2V0VmFsdWUoY29uZmlnLCAnYmFubmVyJywgbnVsbCkgPT09IGZhbHNlKTtcclxuXHJcbiAgICAgICAgdGhpcy5oaWRlUGhhc2VyID0gR2V0VmFsdWUoY29uZmlnLCAnYmFubmVyLmhpZGVQaGFzZXInLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5iYW5uZXJUZXh0Q29sb3IgPSBHZXRWYWx1ZShjb25maWcsICdiYW5uZXIudGV4dCcsIGRlZmF1bHRCYW5uZXJUZXh0Q29sb3IpO1xyXG4gICAgICAgIHRoaXMuYmFubmVyQmFja2dyb3VuZENvbG9yID0gR2V0VmFsdWUoY29uZmlnLCAnYmFubmVyLmJhY2tncm91bmQnLCBkZWZhdWx0QmFubmVyQ29sb3IpO1xyXG4gICAgICAgXHJcbiAgICAgICAgLy8gIEZyYW1lIFJhdGUgY29uZmlnXHJcbiAgICAgICAgLy8gICAgICBmcHM6IHtcclxuICAgICAgICAvLyAgICAgICAgICBtaW46IDEwLFxyXG4gICAgICAgIC8vICAgICAgICAgIHRhcmdldDogNjAsXHJcbiAgICAgICAgLy8gICAgICAgICAgZm9yY2VTZXRUaW1lT3V0OiBmYWxzZSxcclxuICAgICAgICAvLyAgICAgICAgICBkZWx0YUhpc3Rvcnk6IDEwXHJcbiAgICAgICAgLy8gICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5mcHMgPSBHZXRWYWx1ZShjb25maWcsICdmcHMnLCBudWxsKTtcclxuXHJcbiAgICAgICAgdGhpcy5waXhlbEFydCA9IEdldFZhbHVlKGNvbmZpZywgJ3BpeGVsQXJ0JywgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSBHZXRWYWx1ZShjb25maWcsICd0cmFuc3BhcmVudCcsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gR2V0VmFsdWUoY29uZmlnLCAnY2xlYXJCZWZvcmVSZW5kZXInLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IFZhbHVlVG9Db2xvcihHZXRWYWx1ZShjb25maWcsICdiYWNrZ3JvdW5kQ29sb3InLCAwKSk7XHJcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBWYWx1ZVRvQ29sb3IoR2V0VmFsdWUoY29uZmlnLCAncHJlc2VydmVEcmF3aW5nQnVmZmVyJywgZmFsc2UpKTtcclxuXHJcbiAgICAgICAgLy8gIENhbGxiYWNrc1xyXG4gICAgICAgIHRoaXMucHJlQm9vdCA9IEdldFZhbHVlKGNvbmZpZywgJ2NhbGxiYWNrcy5wcmVCb290JywgTk9PUCk7XHJcbiAgICAgICAgdGhpcy5wb3N0Qm9vdCA9IEdldFZhbHVlKGNvbmZpZywgJ2NhbGxiYWNrcy5wb3N0Qm9vdCcsIE5PT1ApO1xyXG5cclxuICAgICAgICB0aGlzLnVzZVRpY2tlciA9IEdldFZhbHVlKGNvbmZpZywgJ3VzZVRpY2tlcicsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gIFBoeXNpY3NcclxuICAgICAgICAvLyAgcGh5c2ljczoge1xyXG4gICAgICAgIC8vICAgICAgc3lzdGVtOiAnaW1wYWN0JyxcclxuICAgICAgICAvLyAgICAgIHNldEJvdW5kczogdHJ1ZSxcclxuICAgICAgICAvLyAgICAgIGdyYXZpdHk6IDAsXHJcbiAgICAgICAgLy8gICAgICBjZWxsU2l6ZTogNjRcclxuICAgICAgICAvLyAgfVxyXG4gICAgICAgIHRoaXMucGh5c2ljcyA9IEdldFZhbHVlKGNvbmZpZywgJ3BoeXNpY3MnLCB7fSk7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0UGh5c2ljc1N5c3RlbSA9IEdldFZhbHVlKHRoaXMucGh5c2ljcywgJ2RlZmF1bHQnLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vICBEZWZhdWx0IC8gTWlzc2luZyBJbWFnZXNcclxuICAgICAgICB2YXIgcG5nUHJlZml4ID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZyc7XHJcblxyXG4gICAgICAgIHRoaXMuZGVmYXVsdEltYWdlID0gR2V0VmFsdWUoY29uZmlnLCAnaW1hZ2VzLmRlZmF1bHQnLCBwbmdQcmVmaXggKyAnQVFNQUFBQkp0T2kzQUFBQUExQk1WRVgvLy8rbnhCdklBQUFBQVhSU1RsTUFRT2JZWmdBQUFCVkpSRUZVZUY3TndJRUFBQUFBZ0tEOXFkZW9jQU1Bb0FBQm0zRGtjQUFBQUFCSlJVNUVya0pnZ2c9PScpO1xyXG4gICAgICAgIHRoaXMubWlzc2luZ0ltYWdlID0gR2V0VmFsdWUoY29uZmlnLCAnaW1hZ2VzLm1pc3NpbmcnLCBwbmdQcmVmaXggKyAnQ0FJQUFBRDhHTzJqQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFKOUpSRUZVZU5xMDFzc093eUFNUkZHNDZ2Ly9NdDFFU21naCtERm1FMkdQT0JBUktiMk5Wam8rMTdQWExEOGExK3BsNStBK3dTZ0Z5Z3ltV1lIQmIwRnRzS2hKRGRabG5jRzJJeko0YXlvTUR2MjB3VG1TTXpDbEVnYldZTlRBa1EwWitPSitBL2VXbkFhUjkrb3hDRjRPczBIOGh0c01VcCtwd2NnQkJpTU5uQXdGOEdxSWdMMmhBemFHRkZnWmF1RFBLQUJtb3daNEdMMzY5LzByd0FDcDJ5QS90dG12c1FBQUFBQkpSVTVFcmtKZ2dnPT0nKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb25maWc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYm9vdC9Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDM1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XHJcbnZhciBGZWF0dXJlcyA9IHJlcXVpcmUoJy4uL2RldmljZS9GZWF0dXJlcycpO1xyXG52YXIgQ2FudmFzSW50ZXJwb2xhdGlvbiA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNJbnRlcnBvbGF0aW9uJyk7XHJcblxyXG52YXIgQ3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbiAoZ2FtZSlcclxue1xyXG4gICAgdmFyIGNvbmZpZyA9IGdhbWUuY29uZmlnO1xyXG5cclxuICAgIC8vICBHYW1lIGVpdGhlciByZXF1ZXN0ZWQgQ2FudmFzLFxyXG4gICAgLy8gIG9yIHJlcXVlc3RlZCBBVVRPIG9yIFdFQkdMIGJ1dCB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgaXQsIHNvIGZhbGwgYmFjayB0byBDYW52YXNcclxuICAgIGlmIChjb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuQ0FOVkFTIHx8IChjb25maWcucmVuZGVyVHlwZSAhPT0gQ09OU1QuQ0FOVkFTICYmICFGZWF0dXJlcy53ZWJHTCkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEZlYXR1cmVzLmNhbnZhcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGV5IHJlcXVlc3RlZCBDYW52YXMgYW5kIHRoZWlyIGJyb3dzZXIgc3VwcG9ydHMgaXRcclxuICAgICAgICAgICAgY29uZmlnLnJlbmRlclR5cGUgPSBDT05TVC5DQU5WQVM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBDYW52YXMgb3IgV2ViR0wgY29udGV4dCwgYWJvcnRpbmcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vICBHYW1lIHJlcXVlc3RlZCBXZWJHTCBhbmQgYnJvd3NlciBzYXlzIGl0IHN1cHBvcnRzIGl0XHJcbiAgICAgICAgY29uZmlnLnJlbmRlclR5cGUgPSBDT05TVC5XRUJHTDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgUGl4ZWwgQXJ0IG1vZGU/XHJcbiAgICBpZiAoY29uZmlnLnBpeGVsQXJ0KVxyXG4gICAge1xyXG4gICAgICAgIENhbnZhc1Bvb2wuZGlzYWJsZVNtb290aGluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBEb2VzIHRoZSBnYW1lIGNvbmZpZyBwcm92aWRlIGl0cyBvd24gY2FudmFzIGVsZW1lbnQgdG8gdXNlP1xyXG4gICAgaWYgKGNvbmZpZy5jYW52YXMpXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZS5jYW52YXMgPSBjb25maWcuY2FudmFzO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGdhbWUuY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGUoZ2FtZSwgY29uZmlnLndpZHRoLCBjb25maWcuaGVpZ2h0LCBjb25maWcucmVuZGVyVHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIERvZXMgdGhlIGdhbWUgY29uZmlnIHByb3ZpZGUgc29tZSBjYW52YXMgY3NzIHN0eWxlcyB0byB1c2U/XHJcbiAgICBpZiAoY29uZmlnLmNhbnZhc1N0eWxlKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWUuY2FudmFzLnN0eWxlID0gY29uZmlnLmNhbnZhc1N0eWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBQaXhlbCBBcnQgbW9kZT9cclxuICAgIGlmIChjb25maWcucGl4ZWxBcnQpXHJcbiAgICB7XHJcbiAgICAgICAgQ2FudmFzSW50ZXJwb2xhdGlvbi5zZXRDcmlzcChnYW1lLmNhbnZhcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFpvb21lZD9cclxuICAgIGlmIChjb25maWcuem9vbSAhPT0gMSlcclxuICAgIHtcclxuICAgICAgICBnYW1lLmNhbnZhcy5zdHlsZS53aWR0aCA9IChjb25maWcud2lkdGggKiBjb25maWcuem9vbSkudG9TdHJpbmcoKSArICdweCc7XHJcbiAgICAgICAgZ2FtZS5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gKGNvbmZpZy5oZWlnaHQgKiBjb25maWcuem9vbSkudG9TdHJpbmcoKSArICdweCc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIENhbnZhc1JlbmRlcmVyO1xyXG4gICAgdmFyIFdlYkdMUmVuZGVyZXI7XHJcblxyXG4gICAgaWYgKFdFQkdMX1JFTkRFUkVSICYmIENBTlZBU19SRU5ERVJFUilcclxuICAgIHtcclxuICAgICAgICBDYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL2NhbnZhcy9DYW52YXNSZW5kZXJlcicpO1xyXG4gICAgICAgIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyJyk7XHJcblxyXG4gICAgICAgIC8vICBMZXQgdGhlIGNvbmZpZyBwaWNrIHRoZSByZW5kZXJlciB0eXBlLCBib3RoIGFyZSBpbmNsdWRlZFxyXG4gICAgICAgIGlmIChjb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuV0VCR0wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnYW1lLnJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoZ2FtZSk7XHJcbiAgICAgICAgICAgIGdhbWUuY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWUucmVuZGVyZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIoZ2FtZSk7XHJcbiAgICAgICAgICAgIGdhbWUuY29udGV4dCA9IGdhbWUucmVuZGVyZXIuZ2FtZUNvbnRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChXRUJHTF9SRU5ERVJFUiAmJiAhQ0FOVkFTX1JFTkRFUkVSKVxyXG4gICAge1xyXG4gICAgICAgIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyJyk7XHJcblxyXG4gICAgICAgIC8vICBGb3JjZSB0aGUgdHlwZSB0byBXZWJHTCwgcmVnYXJkbGVzcyB3aGF0IHdhcyByZXF1ZXN0ZWRcclxuICAgICAgICBjb25maWcucmVuZGVyVHlwZSA9IENPTlNULldFQkdMO1xyXG4gICAgICAgIGdhbWUucmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcihnYW1lKTtcclxuICAgICAgICBnYW1lLmNvbnRleHQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghV0VCR0xfUkVOREVSRVIgJiYgQ0FOVkFTX1JFTkRFUkVSKVxyXG4gICAge1xyXG4gICAgICAgIENhbnZhc1JlbmRlcmVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvY2FudmFzL0NhbnZhc1JlbmRlcmVyJyk7XHJcblxyXG4gICAgICAgIC8vICBGb3JjZSB0aGUgdHlwZSB0byBDYW52YXMsIHJlZ2FyZGxlc3Mgd2hhdCB3YXMgcmVxdWVzdGVkXHJcbiAgICAgICAgY29uZmlnLnJlbmRlclR5cGUgPSBDT05TVC5DQU5WQVM7XHJcbiAgICAgICAgZ2FtZS5yZW5kZXJlciA9IG5ldyBDYW52YXNSZW5kZXJlcihnYW1lKTtcclxuICAgICAgICBnYW1lLmNvbnRleHQgPSBnYW1lLnJlbmRlcmVyLmdhbWVDb250ZXh0O1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ib290L0NyZWF0ZVJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIENIRUNLU1VNID0gcmVxdWlyZSgnLi4vY2hlY2tzdW0nKTtcclxuXHJcbnZhciBEZWJ1Z0hlYWRlciA9IGZ1bmN0aW9uIChnYW1lKVxyXG57XHJcbiAgICB2YXIgY29uZmlnID0gZ2FtZS5jb25maWc7XHJcblxyXG4gICAgaWYgKGNvbmZpZy5oaWRlQmFubmVyKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVuZGVyVHlwZSA9IChjb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuQ0FOVkFTKSA/ICdDYW52YXMnIDogJ1dlYkdMJztcclxuXHJcbiAgICB2YXIgaWUgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoIWllKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjID0gJyc7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbIGMgXTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmJhbm5lckJhY2tncm91bmRDb2xvcikpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbGFzdENvbG9yO1xyXG5cclxuICAgICAgICAgICAgY29uZmlnLmJhbm5lckJhY2tncm91bmRDb2xvci5mb3JFYWNoKGZ1bmN0aW9uIChjb2xvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYyA9IGMuY29uY2F0KCclYyAnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2JhY2tncm91bmQ6ICcgKyBjb2xvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgbGFzdENvbG9yID0gY29sb3I7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vICBpbmplY3QgdGhlIHRleHQgY29sb3JcclxuICAgICAgICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdID0gJ2NvbG9yOiAnICsgY29uZmlnLmJhbm5lclRleHRDb2xvciArICc7IGJhY2tncm91bmQ6ICcgKyBsYXN0Q29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnJWMgJyk7XHJcblxyXG4gICAgICAgICAgICBhcmdzLnB1c2goJ2NvbG9yOiAnICsgY29uZmlnLmJhbm5lclRleHRDb2xvciArICc7IGJhY2tncm91bmQ6ICcgKyBjb25maWcuYmFubmVyQmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBVUkwgbGluayBiYWNrZ3JvdW5kIGNvbG9yIChhbHdheXMgd2hpdGUpXHJcbiAgICAgICAgYXJncy5wdXNoKCdiYWNrZ3JvdW5kOiAjZmZmJyk7XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuZ2FtZVRpdGxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYyA9IGMuY29uY2F0KGNvbmZpZy5nYW1lVGl0bGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5nYW1lVmVyc2lvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYyA9IGMuY29uY2F0KCcgdicgKyBjb25maWcuZ2FtZVZlcnNpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5oaWRlUGhhc2VyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjID0gYy5jb25jYXQoJyAvICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZy5oaWRlUGhhc2VyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYyA9IGMuY29uY2F0KCdQaGFzZXIgdicgKyBDT05TVC5WRVJTSU9OICsgJyAoJyArIHJlbmRlclR5cGUgKyAnKScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYyA9IGMuY29uY2F0KCcgJWMgJyArIGNvbmZpZy5nYW1lVVJMKTtcclxuXHJcbiAgICAgICAgLy8gIEluamVjdCB0aGUgbmV3IHN0cmluZyBiYWNrIGludG8gdGhlIGFyZ3MgYXJyYXlcclxuICAgICAgICBhcmdzWzBdID0gYztcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh3aW5kb3dbJ2NvbnNvbGUnXSlcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnUGhhc2VyIHYnICsgQ09OU1QuVkVSU0lPTiArICcgLyBodHRwOi8vcGhhc2VyLmlvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gS2VlcCB0aGlzIGR1cmluZyBkZXYgYnVpbGQgb25seVxyXG4gICAgY29uc29sZS5sb2coQ0hFQ0tTVU0uYnVpbGQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWJ1Z0hlYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ib290L0RlYnVnSGVhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBOT09QID0gcmVxdWlyZSgnLi4vdXRpbHMvTk9PUCcpO1xyXG52YXIgUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi4vZG9tL1JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xyXG5cclxuLy8gIEZyYW1lIFJhdGUgY29uZmlnXHJcbi8vICAgICAgZnBzOiB7XHJcbi8vICAgICAgICAgIG1pbjogMTAsXHJcbi8vICAgICAgICAgIHRhcmdldDogNjAsXHJcbi8vICAgICAgICAgIGZvcmNlU2V0VGltZU91dDogZmFsc2UsXHJcbi8vICAgICAgICAgIGRlbHRhSGlzdG9yeTogMTAsXHJcbi8vICAgICAgICAgIHBhbmljTWF4OiAxMjBcclxuLy8gICAgIH1cclxuXHJcbi8vIGh0dHA6Ly93d3cudGVzdHVmby5jb20vI3Rlc3Q9YW5pbWF0aW9uLXRpbWUtZ3JhcGhcclxuXHJcbnZhciBUaW1lU3RlcCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBUaW1lU3RlcCAoZ2FtZSwgY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcblxyXG4gICAgICAgIHRoaXMucmFmID0gbmV3IFJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm1pbkZwcyA9IEdldFZhbHVlKGNvbmZpZywgJ21pbicsIDUpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0RnBzID0gR2V0VmFsdWUoY29uZmlnLCAndGFyZ2V0JywgNjApO1xyXG5cclxuICAgICAgICB0aGlzLl9taW4gPSAxMDAwIC8gdGhpcy5taW5GcHM7ICAgICAgICAgLy8gIDIwMG1zIGJldHdlZW4gZnJhbWVzIChpLmUuIHN1cGVyIHNsb3chKVxyXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IDEwMDAgLyB0aGlzLnRhcmdldEZwczsgICAvLyAgMTYuNjY2bXMgYmV0d2VlbiBmcmFtZXMgKGkuZS4gbm9ybWFsKVxyXG5cclxuICAgICAgICAvLyAgMjAwIC8gMTAwMCA9IDAuMiAoNWZwcylcclxuICAgICAgICAvLyAgOC4zMzMgLyAxMDAwID0gMC4wMDgzMzMgKDEyMGZwcylcclxuICAgICAgICAvLyAgMTYuNjY2IC8gMTAwMCA9IDAuMDE2NjYgKDYwZnBzKVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcHMgLSBBbiBleHBvbmVudGlhbCBtb3ZpbmcgYXZlcmFnZSBvZiB0aGUgZnJhbWVzIHBlciBzZWNvbmQuXHJcbiAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0dWFsRnBzID0gdGhpcy50YXJnZXRGcHM7XHJcblxyXG4gICAgICAgIHRoaXMubmV4dEZwc1VwZGF0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5mcmFtZXNUaGlzU2Vjb25kID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IE5PT1A7XHJcblxyXG4gICAgICAgIHRoaXMuZm9yY2VTZXRUaW1lT3V0ID0gR2V0VmFsdWUoY29uZmlnLCAnZm9yY2VTZXRUaW1lT3V0JywgZmFsc2UpO1xyXG5cclxuICAgICAgICB0aGlzLnRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RUaW1lID0gMDtcclxuICAgICAgICB0aGlzLmZyYW1lID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5pbkZvY3VzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5fcGF1c2VUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9jb29sRG93biA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuZGVsdGEgPSAwO1xyXG4gICAgICAgIHRoaXMuZGVsdGFJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5kZWx0YUhpc3RvcnkgPSBbXTtcclxuICAgICAgICB0aGlzLmRlbHRhU21vb3RoaW5nTWF4ID0gR2V0VmFsdWUoY29uZmlnLCAnZGVsdGFIaXN0b3J5JywgMTApO1xyXG4gICAgICAgIHRoaXMucGFuaWNNYXggPSBHZXRWYWx1ZShjb25maWcsICdwYW5pY01heCcsIDEyMCk7XHJcblxyXG4gICAgICAgIC8vICBUaGUgYWN0dWFsIGVsYXBzZWQgdGltZSBpbiBtcyBiZXR3ZWVuIG9uZSB1cGRhdGUgYW5kIHRoZSBuZXh0LlxyXG4gICAgICAgIC8vICBObyBzbW9vdGhpbmcsIG5vIGNhcHBpbmcsIG5vIGF2ZXJhZ2luZy4gU28gcGxlYXNlIGJlIGF3YXJlIG9mIHRoaXMgd2hlbiB1c2luZyB0aGUgY29udGVudHMgb2YgdGhpcyBwcm9wZXJ0eS5cclxuICAgICAgICB0aGlzLnJhd0RlbHRhID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGxlZCB3aGVuIHRoZSBET00gd2luZG93Lm9uQmx1ciBldmVudCB0cmlnZ2Vyc1xyXG4gICAgYmx1cjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmluRm9jdXMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1RpbWVTdGVwLmJsdXInKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGxlZCB3aGVuIHRoZSBET00gd2luZG93Lm9uRm9jdXMgZXZlbnQgdHJpZ2dlcnNcclxuICAgIGZvY3VzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaW5Gb2N1cyA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdUaW1lU3RlcC5mb2N1cycpO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2V0RGVsdGEoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IEFQSSBzYXlzIHRoZSBnYW1lIGlzICdoaWRkZW4nICh0YWIgc3dpdGNoLCBldGMpXHJcbiAgICBwYXVzZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnVGltZVN0ZXAucGF1c2UnKTtcclxuXHJcbiAgICAgICAgdGhpcy5fcGF1c2VUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIHdoZW4gdGhlIHZpc2liaWxpdHkgQVBJIHNheXMgdGhlIGdhbWUgaXMgJ3Zpc2libGUnIGFnYWluICh0YWIgc3dpdGNoLCBldGMpXHJcbiAgICByZXN1bWU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZXNldERlbHRhKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lICs9IHRoaXMudGltZSAtIHRoaXMuX3BhdXNlVGltZTtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1RpbWVTdGVwLnJlc3VtZSAtIHBhdXNlZCBmb3InLCAodGhpcy50aW1lIC0gdGhpcy5fcGF1c2VUaW1lKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0RGVsdGE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbiAgICAgICAgdGhpcy50aW1lID0gbm93O1xyXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBub3c7XHJcbiAgICAgICAgdGhpcy5uZXh0RnBzVXBkYXRlID0gbm93ICsgMTAwMDtcclxuICAgICAgICB0aGlzLmZyYW1lc1RoaXNTZWNvbmQgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJhbWUgPSAwO1xyXG5cclxuICAgICAgICAvLyAgUHJlLXBvcHVsYXRlIHNtb290aGluZyBhcnJheVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVsdGFTbW9vdGhpbmdNYXg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFIaXN0b3J5W2ldID0gTWF0aC5taW4odGhpcy5fdGFyZ2V0LCB0aGlzLmRlbHRhSGlzdG9yeVtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRlbHRhID0gMDtcclxuICAgICAgICB0aGlzLmRlbHRhSW5kZXggPSAwO1xyXG5cclxuICAgICAgICB0aGlzLl9jb29sRG93biA9IHRoaXMucGFuaWNNYXg7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVsdGFTbW9vdGhpbmdNYXg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFIaXN0b3J5W2ldID0gdGhpcy5fdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZXNldERlbHRhKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG4gICAgICAgIHRoaXMucmFmLnN0YXJ0KHRoaXMuc3RlcC5iaW5kKHRoaXMpLCB0aGlzLmZvcmNlU2V0VGltZU91dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICB0aW1lIGNvbWVzIGZyb20gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFuZCBpcyBlaXRoZXIgYSBoaWdoIHJlcyB0aW1lIHZhbHVlLFxyXG4gICAgLy8gIG9yIERhdGUubm93IGlmIHVzaW5nIHNldFRpbWVvdXRcclxuICAgIHN0ZXA6IGZ1bmN0aW9uICh0aW1lKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBEZWJ1ZyBvbmx5XHJcbiAgICAgICAgLy8gdmFyIGRlYnVnID0gMDtcclxuICAgICAgICAvLyB2YXIgZHVtcCA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLmZyYW1lKys7XHJcblxyXG4gICAgICAgIHRoaXMucmF3RGVsdGEgPSB0aW1lIC0gdGhpcy5sYXN0VGltZTtcclxuXHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuZGVsdGFJbmRleDtcclxuICAgICAgICB2YXIgaGlzdG9yeSA9IHRoaXMuZGVsdGFIaXN0b3J5O1xyXG4gICAgICAgIHZhciBtYXggPSB0aGlzLmRlbHRhU21vb3RoaW5nTWF4O1xyXG5cclxuICAgICAgICAvLyAgZGVsdGEgdGltZSAodGltZSBpcyBpbiBtcylcclxuICAgICAgICB2YXIgZHQgPSAodGltZSAtIHRoaXMubGFzdFRpbWUpO1xyXG5cclxuICAgICAgICAvLyAgV2hlbiBhIGJyb3dzZXIgc3dpdGNoZXMgdGFiLCB0aGVuIGNvbWVzIGJhY2sgYWdhaW4sIGl0IHRha2VzIGFyb3VuZCAxMCBmcmFtZXMgYmVmb3JlXHJcbiAgICAgICAgLy8gIHRoZSBkZWx0YSB0aW1lIHNldHRsZXMgZG93biBzbyB3ZSBlbXBsb3kgYSAnY29vbGluZyBkb3duJyBwZXJpb2QgYmVmb3JlIHdlIHN0YXJ0XHJcbiAgICAgICAgLy8gIHRydXN0aW5nIHRoZSBkZWx0YSB2YWx1ZXMgYWdhaW4sIHRvIGF2b2lkIHNwaWtlcyBmbG9vZGluZyB0aHJvdWdoIG91ciBkZWx0YSBhdmVyYWdlXHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9jb29sRG93biA+IDAgfHwgIXRoaXMuaW5Gb2N1cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Nvb2xEb3duLS07XHJcblxyXG4gICAgICAgICAgICBkdCA9IE1hdGgubWluKGR0LCB0aGlzLl90YXJnZXQpO1xyXG5cclxuICAgICAgICAgICAgLy8gZGVidWcgPSAodGltZSAtIHRoaXMubGFzdFRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGR0ID4gdGhpcy5fbWluKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFByb2JhYmx5IHN1cGVyIGJhZCBzdGFydCB0aW1lIG9yIGJyb3dzZXIgdGFiIGNvbnRleHQgbG9zcyxcclxuICAgICAgICAgICAgLy8gIHNvIHVzZSB0aGUgbGFzdCAnc2FuZScgZHQgdmFsdWVcclxuXHJcbiAgICAgICAgICAgIC8vIGRlYnVnID0gZHQ7XHJcblxyXG4gICAgICAgICAgICBkdCA9IGhpc3RvcnlbaWR4XTtcclxuXHJcbiAgICAgICAgICAgIC8vICBDbGFtcCBkZWx0YSB0byBtaW4gKGluIGNhc2UgaGlzdG9yeSBoYXMgYmVjb21lIGNvcnJ1cHRlZCBzb21laG93KVxyXG4gICAgICAgICAgICBkdCA9IE1hdGgubWluKGR0LCB0aGlzLl9taW4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFNtb290aCBvdXQgdGhlIGRlbHRhIG92ZXIgdGhlIHByZXZpb3VzIFggZnJhbWVzXHJcblxyXG4gICAgICAgIC8vICBhZGQgdGhlIGRlbHRhIHRvIHRoZSBzbW9vdGhpbmcgYXJyYXlcclxuICAgICAgICBoaXN0b3J5W2lkeF0gPSBkdDtcclxuXHJcbiAgICAgICAgLy8gIGFkanVzdHMgdGhlIGRlbHRhIGhpc3RvcnkgYXJyYXkgaW5kZXggYmFzZWQgb24gdGhlIHNtb290aGluZyBjb3VudFxyXG4gICAgICAgIC8vICB0aGlzIHN0b3BzIHRoZSBhcnJheSBncm93aW5nIGJleW9uZCB0aGUgc2l6ZSBvZiBkZWx0YVNtb290aGluZ01heFxyXG4gICAgICAgIHRoaXMuZGVsdGFJbmRleCsrO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kZWx0YUluZGV4ID4gbWF4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kZWx0YUluZGV4ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBEZWx0YSBBdmVyYWdlXHJcbiAgICAgICAgdmFyIGF2ZyA9IDA7XHJcblxyXG4gICAgICAgIC8vICBMb29wIHRoZSBoaXN0b3J5IGFycmF5LCBhZGRpbmcgdGhlIGRlbHRhIHZhbHVlcyB0b2dldGhlclxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gICBEZWJ1Z1xyXG4gICAgICAgICAgICAvLyBpZiAoaGlzdG9yeVtpXSA8IDE2IHx8IGhpc3RvcnlbaV0gPiAxNylcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgZHVtcC5wdXNoKHsgaTogaSwgZHQ6IGhpc3RvcnlbaV0gfSk7XHJcbiAgICAgICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgICAgIGF2ZyArPSBoaXN0b3J5W2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFRoZW4gZGl2aWRlIGJ5IHRoZSBhcnJheSBsZW5ndGggdG8gZ2V0IHRoZSBhdmVyYWdlIGRlbHRhXHJcbiAgICAgICAgYXZnIC89IG1heDtcclxuXHJcbiAgICAgICAgLy8gIFNldCBhcyB0aGUgd29ybGQgZGVsdGEgdmFsdWVcclxuICAgICAgICB0aGlzLmRlbHRhID0gYXZnO1xyXG5cclxuICAgICAgICAvLyAgUmVhbC13b3JsZCB0aW1lciBhZHZhbmNlXHJcbiAgICAgICAgLy8gdGhpcy50aW1lICs9IGF2ZztcclxuICAgICAgICB0aGlzLnRpbWUgKz0gdGhpcy5yYXdEZWx0YTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBlc3RpbWF0ZSBvZiB0aGUgZnJhbWUgcmF0ZSwgYGZwc2AuIEV2ZXJ5IHNlY29uZCwgdGhlIG51bWJlclxyXG4gICAgICAgIC8vIG9mIGZyYW1lcyB0aGF0IG9jY3VycmVkIGluIHRoYXQgc2Vjb25kIGFyZSBpbmNsdWRlZCBpbiBhbiBleHBvbmVudGlhbFxyXG4gICAgICAgIC8vIG1vdmluZyBhdmVyYWdlIG9mIGFsbCBmcmFtZXMgcGVyIHNlY29uZCwgd2l0aCBhbiBhbHBoYSBvZiAwLjI1LiBUaGlzXHJcbiAgICAgICAgLy8gbWVhbnMgdGhhdCBtb3JlIHJlY2VudCBzZWNvbmRzIGFmZmVjdCB0aGUgZXN0aW1hdGVkIGZyYW1lIHJhdGUgbW9yZSB0aGFuXHJcbiAgICAgICAgLy8gb2xkZXIgc2Vjb25kcy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdoZW4gYSBicm93c2VyIHdpbmRvdyBpcyBOT1QgbWluaW1pemVkLCBidXQgaXMgY292ZXJlZCB1cCAoaS5lLiB5b3UncmUgdXNpbmdcclxuICAgICAgICAvLyBhbm90aGVyIGFwcCB3aGljaCBoYXMgc3Bhd25lZCBhIHdpbmRvdyBvdmVyIHRoZSB0b3Agb2YgdGhlIGJyb3dzZXIpLCB0aGVuIGl0XHJcbiAgICAgICAgLy8gd2lsbCBzdGFydCB0byB0aHJvdHRsZSB0aGUgcmFmIGNhbGxiYWNrIHRpbWUuIEl0IHdhaXRzIGZvciBhIHdoaWxlLCBhbmQgdGhlblxyXG4gICAgICAgIC8vIHN0YXJ0cyB0byBkcm9wIHRoZSBmcmFtZSByYXRlIGF0IDEgZnJhbWUgcGVyIHNlY29uZCB1bnRpbCBpdCdzIGRvd24gdG8ganVzdCBvdmVyIDFmcHMuXHJcbiAgICAgICAgLy8gU28gaWYgdGhlIGdhbWUgd2FzIHJ1bm5pbmcgYXQgNjBmcHMsIGFuZCB0aGUgcGxheWVyIG9wZW5zIGEgbmV3IHdpbmRvdywgdGhlblxyXG4gICAgICAgIC8vIGFmdGVyIDYwIHNlY29uZHMgKCsgdGhlICdidWZmZXIgdGltZScpIGl0J2xsIGJlIGRvd24gdG8gMWZwcywgc28gcmFmaW4nZyBhdCAxSHouXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXaGVuIHRoZXkgbWFrZSB0aGUgZ2FtZSB2aXNpYmxlIGFnYWluLCB0aGUgZnJhbWUgcmF0ZSBpcyBpbmNyZWFzZWQgYXQgYSByYXRlIG9mXHJcbiAgICAgICAgLy8gYXBwcm94LiA4ZnBzLCBiYWNrIHVwIHRvIDYwZnBzIChvciB0aGUgbWF4IGl0IGNhbiBvYnRhaW4pXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUaGVyZSBpcyBubyBlYXN5IHdheSB0byBkZXRlcm1pbmUgaWYgdGhpcyBkcm9wIGluIGZyYW1lIHJhdGUgaXMgYmVjYXVzZSB0aGVcclxuICAgICAgICAvLyBicm93c2VyIGlzIHRocm90dGxpbmcgcmFmLCBvciBiZWNhdXNlIHRoZSBnYW1lIGlzIHN0cnVnZ2xpbmcgd2l0aCBwZXJmb3JtYW5jZVxyXG4gICAgICAgIC8vIGJlY2F1c2UgeW91J3JlIGFza2luZyBpdCB0byBkbyB0b28gbXVjaCBvbiB0aGUgZGV2aWNlLlxyXG5cclxuICAgICAgICBpZiAodGltZSA+IHRoaXMubmV4dEZwc1VwZGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBDb21wdXRlIHRoZSBuZXcgZXhwb25lbnRpYWwgbW92aW5nIGF2ZXJhZ2Ugd2l0aCBhbiBhbHBoYSBvZiAwLjI1LlxyXG4gICAgICAgICAgICB0aGlzLmFjdHVhbEZwcyA9IDAuMjUgKiB0aGlzLmZyYW1lc1RoaXNTZWNvbmQgKyAwLjc1ICogdGhpcy5hY3R1YWxGcHM7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dEZwc1VwZGF0ZSA9IHRpbWUgKyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lc1RoaXNTZWNvbmQgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgKHRoaXMuYWN0dWFsRnBzIDwgNTYpXHJcbiAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKHRoaXMuYWN0dWFsRnBzKTtcclxuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdGJywgdGhpcy5mcmFtZSwgJ0F2ZycsIGF2ZywgJ0R0JywgZGVidWcsICdQYW5pYycsIHRoaXMuX2Nvb2xEb3duKTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5mcmFtZXNUaGlzU2Vjb25kKys7XHJcblxyXG4gICAgICAgIC8vICBJbnRlcnBvbGF0aW9uIC0gaG93IGZhciBiZXR3ZWVuIHdoYXQgaXMgZXhwZWN0ZWQgYW5kIHdoZXJlIHdlIGFyZT9cclxuICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbiA9IGF2ZyAvIHRoaXMuX3RhcmdldDtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aW1lLCBhdmcsIGludGVycG9sYXRpb24pO1xyXG5cclxuICAgICAgICAvLyAgU2hpZnQgdGltZSB2YWx1ZSBvdmVyXHJcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IHRpbWU7XHJcblxyXG4gICAgICAgIC8vIGlmIChkZWJ1ZyAhPT0gMClcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdGJywgdGhpcy5mcmFtZSwgJ0F2ZycsIGF2ZywgJ0R0JywgZGVidWcsICdQYW5pYycsIHRoaXMuX2Nvb2xEb3duKTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgaWYgKGRlYnVnICE9PSAwIHx8IGR1bXAubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS5ncm91cCgnRnJhbWUgJyArIHRoaXMuZnJhbWUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSW50ZXJwb2xhdGlvbicsIGludGVycG9sYXRpb24sICclJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVidWcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFbGFwc2VkJywgZGVidWcsICdtcycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRnJhbWUnLCB0aGlzLmZyYW1lLCAnRGVsdGEnLCBhdmcsICcoYXZlcmFnZSknLCBkZWJ1ZywgJyhub3cpJyk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRGVsdGEnLCBhdmcsICcoYXZlcmFnZSknKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkdW1wLmxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS50YWJsZShkdW1wKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAqL1xyXG4gICAgfSxcclxuXHJcbiAgICB0aWNrOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RlcCh3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzbGVlcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yYWYuc3RvcCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB3YWtlOiBmdW5jdGlvbiAoc2VhbWxlc3MpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMucnVubmluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2xlZXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VhbWxlc3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSArPSAtdGhpcy5sYXN0VGltZSArICh0aGlzLmxhc3RUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmFmLnN0YXJ0KHRoaXMuc3RlcC5iaW5kKHRoaXMpLCB0aGlzLnVzZVJBRik7XHJcblxyXG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuc3RlcCh3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcHM6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZwcyA9IHZhbHVlO1xyXG5cclxuICAgICAgICB0aGlzLndha2UoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RnBzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZwcztcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5yYWYuc3RvcCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGltZVN0ZXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYm9vdC9UaW1lU3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMzU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIFZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50RGlzcGF0Y2hlcilcclxue1xyXG4gICAgdmFyIGhpZGRlblZhcjtcclxuXHJcbiAgICBpZiAoZG9jdW1lbnQuaGlkZGVuICE9PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgaGlkZGVuVmFyID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHZhciB2ZW5kb3JzID0gWyAnd2Via2l0JywgJ21veicsICdtcycgXTtcclxuXHJcbiAgICAgICAgdmVuZG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnRbcHJlZml4ICsgJ0hpZGRlbiddICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmhpZGRlbiA9IGZ1bmN0aW9uICgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50W3ByZWZpeCArICdIaWRkZW4nXTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaGlkZGVuVmFyID0gcHJlZml4ICsgJ3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvbkNoYW5nZSA9IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuIHx8IGV2ZW50LnR5cGUgPT09ICdwYXVzZScpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBldmVudERpc3BhdGNoZXIuZGlzcGF0Y2gobmV3IEV2ZW50KCdISURERU4nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaChuZXcgRXZlbnQoJ1ZJU0lCTEUnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyAgRG9lcyBicm93c2VyIHN1cHBvcnQgaXQ/XHJcbiAgICAvLyAgSWYgbm90IChsaWtlIGluIElFOSBvciBvbGQgQW5kcm9pZCkgd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gYmx1ciAvIGZvY3VzXHJcbiAgICBpZiAoaGlkZGVuVmFyKVxyXG4gICAge1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoaGlkZGVuVmFyLCBvbkNoYW5nZSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdGYWxsYmFjayBUT0RPJyk7XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93Lm9uYmx1ciA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoKG5ldyBFdmVudCgnT05fQkxVUicpKTtcclxuICAgIH07XHJcblxyXG4gICAgd2luZG93Lm9uZm9jdXMgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaChuZXcgRXZlbnQoJ09OX0ZPQ1VTJykpO1xyXG4gICAgfTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZpc2liaWxpdHlIYW5kbGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Jvb3QvVmlzaWJpbGl0eUhhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcclxuXHJcbi8vICBQaGFzZXIuQ2FjaGUuQmFzZUNhY2hlXHJcblxyXG52YXIgQmFzZUNhY2hlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEJhc2VDYWNoZSAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZW50cmllcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGtleSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmVudHJpZXMuc2V0KGtleSwgZGF0YSk7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudHMuQ0FDSEVfQUREX0VWRU5UKHRoaXMsIGtleSwgZGF0YSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXM6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5oYXMoa2V5KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMuZ2V0KGtleSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmdldChrZXkpO1xyXG5cclxuICAgICAgICBpZiAoZW50cnkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmVudHJpZXMuZGVsZXRlKGtleSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnRzLkNBQ0hFX1JFTU9WRV9FVkVOVCh0aGlzLCBrZXksIGVudHJ5LmRhdGEpKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFzZUNhY2hlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhY2hlL0Jhc2VDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMzYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCYXNlQ2FjaGUgPSByZXF1aXJlKCcuL0Jhc2VDYWNoZScpO1xyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG5cclxuLy8gIFBoYXNlci5DYWNoZS5HbG9iYWxDYWNoZVxyXG5cclxudmFyIEdsb2JhbENhY2hlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEdsb2JhbENhY2hlIChnYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcblxyXG4gICAgICAgIHRoaXMuYmluYXJ5ID0gbmV3IEJhc2VDYWNoZSgpO1xyXG4gICAgICAgIHRoaXMuYml0bWFwRm9udCA9IG5ldyBCYXNlQ2FjaGUoKTtcclxuICAgICAgICB0aGlzLmpzb24gPSBuZXcgQmFzZUNhY2hlKCk7XHJcbiAgICAgICAgdGhpcy5waHlzaWNzID0gbmV3IEJhc2VDYWNoZSgpO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbmV3IEJhc2VDYWNoZSgpO1xyXG4gICAgICAgIHRoaXMuc291bmQgPSBuZXcgQmFzZUNhY2hlKCk7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gbmV3IEJhc2VDYWNoZSgpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcCA9IG5ldyBCYXNlQ2FjaGUoKTtcclxuICAgICAgICB0aGlzLnZpZGVvID0gbmV3IEJhc2VDYWNoZSgpO1xyXG4gICAgICAgIHRoaXMueG1sID0gbmV3IEJhc2VDYWNoZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmN1c3RvbSA9IHt9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQWRkIHlvdXIgb3duIGN1c3RvbSBDYWNoZSBlbnRyeSwgYXZhaWxhYmxlIHVuZGVyIENhY2hlLmN1c3RvbS5rZXlcclxuICAgIGFkZEN1c3RvbTogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuY3VzdG9tLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbVtrZXldID0gbmV3IEJhc2VDYWNoZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdsb2JhbENhY2hlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhY2hlL0dsb2JhbENhY2hlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgQ2FjaGVBZGRFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBDYWNoZUFkZEV2ZW50IChjYWNoZSwga2V5LCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ0NBQ0hFX0FERF9FVkVOVCcpO1xyXG5cclxuICAgICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZUFkZEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhY2hlL2V2ZW50cy9DYWNoZUFkZEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgQ2FjaGVSZW1vdmVFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBDYWNoZVJlbW92ZUV2ZW50IChjYWNoZSwga2V5LCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ0NBQ0hFX1JFTU9WRV9FVkVOVCcpO1xyXG5cclxuICAgICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZVJlbW92ZUV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhY2hlL2V2ZW50cy9DYWNoZVJlbW92ZUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ0FDSEVfQUREX0VWRU5UOiByZXF1aXJlKCcuL0NhY2hlQWRkRXZlbnQnKSxcclxuICAgIENBQ0hFX1JFTU9WRV9FVkVOVDogcmVxdWlyZSgnLi9DYWNoZVJlbW92ZUV2ZW50JylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FjaGUvZXZlbnRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhbWVyYVRvU2NyZWVuID0gZnVuY3Rpb24gKHBvaW50SW4sIHBvaW50T3V0KVxyXG57XHJcbiAgICB2YXIgY2FtZXJhTWF0cml4ID0gdGhpcy5tYXRyaXgubWF0cml4O1xyXG4gICAgdmFyIG12YSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgIHZhciBtdmIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICB2YXIgbXZjID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgdmFyIG12ZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgIHZhciBtdmUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICB2YXIgbXZmID0gY2FtZXJhTWF0cml4WzVdO1xyXG4gICAgXHJcbiAgICAvKiBGaXJzdCBJbnZlcnQgTWF0cml4ICovXHJcbiAgICB2YXIgZGV0ZXJtaW5hbnQgPSAobXZhICogbXZkKSAtIChtdmIgKiBtdmMpO1xyXG5cclxuICAgIGlmICghZGV0ZXJtaW5hbnQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50SW47XHJcbiAgICB9XHJcblxyXG4gICAgZGV0ZXJtaW5hbnQgPSAxIC8gZGV0ZXJtaW5hbnQ7XHJcblxyXG4gICAgdmFyIGltYSA9IG12ZCAqIGRldGVybWluYW50O1xyXG4gICAgdmFyIGltYiA9IC1tdmIgKiBkZXRlcm1pbmFudDtcclxuICAgIHZhciBpbWMgPSAtbXZjICogZGV0ZXJtaW5hbnQ7XHJcbiAgICB2YXIgaW1kID0gbXZhICogZGV0ZXJtaW5hbnQ7XHJcbiAgICB2YXIgaW1lID0gKG12YyAqIG12ZiAtIG12ZCAqIG12ZSkgKiBkZXRlcm1pbmFudDtcclxuICAgIHZhciBpbWYgPSAobXZiICogbXZlIC0gbXZhICogbXZmKSAqIGRldGVybWluYW50O1xyXG5cclxuICAgIHZhciB4ID0gcG9pbnRJbi54O1xyXG4gICAgdmFyIHkgPSBwb2ludEluLnk7XHJcblxyXG4gICAgaWYgKCFwb2ludE91dClcclxuICAgIHtcclxuICAgICAgICBwb2ludE91dCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qIEFwcGx5IHRyYW5zZm9ybSB0byBwb2ludCAqL1xyXG4gICAgcG9pbnRPdXQueCA9ICh4ICogaW1hICsgeSAqIGltYyArIGltZSk7XHJcbiAgICBwb2ludE91dC55ID0gKHggKiBpbWIgKyB5ICogaW1kICsgaW1mKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHBvaW50T3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYW1lcmFUb1NjcmVlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvMmQvaW5jL0NhbWVyYVRvU2NyZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENlbnRlclRvQm91bmRzID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5zY3JvbGxYID0gKHRoaXMuX2JvdW5kcy53aWR0aCAqIDAuNSkgLSAodGhpcy53aWR0aCAqIDAuNSk7XHJcbiAgICB0aGlzLnNjcm9sbFkgPSAodGhpcy5fYm91bmRzLmhlaWdodCAqIDAuNSkgLSAodGhpcy5oZWlnaHQgKiAwLjUpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VudGVyVG9Cb3VuZHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9DZW50ZXJUb0JvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gMzY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZW50ZXJUb1NpemUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLnNjcm9sbFggPSB0aGlzLndpZHRoICogMC41O1xyXG4gICAgdGhpcy5zY3JvbGxZID0gdGhpcy5oZWlnaHQgKiAwLjU7XHJcbiAgICBcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJUb1NpemU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9DZW50ZXJUb1NpemUuanNcbi8vIG1vZHVsZSBpZCA9IDM2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3VsbCA9IGZ1bmN0aW9uIChyZW5kZXJhYmxlT2JqZWN0cylcclxue1xyXG4gICAgaWYgKHRoaXMuZGlzYWJsZUN1bGwpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmFibGVPYmplY3RzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjYW1lcmFNYXRyaXggPSB0aGlzLm1hdHJpeC5tYXRyaXg7XHJcblxyXG4gICAgdmFyIG12YSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgIHZhciBtdmIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICB2YXIgbXZjID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgdmFyIG12ZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgIFxyXG4gICAgLyogRmlyc3QgSW52ZXJ0IE1hdHJpeCAqL1xyXG4gICAgdmFyIGRldGVybWluYW50ID0gKG12YSAqIG12ZCkgLSAobXZiICogbXZjKTtcclxuXHJcbiAgICBpZiAoIWRldGVybWluYW50KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiByZW5kZXJhYmxlT2JqZWN0cztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbXZlID0gY2FtZXJhTWF0cml4WzRdO1xyXG4gICAgdmFyIG12ZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuXHJcbiAgICB2YXIgc2Nyb2xsWCA9IHRoaXMuc2Nyb2xsWDtcclxuICAgIHZhciBzY3JvbGxZID0gdGhpcy5zY3JvbGxZO1xyXG4gICAgdmFyIGNhbWVyYVcgPSB0aGlzLndpZHRoO1xyXG4gICAgdmFyIGNhbWVyYUggPSB0aGlzLmhlaWdodDtcclxuICAgIHZhciBjdWxsZWRPYmplY3RzID0gdGhpcy5jdWxsZWRPYmplY3RzO1xyXG4gICAgdmFyIGxlbmd0aCA9IHJlbmRlcmFibGVPYmplY3RzLmxlbmd0aDtcclxuXHJcbiAgICBkZXRlcm1pbmFudCA9IDEgLyBkZXRlcm1pbmFudDtcclxuXHJcbiAgICBjdWxsZWRPYmplY3RzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgKytpbmRleClcclxuICAgIHtcclxuICAgICAgICB2YXIgb2JqZWN0ID0gcmVuZGVyYWJsZU9iamVjdHNbaW5kZXhdO1xyXG5cclxuICAgICAgICBpZiAoIW9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnd2lkdGgnKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN1bGxlZE9iamVjdHMucHVzaChvYmplY3QpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvYmplY3RXID0gb2JqZWN0LndpZHRoO1xyXG4gICAgICAgIHZhciBvYmplY3RIID0gb2JqZWN0LmhlaWdodDtcclxuICAgICAgICB2YXIgb2JqZWN0WCA9IChvYmplY3QueCAtIChzY3JvbGxYICogb2JqZWN0LnNjcm9sbEZhY3RvclgpKSAtIChvYmplY3RXICogb2JqZWN0Lm9yaWdpblgpO1xyXG4gICAgICAgIHZhciBvYmplY3RZID0gKG9iamVjdC55IC0gKHNjcm9sbFkgKiBvYmplY3Quc2Nyb2xsRmFjdG9yWSkpIC0gKG9iamVjdEggKiBvYmplY3Qub3JpZ2luWSk7XHJcbiAgICAgICAgdmFyIHR4ID0gKG9iamVjdFggKiBtdmEgKyBvYmplY3RZICogbXZjICsgbXZlKTtcclxuICAgICAgICB2YXIgdHkgPSAob2JqZWN0WCAqIG12YiArIG9iamVjdFkgKiBtdmQgKyBtdmYpO1xyXG4gICAgICAgIHZhciB0dyA9ICgob2JqZWN0WCArIG9iamVjdFcpICogbXZhICsgKG9iamVjdFkgKyBvYmplY3RIKSAqIG12YyArIG12ZSk7XHJcbiAgICAgICAgdmFyIHRoID0gKChvYmplY3RYICsgb2JqZWN0VykgKiBtdmIgKyAob2JqZWN0WSArIG9iamVjdEgpICogbXZkICsgbXZmKTtcclxuICAgICAgICB2YXIgY3VsbFcgPSBjYW1lcmFXICsgb2JqZWN0VztcclxuICAgICAgICB2YXIgY3VsbEggPSBjYW1lcmFIICsgb2JqZWN0SDtcclxuXHJcbiAgICAgICAgaWYgKHR4ID4gLW9iamVjdFcgfHwgdHkgPiAtb2JqZWN0SCB8fCB0eCA8IGN1bGxXIHx8IHR5IDwgY3VsbEggfHxcclxuICAgICAgICAgICAgdHcgPiAtb2JqZWN0VyB8fCB0aCA+IC1vYmplY3RIIHx8IHR3IDwgY3VsbFcgfHwgdGggPCBjdWxsSClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN1bGxlZE9iamVjdHMucHVzaChvYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3VsbGVkT2JqZWN0cztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3VsbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvMmQvaW5jL0N1bGwuanNcbi8vIG1vZHVsZSBpZCA9IDM2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3VsbEhpdFRlc3QgPSBmdW5jdGlvbiAoaW50ZXJhY3RpdmVPYmplY3RzKVxyXG57XHJcbiAgICBpZiAodGhpcy5kaXNhYmxlQ3VsbClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJhY3RpdmVPYmplY3RzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjYW1lcmFNYXRyaXggPSB0aGlzLm1hdHJpeC5tYXRyaXg7XHJcblxyXG4gICAgdmFyIG12YSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgIHZhciBtdmIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICB2YXIgbXZjID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgdmFyIG12ZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgIFxyXG4gICAgLyogRmlyc3QgSW52ZXJ0IE1hdHJpeCAqL1xyXG4gICAgdmFyIGRldGVybWluYW50ID0gKG12YSAqIG12ZCkgLSAobXZiICogbXZjKTtcclxuXHJcbiAgICBpZiAoIWRldGVybWluYW50KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmFjdGl2ZU9iamVjdHM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG12ZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgIHZhciBtdmYgPSBjYW1lcmFNYXRyaXhbNV07XHJcblxyXG4gICAgdmFyIHNjcm9sbFggPSB0aGlzLnNjcm9sbFg7XHJcbiAgICB2YXIgc2Nyb2xsWSA9IHRoaXMuc2Nyb2xsWTtcclxuICAgIHZhciBjYW1lcmFXID0gdGhpcy53aWR0aDtcclxuICAgIHZhciBjYW1lcmFIID0gdGhpcy5oZWlnaHQ7XHJcbiAgICB2YXIgbGVuZ3RoID0gaW50ZXJhY3RpdmVPYmplY3RzLmxlbmd0aDtcclxuXHJcbiAgICBkZXRlcm1pbmFudCA9IDEgLyBkZXRlcm1pbmFudDtcclxuXHJcbiAgICB2YXIgY3VsbGVkT2JqZWN0cyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG9iamVjdCA9IGludGVyYWN0aXZlT2JqZWN0c1tpbmRleF0uZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgaWYgKCFvYmplY3QuaGFzT3duUHJvcGVydHkoJ3dpZHRoJykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdWxsZWRPYmplY3RzLnB1c2goaW50ZXJhY3RpdmVPYmplY3RzW2luZGV4XSk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG9iamVjdFcgPSBvYmplY3Qud2lkdGg7XHJcbiAgICAgICAgdmFyIG9iamVjdEggPSBvYmplY3QuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBvYmplY3RYID0gKG9iamVjdC54IC0gKHNjcm9sbFggKiBvYmplY3Quc2Nyb2xsRmFjdG9yWCkpIC0gKG9iamVjdFcgKiBvYmplY3Qub3JpZ2luWCk7XHJcbiAgICAgICAgdmFyIG9iamVjdFkgPSAob2JqZWN0LnkgLSAoc2Nyb2xsWSAqIG9iamVjdC5zY3JvbGxGYWN0b3JZKSkgLSAob2JqZWN0SCAqIG9iamVjdC5vcmlnaW5ZKTtcclxuICAgICAgICB2YXIgdHggPSAob2JqZWN0WCAqIG12YSArIG9iamVjdFkgKiBtdmMgKyBtdmUpO1xyXG4gICAgICAgIHZhciB0eSA9IChvYmplY3RYICogbXZiICsgb2JqZWN0WSAqIG12ZCArIG12Zik7XHJcbiAgICAgICAgdmFyIHR3ID0gKChvYmplY3RYICsgb2JqZWN0VykgKiBtdmEgKyAob2JqZWN0WSArIG9iamVjdEgpICogbXZjICsgbXZlKTtcclxuICAgICAgICB2YXIgdGggPSAoKG9iamVjdFggKyBvYmplY3RXKSAqIG12YiArIChvYmplY3RZICsgb2JqZWN0SCkgKiBtdmQgKyBtdmYpO1xyXG4gICAgICAgIHZhciBjdWxsVyA9IGNhbWVyYVcgKyBvYmplY3RXO1xyXG4gICAgICAgIHZhciBjdWxsSCA9IGNhbWVyYUggKyBvYmplY3RIO1xyXG5cclxuICAgICAgICBpZiAodHggPiAtb2JqZWN0VyB8fCB0eSA+IC1vYmplY3RIIHx8IHR4IDwgY3VsbFcgfHwgdHkgPCBjdWxsSCB8fFxyXG4gICAgICAgICAgICB0dyA+IC1vYmplY3RXIHx8IHRoID4gLW9iamVjdEggfHwgdHcgPCBjdWxsVyB8fCB0aCA8IGN1bGxIKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3VsbGVkT2JqZWN0cy5wdXNoKGludGVyYWN0aXZlT2JqZWN0c1tpbmRleF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3VsbGVkT2JqZWN0cztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3VsbEhpdFRlc3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9DdWxsSGl0VGVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMzcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDdWxsVGlsZW1hcCA9IGZ1bmN0aW9uICh0aWxlbWFwKVxyXG57XHJcbiAgICB2YXIgY2FtZXJhTWF0cml4ID0gdGhpcy5tYXRyaXgubWF0cml4O1xyXG5cclxuICAgIHZhciBtdmEgPSBjYW1lcmFNYXRyaXhbMF07XHJcbiAgICB2YXIgbXZiID0gY2FtZXJhTWF0cml4WzFdO1xyXG4gICAgdmFyIG12YyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgIHZhciBtdmQgPSBjYW1lcmFNYXRyaXhbM107XHJcbiAgICBcclxuICAgIC8qIEZpcnN0IEludmVydCBNYXRyaXggKi9cclxuICAgIHZhciBkZXRlcm1pbmFudCA9IChtdmEgKiBtdmQpIC0gKG12YiAqIG12Yyk7XHJcblxyXG4gICAgaWYgKCFkZXRlcm1pbmFudClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGlsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG12ZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgIHZhciBtdmYgPSBjYW1lcmFNYXRyaXhbNV07XHJcbiAgICB2YXIgdGlsZXMgPSB0aWxlbWFwLnRpbGVzO1xyXG4gICAgdmFyIHNjcm9sbFggPSB0aGlzLnNjcm9sbFg7XHJcbiAgICB2YXIgc2Nyb2xsWSA9IHRoaXMuc2Nyb2xsWTtcclxuICAgIHZhciBjYW1lcmFXID0gdGhpcy53aWR0aDtcclxuICAgIHZhciBjYW1lcmFIID0gdGhpcy5oZWlnaHQ7XHJcbiAgICB2YXIgY3VsbGVkT2JqZWN0cyA9IHRoaXMuY3VsbGVkT2JqZWN0cztcclxuICAgIHZhciBsZW5ndGggPSB0aWxlcy5sZW5ndGg7XHJcbiAgICB2YXIgdGlsZVcgPSB0aWxlbWFwLnRpbGVXaWR0aDtcclxuICAgIHZhciB0aWxlSCA9IHRpbGVtYXAudGlsZUhlaWdodDtcclxuICAgIHZhciBjdWxsVyA9IGNhbWVyYVcgKyB0aWxlVztcclxuICAgIHZhciBjdWxsSCA9IGNhbWVyYUggKyB0aWxlSDtcclxuICAgIHZhciBzY3JvbGxGYWN0b3JYID0gdGlsZW1hcC5zY3JvbGxGYWN0b3JYO1xyXG4gICAgdmFyIHNjcm9sbEZhY3RvclkgPSB0aWxlbWFwLnNjcm9sbEZhY3Rvclk7XHJcblxyXG4gICAgZGV0ZXJtaW5hbnQgPSAxIC8gZGV0ZXJtaW5hbnQ7XHJcblxyXG4gICAgY3VsbGVkT2JqZWN0cy5sZW5ndGggPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRpbGUgPSB0aWxlc1tpbmRleF07XHJcbiAgICAgICAgdmFyIHRpbGVYID0gKHRpbGUueCAtIChzY3JvbGxYICogc2Nyb2xsRmFjdG9yWCkpO1xyXG4gICAgICAgIHZhciB0aWxlWSA9ICh0aWxlLnkgLSAoc2Nyb2xsWSAqIHNjcm9sbEZhY3RvclkpKTtcclxuICAgICAgICB2YXIgdHggPSAodGlsZVggKiBtdmEgKyB0aWxlWSAqIG12YyArIG12ZSk7XHJcbiAgICAgICAgdmFyIHR5ID0gKHRpbGVYICogbXZiICsgdGlsZVkgKiBtdmQgKyBtdmYpO1xyXG4gICAgICAgIHZhciB0dyA9ICgodGlsZVggKyB0aWxlVykgKiBtdmEgKyAodGlsZVkgKyB0aWxlSCkgKiBtdmMgKyBtdmUpO1xyXG4gICAgICAgIHZhciB0aCA9ICgodGlsZVggKyB0aWxlVykgKiBtdmIgKyAodGlsZVkgKyB0aWxlSCkgKiBtdmQgKyBtdmYpO1xyXG5cclxuICAgICAgICBpZiAodHggPiAtdGlsZVcgJiYgdHkgPiAtdGlsZUggJiYgdHcgPCBjdWxsVyAmJiB0aCA8IGN1bGxIKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3VsbGVkT2JqZWN0cy5wdXNoKHRpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3VsbGVkT2JqZWN0cztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3VsbFRpbGVtYXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9DdWxsVGlsZW1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMzcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEZXN0cm95ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5tYXRyaXggPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmN1bGxlZE9iamVjdHMgPSBbXTtcclxuICAgIHRoaXMuc2NlbmUgPSB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlc3Ryb3k7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9EZXN0cm95LmpzXG4vLyBtb2R1bGUgaWQgPSAzNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZhZGUgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHJlZCwgZ3JlZW4sIGJsdWUsIGZvcmNlKVxyXG57XHJcbiAgICBpZiAocmVkID09PSB1bmRlZmluZWQpIHsgcmVkID0gMC4wOyB9XHJcbiAgICBpZiAoZ3JlZW4gPT09IHVuZGVmaW5lZCkgeyBncmVlbiA9IDAuMDsgfVxyXG4gICAgaWYgKGJsdWUgPT09IHVuZGVmaW5lZCkgeyBibHVlID0gMC4wOyB9XHJcblxyXG4gICAgaWYgKCFmb3JjZSAmJiB0aGlzLl9mYWRlQWxwaGEgPiAwLjApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2ZhZGVSZWQgPSByZWQ7XHJcbiAgICB0aGlzLl9mYWRlR3JlZW4gPSBncmVlbjtcclxuICAgIHRoaXMuX2ZhZGVCbHVlID0gYmx1ZTtcclxuXHJcbiAgICBpZiAoZHVyYXRpb24gPD0gMClcclxuICAgIHtcclxuICAgICAgICBkdXJhdGlvbiA9IE51bWJlci5NSU5fVkFMVUU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZmFkZUR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICB0aGlzLl9mYWRlQWxwaGEgPSBOdW1iZXIuTUlOX1ZBTFVFO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS8yZC9pbmMvRmFkZS5qc1xuLy8gbW9kdWxlIGlkID0gMzczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbGFzaCA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgcmVkLCBncmVlbiwgYmx1ZSwgZm9yY2UpXHJcbntcclxuICAgIGlmICghZm9yY2UgJiYgdGhpcy5fZmxhc2hBbHBoYSA+IDAuMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlZCA9PT0gdW5kZWZpbmVkKSB7IHJlZCA9IDEuMDsgfVxyXG4gICAgaWYgKGdyZWVuID09PSB1bmRlZmluZWQpIHsgZ3JlZW4gPSAxLjA7IH1cclxuICAgIGlmIChibHVlID09PSB1bmRlZmluZWQpIHsgYmx1ZSA9IDEuMDsgfVxyXG5cclxuICAgIHRoaXMuX2ZsYXNoUmVkID0gcmVkO1xyXG4gICAgdGhpcy5fZmxhc2hHcmVlbiA9IGdyZWVuO1xyXG4gICAgdGhpcy5fZmxhc2hCbHVlID0gYmx1ZTtcclxuXHJcbiAgICBpZiAoZHVyYXRpb24gPD0gMClcclxuICAgIHtcclxuICAgICAgICBkdXJhdGlvbiA9IE51bWJlci5NSU5fVkFMVUU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZmxhc2hEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgdGhpcy5fZmxhc2hBbHBoYSA9IDEuMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmxhc2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9GbGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gMzc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJZ25vcmUgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdE9yQXJyYXkpXHJcbntcclxuICAgIGlmIChnYW1lT2JqZWN0T3JBcnJheSBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBnYW1lT2JqZWN0T3JBcnJheS5sZW5ndGg7ICsraW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnYW1lT2JqZWN0T3JBcnJheVtpbmRleF0uY2FtZXJhRmlsdGVyIHw9IHRoaXMuX2lkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBnYW1lT2JqZWN0T3JBcnJheS5jYW1lcmFGaWx0ZXIgfD0gdGhpcy5faWQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElnbm9yZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvMmQvaW5jL0lnbm9yZS5qc1xuLy8gbW9kdWxlIGlkID0gMzc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQcmVSZW5kZXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgdmFyIHpvb20gPSB0aGlzLnpvb207XHJcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcbiAgICB2YXIgb3JpZ2luWCA9IHdpZHRoIC8gMjtcclxuICAgIHZhciBvcmlnaW5ZID0gaGVpZ2h0IC8gMjtcclxuICAgIHZhciBmb2xsb3cgPSB0aGlzLl9mb2xsb3c7XHJcblxyXG4gICAgaWYgKGZvbGxvdyAhPT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICBvcmlnaW5YID0gZm9sbG93Lng7XHJcbiAgICAgICAgb3JpZ2luWSA9IGZvbGxvdy55O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuc2Nyb2xsWCA9IG9yaWdpblggLSB3aWR0aCAqIDAuNTtcclxuICAgICAgICB0aGlzLnNjcm9sbFkgPSBvcmlnaW5ZIC0gaGVpZ2h0ICogMC41O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnVzZUJvdW5kcylcclxuICAgIHtcclxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xyXG4gICAgICAgIHZhciBib3VuZHNYID0gYm91bmRzLng7XHJcbiAgICAgICAgdmFyIGJvdW5kc1kgPSBib3VuZHMueTtcclxuICAgICAgICB2YXIgYm91bmRzUiA9IE1hdGgubWF4KGJvdW5kcy5yaWdodCAtIHdpZHRoLCB3aWR0aCk7XHJcbiAgICAgICAgdmFyIGJvdW5kc0IgPSBNYXRoLm1heChib3VuZHMuYm90dG9tIC0gaGVpZ2h0LCBoZWlnaHQpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxYIDwgYm91bmRzWClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsWCA9IGJvdW5kc1g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFggPiBib3VuZHNSKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxYID0gYm91bmRzUjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFkgPCBib3VuZHNZKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxZID0gYm91bmRzWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsWSA+IGJvdW5kc0IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFkgPSBib3VuZHNCO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5yb3VuZFBpeGVscylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFggPSBNYXRoLnJvdW5kKHRoaXMuc2Nyb2xsWCk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxZID0gTWF0aC5yb3VuZCh0aGlzLnNjcm9sbFkpO1xyXG4gICAgfVxyXG5cclxuICAgIG1hdHJpeC5sb2FkSWRlbnRpdHkoKTtcclxuICAgIG1hdHJpeC50cmFuc2xhdGUodGhpcy54ICsgb3JpZ2luWCwgdGhpcy55ICsgb3JpZ2luWSk7XHJcbiAgICBtYXRyaXgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgbWF0cml4LnNjYWxlKHpvb20sIHpvb20pO1xyXG4gICAgbWF0cml4LnRyYW5zbGF0ZSgtb3JpZ2luWCwgLW9yaWdpblkpO1xyXG4gICAgbWF0cml4LnRyYW5zbGF0ZSh0aGlzLl9zaGFrZU9mZnNldFgsIHRoaXMuX3NoYWtlT2Zmc2V0WSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByZVJlbmRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvMmQvaW5jL1ByZVJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZW1vdmVCb3VuZHMgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLnVzZUJvdW5kcyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX2JvdW5kcy5zZXRFbXB0eSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVCb3VuZHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9SZW1vdmVCb3VuZHMuanNcbi8vIG1vZHVsZSBpZCA9IDM3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVmFsdWVUb0NvbG9yID0gcmVxdWlyZSgnLi4vLi4vLi4vZ3JhcGhpY3MvY29sb3IvVmFsdWVUb0NvbG9yJyk7XHJcblxyXG52YXIgU2V0QmFja2dyb3VuZENvbG9yID0gZnVuY3Rpb24gKGNvbG9yKVxyXG57XHJcbiAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkgeyBjb2xvciA9ICdyZ2JhKDAsMCwwLDApJzsgfVxyXG5cclxuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gVmFsdWVUb0NvbG9yKGNvbG9yKTtcclxuXHJcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gKHRoaXMuYmFja2dyb3VuZENvbG9yLmFscGhhID09PSAwKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0QmFja2dyb3VuZENvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS8yZC9pbmMvU2V0QmFja2dyb3VuZENvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldEJvdW5kcyA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICB0aGlzLl9ib3VuZHMuc2V0VG8oeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgdGhpcy51c2VCb3VuZHMgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRCb3VuZHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9TZXRCb3VuZHMuanNcbi8vIG1vZHVsZSBpZCA9IDM3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0TmFtZSA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHsgdmFsdWUgPSAnJzsgfVxyXG5cclxuICAgIHRoaXMubmFtZSA9IHZhbHVlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXROYW1lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS8yZC9pbmMvU2V0TmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMzgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICh4LCB5KVxyXG57XHJcbiAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFBvc2l0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS8yZC9pbmMvU2V0UG9zaXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0Um90YXRpb24gPSBmdW5jdGlvbiAodmFsdWUpXHJcbntcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IHZhbHVlID0gMDsgfVxyXG5cclxuICAgIHRoaXMucm90YXRpb24gPSB2YWx1ZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0Um90YXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9TZXRSb3RhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRSb3VuZFBpeGVscyA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IHZhbHVlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRSb3VuZFBpeGVscztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvMmQvaW5jL1NldFJvdW5kUGl4ZWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFNjZW5lID0gZnVuY3Rpb24gKHNjZW5lKVxyXG57XHJcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFNjZW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS8yZC9pbmMvU2V0U2NlbmUuanNcbi8vIG1vZHVsZSBpZCA9IDM4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0U2Nyb2xsID0gZnVuY3Rpb24gKHgsIHkpXHJcbntcclxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICB0aGlzLnNjcm9sbFggPSB4O1xyXG4gICAgdGhpcy5zY3JvbGxZID0geTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0U2Nyb2xsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS8yZC9pbmMvU2V0U2Nyb2xsLmpzXG4vLyBtb2R1bGUgaWQgPSAzODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IHdpZHRoOyB9XHJcblxyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFNpemU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9TZXRTaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAzODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbntcclxuICAgIHRoaXMueCA9IHg7XHJcbiAgICB0aGlzLnkgPSB5O1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFZpZXdwb3J0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS8yZC9pbmMvU2V0Vmlld3BvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDM4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0Wm9vbSA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHsgdmFsdWUgPSAxOyB9XHJcblxyXG4gICAgdGhpcy56b29tID0gdmFsdWU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFpvb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9TZXRab29tLmpzXG4vLyBtb2R1bGUgaWQgPSAzODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNoYWtlID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBpbnRlbnNpdHksIGZvcmNlKVxyXG57XHJcbiAgICBpZiAoaW50ZW5zaXR5ID09PSB1bmRlZmluZWQpIHsgaW50ZW5zaXR5ID0gMC4wNTsgfVxyXG5cclxuICAgIGlmICghZm9yY2UgJiYgKHRoaXMuX3NoYWtlT2Zmc2V0WCAhPT0gMC4wIHx8IHRoaXMuX3NoYWtlT2Zmc2V0WSAhPT0gMC4wKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fc2hha2VEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgdGhpcy5fc2hha2VJbnRlbnNpdHkgPSBpbnRlbnNpdHk7XHJcbiAgICB0aGlzLl9zaGFrZU9mZnNldFggPSAwO1xyXG4gICAgdGhpcy5fc2hha2VPZmZzZXRZID0gMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hha2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9TaGFrZS5qc1xuLy8gbW9kdWxlIGlkID0gMzg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdGFydEZvbGxvdyA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0T3JQb2ludCwgcm91bmRQeClcclxue1xyXG4gICAgaWYgKHRoaXMuX2ZvbGxvdyAhPT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0b3BGb2xsb3coKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9mb2xsb3cgPSBnYW1lT2JqZWN0T3JQb2ludDtcclxuXHJcbiAgICBpZiAocm91bmRQeCAhPT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucm91bmRQaXhlbHMgPSByb3VuZFB4O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGFydEZvbGxvdztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvMmQvaW5jL1N0YXJ0Rm9sbG93LmpzXG4vLyBtb2R1bGUgaWQgPSAzOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0b3BGb2xsb3cgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvKiBkbyB1bmZvbGxvdyB3b3JrIGhlcmUgKi9cclxuICAgIHRoaXMuX2ZvbGxvdyA9IG51bGw7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3BGb2xsb3c7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhLzJkL2luYy9TdG9wRm9sbG93LmpzXG4vLyBtb2R1bGUgaWQgPSAzOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuICAgIGNhbWVyYToge1xyXG4gICAgICAgIHg6IGludFxyXG4gICAgICAgIHk6IGludFxyXG4gICAgICAgIHdpZHRoOiBpbnRcclxuICAgICAgICBoZWlnaHQ6IGludFxyXG4gICAgICAgIHpvb206IGZsb2F0XHJcbiAgICAgICAgcm90YXRpb246IGZsb2F0XHJcbiAgICAgICAgcm91bmRQaXhlbHM6IGJvb2xcclxuICAgICAgICBzY3JvbGxYOiBmbG9hdFxyXG4gICAgICAgIHNjcm9sbFk6IGZsb2F0XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBzdHJpbmdcclxuICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgeDogaW50XHJcbiAgICAgICAgICAgIHk6IGludFxyXG4gICAgICAgICAgICB3aWR0aDogaW50XHJcbiAgICAgICAgICAgIGhlaWdodDogaW50XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4qL1xyXG52YXIgVG9KU09OID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIG91dHB1dCA9IHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgeDogdGhpcy54LFxyXG4gICAgICAgIHk6IHRoaXMueSxcclxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgIHpvb206IHRoaXMuem9vbSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcclxuICAgICAgICByb3VuZFBpeGVsczogdGhpcy5yb3VuZFBpeGVscyxcclxuICAgICAgICBzY3JvbGxYOiB0aGlzLnNjcm9sbFgsXHJcbiAgICAgICAgc2Nyb2xsWTogdGhpcy5zY3JvbGxZLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5iYWNrZ3JvdW5kQ29sb3IucmdiYVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodGhpcy51c2VCb3VuZHMpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0Wydib3VuZHMnXSA9IHtcclxuICAgICAgICAgICAgeDogdGhpcy5fYm91bmRzLngsXHJcbiAgICAgICAgICAgIHk6IHRoaXMuX2JvdW5kcy55LFxyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5fYm91bmRzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuX2JvdW5kcy5oZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvSlNPTjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvMmQvaW5jL1RvSlNPTi5qc1xuLy8gbW9kdWxlIGlkID0gMzkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBVcGRhdGUgPSBmdW5jdGlvbiAodGltZXN0ZXAsIGRlbHRhKVxyXG57XHJcbiAgICBpZiAodGhpcy5fZmxhc2hBbHBoYSA+IDAuMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9mbGFzaEFscGhhIC09IGRlbHRhIC8gdGhpcy5fZmxhc2hEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYXNoQWxwaGEgPCAwLjApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9mbGFzaEFscGhhID0gMC4wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fZmFkZUFscGhhID4gMC4wICYmIHRoaXMuX2ZhZGVBbHBoYSA8IDEuMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9mYWRlQWxwaGEgKz0gZGVsdGEgLyB0aGlzLl9mYWRlRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mYWRlQWxwaGEgPj0gMS4wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fZmFkZUFscGhhID0gMS4wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fc2hha2VEdXJhdGlvbiA+IDAuMClcclxuICAgIHtcclxuICAgICAgICB2YXIgaW50ZW5zaXR5ID0gdGhpcy5fc2hha2VJbnRlbnNpdHk7XHJcblxyXG4gICAgICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gLT0gZGVsdGE7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9zaGFrZUR1cmF0aW9uIDw9IDAuMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlT2Zmc2V0WCA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy5fc2hha2VPZmZzZXRZID0gMC4wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFggPSAoTWF0aC5yYW5kb20oKSAqIGludGVuc2l0eSAqIHRoaXMud2lkdGggKiAyIC0gaW50ZW5zaXR5ICogdGhpcy53aWR0aCkgKiB0aGlzLnpvb207XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlT2Zmc2V0WSA9IChNYXRoLnJhbmRvbSgpICogaW50ZW5zaXR5ICogdGhpcy5oZWlnaHQgKiAyIC0gaW50ZW5zaXR5ICogdGhpcy5oZWlnaHQpICogdGhpcy56b29tO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXBkYXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS8yZC9pbmMvVXBkYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBDYW1lcmFNYW5hZ2VyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIENhbWVyYU1hbmFnZXIgKHNjZW5lKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUaGUgU2NlbmUgdGhhdCBvd25zIHRoaXMgcGx1Z2luXHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FtZXJhSWQgPSAxO1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuXHJcbiAgICAgICAgdGhpcy5jYW1lcmFzID0gW107XHJcbiAgICAgICAgdGhpcy5jYW1lcmFQb29sID0gW107XHJcblxyXG4gICAgICAgIGlmIChzY2VuZS5zeXMuc2V0dGluZ3MuY2FtZXJhcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBXZSBoYXZlIGNhbWVyYXMgdG8gY3JlYXRlXHJcbiAgICAgICAgICAgIHRoaXMuZnJvbUpTT04oc2NlbmUuc3lzLnNldHRpbmdzLmNhbWVyYXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgTWFrZSBvbmVcclxuICAgICAgICAgICAgdGhpcy5hZGQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBTZXQgdGhlIGRlZmF1bHQgY2FtZXJhXHJcbiAgICAgICAgdGhpcy5tYWluID0gdGhpcy5jYW1lcmFzWzBdO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IHJlcXVpcmUoJy4vaW5jL0FkZDJEQ2FtZXJhJyksXHJcbiAgICBhZGQzRDogcmVxdWlyZSgnLi9pbmMvQWRkUGVyc3BlY3RpdmVDYW1lcmEnKSxcclxuICAgIGFkZFBlcnNwZWN0aXZlQ2FtZXJhOiByZXF1aXJlKCcuL2luYy9BZGRQZXJzcGVjdGl2ZUNhbWVyYScpLFxyXG4gICAgYWRkT3J0aG9ncmFwaGljQ2FtZXJhOiByZXF1aXJlKCcuL2luYy9BZGRPcnRob2dyYXBoaWNDYW1lcmEnKSxcclxuICAgIGFkZEV4aXN0aW5nOiByZXF1aXJlKCcuL2luYy9BZGRFeGlzdGluZycpLFxyXG4gICAgYWRkS2V5Q29udHJvbDogcmVxdWlyZSgnLi9pbmMvQWRkS2V5Q29udHJvbCcpLFxyXG4gICAgYWRkU21vb3RoZWRLZXlDb250cm9sOiByZXF1aXJlKCcuL2luYy9BZGRTbW9vdGhlZEtleUNvbnRyb2wnKSxcclxuICAgIGRlc3Ryb3k6IHJlcXVpcmUoJy4vaW5jL0Rlc3Ryb3knKSxcclxuICAgIGZyb21KU09OOiByZXF1aXJlKCcuL2luYy9Gcm9tSlNPTicpLFxyXG4gICAgZ2V0Q2FtZXJhQmVsb3dQb2ludGVyOiByZXF1aXJlKCcuL2luYy9HZXRDYW1lcmFCZWxvd1BvaW50ZXInKSxcclxuICAgIHJlbW92ZTogcmVxdWlyZSgnLi9pbmMvUmVtb3ZlQ2FtZXJhJyksXHJcbiAgICByZW5kZXI6IHJlcXVpcmUoJy4vaW5jL1JlbmRlcicpLFxyXG4gICAgcmVzZXRBbGw6IHJlcXVpcmUoJy4vaW5jL1Jlc2V0QWxsJyksXHJcbiAgICB1cGRhdGU6IHJlcXVpcmUoJy4vaW5jL1VwZGF0ZScpXHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FtZXJhTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvbG9jYWwvQ2FtZXJhTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMzk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYW1lcmEgPSByZXF1aXJlKCcuLi8uLi8yZC9DYW1lcmEnKTtcclxuXHJcbnZhciBBZGQyRENhbWVyYSA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBtYWtlTWFpbilcclxue1xyXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSB0aGlzLnNjZW5lLnN5cy5nYW1lLmNvbmZpZy53aWR0aDsgfVxyXG4gICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IHRoaXMuc2NlbmUuc3lzLmdhbWUuY29uZmlnLmhlaWdodDsgfVxyXG4gICAgaWYgKG1ha2VNYWluID09PSB1bmRlZmluZWQpIHsgbWFrZU1haW4gPSBmYWxzZTsgfVxyXG5cclxuICAgIHZhciBjYW1lcmEgPSBudWxsO1xyXG5cclxuICAgIGlmICh0aGlzLmNhbWVyYVBvb2wubGVuZ3RoID4gMClcclxuICAgIHtcclxuICAgICAgICBjYW1lcmEgPSB0aGlzLmNhbWVyYVBvb2wucG9wKCk7XHJcblxyXG4gICAgICAgIGNhbWVyYS5zZXRWaWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBjYW1lcmEgPSBuZXcgQ2FtZXJhKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbWVyYS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcclxuXHJcbiAgICB0aGlzLmNhbWVyYXMucHVzaChjYW1lcmEpO1xyXG5cclxuICAgIGlmIChtYWtlTWFpbilcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1haW4gPSBjYW1lcmE7XHJcbiAgICB9XHJcblxyXG4gICAgY2FtZXJhLl9pZCA9IHRoaXMuY3VycmVudENhbWVyYUlkO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENhbWVyYUlkID0gdGhpcy5jdXJyZW50Q2FtZXJhSWQgPDwgMTtcclxuXHJcbiAgICByZXR1cm4gY2FtZXJhO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGQyRENhbWVyYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvbG9jYWwvaW5jL0FkZDJEQ2FtZXJhLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEFkZEV4aXN0aW5nID0gZnVuY3Rpb24gKGNhbWVyYSlcclxue1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5jYW1lcmFzLmluZGV4T2YoY2FtZXJhKTtcclxuICAgIHZhciBwb29sSW5kZXggPSB0aGlzLmNhbWVyYVBvb2wuaW5kZXhPZihjYW1lcmEpO1xyXG5cclxuICAgIGlmIChpbmRleCA8IDAgJiYgcG9vbEluZGV4ID49IDApXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jYW1lcmFzLnB1c2goY2FtZXJhKTtcclxuICAgICAgICB0aGlzLmNhbWVyYVBvb2wuc2xpY2UocG9vbEluZGV4LCAxKTtcclxuICAgICAgICByZXR1cm4gY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkRXhpc3Rpbmc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhL2xvY2FsL2luYy9BZGRFeGlzdGluZy5qc1xuLy8gbW9kdWxlIGlkID0gMzk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBLZXlDb250cm9sID0gcmVxdWlyZSgnLi4vLi4vY29udHJvbHMvS2V5Q29udHJvbCcpO1xyXG5cclxudmFyIEFkZEtleUNvbnRyb2wgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IEtleUNvbnRyb2woY29uZmlnKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkS2V5Q29udHJvbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvbG9jYWwvaW5jL0FkZEtleUNvbnRyb2wuanNcbi8vIG1vZHVsZSBpZCA9IDM5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT3J0aG9ncmFwaGljQ2FtZXJhID0gcmVxdWlyZSgnLi4vLi4vM2QvT3J0aG9ncmFwaGljQ2FtZXJhJyk7XHJcblxyXG52YXIgQWRkT3J0aG9ncmFwaGljQ2FtZXJhID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbntcclxuICAgIHZhciBjb25maWcgPSB0aGlzLnNjZW5lLnN5cy5nYW1lLmNvbmZpZztcclxuXHJcbiAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IGNvbmZpZy53aWR0aDsgfVxyXG4gICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7IH1cclxuXHJcbiAgICB2YXIgY2FtcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKHRoaXMuc2NlbmUsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIHJldHVybiBjYW1lcmE7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZE9ydGhvZ3JhcGhpY0NhbWVyYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvbG9jYWwvaW5jL0FkZE9ydGhvZ3JhcGhpY0NhbWVyYS5qc1xuLy8gbW9kdWxlIGlkID0gMzk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbW9vdGhlZEtleUNvbnRyb2wgPSByZXF1aXJlKCcuLi8uLi9jb250cm9scy9TbW9vdGhlZEtleUNvbnRyb2wnKTtcclxuXHJcbnZhciBBZGRTbW9vdGhlZEtleUNvbnRyb2wgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFNtb290aGVkS2V5Q29udHJvbChjb25maWcpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGRTbW9vdGhlZEtleUNvbnRyb2w7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhL2xvY2FsL2luYy9BZGRTbW9vdGhlZEtleUNvbnRyb2wuanNcbi8vIG1vZHVsZSBpZCA9IDM5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMubWFpbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2FtZXJhcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNhbWVyYXNbaV0uZGVzdHJveSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNhbWVyYVBvb2wubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jYW1lcmFQb29sW2ldLmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNhbWVyYXMgPSBbXTtcclxuICAgIHRoaXMuY2FtZXJhUG9vbCA9IFtdO1xyXG4gICAgdGhpcy5zY2VuZSA9IHVuZGVmaW5lZDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGVzdHJveTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW1lcmEvbG9jYWwvaW5jL0Rlc3Ryb3kuanNcbi8vIG1vZHVsZSBpZCA9IDQwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0RmFzdFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvb2JqZWN0L0dldEZhc3RWYWx1ZScpO1xyXG5cclxuLypcclxue1xyXG4gICAgY2FtZXJhczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogc3RyaW5nXHJcbiAgICAgICAgICAgIHg6IGludFxyXG4gICAgICAgICAgICB5OiBpbnRcclxuICAgICAgICAgICAgd2lkdGg6IGludFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGludFxyXG4gICAgICAgICAgICB6b29tOiBmbG9hdFxyXG4gICAgICAgICAgICByb3RhdGlvbjogZmxvYXRcclxuICAgICAgICAgICAgcm91bmRQaXhlbHM6IGJvb2xcclxuICAgICAgICAgICAgc2Nyb2xsWDogZmxvYXRcclxuICAgICAgICAgICAgc2Nyb2xsWTogZmxvYXRcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBzdHJpbmdcclxuICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICB4OiBpbnRcclxuICAgICAgICAgICAgICAgIHk6IGludFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGludFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIF1cclxufVxyXG4qL1xyXG5cclxudmFyIEZyb21KU09OID0gZnVuY3Rpb24gKGNvbmZpZylcclxue1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZykpXHJcbiAgICB7XHJcbiAgICAgICAgY29uZmlnID0gWyBjb25maWcgXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZ2FtZVdpZHRoID0gdGhpcy5zY2VuZS5zeXMuZ2FtZS5jb25maWcud2lkdGg7XHJcbiAgICB2YXIgZ2FtZUhlaWdodCA9IHRoaXMuc2NlbmUuc3lzLmdhbWUuY29uZmlnLmhlaWdodDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgY2FtZXJhQ29uZmlnID0gY29uZmlnW2ldO1xyXG5cclxuICAgICAgICB2YXIgeCA9IEdldEZhc3RWYWx1ZShjYW1lcmFDb25maWcsICd4JywgMCk7XHJcbiAgICAgICAgdmFyIHkgPSBHZXRGYXN0VmFsdWUoY2FtZXJhQ29uZmlnLCAneScsIDApO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IEdldEZhc3RWYWx1ZShjYW1lcmFDb25maWcsICd3aWR0aCcsIGdhbWVXaWR0aCk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IEdldEZhc3RWYWx1ZShjYW1lcmFDb25maWcsICdoZWlnaHQnLCBnYW1lSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMuYWRkKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICAvLyAgRGlyZWN0IHByb3BlcnRpZXNcclxuICAgICAgICBjYW1lcmEubmFtZSA9IEdldEZhc3RWYWx1ZShjYW1lcmFDb25maWcsICduYW1lJywgJycpO1xyXG4gICAgICAgIGNhbWVyYS56b29tID0gR2V0RmFzdFZhbHVlKGNhbWVyYUNvbmZpZywgJ3pvb20nLCAxKTtcclxuICAgICAgICBjYW1lcmEucm90YXRpb24gPSBHZXRGYXN0VmFsdWUoY2FtZXJhQ29uZmlnLCAncm90YXRpb24nLCAwKTtcclxuICAgICAgICBjYW1lcmEuc2Nyb2xsWCA9IEdldEZhc3RWYWx1ZShjYW1lcmFDb25maWcsICdzY3JvbGxYJywgMCk7XHJcbiAgICAgICAgY2FtZXJhLnNjcm9sbFkgPSBHZXRGYXN0VmFsdWUoY2FtZXJhQ29uZmlnLCAnc2Nyb2xsWScsIDApO1xyXG4gICAgICAgIGNhbWVyYS5yb3VuZFBpeGVscyA9IEdldEZhc3RWYWx1ZShjYW1lcmFDb25maWcsICdyb3VuZFBpeGVscycsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gQmFja2dyb3VuZCBDb2xvclxyXG5cclxuICAgICAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gR2V0RmFzdFZhbHVlKGNhbWVyYUNvbmZpZywgJ2JhY2tncm91bmRDb2xvcicsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgaWYgKGJhY2tncm91bmRDb2xvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbWVyYS5zZXRCYWNrZ3JvdW5kQ29sb3IoYmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBCb3VuZHNcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kc0NvbmZpZyA9IEdldEZhc3RWYWx1ZShjYW1lcmFDb25maWcsICdib3VuZHMnLCBudWxsKTtcclxuXHJcbiAgICAgICAgaWYgKGJvdW5kc0NvbmZpZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBieCA9IEdldEZhc3RWYWx1ZShib3VuZHNDb25maWcsICd4JywgMCk7XHJcbiAgICAgICAgICAgIHZhciBieSA9IEdldEZhc3RWYWx1ZShib3VuZHNDb25maWcsICd5JywgMCk7XHJcbiAgICAgICAgICAgIHZhciBid2lkdGggPSBHZXRGYXN0VmFsdWUoYm91bmRzQ29uZmlnLCAnd2lkdGgnLCBnYW1lV2lkdGgpO1xyXG4gICAgICAgICAgICB2YXIgYmhlaWdodCA9IEdldEZhc3RWYWx1ZShib3VuZHNDb25maWcsICdoZWlnaHQnLCBnYW1lSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGNhbWVyYS5zZXRCb3VuZHMoYngsIGJ5LCBid2lkdGgsIGJoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRnJvbUpTT047XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhL2xvY2FsL2luYy9Gcm9tSlNPTi5qc1xuLy8gbW9kdWxlIGlkID0gNDAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGVDb250YWlucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgR2V0Q2FtZXJhQmVsb3dQb2ludGVyID0gZnVuY3Rpb24gKHBvaW50ZXIpXHJcbntcclxuICAgIHZhciBjYW1lcmFzID0gdGhpcy5jYW1lcmFzO1xyXG5cclxuICAgIC8vICBTdGFydCBmcm9tIHRoZSBtb3N0IHJlY2VudGx5IGFkZGVkIGNhbWVyYSAodGhlICd0b3AnIGNhbWVyYSlcclxuICAgIGZvciAodmFyIGkgPSBjYW1lcmFzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjYW1lcmEgPSBjYW1lcmFzW2ldO1xyXG5cclxuICAgICAgICBpZiAoY2FtZXJhLmlucHV0RW5hYmxlZCAmJiBSZWN0YW5nbGVDb250YWlucyhjYW1lcmEsIHBvaW50ZXIueCwgcG9pbnRlci55KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYW1lcmE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRDYW1lcmFCZWxvd1BvaW50ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhL2xvY2FsL2luYy9HZXRDYW1lcmFCZWxvd1BvaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVtb3ZlQ2FtZXJhID0gZnVuY3Rpb24gKGNhbWVyYSlcclxue1xyXG4gICAgdmFyIGNhbWVyYUluZGV4ID0gdGhpcy5jYW1lcmFzLmluZGV4T2YoY2FtZXJhKTtcclxuXHJcbiAgICBpZiAoY2FtZXJhSW5kZXggPj0gMCAmJiB0aGlzLmNhbWVyYXMubGVuZ3RoID4gMSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNhbWVyYVBvb2wucHVzaCh0aGlzLmNhbWVyYXNbY2FtZXJhSW5kZXhdKTtcclxuICAgICAgICB0aGlzLmNhbWVyYXMuc3BsaWNlKGNhbWVyYUluZGV4LCAxKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubWFpbiA9PT0gY2FtZXJhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5tYWluID0gdGhpcy5jYW1lcmFzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlQ2FtZXJhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS9sb2NhbC9pbmMvUmVtb3ZlQ2FtZXJhLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgY2hpbGRyZW4sIGludGVycG9sYXRpb24pXHJcbntcclxuICAgIHZhciBjYW1lcmFzID0gdGhpcy5jYW1lcmFzO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FtZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNhbWVyYSA9IGNhbWVyYXNbaV07XHJcblxyXG4gICAgICAgIGNhbWVyYS5wcmVSZW5kZXIoKTtcclxuXHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIGNoaWxkcmVuLCBpbnRlcnBvbGF0aW9uLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhL2xvY2FsL2luYy9SZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVzZXRBbGwgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB3aGlsZSAodGhpcy5jYW1lcmFzLmxlbmd0aCA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jYW1lcmFQb29sLnB1c2godGhpcy5jYW1lcmFzLnBvcCgpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1haW4gPSB0aGlzLmFkZCgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm1haW47XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc2V0QWxsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS9sb2NhbC9pbmMvUmVzZXRBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDQwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVXBkYXRlID0gZnVuY3Rpb24gKHRpbWVzdGVwLCBkZWx0YSlcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmNhbWVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhc1tpXS51cGRhdGUodGltZXN0ZXAsIGRlbHRhKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXBkYXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS9sb2NhbC9pbmMvVXBkYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENIRUNLU1VNID0ge1xuICAgIGJ1aWxkOiAnMTJmNTI4NTAtOWZhYi0xMWU3LTg5MzYtNDkxYTlmN2NkOWZmJ1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ0hFQ0tTVU07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jaGVja3N1bS5qc1xuLy8gbW9kdWxlIGlkID0gNDA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcbmltcG9ydCBDYW52YXMgZnJvbSAnY2FudmFzL0NhbnZhcy5qcyc7XHJcbmltcG9ydCBHZXRDb250ZXh0IGZyb20gJ2NhbnZhcy9HZXRDb250ZXh0LmpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdyaWQgIChcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbnZhcyA9IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgd2lkdGggPSAyNTYsXHJcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoLFxyXG4gICAgICAgICAgICBjZWxsV2lkdGggPSAzMixcclxuICAgICAgICAgICAgY2VsbEhlaWdodCA9IGNlbGxXaWR0aCxcclxuICAgICAgICAgICAgY29sb3IxID0gJyNmZmYnLFxyXG4gICAgICAgICAgICBjb2xvcjIgPSAnIzAwMCcsXHJcbiAgICAgICAgICAgIGRyYXdMaW5lcyA9IGZhbHNlLFxyXG4gICAgICAgICAgICBsaW5lQ29sb3IgPSAnI2ZmMDAwMCcsXHJcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IHRydWUsXHJcbiAgICAgICAgICAgIHJlc2l6ZUNhbnZhcyA9IHRydWUsXHJcbiAgICAgICAgICAgIGNsZWFyID0gdHJ1ZSxcclxuICAgICAgICAgICAgcHJlUmVuZGVyID0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3N0UmVuZGVyID0gdW5kZWZpbmVkXHJcbiAgICAgICAgfSA9IHt9XHJcbiAgICApIHtcclxuXHJcbiAgICBpZiAoIWNhbnZhcylcclxuICAgIHtcclxuICAgICAgICBjYW52YXMgPSBDYW52YXMod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmVzaXplQ2FudmFzID0gZmFsc2U7XHJcbiAgICAgICAgY2xlYXIgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgVGhleSBwcm92aWRlZCBvd24gY2FudmFzLCBzbyB3ZSB1c2UgaXRzIGRpbWVuc2lvbnNcclxuICAgICAgICBpZiAoIXJlc2l6ZUNhbnZhcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgY3R4ID0gR2V0Q29udGV4dChjYW52YXMpO1xyXG5cclxuICAgIGlmIChyZXNpemVDYW52YXMpXHJcbiAgICB7XHJcbiAgICAgICAgUmVzaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNsZWFyKVxyXG4gICAge1xyXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRyYXdMaW5lcylcclxuICAgIHtcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIHByZVJlbmRlciBDYWxsYmFjaz9cclxuICAgIGlmIChwcmVSZW5kZXIpXHJcbiAgICB7XHJcbiAgICAgICAgcHJlUmVuZGVyKGNhbnZhcywgY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRHJhdyB0aGUgZ3JpZCBjZWxscyBmaXJzdCAodGhlIGxpbmVzIGdvIG9uIHRvcClcclxuXHJcbiAgICBsZXQgY3ggPSBNYXRoLmNlaWwod2lkdGggLyBjZWxsV2lkdGgpO1xyXG4gICAgbGV0IGN5ID0gTWF0aC5jZWlsKGhlaWdodCAvIGNlbGxIZWlnaHQpO1xyXG4gICAgbGV0IGMgPSAwO1xyXG4gICAgbGV0IGNvbG9yID0gY29sb3IxO1xyXG5cclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY3k7IHkrKylcclxuICAgIHtcclxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGN4OyB4KyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvcjE7XHJcbiAgICAgICAgICAgICAgICBjID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3IyO1xyXG4gICAgICAgICAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb2xvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHggKiBjZWxsV2lkdGgsIHkgKiBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZHJhd0xpbmVzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgKy0gMC41IGJlY2F1c2Ugd2UncmUgdXNpbmcgc3Ryb2tlLCBhbmQgd2lsbCBnZXQgYW50aS1hbGlhc2VkIGxpbmUgc3Ryb2tlcyB3aXRob3V0XHJcbiAgICAgICAgICAgICAgICBsZXQgb3ggPSAwLjU7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3kgPSAwLjU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGN4IC0gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBveCA9IC0wLjU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IGN5IC0gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBveSA9IC0wLjU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoKHggKiBjZWxsV2lkdGgpICsgb3gsICh5ICogY2VsbEhlaWdodCkgKyBveSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFsdGVybmF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyAgcG9zdFJlbmRlciBDYWxsYmFjaz9cclxuICAgIGlmIChwb3N0UmVuZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHBvc3RSZW5kZXIoY2FudmFzLCBjdHgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYW52YXM7XHJcblxyXG59XHJcbiovXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY3JlYXRlL0dyaWQuanNcbi8vIG1vZHVsZSBpZCA9IDQwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBBIDE2IGNvbG9yIEM2NCBpbnNwaXJlZCBwYWxldHRlLlxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAwOiAnIzAwMCcsXHJcbiAgICAxOiAnI2ZmZicsXHJcbiAgICAyOiAnIzhiNDEzMScsXHJcbiAgICAzOiAnIzdiYmRjNScsXHJcbiAgICA0OiAnIzhiNDFhYycsXHJcbiAgICA1OiAnIzZhYWM0MScsXHJcbiAgICA2OiAnIzM5MzFhNCcsXHJcbiAgICA3OiAnI2Q1ZGU3MycsXHJcbiAgICA4OiAnIzk0NWEyMCcsXHJcbiAgICA5OiAnIzVhNDEwMCcsXHJcbiAgICBBOiAnI2JkNzM2YScsXHJcbiAgICBCOiAnIzUyNTI1MicsXHJcbiAgICBDOiAnIzgzODM4MycsXHJcbiAgICBEOiAnI2FjZWU4YicsXHJcbiAgICBFOiAnIzdiNzNkZScsXHJcbiAgICBGOiAnI2FjYWNhYydcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jcmVhdGUvcGFsZXR0ZXMvQzY0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQSAxNiBjb2xvciBDR0EgaW5zcGlyZWQgcGFsZXR0ZSBieSBbQXJuZV0oaHR0cDovL2FuZHJvaWRhcnRzLmNvbS9wYWxldHRlLzE2cGFsLmh0bSlcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgMDogJyMwMDAnLFxyXG4gICAgMTogJyMyMjM0ZDEnLFxyXG4gICAgMjogJyMwYzdlNDUnLFxyXG4gICAgMzogJyM0NGFhY2MnLFxyXG4gICAgNDogJyM4YTM2MjInLFxyXG4gICAgNTogJyM1YzJlNzgnLFxyXG4gICAgNjogJyNhYTVjM2QnLFxyXG4gICAgNzogJyNiNWI1YjUnLFxyXG4gICAgODogJyM1ZTYwNmUnLFxyXG4gICAgOTogJyM0YzgxZmInLFxyXG4gICAgQTogJyM2Y2Q5NDcnLFxyXG4gICAgQjogJyM3YmUyZjknLFxyXG4gICAgQzogJyNlYjhhNjAnLFxyXG4gICAgRDogJyNlMjNkNjknLFxyXG4gICAgRTogJyNmZmQ5M2YnLFxyXG4gICAgRjogJyNmZmYnXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY3JlYXRlL3BhbGV0dGVzL0NHQS5qc1xuLy8gbW9kdWxlIGlkID0gNDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEEgMTYgY29sb3IgSk1QIHBhbGV0dGUgYnkgW0FybmVdKGh0dHA6Ly9hbmRyb2lkYXJ0cy5jb20vcGFsZXR0ZS8xNnBhbC5odG0pXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIDA6ICcjMDAwJyxcclxuICAgIDE6ICcjMTkxMDI4JyxcclxuICAgIDI6ICcjNDZhZjQ1JyxcclxuICAgIDM6ICcjYTFkNjg1JyxcclxuICAgIDQ6ICcjNDUzZTc4JyxcclxuICAgIDU6ICcjNzY2NGZlJyxcclxuICAgIDY6ICcjODMzMTI5JyxcclxuICAgIDc6ICcjOWVjMmU4JyxcclxuICAgIDg6ICcjZGM1MzRiJyxcclxuICAgIDk6ICcjZTE4ZDc5JyxcclxuICAgIEE6ICcjZDZiOTdiJyxcclxuICAgIEI6ICcjZTlkOGExJyxcclxuICAgIEM6ICcjMjE2YzRiJyxcclxuICAgIEQ6ICcjZDM2NWM4JyxcclxuICAgIEU6ICcjYWZhYWI5JyxcclxuICAgIEY6ICcjZjVmNGViJ1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NyZWF0ZS9wYWxldHRlcy9KTVAuanNcbi8vIG1vZHVsZSBpZCA9IDQxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBBIDE2IGNvbG9yIHBhbGV0dGUgaW5zcGlyZWQgYnkgSmFwYW5lc2UgY29tcHV0ZXJzIGxpa2UgdGhlIE1TWC5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgMDogJyMwMDAnLFxyXG4gICAgMTogJyMxOTEwMjgnLFxyXG4gICAgMjogJyM0NmFmNDUnLFxyXG4gICAgMzogJyNhMWQ2ODUnLFxyXG4gICAgNDogJyM0NTNlNzgnLFxyXG4gICAgNTogJyM3NjY0ZmUnLFxyXG4gICAgNjogJyM4MzMxMjknLFxyXG4gICAgNzogJyM5ZWMyZTgnLFxyXG4gICAgODogJyNkYzUzNGInLFxyXG4gICAgOTogJyNlMThkNzknLFxyXG4gICAgQTogJyNkNmI5N2InLFxyXG4gICAgQjogJyNlOWQ4YTEnLFxyXG4gICAgQzogJyMyMTZjNGInLFxyXG4gICAgRDogJyNkMzY1YzgnLFxyXG4gICAgRTogJyNhZmFhYjknLFxyXG4gICAgRjogJyNmZmYnXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY3JlYXRlL3BhbGV0dGVzL01TWC5qc1xuLy8gbW9kdWxlIGlkID0gNDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEFSTkUxNjogcmVxdWlyZSgnLi9Bcm5lMTYnKSxcclxuICAgIEM2NDogcmVxdWlyZSgnLi9DNjQnKSxcclxuICAgIENHQTogcmVxdWlyZSgnLi9DR0EnKSxcclxuICAgIEpNUDogcmVxdWlyZSgnLi9KTVAnKSxcclxuICAgIE1TWDogcmVxdWlyZSgnLi9NU1gnKVxyXG4gICAgXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY3JlYXRlL3BhbGV0dGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcclxuXHJcbnZhciBBdWRpbyA9IHtcclxuXHJcbiAgICAvLyBAcHJvcGVydHkge2Jvb2xlYW59IGF1ZGlvRGF0YSAtIEFyZSBBdWRpbyB0YWdzIGF2YWlsYWJsZT9cclxuICAgIGF1ZGlvRGF0YTogZmFsc2UsXHJcblxyXG4gICAgLy8gQHByb3BlcnR5IHtib29sZWFufSB3ZWJBdWRpbyAtIElzIHRoZSBXZWJBdWRpbyBBUEkgYXZhaWxhYmxlP1xyXG4gICAgd2ViQXVkaW86IGZhbHNlLFxyXG5cclxuICAgIC8vIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2dnIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgb2dnIGZpbGVzP1xyXG4gICAgb2dnOiBmYWxzZSxcclxuXHJcbiAgICAvLyBAcHJvcGVydHkge2Jvb2xlYW59IG9wdXMgLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBvcHVzIGZpbGVzP1xyXG4gICAgb3B1czogZmFsc2UsXHJcblxyXG4gICAgLy8gQHByb3BlcnR5IHtib29sZWFufSBtcDMgLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBtcDMgZmlsZXM/XHJcbiAgICBtcDM6IGZhbHNlLFxyXG5cclxuICAgIC8vIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2F2IC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgd2F2IGZpbGVzP1xyXG4gICAgd2F2OiBmYWxzZSxcclxuXHJcbiAgICAvLyBDYW4gdGhpcyBkZXZpY2UgcGxheSBtNGEgZmlsZXM/XHJcbiAgICAvLyBAcHJvcGVydHkge2Jvb2xlYW59IG00YSAtIFRydWUgaWYgdGhpcyBkZXZpY2UgY2FuIHBsYXkgbTRhIGZpbGVzLlxyXG4gICAgbTRhOiBmYWxzZSxcclxuXHJcbiAgICAvLyBAcHJvcGVydHkge2Jvb2xlYW59IHdlYm0gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSB3ZWJtIGZpbGVzP1xyXG4gICAgd2VibTogZmFsc2UsXHJcblxyXG4gICAgLy8gQHByb3BlcnR5IHtib29sZWFufSBkb2xieSAtIENhbiB0aGlzIGRldmljZSBwbGF5IEVDLTMgRG9sYnkgRGlnaXRhbCBQbHVzIGZpbGVzP1xyXG4gICAgZG9sYnk6IGZhbHNlXHJcblxyXG59O1xyXG5cclxuZnVuY3Rpb24gaW5pdCAoKVxyXG57XHJcbiAgICBBdWRpby5hdWRpb0RhdGEgPSAhISh3aW5kb3dbJ0F1ZGlvJ10pO1xyXG4gICAgQXVkaW8ud2ViQXVkaW8gPSAhISh3aW5kb3dbJ0F1ZGlvQ29udGV4dCddIHx8IHdpbmRvd1snd2Via2l0QXVkaW9Db250ZXh0J10pO1xyXG5cclxuICAgIHZhciBhdWRpb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSAhIWF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZTtcclxuXHJcbiAgICB0cnlcclxuICAgIHtcclxuICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF1ZGlvLm9nZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwib3B1c1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSB8fCBhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL29wdXM7JykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXVkaW8ub3B1cyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWc7JykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXVkaW8ubXAzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIE1pbWV0eXBlcyBhY2NlcHRlZDpcclxuICAgICAgICAgICAgLy8gIGRldmVsb3Blci5tb3ppbGxhLm9yZy9Fbi9NZWRpYV9mb3JtYXRzX3N1cHBvcnRlZF9ieV90aGVfYXVkaW9fYW5kX3ZpZGVvX2VsZW1lbnRzXHJcbiAgICAgICAgICAgIC8vICBiaXQubHkvaXBob25lb3Njb2RlY3NcclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vd2F2OyBjb2RlY3M9XCIxXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdWRpby53YXYgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby94LW00YTsnKSB8fCBhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdWRpby5tNGEgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF1ZGlvLndlYm0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9tcDQ7Y29kZWNzPVwiZWMtM1wiJykgIT09ICcnKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQnJvd3Nlci5lZGdlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEF1ZGlvLmRvbGJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJyb3dzZXIuc2FmYXJpICYmIEJyb3dzZXIuc2FmYXJpVmVyc2lvbiA+PSA5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoL01hYyBPUyBYIChcXGQrKV8oXFxkKykvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ham9yID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5vciA9IHBhcnNlSW50KFJlZ0V4cC4kMiwgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYWpvciA9PT0gMTAgJiYgbWlub3IgPj0gMTEpIHx8IG1ham9yID4gMTApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1ZGlvLmRvbGJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBOb3RoaW5nIHRvIGRvIGhlcmVcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQXVkaW87XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RldmljZS9BdWRpby5qc1xuLy8gbW9kdWxlIGlkID0gNDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGdWxsc2NyZWVuID0ge1xyXG5cclxuICAgIC8vICBAcHJvcGVydHkge2Jvb2xlYW59IGF2YWlsYWJsZSAtIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCB0aGUgRnVsbCBTY3JlZW4gQVBJP1xyXG4gICAgYXZhaWxhYmxlOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtzdHJpbmd9IHJlcXVlc3QgLSBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgRnVsbCBTY3JlZW4gQVBJIHRoaXMgaG9sZHMgdGhlIGNhbGwgeW91IG5lZWQgdG8gdXNlIHRvIGFjdGl2YXRlIGl0LlxyXG4gICAgcmVxdWVzdDogJycsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7c3RyaW5nfSBjYW5jZWwgLSBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgRnVsbCBTY3JlZW4gQVBJIHRoaXMgaG9sZHMgdGhlIGNhbGwgeW91IG5lZWQgdG8gdXNlIHRvIGNhbmNlbCBpdC5cclxuICAgIGNhbmNlbDogJycsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0ga2V5Ym9hcmQgLSBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgYWNjZXNzIHRvIHRoZSBLZXlib2FyZCBkdXJpbmcgRnVsbCBTY3JlZW4gbW9kZT9cclxuICAgIGtleWJvYXJkOiBmYWxzZVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4qIENoZWNrcyBmb3Igc3VwcG9ydCBvZiB0aGUgRnVsbCBTY3JlZW4gQVBJLlxyXG4qL1xyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIHZhciBpO1xyXG5cclxuICAgIHZhciBmcyA9IFtcclxuICAgICAgICAncmVxdWVzdEZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICdyZXF1ZXN0RnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJyxcclxuICAgICAgICAnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICdtc1JlcXVlc3RGdWxsc2NyZWVuJyxcclxuICAgICAgICAnbXNSZXF1ZXN0RnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ21velJlcXVlc3RGdWxsU2NyZWVuJyxcclxuICAgICAgICAnbW96UmVxdWVzdEZ1bGxzY3JlZW4nXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGZzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChlbGVtZW50W2ZzW2ldXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZ1bGxzY3JlZW4uYXZhaWxhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgRnVsbHNjcmVlbi5yZXF1ZXN0ID0gZnNbaV07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2ZzID0gW1xyXG4gICAgICAgICdjYW5jZWxGdWxsU2NyZWVuJyxcclxuICAgICAgICAnZXhpdEZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICd3ZWJraXRDYW5jZWxGdWxsU2NyZWVuJyxcclxuICAgICAgICAnd2Via2l0RXhpdEZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICdtc0NhbmNlbEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICdtc0V4aXRGdWxsc2NyZWVuJyxcclxuICAgICAgICAnbW96Q2FuY2VsRnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ21vekV4aXRGdWxsc2NyZWVuJ1xyXG4gICAgXTtcclxuXHJcbiAgICBpZiAoRnVsbHNjcmVlbi5hdmFpbGFibGUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNmcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudFtjZnNbaV1dKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGdWxsc2NyZWVuLmNhbmNlbCA9IGNmc1tpXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBLZXlib2FyZCBJbnB1dD9cclxuICAgIGlmICh3aW5kb3dbJ0VsZW1lbnQnXSAmJiBFbGVtZW50WydBTExPV19LRVlCT0FSRF9JTlBVVCddKVxyXG4gICAge1xyXG4gICAgICAgIEZ1bGxzY3JlZW4ua2V5Ym9hcmQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBGdWxsc2NyZWVuO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kZXZpY2UvRnVsbHNjcmVlbi5qc1xuLy8gbW9kdWxlIGlkID0gNDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcclxudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcclxuXHJcbnZhciBJbnB1dCA9IHtcclxuXHJcbiAgICAvLyBAcHJvcGVydHkge2Jvb2xlYW59IHRvdWNoIC0gSXMgdG91Y2ggYXZhaWxhYmxlP1xyXG4gICAgdG91Y2g6IGZhbHNlLFxyXG5cclxuICAgIC8vIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXNwb2ludGVyIC0gSXMgbXNwb2ludGVyIGF2YWlsYWJsZT9cclxuICAgIG1zcG9pbnRlcjogZmFsc2UsXHJcblxyXG4gICAgLy8gQHByb3BlcnR5IHs/c3RyaW5nfSB3aGVlbFR5cGUgLSBUaGUgbmV3ZXN0IHR5cGUgb2YgV2hlZWwvU2Nyb2xsIGV2ZW50IHN1cHBvcnRlZDogJ3doZWVsJywgJ21vdXNld2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnXHJcbiAgICB3aGVlbEV2ZW50OiBudWxsLFxyXG5cclxuICAgIC8vIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZ2FtZXBhZHMgLSBJcyBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMgYXZhaWxhYmxlP1xyXG4gICAgZ2FtZXBhZHM6IGZhbHNlXHJcbiAgICBcclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCAobmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+PSAxKSlcclxuICAgIHtcclxuICAgICAgICBJbnB1dC50b3VjaCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZClcclxuICAgIHtcclxuICAgICAgICBJbnB1dC5tc3BvaW50ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMpXHJcbiAgICB7XHJcbiAgICAgICAgSW5wdXQuZ2FtZXBhZHMgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghT1MuY29jb29uSlMpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy93aGVlbFxyXG4gICAgICAgIGlmICgnb253aGVlbCcgaW4gd2luZG93IHx8IChCcm93c2VyLmllICYmICdXaGVlbEV2ZW50JyBpbiB3aW5kb3cpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRE9NMyBXaGVlbCBFdmVudDogRkYgMTcrLCBJRSA5KywgQ2hyb21lIDMxKywgU2FmYXJpIDcrXHJcbiAgICAgICAgICAgIElucHV0LndoZWVsRXZlbnQgPSAnd2hlZWwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnb25tb3VzZXdoZWVsJyBpbiB3aW5kb3cpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBOb24tRkYgbGVnYWN5OiBJRSA2LTksIENocm9tZSAxLTMxLCBTYWZhcmkgNS03LlxyXG4gICAgICAgICAgICBJbnB1dC53aGVlbEV2ZW50ID0gJ21vdXNld2hlZWwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChCcm93c2VyLmZpcmVmb3ggJiYgJ01vdXNlU2Nyb2xsRXZlbnQnIGluIHdpbmRvdylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIEZGIHByaW9yIHRvIDE3LiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBzY3J1YmJlZC5cclxuICAgICAgICAgICAgSW5wdXQud2hlZWxFdmVudCA9ICdET01Nb3VzZVNjcm9sbCc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBJbnB1dDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGV2aWNlL0lucHV0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBWaWRlbyA9IHtcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBvZ2dWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IG9nZyB2aWRlbyBmaWxlcz9cclxuICAgIG9nZ1ZpZGVvOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBoMjY0VmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBoMjY0IG1wNCB2aWRlbyBmaWxlcz9cclxuICAgIGgyNjRWaWRlbzogZmFsc2UsXHJcblxyXG4gICAgLy8gIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXA0VmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBoMjY0IG1wNCB2aWRlbyBmaWxlcz9cclxuICAgIG1wNFZpZGVvOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSB3ZWJtVmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSB3ZWJtIHZpZGVvIGZpbGVzP1xyXG4gICAgd2VibVZpZGVvOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSB2cDlWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IHZwOSB2aWRlbyBmaWxlcz9cclxuICAgIHZwOVZpZGVvOiBmYWxzZSxcclxuXHJcbiAgICAvLyAgQHByb3BlcnR5IHtib29sZWFufSBobHNWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IGhscyB2aWRlbyBmaWxlcz9cclxuICAgIGhsc1ZpZGVvOiBmYWxzZVxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgdmFyIHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XHJcbiAgICB2YXIgcmVzdWx0ID0gISF2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGU7XHJcblxyXG4gICAgdHJ5XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGUoJ3ZpZGVvL29nZzsgY29kZWNzPVwidGhlb3JhXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWaWRlby5vZ2dWaWRlbyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGUoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUVcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFdpdGhvdXQgUXVpY2tUaW1lLCB0aGlzIHZhbHVlIHdpbGwgYmUgYHVuZGVmaW5lZGAuIGdpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9pc3N1ZXMvNTQ2XHJcbiAgICAgICAgICAgICAgICBWaWRlby5oMjY0VmlkZW8gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgVmlkZW8ubXA0VmlkZW8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby93ZWJtOyBjb2RlY3M9XCJ2cDgsIHZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmlkZW8ud2VibVZpZGVvID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5jYW5QbGF5VHlwZSgndmlkZW8vd2VibTsgY29kZWNzPVwidnA5XCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWaWRlby52cDlWaWRlbyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2FwcGxpY2F0aW9uL3gtbXBlZ1VSTDsgY29kZWNzPVwiYXZjMS40MkUwMUVcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZpZGVvLmhsc1ZpZGVvID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBOb3RoaW5nIHRvIGRvXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFZpZGVvO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kZXZpY2UvVmlkZW8uanNcbi8vIG1vZHVsZSBpZCA9IDQxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgVGhpcyBzaW5nbGV0b24gaXMgaW5zdGFudGlhdGVkIGFzIHNvb24gYXMgUGhhc2VyIGxvYWRzLFxyXG4vLyAgYmVmb3JlIGEgUGhhc2VyLkdhbWUgaW5zdGFuY2UgaGFzIGV2ZW4gYmVlbiBjcmVhdGVkLlxyXG4vLyAgV2hpY2ggbWVhbnMgYWxsIGluc3RhbmNlcyBvZiBQaGFzZXIgR2FtZXMgY2FuIHNoYXJlIGl0LFxyXG4vLyAgd2l0aG91dCBoYXZpbmcgdG8gcmUtcG9sbCB0aGUgZGV2aWNlIGFsbCBvdmVyIGFnYWluXHJcblxyXG52YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcbnZhciBGZWF0dXJlcyA9IHJlcXVpcmUoJy4vRmVhdHVyZXMnKTtcclxudmFyIElucHV0ID0gcmVxdWlyZSgnLi9JbnB1dCcpO1xyXG52YXIgQXVkaW8gPSByZXF1aXJlKCcuL0F1ZGlvJyk7XHJcbnZhciBWaWRlbyA9IHJlcXVpcmUoJy4vVmlkZW8nKTtcclxudmFyIEZ1bGxzY3JlZW4gPSByZXF1aXJlKCcuL0Z1bGxzY3JlZW4nKTtcclxudmFyIENhbnZhc0ZlYXR1cmVzID0gcmVxdWlyZSgnLi9DYW52YXNGZWF0dXJlcycpO1xyXG5cclxuLy8gIFBoYXNlci5EZXZpY2VcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE9TOiBPUyxcclxuICAgIEJyb3dzZXI6IEJyb3dzZXIsXHJcbiAgICBGZWF0dXJlczogRmVhdHVyZXMsXHJcbiAgICBJbnB1dDogSW5wdXQsXHJcbiAgICBBdWRpbzogQXVkaW8sXHJcbiAgICBWaWRlbzogVmlkZW8sXHJcbiAgICBGdWxsc2NyZWVuOiBGdWxsc2NyZWVuLFxyXG4gICAgQ2FudmFzRmVhdHVyZXM6IENhbnZhc0ZlYXR1cmVzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RldmljZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKVxyXG57XHJcbiAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKSB7IHVzZUNhcHR1cmUgPSBmYWxzZTsgfVxyXG5cclxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZEV2ZW50TGlzdGVuZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9tL0FkZEV2ZW50TGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcilcclxue1xyXG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vUmVtb3ZlRXZlbnRMaXN0ZW5lci5qc1xuLy8gbW9kdWxlIGlkID0gNDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZW1vdmVGcm9tRE9NID0gZnVuY3Rpb24gKGVsZW1lbnQpXHJcbntcclxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVGcm9tRE9NO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RvbS9SZW1vdmVGcm9tRE9NLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU2V0cyB0aGUgdG91Y2gtYWN0aW9uIHByb3BlcnR5IG9uIHRoZSBjYW52YXMgc3R5bGUuIENhbiBiZSB1c2VkIHRvIGRpc2FibGUgZGVmYXVsdCBicm93c2VyIHRvdWNoIGFjdGlvbnMuXHJcbiovXHJcbnZhciBUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIChjYW52YXMsIHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgeyB2YWx1ZSA9ICdub25lJzsgfVxyXG5cclxuICAgIGNhbnZhcy5zdHlsZVsnbXNUb3VjaEFjdGlvbiddID0gdmFsdWU7XHJcbiAgICBjYW52YXMuc3R5bGVbJ21zLXRvdWNoLWFjdGlvbiddID0gdmFsdWU7XHJcbiAgICBjYW52YXMuc3R5bGVbJ3RvdWNoLWFjdGlvbiddID0gdmFsdWU7XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG91Y2hBY3Rpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9tL1RvdWNoQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU2V0cyB0aGUgdXNlci1zZWxlY3QgcHJvcGVydHkgb24gdGhlIGNhbnZhcyBzdHlsZS4gQ2FuIGJlIHVzZWQgdG8gZGlzYWJsZSBkZWZhdWx0IGJyb3dzZXIgc2VsZWN0aW9uIGFjdGlvbnMuXHJcbiovXHJcbnZhciBVc2VyU2VsZWN0ID0gZnVuY3Rpb24gKGNhbnZhcywgdmFsdWUpXHJcbntcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IHZhbHVlID0gJ25vbmUnOyB9XHJcblxyXG4gICAgdmFyIHZlbmRvcnMgPSBbXHJcbiAgICAgICAgJy13ZWJraXQtJyxcclxuICAgICAgICAnLWtodG1sLScsXHJcbiAgICAgICAgJy1tb3otJyxcclxuICAgICAgICAnLW1zLScsXHJcbiAgICAgICAgJydcclxuICAgIF07XHJcblxyXG4gICAgdmVuZG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2ZW5kb3IpXHJcbiAgICB7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlW3ZlbmRvciArICd1c2VyLXNlbGVjdCddID0gdmFsdWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjYW52YXMuc3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gdmFsdWU7XHJcbiAgICBjYW52YXMuc3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3JnYmEoMCwgMCwgMCwgMCknO1xyXG5cclxuICAgIHJldHVybiBjYW52YXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXJTZWxlY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9tL1VzZXJTZWxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDQyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi9FdmVudExpc3RlbmVyJyk7XHJcblxyXG52YXIgRXZlbnRCaW5kaW5nID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEV2ZW50QmluZGluZyAoZGlzcGF0Y2hlciwgdHlwZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfSURMRTtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IFtdO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b3RhbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgdG90YWwgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLnN0YXRlICE9PSBDT05TVC5MSVNURU5FUl9SRU1PVklORylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdG90YWwrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjaylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhczogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5nZXQoY2FsbGJhY2spKTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHByaW9yaXR5LCBvbmNlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuZ2V0KGNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgaWYgKCFsaXN0ZW5lcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGUgbGlzdGVuZXIgZG9lc24ndCBleGlzdCwgc28gY3JlYXRlIG9uZVxyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IEV2ZW50TGlzdGVuZXIodGhpcy50eXBlLCBjYWxsYmFjaywgcHJpb3JpdHksIG9uY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgTGlzdGVuZXIgYWxyZWFkeSBleGlzdHMsIGFib3J0XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVGhlIERpc3BhdGNoZXIgaXNuJ3QgZG9pbmcgYW55dGhpbmcsIHNvIHdlIGRvbid0IG5lZWQgYSBwZW5kaW5nIHN0YXRlXHJcbiAgICAgICAgICAgIGxpc3RlbmVyLnN0YXRlID0gQ09OU1QuTElTVEVORVJfQUNUSVZFO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUucHVzaChsaXN0ZW5lcik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zb3J0KHRoaXMuc29ydEhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0RJU1BBVENISU5HKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEFkZCBpdCB0byB0aGUgbGlzdCwgYnV0IGtlZXAgdGhlIHN0YXRlIGFzIHBlbmRpbmcuXHJcbiAgICAgICAgICAgIC8vICBUaGUgY2FsbCB0byAndGlkeScgd2lsbCBzb3J0IGl0IG91dCBhdCB0aGUgZW5kIG9mIHRoZSBkaXNwYXRjaC5cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzb3J0SGFuZGxlcjogZnVuY3Rpb24gKGxpc3RlbmVyQSwgbGlzdGVuZXJCKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChsaXN0ZW5lckIucHJpb3JpdHkgPCBsaXN0ZW5lckEucHJpb3JpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxpc3RlbmVyQi5wcmlvcml0eSA+IGxpc3RlbmVyQS5wcmlvcml0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVGhlIERpc3BhdGNoZXIgaXNuJ3QgZG9pbmcgYW55dGhpbmcsIHNvIHdlIGNhbiByZW1vdmUgcmlnaHQgYXdheVxyXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0SW5kZXgoY2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgaWYgKGkgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0RJU1BBVENISU5HKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRoZSBEaXNwYXRjaGVyIGlzIHdvcmtpbmcsIHNvIHdlIGZsYWcgdGhlIGxpc3RlbmVyIGZvciByZW1vdmFsIGF0IHRoZSBlbmRcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5nZXQoY2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5zdGF0ZSA9IENPTlNULkxJU1RFTkVSX1JFTU9WSU5HO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yOiBGYWlsZWQgdG8gZXhlY3V0ZSBcXCdFdmVudERpc3BhdGNoZXIuZGlzcGF0Y2hcXCcgb24gXFwnJyArIHRoaXMudHlwZSArICdcXCc6IFRoZSBldmVudCBpcyBhbHJlYWR5IGJlaW5nIGRpc3BhdGNoZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGlzIHdhcyBhIHZhbGlkIGRpc3BhdGNoIGNhbGwsIHdlIGp1c3QgaGFkIG5vdGhpbmcgdG8gZG8gLi4uXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5ESVNQQVRDSEVSX0RJU1BBVENISU5HO1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXI7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMuYWN0aXZlW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnN0YXRlICE9PSBDT05TVC5MSVNURU5FUl9BQ1RJVkUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMuZGlzcGF0Y2hlciwgZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gIEhhcyB0aGUgY2FsbGJhY2sgY2hhbmdlZCB0aGUgc3RhdGUgb2YgdGhpcyBiaW5kaW5nP1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFl1cCEgTGV0J3MgYnJlYWsgb3V0XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIFdhcyBpdCBhICdvbmNlJyBsaXN0ZW5lcj9cclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9uY2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnN0YXRlID0gQ09OU1QuTElTVEVORVJfUkVNT1ZJTkc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vICBIYXMgdGhlIGV2ZW50IGJlZW4gaGFsdGVkIGJ5IHRoZSBjYWxsYmFjaz9cclxuICAgICAgICAgICAgaWYgKCFldmVudC5fcHJvcGFnYXRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgQnJlYWsgb3V0LCBhIGxpc3RlbmVyIGhhcyBjYWxsZWQgRXZlbnQuc3RvcFByb3BhZ2F0aW9uXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIERpc3BhdGNoIG92ZXIsIG9yIGFib3J0ZWRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9SRU1PVklORylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsKCk7XHJcblxyXG4gICAgICAgICAgICAvLyAgQWxsIGRvbmUsIHRpZHkgdGhlIGxpc3QgaW4gY2FzZSB0aGVyZSB3ZXJlIGFueSBwZW5kaW5nIGV2ZW50cyBhZGRlZFxyXG4gICAgICAgICAgICB0aGlzLnRpZHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9ERVNUUk9ZRUQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIuZGVsZXRlKHRoaXMudHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBBbGwgZG9uZSwganVzdCBwdXJnZSB0aGUgbGlzdFxyXG4gICAgICAgICAgICB0aGlzLnRpZHkoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5ESVNQQVRDSEVSX0lETEU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUmVtb3ZlcyBhbGwgbGlzdGVuZXJzXHJcbiAgICAvLyAgSWYgdGhpcyBpcyBjdXJyZW50bHkgYmVpbmcgZGlzcGF0Y2hlZCB0aGVuIGRvbid0IHJlbW92ZSAncGVuZGluZycgbGlzdGVuZXJzXHJcbiAgICAvLyAgKGkuZS4gb25lcyB0aGF0IHdlcmUgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaCksIG9ubHkgYWN0aXZlIG9uZXNcclxuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9JRExFKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgIT09IENPTlNULkxJU1RFTkVSX1BFTkRJTkcpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5ESVNQQVRDSEVSX0lETEU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB0aWR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBOb3RoaW5nIHRvIGRvIC4uLlxyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGggPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYWRkZWQgPSAwO1xyXG5cclxuICAgICAgICB2YXIgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgIGRvXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IENPTlNULkxJU1RFTkVSX1JFTU9WSU5HKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IENPTlNULkxJU1RFTkVSX1BFTkRJTkcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlW2ldLnN0YXRlID09PSBDT05TVC5MSVNURU5FUl9BQ1RJVkU7XHJcbiAgICAgICAgICAgICAgICBhZGRlZCsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpID49IDApO1xyXG5cclxuICAgICAgICBpZiAoYWRkZWQgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUuc29ydCh0aGlzLnNvcnRIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJyc7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfREVTVFJPWUVEO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50QmluZGluZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ldmVudHMvRXZlbnRCaW5kaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2ssIHByaW9yaXR5LCBvbmNlKVxyXG57XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxyXG4gICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcclxuICAgICAgICBvbmNlOiBvbmNlLFxyXG4gICAgICAgIHN0YXRlOiBDT05TVC5MSVNURU5FUl9QRU5ESU5HXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2V2ZW50cy9FdmVudExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhcnNlWE1MQml0bWFwRm9udCA9IHJlcXVpcmUoJy4vUGFyc2VYTUxCaXRtYXBGb250Jyk7XHJcblxyXG52YXIgUGFyc2VGcm9tQXRsYXMgPSBmdW5jdGlvbiAoc2NlbmUsIGZvbnROYW1lLCB0ZXh0dXJlS2V5LCBmcmFtZUtleSwgeG1sS2V5LCB4U3BhY2luZywgeVNwYWNpbmcpXHJcbntcclxuICAgIHZhciBmcmFtZSA9IHNjZW5lLnN5cy50ZXh0dXJlcy5nZXRGcmFtZSh0ZXh0dXJlS2V5LCBmcmFtZUtleSk7XHJcbiAgICB2YXIgeG1sID0gc2NlbmUuc3lzLmNhY2hlLnhtbC5nZXQoeG1sS2V5KTtcclxuXHJcbiAgICBpZiAoZnJhbWUgJiYgeG1sKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gUGFyc2VYTUxCaXRtYXBGb250KHhtbCwgeFNwYWNpbmcsIHlTcGFjaW5nLCBmcmFtZSk7XHJcblxyXG4gICAgICAgIHNjZW5lLnN5cy5jYWNoZS5iaXRtYXBGb250LmFkZChmb250TmFtZSwgeyBkYXRhOiBkYXRhLCB0ZXh0dXJlOiB0ZXh0dXJlS2V5LCBmcmFtZTogZnJhbWVLZXkgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFyc2VGcm9tQXRsYXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9QYXJzZUZyb21BdGxhcy5qc1xuLy8gbW9kdWxlIGlkID0gNDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG5cclxuLy8gKiBAcGFyYW0ge251bWJlcn0gY2hhcmFjdGVyV2lkdGggLSBUaGUgd2lkdGggb2YgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGZvbnQgc2V0LlxyXG4vLyAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyYWN0ZXJIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBmb250IHNldC5cclxuLy8gKiBAcGFyYW0ge3N0cmluZ30gY2hhcnMgLSBUaGUgY2hhcmFjdGVycyB1c2VkIGluIHRoZSBmb250IHNldCwgaW4gZGlzcGxheSBvcmRlci4gWW91IGNhbiB1c2UgdGhlIFRFWFRfU0VUIGNvbnN0cyBmb3IgY29tbW9uIGZvbnQgc2V0IGFycmFuZ2VtZW50cy5cclxuLy8gKiBAcGFyYW0ge251bWJlcn0gW2NoYXJzUGVyUm93XSAtIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBwZXIgcm93IGluIHRoZSBmb250IHNldC4gSWYgbm90IGdpdmVuIGNoYXJzUGVyUm93IHdpbGwgYmUgdGhlIGltYWdlIHdpZHRoIC8gY2hhcmFjdGVyV2lkdGguXHJcbi8vICogQHBhcmFtIHtudW1iZXJ9IFt4U3BhY2luZz0wXSAtIElmIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBmb250IHNldCBoYXZlIGhvcml6b250YWwgc3BhY2luZyBiZXR3ZWVuIHRoZW0gc2V0IHRoZSByZXF1aXJlZCBhbW91bnQgaGVyZS5cclxuLy8gKiBAcGFyYW0ge251bWJlcn0gW3lTcGFjaW5nPTBdIC0gSWYgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIGZvbnQgc2V0IGhhdmUgdmVydGljYWwgc3BhY2luZyBiZXR3ZWVuIHRoZW0gc2V0IHRoZSByZXF1aXJlZCBhbW91bnQgaGVyZS5cclxuLy8gKiBAcGFyYW0ge251bWJlcn0gW3hPZmZzZXQ9MF0gLSBJZiB0aGUgZm9udCBzZXQgZG9lc24ndCBzdGFydCBhdCB0aGUgdG9wIGxlZnQgb2YgdGhlIGdpdmVuIGltYWdlLCBzcGVjaWZ5IHRoZSBYIGNvb3JkaW5hdGUgb2Zmc2V0IGhlcmUuXHJcbi8vICogQHBhcmFtIHtudW1iZXJ9IFt5T2Zmc2V0PTBdIC0gSWYgdGhlIGZvbnQgc2V0IGRvZXNuJ3Qgc3RhcnQgYXQgdGhlIHRvcCBsZWZ0IG9mIHRoZSBnaXZlbiBpbWFnZSwgc3BlY2lmeSB0aGUgWSBjb29yZGluYXRlIG9mZnNldCBoZXJlLlxyXG4vLyBQaGFzZXIuR2FtZU9iamVjdC5SZXRyb0ZvbnQgPSBmdW5jdGlvbiAoZ2FtZSwga2V5LCBjaGFyYWN0ZXJXaWR0aCwgY2hhcmFjdGVySGVpZ2h0LCBjaGFycywgY2hhcnNQZXJSb3csIHhTcGFjaW5nLCB5U3BhY2luZywgeE9mZnNldCwgeU9mZnNldClcclxuXHJcbi8vIHtcclxuLy8gICAgICBpbWFnZToga2V5LFxyXG4vLyAgICAgIHdpZHRoOiAzMixcclxuLy8gICAgICBoZWlnaHQ6IDMyLFxyXG4vLyAgICAgIGNoYXJzOiAnc3RyaW5nJyxcclxuLy8gICAgICBjaGFyc1BlclJvdzogbnVsbCxcclxuLy8gICAgICBzcGFjaW5nOiB7IHg6IDAsIHk6IDAgfSxcclxuLy8gICAgICBvZmZzZXQ6IHsgeDogMCwgeTogMCB9XHJcbi8vIH1cclxuXHJcbnZhciBQYXJzZVJldHJvRm9udCA9IGZ1bmN0aW9uIChzY2VuZSwgY29uZmlnKVxyXG57XHJcbiAgICB2YXIgdyA9IGNvbmZpZy53aWR0aDtcclxuICAgIHZhciBoID0gY29uZmlnLmhlaWdodDtcclxuICAgIHZhciBjeCA9IE1hdGguZmxvb3IodyAvIDIpO1xyXG4gICAgdmFyIGN5ID0gTWF0aC5mbG9vcihoIC8gMik7XHJcbiAgICB2YXIgbGV0dGVycyA9IGNvbmZpZy5jaGFycztcclxuXHJcbiAgICB2YXIga2V5ID0gR2V0VmFsdWUoY29uZmlnLCAnaW1hZ2UnLCAnJyk7XHJcbiAgICB2YXIgb2Zmc2V0WCA9IEdldFZhbHVlKGNvbmZpZywgJ29mZnNldC54JywgMCk7XHJcbiAgICB2YXIgb2Zmc2V0WSA9IEdldFZhbHVlKGNvbmZpZywgJ29mZnNldC55JywgMCk7XHJcbiAgICB2YXIgc3BhY2luZ1ggPSBHZXRWYWx1ZShjb25maWcsICdzcGFjaW5nLngnLCAwKTtcclxuICAgIHZhciBzcGFjaW5nWSA9IEdldFZhbHVlKGNvbmZpZywgJ3NwYWNpbmcueScsIDApO1xyXG5cclxuICAgIHZhciBjaGFyc1BlclJvdyA9IEdldFZhbHVlKGNvbmZpZywgJ2NoYXJzUGVyUm93JywgbnVsbCk7XHJcblxyXG4gICAgaWYgKGNoYXJzUGVyUm93ID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIGNoYXJzUGVyUm93ID0gc2NlbmUuc3lzLnRleHR1cmVzLmdldEZyYW1lKGtleSkud2lkdGggLyB3O1xyXG5cclxuICAgICAgICBpZiAoY2hhcnNQZXJSb3cgPiBsZXR0ZXJzLmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNoYXJzUGVyUm93ID0gbGV0dGVycy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB4ID0gb2Zmc2V0WDtcclxuICAgIHZhciB5ID0gb2Zmc2V0WTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICByZXRyb0ZvbnQ6IHRydWUsXHJcbiAgICAgICAgZm9udDoga2V5LFxyXG4gICAgICAgIHNpemU6IHcsXHJcbiAgICAgICAgbGluZUhlaWdodDogaCxcclxuICAgICAgICBjaGFyczoge31cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHIgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICAvLyB2YXIgbm9kZSA9IGxldHRlcnNbaV07XHJcblxyXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IGxldHRlcnMuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICAgICAgZGF0YS5jaGFyc1tjaGFyQ29kZV0gPVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgd2lkdGg6IHcsXHJcbiAgICAgICAgICAgIGhlaWdodDogaCxcclxuICAgICAgICAgICAgY2VudGVyWDogY3gsXHJcbiAgICAgICAgICAgIGNlbnRlclk6IGN5LFxyXG4gICAgICAgICAgICB4T2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB5T2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB4QWR2YW5jZTogdyxcclxuICAgICAgICAgICAgZGF0YToge30sXHJcbiAgICAgICAgICAgIGtlcm5pbmc6IHt9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcisrO1xyXG5cclxuICAgICAgICBpZiAociA9PT0gY2hhcnNQZXJSb3cpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByID0gMDtcclxuICAgICAgICAgICAgeCA9IG9mZnNldFg7XHJcbiAgICAgICAgICAgIHkgKz0gaCArIHNwYWNpbmdZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4ICs9IHcgKyBzcGFjaW5nWDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVudHJ5ID0ge1xyXG4gICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgZnJhbWU6IG51bGwsXHJcbiAgICAgICAgdGV4dHVyZToga2V5XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBlbnRyeTtcclxufTtcclxuXHJcbi8qKlxyXG4qIFRleHQgU2V0IDEgPSAgIVxcXCIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXFxcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9flxyXG4qIEBjb25zdGFudFxyXG4qIEB0eXBlIHtzdHJpbmd9XHJcbiovXHJcblBhcnNlUmV0cm9Gb250LlRFWFRfU0VUMSA9IFwiICFcXFwiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5cIjtcclxuXHJcbi8qKlxyXG4qIFRleHQgU2V0IDIgPSAgIVwiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcclxuKiBAY29uc3RhbnRcclxuKiBAdHlwZSB7c3RyaW5nfVxyXG4qL1xyXG5QYXJzZVJldHJvRm9udC5URVhUX1NFVDIgPSBcIiAhXFxcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XHJcblxyXG4vKipcclxuKiBUZXh0IFNldCAzID0gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5IFxyXG4qIEBjb25zdGFudFxyXG4qIEB0eXBlIHtzdHJpbmd9XHJcbiovXHJcblBhcnNlUmV0cm9Gb250LlRFWFRfU0VUMyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5IFwiO1xyXG5cclxuLyoqXHJcbiogVGV4dCBTZXQgNCA9IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaIDAxMjM0NTY3ODlcclxuKiBAY29uc3RhbnRcclxuKiBAdHlwZSB7c3RyaW5nfVxyXG4qL1xyXG5QYXJzZVJldHJvRm9udC5URVhUX1NFVDQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaIDAxMjM0NTY3ODlcIjtcclxuXHJcbi8qKlxyXG4qIFRleHQgU2V0IDUgPSBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi4sLygpICchPy0qOjAxMjM0NTY3ODlcclxuKiBAY29uc3RhbnRcclxuKiBAdHlwZSB7c3RyaW5nfVxyXG4qL1xyXG5QYXJzZVJldHJvRm9udC5URVhUX1NFVDUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLiwvKCkgJyE/LSo6MDEyMzQ1Njc4OVwiO1xyXG5cclxuLyoqXHJcbiogVGV4dCBTZXQgNiA9IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaIT86OzAxMjM0NTY3ODlcIigpLC0uJyBcclxuKiBAY29uc3RhbnRcclxuKiBAdHlwZSB7c3RyaW5nfVxyXG4qL1xyXG5QYXJzZVJldHJvRm9udC5URVhUX1NFVDYgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaIT86OzAxMjM0NTY3ODlcXFwiKCksLS4nIFwiO1xyXG5cclxuLyoqXHJcbiogVGV4dCBTZXQgNyA9IEFHTVNZKzo0QkhOVFohOzVDSU9VLj8wNkRKUFYsKDE3RUtRV1wiKTI4RkxSWC0nMzlcclxuKiBAY29uc3RhbnRcclxuKiBAdHlwZSB7c3RyaW5nfVxyXG4qL1xyXG5QYXJzZVJldHJvRm9udC5URVhUX1NFVDcgPSBcIkFHTVNZKzo0QkhOVFohOzVDSU9VLj8wNkRKUFYsKDE3RUtRV1xcXCIpMjhGTFJYLSczOVwiO1xyXG5cclxuLyoqXHJcbiogVGV4dCBTZXQgOCA9IDAxMjM0NTY3ODkgLkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXHJcbiogQGNvbnN0YW50XHJcbiogQHR5cGUge3N0cmluZ31cclxuKi9cclxuUGFyc2VSZXRyb0ZvbnQuVEVYVF9TRVQ4ID0gXCIwMTIzNDU2Nzg5IC5BQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xyXG5cclxuLyoqXHJcbiogVGV4dCBTZXQgOSA9IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaKCktMDEyMzQ1Njc4OS46LCdcIj8hXHJcbiogQGNvbnN0YW50XHJcbiogQHR5cGUge3N0cmluZ31cclxuKi9cclxuUGFyc2VSZXRyb0ZvbnQuVEVYVF9TRVQ5ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWigpLTAxMjM0NTY3ODkuOiwnXFxcIj8hXCI7XHJcblxyXG4vKipcclxuKiBUZXh0IFNldCAxMCA9IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXHJcbiogQGNvbnN0YW50XHJcbiogQHR5cGUge3N0cmluZ31cclxuKi9cclxuUGFyc2VSZXRyb0ZvbnQuVEVYVF9TRVQxMCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcclxuXHJcbi8qKlxyXG4qIFRleHQgU2V0IDExID0gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVouLFwiLSshPygpJzo7MDEyMzQ1Njc4OVxyXG4qIEBjb25zdGFudFxyXG4qIEB0eXBlIHtzdHJpbmd9XHJcbiovXHJcblBhcnNlUmV0cm9Gb250LlRFWFRfU0VUMTEgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLixcXFwiLSshPygpJzo7MDEyMzQ1Njc4OVwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZVJldHJvRm9udDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L1BhcnNlUmV0cm9Gb250LmpzXG4vLyBtb2R1bGUgaWQgPSA0Mjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgRHluYW1pY0JpdG1hcFRleHRDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICB2YXIgdGV4dCA9IHNyYy50ZXh0O1xyXG4gICAgdmFyIHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAoR2FtZU9iamVjdC5SRU5ERVJfTUFTSyAhPT0gc3JjLnJlbmRlckZsYWdzIHx8IHRleHRMZW5ndGggPT09IDAgfHwgKHNyYy5jYW1lcmFGaWx0ZXIgPiAwICYmIChzcmMuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHRleHR1cmVGcmFtZSA9IHNyYy5mcmFtZTtcclxuXHJcbiAgICB2YXIgZGlzcGxheUNhbGxiYWNrID0gc3JjLmRpc3BsYXlDYWxsYmFjaztcclxuXHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYICogc3JjLnNjcm9sbEZhY3Rvclg7XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWSA9IGNhbWVyYS5zY3JvbGxZICogc3JjLnNjcm9sbEZhY3Rvclk7XHJcblxyXG4gICAgdmFyIGNoYXJzID0gc3JjLmZvbnREYXRhLmNoYXJzO1xyXG4gICAgdmFyIGxpbmVIZWlnaHQgPSBzcmMuZm9udERhdGEubGluZUhlaWdodDtcclxuXHJcbiAgICB2YXIgeEFkdmFuY2UgPSAwO1xyXG4gICAgdmFyIHlBZHZhbmNlID0gMDtcclxuXHJcbiAgICB2YXIgaW5kZXhDb3VudCA9IDA7XHJcbiAgICB2YXIgY2hhckNvZGUgPSAwO1xyXG5cclxuICAgIHZhciBnbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgZ2x5cGhYID0gMDtcclxuICAgIHZhciBnbHlwaFkgPSAwO1xyXG4gICAgdmFyIGdseXBoVyA9IDA7XHJcbiAgICB2YXIgZ2x5cGhIID0gMDtcclxuXHJcbiAgICB2YXIgeCA9IDA7XHJcbiAgICB2YXIgeSA9IDA7XHJcblxyXG4gICAgdmFyIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgbGFzdENoYXJDb2RlID0gMDtcclxuXHJcbiAgICB2YXIgY3R4ID0gcmVuZGVyZXIuY3VycmVudENvbnRleHQ7XHJcbiAgICB2YXIgaW1hZ2UgPSBzcmMuZnJhbWUuc291cmNlLmltYWdlO1xyXG5cclxuICAgIHZhciB0ZXh0dXJlWCA9IHRleHR1cmVGcmFtZS5jdXRYO1xyXG4gICAgdmFyIHRleHR1cmVZID0gdGV4dHVyZUZyYW1lLmN1dFk7XHJcblxyXG4gICAgdmFyIHJvdGF0aW9uID0gMDtcclxuICAgIHZhciBzY2FsZSA9IChzcmMuZm9udFNpemUgLyBzcmMuZm9udERhdGEuc2l6ZSk7XHJcblxyXG4gICAgLy8gIEJsZW5kIE1vZGVcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlICE9PSBzcmMuYmxlbmRNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgPSBzcmMuYmxlbmRNb2RlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3NyYy5ibGVuZE1vZGVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBbHBoYVxyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRBbHBoYSAhPT0gc3JjLmFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRBbHBoYSA9IHNyYy5hbHBoYTtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNtb290aGluZ1xyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgIT09IHNyYy5zY2FsZU1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSA9IHNyYy5zY2FsZU1vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC50cmFuc2xhdGUoc3JjLngsIHNyYy55KTtcclxuICAgIGN0eC5yb3RhdGUoc3JjLnJvdGF0aW9uKTtcclxuICAgIGN0eC5zY2FsZShzcmMuc2NhbGVYLCBzcmMuc2NhbGVZKTtcclxuXHJcbiAgICBpZiAoc3JjLmNyb3BXaWR0aCA+IDAgJiYgc3JjLmNyb3BIZWlnaHQgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5yZWN0KDAsIDAsIHNyYy5jcm9wV2lkdGgsIHNyYy5jcm9wSGVpZ2h0KTtcclxuICAgICAgICBjdHguY2xpcCgpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGV4dExlbmd0aDsgKytpbmRleClcclxuICAgIHtcclxuICAgICAgICAvLyAgUmVzZXQgdGhlIHNjYWxlIChpbiBjYXNlIHRoZSBjYWxsYmFjayBjaGFuZ2VkIGl0KVxyXG4gICAgICAgIHNjYWxlID0gKHNyYy5mb250U2l6ZSAvIHNyYy5mb250RGF0YS5zaXplKTtcclxuICAgICAgICByb3RhdGlvbiA9IDA7XHJcblxyXG4gICAgICAgIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGluZGV4KTtcclxuXHJcbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSAxMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHhBZHZhbmNlID0gMDtcclxuICAgICAgICAgICAgaW5kZXhDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHlBZHZhbmNlICs9IGxpbmVIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGggPSBjaGFyc1tjaGFyQ29kZV07XHJcblxyXG4gICAgICAgIGlmICghZ2x5cGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdseXBoWCA9IHRleHR1cmVYICsgZ2x5cGgueDtcclxuICAgICAgICBnbHlwaFkgPSB0ZXh0dXJlWSArIGdseXBoLnk7XHJcblxyXG4gICAgICAgIGdseXBoVyA9IGdseXBoLndpZHRoO1xyXG4gICAgICAgIGdseXBoSCA9IGdseXBoLmhlaWdodDtcclxuXHJcbiAgICAgICAgeCA9IChpbmRleENvdW50ICsgZ2x5cGgueE9mZnNldCArIHhBZHZhbmNlKSAtIHNyYy5zY3JvbGxYO1xyXG4gICAgICAgIHkgPSAoZ2x5cGgueU9mZnNldCArIHlBZHZhbmNlKSAtIHNyYy5zY3JvbGxZO1xyXG5cclxuICAgICAgICAvLyAgVGhpcyBjb3VsZCBiZSBvcHRpbWl6ZWQgc28gdGhhdCBpdCBkb2Vzbid0IGV2ZW4gYm90aGVyIGRyYXdpbmcgaXQgaWYgdGhlIHgveSBpcyBvdXQgb2YgcmFuZ2VcclxuXHJcbiAgICAgICAgaWYgKGxhc3RHbHlwaCAhPT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBrZXJuaW5nT2Zmc2V0ID0gZ2x5cGgua2VybmluZ1tsYXN0Q2hhckNvZGVdO1xyXG4gICAgICAgICAgICB4ICs9IChrZXJuaW5nT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8ga2VybmluZ09mZnNldCA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGlzcGxheUNhbGxiYWNrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGRpc3BsYXlDYWxsYmFjayh7IHRpbnQ6IHsgdG9wTGVmdDogMCwgdG9wUmlnaHQ6IDAsIGJvdHRvbUxlZnQ6IDAsIGJvdHRvbVJpZ2h0OiAwIH0sIGluZGV4OiBpbmRleCwgY2hhckNvZGU6IGNoYXJDb2RlLCB4OiB4LCB5OiB5LCBzY2FsZTogc2NhbGUsIHJvdGF0aW9uOiAwLCBkYXRhOiBnbHlwaC5kYXRhIH0pO1xyXG5cclxuICAgICAgICAgICAgeCA9IG91dHB1dC54O1xyXG4gICAgICAgICAgICB5ID0gb3V0cHV0Lnk7XHJcbiAgICAgICAgICAgIHNjYWxlID0gb3V0cHV0LnNjYWxlO1xyXG4gICAgICAgICAgICByb3RhdGlvbiA9IG91dHB1dC5yb3RhdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggKj0gc2NhbGU7XHJcbiAgICAgICAgeSAqPSBzY2FsZTtcclxuXHJcbiAgICAgICAgeCAtPSBjYW1lcmFTY3JvbGxYO1xyXG4gICAgICAgIHkgLT0gY2FtZXJhU2Nyb2xsWTtcclxuXHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgIGN0eC5yb3RhdGUocm90YXRpb24pO1xyXG4gICAgICAgIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICAvLyBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwyNTUsMCwwLjIpJztcclxuICAgICAgICAvLyBjdHguZmlsbFJlY3QoMCwgMCwgZ2x5cGhXLCBnbHlwaEgpO1xyXG5cclxuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBnbHlwaFgsIGdseXBoWSwgZ2x5cGhXLCBnbHlwaEgsIDAsIDAsIGdseXBoVywgZ2x5cGhIKTtcclxuXHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICBcclxuICAgICAgICB4QWR2YW5jZSArPSBnbHlwaC54QWR2YW5jZTtcclxuICAgICAgICBpbmRleENvdW50ICs9IDE7XHJcbiAgICAgICAgbGFzdEdseXBoID0gZ2x5cGg7XHJcbiAgICAgICAgbGFzdENoYXJDb2RlID0gY2hhckNvZGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNyYy5jcm9wV2lkdGggPiAwICYmIHNyYy5jcm9wSGVpZ2h0ID4gMClcclxuICAgIHtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IER5bmFtaWNCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQml0bWFwVGV4dCA9IHJlcXVpcmUoJy4vRHluYW1pY0JpdG1hcFRleHQnKTtcclxudmFyIEJ1aWxkR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL0J1aWxkR2FtZU9iamVjdCcpO1xyXG52YXIgR2FtZU9iamVjdENyZWF0b3IgPSByZXF1aXJlKCcuLi8uLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RDcmVhdG9yJyk7XHJcbnZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0Q3JlYXRvciBjb250ZXh0LlxyXG5cclxuR2FtZU9iamVjdENyZWF0b3IucmVnaXN0ZXIoJ2R5bmFtaWNCaXRtYXBUZXh0JywgZnVuY3Rpb24gKGNvbmZpZylcclxue1xyXG4gICAgdmFyIGZvbnQgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2ZvbnQnLCAnJyk7XHJcbiAgICB2YXIgdGV4dCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAndGV4dCcsICcnKTtcclxuICAgIHZhciBzaXplID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdzaXplJywgZmFsc2UpO1xyXG4gICAgdmFyIGFsaWduID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdhbGlnbicsICdsZWZ0Jyk7XHJcblxyXG4gICAgdmFyIGJpdG1hcFRleHQgPSBuZXcgQml0bWFwVGV4dCh0aGlzLnNjZW5lLCAwLCAwLCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbik7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHRoaXMuc2NlbmUsIGJpdG1hcFRleHQsIGNvbmZpZyk7XHJcblxyXG4gICAgcmV0dXJuIGJpdG1hcFRleHQ7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dENyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDQyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRHluYW1pY0JpdG1hcFRleHQgPSByZXF1aXJlKCcuL0R5bmFtaWNCaXRtYXBUZXh0Jyk7XHJcbnZhciBHYW1lT2JqZWN0RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdEZhY3RvcnknKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0RmFjdG9yeSBjb250ZXh0LlxyXG4vLyAgXHJcbi8vICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9wZXJ0aWVzIGF2YWlsYWJsZSB0byB1c2U6XHJcbi8vICBcclxuLy8gIHRoaXMuc2NlbmUgLSBhIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhhdCBvd25zIHRoZSBHYW1lT2JqZWN0RmFjdG9yeVxyXG4vLyAgdGhpcy5kaXNwbGF5TGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBEaXNwbGF5IExpc3QgdGhlIFNjZW5lIG93bnNcclxuLy8gIHRoaXMudXBkYXRlTGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBVcGRhdGUgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG5cclxuR2FtZU9iamVjdEZhY3RvcnkucmVnaXN0ZXIoJ2R5bmFtaWNCaXRtYXBUZXh0JywgZnVuY3Rpb24gKHgsIHksIGZvbnQsIHRleHQsIHNpemUpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmRpc3BsYXlMaXN0LmFkZChuZXcgRHluYW1pY0JpdG1hcFRleHQodGhpcy5zY2VuZSwgeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSkpO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlcldlYkdMID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvTk9PUCcpO1xyXG52YXIgcmVuZGVyQ2FudmFzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvTk9PUCcpO1xyXG5cclxuaWYgKFdFQkdMX1JFTkRFUkVSKVxyXG57XHJcbiAgICByZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4vRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyJyk7XHJcbn1cclxuXHJcbmlmIChDQU5WQVNfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4vRHluYW1pY0JpdG1hcFRleHRDYW52YXNSZW5kZXJlcicpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJXZWJHTDogcmVuZGVyV2ViR0wsXHJcbiAgICByZW5kZXJDYW52YXM6IHJlbmRlckNhbnZhc1xyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL0dhbWVPYmplY3QnKTtcclxudmFyIFRyYW5zZm9ybU1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvVHJhbnNmb3JtTWF0cml4Jyk7XHJcbnZhciB0ZW1wTWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG52YXIgdGVtcE1hdHJpeENoYXIgPSBuZXcgVHJhbnNmb3JtTWF0cml4KCk7XHJcblxyXG52YXIgRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBnYW1lT2JqZWN0LCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICB2YXIgdGV4dCA9IGdhbWVPYmplY3QudGV4dDtcclxuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IGdhbWVPYmplY3QucmVuZGVyRmxhZ3MgfHwgdGV4dExlbmd0aCA9PT0gMCB8fCAoZ2FtZU9iamVjdC5jYW1lcmFGaWx0ZXIgPiAwICYmIChnYW1lT2JqZWN0LmNhbWVyYUZpbHRlciAmIGNhbWVyYS5faWQpKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRpc3BsYXlDYWxsYmFjayA9IGdhbWVPYmplY3QuZGlzcGxheUNhbGxiYWNrO1xyXG4gICAgdmFyIHRleHR1cmVGcmFtZSA9IGdhbWVPYmplY3QuZnJhbWU7XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYICogZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JYO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgIHZhciBjaGFycyA9IGdhbWVPYmplY3QuZm9udERhdGEuY2hhcnM7XHJcbiAgICB2YXIgbGluZUhlaWdodCA9IGdhbWVPYmplY3QuZm9udERhdGEubGluZUhlaWdodDtcclxuICAgIHZhciBzcHJpdGVCYXRjaCA9IHJlbmRlcmVyLnNwcml0ZUJhdGNoO1xyXG4gICAgdmFyIGFscGhhID0gZ2FtZU9iamVjdC5hbHBoYTtcclxuICAgIHZhciB0aW50VEwgPSBnYW1lT2JqZWN0Ll90aW50VEw7XHJcbiAgICB2YXIgdGludFRSID0gZ2FtZU9iamVjdC5fdGludFRSO1xyXG4gICAgdmFyIHRpbnRCTCA9IGdhbWVPYmplY3QuX3RpbnRCTDtcclxuICAgIHZhciB0aW50QlIgPSBnYW1lT2JqZWN0Ll90aW50QlI7XHJcbiAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHNwcml0ZUJhdGNoLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICB2YXIgdmVydGV4QnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgdmFyIHRleHR1cmVEYXRhID0gZ2FtZU9iamVjdC50ZXh0dXJlLnNvdXJjZVt0ZXh0dXJlRnJhbWUuc291cmNlSW5kZXhdO1xyXG4gICAgdmFyIHRleHR1cmVYID0gdGV4dHVyZUZyYW1lLmN1dFg7XHJcbiAgICB2YXIgdGV4dHVyZVkgPSB0ZXh0dXJlRnJhbWUuY3V0WTtcclxuICAgIHZhciB0ZXh0dXJlV2lkdGggPSB0ZXh0dXJlRGF0YS53aWR0aDtcclxuICAgIHZhciB0ZXh0dXJlSGVpZ2h0ID0gdGV4dHVyZURhdGEuaGVpZ2h0O1xyXG4gICAgdmFyIHRleHR1cmUgPSB0ZXh0dXJlRGF0YS5nbFRleHR1cmU7XHJcbiAgICB2YXIgeEFkdmFuY2UgPSAwO1xyXG4gICAgdmFyIHlBZHZhbmNlID0gMDtcclxuICAgIHZhciBpbmRleENvdW50ID0gMDtcclxuICAgIHZhciBjaGFyQ29kZSA9IDA7XHJcbiAgICB2YXIgZ2x5cGggPSBudWxsO1xyXG4gICAgdmFyIGdseXBoWCA9IDA7XHJcbiAgICB2YXIgZ2x5cGhZID0gMDtcclxuICAgIHZhciBnbHlwaFcgPSAwO1xyXG4gICAgdmFyIGdseXBoSCA9IDA7XHJcbiAgICB2YXIgeCA9IDA7XHJcbiAgICB2YXIgeSA9IDA7XHJcbiAgICB2YXIgcm90YXRpb24gPSAwO1xyXG4gICAgdmFyIHh3ID0gMDtcclxuICAgIHZhciB5aCA9IDA7XHJcbiAgICB2YXIgdW1pbiA9IDA7XHJcbiAgICB2YXIgdW1heCA9IDA7XHJcbiAgICB2YXIgdm1pbiA9IDA7XHJcbiAgICB2YXIgdm1heCA9IDA7XHJcbiAgICB2YXIgbGFzdEdseXBoID0gbnVsbDtcclxuICAgIHZhciBsYXN0Q2hhckNvZGUgPSAwO1xyXG4gICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgIHZhciBjYW1lcmFNYXRyaXggPSBjYW1lcmEubWF0cml4Lm1hdHJpeDtcclxuICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgdmFyIHNjYWxlID0gKGdhbWVPYmplY3QuZm9udFNpemUgLyBnYW1lT2JqZWN0LmZvbnREYXRhLnNpemUpO1xyXG4gICAgdmFyIHV0YSwgdXRiLCB1dGMsIHV0ZCwgdXRlLCB1dGY7XHJcbiAgICB2YXIgdGVtcE1hdHJpeENoYXJNYXRyaXggPSB0ZW1wTWF0cml4Q2hhci5tYXRyaXg7XHJcbiAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQ7XHJcblxyXG4gICAgdGVtcE1hdHJpeC5hcHBseUlUUlMoXHJcbiAgICAgICAgZ2FtZU9iamVjdC54IC0gY2FtZXJhU2Nyb2xsWCwgZ2FtZU9iamVjdC55IC0gY2FtZXJhU2Nyb2xsWSxcclxuICAgICAgICAtZ2FtZU9iamVjdC5yb3RhdGlvbixcclxuICAgICAgICBnYW1lT2JqZWN0LnNjYWxlWCwgZ2FtZU9iamVjdC5zY2FsZVlcclxuICAgICk7XHJcblxyXG4gICAgc3JhID0gdGVtcE1hdHJpeE1hdHJpeFswXTtcclxuICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XHJcbiAgICBzcmMgPSB0ZW1wTWF0cml4TWF0cml4WzJdO1xyXG4gICAgc3JkID0gdGVtcE1hdHJpeE1hdHJpeFszXTtcclxuICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XHJcbiAgICBzcmYgPSB0ZW1wTWF0cml4TWF0cml4WzVdO1xyXG5cclxuICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgIGNtYiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgIGNtYyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgIGNtZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgIGNtZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuXHJcbiAgICBtdmEgPSBzcmEgKiBjbWEgKyBzcmIgKiBjbWM7XHJcbiAgICBtdmIgPSBzcmEgKiBjbWIgKyBzcmIgKiBjbWQ7XHJcbiAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XHJcbiAgICBtdmQgPSBzcmMgKiBjbWIgKyBzcmQgKiBjbWQ7XHJcbiAgICBtdmUgPSBzcmUgKiBjbWEgKyBzcmYgKiBjbWMgKyBjbWU7XHJcbiAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7XHJcblxyXG4gICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgaWYgKGdhbWVPYmplY3QuY3JvcFdpZHRoID4gMCAmJiBnYW1lT2JqZWN0LmNyb3BIZWlnaHQgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyZW5kZXJlci5jdXJyZW50UmVuZGVyZXIgIT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZW5kZXJlci5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghcmVuZGVyZXIuc2Npc3Nvci5lbmFibGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3cgPSBnYW1lT2JqZWN0LmNyb3BXaWR0aCAqIGdhbWVPYmplY3Quc2NhbGVYO1xyXG4gICAgICAgIHZhciBzaCA9IGdhbWVPYmplY3QuY3JvcEhlaWdodCAqIGdhbWVPYmplY3Quc2NhbGVZO1xyXG5cclxuICAgICAgICBnbC5zY2lzc29yKGdhbWVPYmplY3QueCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAtIGdhbWVPYmplY3QueSAtIHNoLCBzdywgc2gpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0TGVuZ3RoOyArK2luZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGluZGV4KTtcclxuXHJcbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSAxMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHhBZHZhbmNlID0gMDtcclxuICAgICAgICAgICAgaW5kZXhDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHlBZHZhbmNlICs9IGxpbmVIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGggPSBjaGFyc1tjaGFyQ29kZV07XHJcblxyXG4gICAgICAgIGlmICghZ2x5cGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdseXBoWCA9IHRleHR1cmVYICsgZ2x5cGgueDtcclxuICAgICAgICBnbHlwaFkgPSB0ZXh0dXJlWSArIGdseXBoLnk7XHJcblxyXG4gICAgICAgIGdseXBoVyA9IGdseXBoLndpZHRoO1xyXG4gICAgICAgIGdseXBoSCA9IGdseXBoLmhlaWdodDtcclxuXHJcbiAgICAgICAgeCA9IChpbmRleENvdW50ICsgZ2x5cGgueE9mZnNldCArIHhBZHZhbmNlKSAqIHNjYWxlO1xyXG4gICAgICAgIHkgPSAoZ2x5cGgueU9mZnNldCArIHlBZHZhbmNlKSAqIHNjYWxlO1xyXG5cclxuICAgICAgICByb3RhdGlvbiA9IDA7XHJcblxyXG4gICAgICAgIGlmIChsYXN0R2x5cGggIT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIga2VybmluZ09mZnNldCA9IGdseXBoLmtlcm5pbmdbbGFzdENoYXJDb2RlXTtcclxuICAgICAgICAgICAgeCArPSAoa2VybmluZ09mZnNldCAhPT0gdW5kZWZpbmVkKSA/IGtlcm5pbmdPZmZzZXQgOiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRpc3BsYXlDYWxsYmFjaylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBkaXNwbGF5Q2FsbGJhY2soeyBjb2xvcjogMCwgdGludDogeyB0b3BMZWZ0OiB0aW50VEwsIHRvcFJpZ2h0OiB0aW50VFIsIGJvdHRvbUxlZnQ6IHRpbnRCTCwgYm90dG9tUmlnaHQ6IHRpbnRCUiB9LCBpbmRleDogaW5kZXgsIGNoYXJDb2RlOiBjaGFyQ29kZSwgeDogeCwgeTogeSwgc2NhbGU6IHNjYWxlLCByb3RhdGlvbjogMCwgZGF0YTogZ2x5cGguZGF0YSB9KTtcclxuXHJcbiAgICAgICAgICAgIHggPSBvdXRwdXQueDtcclxuICAgICAgICAgICAgeSA9IG91dHB1dC55O1xyXG4gICAgICAgICAgICBzY2FsZSA9IG91dHB1dC5zY2FsZTtcclxuICAgICAgICAgICAgcm90YXRpb24gPSBvdXRwdXQucm90YXRpb247XHJcblxyXG4gICAgICAgICAgICBpZiAob3V0cHV0LmNvbG9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aW50VEwgPSBvdXRwdXQuY29sb3I7XHJcbiAgICAgICAgICAgICAgICB0aW50VFIgPSBvdXRwdXQuY29sb3I7XHJcbiAgICAgICAgICAgICAgICB0aW50QkwgPSBvdXRwdXQuY29sb3I7XHJcbiAgICAgICAgICAgICAgICB0aW50QlIgPSBvdXRwdXQuY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aW50VEwgPSBvdXRwdXQudGludC50b3BMZWZ0O1xyXG4gICAgICAgICAgICAgICAgdGludFRSID0gb3V0cHV0LnRpbnQudG9wUmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aW50QkwgPSBvdXRwdXQudGludC5ib3R0b21MZWZ0O1xyXG4gICAgICAgICAgICAgICAgdGludEJSID0gb3V0cHV0LnRpbnQuYm90dG9tUmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggLT0gZ2FtZU9iamVjdC5zY3JvbGxYIHwgMDtcclxuICAgICAgICB5IC09IGdhbWVPYmplY3Quc2Nyb2xsWSB8IDA7XHJcblxyXG4gICAgICAgIHRlbXBNYXRyaXhDaGFyLmFwcGx5SVRSUyhcclxuICAgICAgICAgICAgeCwgeSxcclxuICAgICAgICAgICAgLXJvdGF0aW9uLFxyXG4gICAgICAgICAgICBzY2FsZSwgc2NhbGVcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB1dGEgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFswXTtcclxuICAgICAgICB1dGIgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFsxXTtcclxuICAgICAgICB1dGMgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFsyXTtcclxuICAgICAgICB1dGQgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFszXTtcclxuICAgICAgICB1dGUgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFs0XTtcclxuICAgICAgICB1dGYgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgc3JhID0gdXRhICogbXZhICsgdXRiICogbXZjO1xyXG4gICAgICAgIHNyYiA9IHV0YSAqIG12YiArIHV0YiAqIG12ZDtcclxuICAgICAgICBzcmMgPSB1dGMgKiBtdmEgKyB1dGQgKiBtdmM7XHJcbiAgICAgICAgc3JkID0gdXRjICogbXZiICsgdXRkICogbXZkO1xyXG4gICAgICAgIHNyZSA9IHV0ZSAqIG12YSArIHV0ZiAqIG12YyArIG12ZTtcclxuICAgICAgICBzcmYgPSB1dGUgKiBtdmIgKyB1dGYgKiBtdmQgKyBtdmY7XHJcblxyXG4gICAgICAgIHh3ID0gZ2x5cGhXO1xyXG4gICAgICAgIHloID0gZ2x5cGhIO1xyXG4gICAgICAgIHR4MCA9IHNyZTtcclxuICAgICAgICB0eTAgPSBzcmY7XHJcbiAgICAgICAgdHgxID0geWggKiBzcmMgKyBzcmU7XHJcbiAgICAgICAgdHkxID0geWggKiBzcmQgKyBzcmY7XHJcbiAgICAgICAgdHgyID0geHcgKiBzcmEgKyB5aCAqIHNyYyArIHNyZTtcclxuICAgICAgICB0eTIgPSB4dyAqIHNyYiArIHloICogc3JkICsgc3JmO1xyXG4gICAgICAgIHR4MyA9IHh3ICogc3JhICsgc3JlO1xyXG4gICAgICAgIHR5MyA9IHh3ICogc3JiICsgc3JmO1xyXG4gICAgICAgIHVtaW4gPSBnbHlwaFggLyB0ZXh0dXJlV2lkdGg7XHJcbiAgICAgICAgdW1heCA9IChnbHlwaFggKyBnbHlwaFcpIC8gdGV4dHVyZVdpZHRoO1xyXG4gICAgICAgIHZtaW4gPSBnbHlwaFkgLyB0ZXh0dXJlSGVpZ2h0O1xyXG4gICAgICAgIHZtYXggPSAoZ2x5cGhZICsgZ2x5cGhIKSAvIHRleHR1cmVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChzcHJpdGVCYXRjaC5lbGVtZW50Q291bnQgPj0gc3ByaXRlQmF0Y2gubWF4UGFydGljbGVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3ByaXRlQmF0Y2guZmx1c2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlcmVyKHNwcml0ZUJhdGNoLCB0ZXh0dXJlLCByZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjQpO1xyXG4gICAgICAgIHNwcml0ZUJhdGNoLmVsZW1lbnRDb3VudCArPSA2O1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnRUTDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludEJMO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWF4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWF4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50QlI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtYXg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnRUUjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHhBZHZhbmNlICs9IGdseXBoLnhBZHZhbmNlO1xyXG4gICAgICAgIGluZGV4Q291bnQgKz0gMTtcclxuICAgICAgICBsYXN0R2x5cGggPSBnbHlwaDtcclxuICAgICAgICBsYXN0Q2hhckNvZGUgPSBjaGFyQ29kZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZ2FtZU9iamVjdC5jcm9wV2lkdGggPiAwICYmIGdhbWVPYmplY3QuY3JvcEhlaWdodCA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgc3ByaXRlQmF0Y2guZmx1c2goKTtcclxuXHJcbiAgICAgICAgaWYgKHJlbmRlcmVyLnNjaXNzb3IuZW5hYmxlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLnNjaXNzb3IocmVuZGVyZXIuc2Npc3Nvci54LCByZW5kZXJlci5zY2lzc29yLnksIHJlbmRlcmVyLnNjaXNzb3Iud2lkdGgsIHJlbmRlcmVyLnNjaXNzb3IuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuc2Npc3NvcihjYW1lcmEueCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAtIGNhbWVyYS55IC0gY2FtZXJhLmhlaWdodCwgY2FtZXJhLndpZHRoLCBjYW1lcmEuaGVpZ2h0KTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dFdlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL0dhbWVPYmplY3QnKTtcclxuXHJcbnZhciBCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgdmFyIHRleHQgPSBzcmMudGV4dDtcclxuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IHNyYy5yZW5kZXJGbGFncyB8fCB0ZXh0TGVuZ3RoID09PSAwIHx8IChzcmMuY2FtZXJhRmlsdGVyID4gMCAmJiAoc3JjLmNhbWVyYUZpbHRlciAmIGNhbWVyYS5faWQpKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciB0ZXh0dXJlRnJhbWUgPSBzcmMuZnJhbWU7XHJcblxyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFggPSBjYW1lcmEuc2Nyb2xsWCAqIHNyYy5zY3JvbGxGYWN0b3JYO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWSAqIHNyYy5zY3JvbGxGYWN0b3JZO1xyXG5cclxuICAgIHZhciBjaGFycyA9IHNyYy5mb250RGF0YS5jaGFycztcclxuICAgIHZhciBsaW5lSGVpZ2h0ID0gc3JjLmZvbnREYXRhLmxpbmVIZWlnaHQ7XHJcblxyXG4gICAgdmFyIHhBZHZhbmNlID0gMDtcclxuICAgIHZhciB5QWR2YW5jZSA9IDA7XHJcblxyXG4gICAgdmFyIGluZGV4Q291bnQgPSAwO1xyXG4gICAgdmFyIGNoYXJDb2RlID0gMDtcclxuXHJcbiAgICB2YXIgZ2x5cGggPSBudWxsO1xyXG4gICAgdmFyIGdseXBoWCA9IDA7XHJcbiAgICB2YXIgZ2x5cGhZID0gMDtcclxuICAgIHZhciBnbHlwaFcgPSAwO1xyXG4gICAgdmFyIGdseXBoSCA9IDA7XHJcblxyXG4gICAgdmFyIHggPSAwO1xyXG4gICAgdmFyIHkgPSAwO1xyXG5cclxuICAgIHZhciBsYXN0R2x5cGggPSBudWxsO1xyXG4gICAgdmFyIGxhc3RDaGFyQ29kZSA9IDA7XHJcblxyXG4gICAgdmFyIGN0eCA9IHJlbmRlcmVyLmN1cnJlbnRDb250ZXh0O1xyXG4gICAgdmFyIGltYWdlID0gc3JjLmZyYW1lLnNvdXJjZS5pbWFnZTtcclxuXHJcbiAgICB2YXIgdGV4dHVyZVggPSB0ZXh0dXJlRnJhbWUuY3V0WDtcclxuICAgIHZhciB0ZXh0dXJlWSA9IHRleHR1cmVGcmFtZS5jdXRZO1xyXG5cclxuICAgIHZhciByb3RhdGlvbiA9IDA7XHJcbiAgICB2YXIgc2NhbGUgPSAoc3JjLmZvbnRTaXplIC8gc3JjLmZvbnREYXRhLnNpemUpO1xyXG5cclxuICAgIC8vICBCbGVuZCBNb2RlXHJcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSAhPT0gc3JjLmJsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlID0gc3JjLmJsZW5kTW9kZTtcclxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gcmVuZGVyZXIuYmxlbmRNb2Rlc1tzcmMuYmxlbmRNb2RlXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQWxwaGFcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QWxwaGEgIT09IHNyYy5hbHBoYSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50QWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTbW9vdGhpbmdcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50U2NhbGVNb2RlICE9PSBzcmMuc2NhbGVNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgPSBzcmMuc2NhbGVNb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKChzcmMueCAtIGNhbWVyYVNjcm9sbFgpICsgc3JjLmZyYW1lLngsIChzcmMueSAtIGNhbWVyYVNjcm9sbFkpICsgc3JjLmZyYW1lLnkpO1xyXG4gICAgY3R4LnJvdGF0ZShzcmMucm90YXRpb24pO1xyXG4gICAgY3R4LnNjYWxlKHNyYy5zY2FsZVgsIHNyYy5zY2FsZVkpO1xyXG5cclxuICAgIC8vIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyNTUsMCwyNTUsMC41KSc7XHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRleHRMZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xyXG5cclxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IDEwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeEFkdmFuY2UgPSAwO1xyXG4gICAgICAgICAgICBpbmRleENvdW50ID0gMDtcclxuICAgICAgICAgICAgeUFkdmFuY2UgKz0gbGluZUhlaWdodDtcclxuICAgICAgICAgICAgbGFzdEdseXBoID0gbnVsbDtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbHlwaCA9IGNoYXJzW2NoYXJDb2RlXTtcclxuXHJcbiAgICAgICAgaWYgKCFnbHlwaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGhYID0gdGV4dHVyZVggKyBnbHlwaC54O1xyXG4gICAgICAgIGdseXBoWSA9IHRleHR1cmVZICsgZ2x5cGgueTtcclxuXHJcbiAgICAgICAgZ2x5cGhXID0gZ2x5cGgud2lkdGg7XHJcbiAgICAgICAgZ2x5cGhIID0gZ2x5cGguaGVpZ2h0O1xyXG5cclxuICAgICAgICB4ID0gaW5kZXhDb3VudCArIGdseXBoLnhPZmZzZXQgKyB4QWR2YW5jZTtcclxuICAgICAgICB5ID0gZ2x5cGgueU9mZnNldCArIHlBZHZhbmNlO1xyXG5cclxuICAgICAgICBpZiAobGFzdEdseXBoICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGtlcm5pbmdPZmZzZXQgPSBnbHlwaC5rZXJuaW5nW2xhc3RDaGFyQ29kZV07XHJcbiAgICAgICAgICAgIHggKz0gKGtlcm5pbmdPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBrZXJuaW5nT2Zmc2V0IDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggKj0gc2NhbGU7XHJcbiAgICAgICAgeSAqPSBzY2FsZTtcclxuXHJcbiAgICAgICAgeEFkdmFuY2UgKz0gZ2x5cGgueEFkdmFuY2U7XHJcbiAgICAgICAgaW5kZXhDb3VudCArPSAxO1xyXG4gICAgICAgIGxhc3RHbHlwaCA9IGdseXBoO1xyXG4gICAgICAgIGxhc3RDaGFyQ29kZSA9IGNoYXJDb2RlO1xyXG5cclxuICAgICAgICAvLyAgTm90aGluZyB0byByZW5kZXIgb3IgYSBzcGFjZT8gVGhlbiBza2lwIHRvIHRoZSBuZXh0IGdseXBoXHJcbiAgICAgICAgaWYgKGdseXBoVyA9PT0gMCB8fCBnbHlwaEggPT09IDAgfHwgY2hhckNvZGUgPT09IDMyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XHJcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XHJcbiAgICAgICAgLy8gY3R4LmZpbGxSZWN0KDAsIDAsIGdseXBoVywgZ2x5cGhIKTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBnbHlwaFgsIGdseXBoWSwgZ2x5cGhXLCBnbHlwaEgsIDAsIDAsIGdseXBoVywgZ2x5cGhIKTtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpdG1hcFRleHRDYW52YXNSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQml0bWFwVGV4dCA9IHJlcXVpcmUoJy4vQml0bWFwVGV4dCcpO1xyXG52YXIgQnVpbGRHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vQnVpbGRHYW1lT2JqZWN0Jyk7XHJcbnZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4uLy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdENyZWF0b3InKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0Q3JlYXRvciBjb250ZXh0LlxyXG5cclxuR2FtZU9iamVjdENyZWF0b3IucmVnaXN0ZXIoJ2JpdG1hcFRleHQnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIgZm9udCA9IEdldFZhbHVlKGNvbmZpZywgJ2ZvbnQnLCAnJyk7XHJcbiAgICB2YXIgdGV4dCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAndGV4dCcsICcnKTtcclxuICAgIHZhciBzaXplID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdzaXplJywgZmFsc2UpO1xyXG4gICAgLy8gdmFyIGFsaWduID0gR2V0VmFsdWUoY29uZmlnLCAnYWxpZ24nLCAnbGVmdCcpO1xyXG5cclxuICAgIHZhciBiaXRtYXBUZXh0ID0gbmV3IEJpdG1hcFRleHQodGhpcy5zY2VuZSwgMCwgMCwgZm9udCwgdGV4dCwgc2l6ZSk7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHRoaXMuc2NlbmUsIGJpdG1hcFRleHQsIGNvbmZpZyk7XHJcblxyXG4gICAgcmV0dXJuIGJpdG1hcFRleHQ7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRDcmVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJpdG1hcFRleHQgPSByZXF1aXJlKCcuL0JpdG1hcFRleHQnKTtcclxudmFyIEdhbWVPYmplY3RGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0RmFjdG9yeScpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RGYWN0b3J5IGNvbnRleHQuXHJcbi8vICBcclxuLy8gIFRoZXJlIGFyZSBzZXZlcmFsIHByb3BlcnRpZXMgYXZhaWxhYmxlIHRvIHVzZTpcclxuLy8gIFxyXG4vLyAgdGhpcy5zY2VuZSAtIGEgcmVmZXJlbmNlIHRvIHRoZSBTY2VuZSB0aGF0IG93bnMgdGhlIEdhbWVPYmplY3RGYWN0b3J5XHJcbi8vICB0aGlzLmRpc3BsYXlMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIERpc3BsYXkgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG4vLyAgdGhpcy51cGRhdGVMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIFVwZGF0ZSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcblxyXG5HYW1lT2JqZWN0RmFjdG9yeS5yZWdpc3RlcignYml0bWFwVGV4dCcsIGZ1bmN0aW9uICh4LCB5LCBmb250LCB0ZXh0LCBzaXplKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5kaXNwbGF5TGlzdC5hZGQobmV3IEJpdG1hcFRleHQodGhpcy5zY2VuZSwgeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSkpO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0RmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL05PT1AnKTtcclxudmFyIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL05PT1AnKTtcclxuXHJcbmlmIChXRUJHTF9SRU5ERVJFUilcclxue1xyXG4gICAgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuL0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyJyk7XHJcbn1cclxuXHJcbmlmIChDQU5WQVNfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4vQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlcldlYkdMOiByZW5kZXJXZWJHTCxcclxuICAgIHJlbmRlckNhbnZhczogcmVuZGVyQ2FudmFzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL0dhbWVPYmplY3QnKTtcclxudmFyIFRyYW5zZm9ybU1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvVHJhbnNmb3JtTWF0cml4Jyk7XHJcbnZhciB0ZW1wTWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG5cclxudmFyIEJpdG1hcFRleHRXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBnYW1lT2JqZWN0LCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICB2YXIgdGV4dCA9IGdhbWVPYmplY3QudGV4dDtcclxuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IGdhbWVPYmplY3QucmVuZGVyRmxhZ3MgfHwgdGV4dExlbmd0aCA9PT0gMCB8fCAoZ2FtZU9iamVjdC5jYW1lcmFGaWx0ZXIgPiAwICYmIChnYW1lT2JqZWN0LmNhbWVyYUZpbHRlciAmIGNhbWVyYS5faWQpKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRleHR1cmVGcmFtZSA9IGdhbWVPYmplY3QuZnJhbWU7XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYICogZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JYO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgIHZhciBjaGFycyA9IGdhbWVPYmplY3QuZm9udERhdGEuY2hhcnM7XHJcbiAgICB2YXIgbGluZUhlaWdodCA9IGdhbWVPYmplY3QuZm9udERhdGEubGluZUhlaWdodDtcclxuICAgIHZhciBzcHJpdGVCYXRjaCA9IHJlbmRlcmVyLnNwcml0ZUJhdGNoO1xyXG4gICAgdmFyIGFscGhhID0gZ2FtZU9iamVjdC5hbHBoYTtcclxuICAgIHZhciB0aW50VEwgPSBnYW1lT2JqZWN0Ll90aW50VEw7XHJcbiAgICB2YXIgdGludFRSID0gZ2FtZU9iamVjdC5fdGludFRSO1xyXG4gICAgdmFyIHRpbnRCTCA9IGdhbWVPYmplY3QuX3RpbnRCTDtcclxuICAgIHZhciB0aW50QlIgPSBnYW1lT2JqZWN0Ll90aW50QlI7XHJcbiAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHNwcml0ZUJhdGNoLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICB2YXIgdmVydGV4QnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgdmFyIHNyY1ggPSBnYW1lT2JqZWN0Lng7XHJcbiAgICB2YXIgc3JjWSA9IGdhbWVPYmplY3QueTtcclxuICAgIHZhciB0ZXh0dXJlRGF0YSA9IGdhbWVPYmplY3QudGV4dHVyZS5zb3VyY2VbdGV4dHVyZUZyYW1lLnNvdXJjZUluZGV4XTtcclxuICAgIHZhciB0ZXh0dXJlWCA9IHRleHR1cmVGcmFtZS5jdXRYO1xyXG4gICAgdmFyIHRleHR1cmVZID0gdGV4dHVyZUZyYW1lLmN1dFk7XHJcbiAgICB2YXIgdGV4dHVyZVdpZHRoID0gdGV4dHVyZURhdGEud2lkdGg7XHJcbiAgICB2YXIgdGV4dHVyZUhlaWdodCA9IHRleHR1cmVEYXRhLmhlaWdodDtcclxuICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZURhdGEuZ2xUZXh0dXJlO1xyXG4gICAgdmFyIHhBZHZhbmNlID0gMDtcclxuICAgIHZhciB5QWR2YW5jZSA9IDA7XHJcbiAgICB2YXIgaW5kZXhDb3VudCA9IDA7XHJcbiAgICB2YXIgY2hhckNvZGUgPSAwO1xyXG4gICAgdmFyIGdseXBoID0gbnVsbDtcclxuICAgIHZhciBnbHlwaFggPSAwO1xyXG4gICAgdmFyIGdseXBoWSA9IDA7XHJcbiAgICB2YXIgZ2x5cGhXID0gMDtcclxuICAgIHZhciBnbHlwaEggPSAwO1xyXG4gICAgdmFyIHggPSAwO1xyXG4gICAgdmFyIHkgPSAwO1xyXG4gICAgdmFyIHh3ID0gMDtcclxuICAgIHZhciB5aCA9IDA7XHJcbiAgICB2YXIgdW1pbiA9IDA7XHJcbiAgICB2YXIgdW1heCA9IDA7XHJcbiAgICB2YXIgdm1pbiA9IDA7XHJcbiAgICB2YXIgdm1heCA9IDA7XHJcbiAgICB2YXIgbGFzdEdseXBoID0gbnVsbDtcclxuICAgIHZhciBsYXN0Q2hhckNvZGUgPSAwO1xyXG4gICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgIHZhciBjYW1lcmFNYXRyaXggPSBjYW1lcmEubWF0cml4Lm1hdHJpeDtcclxuICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgdmFyIHNjYWxlID0gKGdhbWVPYmplY3QuZm9udFNpemUgLyBnYW1lT2JqZWN0LmZvbnREYXRhLnNpemUpO1xyXG4gICAgdmFyIHJlbmRlclRhcmdldCA9IGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0O1xyXG5cclxuICAgIHRlbXBNYXRyaXguYXBwbHlJVFJTKFxyXG4gICAgICAgIChzcmNYIC0gY2FtZXJhU2Nyb2xsWCkgKyB0ZXh0dXJlRnJhbWUueCwgKHNyY1kgLSBjYW1lcmFTY3JvbGxZKSArIHRleHR1cmVGcmFtZS55LFxyXG4gICAgICAgIC1nYW1lT2JqZWN0LnJvdGF0aW9uLFxyXG4gICAgICAgIGdhbWVPYmplY3Quc2NhbGVYLCBnYW1lT2JqZWN0LnNjYWxlWVxyXG4gICAgKTtcclxuXHJcbiAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgc3JiID0gdGVtcE1hdHJpeE1hdHJpeFsxXTtcclxuICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XHJcbiAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgc3JlID0gdGVtcE1hdHJpeE1hdHJpeFs0XTtcclxuICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XHJcblxyXG4gICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgY21iID0gY2FtZXJhTWF0cml4WzFdO1xyXG4gICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgY21lID0gY2FtZXJhTWF0cml4WzRdO1xyXG4gICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xyXG5cclxuICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcclxuICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcclxuICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcclxuICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjtcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGV4dExlbmd0aDsgKytpbmRleClcclxuICAgIHtcclxuICAgICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpbmRleCk7XHJcblxyXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gMTApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4QWR2YW5jZSA9IDA7XHJcbiAgICAgICAgICAgIGluZGV4Q291bnQgPSAwO1xyXG4gICAgICAgICAgICB5QWR2YW5jZSArPSBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgICBsYXN0R2x5cGggPSBudWxsO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdseXBoID0gY2hhcnNbY2hhckNvZGVdO1xyXG5cclxuICAgICAgICBpZiAoIWdseXBoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbHlwaFggPSB0ZXh0dXJlWCArIGdseXBoLng7XHJcbiAgICAgICAgZ2x5cGhZID0gdGV4dHVyZVkgKyBnbHlwaC55O1xyXG4gICAgICAgIGdseXBoVyA9IGdseXBoLndpZHRoO1xyXG4gICAgICAgIGdseXBoSCA9IGdseXBoLmhlaWdodDtcclxuICAgICAgICB4ID0gKGluZGV4Q291bnQgKyBnbHlwaC54T2Zmc2V0ICsgeEFkdmFuY2UpICogc2NhbGU7XHJcbiAgICAgICAgeSA9IChnbHlwaC55T2Zmc2V0ICsgeUFkdmFuY2UpICogc2NhbGU7XHJcblxyXG4gICAgICAgIGlmIChsYXN0R2x5cGggIT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIga2VybmluZ09mZnNldCA9IGdseXBoLmtlcm5pbmdbbGFzdENoYXJDb2RlXTtcclxuICAgICAgICAgICAgeCArPSAoa2VybmluZ09mZnNldCAhPT0gdW5kZWZpbmVkKSA/IGtlcm5pbmdPZmZzZXQgOiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeEFkdmFuY2UgKz0gZ2x5cGgueEFkdmFuY2U7XHJcbiAgICAgICAgaW5kZXhDb3VudCArPSAxO1xyXG4gICAgICAgIGxhc3RHbHlwaCA9IGdseXBoO1xyXG4gICAgICAgIGxhc3RDaGFyQ29kZSA9IGNoYXJDb2RlO1xyXG5cclxuICAgICAgICAvLyAgTm90aGluZyB0byByZW5kZXIgb3IgYSBzcGFjZT8gVGhlbiBza2lwIHRvIHRoZSBuZXh0IGdseXBoXHJcbiAgICAgICAgaWYgKGdseXBoVyA9PT0gMCB8fCBnbHlwaEggPT09IDAgfHwgY2hhckNvZGUgPT09IDMyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4dyA9IHggKyBnbHlwaFcgKiBzY2FsZTtcclxuICAgICAgICB5aCA9IHkgKyBnbHlwaEggKiBzY2FsZTtcclxuICAgICAgICB0eDAgPSB4ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTAgPSB4ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDEgPSB4ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkxID0geCAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MiA9IHh3ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkyID0geHcgKiBtdmIgKyB5aCAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDMgPSB4dyAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkzID0geHcgKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG4gICAgICAgIHVtaW4gPSBnbHlwaFggLyB0ZXh0dXJlV2lkdGg7XHJcbiAgICAgICAgdW1heCA9IChnbHlwaFggKyBnbHlwaFcpIC8gdGV4dHVyZVdpZHRoO1xyXG4gICAgICAgIHZtaW4gPSBnbHlwaFkgLyB0ZXh0dXJlSGVpZ2h0O1xyXG4gICAgICAgIHZtYXggPSAoZ2x5cGhZICsgZ2x5cGhIKSAvIHRleHR1cmVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChzcHJpdGVCYXRjaC5lbGVtZW50Q291bnQgPj0gc3ByaXRlQmF0Y2gubWF4UGFydGljbGVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3ByaXRlQmF0Y2guZmx1c2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlcmVyKHNwcml0ZUJhdGNoLCB0ZXh0dXJlLCByZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjQpO1xyXG4gICAgICAgIHNwcml0ZUJhdGNoLmVsZW1lbnRDb3VudCArPSA2O1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnRUTDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludEJMO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWF4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWF4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50VFI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtYXg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnRCUjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpdG1hcFRleHRXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgQmxpdHRlckNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmIChHYW1lT2JqZWN0LlJFTkRFUl9NQVNLICE9PSBzcmMucmVuZGVyRmxhZ3MgfHwgKHNyYy5jYW1lcmFGaWx0ZXIgPiAwICYmIChzcmMuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGlzdCA9IHNyYy5nZXRSZW5kZXJMaXN0KCk7XHJcblxyXG4gICAgcmVuZGVyZXIuc2V0QmxlbmRNb2RlKHNyYy5ibGVuZE1vZGUpO1xyXG5cclxuICAgIHZhciBjYSA9IHJlbmRlcmVyLmN1cnJlbnRBbHBoYTtcclxuXHJcbiAgICAvLyAgUmVuZGVyIGJvYnNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgYm9iID0gbGlzdFtpXTtcclxuXHJcbiAgICAgICAgaWYgKGNhICE9PSBib2IuYWxwaGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYSA9IHJlbmRlcmVyLnNldEFscGhhKGJvYi5hbHBoYSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXJlci5ibGl0SW1hZ2UoYm9iLngsIGJvYi55LCBib2IuZnJhbWUsIGNhbWVyYSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJsaXR0ZXJDYW52YXNSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCbGl0dGVyID0gcmVxdWlyZSgnLi9CbGl0dGVyJyk7XHJcbnZhciBCdWlsZEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9CdWlsZEdhbWVPYmplY3QnKTtcclxudmFyIEdhbWVPYmplY3RDcmVhdG9yID0gcmVxdWlyZSgnLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xyXG52YXIgR2V0QWR2YW5jZWRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRBZHZhbmNlZFZhbHVlJyk7XHJcblxyXG4vLyAgV2hlbiByZWdpc3RlcmluZyBhIGZhY3RvcnkgZnVuY3Rpb24gJ3RoaXMnIHJlZmVycyB0byB0aGUgR2FtZU9iamVjdENyZWF0b3IgY29udGV4dC5cclxuXHJcbkdhbWVPYmplY3RDcmVhdG9yLnJlZ2lzdGVyKCdibGl0dGVyJywgZnVuY3Rpb24gKGNvbmZpZylcclxue1xyXG4gICAgdmFyIGtleSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAna2V5JywgbnVsbCk7XHJcbiAgICB2YXIgZnJhbWUgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2ZyYW1lJywgbnVsbCk7XHJcblxyXG4gICAgdmFyIGJsaXR0ZXIgPSBuZXcgQmxpdHRlcih0aGlzLnNjZW5lLCAwLCAwLCBrZXksIGZyYW1lKTtcclxuXHJcbiAgICBCdWlsZEdhbWVPYmplY3QodGhpcy5zY2VuZSwgYmxpdHRlciwgY29uZmlnKTtcclxuXHJcbiAgICByZXR1cm4gYmxpdHRlcjtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCbGl0dGVyID0gcmVxdWlyZSgnLi9CbGl0dGVyJyk7XHJcbnZhciBHYW1lT2JqZWN0RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdEZhY3RvcnknKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0RmFjdG9yeSBjb250ZXh0LlxyXG4vLyAgXHJcbi8vICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9wZXJ0aWVzIGF2YWlsYWJsZSB0byB1c2U6XHJcbi8vICBcclxuLy8gIHRoaXMuc2NlbmUgLSBhIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhhdCBvd25zIHRoZSBHYW1lT2JqZWN0RmFjdG9yeVxyXG4vLyAgdGhpcy5kaXNwbGF5TGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBEaXNwbGF5IExpc3QgdGhlIFNjZW5lIG93bnNcclxuLy8gIHRoaXMudXBkYXRlTGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBVcGRhdGUgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG5cclxuR2FtZU9iamVjdEZhY3RvcnkucmVnaXN0ZXIoJ2JsaXR0ZXInLCBmdW5jdGlvbiAoeCwgeSwga2V5LCBmcmFtZSlcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuZGlzcGxheUxpc3QuYWRkKG5ldyBCbGl0dGVyKHRoaXMuc2NlbmUsIHgsIHksIGtleSwgZnJhbWUpKTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL05PT1AnKTtcclxudmFyIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL05PT1AnKTtcclxuXHJcbmlmIChXRUJHTF9SRU5ERVJFUilcclxue1xyXG4gICAgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuL0JsaXR0ZXJXZWJHTFJlbmRlcmVyJyk7XHJcbn1cclxuXHJcbmlmIChDQU5WQVNfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4vQmxpdHRlckNhbnZhc1JlbmRlcmVyJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlcldlYkdMOiByZW5kZXJXZWJHTCxcclxuICAgIHJlbmRlckNhbnZhczogcmVuZGVyQ2FudmFzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlclJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG5cclxudmFyIEJsaXR0ZXJXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmIChHYW1lT2JqZWN0LlJFTkRFUl9NQVNLICE9PSBzcmMucmVuZGVyRmxhZ3MgfHwgKHNyYy5jYW1lcmFGaWx0ZXIgPiAwICYmIChzcmMuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGlzdCA9IHNyYy5nZXRSZW5kZXJMaXN0KCk7XHJcbiAgICB2YXIgYmxpdHRlckJhdGNoID0gcmVuZGVyZXIuYmxpdHRlckJhdGNoO1xyXG4gICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgdmFyIGEgPSBjYW1lcmFNYXRyaXhbMF07XHJcbiAgICB2YXIgYiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgIHZhciBjID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgdmFyIGQgPSBjYW1lcmFNYXRyaXhbM107XHJcbiAgICB2YXIgZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgIHZhciBmID0gY2FtZXJhTWF0cml4WzVdO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFggPSBjYW1lcmEuc2Nyb2xsWCAqIHNyYy5zY3JvbGxGYWN0b3JYO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWSAqIHNyYy5zY3JvbGxGYWN0b3JZO1xyXG4gICAgdmFyIHJlbmRlclRhcmdldCA9IHNyYy5yZW5kZXJUYXJnZXQ7XHJcblxyXG4gICAgLy8gIFJlbmRlciBib2JzXHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgYm9iID0gbGlzdFtpXTtcclxuICAgICAgICB2YXIgZnJhbWUgPSBib2IuZnJhbWU7XHJcbiAgICAgICAgdmFyIGFscGhhID0gYm9iLmFscGhhO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gYmxpdHRlckJhdGNoLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciB1dnMgPSBmcmFtZS51dnM7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGggKiAoYm9iLmZsaXBYID8gLTEgOiAxKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0ICogKGJvYi5mbGlwWSA/IC0xIDogMSk7XHJcbiAgICAgICAgdmFyIHggPSBib2IueCArIGZyYW1lLnggLSBjYW1lcmFTY3JvbGxYICsgKChmcmFtZS53aWR0aCkgKiAoYm9iLmZsaXBYID8gMSA6IDAuMCkpO1xyXG4gICAgICAgIHZhciB5ID0gYm9iLnkgKyBmcmFtZS55IC0gY2FtZXJhU2Nyb2xsWSArICgoZnJhbWUuaGVpZ2h0KSAqIChib2IuZmxpcFkgPyAxIDogMC4wKSk7XHJcbiAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xyXG4gICAgICAgIHZhciB5aCA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgdmFyIHR4ID0geCAqIGEgKyB5ICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5ID0geCAqIGIgKyB5ICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4dyA9IHh3ICogYSArIHloICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5aCA9IHh3ICogYiArIHloICogZCArIGY7XHJcblxyXG4gICAgICAgIGlmIChibGl0dGVyQmF0Y2guZWxlbWVudENvdW50ID49IGJsaXR0ZXJCYXRjaC5tYXhQYXJ0aWNsZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBibGl0dGVyQmF0Y2guZmx1c2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlcmVyKGJsaXR0ZXJCYXRjaCwgZnJhbWUudGV4dHVyZS5zb3VyY2VbZnJhbWUuc291cmNlSW5kZXhdLmdsVGV4dHVyZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjApO1xyXG4gICAgICAgIGJsaXR0ZXJCYXRjaC5lbGVtZW50Q291bnQgKz0gNjtcclxuICAgICAgICB4ICs9IGZyYW1lLng7XHJcbiAgICAgICAgeSArPSBmcmFtZS55O1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHloO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eHc7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHh3O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCbGl0dGVyV2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBCb2IgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQm9iICh4LCB5LCBmcmFtZSwgdmlzaWJsZSlcclxuICAgIHtcclxuICAgICAgICAvLyAgU2V0IGJ5IHRoZSBEaXNwbGF5TGlzdCBjbGFzc1xyXG4gICAgICAgIHRoaXMucGFyZW50O1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xyXG5cclxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICB0aGlzLl9hbHBoYSA9IDE7XHJcblxyXG4gICAgICAgIHRoaXMuZmxpcFggLSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZsaXBZID0gZmFsc2U7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZXNldEZsaXA6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mbGlwWCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICh4LCB5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGFyZW50LmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4ucmVtb3ZlKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZyYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgdmlzaWJsZToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFscGhhOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbHBoYTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FscGhhID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJvYjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JvYi5qc1xuLy8gbW9kdWxlIGlkID0gNDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFtcCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvQ2xhbXAnKTtcclxuXHJcbi8vICBBbHBoYSBDb21wb25lbnRcclxuXHJcbi8vICBiaXRtYXNrIGZsYWcgZm9yIEdhbWVPYmplY3QucmVuZGVyTWFza1xyXG52YXIgX0ZMQUcgPSAyOyAvLyAwMDEwXHJcblxyXG52YXIgQWxwaGEgPSB7XHJcblxyXG4gICAgX2FscGhhOiAxLFxyXG5cclxuICAgIF9hbHBoYVRMOiAxLFxyXG4gICAgX2FscGhhVFI6IDEsXHJcbiAgICBfYWxwaGFCTDogMSxcclxuICAgIF9hbHBoYUJSOiAxLFxyXG5cclxuICAgIGNsZWFyQWxwaGE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0QWxwaGEoMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEFscGhhOiBmdW5jdGlvbiAodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0b3BMZWZ0ID09PSB1bmRlZmluZWQpIHsgdG9wTGVmdCA9IDE7IH1cclxuXHJcbiAgICAgICAgLy8gIFRyZWF0IGFzIGlmIHRoZXJlIGlzIG9ubHkgb25lIGFscGhhIHZhbHVlIGZvciB0aGUgd2hvbGUgR2FtZSBPYmplY3RcclxuICAgICAgICBpZiAodG9wUmlnaHQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxwaGEgPSB0b3BMZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9hbHBoYVRMID0gQ2xhbXAodG9wTGVmdCwgMCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FscGhhVFIgPSBDbGFtcCh0b3BSaWdodCwgMCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FscGhhQkwgPSBDbGFtcChib3R0b21MZWZ0LCAwLCAxKTtcclxuICAgICAgICAgICAgdGhpcy5fYWxwaGFCUiA9IENsYW1wKGJvdHRvbVJpZ2h0LCAwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgR2xvYmFsIEFscGhhIHZhbHVlLiBJZiBjaGFuZ2VkIHRoaXMgYWRqdXN0cyBhbGwgYWxwaGEgcHJvcGVydGllcyAodG9wTGVmdCwgdG9wUmlnaHQsIGV0YylcclxuICAgIGFscGhhOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbHBoYTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gQ2xhbXAodmFsdWUsIDAsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSB2O1xyXG4gICAgICAgICAgICB0aGlzLl9hbHBoYVRMID0gdjtcclxuICAgICAgICAgICAgdGhpcy5fYWxwaGFUUiA9IHY7XHJcbiAgICAgICAgICAgIHRoaXMuX2FscGhhQkwgPSB2O1xyXG4gICAgICAgICAgICB0aGlzLl9hbHBoYUJSID0gdjtcclxuXHJcbiAgICAgICAgICAgIGlmICh2ID09PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzICY9IH5fRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgfD0gX0ZMQUc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQWRqdXN0cyB0aGUgYWxwaGEgdmFsdWUgb2YgdGhlIHRvcC1sZWZ0IHZlcnRleCAoV2ViR0wgb25seSlcclxuICAgIGFscGhhVG9wTGVmdDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGFUTDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gQ2xhbXAodmFsdWUsIDAsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fYWxwaGFUTCA9IHZcclxuXHJcbiAgICAgICAgICAgIGlmICh2ICE9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzIHw9IF9GTEFHO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGFUb3BSaWdodDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGFUUjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gQ2xhbXAodmFsdWUsIDAsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fYWxwaGFUUiA9IHZcclxuXHJcbiAgICAgICAgICAgIGlmICh2ICE9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzIHw9IF9GTEFHO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGFCb3R0b21MZWZ0OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbHBoYUJMO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHYgPSBDbGFtcCh2YWx1ZSwgMCwgMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9hbHBoYUJMID0gdlxyXG5cclxuICAgICAgICAgICAgaWYgKHYgIT09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgfD0gX0ZMQUc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbHBoYUJvdHRvbVJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbHBoYUJSO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHYgPSBDbGFtcCh2YWx1ZSwgMCwgMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9hbHBoYUJSID0gdlxyXG5cclxuICAgICAgICAgICAgaWYgKHYgIT09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgfD0gX0ZMQUc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWxwaGE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9BbHBoYS5qc1xuLy8gbW9kdWxlIGlkID0gNDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uLycpO1xyXG5cclxuLy8gIEdhbWUgT2JqZWN0IEFuaW1hdGlvbiBDb250cm9sbGVyXHJcblxyXG52YXIgQW5pbWF0aW9uID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbiAocGFyZW50KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBTcHJpdGUgLyBHYW1lIE9iamVjdFxyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIgPSBwYXJlbnQuc2NlbmUuc3lzLmFuaW1zO1xyXG5cclxuICAgICAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuZXZlbnRzLm9uY2UoJ1JFTU9WRV9BTklNQVRJT05fRVZFTlQnLCB0aGlzLnJlbW92ZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gIFJlZmVyZW5jZSB0byB0aGUgUGhhc2VyLkFuaW1hdGlvbiBvYmplY3RcclxuICAgICAgICB0aGlzLmN1cnJlbnRBbmltID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gIFJlZmVyZW5jZSB0byB0aGUgUGhhc2VyLkFuaW1hdGlvbkZyYW1lIG9iamVjdFxyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gIEFuaW1hdGlvbiBzcGVjaWZpYyB2YWx1ZXNcclxuICAgICAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgICAgICAvLyAgU2NhbGUgdGhlIHRpbWUgKG1ha2UgaXQgZ28gZmFzdGVyIC8gc2xvd2VyKVxyXG4gICAgICAgIC8vICBGYWN0b3IgdGhhdCdzIHVzZWQgdG8gc2NhbGUgdGltZSB3aGVyZSAxID0gbm9ybWFsIHNwZWVkICh0aGUgZGVmYXVsdCksIDAuNSA9IGhhbGYgc3BlZWQsIDIgPSBkb3VibGUgc3BlZWQsIGV0Yy5cclxuICAgICAgICB0aGlzLl90aW1lU2NhbGUgPSAxO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGZyYW1lIHJhdGUgb2YgcGxheWJhY2sgaW4gZnJhbWVzIHBlciBzZWNvbmQgKGRlZmF1bHQgMjQgaWYgZHVyYXRpb24gaXMgbnVsbClcclxuICAgICAgICB0aGlzLmZyYW1lUmF0ZSA9IDA7XHJcblxyXG4gICAgICAgIC8vICBIb3cgbG9uZyB0aGUgYW5pbWF0aW9uIHNob3VsZCBwbGF5IGZvci4gSWYgZnJhbWVSYXRlIGlzIHNldCBpdCBvdmVycmlkZXMgdGhpcyB2YWx1ZVxyXG4gICAgICAgIC8vICBvdGhlcndpc2UgZnJhbWVSYXRlIGlzIGRlcml2ZWQgZnJvbSBkdXJhdGlvblxyXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xyXG5cclxuICAgICAgICAvLyAgbXMgcGVyIGZyYW1lICh3aXRob3V0IGluY2x1ZGluZyBmcmFtZSBzcGVjaWZpYyBtb2RpZmllcnMpXHJcbiAgICAgICAgdGhpcy5tc1BlckZyYW1lID0gMDtcclxuXHJcbiAgICAgICAgLy8gIFNraXAgZnJhbWVzIGlmIHRoZSB0aW1lIGxhZ3MsIG9yIGFsd2F5cyBhZHZhbmNlZCBhbnl3YXk/XHJcbiAgICAgICAgdGhpcy5za2lwTWlzc2VkRnJhbWVzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gIERlbGF5IGJlZm9yZSBzdGFydGluZyBwbGF5YmFjayAoaW4gc2Vjb25kcylcclxuICAgICAgICB0aGlzLl9kZWxheSA9IDA7XHJcblxyXG4gICAgICAgIC8vICBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBhbmltYXRpb24gKC0xIGZvciBpbmZpbml0eSlcclxuICAgICAgICB0aGlzLl9yZXBlYXQgPSAwO1xyXG5cclxuICAgICAgICAvLyAgRGVsYXkgYmVmb3JlIHRoZSByZXBlYXQgc3RhcnRzIChpbiBzZWNvbmRzKVxyXG4gICAgICAgIHRoaXMuX3JlcGVhdERlbGF5ID0gMDtcclxuXHJcbiAgICAgICAgLy8gIFNob3VsZCB0aGUgYW5pbWF0aW9uIHlveW8/IChyZXZlcnNlIGJhY2sgZG93biB0byB0aGUgc3RhcnQpIGJlZm9yZSByZXBlYXRpbmc/XHJcbiAgICAgICAgdGhpcy5feW95byA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyAgUGxheWhlYWQgdmFsdWVzXHJcbiAgICAgICAgLy8gIC0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgICAgICAvLyAgTW92ZSB0aGUgcGxheWhlYWQgZm9yd2FyZCAodHJ1ZSkgb3IgaW4gcmV2ZXJzZSAoZmFsc2UpXHJcbiAgICAgICAgdGhpcy5mb3J3YXJkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IDA7XHJcbiAgICAgICAgdGhpcy5uZXh0VGljayA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucmVwZWF0Q291bnRlciA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucGVuZGluZ1JlcGVhdCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl93YXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrQXJncyA9IFsgcGFyZW50LCBudWxsIF07XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlUGFyYW1zID0gW107XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGVsYXk6IENvbXBvbmVudHMuRGVsYXksXHJcbiAgICBkZWxheWVkUGxheTogQ29tcG9uZW50cy5EZWxheWVkUGxheSxcclxuICAgIGdldEN1cnJlbnRLZXk6IENvbXBvbmVudHMuR2V0Q3VycmVudEtleSxcclxuICAgIGxvYWQ6IENvbXBvbmVudHMuTG9hZCxcclxuICAgIHBhdXNlOiBDb21wb25lbnRzLlBhdXNlLFxyXG4gICAgcGF1c2VkOiBDb21wb25lbnRzLlBhdXNlZCxcclxuICAgIHBsYXk6IENvbXBvbmVudHMuUGxheSxcclxuICAgIHByb2dyZXNzOiBDb21wb25lbnRzLlByb2dyZXNzLFxyXG4gICAgcmVtb3ZlOiBDb21wb25lbnRzLlJlbW92ZSxcclxuICAgIHJlcGVhdDogQ29tcG9uZW50cy5SZXBlYXQsXHJcbiAgICByZXBlYXREZWxheTogQ29tcG9uZW50cy5SZXBlYXREZWxheSxcclxuICAgIHJlc3RhcnQ6IENvbXBvbmVudHMuUmVzdGFydCxcclxuICAgIHJlc3VtZTogQ29tcG9uZW50cy5SZXN1bWUsXHJcbiAgICBzdG9wOiBDb21wb25lbnRzLlN0b3AsXHJcbiAgICB0aW1lU2NhbGU6IENvbXBvbmVudHMuVGltZVNjYWxlLFxyXG4gICAgdG90YWxGcmFtZXM6IENvbXBvbmVudHMuVG90YWxGcmFtZXMsXHJcbiAgICB0b3RhbFByb2dyZXNzOiBDb21wb25lbnRzLlRvdGFsUHJvZ3Jlc3MsXHJcbiAgICB1cGRhdGU6IENvbXBvbmVudHMuVXBkYXRlLFxyXG4gICAgdXBkYXRlRnJhbWU6IENvbXBvbmVudHMuVXBkYXRlRnJhbWUsXHJcbiAgICB5b3lvOiBDb21wb25lbnRzLllveW9cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9BbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDQ0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmxlbmRNb2RlcyA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVyL0JsZW5kTW9kZXMnKTtcclxuXHJcbi8vICBCbGVuZE1vZGUgQ29tcG9uZW50XHJcblxyXG52YXIgQmxlbmRNb2RlID0ge1xyXG5cclxuICAgIF9ibGVuZE1vZGU6IEJsZW5kTW9kZXMuTk9STUFMLFxyXG5cclxuICAgIGJsZW5kTW9kZToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsdWUgfCAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kTW9kZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCbGVuZE1vZGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9CbGVuZE1vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29tcHV0ZWRTaXplID0ge1xyXG5cclxuICAgIHdpZHRoOiAwLFxyXG4gICAgaGVpZ2h0OiAwLFxyXG5cclxuICAgIGRpc3BsYXlXaWR0aDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVggKiB0aGlzLndpZHRoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSB2YWx1ZSAvIHRoaXMud2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGxheUhlaWdodDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVkgKiB0aGlzLmhlaWdodDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gdmFsdWUgLyB0aGlzLmhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29tcHV0ZWRTaXplO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvQ29tcHV0ZWRTaXplLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBEYXRhUHJveHkgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gRGF0YVByb3h5IChzY2VuZSwgZ2FtZU9iamVjdClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBzY2VuZS5zeXMuZGF0YVN0b3JlO1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuc2V0KHRoaXMuZ2FtZU9iamVjdCwga2V5LCB2YWx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldCh0aGlzLmdhbWVPYmplY3QsIGtleSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldEFsbCh0aGlzLmdhbWVPYmplY3QpO1xyXG4gICAgfSxcclxuXHJcbiAgICBxdWVyeTogZnVuY3Rpb24gKHNlYXJjaClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLnF1ZXJ5KHRoaXMuZ2FtZU9iamVjdCwgc2VhcmNoKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmVmb3JlOiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaywgc2NvcGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5iZWZvcmUodGhpcy5nYW1lT2JqZWN0LCBrZXksIGNhbGxiYWNrLCBzY29wZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFmdGVyOiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaywgc2NvcGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5hZnRlcih0aGlzLmdhbWVPYmplY3QsIGtleSwgY2FsbGJhY2ssIHNjb3BlKTtcclxuICAgIH0sXHJcblxyXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYXJncyA9IFsgdGhpcy5nYW1lT2JqZWN0LCBudWxsLCB1bmRlZmluZWQgXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZWFjaCh0aGlzLmdhbWVPYmplY3QsIGNhbGxiYWNrLCBzY29wZSwgYXJncyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1lcmdlOiBmdW5jdGlvbiAoZGF0YSwgb3ZlcndyaXRlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIubWVyZ2UodGhpcy5nYW1lT2JqZWN0LCBkYXRhLCBvdmVyd3JpdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5yZW1vdmUodGhpcy5nYW1lT2JqZWN0LCBrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5yZW1vdmVMaXN0ZW5lcnModGhpcy5nYW1lT2JqZWN0LCBrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwb3A6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5wb3AodGhpcy5nYW1lT2JqZWN0LCBrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXM6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5oYXModGhpcy5nYW1lT2JqZWN0LCBrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLnJlc2V0KHRoaXMuZ2FtZU9iamVjdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZyZWV6ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIuZnJlZXplKHRoaXMuZ2FtZU9iamVjdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVuZnJlZXplOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci51bmZyZWV6ZSh0aGlzLmdhbWVPYmplY3QpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5raWxsKHRoaXMuZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXRhUHJveHk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9EYXRhUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IDQ0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxpcCA9IHtcclxuXHJcbiAgICBmbGlwWDogZmFsc2UsXHJcbiAgICBmbGlwWTogZmFsc2UsXHJcblxyXG4gICAgdG9nZ2xlRmxpcFg6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mbGlwWCA9ICF0aGlzLmZsaXBYO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgdG9nZ2xlRmxpcFk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mbGlwWSA9ICF0aGlzLmZsaXBZO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RmxpcFg6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZsaXBYID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGbGlwWTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZmxpcFkgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZsaXA6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZmxpcFggPSB4O1xyXG4gICAgICAgIHRoaXMuZmxpcFkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRGbGlwOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZmxpcFggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZsaXBZID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbGlwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvRmxpcC5qc1xuLy8gbW9kdWxlIGlkID0gNDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRCb3VuZHMgPSB7XHJcblxyXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbiAob3V0cHV0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTsgfVxyXG5cclxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuXHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLmRpc3BsYXlXaWR0aDtcclxuICAgICAgICB2YXIgaCA9IHRoaXMuZGlzcGxheUhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJvdGF0aW9uO1xyXG5cclxuICAgICAgICB2YXIgd2N0ID0gdyAqIE1hdGguY29zKHIpO1xyXG4gICAgICAgIHZhciBoY3QgPSBoICogTWF0aC5jb3Mocik7XHJcblxyXG4gICAgICAgIHZhciB3c3QgPSB3ICogTWF0aC5zaW4ocik7XHJcbiAgICAgICAgdmFyIGhzdCA9IGggKiBNYXRoLnNpbihyKTtcclxuXHJcbiAgICAgICAgdmFyIHhNaW4gPSB4O1xyXG4gICAgICAgIHZhciB4TWF4ID0geDtcclxuICAgICAgICB2YXIgeU1pbiA9IHk7XHJcbiAgICAgICAgdmFyIHlNYXggPSB5O1xyXG5cclxuICAgICAgICBpZiAociA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAociA8IDEuNTcwNzk2MzI2Nzk0ODk2NilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gMCA8IHRoZXRhIDwgOTBcclxuICAgICAgICAgICAgICAgIHlNYXggPSB5ICsgaGN0ICsgd3N0O1xyXG4gICAgICAgICAgICAgICAgeE1pbiA9IHggLSBoc3Q7XHJcbiAgICAgICAgICAgICAgICB4TWF4ID0geCArIHdjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIDkwIDw9IHRoZXRhIDw9IDE4MFxyXG4gICAgICAgICAgICAgICAgeU1pbiA9IHkgKyBoY3Q7XHJcbiAgICAgICAgICAgICAgICB5TWF4ID0geSArIHdzdDtcclxuICAgICAgICAgICAgICAgIHhNaW4gPSB4IC0gaHN0ICsgd2N0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHIgPiAtMS41NzA3OTYzMjY3OTQ4OTY2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gLTkwIDwgdGhldGEgPD0gMFxyXG4gICAgICAgICAgICB5TWluID0geSArIHdzdDtcclxuICAgICAgICAgICAgeU1heCA9IHkgKyBoY3Q7XHJcbiAgICAgICAgICAgIHhNYXggPSB4ICsgd2N0IC0gaHN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAtMTgwIDw9IHRoZXRhIDw9IC05MFxyXG4gICAgICAgICAgICB5TWluID0geSArIHdzdCArIGhjdDtcclxuICAgICAgICAgICAgeE1pbiA9IHggKyB3Y3Q7XHJcbiAgICAgICAgICAgIHhNYXggPSB4IC0gaHN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3V0cHV0LnggPSB4TWluO1xyXG4gICAgICAgIG91dHB1dC55ID0geU1pbjtcclxuICAgICAgICBvdXRwdXQud2lkdGggPSB4TWF4IC0geE1pbjtcclxuICAgICAgICBvdXRwdXQuaGVpZ2h0ID0geU1heCAtIHlNaW47XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEJvdW5kcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL0dldEJvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gNDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBPcmlnaW4gQ29tcG9uZW50XHJcbi8vICBWYWx1ZXMgYXJlIG5vcm1hbGl6ZWQsIGdpdmVuIGluIHRoZSByYW5nZSAwIHRvIDEuXHJcbi8vICBEaXNwbGF5IHZhbHVlcyBjb250YWluIHRoZSBjYWxjdWxhdGVkIHBpeGVsIHZhbHVlcy5cclxuXHJcbnZhciBPcmlnaW4gPSB7XHJcblxyXG4gICAgb3JpZ2luWDogMC41LFxyXG4gICAgb3JpZ2luWTogMC41LFxyXG5cclxuICAgIC8vICBSRUFEIE9OTFlcclxuICAgIGRpc3BsYXlPcmlnaW5YOiAwLFxyXG4gICAgZGlzcGxheU9yaWdpblk6IDAsXHJcblxyXG4gICAgc2V0T3JpZ2luOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwLjU7IH1cclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMub3JpZ2luWCA9IHg7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlT3JpZ2luKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldERpc3BsYXlPcmlnaW46IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGxheU9yaWdpblggPSB4O1xyXG4gICAgICAgIHRoaXMuZGlzcGxheU9yaWdpblkgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLm9yaWdpblggPSB0aGlzLndpZHRoIC8geDtcclxuICAgICAgICB0aGlzLm9yaWdpblkgPSB0aGlzLmhlaWdodCAvIHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVPcmlnaW46IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5T3JpZ2luWCA9IE1hdGgucm91bmQodGhpcy5vcmlnaW5YICogdGhpcy53aWR0aCk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5T3JpZ2luWSA9IE1hdGgucm91bmQodGhpcy5vcmlnaW5ZICogdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9yaWdpbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL09yaWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gNDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZW5kZXJUYXJnZXQgPSB7XHJcblxyXG4gICAgcmVuZGVyVGFyZ2V0OiBudWxsXHJcbiAgICBcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyVGFyZ2V0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9SZW5kZXJUYXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQ1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2NhbGVNb2RlcyA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVyL1NjYWxlTW9kZXMnKTtcclxuXHJcbi8vICBTY2FsZU1vZGUgQ29tcG9uZW50XHJcblxyXG52YXIgU2NhbGVNb2RlID0ge1xyXG5cclxuICAgIF9zY2FsZU1vZGU6IFNjYWxlTW9kZXMuREVGQVVMVCxcclxuXHJcbiAgICBzY2FsZU1vZGU6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlTW9kZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gU2NhbGVNb2Rlcy5MSU5FQVIgfHwgdmFsdWUgPT09IFNjYWxlTW9kZXMuTkVBUkVTVClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2NhbGVNb2RlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTY2FsZU1vZGU6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNjYWxlTW9kZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlTW9kZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1NjYWxlTW9kZS5qc1xuLy8gbW9kdWxlIGlkID0gNDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTY3JvbGxGYWN0b3IgPSB7XHJcblxyXG4gICAgc2Nyb2xsRmFjdG9yWDogMS4wLFxyXG4gICAgc2Nyb2xsRmFjdG9yWTogMS4wLFxyXG5cclxuICAgIHNldFNjcm9sbEZhY3RvcjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnNjcm9sbEZhY3RvclggPSB4O1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRmFjdG9yWSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsRmFjdG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvU2Nyb2xsRmFjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNpemUgPSB7XHJcblxyXG4gICAgd2lkdGg6IDAsXHJcbiAgICBoZWlnaHQ6IDAsXHJcblxyXG4gICAgZGlzcGxheVdpZHRoOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlWCAqIHRoaXMuZnJhbWUucmVhbFdpZHRoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSB2YWx1ZSAvIHRoaXMuZnJhbWUucmVhbFdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BsYXlIZWlnaHQ6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVZICogdGhpcy5mcmFtZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSB2YWx1ZSAvIHRoaXMuZnJhbWUucmVhbEhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaXplVG9GcmFtZTogZnVuY3Rpb24gKGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChmcmFtZSA9PT0gdW5kZWZpbmVkKSB7IGZyYW1lID0gdGhpcy5mcmFtZTsgfVxyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gZnJhbWUucmVhbFdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZnJhbWUucmVhbEhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldERpc3BsYXlTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRpc3BsYXlXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheUhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaXplO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvU2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUZXh0dXJlIENvbXBvbmVudFxyXG5cclxuLy8gIGJpdG1hc2sgZmxhZyBmb3IgR2FtZU9iamVjdC5yZW5kZXJNYXNrXHJcbnZhciBfRkxBRyA9IDg7IC8vIDEwMDBcclxuXHJcbnZhciBUZXh0dXJlID0ge1xyXG5cclxuICAgIHRleHR1cmU6IG51bGwsXHJcbiAgICBmcmFtZTogbnVsbCxcclxuXHJcbiAgICBzZXRUZXh0dXJlOiBmdW5jdGlvbiAoa2V5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLnNjZW5lLnN5cy50ZXh0dXJlcy5nZXQoa2V5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RnJhbWUoZnJhbWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcmFtZTogZnVuY3Rpb24gKGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLnRleHR1cmUuZ2V0KGZyYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmZyYW1lLmN1dFdpZHRoIHx8ICF0aGlzLmZyYW1lLmN1dEhlaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgJj0gfl9GTEFHO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzIHw9IF9GTEFHO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvVGV4dHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gNDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgR2V0Q29sb3IgPSBmdW5jdGlvbiAodmFsdWUpXHJcbntcclxuICAgIHJldHVybiAodmFsdWUgPj4gMTYpICsgKHZhbHVlICYgMHhmZjAwKSArICgodmFsdWUgJiAweGZmKSA8PCAxNik7XHJcbn07XHJcblxyXG52YXIgVGludCA9IHtcclxuXHJcbiAgICAvLyAgMDogdG9wTGVmdCwgMTogdG9wUmlnaHQsIDI6IGJvdHRvbUxlZnQsIDM6IGJvdHRvbVJpZ2h0XHJcbiAgICBfdGludFRMOiAxNjc3NzIxNSxcclxuICAgIF90aW50VFI6IDE2Nzc3MjE1LFxyXG4gICAgX3RpbnRCTDogMTY3NzcyMTUsXHJcbiAgICBfdGludEJSOiAxNjc3NzIxNSxcclxuXHJcbiAgICBjbGVhclRpbnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zZXRUaW50KDB4ZmZmZmZmKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRpbnQ6IGZ1bmN0aW9uICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRvcExlZnQgPT09IHVuZGVmaW5lZCkgeyB0b3BMZWZ0ID0gMHhmZmZmZmY7IH1cclxuXHJcbiAgICAgICAgaWYgKHRvcFJpZ2h0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0b3BSaWdodCA9IHRvcExlZnQ7XHJcbiAgICAgICAgICAgIGJvdHRvbUxlZnQgPSB0b3BMZWZ0O1xyXG4gICAgICAgICAgICBib3R0b21SaWdodCA9IHRvcExlZnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl90aW50VEwgPSBHZXRDb2xvcih0b3BMZWZ0KTtcclxuICAgICAgICB0aGlzLl90aW50VFIgPSBHZXRDb2xvcih0b3BSaWdodCk7XHJcbiAgICAgICAgdGhpcy5fdGludEJMID0gR2V0Q29sb3IoYm90dG9tTGVmdCk7XHJcbiAgICAgICAgdGhpcy5fdGludEJSID0gR2V0Q29sb3IoYm90dG9tUmlnaHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgdGludFRvcExlZnQ6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnRUTDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbnRUTCA9IEdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0aW50VG9wUmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnRUUjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbnRUUiA9IEdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0aW50Qm90dG9tTGVmdDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludEJMO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fdGludEJMID0gR2V0Q29sb3IodmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRpbnRCb3R0b21SaWdodDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludEJSO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fdGludEJSID0gR2V0Q29sb3IodmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRpbnQ6IHtcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNldFRpbnQodmFsdWUsIHZhbHVlLCB2YWx1ZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9UaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0NTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIERlZmF1bHQgR2FtZSBPYmplY3QgSlNPTiBleHBvcnRcclxuLy8gIElzIGV4dGVuZGVkIGZ1cnRoZXIgYnkgR2FtZSBPYmplY3Qgc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zXHJcblxyXG52YXIgVG9KU09OID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHZhciBvdXQgPSB7XHJcbiAgICAgICAgbmFtZTogZ2FtZU9iamVjdC5uYW1lLFxyXG4gICAgICAgIHR5cGU6IGdhbWVPYmplY3QudHlwZSxcclxuICAgICAgICB4OiBnYW1lT2JqZWN0LngsXHJcbiAgICAgICAgeTogZ2FtZU9iamVjdC55LFxyXG4gICAgICAgIGRlcHRoOiBnYW1lT2JqZWN0LmRlcHRoLFxyXG4gICAgICAgIHNjYWxlOiB7XHJcbiAgICAgICAgICAgIHg6IGdhbWVPYmplY3Quc2NhbGVYLFxyXG4gICAgICAgICAgICB5OiBnYW1lT2JqZWN0LnNjYWxlWVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3JpZ2luOiB7XHJcbiAgICAgICAgICAgIHg6IGdhbWVPYmplY3Qub3JpZ2luWCxcclxuICAgICAgICAgICAgeTogZ2FtZU9iamVjdC5vcmlnaW5ZXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmbGlwWDogZ2FtZU9iamVjdC5mbGlwWCxcclxuICAgICAgICBmbGlwWTogZ2FtZU9iamVjdC5mbGlwWSxcclxuICAgICAgICByb3RhdGlvbjogZ2FtZU9iamVjdC5yb3RhdGlvbixcclxuICAgICAgICBhbHBoYTogZ2FtZU9iamVjdC5hbHBoYSxcclxuICAgICAgICB2aXNpYmxlOiBnYW1lT2JqZWN0LnZpc2libGUsXHJcbiAgICAgICAgc2NhbGVNb2RlOiBnYW1lT2JqZWN0LnNjYWxlTW9kZSxcclxuICAgICAgICBibGVuZE1vZGU6IGdhbWVPYmplY3QuYmxlbmRNb2RlLFxyXG4gICAgICAgIHRleHR1cmVLZXk6ICcnLFxyXG4gICAgICAgIGZyYW1lS2V5OiAnJyxcclxuICAgICAgICBkYXRhOiB7fVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoZ2FtZU9iamVjdC50ZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIG91dC50ZXh0dXJlS2V5ID0gZ2FtZU9iamVjdC50ZXh0dXJlLmtleTtcclxuICAgICAgICBvdXQuZnJhbWVLZXkgPSBnYW1lT2JqZWN0LmZyYW1lLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9KU09OO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvVG9KU09OLmpzXG4vLyBtb2R1bGUgaWQgPSA0NThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBXcmFwQW5nbGUgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2FuZ2xlL1dyYXAnKTtcclxudmFyIFdyYXBBbmdsZURlZ3JlZXMgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2FuZ2xlL1dyYXBEZWdyZWVzJyk7XHJcblxyXG4vLyAgZ2xvYmFsIGJpdG1hc2sgZmxhZyBmb3IgR2FtZU9iamVjdC5yZW5kZXJNYXNrICh1c2VkIGJ5IFNjYWxlKVxyXG52YXIgX0ZMQUcgPSA0OyAvLyAwMTAwXHJcblxyXG4vLyAgVHJhbnNmb3JtIENvbXBvbmVudFxyXG5cclxudmFyIFRyYW5zZm9ybSA9IHtcclxuXHJcbiAgICAvLyAgXCJwcml2YXRlXCIgcHJvcGVydGllc1xyXG4gICAgX3NjYWxlWDogMSxcclxuICAgIF9zY2FsZVk6IDEsXHJcbiAgICBfcm90YXRpb246IDAsXHJcbiAgICBfZGVwdGg6IDAsXHJcblxyXG4gICAgLy8gIHB1YmxpYyBwcm9wZXJ0aWVzIC8gbWV0aG9kc1xyXG5cclxuICAgIHg6IDAsXHJcbiAgICB5OiAwLFxyXG4gICAgejogMCxcclxuICAgIHc6IDAsXHJcblxyXG4gICAgZGVwdGg6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlcHRoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5zeXMuc29ydENoaWxkcmVuRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGVYOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZVggPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZVggPT09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgJj0gfl9GTEFHO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyB8PSBfRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlWToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc2NhbGVZID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc2NhbGVZID09PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzICY9IH5fRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgfD0gX0ZMQUc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmdsZToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gV3JhcEFuZ2xlRGVncmVlcyh0aGlzLl9yb3RhdGlvbiAqIE1BVEhfQ09OU1QuUkFEX1RPX0RFRyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgdmFsdWUgaXMgaW4gZGVncmVlc1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gV3JhcEFuZ2xlRGVncmVlcyh2YWx1ZSkgKiBNQVRIX0NPTlNULkRFR19UT19SQUQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGlvbjoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb247XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgdmFsdWUgaXMgaW4gcmFkaWFuc1xyXG4gICAgICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IFdyYXBBbmdsZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHksIHosIHcpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuICAgICAgICBpZiAoeiA9PT0gdW5kZWZpbmVkKSB7IHogPSAwOyB9XHJcbiAgICAgICAgaWYgKHcgPT09IHVuZGVmaW5lZCkgeyB3ID0gMDsgfVxyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy56ID0gejtcclxuICAgICAgICB0aGlzLncgPSB3O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Um90YXRpb246IGZ1bmN0aW9uIChyYWRpYW5zKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyYWRpYW5zID09PSB1bmRlZmluZWQpIHsgcmFkaWFucyA9IDA7IH1cclxuXHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJhZGlhbnM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBbmdsZTogZnVuY3Rpb24gKGRlZ3JlZXMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGRlZ3JlZXMgPT09IHVuZGVmaW5lZCkgeyBkZWdyZWVzID0gMDsgfVxyXG5cclxuICAgICAgICB0aGlzLmFuZ2xlID0gZGVncmVlcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAxOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnNjYWxlWCA9IHg7XHJcbiAgICAgICAgdGhpcy5zY2FsZVkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0WjogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IHZhbHVlID0gMDsgfVxyXG5cclxuICAgICAgICB0aGlzLnogPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFc6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgeyB2YWx1ZSA9IDA7IH1cclxuXHJcbiAgICAgICAgdGhpcy53ID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXREZXB0aDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IHZhbHVlID0gMDsgfVxyXG5cclxuICAgICAgICB0aGlzLmRlcHRoID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvVHJhbnNmb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbi8vICBWaXNpYmxlIENvbXBvbmVudFxyXG5cclxuLy8gIGJpdG1hc2sgZmxhZyBmb3IgR2FtZU9iamVjdC5yZW5kZXJNYXNrXHJcbnZhciBfRkxBRyA9IDE7IC8vIDAwMDFcclxuXHJcbnZhciBWaXNpYmxlID0ge1xyXG5cclxuICAgIF92aXNpYmxlOiB0cnVlLFxyXG5cclxuICAgIHZpc2libGU6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyB8PSBfRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgJj0gfl9GTEFHO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVmlzaWJsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1Zpc2libGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgR2V0cyBvciBzZXRzIHRoZSBhbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIGJldHdlZW4gcmVwZWF0cy5cclxuLy8gIEZvciBleGFtcGxlLCBpZiByZXBlYXQgaXMgMiBhbmQgcmVwZWF0RGVsYXkgaXMgMSwgdGhlIGFuaW1hdGlvbiB3aWxsIHBsYXkgaW5pdGlhbGx5LFxyXG4vLyAgdGhlbiB3YWl0IGZvciAxIHNlY29uZCBiZWZvcmUgaXQgcmVwZWF0cywgdGhlbiBwbGF5IGFnYWluLCB0aGVuIHdhaXQgMSBzZWNvbmQgYWdhaW5cclxuLy8gIGJlZm9yZSBkb2luZyBpdHMgZmluYWwgcmVwZWF0LlxyXG5cclxudmFyIERlbGF5ID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVsYXk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fZGVsYXkgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlbGF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL0RlbGF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERlbGF5ZWRQbGF5ID0gZnVuY3Rpb24gKGRlbGF5LCBrZXksIHN0YXJ0RnJhbWUpXHJcbntcclxuICAgIHRoaXMucGxheShrZXksIHN0YXJ0RnJhbWUpO1xyXG5cclxuICAgIHRoaXMubmV4dFRpY2sgKz0gKGRlbGF5ICogMTAwMCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlbGF5ZWRQbGF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL0RlbGF5ZWRQbGF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEN1cnJlbnRLZXkgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICBpZiAodGhpcy5jdXJyZW50QW5pbSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50QW5pbS5rZXk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEN1cnJlbnRLZXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vR2V0Q3VycmVudEtleS5qc1xuLy8gbW9kdWxlIGlkID0gNDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMb2FkID0gZnVuY3Rpb24gKGtleSwgc3RhcnRGcmFtZSlcclxue1xyXG4gICAgaWYgKHN0YXJ0RnJhbWUgPT09IHVuZGVmaW5lZCkgeyBzdGFydEZyYW1lID0gMDsgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzUGxheWluZylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgTG9hZCB0aGUgbmV3IGFuaW1hdGlvbiBpblxyXG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLmxvYWQodGhpcywga2V5LCBzdGFydEZyYW1lKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTG9hZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9Mb2FkLmpzXG4vLyBtb2R1bGUgaWQgPSA0NjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdXNlID0gZnVuY3Rpb24gKGF0RnJhbWUpXHJcbntcclxuICAgIGlmICghdGhpcy5fcGF1c2VkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fd2FzUGxheWluZyA9IHRoaXMuaXNQbGF5aW5nO1xyXG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGF0RnJhbWUgIT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUZyYW1lKGF0RnJhbWUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGF1c2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vUGF1c2UuanNcbi8vIG1vZHVsZSBpZCA9IDQ2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF1c2VkID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICAvLyAgU2V0dGVyXHJcbiAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF1c2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhdXNlZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9QYXVzZWQuanNcbi8vIG1vZHVsZSBpZCA9IDQ2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGxheSA9IGZ1bmN0aW9uIChrZXksIGlnbm9yZUlmUGxheWluZywgc3RhcnRGcmFtZSlcclxue1xyXG4gICAgaWYgKGlnbm9yZUlmUGxheWluZyA9PT0gdW5kZWZpbmVkKSB7IGlnbm9yZUlmUGxheWluZyA9IGZhbHNlOyB9XHJcbiAgICBpZiAoc3RhcnRGcmFtZSA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0RnJhbWUgPSAwOyB9XHJcblxyXG4gICAgaWYgKGlnbm9yZUlmUGxheWluZyAmJiB0aGlzLmlzUGxheWluZyAmJiB0aGlzLmN1cnJlbnRBbmltLmtleSA9PT0ga2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubG9hZChrZXksIHN0YXJ0RnJhbWUpO1xyXG5cclxuICAgIHZhciBhbmltID0gdGhpcy5jdXJyZW50QW5pbTtcclxuXHJcbiAgICAvLyAgU2hvdWxkIGdpdmUgdXMgOSwwMDcsMTk5LDI1NCw3NDAsOTkxIHNhZmUgcmVwZWF0c1xyXG4gICAgdGhpcy5yZXBlYXRDb3VudGVyID0gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiB0aGlzLl9yZXBlYXQ7XHJcblxyXG4gICAgYW5pbS5nZXRGaXJzdFRpY2sodGhpcyk7XHJcblxyXG4gICAgdGhpcy5mb3J3YXJkID0gdHJ1ZTtcclxuICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgIHRoaXMucGVuZGluZ1JlcGVhdCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChhbmltLnNob3dPblN0YXJ0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGFyZW50LnZpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhbmltLm9uU3RhcnQpXHJcbiAgICB7XHJcbiAgICAgICAgYW5pbS5vblN0YXJ0LmFwcGx5KGFuaW0uY2FsbGJhY2tTY29wZSwgdGhpcy5fY2FsbGJhY2tBcmdzLmNvbmNhdChhbmltLm9uU3RhcnRQYXJhbXMpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGxheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9QbGF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0Njdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFZhbHVlIGJldHdlZW4gMCBhbmQgMS4gSG93IGZhciB0aGlzIGFuaW1hdGlvbiBpcyB0aHJvdWdoLCBpZ25vcmluZyByZXBlYXRzIGFuZCB5b3lvcy5cclxuLy8gIElmIHRoZSBhbmltYXRpb24gaGFzIGEgbm9uLXplcm8gcmVwZWF0IGRlZmluZWQsIHByb2dyZXNzIGFuZCB0b3RhbFByb2dyZXNzIHdpbGwgYmUgZGlmZmVyZW50XHJcbi8vICBiZWNhdXNlIHByb2dyZXNzIGRvZXNuJ3QgaW5jbHVkZSBhbnkgcmVwZWF0cyBvciByZXBlYXREZWxheXMgd2hlcmVhcyB0b3RhbFByb2dyZXNzIGRvZXMuXHJcbnZhciBQcm9ncmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHAgPSB0aGlzLmN1cnJlbnRGcmFtZS5wcm9ncmVzcztcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmZvcndhcmQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwID0gMSAtIHA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgVE9ETzogU2V0IHByb2dyZXNzXHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmVzcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9Qcm9ncmVzcy5qc1xuLy8gbW9kdWxlIGlkID0gNDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpXHJcbntcclxuICAgIGlmIChldmVudCA9PT0gdW5kZWZpbmVkKSB7IGV2ZW50ID0gdGhpcy5jdXJyZW50QW5pbTsgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzUGxheWluZyAmJiBldmVudC5rZXkgPT09IHRoaXMuY3VycmVudEFuaW0ua2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RvcCgpO1xyXG5cclxuICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5jdXJyZW50QW5pbS5mcmFtZXNbMF07XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWU7XHJcblxyXG4gICAgICAgIHNwcml0ZS50ZXh0dXJlID0gZnJhbWUuZnJhbWUudGV4dHVyZTtcclxuICAgICAgICBzcHJpdGUuZnJhbWUgPSBmcmFtZS5mcmFtZTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL1JlbW92ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBHZXRzIG9yIHNldHMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoZSBhbmltYXRpb24gc2hvdWxkIHJlcGVhdFxyXG4vLyAgYWZ0ZXIgaXRzIGZpcnN0IGl0ZXJhdGlvbi4gRm9yIGV4YW1wbGUsIGlmIHJlcGVhdCBpcyAxLCB0aGUgYW5pbWF0aW9uIHdpbGxcclxuLy8gIHBsYXkgYSB0b3RhbCBvZiB0d2ljZSAodGhlIGluaXRpYWwgcGxheSBwbHVzIDEgcmVwZWF0KS5cclxuLy8gIFRvIHJlcGVhdCBpbmRlZmluaXRlbHksIHVzZSAtMS4gcmVwZWF0IHNob3VsZCBhbHdheXMgYmUgYW4gaW50ZWdlci5cclxuXHJcbnZhciBSZXBlYXQgPSBmdW5jdGlvbiAodmFsdWUpXHJcbntcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXBlYXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5yZXBlYXRDb3VudGVyID0gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlcGVhdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9SZXBlYXQuanNcbi8vIG1vZHVsZSBpZCA9IDQ3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgR2V0cyBvciBzZXRzIHRoZSBhbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIGJldHdlZW4gcmVwZWF0cy5cclxuLy8gIEZvciBleGFtcGxlLCBpZiByZXBlYXQgaXMgMiBhbmQgcmVwZWF0RGVsYXkgaXMgMSwgdGhlIGFuaW1hdGlvbiB3aWxsIHBsYXkgaW5pdGlhbGx5LFxyXG4vLyAgdGhlbiB3YWl0IGZvciAxIHNlY29uZCBiZWZvcmUgaXQgcmVwZWF0cywgdGhlbiBwbGF5IGFnYWluLCB0aGVuIHdhaXQgMSBzZWNvbmQgYWdhaW5cclxuLy8gIGJlZm9yZSBkb2luZyBpdHMgZmluYWwgcmVwZWF0LlxyXG5cclxudmFyIFJlcGVhdERlbGF5ID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVwZWF0RGVsYXk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0RGVsYXkgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlcGVhdERlbGF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL1JlcGVhdERlbGF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlc3RhcnQgPSBmdW5jdGlvbiAoaW5jbHVkZURlbGF5KVxyXG57XHJcbiAgICBpZiAoaW5jbHVkZURlbGF5ID09PSB1bmRlZmluZWQpIHsgaW5jbHVkZURlbGF5ID0gZmFsc2U7IH1cclxuXHJcbiAgICB0aGlzLmN1cnJlbnRBbmltLmdldEZpcnN0VGljayh0aGlzLCBpbmNsdWRlRGVsYXkpO1xyXG5cclxuICAgIHRoaXMuZm9yd2FyZCA9IHRydWU7XHJcbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcbiAgICB0aGlzLnBlbmRpbmdSZXBlYXQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8vICBTZXQgZnJhbWVcclxuICAgIHRoaXMudXBkYXRlRnJhbWUodGhpcy5jdXJyZW50QW5pbS5mcmFtZXNbMF0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXN0YXJ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL1Jlc3RhcnQuanNcbi8vIG1vZHVsZSBpZCA9IDQ3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVzdW1lID0gZnVuY3Rpb24gKGZyb21GcmFtZSlcclxue1xyXG4gICAgaWYgKHRoaXMuX3BhdXNlZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IHRoaXMuX3dhc1BsYXlpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZyb21GcmFtZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudXBkYXRlRnJhbWUoZnJvbUZyYW1lKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9SZXN1bWUuanNcbi8vIG1vZHVsZSBpZCA9IDQ3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3RvcCA9IGZ1bmN0aW9uIChkaXNwYXRjaENhbGxiYWNrcylcclxue1xyXG4gICAgaWYgKGRpc3BhdGNoQ2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHsgZGlzcGF0Y2hDYWxsYmFja3MgPSBmYWxzZTsgfVxyXG5cclxuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIGFuaW0gPSB0aGlzLmN1cnJlbnRBbmltO1xyXG5cclxuICAgIGlmIChkaXNwYXRjaENhbGxiYWNrcyAmJiBhbmltLm9uQ29tcGxldGUpXHJcbiAgICB7XHJcbiAgICAgICAgYW5pbS5vbkNvbXBsZXRlLmFwcGx5KGFuaW0uY2FsbGJhY2tTY29wZSwgdGhpcy5fY2FsbGJhY2tBcmdzLmNvbmNhdChhbmltLm9uQ29tcGxldGVQYXJhbXMpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RvcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9TdG9wLmpzXG4vLyBtb2R1bGUgaWQgPSA0NzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRpbWVTY2FsZSA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVTY2FsZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB0aGlzLl90aW1lU2NhbGUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVTY2FsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9UaW1lU2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVG90YWxGcmFtZXMgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QW5pbS5mcmFtZXMubGVuZ3RoO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb3RhbEZyYW1lcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL2FuaW1hdGlvbi9Ub3RhbEZyYW1lcy5qc1xuLy8gbW9kdWxlIGlkID0gNDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDEuIEhvdyBmYXIgdGhpcyBhbmltYXRpb24gaXMgdGhyb3VnaCwgaW5jbHVkaW5nIHRoaW5ncyBsaWtlIGRlbGF5c1xyXG4vLyAgcmVwZWF0cywgY3VzdG9tIGZyYW1lIGR1cmF0aW9ucywgZXRjLiBJZiB0aGUgYW5pbWF0aW9uIGlzIHNldCB0byByZXBlYXQgLTEgaXQgY2FuIG5ldmVyXHJcbi8vICBoYXZlIGEgZHVyYXRpb24sIHRoZXJlZm9yZSB0aGlzIHdpbGwgcmV0dXJuIC0xLlxyXG52YXIgVG90YWxQcm9ncmVzID0gZnVuY3Rpb24gKClcclxue1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG90YWxQcm9ncmVzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL1RvdGFsUHJvZ3Jlc3MuanNcbi8vIG1vZHVsZSBpZCA9IDQ3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVXBkYXRlID0gZnVuY3Rpb24gKHRpbWVzdGFtcCwgZGVsdGEpXHJcbntcclxuICAgIGlmICghdGhpcy5pc1BsYXlpbmcgfHwgdGhpcy5jdXJyZW50QW5pbS5wYXVzZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYWNjdW11bGF0b3IgKz0gZGVsdGEgKiB0aGlzLl90aW1lU2NhbGU7XHJcblxyXG4gICAgaWYgKHRoaXMuYWNjdW11bGF0b3IgPj0gdGhpcy5uZXh0VGljaylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBbmltLnNldEZyYW1lKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVcGRhdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vVXBkYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0Nzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFVwZGF0ZUZyYW1lID0gZnVuY3Rpb24gKGFuaW1hdGlvbkZyYW1lKVxyXG57XHJcbiAgICB2YXIgc3ByaXRlID0gdGhpcy5wYXJlbnQ7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBhbmltYXRpb25GcmFtZTtcclxuXHJcbiAgICBzcHJpdGUudGV4dHVyZSA9IGFuaW1hdGlvbkZyYW1lLmZyYW1lLnRleHR1cmU7XHJcbiAgICBzcHJpdGUuZnJhbWUgPSBhbmltYXRpb25GcmFtZS5mcmFtZTtcclxuXHJcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvbkZyYW1lLnNldEFscGhhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3ByaXRlLmFscGhhID0gYW5pbWF0aW9uRnJhbWUuYWxwaGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYW5pbSA9IHRoaXMuY3VycmVudEFuaW07XHJcblxyXG4gICAgICAgIGlmIChhbmltLm9uVXBkYXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYW5pbS5vblVwZGF0ZS5hcHBseShhbmltLmNhbGxiYWNrU2NvcGUsIHRoaXMuX3VwZGF0ZVBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYW5pbWF0aW9uRnJhbWUub25VcGRhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbmltYXRpb25GcmFtZS5vblVwZGF0ZShzcHJpdGUsIGFuaW1hdGlvbkZyYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVwZGF0ZUZyYW1lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbXBvbmVudHMvYW5pbWF0aW9uL1VwZGF0ZUZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA0Nzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFlveW8gPSBmdW5jdGlvbiAodmFsdWUpXHJcbntcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl95b3lvO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3lveW8gPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFlveW87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vWW95by5qc1xuLy8gbW9kdWxlIGlkID0gNDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuQW5pbWF0aW9uLkZyYW1lLkNvbXBvbmVudHNcclxuXHJcbi8vICBVc2VkIGJ5IHRoZSBHYW1lT2JqZWN0IEFuaW1hdGlvbiBDb250cm9sbGVyLCBub3QgdGhlIEFuaW1hdGlvbiBpdHNlbGZcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIERlbGF5OiByZXF1aXJlKCcuL0RlbGF5JyksXHJcbiAgICBEZWxheWVkUGxheTogcmVxdWlyZSgnLi9EZWxheWVkUGxheScpLFxyXG4gICAgR2V0Q3VycmVudEtleTogcmVxdWlyZSgnLi9HZXRDdXJyZW50S2V5JyksXHJcbiAgICBMb2FkOiByZXF1aXJlKCcuL0xvYWQnKSxcclxuICAgIFBhdXNlOiByZXF1aXJlKCcuL1BhdXNlJyksXHJcbiAgICBQYXVzZWQ6IHJlcXVpcmUoJy4vUGF1c2VkJyksXHJcbiAgICBQbGF5OiByZXF1aXJlKCcuL1BsYXknKSxcclxuICAgIFByb2dyZXNzOiByZXF1aXJlKCcuL1Byb2dyZXNzJyksXHJcbiAgICBSZW1vdmU6IHJlcXVpcmUoJy4vUmVtb3ZlJyksXHJcbiAgICBSZXBlYXQ6IHJlcXVpcmUoJy4vUmVwZWF0JyksXHJcbiAgICBSZXBlYXREZWxheTogcmVxdWlyZSgnLi9SZXBlYXREZWxheScpLFxyXG4gICAgUmVzdGFydDogcmVxdWlyZSgnLi9SZXN0YXJ0JyksXHJcbiAgICBSZXN1bWU6IHJlcXVpcmUoJy4vUmVzdW1lJyksXHJcbiAgICBTdG9wOiByZXF1aXJlKCcuL1N0b3AnKSxcclxuICAgIFRpbWVTY2FsZTogcmVxdWlyZSgnLi9UaW1lU2NhbGUnKSxcclxuICAgIFRvdGFsRnJhbWVzOiByZXF1aXJlKCcuL1RvdGFsRnJhbWVzJyksXHJcbiAgICBUb3RhbFByb2dyZXNzOiByZXF1aXJlKCcuL1RvdGFsUHJvZ3Jlc3MnKSxcclxuICAgIFVwZGF0ZTogcmVxdWlyZSgnLi9VcGRhdGUnKSxcclxuICAgIFVwZGF0ZUZyYW1lOiByZXF1aXJlKCcuL1VwZGF0ZUZyYW1lJyksXHJcbiAgICBZb3lvOiByZXF1aXJlKCcuL1lveW8nKVxyXG4gICAgXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9hbmltYXRpb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRWZmZWN0TGF5ZXJDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RMYXllckNhbnZhc1JlbmRlcmVyO1xyXG4gXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9lZmZlY3RsYXllci9FZmZlY3RMYXllckNhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0ODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJ1aWxkR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0J1aWxkR2FtZU9iamVjdCcpO1xyXG52YXIgRWZmZWN0TGF5ZXIgPSByZXF1aXJlKCcuL0VmZmVjdExheWVyJyk7XHJcbnZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdENyZWF0b3InKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RDcmVhdG9yIGNvbnRleHQuXHJcblxyXG5HYW1lT2JqZWN0Q3JlYXRvci5yZWdpc3RlcignZWZmZWN0TGF5ZXInLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIgeCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAneCcsIDApO1xyXG4gICAgdmFyIHkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3knLCAwKTtcclxuICAgIHZhciB3aWR0aCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnd2lkdGgnLCA1MTIpO1xyXG4gICAgdmFyIGhlaWdodCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnaGVpZ2h0JywgNTEyKTtcclxuICAgIHZhciBrZXkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2tleScsIG51bGwpO1xyXG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmcmFnbWVudFNoYWRlcicsICcnKTtcclxuXHJcbiAgICB2YXIgbGF5ZXIgPSBuZXcgRWZmZWN0TGF5ZXIodGhpcy5zY2VuZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZWZmZWN0TmFtZSwgZnJhZ21lbnRTaGFkZXIpO1xyXG5cclxuICAgIEJ1aWxkR2FtZU9iamVjdCh0aGlzLnNjZW5lLCBsYXllciwgY29uZmlnKTtcclxuXHJcbiAgICByZXR1cm4gbGF5ZXI7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VmZmVjdGxheWVyL0VmZmVjdExheWVyQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFZmZlY3RMYXllciA9IHJlcXVpcmUoJy4vRWZmZWN0TGF5ZXInKTtcclxudmFyIEdhbWVPYmplY3RGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0RmFjdG9yeScpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RGYWN0b3J5IGNvbnRleHQuXHJcbi8vICBcclxuLy8gIFRoZXJlIGFyZSBzZXZlcmFsIHByb3BlcnRpZXMgYXZhaWxhYmxlIHRvIHVzZTpcclxuLy8gIFxyXG4vLyAgdGhpcy5zY2VuZSAtIGEgcmVmZXJlbmNlIHRvIHRoZSBTY2VuZSB0aGF0IG93bnMgdGhlIEdhbWVPYmplY3RGYWN0b3J5XHJcbi8vICB0aGlzLmRpc3BsYXlMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIERpc3BsYXkgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG4vLyAgdGhpcy51cGRhdGVMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIFVwZGF0ZSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcblxyXG5pZiAoV0VCR0xfUkVOREVSRVIpXHJcbntcclxuICAgIEdhbWVPYmplY3RGYWN0b3J5LnJlZ2lzdGVyKCdlZmZlY3RMYXllcicsIGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBlZmZlY3ROYW1lLCBmcmFnbWVudFNoYWRlcilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5TGlzdC5hZGQobmV3IEVmZmVjdExheWVyKHRoaXMuc2NlbmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGVmZmVjdE5hbWUsIGZyYWdtZW50U2hhZGVyKSk7XHJcbiAgICB9KTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VmZmVjdGxheWVyL0VmZmVjdExheWVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL05PT1AnKTtcclxudmFyIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL05PT1AnKTtcclxuXHJcbmlmIChXRUJHTF9SRU5ERVJFUilcclxue1xyXG4gICAgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuL0VmZmVjdExheWVyV2ViR0xSZW5kZXJlcicpO1xyXG59XHJcblxyXG5pZiAoQ0FOVkFTX1JFTkRFUkVSKVxyXG57XHJcbiAgICByZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuL0VmZmVjdExheWVyQ2FudmFzUmVuZGVyZXInKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgcmVuZGVyV2ViR0w6IHJlbmRlcldlYkdMLFxyXG4gICAgcmVuZGVyQ2FudmFzOiByZW5kZXJDYW52YXNcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvZWZmZWN0bGF5ZXIvRWZmZWN0TGF5ZXJSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxuXHJcbnZhciBFZmZlY3RMYXllcldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IHNyYy5yZW5kZXJGbGFncyB8fCAoc3JjLmNhbWVyYUZpbHRlciA+IDAgJiYgKHNyYy5jYW1lcmFGaWx0ZXIgJiBjYW1lcmEuX2lkKSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcmVyLmVmZmVjdFJlbmRlcmVyLnJlbmRlckVmZmVjdChzcmMsIGNhbWVyYSwgc3JjLnJlbmRlclRleHR1cmUsIHNyYy53aWR0aCwgc3JjLmhlaWdodCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVmZmVjdExheWVyV2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9lZmZlY3RsYXllci9FZmZlY3RMYXllcldlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIFBhcnRpY2xlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFBhcnRpY2xlICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnZlbG9jaXR5WCA9IDAuMDtcclxuICAgICAgICB0aGlzLnZlbG9jaXR5WSA9IDAuMDtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMC4wO1xyXG4gICAgICAgIHRoaXMuc2NhbGVYID0gMS4wO1xyXG4gICAgICAgIHRoaXMuc2NhbGVZID0gMS4wO1xyXG4gICAgICAgIHRoaXMubGlmZSA9IDEuMDtcclxuICAgICAgICB0aGlzLmNvbG9yID0gMHhGRkZGRkZGRjtcclxuICAgICAgICB0aGlzLmxpZmVTdGVwID0gMS4wO1xyXG4gICAgICAgIHRoaXMubm9ybUxpZmVTdGVwID0gMS4wO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0ID0ge1xyXG4gICAgICAgICAgICB0aW50OiAweEZGRkZGRixcclxuICAgICAgICAgICAgYWxwaGE6IDEuMCxcclxuICAgICAgICAgICAgc2NhbGU6IDEuMCxcclxuICAgICAgICAgICAgYW5nbGU6IDAuMFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZW5kID0ge1xyXG4gICAgICAgICAgICB0aW50OiAweEZGRkZGRixcclxuICAgICAgICAgICAgYWxwaGE6IDEuMCxcclxuICAgICAgICAgICAgc2NhbGU6IDEuMCxcclxuICAgICAgICAgICAgYW5nbGU6IDAuMFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy52ZWxvY2l0eVggPSAwLjA7XHJcbiAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSAwLjA7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDAuMDtcclxuICAgICAgICB0aGlzLnNjYWxlWCA9IDEuMDtcclxuICAgICAgICB0aGlzLnNjYWxlWSA9IDEuMDtcclxuICAgICAgICB0aGlzLmxpZmUgPSAxLjA7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IDB4RkZGRkZGRkY7XHJcbiAgICAgICAgdGhpcy5saWZlU3RlcCA9IDEuMDtcclxuICAgICAgICB0aGlzLm5vcm1MaWZlU3RlcCA9IDEuMDtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHtcclxuICAgICAgICAgICAgdGludDogMHhGRkZGRkYsXHJcbiAgICAgICAgICAgIGFscGhhOiAxLjAsXHJcbiAgICAgICAgICAgIHNjYWxlOiAxLjAsXHJcbiAgICAgICAgICAgIGFuZ2xlOiAwLjBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmVuZCA9IHtcclxuICAgICAgICAgICAgdGludDogMHhGRkZGRkYsXHJcbiAgICAgICAgICAgIGFscGhhOiAxLjAsXHJcbiAgICAgICAgICAgIHNjYWxlOiAxLjAsXHJcbiAgICAgICAgICAgIGFuZ2xlOiAwLjBcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0FsaXZlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpZmVTdGVwID4gMDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWNsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9lbWl0dGVyL1BhcnRpY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA0ODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhcnRpY2xlRW1pdHRlckNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlRW1pdHRlckNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VtaXR0ZXIvUGFydGljbGVFbWl0dGVyQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQnVpbGRHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vQnVpbGRHYW1lT2JqZWN0Jyk7XHJcbnZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdENyZWF0b3InKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG52YXIgUGFydGljbGVFbWl0dGVyID0gcmVxdWlyZSgnLi9QYXJ0aWNsZUVtaXR0ZXInKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0Q3JlYXRvciBjb250ZXh0LlxyXG5cclxuR2FtZU9iamVjdENyZWF0b3IucmVnaXN0ZXIoJ2VtaXR0ZXInLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIga2V5ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdrZXknLCBudWxsKTtcclxuICAgIHZhciBmcmFtZSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnZnJhbWUnLCBudWxsKTtcclxuXHJcbiAgICB2YXIgZW1pdHRlciA9IG5ldyBQYXJ0aWNsZUVtaXR0ZXIodGhpcy5zY2VuZSwgMCwgMCwga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHRoaXMuc2NlbmUsIGVtaXR0ZXIsIGNvbmZpZyk7XHJcblxyXG4gICAgcmV0dXJuIGVtaXR0ZXI7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VtaXR0ZXIvUGFydGljbGVFbWl0dGVyQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXJ0aWNsZUVtaXR0ZXIgPSByZXF1aXJlKCcuL1BhcnRpY2xlRW1pdHRlcicpO1xyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RGYWN0b3J5Jyk7XHJcblxyXG4vLyAgV2hlbiByZWdpc3RlcmluZyBhIGZhY3RvcnkgZnVuY3Rpb24gJ3RoaXMnIHJlZmVycyB0byB0aGUgR2FtZU9iamVjdEZhY3RvcnkgY29udGV4dC5cclxuLy8gIFxyXG4vLyAgVGhlcmUgYXJlIHNldmVyYWwgcHJvcGVydGllcyBhdmFpbGFibGUgdG8gdXNlOlxyXG4vLyAgXHJcbi8vICB0aGlzLnNjZW5lIC0gYSByZWZlcmVuY2UgdG8gdGhlIFNjZW5lIHRoYXQgb3ducyB0aGUgR2FtZU9iamVjdEZhY3RvcnlcclxuLy8gIHRoaXMuZGlzcGxheUxpc3QgLSBhIHJlZmVyZW5jZSB0byB0aGUgRGlzcGxheSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcbi8vICB0aGlzLnVwZGF0ZUxpc3QgLSBhIHJlZmVyZW5jZSB0byB0aGUgVXBkYXRlIExpc3QgdGhlIFNjZW5lIG93bnNcclxuXHJcbkdhbWVPYmplY3RGYWN0b3J5LnJlZ2lzdGVyKCdlbWl0dGVyJywgZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUpXHJcbntcclxuICAgIHZhciBlbWl0dGVyID0gbmV3IFBhcnRpY2xlRW1pdHRlcih0aGlzLnNjZW5lLCB4LCB5LCBrZXksIGZyYW1lKTtcclxuICAgIFxyXG4gICAgdGhpcy5kaXNwbGF5TGlzdC5hZGQoZW1pdHRlcik7XHJcbiAgICB0aGlzLnVwZGF0ZUxpc3QuYWRkKGVtaXR0ZXIpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZW1pdHRlcjtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvZW1pdHRlci9QYXJ0aWNsZUVtaXR0ZXJGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA0OTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlcldlYkdMID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvTk9PUCcpO1xyXG52YXIgcmVuZGVyQ2FudmFzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvTk9PUCcpO1xyXG5cclxuaWYgKFdFQkdMX1JFTkRFUkVSKVxyXG57XHJcbiAgICByZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4vUGFydGljbGVFbWl0dGVyV2ViR0xSZW5kZXJlcicpO1xyXG59XHJcblxyXG5pZiAoQ0FOVkFTX1JFTkRFUkVSKVxyXG57XHJcbiAgICByZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuL1BhcnRpY2xlRW1pdHRlckNhbnZhc1JlbmRlcmVyJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlcldlYkdMOiByZW5kZXJXZWJHTCxcclxuICAgIHJlbmRlckNhbnZhczogcmVuZGVyQ2FudmFzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VtaXR0ZXIvUGFydGljbGVFbWl0dGVyUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgUGFydGljbGVFbWl0dGVyV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgZW1pdHRlciwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IGVtaXR0ZXIucmVuZGVyRmxhZ3MgfHwgKGVtaXR0ZXIuY2FtZXJhRmlsdGVyID4gMCAmJiAoZW1pdHRlci5jYW1lcmFGaWx0ZXIgJiBjYW1lcmEuX2lkKSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcmVyLnBhcnRpY2xlUmVuZGVyZXIucmVuZGVyRW1pdHRlcihlbWl0dGVyLCBjYW1lcmEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWNsZUVtaXR0ZXJXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VtaXR0ZXIvUGFydGljbGVFbWl0dGVyV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdENyZWF0b3InKTtcclxudmFyIEdyYXBoaWNzID0gcmVxdWlyZSgnLi9HcmFwaGljcycpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RDcmVhdG9yIGNvbnRleHQuXHJcblxyXG5HYW1lT2JqZWN0Q3JlYXRvci5yZWdpc3RlcignZ3JhcGhpY3MnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IEdyYXBoaWNzKHRoaXMuc2NlbmUsIGNvbmZpZyk7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHcmFwaGljcyA9IHJlcXVpcmUoJy4vR3JhcGhpY3MnKTtcclxudmFyIEdhbWVPYmplY3RGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0RmFjdG9yeScpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RGYWN0b3J5IGNvbnRleHQuXHJcbi8vICBcclxuLy8gIFRoZXJlIGFyZSBzZXZlcmFsIHByb3BlcnRpZXMgYXZhaWxhYmxlIHRvIHVzZTpcclxuLy8gIFxyXG4vLyAgdGhpcy5zY2VuZSAtIGEgcmVmZXJlbmNlIHRvIHRoZSBTY2VuZSB0aGF0IG93bnMgdGhlIEdhbWVPYmplY3RGYWN0b3J5XHJcbi8vICB0aGlzLmRpc3BsYXlMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIERpc3BsYXkgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG4vLyAgdGhpcy51cGRhdGVMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIFVwZGF0ZSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcblxyXG5HYW1lT2JqZWN0RmFjdG9yeS5yZWdpc3RlcignZ3JhcGhpY3MnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5kaXNwbGF5TGlzdC5hZGQobmV3IEdyYXBoaWNzKHRoaXMuc2NlbmUsIGNvbmZpZykpO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc0ZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDQ5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuLi8uLi91dGlscy9OT09QJyk7XHJcbnZhciByZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9OT09QJyk7XHJcblxyXG5pZiAoV0VCR0xfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlcldlYkdMID0gcmVxdWlyZSgnLi9HcmFwaGljc1dlYkdMUmVuZGVyZXInKTtcclxuXHJcbiAgICAvLyAgTmVlZGVkIGZvciBHcmFwaGljcy5nZW5lcmF0ZVRleHR1cmVcclxuICAgIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4vR3JhcGhpY3NDYW52YXNSZW5kZXJlcicpO1xyXG59XHJcblxyXG5pZiAoQ0FOVkFTX1JFTkRFUkVSKVxyXG57XHJcbiAgICByZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuL0dyYXBoaWNzQ2FudmFzUmVuZGVyZXInKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgcmVuZGVyV2ViR0w6IHJlbmRlcldlYkdMLFxyXG4gICAgcmVuZGVyQ2FudmFzOiByZW5kZXJDYW52YXNcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxudmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi9Db21tYW5kcycpO1xyXG52YXIgVHJhbnNmb3JtTWF0cml4ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXgnKTtcclxudmFyIHBhdGhBcnJheSA9IFtdO1xyXG52YXIgY29zID0gTWF0aC5jb3M7XHJcbnZhciBzaW4gPSBNYXRoLnNpbjtcclxudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XHJcbnZhciB0ZW1wTWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG52YXIgbWF0cml4U3RhY2sgPSBuZXcgRmxvYXQzMkFycmF5KDYgKiAxMDAwKTtcclxudmFyIG1hdHJpeFN0YWNrTGVuZ3RoID0gMDtcclxudmFyIGN1cnJlbnRNYXRyaXggPSBuZXcgVHJhbnNmb3JtTWF0cml4KCk7XHJcblxyXG52YXIgUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIHJnYiwgYWxwaGEpXHJcbntcclxuICAgIHRoaXMueCA9IHg7XHJcbiAgICB0aGlzLnkgPSB5O1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5yZ2IgPSByZ2I7XHJcbiAgICB0aGlzLmFscGhhID0gYWxwaGE7XHJcbn07XHJcblxyXG52YXIgUGF0aCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgcmdiLCBhbHBoYSlcclxue1xyXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcclxuICAgIHRoaXMucG9pbnRzTGVuZ3RoID0gMTtcclxuICAgIHRoaXMucG9pbnRzWzBdID0gbmV3IFBvaW50KHgsIHksIHdpZHRoLCByZ2IsIGFscGhhKTtcclxufTtcclxuXHJcbnZhciBHcmFwaGljc1dlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGdhbWVPYmplY3QsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEsIGZvcmNlUmVuZGVyVGFyZ2V0KVxyXG57XHJcbiAgICBpZiAoR2FtZU9iamVjdC5SRU5ERVJfTUFTSyAhPT0gZ2FtZU9iamVjdC5yZW5kZXJGbGFncyB8fCAoZ2FtZU9iamVjdC5jYW1lcmFGaWx0ZXIgPiAwICYmIChnYW1lT2JqZWN0LmNhbWVyYUZpbHRlciAmIGNhbWVyYS5faWQpKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlbmRlclRhcmdldCA9IGZvcmNlUmVuZGVyVGFyZ2V0IHx8IGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0O1xyXG4gICAgdmFyIHNoYXBlQmF0Y2ggPSByZW5kZXJlci5zaGFwZUJhdGNoO1xyXG4gICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBzaGFwZUJhdGNoLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICB2YXIgdmVydGV4QnVmZmVyRjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFggPSBjYW1lcmEuc2Nyb2xsWCAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFkgKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclk7XHJcbiAgICBjb25zdCBzcmNYID0gZ2FtZU9iamVjdC54IC0gY2FtZXJhU2Nyb2xsWDtcclxuICAgIGNvbnN0IHNyY1kgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmFTY3JvbGxZO1xyXG4gICAgY29uc3Qgc3JjU2NhbGVYID0gZ2FtZU9iamVjdC5zY2FsZVg7XHJcbiAgICBjb25zdCBzcmNTY2FsZVkgPSBnYW1lT2JqZWN0LnNjYWxlWTtcclxuICAgIGNvbnN0IHNyY1JvdGF0aW9uID0gLWdhbWVPYmplY3Qucm90YXRpb247XHJcbiAgICB2YXIgY29tbWFuZEJ1ZmZlciA9IGdhbWVPYmplY3QuY29tbWFuZEJ1ZmZlcjtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIHZhciBsaW5lQWxwaGEgPSAxLjA7XHJcbiAgICB2YXIgZmlsbEFscGhhID0gMS4wO1xyXG4gICAgdmFyIGxpbmVDb2xvciA9IDA7XHJcbiAgICB2YXIgZmlsbENvbG9yID0gMDtcclxuICAgIHZhciBsaW5lV2lkdGggPSAxLjA7XHJcbiAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICB2YXIgbGFzdFBhdGggPSBudWxsO1xyXG4gICAgdmFyIGl0ZXJhdGlvbiA9IDA7XHJcbiAgICB2YXIgaXRlclN0ZXAgPSAwLjAxO1xyXG4gICAgdmFyIHR4ID0gMDtcclxuICAgIHZhciB0eSA9IDA7XHJcbiAgICB2YXIgdGEgPSAwO1xyXG4gICAgdmFyIHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2U7XHJcbiAgICB2YXIgd2lkdGgsIGhlaWdodCwgdHh3LCB0eWg7XHJcbiAgICB2YXIgdmVydGV4Q291bnQgPSBzaGFwZUJhdGNoLnZlcnRleENvdW50O1xyXG4gICAgdmFyIHBvbHlnb24gPSBbXTtcclxuICAgIHZhciB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyO1xyXG4gICAgdmFyIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTI7XHJcbiAgICB2YXIgdjAsIHYxLCB2MjtcclxuICAgIHZhciBwb2x5Z29uSW5kZXg7XHJcbiAgICB2YXIgcGF0aDtcclxuICAgIHZhciBwYXRoTGVuZ3RoO1xyXG4gICAgdmFyIHBvaW50O1xyXG4gICAgdmFyIG1heFZlcnRpY2VzID0gc2hhcGVCYXRjaC5tYXhWZXJ0aWNlcztcclxuICAgIHZhciB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZO1xyXG4gICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgdmFyIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmY7XHJcblxyXG4gICAgdGVtcE1hdHJpeC5hcHBseUlUUlMoc3JjWCwgc3JjWSwgc3JjUm90YXRpb24sIHNyY1NjYWxlWCwgc3JjU2NhbGVZKTtcclxuXHJcbiAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgc3JiID0gdGVtcE1hdHJpeE1hdHJpeFsxXTtcclxuICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XHJcbiAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgc3JlID0gdGVtcE1hdHJpeE1hdHJpeFs0XTtcclxuICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XHJcblxyXG4gICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgY21iID0gY2FtZXJhTWF0cml4WzFdO1xyXG4gICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgY21lID0gY2FtZXJhTWF0cml4WzRdO1xyXG4gICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xyXG5cclxuICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcclxuICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcclxuICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcclxuICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjtcclxuXHJcbiAgICByZW5kZXJlci5zZXRSZW5kZXJlcihzaGFwZUJhdGNoLCBudWxsLCByZW5kZXJUYXJnZXQpO1xyXG5cclxuICAgIGZvciAodmFyIGNtZEluZGV4ID0gMCwgY21kTGVuZ3RoID0gY29tbWFuZEJ1ZmZlci5sZW5ndGg7IGNtZEluZGV4IDwgY21kTGVuZ3RoOyArK2NtZEluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kQnVmZmVyW2NtZEluZGV4XTtcclxuXHJcbiAgICAgICAgc3dpdGNoKGNtZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQVJDOlxyXG4gICAgICAgICAgICAgICAgaXRlcmF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIHggPSBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV07XHJcbiAgICAgICAgICAgICAgICB5ID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdO1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDNdO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA0XTtcclxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDVdO1xyXG4gICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZSA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA2XTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdGlvbiA8IDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGEgPSAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAqIGl0ZXJhdGlvbiArIHN0YXJ0QW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdHggPSB4ICsgY29zKHRhKSAqIHJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICB0eSA9IHkgKyBzaW4odGEpICogcmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBhdGggPSBuZXcgUGF0aCh0eCwgdHksIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkucHVzaChsYXN0UGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoLnBvaW50cy5wdXNoKG5ldyBQb2ludCh0eCwgdHksIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbiArPSBpdGVyU3RlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTElORV9TVFlMRTpcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgIGxpbmVDb2xvciA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXTtcclxuICAgICAgICAgICAgICAgIGxpbmVBbHBoYSA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXTtcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9TVFlMRTpcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvciA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgIGZpbGxBbHBoYSA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXTtcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQkVHSU5fUEFUSDpcclxuICAgICAgICAgICAgICAgIHBhdGhBcnJheS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkNMT1NFX1BBVEg6XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhdGggIT09IG51bGwgJiYgbGFzdFBhdGgucG9pbnRzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0UG9pbnQgPSBsYXN0UGF0aC5wb2ludHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RQb2ludCA9IGxhc3RQYXRoLnBvaW50c1tsYXN0UGF0aC5wb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBhdGgucG9pbnRzLnB1c2goZmlyc3RQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBhdGggPSBuZXcgUGF0aChsYXN0UG9pbnQueCwgbGFzdFBvaW50LnksIGxhc3RQb2ludC53aWR0aCwgbGFzdFBvaW50LnJnYiwgbGFzdFBvaW50LmFscGhhKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkucHVzaChsYXN0UGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9QQVRIOlxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcGF0aEFycmF5SW5kZXggPSAwLCBwYXRoQXJyYXlMZW5ndGggPSBwYXRoQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheUluZGV4IDwgcGF0aEFycmF5TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICsrcGF0aEFycmF5SW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVCYXRjaC5hZGRGaWxsUGF0aChcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgUHJvcGVydGllcyAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlY3RhbmdsZSBwcm9wZXJ0aWVzICovIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXlbcGF0aEFycmF5SW5kZXhdLnBvaW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyYW5zZm9ybSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWF0cml4XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TVFJPS0VfUEFUSDpcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHBhdGhBcnJheUluZGV4ID0gMCwgcGF0aEFycmF5TGVuZ3RoID0gcGF0aEFycmF5Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXlJbmRleCA8IHBhdGhBcnJheUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICArK3BhdGhBcnJheUluZGV4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gcGF0aEFycmF5W3BhdGhBcnJheUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZUJhdGNoLmFkZFN0cm9rZVBhdGgoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IFByb3BlcnRpZXMgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBSZWN0YW5nbGUgcHJvcGVydGllcyAqLyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5wb2ludHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lQWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyYW5zZm9ybSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID09PSB0aGlzLl9sYXN0UGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hdHJpeFxyXG5cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1JFQ1Q6XHJcbiAgICAgICAgICAgICAgICBzaGFwZUJhdGNoLmFkZEZpbGxSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IFByb3BlcnRpZXMgKi9cclxuICAgICAgICAgICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgLyogUmVjdGFuZ2xlIHByb3BlcnRpZXMgKi8gXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdIC0gY2FtZXJhU2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0gLSBjYW1lcmFTY3JvbGxZLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxBbHBoYSxcclxuICAgICAgICAgICAgICAgICAgICAvKiBUcmFuc2Zvcm0gKi9cclxuICAgICAgICAgICAgICAgICAgICBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXhcclxuXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjbWRJbmRleCArPSA0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkZJTExfVFJJQU5HTEU6XHJcbiAgICAgICAgICAgICAgICBzaGFwZUJhdGNoLmFkZEZpbGxUcmlhbmdsZShcclxuICAgICAgICAgICAgICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBQcm9wZXJ0aWVzICovXHJcbiAgICAgICAgICAgICAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIFRyaWFuZ2xlIHByb3BlcnRpZXMgKi8gXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdIC0gY2FtZXJhU2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0gLSBjYW1lcmFTY3JvbGxZLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXSAtIGNhbWVyYVNjcm9sbFgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDRdIC0gY2FtZXJhU2Nyb2xsWSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNV0gLSBjYW1lcmFTY3JvbGxYLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA2XSAtIGNhbWVyYVNjcm9sbFksXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxBbHBoYSxcclxuICAgICAgICAgICAgICAgICAgICAvKiBUcmFuc2Zvcm0gKi9cclxuICAgICAgICAgICAgICAgICAgICBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXhcclxuXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjbWRJbmRleCArPSA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLlNUUk9LRV9UUklBTkdMRTpcclxuICAgICAgICAgICAgICAgIHNoYXBlQmF0Y2guYWRkU3Ryb2tlVHJpYW5nbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgUHJvcGVydGllcyAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAvKiBUcmlhbmdsZSBwcm9wZXJ0aWVzICovIFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSAtIGNhbWVyYVNjcm9sbFgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdIC0gY2FtZXJhU2Nyb2xsWSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgM10gLSBjYW1lcmFTY3JvbGxYLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA0XSAtIGNhbWVyYVNjcm9sbFksXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDVdIC0gY2FtZXJhU2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNl0gLSBjYW1lcmFTY3JvbGxZLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZUFscGhhLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIFRyYW5zZm9ybSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmYsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hdHJpeFxyXG5cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDY7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5MSU5FX1RPOlxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXRoICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoLnBvaW50cy5wdXNoKG5ldyBQb2ludChjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV0sIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXSwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGxpbmVBbHBoYSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFBhdGgoY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0sIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheS5wdXNoKGxhc3RQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTU9WRV9UTzpcclxuICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFBhdGgoY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0sIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgcGF0aEFycmF5LnB1c2gobGFzdFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5MSU5FX0ZYX1RPOlxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXRoICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoLnBvaW50cy5wdXNoKG5ldyBQb2ludChcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA1XVxyXG4gICAgICAgICAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFBhdGgoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNV1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheS5wdXNoKGxhc3RQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTU9WRV9GWF9UTzpcclxuICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFBhdGgoXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0sIFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDVdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcGF0aEFycmF5LnB1c2gobGFzdFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gNTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TQVZFOlxyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAwXSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzBdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAxXSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzFdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAyXSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzJdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAzXSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzNdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyA0XSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzRdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyA1XSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzVdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tMZW5ndGggKz0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5SRVNUT1JFOlxyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tMZW5ndGggLT0gNjtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzBdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAwXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzFdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAxXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzJdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAyXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzNdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAzXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzRdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyA0XTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzVdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyA1XTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5UUkFOU0xBVEU6XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0cml4LnRyYW5zbGF0ZShcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TQ0FMRTpcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXguc2NhbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuUk9UQVRFOlxyXG4gICAgICAgICAgICAgICAgY3VycmVudE1hdHJpeC5yb3RhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgLWNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQaGFzZXI6IEludmFsaWQgR3JhcGhpY3MgQ29tbWFuZCBJRCAnICsgY21kKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGN1cnJlbnRNYXRyaXgubG9hZElkZW50aXR5KCk7XHJcbiAgICBwYXRoQXJyYXkubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdENyZWF0b3InKTtcclxudmFyIEdyb3VwID0gcmVxdWlyZSgnLi9Hcm91cCcpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RDcmVhdG9yIGNvbnRleHQuXHJcblxyXG5HYW1lT2JqZWN0Q3JlYXRvci5yZWdpc3RlcignZ3JvdXAnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IEdyb3VwKHRoaXMuc2NlbmUsIG51bGwsIGNvbmZpZyk7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2dyb3VwL0dyb3VwQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHcm91cCA9IHJlcXVpcmUoJy4vR3JvdXAnKTtcclxudmFyIEdhbWVPYmplY3RGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0RmFjdG9yeScpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RGYWN0b3J5IGNvbnRleHQuXHJcbi8vICBcclxuLy8gIFRoZXJlIGFyZSBzZXZlcmFsIHByb3BlcnRpZXMgYXZhaWxhYmxlIHRvIHVzZTpcclxuLy8gIFxyXG4vLyAgdGhpcy5zY2VuZSAtIGEgcmVmZXJlbmNlIHRvIHRoZSBTY2VuZSB0aGF0IG93bnMgdGhlIEdhbWVPYmplY3RGYWN0b3J5XHJcbi8vICB0aGlzLmRpc3BsYXlMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIERpc3BsYXkgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG4vLyAgdGhpcy51cGRhdGVMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIFVwZGF0ZSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcblxyXG5HYW1lT2JqZWN0RmFjdG9yeS5yZWdpc3RlcignZ3JvdXAnLCBmdW5jdGlvbiAoY2hpbGRyZW4sIGNvbmZpZylcclxue1xyXG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ29iamVjdCcgJiYgY29uZmlnID09PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgY29uZmlnID0gY2hpbGRyZW47XHJcbiAgICAgICAgY2hpbGRyZW4gPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IEdyb3VwKHRoaXMuc2NlbmUsIGNoaWxkcmVuLCBjb25maWcpO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9ncm91cC9Hcm91cEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDQ5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxuXHJcbnZhciBJbWFnZUNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmIChHYW1lT2JqZWN0LlJFTkRFUl9NQVNLICE9PSBzcmMucmVuZGVyRmxhZ3MgfHwgKHNyYy5jYW1lcmFGaWx0ZXIgPiAwICYmIChzcmMuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJlci5kcmF3SW1hZ2Uoc3JjLCBjYW1lcmEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZUNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQnVpbGRHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vQnVpbGRHYW1lT2JqZWN0Jyk7XHJcbnZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdENyZWF0b3InKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG52YXIgSW1hZ2UgPSByZXF1aXJlKCcuL0ltYWdlJyk7XHJcblxyXG4vLyAgV2hlbiByZWdpc3RlcmluZyBhIGZhY3RvcnkgZnVuY3Rpb24gJ3RoaXMnIHJlZmVycyB0byB0aGUgR2FtZU9iamVjdENyZWF0b3IgY29udGV4dC5cclxuXHJcbkdhbWVPYmplY3RDcmVhdG9yLnJlZ2lzdGVyKCdpbWFnZScsIGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHZhciBrZXkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2tleScsIG51bGwpO1xyXG4gICAgdmFyIGZyYW1lID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmcmFtZScsIG51bGwpO1xyXG5cclxuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSh0aGlzLnNjZW5lLCAwLCAwLCBrZXksIGZyYW1lKTtcclxuXHJcbiAgICBCdWlsZEdhbWVPYmplY3QodGhpcy5zY2VuZSwgaW1hZ2UsIGNvbmZpZyk7XHJcblxyXG4gICAgcmV0dXJuIGltYWdlO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUNyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDUwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW1hZ2UgPSByZXF1aXJlKCcuL0ltYWdlJyk7XHJcbnZhciBHYW1lT2JqZWN0RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdEZhY3RvcnknKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0RmFjdG9yeSBjb250ZXh0LlxyXG4vLyAgXHJcbi8vICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9wZXJ0aWVzIGF2YWlsYWJsZSB0byB1c2U6XHJcbi8vICBcclxuLy8gIHRoaXMuc2NlbmUgLSBhIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhhdCBvd25zIHRoZSBHYW1lT2JqZWN0RmFjdG9yeVxyXG4vLyAgdGhpcy5kaXNwbGF5TGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBEaXNwbGF5IExpc3QgdGhlIFNjZW5lIG93bnNcclxuLy8gIHRoaXMudXBkYXRlTGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBVcGRhdGUgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG5cclxuR2FtZU9iamVjdEZhY3RvcnkucmVnaXN0ZXIoJ2ltYWdlJywgZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmRpc3BsYXlMaXN0LmFkZChuZXcgSW1hZ2UodGhpcy5zY2VuZSwgeCwgeSwga2V5LCBmcmFtZSkpO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDUwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuLi8uLi91dGlscy9OT09QJyk7XHJcbnZhciByZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9OT09QJyk7XHJcblxyXG5pZiAoV0VCR0xfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlcldlYkdMID0gcmVxdWlyZSgnLi9JbWFnZVdlYkdMUmVuZGVyZXInKTtcclxufVxyXG5cclxuaWYgKENBTlZBU19SRU5ERVJFUilcclxue1xyXG4gICAgcmVuZGVyQ2FudmFzID0gcmVxdWlyZSgnLi9JbWFnZUNhbnZhc1JlbmRlcmVyJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlcldlYkdMOiByZW5kZXJXZWJHTCxcclxuICAgIHJlbmRlckNhbnZhczogcmVuZGVyQ2FudmFzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgSW1hZ2VXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmIChHYW1lT2JqZWN0LlJFTkRFUl9NQVNLICE9PSBzcmMucmVuZGVyRmxhZ3MgfHwgKHNyYy5jYW1lcmFGaWx0ZXIgPiAwICYmIChzcmMuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmVuZGVyZXIuc3ByaXRlQmF0Y2guYWRkU3ByaXRlKHNyYywgY2FtZXJhKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE1BWF9MSUdIVFM6IDEwLFxyXG4gICAgREVGRVJSRURfTUFYX0xJR0hUUzogMTAwXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2xpZ2h0bGF5ZXIvQ29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDUwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyZXIvd2ViZ2wvcmVzb3VyY2VzL1ZlcnRleEJ1ZmZlcicpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxuXHJcbnZhciBEZWZlcnJlZFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBsaWdodExheWVyLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICB2YXIgc3ByaXRlTGlzdCA9IGxpZ2h0TGF5ZXIuc3ByaXRlcztcclxuICAgIHZhciBsZW5ndGggPSBzcHJpdGVMaXN0Lmxlbmd0aDtcclxuICAgIHZhciBiYXRjaCA9IHJlbmRlcmVyLnNwcml0ZUJhdGNoO1xyXG4gICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IGxpZ2h0TGF5ZXIucmVuZGVyRmxhZ3MgfHwgbGVuZ3RoID09PSAwIHx8IChsaWdodExheWVyLmNhbWVyYUZpbHRlciA+IDAgJiYgKGxpZ2h0TGF5ZXIuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudFJlbmRlcmVyICE9PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGJhdGNoLmJpbmQobGlnaHRMYXllci5nQnVmZmVyU2hhZGVyUGFzcyk7XHJcbiAgICBiYXRjaC5pbmRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICBsaWdodExheWVyLnVwZGF0ZUxpZ2h0cyhyZW5kZXJlciwgY2FtZXJhLCBsaWdodExheWVyLmxpZ2h0UGFzc1NoYWRlcik7XHJcblxyXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBsaWdodExheWVyLmdCdWZmZXJGYm8pO1xyXG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcclxuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHNwcml0ZU5vcm1hbFBhaXIgPSBzcHJpdGVMaXN0W2luZGV4XTtcclxuICAgICAgICB2YXIgZ2FtZU9iamVjdCA9IHNwcml0ZU5vcm1hbFBhaXIuc3ByaXRlUmVmO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8qIElubGluZWQgZnVuY3Rpb24gb2YgYWRkIHNwcml0ZSBtb2RpZmllZC4gKi9cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wTWF0cml4ID0gYmF0Y2gudGVtcE1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIGZyYW1lID0gZ2FtZU9iamVjdC5mcmFtZTtcclxuICAgICAgICAgICAgdmFyIGZvcmNlRmxpcFkgPSAoZnJhbWUudGV4dHVyZS5zb3VyY2VbZnJhbWUuc291cmNlSW5kZXhdLmdsVGV4dHVyZS5pc1JlbmRlclRleHR1cmUgPyB0cnVlIDogZmFsc2UpO1xyXG4gICAgICAgICAgICB2YXIgZmxpcFggPSBnYW1lT2JqZWN0LmZsaXBYO1xyXG4gICAgICAgICAgICB2YXIgZmxpcFkgPSBnYW1lT2JqZWN0LmZsaXBZIF4gZm9yY2VGbGlwWTtcclxuICAgICAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBiYXRjaC52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0RjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgdmFyIHV2cyA9IGZyYW1lLnV2cztcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGggKiAoZmxpcFggPyAtMSA6IDEpO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0ICogKGZsaXBZID8gLTEgOiAxKTtcclxuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVggPSBnYW1lT2JqZWN0LnggLSBjYW1lcmEuc2Nyb2xsWCAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICAgICAgdmFyIHNjYWxlWCA9IGdhbWVPYmplY3Quc2NhbGVYO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVZID0gZ2FtZU9iamVjdC5zY2FsZVk7XHJcbiAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IC1nYW1lT2JqZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB2YXIgdGVtcE1hdHJpeE1hdHJpeCA9IHRlbXBNYXRyaXgubWF0cml4O1xyXG4gICAgICAgICAgICB2YXIgeCA9IC1nYW1lT2JqZWN0LmRpc3BsYXlPcmlnaW5YICsgZnJhbWUueCArICgoZnJhbWUud2lkdGgpICogKGZsaXBYID8gMSA6IDAuMCkpO1xyXG4gICAgICAgICAgICB2YXIgeSA9IC1nYW1lT2JqZWN0LmRpc3BsYXlPcmlnaW5ZICsgZnJhbWUueSArICgoZnJhbWUuaGVpZ2h0KSAqIChmbGlwWSA/IDEgOiAwLjApKTtcclxuICAgICAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgeWggPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgICAgICAgICAgdmFyIHNyYSwgc3JiLCBzcmMsIHNyZCwgc3JlLCBzcmYsIGNtYSwgY21iLCBjbWMsIGNtZCwgY21lLCBjbWY7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYVRMID0gZ2FtZU9iamVjdC5fYWxwaGFUTDtcclxuICAgICAgICAgICAgdmFyIGFscGhhVFIgPSBnYW1lT2JqZWN0Ll9hbHBoYVRSO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGFCTCA9IGdhbWVPYmplY3QuX2FscGhhQkw7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYUJSID0gZ2FtZU9iamVjdC5fYWxwaGFCUjtcclxuICAgICAgICAgICAgdmFyIHRpbnRUTCA9IGdhbWVPYmplY3QuX3RpbnRUTDtcclxuICAgICAgICAgICAgdmFyIHRpbnRUUiA9IGdhbWVPYmplY3QuX3RpbnRUUjtcclxuICAgICAgICAgICAgdmFyIHRpbnRCTCA9IGdhbWVPYmplY3QuX3RpbnRCTDtcclxuICAgICAgICAgICAgdmFyIHRpbnRCUiA9IGdhbWVPYmplY3QuX3RpbnRCUjtcclxuXHJcbiAgICAgICAgICAgIHRlbXBNYXRyaXguYXBwbHlJVFJTKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSk7XHJcblxyXG4gICAgICAgICAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgICAgICAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xyXG4gICAgICAgICAgICBzcmMgPSB0ZW1wTWF0cml4TWF0cml4WzJdO1xyXG4gICAgICAgICAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgICAgICAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xyXG4gICAgICAgICAgICBzcmYgPSB0ZW1wTWF0cml4TWF0cml4WzVdO1xyXG5cclxuICAgICAgICAgICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgICAgICAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICAgICAgICAgIGNtYyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgICAgICAgICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgICAgICAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICAgICAgICAgIGNtZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgICAgICAgICAgbXZiID0gc3JhICogY21iICsgc3JiICogY21kO1xyXG4gICAgICAgICAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XHJcbiAgICAgICAgICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgICAgICAgICAgbXZlID0gc3JlICogY21hICsgc3JmICogY21jICsgY21lO1xyXG4gICAgICAgICAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0eDAgPSB4ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICAgICAgdHkwID0geCAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgICAgIHR4MSA9IHggKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICAgICAgdHkxID0geCAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgICAgICB0eDIgPSB4dyAqIG12YSArIHloICogbXZjICsgbXZlO1xyXG4gICAgICAgICAgICB0eTIgPSB4dyAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgICAgICB0eDMgPSB4dyAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgICAgIHR5MyA9IHh3ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuXHJcbiAgICBcclxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRUZXh0dXJlWzBdICE9PSBmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlIHx8XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5jdXJyZW50VGV4dHVyZVsxXSAhPT0gc3ByaXRlTm9ybWFsUGFpci5ub3JtYWxUZXh0dXJlUmVmLnNvdXJjZVtzcHJpdGVOb3JtYWxQYWlyLnNwcml0ZVJlZi5mcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlIHx8XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5zaG91bGRGbHVzaCgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5mbHVzaChsaWdodExheWVyLmdCdWZmZXJTaGFkZXJQYXNzLCBsaWdodExheWVyLnJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRUZXh0dXJlKGZyYW1lLnRleHR1cmUuc291cmNlW2ZyYW1lLnNvdXJjZUluZGV4XS5nbFRleHR1cmUsIDApO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0VGV4dHVyZShzcHJpdGVOb3JtYWxQYWlyLm5vcm1hbFRleHR1cmVSZWYuc291cmNlW3Nwcml0ZU5vcm1hbFBhaXIuc3ByaXRlUmVmLmZyYW1lLnNvdXJjZUluZGV4XS5nbFRleHR1cmUsIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiYXRjaC5kcmF3SW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJhdGNoLmRyYXdpbmdNZXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjQpO1xyXG4gICAgICAgICAgICBiYXRjaC5lbGVtZW50Q291bnQgKz0gNjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vICBUb3AgTGVmdFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngwO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkwO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludFRMO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGFUTDtcclxuXHJcbiAgICAgICAgICAgIC8vICBCb3R0b20gTGVmdFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkxO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngxO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkxO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludEJMO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGFCTDtcclxuXHJcbiAgICAgICAgICAgIC8vICBCb3R0b20gUmlnaHRcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnRCUjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhQlI7XHJcblxyXG4gICAgICAgICAgICAvLyAgVG9wIFJpZ2h0XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDM7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDM7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTM7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50VFI7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYVRSO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBiYXRjaC5mbHVzaChsaWdodExheWVyLmdCdWZmZXJTaGFkZXJQYXNzLCBsaWdodExheWVyLnJlbmRlclRhcmdldCk7XHJcbiAgICByZW5kZXJlci5zZXRUZXh0dXJlKHt0ZXh0dXJlOiBsaWdodExheWVyLmdCdWZmZXJDb2xvclRleH0sIDApO1xyXG4gICAgcmVuZGVyZXIuc2V0VGV4dHVyZSh7dGV4dHVyZTogbGlnaHRMYXllci5nQnVmZmVyTm9ybWFsVGV4fSwgMSk7XHJcblxyXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgIGxpZ2h0TGF5ZXIubGlnaHRQYXNzU2hhZGVyLmJpbmQoKTtcclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBsaWdodExheWVyLmxpZ2h0UGFzc1ZCTyk7XHJcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSgwKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoMCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIDApO1xyXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDMpO1xyXG4gICAgVmVydGV4QnVmZmVyLlNldERpcnR5KCk7XHJcbiAgICBiYXRjaC5iaW5kKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlZmVycmVkUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvbGlnaHRsYXllci9EZWZlcnJlZFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBMaWdodCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBMaWdodCAoeCwgeSwgeiwgcmFkaXVzLCByLCBnLCBiLCBhdHRlbnVhdGlvbilcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy56ID0gejtcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuICAgICAgICB0aGlzLnIgPSByO1xyXG4gICAgICAgIHRoaXMuZyA9IGc7XHJcbiAgICAgICAgdGhpcy5iID0gYjtcclxuICAgICAgICB0aGlzLmF0dGVudWF0aW9uID0gYXR0ZW51YXRpb247XHJcbiAgICAgICAgdGhpcy5zY3JvbGxGYWN0b3JYID0gMS4wO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRmFjdG9yWSA9IDEuMDtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoeCwgeSwgeiwgcmFkaXVzLCByLCBnLCBiLCBhdHRlbnVhdGlvbilcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy56ID0gejtcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuICAgICAgICB0aGlzLnIgPSByO1xyXG4gICAgICAgIHRoaXMuZyA9IGc7XHJcbiAgICAgICAgdGhpcy5iID0gYjtcclxuICAgICAgICB0aGlzLmF0dGVudWF0aW9uID0gYXR0ZW51YXRpb247XHJcbiAgICAgICAgdGhpcy5zY3JvbGxGYWN0b3JYID0gMS4wO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRmFjdG9yWSA9IDEuMDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9saWdodGxheWVyL0xpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA1MDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpZ2h0TGF5ZXJDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaWdodExheWVyQ2FudmFzUmVuZGVyZXI7XHJcbiBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2xpZ2h0bGF5ZXIvTGlnaHRMYXllckNhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJ1aWxkR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0J1aWxkR2FtZU9iamVjdCcpO1xyXG52YXIgR2FtZU9iamVjdENyZWF0b3IgPSByZXF1aXJlKCcuLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RDcmVhdG9yJyk7XHJcbnZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxudmFyIExpZ2h0TGF5ZXIgPSByZXF1aXJlKCcuL0xpZ2h0TGF5ZXInKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0Q3JlYXRvciBjb250ZXh0LlxyXG5cclxuR2FtZU9iamVjdENyZWF0b3IucmVnaXN0ZXIoJ2xpZ2h0TGF5ZXInLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIgcGFzcyA9IG5ldyBMaWdodExheWVyKHRoaXMuc2NlbmUpO1xyXG5cclxuICAgIEJ1aWxkR2FtZU9iamVjdCh0aGlzLnNjZW5lLCBwYXNzLCBjb25maWcpO1xyXG5cclxuICAgIHJldHVybiBwYXNzO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9saWdodGxheWVyL0xpZ2h0TGF5ZXJDcmVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1MDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpZ2h0TGF5ZXIgPSByZXF1aXJlKCcuL0xpZ2h0TGF5ZXInKTtcclxudmFyIEdhbWVPYmplY3RGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0RmFjdG9yeScpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RGYWN0b3J5IGNvbnRleHQuXHJcbi8vICBcclxuLy8gIFRoZXJlIGFyZSBzZXZlcmFsIHByb3BlcnRpZXMgYXZhaWxhYmxlIHRvIHVzZTpcclxuLy8gIFxyXG4vLyAgdGhpcy5zY2VuZSAtIGEgcmVmZXJlbmNlIHRvIHRoZSBTY2VuZSB0aGF0IG93bnMgdGhlIEdhbWVPYmplY3RGYWN0b3J5XHJcbi8vICB0aGlzLmRpc3BsYXlMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIERpc3BsYXkgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG4vLyAgdGhpcy51cGRhdGVMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIFVwZGF0ZSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcblxyXG5pZiAoV0VCR0xfUkVOREVSRVIpXHJcbntcclxuICAgIEdhbWVPYmplY3RGYWN0b3J5LnJlZ2lzdGVyKCdsaWdodExheWVyJywgZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5TGlzdC5hZGQobmV3IExpZ2h0TGF5ZXIodGhpcy5zY2VuZSkpO1xyXG4gICAgfSk7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9saWdodGxheWVyL0xpZ2h0TGF5ZXJGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA1MDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlcldlYkdMID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvTk9PUCcpO1xyXG52YXIgcmVuZGVyQ2FudmFzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvTk9PUCcpO1xyXG5cclxuaWYgKFdFQkdMX1JFTkRFUkVSKVxyXG57XHJcbiAgICByZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4vTGlnaHRMYXllcldlYkdMUmVuZGVyZXInKTtcclxufVxyXG5cclxuaWYgKENBTlZBU19SRU5ERVJFUilcclxue1xyXG4gICAgcmVuZGVyQ2FudmFzID0gcmVxdWlyZSgnLi9MaWdodExheWVyQ2FudmFzUmVuZGVyZXInKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgcmVuZGVyV2ViR0w6IHJlbmRlcldlYkdMLFxyXG4gICAgcmVuZGVyQ2FudmFzOiByZW5kZXJDYW52YXNcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvbGlnaHRsYXllci9MaWdodExheWVyUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdlYkdMU3VwcG9ydGVkRXh0ZW5zaW9ucyA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVyL3dlYmdsL1dlYkdMU3VwcG9ydGVkRXh0ZW5zaW9ucycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKFdlYkdMU3VwcG9ydGVkRXh0ZW5zaW9ucy5oYXMoJ1dFQkdMX2RyYXdfYnVmZmVycycpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL0RlZmVycmVkUmVuZGVyZXInKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi9Gb3J3YXJkUmVuZGVyZXInKTtcclxuICAgIH1cclxufSkoKTtcclxuXHJcbiBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2xpZ2h0bGF5ZXIvTGlnaHRMYXllcldlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxudmFyIFNwcml0ZU5vcm1hbFBhaXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gU3ByaXRlTm9ybWFsUGFpciAoc3ByaXRlLCBub3JtYWxUZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3ByaXRlUmVmID0gc3ByaXRlO1xyXG4gICAgICAgIHRoaXMubm9ybWFsVGV4dHVyZVJlZiA9IG5vcm1hbFRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKHNwcml0ZSwgbm9ybWFsVGV4dHVyZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNwcml0ZVJlZiA9IHNwcml0ZTtcclxuICAgICAgICB0aGlzLm5vcm1hbFRleHR1cmVSZWYgPSBub3JtYWxUZXh0dXJlO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZU5vcm1hbFBhaXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvbGlnaHRsYXllci9TcHJpdGVOb3JtYWxQYWlyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1lc2hDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lc2hDYW52YXNSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9tZXNoL01lc2hDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCdWlsZEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9CdWlsZEdhbWVPYmplY3QnKTtcclxudmFyIEdhbWVPYmplY3RDcmVhdG9yID0gcmVxdWlyZSgnLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xyXG52YXIgR2V0QWR2YW5jZWRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRBZHZhbmNlZFZhbHVlJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgTWVzaCA9IHJlcXVpcmUoJy4vTWVzaCcpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RDcmVhdG9yIGNvbnRleHQuXHJcblxyXG5HYW1lT2JqZWN0Q3JlYXRvci5yZWdpc3RlcignbWVzaCcsIGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHZhciBrZXkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2tleScsIG51bGwpO1xyXG4gICAgdmFyIGZyYW1lID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmcmFtZScsIG51bGwpO1xyXG4gICAgdmFyIHZlcnRpY2VzID0gR2V0VmFsdWUoY29uZmlnLCAndmVydGljZXMnLCBbXSk7XHJcbiAgICB2YXIgaW5kaWNlcyA9IEdldFZhbHVlKGNvbmZpZywgJ2luZGljZXMnLCBbXSk7XHJcbiAgICB2YXIgY29sb3JzID0gR2V0VmFsdWUoY29uZmlnLCAnY29sb3JzJywgW10pO1xyXG4gICAgdmFyIGFscGhhcyA9IEdldFZhbHVlKGNvbmZpZywgJ2FscGhhcycsIFtdKTtcclxuICAgIHZhciB1diA9IEdldFZhbHVlKGNvbmZpZywgJ3V2JywgW10pO1xyXG5cclxuICAgIHZhciBtZXNoID0gbmV3IE1lc2godGhpcy5zY2VuZSwgMCwgMCwgdmVydGljZXMsIHV2LCBpbmRpY2VzLCBjb2xvcnMsIGFscGhhcywga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHRoaXMuc2NlbmUsIG1lc2gsIGNvbmZpZyk7XHJcblxyXG4gICAgcmV0dXJuIG1lc2g7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL21lc2gvTWVzaENyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDUxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWVzaCA9IHJlcXVpcmUoJy4vTWVzaCcpO1xyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RGYWN0b3J5Jyk7XHJcblxyXG4vLyAgV2hlbiByZWdpc3RlcmluZyBhIGZhY3RvcnkgZnVuY3Rpb24gJ3RoaXMnIHJlZmVycyB0byB0aGUgR2FtZU9iamVjdEZhY3RvcnkgY29udGV4dC5cclxuLy8gIFxyXG4vLyAgVGhlcmUgYXJlIHNldmVyYWwgcHJvcGVydGllcyBhdmFpbGFibGUgdG8gdXNlOlxyXG4vLyAgXHJcbi8vICB0aGlzLnNjZW5lIC0gYSByZWZlcmVuY2UgdG8gdGhlIFNjZW5lIHRoYXQgb3ducyB0aGUgR2FtZU9iamVjdEZhY3RvcnlcclxuLy8gIHRoaXMuZGlzcGxheUxpc3QgLSBhIHJlZmVyZW5jZSB0byB0aGUgRGlzcGxheSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcbi8vICB0aGlzLnVwZGF0ZUxpc3QgLSBhIHJlZmVyZW5jZSB0byB0aGUgVXBkYXRlIExpc3QgdGhlIFNjZW5lIG93bnNcclxuXHJcbmlmIChXRUJHTF9SRU5ERVJFUilcclxue1xyXG4gICAgR2FtZU9iamVjdEZhY3RvcnkucmVnaXN0ZXIoJ21lc2gnLCBmdW5jdGlvbiAoeCwgeSwgdmVydGljZXMsIHV2LCBrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlMaXN0LmFkZChuZXcgTWVzaCh0aGlzLnNjZW5lLCB4LCB5LCB2ZXJ0aWNlcywgdXYsIGtleSwgZnJhbWUpKTtcclxuICAgIH0pO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvbWVzaC9NZXNoRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL05PT1AnKTtcclxudmFyIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL05PT1AnKTtcclxuXHJcbmlmIChXRUJHTF9SRU5ERVJFUilcclxue1xyXG4gICAgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuL01lc2hXZWJHTFJlbmRlcmVyJyk7XHJcbn1cclxuXHJcbmlmIChDQU5WQVNfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4vTWVzaENhbnZhc1JlbmRlcmVyJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlcldlYkdMOiByZW5kZXJXZWJHTCxcclxuICAgIHJlbmRlckNhbnZhczogcmVuZGVyQ2FudmFzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL21lc2gvTWVzaFJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG5cclxudmFyIE1lc2hXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmIChHYW1lT2JqZWN0LlJFTkRFUl9NQVNLICE9PSBzcmMucmVuZGVyRmxhZ3MgfHwgKHNyYy5jYW1lcmFGaWx0ZXIgPiAwICYmIChzcmMuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3JjLmluZGljZXMubGVuZ3RoID4gMClcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5zcHJpdGVCYXRjaC5hZGRNZXNoSW5kZXhlZChzcmMsIGNhbWVyYSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuc3ByaXRlQmF0Y2guYWRkTWVzaChzcmMsIGNhbWVyYSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lc2hXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL21lc2gvTWVzaFdlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdhbWVPYmplY3RzLlNwcml0ZVBvb2xcclxuXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBTcHJpdGUgPSByZXF1aXJlKCcuLi9zcHJpdGUvU3ByaXRlJyk7XHJcbnZhciBPYmplY3RQb29sID0gcmVxdWlyZSgnLi9PYmplY3RQb29sJyk7XHJcblxyXG4vLyAgQW4gT2JqZWN0IFBvb2xcclxuXHJcbnZhciBTcHJpdGVQb29sID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBPYmplY3RQb29sLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gU3ByaXRlUG9vbCAobWFuYWdlciwgbWF4U2l6ZSwgcXVhbnRpdHksIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgT2JqZWN0UG9vbC5jYWxsKHRoaXMsIG1hbmFnZXIsIFNwcml0ZSwgbWF4U2l6ZSwgdGhpcy5tYWtlU3ByaXRlLCB0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0S2V5ID0ga2V5O1xyXG5cclxuICAgICAgICB0aGlzLmRlZmF1bHRGcmFtZSA9IGZyYW1lO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlU3ByaXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnYW1lT2JqZWN0ID0gbmV3IHRoaXMuY2xhc3NUeXBlKHRoaXMuc2NlbmUsIDAsIDAsIHRoaXMuZGVmYXVsdEtleSwgdGhpcy5kZWZhdWx0RnJhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmRpc3BsYXlMaXN0LmFkZChnYW1lT2JqZWN0KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxpc3QuYWRkKGdhbWVPYmplY3QpO1xyXG5cclxuICAgICAgICBnYW1lT2JqZWN0LnNldEFjdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgZ2FtZU9iamVjdC5zZXRWaXNpYmxlKGZhbHNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdhbWVPYmplY3QgPSB0aGlzLmdldEZyZWVHYW1lT2JqZWN0KCk7XHJcblxyXG4gICAgICAgIGdhbWVPYmplY3Quc2V0UG9zaXRpb24oeCwgeSk7XHJcblxyXG4gICAgICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZVBvb2w7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvcG9vbC9TcHJpdGVQb29sLmpzXG4vLyBtb2R1bGUgaWQgPSA1MThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJ1aWxkR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0J1aWxkR2FtZU9iamVjdCcpO1xyXG52YXIgR2FtZU9iamVjdENyZWF0b3IgPSByZXF1aXJlKCcuLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RDcmVhdG9yJyk7XHJcbnZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxudmFyIFF1YWQgPSByZXF1aXJlKCcuL1F1YWQnKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0Q3JlYXRvciBjb250ZXh0LlxyXG5cclxuR2FtZU9iamVjdENyZWF0b3IucmVnaXN0ZXIoJ3F1YWQnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIgeCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAneCcsIDApO1xyXG4gICAgdmFyIHkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3knLCAwKTtcclxuICAgIHZhciBrZXkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2tleScsIG51bGwpO1xyXG4gICAgdmFyIGZyYW1lID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmcmFtZScsIG51bGwpO1xyXG5cclxuICAgIHZhciBxdWFkID0gbmV3IFF1YWQodGhpcy5zY2VuZSwgeCwgeSwga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHRoaXMuc2NlbmUsIHF1YWQsIGNvbmZpZyk7XHJcblxyXG4gICAgcmV0dXJuIHF1YWQ7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3F1YWQvUXVhZENyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDUxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUXVhZCA9IHJlcXVpcmUoJy4vUXVhZCcpO1xyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RGYWN0b3J5Jyk7XHJcblxyXG4vLyAgV2hlbiByZWdpc3RlcmluZyBhIGZhY3RvcnkgZnVuY3Rpb24gJ3RoaXMnIHJlZmVycyB0byB0aGUgR2FtZU9iamVjdEZhY3RvcnkgY29udGV4dC5cclxuLy8gIFxyXG4vLyAgVGhlcmUgYXJlIHNldmVyYWwgcHJvcGVydGllcyBhdmFpbGFibGUgdG8gdXNlOlxyXG4vLyAgXHJcbi8vICB0aGlzLnNjZW5lIC0gYSByZWZlcmVuY2UgdG8gdGhlIFNjZW5lIHRoYXQgb3ducyB0aGUgR2FtZU9iamVjdEZhY3RvcnlcclxuLy8gIHRoaXMuZGlzcGxheUxpc3QgLSBhIHJlZmVyZW5jZSB0byB0aGUgRGlzcGxheSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcbi8vICB0aGlzLnVwZGF0ZUxpc3QgLSBhIHJlZmVyZW5jZSB0byB0aGUgVXBkYXRlIExpc3QgdGhlIFNjZW5lIG93bnNcclxuXHJcbmlmIChXRUJHTF9SRU5ERVJFUilcclxue1xyXG4gICAgR2FtZU9iamVjdEZhY3RvcnkucmVnaXN0ZXIoJ3F1YWQnLCBmdW5jdGlvbiAoeCwgeSwga2V5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5TGlzdC5hZGQobmV3IFF1YWQodGhpcy5zY2VuZSwgeCwgeSwga2V5LCBmcmFtZSkpO1xyXG4gICAgfSk7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9xdWFkL1F1YWRGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA1MjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlbmRlclBhc3NDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJQYXNzQ2FudmFzUmVuZGVyZXI7XHJcbiBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3JlbmRlcnBhc3MvUmVuZGVyUGFzc0NhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJ1aWxkR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0J1aWxkR2FtZU9iamVjdCcpO1xyXG52YXIgR2FtZU9iamVjdENyZWF0b3IgPSByZXF1aXJlKCcuLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RDcmVhdG9yJyk7XHJcbnZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxudmFyIFJlbmRlclBhc3MgPSByZXF1aXJlKCcuL1JlbmRlclBhc3MnKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0Q3JlYXRvciBjb250ZXh0LlxyXG5cclxuR2FtZU9iamVjdENyZWF0b3IucmVnaXN0ZXIoJ3JlbmRlclBhc3MnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIgeCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAneCcsIDApO1xyXG4gICAgdmFyIHkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3knLCAwKTtcclxuICAgIHZhciB3aWR0aCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnd2lkdGgnLCA1MTIpO1xyXG4gICAgdmFyIGhlaWdodCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnaGVpZ2h0JywgNTEyKTtcclxuICAgIHZhciBzaGFkZXJOYW1lID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdzaGFkZXJOYW1lJywgJycpO1xyXG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmcmFnbWVudFNoYWRlcicsICcnKTtcclxuXHJcbiAgICB2YXIgcGFzcyA9IG5ldyBSZW5kZXJQYXNzKHRoaXMuc2NlbmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHNoYWRlck5hbWUsIGZyYWdtZW50U2hhZGVyKTtcclxuXHJcbiAgICBCdWlsZEdhbWVPYmplY3QodGhpcy5zY2VuZSwgcGFzcywgY29uZmlnKTtcclxuXHJcbiAgICByZXR1cm4gcGFzcztcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvcmVuZGVycGFzcy9SZW5kZXJQYXNzQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZW5kZXJQYXNzID0gcmVxdWlyZSgnLi9SZW5kZXJQYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdEZhY3RvcnknKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0RmFjdG9yeSBjb250ZXh0LlxyXG4vLyAgXHJcbi8vICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9wZXJ0aWVzIGF2YWlsYWJsZSB0byB1c2U6XHJcbi8vICBcclxuLy8gIHRoaXMuc2NlbmUgLSBhIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhhdCBvd25zIHRoZSBHYW1lT2JqZWN0RmFjdG9yeVxyXG4vLyAgdGhpcy5kaXNwbGF5TGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBEaXNwbGF5IExpc3QgdGhlIFNjZW5lIG93bnNcclxuLy8gIHRoaXMudXBkYXRlTGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBVcGRhdGUgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG5cclxuaWYgKFdFQkdMX1JFTkRFUkVSKVxyXG57XHJcbiAgICBHYW1lT2JqZWN0RmFjdG9yeS5yZWdpc3RlcigncmVuZGVyUGFzcycsIGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzaGFkZXJOYW1lLCBmcmFnbWVudFNoYWRlcilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5TGlzdC5hZGQobmV3IFJlbmRlclBhc3ModGhpcy5zY2VuZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc2hhZGVyTmFtZSwgZnJhZ21lbnRTaGFkZXIpKTtcclxuICAgIH0pO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvcmVuZGVycGFzcy9SZW5kZXJQYXNzRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL05PT1AnKTtcclxudmFyIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL05PT1AnKTtcclxuXHJcbmlmIChXRUJHTF9SRU5ERVJFUilcclxue1xyXG4gICAgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuL1JlbmRlclBhc3NXZWJHTFJlbmRlcmVyJyk7XHJcbn1cclxuXHJcbmlmIChDQU5WQVNfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4vUmVuZGVyUGFzc0NhbnZhc1JlbmRlcmVyJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlcldlYkdMOiByZW5kZXJXZWJHTCxcclxuICAgIHJlbmRlckNhbnZhczogcmVuZGVyQ2FudmFzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3JlbmRlcnBhc3MvUmVuZGVyUGFzc1JlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG5cclxudmFyIFJlbmRlclBhc3NXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmIChHYW1lT2JqZWN0LlJFTkRFUl9NQVNLICE9PSBzcmMucmVuZGVyRmxhZ3MgfHwgKHNyYy5jYW1lcmFGaWx0ZXIgPiAwICYmIChzcmMuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJlci5zcHJpdGVCYXRjaC5hZGRTcHJpdGVUZXh0dXJlKHNyYywgY2FtZXJhLCBzcmMucmVuZGVyVGV4dHVyZSwgc3JjLndpZHRoLCBzcmMuaGVpZ2h0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyUGFzc1dlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvcmVuZGVycGFzcy9SZW5kZXJQYXNzV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCdWlsZEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9CdWlsZEdhbWVPYmplY3QnKTtcclxudmFyIEJ1aWxkR2FtZU9iamVjdEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4uL0J1aWxkR2FtZU9iamVjdEFuaW1hdGlvbicpO1xyXG52YXIgR2FtZU9iamVjdENyZWF0b3IgPSByZXF1aXJlKCcuLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RDcmVhdG9yJyk7XHJcbnZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxudmFyIFNwcml0ZTNEID0gcmVxdWlyZSgnLi9TcHJpdGUzRCcpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RDcmVhdG9yIGNvbnRleHQuXHJcblxyXG5HYW1lT2JqZWN0Q3JlYXRvci5yZWdpc3Rlcignc3ByaXRlM0QnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIga2V5ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdrZXknLCBudWxsKTtcclxuICAgIHZhciBmcmFtZSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnZnJhbWUnLCBudWxsKTtcclxuXHJcbiAgICB2YXIgc3ByaXRlID0gbmV3IFNwcml0ZTNEKHRoaXMuc2NlbmUsIDAsIDAsIGtleSwgZnJhbWUpO1xyXG5cclxuICAgIEJ1aWxkR2FtZU9iamVjdCh0aGlzLnNjZW5lLCBzcHJpdGUsIGNvbmZpZyk7XHJcblxyXG4gICAgLy8gIFNwcml0ZSBzcGVjaWZpYyBjb25maWcgb3B0aW9uczpcclxuXHJcbiAgICBCdWlsZEdhbWVPYmplY3RBbmltYXRpb24oc3ByaXRlLCBjb25maWcpO1xyXG5cclxuICAgIC8vICBQaHlzaWNzLCBJbnB1dCwgZXRjIHRvIGZvbGxvdyAuLi5cclxuXHJcbiAgICByZXR1cm4gc3ByaXRlO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9zcHJpdGUzZC9TcHJpdGUzRENyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDUyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3ByaXRlM0QgPSByZXF1aXJlKCcuL1Nwcml0ZTNEJyk7XHJcbnZhciBHYW1lT2JqZWN0RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdEZhY3RvcnknKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0RmFjdG9yeSBjb250ZXh0LlxyXG4vLyAgXHJcbi8vICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9wZXJ0aWVzIGF2YWlsYWJsZSB0byB1c2U6XHJcbi8vICBcclxuLy8gIHRoaXMuc2NlbmUgLSBhIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhhdCBvd25zIHRoZSBHYW1lT2JqZWN0RmFjdG9yeVxyXG4vLyAgdGhpcy5kaXNwbGF5TGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBEaXNwbGF5IExpc3QgdGhlIFNjZW5lIG93bnNcclxuLy8gIHRoaXMudXBkYXRlTGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBVcGRhdGUgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG5cclxuR2FtZU9iamVjdEZhY3RvcnkucmVnaXN0ZXIoJ3Nwcml0ZTNEJywgZnVuY3Rpb24gKHgsIHksIHosIGtleSwgZnJhbWUpXHJcbntcclxuICAgIHZhciBzcHJpdGUgPSBuZXcgU3ByaXRlM0QodGhpcy5zY2VuZSwgeCwgeSwgeiwga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgdGhpcy5kaXNwbGF5TGlzdC5hZGQoc3ByaXRlLmdhbWVPYmplY3QpO1xyXG4gICAgdGhpcy51cGRhdGVMaXN0LmFkZChzcHJpdGUuZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIHNwcml0ZTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvc3ByaXRlM2QvU3ByaXRlM0RGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA1Mjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgU3ByaXRlQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IHNyYy5yZW5kZXJGbGFncyB8fCAoc3JjLmNhbWVyYUZpbHRlciA+IDAgJiYgKHNyYy5jYW1lcmFGaWx0ZXIgJiBjYW1lcmEuX2lkKSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcmVyLmRyYXdJbWFnZShzcmMsIGNhbWVyYSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCdWlsZEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9CdWlsZEdhbWVPYmplY3QnKTtcclxudmFyIEJ1aWxkR2FtZU9iamVjdEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4uL0J1aWxkR2FtZU9iamVjdEFuaW1hdGlvbicpO1xyXG52YXIgR2FtZU9iamVjdENyZWF0b3IgPSByZXF1aXJlKCcuLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RDcmVhdG9yJyk7XHJcbnZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxudmFyIFNwcml0ZSA9IHJlcXVpcmUoJy4vU3ByaXRlJyk7XHJcblxyXG4vLyAgV2hlbiByZWdpc3RlcmluZyBhIGZhY3RvcnkgZnVuY3Rpb24gJ3RoaXMnIHJlZmVycyB0byB0aGUgR2FtZU9iamVjdENyZWF0b3IgY29udGV4dC5cclxuXHJcbkdhbWVPYmplY3RDcmVhdG9yLnJlZ2lzdGVyKCdzcHJpdGUnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIga2V5ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdrZXknLCBudWxsKTtcclxuICAgIHZhciBmcmFtZSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnZnJhbWUnLCBudWxsKTtcclxuXHJcbiAgICB2YXIgc3ByaXRlID0gbmV3IFNwcml0ZSh0aGlzLnNjZW5lLCAwLCAwLCBrZXksIGZyYW1lKTtcclxuXHJcbiAgICBCdWlsZEdhbWVPYmplY3QodGhpcy5zY2VuZSwgc3ByaXRlLCBjb25maWcpO1xyXG5cclxuICAgIC8vICBTcHJpdGUgc3BlY2lmaWMgY29uZmlnIG9wdGlvbnM6XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0QW5pbWF0aW9uKHNwcml0ZSwgY29uZmlnKTtcclxuXHJcbiAgICAvLyAgUGh5c2ljcywgSW5wdXQsIGV0YyB0byBmb2xsb3cgLi4uXHJcblxyXG4gICAgcmV0dXJuIHNwcml0ZTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZUNyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDUyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3ByaXRlID0gcmVxdWlyZSgnLi9TcHJpdGUnKTtcclxudmFyIEdhbWVPYmplY3RGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0RmFjdG9yeScpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RGYWN0b3J5IGNvbnRleHQuXHJcbi8vICBcclxuLy8gIFRoZXJlIGFyZSBzZXZlcmFsIHByb3BlcnRpZXMgYXZhaWxhYmxlIHRvIHVzZTpcclxuLy8gIFxyXG4vLyAgdGhpcy5zY2VuZSAtIGEgcmVmZXJlbmNlIHRvIHRoZSBTY2VuZSB0aGF0IG93bnMgdGhlIEdhbWVPYmplY3RGYWN0b3J5XHJcbi8vICB0aGlzLmRpc3BsYXlMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIERpc3BsYXkgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG4vLyAgdGhpcy51cGRhdGVMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIFVwZGF0ZSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcblxyXG5HYW1lT2JqZWN0RmFjdG9yeS5yZWdpc3Rlcignc3ByaXRlJywgZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUpXHJcbntcclxuICAgIHZhciBzcHJpdGUgPSBuZXcgU3ByaXRlKHRoaXMuc2NlbmUsIHgsIHksIGtleSwgZnJhbWUpO1xyXG5cclxuICAgIHRoaXMuZGlzcGxheUxpc3QuYWRkKHNwcml0ZSk7XHJcbiAgICB0aGlzLnVwZGF0ZUxpc3QuYWRkKHNwcml0ZSk7XHJcblxyXG4gICAgcmV0dXJuIHNwcml0ZTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZUZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDUzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuLi8uLi91dGlscy9OT09QJyk7XHJcbnZhciByZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9OT09QJyk7XHJcblxyXG5pZiAoV0VCR0xfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlcldlYkdMID0gcmVxdWlyZSgnLi9TcHJpdGVXZWJHTFJlbmRlcmVyJyk7XHJcbn1cclxuXHJcbmlmIChDQU5WQVNfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4vU3ByaXRlQ2FudmFzUmVuZGVyZXInKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgcmVuZGVyV2ViR0w6IHJlbmRlcldlYkdMLFxyXG4gICAgcmVuZGVyQ2FudmFzOiByZW5kZXJDYW52YXNcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZVJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG5cclxudmFyIFNwcml0ZVdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IHNyYy5yZW5kZXJGbGFncyB8fCAoc3JjLmNhbWVyYUZpbHRlciA+IDAgJiYgKHNyYy5jYW1lcmFGaWx0ZXIgJiBjYW1lcmEuX2lkKSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcmVyLnNwcml0ZUJhdGNoLmFkZFNwcml0ZShzcmMsIGNhbWVyYSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZVdlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZVdlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIEdldFRleHRTaXplID0gZnVuY3Rpb24gKHRleHQsIHNpemUsIGxpbmVzKVxyXG57XHJcbiAgICB2YXIgY2FudmFzID0gdGV4dC5jYW52YXM7XHJcbiAgICB2YXIgY29udGV4dCA9IHRleHQuY29udGV4dDtcclxuICAgIHZhciBzdHlsZSA9IHRleHQuc3R5bGU7XHJcblxyXG4gICAgdmFyIGxpbmVXaWR0aHMgPSBbXTtcclxuICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xyXG4gICAgdmFyIGRyYXduTGluZXMgPSBsaW5lcy5sZW5ndGg7XHJcbiAgICBcclxuICAgIGlmIChzdHlsZS5tYXhMaW5lcyA+IDAgJiYgc3R5bGUubWF4TGluZXMgPCBsaW5lcy5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgZHJhd25MaW5lcyA9IHN0eWxlLm1heExpbmVzO1xyXG4gICAgfVxyXG5cclxuICAgIHN0eWxlLnN5bmNGb250KGNhbnZhcywgY29udGV4dCk7XHJcblxyXG4gICAgLy8gIFRleHQgV2lkdGhcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYXduTGluZXM7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xyXG5cclxuICAgICAgICBsaW5lV2lkdGggKz0gY29udGV4dC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGg7XHJcblxyXG4gICAgICAgIC8vIEFkanVzdCBmb3Igd3JhcHBlZCB0ZXh0XHJcbiAgICAgICAgaWYgKHN0eWxlLndvcmRXcmFwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGluZVdpZHRoIC09IGNvbnRleHQubWVhc3VyZVRleHQoJyAnKS53aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpbmVXaWR0aHNbaV0gPSBNYXRoLmNlaWwobGluZVdpZHRoKTtcclxuICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxpbmVXaWR0aHNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBUZXh0IEhlaWdodFxyXG5cclxuICAgIHZhciBsaW5lSGVpZ2h0ID0gc2l6ZS5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcclxuICAgIHZhciBoZWlnaHQgPSBsaW5lSGVpZ2h0ICogZHJhd25MaW5lcztcclxuICAgIHZhciBsaW5lU3BhY2luZyA9IHRleHQuX2xpbmVTcGFjaW5nIHx8IDA7XHJcblxyXG4gICAgaWYgKGxpbmVTcGFjaW5nIDwgMCAmJiBNYXRoLmFicyhsaW5lU3BhY2luZykgPiBsaW5lSGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIGxpbmVTcGFjaW5nID0gLWxpbmVIZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFkanVzdCBmb3IgbGluZSBzcGFjaW5nXHJcbiAgICBpZiAobGluZVNwYWNpbmcgIT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgaGVpZ2h0ICs9IChsaW5lU3BhY2luZyA+IDApID8gbGluZVNwYWNpbmcgKiBsaW5lcy5sZW5ndGggOiBsaW5lU3BhY2luZyAqIChsaW5lcy5sZW5ndGggLSAxKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHdpZHRoOiBtYXhMaW5lV2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgbGluZXM6IGRyYXduTGluZXMsXHJcbiAgICAgICAgbGluZVdpZHRoczogbGluZVdpZHRocyxcclxuICAgICAgICBsaW5lU3BhY2luZzogbGluZVNwYWNpbmcsXHJcbiAgICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodFxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VGV4dFNpemU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGV4dC9HZXRUZXh0U2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vLi4vZG9tL0NhbnZhc1Bvb2wnKTtcclxuXHJcbi8qKlxyXG4qIENhbGN1bGF0ZXMgdGhlIGFzY2VudCwgZGVzY2VudCBhbmQgZm9udFNpemUgb2YgYSBnaXZlbiBmb250IHN0eWxlLlxyXG4qL1xyXG52YXIgTWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dFN0eWxlLCB0ZXN0U3RyaW5nKVxyXG57XHJcbiAgICBpZiAodGVzdFN0cmluZyA9PT0gdW5kZWZpbmVkKSB7IHRlc3RTdHJpbmcgPSAnfE3DiXFneSc7IH1cclxuXHJcbiAgICAvLyBAcHJvcGVydHkge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCB0aGUgdGV4dCBpcyByZW5kZXJlZC5cclxuICAgIHZhciBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZSh0aGlzKTtcclxuXHJcbiAgICAvLyBAcHJvcGVydHkge0hUTUxDYW52YXNFbGVtZW50fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgb2YgdGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgdGhlIHRleHQgaXMgcmVuZGVyZWQgdG8uXHJcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIHRleHRTdHlsZS5zeW5jRm9udChjYW52YXMsIGNvbnRleHQpO1xyXG5cclxuICAgIHZhciB3aWR0aCA9IE1hdGguY2VpbChjb250ZXh0Lm1lYXN1cmVUZXh0KHRlc3RTdHJpbmcpLndpZHRoICogMS4yKTtcclxuICAgIHZhciBiYXNlbGluZSA9IHdpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IDIgKiBiYXNlbGluZTtcclxuXHJcbiAgICBiYXNlbGluZSA9IGJhc2VsaW5lICogMS40IHwgMDtcclxuXHJcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2YwMCc7XHJcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIGNvbnRleHQuZm9udCA9IHRleHRTdHlsZS5mb250O1xyXG5cclxuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnIzAwMCc7XHJcbiAgICBjb250ZXh0LmZpbGxUZXh0KHRlc3RTdHJpbmcsIDAsIGJhc2VsaW5lKTtcclxuXHJcbiAgICB2YXIgb3V0cHV0ID0ge1xyXG4gICAgICAgIGFzY2VudDogMCxcclxuICAgICAgICBkZXNjZW50OiAwLFxyXG4gICAgICAgIGZvbnRTaXplOiAwXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LmFzY2VudCA9IGJhc2VsaW5lO1xyXG4gICAgICAgIG91dHB1dC5kZXNjZW50ID0gYmFzZWxpbmUgKyA2O1xyXG4gICAgICAgIG91dHB1dC5mb250U2l6ZSA9IG91dHB1dC5hc2NlbnQgKyBvdXRwdXQuZGVzY2VudDtcclxuXHJcbiAgICAgICAgQ2FudmFzUG9vbC5yZW1vdmUoY2FudmFzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW1hZ2VkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcclxuICAgIHZhciBwaXhlbHMgPSBpbWFnZWRhdGEubGVuZ3RoO1xyXG4gICAgdmFyIGxpbmUgPSB3aWR0aCAqIDQ7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIGlkeCA9IDA7XHJcbiAgICB2YXIgc3RvcCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIGFzY2VudC4gc2NhbiBmcm9tIHRvcCB0byBib3R0b20gdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcclxuICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlbGluZTsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsaW5lOyBqICs9IDQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghc3RvcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkeCArPSBsaW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb3V0cHV0LmFzY2VudCA9IGJhc2VsaW5lIC0gaTtcclxuXHJcbiAgICBpZHggPSBwaXhlbHMgLSBsaW5lO1xyXG4gICAgc3RvcCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIGRlc2NlbnQuIHNjYW4gZnJvbSBib3R0b20gdG8gdG9wIHVudGlsIHdlIGZpbmQgYSBub24gcmVkIHBpeGVsXHJcbiAgICBmb3IgKGkgPSBoZWlnaHQ7IGkgPiBiYXNlbGluZTsgaS0tKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsaW5lOyBqICs9IDQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghc3RvcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkeCAtPSBsaW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb3V0cHV0LmRlc2NlbnQgPSAoaSAtIGJhc2VsaW5lKTtcclxuICAgIG91dHB1dC5mb250U2l6ZSA9IG91dHB1dC5hc2NlbnQgKyBvdXRwdXQuZGVzY2VudDtcclxuXHJcbiAgICBDYW52YXNQb29sLnJlbW92ZShjYW52YXMpO1xyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lYXN1cmVUZXh0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RleHQvTWVhc3VyZVRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDUzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG52YXIgTWVhc3VyZVRleHQgPSByZXF1aXJlKCcuL01lYXN1cmVUZXh0Jyk7XHJcblxyXG4vLyAgS2V5OiBbIE9iamVjdCBLZXksIERlZmF1bHQgVmFsdWUgXVxyXG5cclxudmFyIHByb3BlcnR5TWFwID0ge1xyXG4gICAgZm9udDogWyAnZm9udCcsICcxNnB4IENvdXJpZXInIF0sXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFsgJ2JhY2tncm91bmRDb2xvcicsIG51bGwgXSxcclxuICAgIGZpbGw6IFsgJ2ZpbGwnLCAnI2ZmZicgXSxcclxuICAgIHN0cm9rZTogWyAnc3Ryb2tlJywgJyNmZmYnIF0sXHJcbiAgICBzdHJva2VUaGlja25lc3M6IFsgJ3N0cm9rZVRoaWNrbmVzcycsIDAgXSxcclxuICAgIHNoYWRvd09mZnNldFg6IFsgJ3NoYWRvdy5vZmZzZXRYJywgMCBdLFxyXG4gICAgc2hhZG93T2Zmc2V0WTogWyAnc2hhZG93Lm9mZnNldFknLCAwIF0sXHJcbiAgICBzaGFkb3dDb2xvcjogWyAnc2hhZG93LmNvbG9yJywgJyMwMDAnIF0sXHJcbiAgICBzaGFkb3dCbHVyOiBbICdzaGFkb3cuYmx1cicsIDAgXSxcclxuICAgIHNoYWRvd1N0cm9rZTogWyAnc2hhZG93LnN0cm9rZScsIGZhbHNlIF0sXHJcbiAgICBzaGFkb3dGaWxsOiBbICdzaGFkb3cuZmlsbCcsIGZhbHNlIF0sXHJcbiAgICBhbGlnbjogWyAnYWxpZ24nLCAnbGVmdCcgXSxcclxuICAgIG1heExpbmVzOiBbICdtYXhMaW5lcycsIDAgXSxcclxuICAgIGZpeGVkV2lkdGg6IFsgJ2ZpeGVkV2lkdGgnLCBmYWxzZSBdLFxyXG4gICAgZml4ZWRIZWlnaHQ6IFsgJ2ZpeGVkSGVpZ2h0JywgZmFsc2UgXSxcclxuICAgIHJ0bDogWyAncnRsJywgZmFsc2UgXVxyXG59O1xyXG5cclxudmFyIFRleHRTdHlsZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBUZXh0U3R5bGUgKHRleHQsIHN0eWxlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gdGV4dDtcclxuXHJcbiAgICAgICAgdGhpcy5mb250O1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIHRoaXMuZmlsbDtcclxuICAgICAgICB0aGlzLnN0cm9rZTtcclxuICAgICAgICB0aGlzLnN0cm9rZVRoaWNrbmVzcztcclxuICAgICAgICB0aGlzLnNoYWRvd09mZnNldFg7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRZO1xyXG4gICAgICAgIHRoaXMuc2hhZG93Q29sb3I7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dCbHVyO1xyXG4gICAgICAgIHRoaXMuc2hhZG93U3Ryb2tlO1xyXG4gICAgICAgIHRoaXMuc2hhZG93RmlsbDtcclxuICAgICAgICB0aGlzLmFsaWduO1xyXG4gICAgICAgIHRoaXMubWF4TGluZXM7XHJcbiAgICAgICAgdGhpcy5maXhlZFdpZHRoO1xyXG4gICAgICAgIHRoaXMuZml4ZWRIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5ydGw7XHJcblxyXG4gICAgICAgIC8vICBTZXQgdG8gZGVmYXVsdHNcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcblxyXG4gICAgICAgIGlmIChzdHlsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0eU1hcClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gR2V0QWR2YW5jZWRWYWx1ZShzdHlsZSwgcHJvcGVydHlNYXBba2V5XVswXSwgdGhpc1trZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1ldHJpY3MgPSBHZXRWYWx1ZShzdHlsZSwgJ21ldHJpY3MnLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vICBQcm92aWRlIG9wdGlvbmFsIFRleHRNZXRyaWNzIGluIHRoZSBzdHlsZSBvYmplY3QgdG8gYXZvaWQgdGhlIGNhbnZhcyBsb29rLXVwIC8gc2Nhbm5pbmdcclxuICAgICAgICAvLyAgRG9pbmcgdGhpcyBpcyB1bi1kb25lIGlmIHlvdSB0aGVuIGNoYW5nZSB0aGUgZm9udCBvZiB0aGlzIFRleHRTdHlsZSBhZnRlciBjcmVhdGlvblxyXG4gICAgICAgIGlmIChtZXRyaWNzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5tZXRyaWNzID0ge1xyXG4gICAgICAgICAgICAgICAgYXNjZW50OiBHZXRWYWx1ZShtZXRyaWNzLCAnYXNjZW50JywgMCksXHJcbiAgICAgICAgICAgICAgICBkZXNjZW50OiBHZXRWYWx1ZShtZXRyaWNzLCAnZGVzY2VudCcsIDApLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IEdldFZhbHVlKG1ldHJpY3MsICdmb250U2l6ZScsIDApXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMubWV0cmljcyA9IE1lYXN1cmVUZXh0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BlcnR5TWFwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpc1trZXldID0gcHJvcGVydHlNYXBba2V5XVsxXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzeW5jRm9udDogZnVuY3Rpb24gKGNhbnZhcywgY29udGV4dClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5ydGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW52YXMuZGlyID0gJ3J0bCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb250ZXh0LmZvbnQgPSB0aGlzLmZvbnQ7XHJcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XHJcblxyXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5maWxsO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZTtcclxuXHJcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVRoaWNrbmVzcztcclxuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSAncm91bmQnO1xyXG4gICAgICAgIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xyXG4gICAgfSxcclxuXHJcbiAgICBzeW5jU2hhZG93OiBmdW5jdGlvbiAoY29udGV4dCwgZW5hYmxlZClcclxuICAgIHtcclxuICAgICAgICBpZiAoZW5hYmxlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93T2Zmc2V0WDtcclxuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3dPZmZzZXRZO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3dDb2xvcjtcclxuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3dCbHVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gMDtcclxuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHJlY2FsY3VsYXRlTWV0cmljcylcclxuICAgIHtcclxuICAgICAgICBpZiAocmVjYWxjdWxhdGVNZXRyaWNzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5tZXRyaWNzID0gTWVhc3VyZVRleHQodGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQudXBkYXRlVGV4dCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0eU1hcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IEdldEFkdmFuY2VkVmFsdWUoc3R5bGUsIHByb3BlcnR5TWFwW2tleV1bMF0sIHRoaXNba2V5XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUodHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZvbnQ6IGZ1bmN0aW9uIChmb250KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSh0cnVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Rml4ZWRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZpeGVkV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmZpeGVkSGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAod2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRleHQud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoZWlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRleHQuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoY29sb3IpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RmlsbDogZnVuY3Rpb24gKGNvbG9yKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZmlsbCA9IGNvbG9yO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTdHJva2U6IGZ1bmN0aW9uIChjb2xvciwgdGhpY2tuZXNzKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjb2xvciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFJlc2V0IHRoZSBzdHJva2UgdG8gemVybyAoZGlzYWJsaW5nIGl0KVxyXG4gICAgICAgICAgICB0aGlzLnN0cm9rZVRoaWNrbmVzcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlja25lc3MgPT09IHVuZGVmaW5lZCkgeyB0aGlja25lc3MgPSB0aGlzLnN0cm9rZVRoaWNrbmVzczsgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBjb2xvcjtcclxuICAgICAgICAgICAgdGhpcy5zdHJva2VUaGlja25lc3MgPSB0aGlja25lc3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUodHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRvdzogZnVuY3Rpb24gKHgsIHksIGNvbG9yLCBibHVyLCBzaGFkb3dTdHJva2UsIHNoYWRvd0ZpbGwpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cclxuICAgICAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkgeyBjb2xvciA9ICcjMDAwJzsgfVxyXG4gICAgICAgIGlmIChibHVyID09PSB1bmRlZmluZWQpIHsgYmx1ciA9IDA7IH1cclxuICAgICAgICBpZiAoc2hhZG93U3Ryb2tlID09PSB1bmRlZmluZWQpIHsgc2hhZG93U3Ryb2tlID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAoc2hhZG93RmlsbCA9PT0gdW5kZWZpbmVkKSB7IHNoYWRvd0ZpbGwgPSB0cnVlOyB9XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZG93T2Zmc2V0WCA9IHg7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRZID0geTtcclxuICAgICAgICB0aGlzLnNoYWRvd0NvbG9yID0gY29sb3I7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dCbHVyID0gYmx1cjtcclxuICAgICAgICB0aGlzLnNoYWRvd1N0cm9rZSA9IHNoYWRvd1N0cm9rZTtcclxuICAgICAgICB0aGlzLnNoYWRvd0ZpbGwgPSBzaGFkb3dGaWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaGFkb3dPZmZzZXQ6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZG93T2Zmc2V0WCA9IHg7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRZID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZG93Q29sb3I6IGZ1bmN0aW9uIChjb2xvcilcclxuICAgIHtcclxuICAgICAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkgeyBjb2xvciA9ICcjMDAwJzsgfVxyXG5cclxuICAgICAgICB0aGlzLnNoYWRvd0NvbG9yID0gY29sb3I7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRvd0JsdXI6IGZ1bmN0aW9uIChibHVyKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChibHVyID09PSB1bmRlZmluZWQpIHsgYmx1ciA9IDA7IH1cclxuXHJcbiAgICAgICAgdGhpcy5zaGFkb3dCbHVyID0gYmx1cjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZG93U3Ryb2tlOiBmdW5jdGlvbiAoZW5hYmxlZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNoYWRvd1N0cm9rZSA9IGVuYWJsZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRvd0ZpbGw6IGZ1bmN0aW9uIChlbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2hhZG93RmlsbCA9IGVuYWJsZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEFsaWduOiBmdW5jdGlvbiAoYWxpZ24pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGFsaWduID09PSB1bmRlZmluZWQpIHsgYWxpZ24gPSAnbGVmdCc7IH1cclxuXHJcbiAgICAgICAgdGhpcy5hbGlnbiA9IGFsaWduO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRNYXhMaW5lczogZnVuY3Rpb24gKG1heClcclxuICAgIHtcclxuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHsgbWF4ID0gMDsgfVxyXG5cclxuICAgICAgICB0aGlzLm1heExpbmVzID0gbWF4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUZXh0TWV0cmljczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubWV0cmljcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYXNjZW50OiBtZXRyaWNzLmFzY2VudCxcclxuICAgICAgICAgICAgZGVzY2VudDogbWV0cmljcy5kZXNjZW50LFxyXG4gICAgICAgICAgICBmb250U2l6ZTogbWV0cmljcy5mb250U2l6ZVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0ge307XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0eU1hcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gdGhpc1trZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3V0cHV0Lm1ldHJpY3MgPSB0aGlzLmdldFRleHRNZXRyaWNzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dFN0eWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RleHQvVGV4dFN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgVGV4dENhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmIChHYW1lT2JqZWN0LlJFTkRFUl9NQVNLICE9PSBzcmMucmVuZGVyRmxhZ3MgfHwgKHNyYy5jYW1lcmFGaWx0ZXIgPiAwICYmIChzcmMuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIGN0eCA9IHJlbmRlcmVyLmN1cnJlbnRDb250ZXh0O1xyXG5cclxuICAgIC8vICBCbGVuZCBNb2RlXHJcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSAhPT0gc3JjLmJsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlID0gc3JjLmJsZW5kTW9kZTtcclxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gcmVuZGVyZXIuYmxlbmRNb2Rlc1tzcmMuYmxlbmRNb2RlXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQWxwaGFcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QWxwaGEgIT09IHNyYy5hbHBoYSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50QWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTbW9vdGhpbmdcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50U2NhbGVNb2RlICE9PSBzcmMuc2NhbGVNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgPSBzcmMuc2NhbGVNb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjYW52YXMgPSBzcmMuY2FudmFzO1xyXG5cclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKHNyYy54IC0gY2FtZXJhLnNjcm9sbFggKiBzcmMuc2Nyb2xsRmFjdG9yWCwgc3JjLnkgLSBjYW1lcmEuc2Nyb2xsWSAqIHNyYy5zY3JvbGxGYWN0b3JZKTtcclxuICAgIGN0eC5yb3RhdGUoc3JjLnJvdGF0aW9uKTtcclxuICAgIGN0eC5zY2FsZShzcmMuc2NhbGVYLCBzcmMuc2NhbGVZKTtcclxuICAgIGN0eC50cmFuc2xhdGUoY2FudmFzLndpZHRoICogKHNyYy5mbGlwWCA/IDEgOiAwKSwgY2FudmFzLmhlaWdodCAqIChzcmMuZmxpcFkgPyAxIDogMCkpO1xyXG4gICAgY3R4LnNjYWxlKHNyYy5mbGlwWCA/IC0xIDogMSwgc3JjLmZsaXBZID8gLTEgOiAxKTtcclxuICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQsIC1zcmMuZGlzcGxheU9yaWdpblgsIC1zcmMuZGlzcGxheU9yaWdpblksIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0Q2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dENhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJ1aWxkR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL0J1aWxkR2FtZU9iamVjdCcpO1xyXG52YXIgR2FtZU9iamVjdENyZWF0b3IgPSByZXF1aXJlKCcuLi8uLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RDcmVhdG9yJyk7XHJcbnZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxudmFyIFRleHQgPSByZXF1aXJlKCcuL1RleHQnKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0Q3JlYXRvciBjb250ZXh0LlxyXG5cclxuR2FtZU9iamVjdENyZWF0b3IucmVnaXN0ZXIoJ3RleHQnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICAvLyBzdHlsZSBPYmplY3QgPSB7XHJcbiAgICAvLyAgICAgZm9udDogWyAnZm9udCcsICcxNnB4IENvdXJpZXInIF0sXHJcbiAgICAvLyAgICAgYmFja2dyb3VuZENvbG9yOiBbICdiYWNrZ3JvdW5kQ29sb3InLCBudWxsIF0sXHJcbiAgICAvLyAgICAgZmlsbDogWyAnZmlsbCcsICcjZmZmJyBdLFxyXG4gICAgLy8gICAgIHN0cm9rZTogWyAnc3Ryb2tlJywgJyNmZmYnIF0sXHJcbiAgICAvLyAgICAgc3Ryb2tlVGhpY2tuZXNzOiBbICdzdHJva2VUaGlja25lc3MnLCAwIF0sXHJcbiAgICAvLyAgICAgc2hhZG93T2Zmc2V0WDogWyAnc2hhZG93Lm9mZnNldFgnLCAwIF0sXHJcbiAgICAvLyAgICAgc2hhZG93T2Zmc2V0WTogWyAnc2hhZG93Lm9mZnNldFknLCAwIF0sXHJcbiAgICAvLyAgICAgc2hhZG93Q29sb3I6IFsgJ3NoYWRvdy5jb2xvcicsICcjMDAwJyBdLFxyXG4gICAgLy8gICAgIHNoYWRvd0JsdXI6IFsgJ3NoYWRvdy5ibHVyJywgMCBdLFxyXG4gICAgLy8gICAgIHNoYWRvd1N0cm9rZTogWyAnc2hhZG93LnN0cm9rZScsIGZhbHNlIF0sXHJcbiAgICAvLyAgICAgc2hhZG93RmlsbDogWyAnc2hhZG93LmZpbGwnLCBmYWxzZSBdLFxyXG4gICAgLy8gICAgIGFsaWduOiBbICdhbGlnbicsICdsZWZ0JyBdLFxyXG4gICAgLy8gICAgIG1heExpbmVzOiBbICdtYXhMaW5lcycsIDAgXSxcclxuICAgIC8vICAgICBmaXhlZFdpZHRoOiBbICdmaXhlZFdpZHRoJywgZmFsc2UgXSxcclxuICAgIC8vICAgICBmaXhlZEhlaWdodDogWyAnZml4ZWRIZWlnaHQnLCBmYWxzZSBdLFxyXG4gICAgLy8gICAgIHJ0bDogWyAncnRsJywgZmFsc2UgXVxyXG4gICAgLy8gfVxyXG5cclxuICAgIHZhciBjb250ZW50ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd0ZXh0JywgJycpO1xyXG4gICAgdmFyIHN0eWxlID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdzdHlsZScsIG51bGwpO1xyXG5cclxuICAgIHZhciB0ZXh0ID0gbmV3IFRleHQodGhpcy5zY2VuZSwgMCwgMCwgY29udGVudCwgc3R5bGUpO1xyXG5cclxuICAgIEJ1aWxkR2FtZU9iamVjdCh0aGlzLnNjZW5lLCB0ZXh0LCBjb25maWcpO1xyXG5cclxuICAgIC8vICBUZXh0IHNwZWNpZmljIGNvbmZpZyBvcHRpb25zOlxyXG5cclxuICAgIHRleHQuYXV0b1JvdW5kID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdhdXRvUm91bmQnLCB0cnVlKTtcclxuICAgIHRleHQucmVzb2x1dGlvbiA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAncmVzb2x1dGlvbicsIDEpO1xyXG5cclxuICAgIC8vICBQYWRkaW5nXHJcbiAgICAvLyAgRWl0aGVyOiB7IHBhZGRpbmc6IDIgfSBvciB7IHBhZGRpbmc6IHsgeDogMiwgeTogMiB9fVxyXG5cclxuICAgIHZhciBwYWRkaW5nID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdwYWRkaW5nJywgbnVsbCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJylcclxuICAgIHtcclxuICAgICAgICB0ZXh0LnBhZGRpbmcueCA9IHBhZGRpbmc7XHJcbiAgICAgICAgdGV4dC5wYWRkaW5nLnkgPSBwYWRkaW5nO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGFkZGluZyAhPT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICB0ZXh0LnBhZGRpbmcueCA9IEdldEFkdmFuY2VkVmFsdWUocGFkZGluZywgJ3gnLCAxKTtcclxuICAgICAgICB0ZXh0LnBhZGRpbmcueSA9IEdldEFkdmFuY2VkVmFsdWUocGFkZGluZywgJ3knLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICB0ZXh0LnVwZGF0ZVRleHQoKTtcclxuXHJcbiAgICByZXR1cm4gdGV4dDtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dENyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDUzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVGV4dCA9IHJlcXVpcmUoJy4vVGV4dCcpO1xyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RGYWN0b3J5Jyk7XHJcblxyXG4vLyAgV2hlbiByZWdpc3RlcmluZyBhIGZhY3RvcnkgZnVuY3Rpb24gJ3RoaXMnIHJlZmVycyB0byB0aGUgR2FtZU9iamVjdEZhY3RvcnkgY29udGV4dC5cclxuLy8gIFxyXG4vLyAgVGhlcmUgYXJlIHNldmVyYWwgcHJvcGVydGllcyBhdmFpbGFibGUgdG8gdXNlOlxyXG4vLyAgXHJcbi8vICB0aGlzLnNjZW5lIC0gYSByZWZlcmVuY2UgdG8gdGhlIFNjZW5lIHRoYXQgb3ducyB0aGUgR2FtZU9iamVjdEZhY3RvcnlcclxuLy8gIHRoaXMuZGlzcGxheUxpc3QgLSBhIHJlZmVyZW5jZSB0byB0aGUgRGlzcGxheSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcbi8vICB0aGlzLnVwZGF0ZUxpc3QgLSBhIHJlZmVyZW5jZSB0byB0aGUgVXBkYXRlIExpc3QgdGhlIFNjZW5lIG93bnNcclxuXHJcbkdhbWVPYmplY3RGYWN0b3J5LnJlZ2lzdGVyKCd0ZXh0JywgZnVuY3Rpb24gKHgsIHksIHRleHQsIHN0eWxlKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5kaXNwbGF5TGlzdC5hZGQobmV3IFRleHQodGhpcy5zY2VuZSwgeCwgeSwgdGV4dCwgc3R5bGUpKTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDUzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9OT09QJyk7XHJcbnZhciByZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9OT09QJyk7XHJcblxyXG5pZiAoV0VCR0xfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlcldlYkdMID0gcmVxdWlyZSgnLi9UZXh0V2ViR0xSZW5kZXJlcicpO1xyXG59XHJcblxyXG5pZiAoQ0FOVkFTX1JFTkRFUkVSKVxyXG57XHJcbiAgICByZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuL1RleHRDYW52YXNSZW5kZXJlcicpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJXZWJHTDogcmVuZGVyV2ViR0wsXHJcbiAgICByZW5kZXJDYW52YXM6IHJlbmRlckNhbnZhc1xyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0UmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1Mzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgVGV4dFdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IHNyYy5yZW5kZXJGbGFncyB8fCAoc3JjLmNhbWVyYUZpbHRlciA+IDAgJiYgKHNyYy5jYW1lcmFGaWx0ZXIgJiBjYW1lcmEuX2lkKSkgfHwgc3JjLnRleHQgPT09ICcnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHNyYy5kaXJ0eSlcclxuICAgIHtcclxuICAgICAgICBzcmMuY2FudmFzVGV4dHVyZSA9IHJlbmRlcmVyLnVwbG9hZENhbnZhc1RvR1BVKHNyYy5jYW52YXMsIHNyYy5jYW52YXNUZXh0dXJlLCB0cnVlKTtcclxuICAgICAgICBzcmMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmVuZGVyZXIuc3ByaXRlQmF0Y2guYWRkU3ByaXRlVGV4dHVyZShzcmMsIGNhbWVyYSwgc3JjLmNhbnZhc1RleHR1cmUsIHNyYy5jYW52YXMud2lkdGgsIHNyYy5jYW52YXMuaGVpZ2h0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dFdlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dFdlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBUaWxlIChwcm9wZXJ0aWVzKVxyXG57XHJcbiAgICB0aGlzLmluZGV4ID0gcHJvcGVydGllcy5pbmRleDtcclxuICAgIHRoaXMuaWQgPSBwcm9wZXJ0aWVzLmlkO1xyXG4gICAgdGhpcy54ID0gcHJvcGVydGllcy54O1xyXG4gICAgdGhpcy55ID0gcHJvcGVydGllcy55O1xyXG4gICAgdGhpcy53aWR0aCA9IHByb3BlcnRpZXMud2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IHByb3BlcnRpZXMuaGVpZ2h0O1xyXG4gICAgdGhpcy5mcmFtZVggPSBwcm9wZXJ0aWVzLmZyYW1lWDtcclxuICAgIHRoaXMuZnJhbWVZID0gcHJvcGVydGllcy5mcmFtZVk7XHJcbiAgICB0aGlzLmZyYW1lV2lkdGggPSBwcm9wZXJ0aWVzLmZyYW1lV2lkdGg7XHJcbiAgICB0aGlzLmZyYW1lSGVpZ2h0ID0gcHJvcGVydGllcy5mcmFtZUhlaWdodDtcclxuICAgIHRoaXMuYWxwaGEgPSAxLjA7XHJcbiAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjtcclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICB0aGlzLnRleHR1cmVXaWR0aCA9IHByb3BlcnRpZXMudGV4dHVyZVdpZHRoO1xyXG4gICAgdGhpcy50ZXh0dXJlSGVpZ2h0ID0gcHJvcGVydGllcy50ZXh0dXJlSGVpZ2h0O1xyXG4gICAgdGhpcy5ib3JkZXIgPSBwcm9wZXJ0aWVzLmJvcmRlcjtcclxuICAgIHRoaXMuY2VudGVyID0gcHJvcGVydGllcy5jZW50ZXI7IFxyXG59XHJcblxyXG5UaWxlLnByb3RvdHlwZS5zZXRJZCA9IGZ1bmN0aW9uIChpZClcclxue1xyXG4gICAgdmFyIHRpbGVJZCA9IHRoaXMuaWQgPSBpZDtcclxuICAgIHZhciB0aWxlV2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgdmFyIHRpbGVIZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgIHZhciBzZXRXaWR0aCA9IHRoaXMudGV4dHVyZVdpZHRoIC8gdGlsZVdpZHRoO1xyXG4gICAgdmFyIHRpbGVXaWR0aEJvcmRlciA9ICh0aWxlV2lkdGggKyB0aGlzLmJvcmRlciAqIDIpO1xyXG4gICAgdmFyIHRpbGVIZWlnaHRCb3JkZXIgPSAodGlsZUhlaWdodCArIHRoaXMuYm9yZGVyICogMik7XHJcbiAgICB2YXIgaGFsZlRpbGVXaWR0aCA9IHRpbGVXaWR0aEJvcmRlciAqIDAuNTtcclxuICAgIHZhciBoYWxmVGlsZUhlaWdodCA9IHRpbGVIZWlnaHRCb3JkZXIgKiAwLjU7XHJcbiAgICBpZiAoIXRoaXMuY2VudGVyKVxyXG4gICAge1xyXG4gICAgICAgIGhhbGZUaWxlV2lkdGggPSAwO1xyXG4gICAgICAgIGhhbGZUaWxlSGVpZ2h0ID0gMDtcclxuICAgIH1cclxuICAgIHZhciByZWN0eCA9ICgoKHRpbGVJZCAlIHNldFdpZHRoKXwwKSAqIHRpbGVXaWR0aEJvcmRlcikgKyBoYWxmVGlsZVdpZHRoO1xyXG4gICAgdmFyIHJlY3R5ID0gKCgodGlsZUlkIC8gc2V0V2lkdGgpfDApICogdGlsZUhlaWdodEJvcmRlcikgKyBoYWxmVGlsZUhlaWdodDtcclxuXHJcbiAgICB0aGlzLmZyYW1lWCA9IHJlY3R4O1xyXG4gICAgdGhpcy5mcmFtZVkgPSByZWN0eTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL2R5bmFtaWMvVGlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vR2FtZU9iamVjdCcpO1xyXG5cclxudmFyIFRpbGVtYXBDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgZ2FtZU9iamVjdCwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IGdhbWVPYmplY3QucmVuZGVyRmxhZ3MgfHwgKGdhbWVPYmplY3QuY2FtZXJhRmlsdGVyID4gMCAmJiAoZ2FtZU9iamVjdC5jYW1lcmFGaWx0ZXIgJiBjYW1lcmEuX2lkKSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGdhbWVPYmplY3QuY3VsbChjYW1lcmEpO1xyXG5cclxuICAgIHZhciB0aWxlcyA9IGdhbWVPYmplY3QuY3VsbGVkVGlsZXM7XHJcbiAgICB2YXIgdGlsZUNvdW50ID0gdGlsZXMubGVuZ3RoO1xyXG4gICAgdmFyIGltYWdlID0gZ2FtZU9iamVjdC5mcmFtZS5zb3VyY2UuaW1hZ2U7XHJcbiAgICB2YXIgc2Nyb2xsRmFjdG9yWCA9IGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgIHZhciBzY3JvbGxGYWN0b3JZID0gZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JZO1xyXG4gICAgdmFyIGFscGhhID0gZ2FtZU9iamVjdC5hbHBoYTtcclxuICAgIHZhciB0eCA9IGdhbWVPYmplY3QueCAtIGNhbWVyYS5zY3JvbGxYICogZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JYO1xyXG4gICAgdmFyIHR5ID0gZ2FtZU9iamVjdC55IC0gY2FtZXJhLnNjcm9sbFkgKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclk7XHJcbiAgICB2YXIgY3R4ID0gcmVuZGVyZXIuZ2FtZUNvbnRleHQ7XHJcblxyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcclxuICAgIGN0eC5yb3RhdGUoZ2FtZU9iamVjdC5yb3RhdGlvbik7XHJcbiAgICBjdHguc2NhbGUoZ2FtZU9iamVjdC5zY2FsZVgsIGdhbWVPYmplY3Quc2NhbGVZKTtcclxuICAgIGN0eC5zY2FsZShnYW1lT2JqZWN0LmZsaXBYID8gLTEgOiAxLCBnYW1lT2JqZWN0LmZsaXBZID8gLTEgOiAxKTtcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGlsZUNvdW50OyArK2luZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0aWxlID0gdGlsZXNbaW5kZXhdO1xyXG5cclxuICAgICAgICBjdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICBpbWFnZSwgXHJcbiAgICAgICAgICAgIHRpbGUuZnJhbWVYLCB0aWxlLmZyYW1lWSwgXHJcbiAgICAgICAgICAgIHRpbGUuZnJhbWVXaWR0aCwgdGlsZS5mcmFtZUhlaWdodCwgXHJcbiAgICAgICAgICAgIHRpbGUueCwgdGlsZS55LCBcclxuICAgICAgICAgICAgdGlsZS5mcmFtZVdpZHRoLCB0aWxlLmZyYW1lSGVpZ2h0XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaWxlbWFwQ2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZW1hcC9keW5hbWljL1RpbGVtYXBDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCdWlsZEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9CdWlsZEdhbWVPYmplY3QnKTtcclxudmFyIEdhbWVPYmplY3RDcmVhdG9yID0gcmVxdWlyZSgnLi4vLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxudmFyIFRpbGVtYXAgPSByZXF1aXJlKCcuL1RpbGVtYXAnKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0Q3JlYXRvciBjb250ZXh0LlxyXG5cclxuR2FtZU9iamVjdENyZWF0b3IucmVnaXN0ZXIoJ3RpbGVtYXAnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIgbWFwRGF0YSA9IEdldFZhbHVlKGNvbmZpZywgJ21hcC5kYXRhJywgbnVsbCk7XHJcbiAgICB2YXIgbWFwV2lkdGggPSBHZXRWYWx1ZShjb25maWcsICdtYXAud2lkdGgnLCAxKTtcclxuICAgIHZhciBtYXBIZWlnaHQgPSBHZXRWYWx1ZShjb25maWcsICdtYXAuaGVpZ2h0JywgMSk7XHJcblxyXG4gICAgdmFyIHggPSBHZXRWYWx1ZShjb25maWcsICd4JywgMCk7XHJcbiAgICB2YXIgeSA9IEdldFZhbHVlKGNvbmZpZywgJ3knLCAwKTtcclxuXHJcbiAgICB2YXIgdGlsZVdpZHRoID0gR2V0VmFsdWUoY29uZmlnLCAndGlsZS53aWR0aCcsIDE2KTtcclxuICAgIHZhciB0aWxlSGVpZ2h0ID0gR2V0VmFsdWUoY29uZmlnLCAndGlsZS5oZWlnaHQnLCAxNik7XHJcbiAgICB2YXIgdGlsZVRleHR1cmUgPSBHZXRWYWx1ZShjb25maWcsICd0aWxlLnRleHR1cmUnLCBudWxsKTtcclxuICAgIHZhciB0aWxlRnJhbWUgPSBHZXRWYWx1ZShjb25maWcsICd0aWxlLmZyYW1lJywgbnVsbCk7XHJcbiAgICB2YXIgdGlsZUJvcmRlciA9IEdldFZhbHVlKGNvbmZpZywgJ3RpbGUuYm9yZGVyJywgMCk7XHJcblxyXG4gICAgdmFyIG1hcCA9IG5ldyBUaWxlbWFwKHRoaXMuc2NlbmUsIG1hcERhdGEsIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgbWFwV2lkdGgsIG1hcEhlaWdodCwgdGlsZUJvcmRlciwgdGlsZVRleHR1cmUsIHRpbGVGcmFtZSk7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHRoaXMuc2NlbmUsIG1hcCwgY29uZmlnKTtcclxuXHJcbiAgICByZXR1cm4gbWFwO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL2R5bmFtaWMvVGlsZW1hcENyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDU0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVGlsZW1hcCA9IHJlcXVpcmUoJy4vVGlsZW1hcCcpO1xyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSByZXF1aXJlKCcuLi8uLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RGYWN0b3J5Jyk7XHJcblxyXG4vLyAgV2hlbiByZWdpc3RlcmluZyBhIGZhY3RvcnkgZnVuY3Rpb24gJ3RoaXMnIHJlZmVycyB0byB0aGUgR2FtZU9iamVjdEZhY3RvcnkgY29udGV4dC5cclxuLy8gIFxyXG4vLyAgVGhlcmUgYXJlIHNldmVyYWwgcHJvcGVydGllcyBhdmFpbGFibGUgdG8gdXNlOlxyXG4vLyAgXHJcbi8vICB0aGlzLnNjZW5lIC0gYSByZWZlcmVuY2UgdG8gdGhlIFNjZW5lIHRoYXQgb3ducyB0aGUgR2FtZU9iamVjdEZhY3RvcnlcclxuLy8gIHRoaXMuZGlzcGxheUxpc3QgLSBhIHJlZmVyZW5jZSB0byB0aGUgRGlzcGxheSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcbi8vICB0aGlzLnVwZGF0ZUxpc3QgLSBhIHJlZmVyZW5jZSB0byB0aGUgVXBkYXRlIExpc3QgdGhlIFNjZW5lIG93bnNcclxuXHJcbkdhbWVPYmplY3RGYWN0b3J5LnJlZ2lzdGVyKCd0aWxlbWFwJywgZnVuY3Rpb24gKG1hcERhdGEsIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgbWFwV2lkdGgsIG1hcEhlaWdodCwgdGlsZUJvcmRlciwgdGV4dHVyZSwgZnJhbWUpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmRpc3BsYXlMaXN0LmFkZChuZXcgVGlsZW1hcCh0aGlzLnNjZW5lLCBtYXBEYXRhLCB4LCB5LCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsIG1hcFdpZHRoLCBtYXBIZWlnaHQsIHRpbGVCb3JkZXIsIHRleHR1cmUsIGZyYW1lKSk7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVtYXAvZHluYW1pYy9UaWxlbWFwRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL05PT1AnKTtcclxudmFyIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL05PT1AnKTtcclxuXHJcbmlmIChXRUJHTF9SRU5ERVJFUilcclxue1xyXG4gICAgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuL1RpbGVtYXBXZWJHTFJlbmRlcmVyJyk7XHJcbn1cclxuXHJcbmlmIChDQU5WQVNfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4vVGlsZW1hcENhbnZhc1JlbmRlcmVyJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlcldlYkdMOiByZW5kZXJXZWJHTCxcclxuICAgIHJlbmRlckNhbnZhczogcmVuZGVyQ2FudmFzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVtYXAvZHluYW1pYy9UaWxlbWFwUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgVGlsZW1hcFdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGdhbWVPYmplY3QsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmIChHYW1lT2JqZWN0LlJFTkRFUl9NQVNLICE9PSBnYW1lT2JqZWN0LnJlbmRlckZsYWdzIHx8IChnYW1lT2JqZWN0LmNhbWVyYUZpbHRlciA+IDAgJiYgKGdhbWVPYmplY3QuY2FtZXJhRmlsdGVyICYgY2FtZXJhLl9pZCkpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBnYW1lT2JqZWN0LmN1bGwoY2FtZXJhKTtcclxuXHJcbiAgICB2YXIgcmVuZGVyVGlsZXMgPSBnYW1lT2JqZWN0LmN1bGxlZFRpbGVzO1xyXG4gICAgdmFyIGxlbmd0aCA9IHJlbmRlclRpbGVzLmxlbmd0aDtcclxuICAgIHZhciBiYXRjaCA9IHJlbmRlcmVyLnNwcml0ZUJhdGNoO1xyXG4gICAgdmFyIHRleHR1cmUgPSBnYW1lT2JqZWN0LnRleHR1cmUuc291cmNlWzBdLmdsVGV4dHVyZTtcclxuICAgIHZhciB0ZXh0dXJlV2lkdGggPSB0ZXh0dXJlLndpZHRoO1xyXG4gICAgdmFyIHRleHR1cmVIZWlnaHQgPSB0ZXh0dXJlLmhlaWdodDtcclxuICAgIHZhciByZW5kZXJUYXJnZXQgPSBnYW1lT2JqZWN0LnJlbmRlclRhcmdldDtcclxuICAgIHZhciBzY3JvbGxGYWN0b3JYID0gZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JYO1xyXG4gICAgdmFyIHNjcm9sbEZhY3RvclkgPSBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclk7XHJcbiAgICB2YXIgYWxwaGEgPSBnYW1lT2JqZWN0LmFscGhhO1xyXG4gICAgdmFyIHggPSBnYW1lT2JqZWN0Lng7XHJcbiAgICB2YXIgeSA9IGdhbWVPYmplY3QueTtcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyArK2luZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0aWxlID0gcmVuZGVyVGlsZXNbaW5kZXhdO1xyXG4gICAgICAgIGJhdGNoLmFkZFRpbGVUZXh0dXJlUmVjdChcclxuICAgICAgICAgICAgdGV4dHVyZSxcclxuICAgICAgICAgICAgeCArIHRpbGUueCwgeSArIHRpbGUueSwgdGlsZS53aWR0aCwgdGlsZS5oZWlnaHQsIGFscGhhICogdGlsZS5hbHBoYSwgdGlsZS50aW50LFxyXG4gICAgICAgICAgICBzY3JvbGxGYWN0b3JYLCBzY3JvbGxGYWN0b3JZLFxyXG4gICAgICAgICAgICB0ZXh0dXJlV2lkdGgsIHRleHR1cmVIZWlnaHQsXHJcbiAgICAgICAgICAgIHRpbGUuZnJhbWVYLCB0aWxlLmZyYW1lWSwgdGlsZS5mcmFtZVdpZHRoLCB0aWxlLmZyYW1lSGVpZ2h0LFxyXG4gICAgICAgICAgICBjYW1lcmEsXHJcbiAgICAgICAgICAgIHJlbmRlclRhcmdldFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVtYXBXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVtYXAvZHluYW1pYy9UaWxlbWFwV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vR2FtZU9iamVjdCcpO1xyXG5cclxudmFyIFN0YXRpY1RpbGVtYXBDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgZ2FtZU9iamVjdCwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IGdhbWVPYmplY3QucmVuZGVyRmxhZ3MgfHwgKGdhbWVPYmplY3QuY2FtZXJhRmlsdGVyID4gMCAmJiAoZ2FtZU9iamVjdC5jYW1lcmFGaWx0ZXIgJiBjYW1lcmEuX2lkKSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGdhbWVPYmplY3QudXBsb2FkKGNhbWVyYSk7XHJcblxyXG4gICAgdmFyIHRpbGVzID0gY2FtZXJhLmN1bGxUaWxlbWFwKGdhbWVPYmplY3QpO1xyXG4gICAgdmFyIHRpbGVXaWR0aCA9IGdhbWVPYmplY3QudGlsZVdpZHRoO1xyXG4gICAgdmFyIHRpbGVIZWlnaHQgPSBnYW1lT2JqZWN0LnRpbGVIZWlnaHQ7XHJcbiAgICB2YXIgZnJhbWUgPSBnYW1lT2JqZWN0LmZyYW1lO1xyXG4gICAgdmFyIGN0eCA9IHJlbmRlcmVyLmdhbWVDb250ZXh0O1xyXG4gICAgdmFyIHRpbGVDb3VudCA9IHRpbGVzLmxlbmd0aDtcclxuICAgIHZhciBpbWFnZSA9IGZyYW1lLnNvdXJjZS5pbWFnZTtcclxuICAgIHZhciB0eCA9IGdhbWVPYmplY3QueCAtIGNhbWVyYS5zY3JvbGxYICogZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JYO1xyXG4gICAgdmFyIHR5ID0gZ2FtZU9iamVjdC55IC0gY2FtZXJhLnNjcm9sbFkgKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclk7XHJcbiAgICB2YXIgYm91bmRzWCA9IGNhbWVyYS5zY3JvbGxYO1xyXG5cclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XHJcbiAgICBjdHgucm90YXRlKGdhbWVPYmplY3Qucm90YXRpb24pO1xyXG4gICAgY3R4LnNjYWxlKGdhbWVPYmplY3Quc2NhbGVYLCBnYW1lT2JqZWN0LnNjYWxlWSk7XHJcbiAgICBjdHguc2NhbGUoZ2FtZU9iamVjdC5mbGlwWCA/IC0xIDogMSwgZ2FtZU9iamVjdC5mbGlwWSA/IC0xIDogMSk7XHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRpbGVDb3VudDsgKytpbmRleClcclxuICAgIHtcclxuICAgICAgICB2YXIgdGlsZSA9IHRpbGVzW2luZGV4XTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB0aWxlLmZyYW1lWCwgdGlsZS5mcmFtZVksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgdGlsZS54LCB0aWxlLnksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RhdGljVGlsZW1hcENhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVtYXAvc3RhdGljL1N0YXRpY1RpbGVtYXBDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCdWlsZEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9CdWlsZEdhbWVPYmplY3QnKTtcclxudmFyIEdhbWVPYmplY3RDcmVhdG9yID0gcmVxdWlyZSgnLi4vLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxudmFyIFN0YXRpY1RpbGVtYXAgPSByZXF1aXJlKCcuL1N0YXRpY1RpbGVtYXAnKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0Q3JlYXRvciBjb250ZXh0LlxyXG5cclxuR2FtZU9iamVjdENyZWF0b3IucmVnaXN0ZXIoJ3N0YXRpY1RpbGVtYXAnLCBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIgbWFwRGF0YSA9IEdldFZhbHVlKGNvbmZpZywgJ21hcC5kYXRhJywgbnVsbCk7XHJcbiAgICB2YXIgbWFwV2lkdGggPSBHZXRWYWx1ZShjb25maWcsICdtYXAud2lkdGgnLCAxKTtcclxuICAgIHZhciBtYXBIZWlnaHQgPSBHZXRWYWx1ZShjb25maWcsICdtYXAuaGVpZ2h0JywgMSk7XHJcblxyXG4gICAgdmFyIHggPSBHZXRWYWx1ZShjb25maWcsICd4JywgMCk7XHJcbiAgICB2YXIgeSA9IEdldFZhbHVlKGNvbmZpZywgJ3knLCAwKTtcclxuXHJcbiAgICB2YXIgdGlsZVdpZHRoID0gR2V0VmFsdWUoY29uZmlnLCAndGlsZS53aWR0aCcsIDE2KTtcclxuICAgIHZhciB0aWxlSGVpZ2h0ID0gR2V0VmFsdWUoY29uZmlnLCAndGlsZS5oZWlnaHQnLCAxNik7XHJcbiAgICB2YXIgdGlsZVRleHR1cmUgPSBHZXRWYWx1ZShjb25maWcsICd0aWxlLnRleHR1cmUnLCBudWxsKTtcclxuICAgIHZhciB0aWxlRnJhbWUgPSBHZXRWYWx1ZShjb25maWcsICd0aWxlLmZyYW1lJywgbnVsbCk7XHJcbiAgICB2YXIgdGlsZUJvcmRlciA9IEdldFZhbHVlKGNvbmZpZywgJ3RpbGUuYm9yZGVyJywgMCk7XHJcblxyXG4gICAgdmFyIG1hcCA9IG5ldyBTdGF0aWNUaWxlbWFwKHRoaXMuc2NlbmUsIG1hcERhdGEsIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgbWFwV2lkdGgsIG1hcEhlaWdodCwgdGlsZUJvcmRlciwgdGlsZVRleHR1cmUsIHRpbGVGcmFtZSk7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHRoaXMuc2NlbmUsIG1hcCwgY29uZmlnKTtcclxuXHJcbiAgICByZXR1cm4gbWFwO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdGF0aWNUaWxlbWFwID0gcmVxdWlyZSgnLi9TdGF0aWNUaWxlbWFwJyk7XHJcbnZhciBHYW1lT2JqZWN0RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdEZhY3RvcnknKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0RmFjdG9yeSBjb250ZXh0LlxyXG4vLyAgXHJcbi8vICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9wZXJ0aWVzIGF2YWlsYWJsZSB0byB1c2U6XHJcbi8vICBcclxuLy8gIHRoaXMuc2NlbmUgLSBhIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhhdCBvd25zIHRoZSBHYW1lT2JqZWN0RmFjdG9yeVxyXG4vLyAgdGhpcy5kaXNwbGF5TGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBEaXNwbGF5IExpc3QgdGhlIFNjZW5lIG93bnNcclxuLy8gIHRoaXMudXBkYXRlTGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBVcGRhdGUgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG5cclxuR2FtZU9iamVjdEZhY3RvcnkucmVnaXN0ZXIoJ3N0YXRpY1RpbGVtYXAnLCBmdW5jdGlvbiAobWFwRGF0YSwgeCwgeSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCBtYXBXaWR0aCwgbWFwSGVpZ2h0LCB0aWxlQm9yZGVyLCB0ZXh0dXJlLCBmcmFtZSlcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuZGlzcGxheUxpc3QuYWRkKG5ldyBTdGF0aWNUaWxlbWFwKHRoaXMuc2NlbmUsIG1hcERhdGEsIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgbWFwV2lkdGgsIG1hcEhlaWdodCwgdGlsZUJvcmRlciwgdGV4dHVyZSwgZnJhbWUpKTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZW1hcC9zdGF0aWMvU3RhdGljVGlsZW1hcEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDU0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9OT09QJyk7XHJcbnZhciByZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9OT09QJyk7XHJcblxyXG5pZiAoV0VCR0xfUkVOREVSRVIpXHJcbntcclxuICAgIHJlbmRlcldlYkdMID0gcmVxdWlyZSgnLi9TdGF0aWNUaWxlbWFwV2ViR0xSZW5kZXJlcicpO1xyXG59XHJcblxyXG5pZiAoQ0FOVkFTX1JFTkRFUkVSKVxyXG57XHJcbiAgICByZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuL1N0YXRpY1RpbGVtYXBDYW52YXNSZW5kZXJlcicpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJXZWJHTDogcmVuZGVyV2ViR0wsXHJcbiAgICByZW5kZXJDYW52YXM6IHJlbmRlckNhbnZhc1xyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgU3RhdGljVGlsZW1hcFdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IHNyYy5yZW5kZXJGbGFncyB8fCAoc3JjLmNhbWVyYUZpbHRlciA+IDAgJiYgKHNyYy5jYW1lcmFGaWx0ZXIgJiBjYW1lcmEuX2lkKSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBnYW1lT2JqZWN0ID0gc3JjO1xyXG4gICAgdmFyIGZyYW1lID0gZ2FtZU9iamVjdC5mcmFtZTtcclxuICAgIHZhciBnbCA9IGdhbWVPYmplY3QuZ2w7XHJcblxyXG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyZXIoZ2FtZU9iamVjdC50aWxlbWFwUmVuZGVyZXIsIGZyYW1lLnRleHR1cmUuc291cmNlW2ZyYW1lLnNvdXJjZUluZGV4XS5nbFRleHR1cmUsIGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0KTtcclxuICAgIGdhbWVPYmplY3QudGlsZW1hcFJlbmRlcmVyLmJpbmQoKTtcclxuICAgIGdhbWVPYmplY3QudXBsb2FkKGNhbWVyYSk7XHJcbiAgICBnYW1lT2JqZWN0LnZiby5iaW5kKCk7XHJcblxyXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIGdhbWVPYmplY3QudmVydGV4Q291bnQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGF0aWNUaWxlbWFwV2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG5cclxudmFyIFRpbGVTcHJpdGVDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAoR2FtZU9iamVjdC5SRU5ERVJfTUFTSyAhPT0gc3JjLnJlbmRlckZsYWdzIHx8IChzcmMuY2FtZXJhRmlsdGVyID4gMCAmJiAoc3JjLmNhbWVyYUZpbHRlciAmIGNhbWVyYS5faWQpKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGN0eCA9IHJlbmRlcmVyLmN1cnJlbnRDb250ZXh0O1xyXG4gICAgdmFyIGZyYW1lID0gc3JjLmZyYW1lO1xyXG5cclxuICAgIC8vICBCbGVuZCBNb2RlXHJcblxyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgIT09IHNyYy5ibGVuZE1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSA9IHNyYy5ibGVuZE1vZGU7XHJcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHJlbmRlcmVyLmJsZW5kTW9kZXNbc3JjLmJsZW5kTW9kZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFscGhhXHJcblxyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRBbHBoYSAhPT0gc3JjLmFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRBbHBoYSA9IHNyYy5hbHBoYTtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNtb290aGluZ1xyXG5cclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50U2NhbGVNb2RlICE9PSBzcmMuc2NhbGVNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgPSBzcmMuc2NhbGVNb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkeCA9IGZyYW1lLnggLSAoc3JjLm9yaWdpblggKiBzcmMud2lkdGgpO1xyXG4gICAgdmFyIGR5ID0gZnJhbWUueSAtIChzcmMub3JpZ2luWSAqIHNyYy5oZWlnaHQpO1xyXG5cclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKGR4LCBkeSk7XHJcbiAgICBjdHgudHJhbnNsYXRlKHNyYy54IC0gY2FtZXJhLnNjcm9sbFggKiBzcmMuc2Nyb2xsRmFjdG9yWCwgc3JjLnkgLSBjYW1lcmEuc2Nyb2xsWSAqIHNyYy5zY3JvbGxGYWN0b3JZKTtcclxuICAgIGN0eC5maWxsU3R5bGUgPSBzcmMuY2FudmFzUGF0dGVybjtcclxuICAgIGN0eC50cmFuc2xhdGUoLXRoaXMudGlsZVBvc2l0aW9uWCwgLXRoaXMudGlsZVBvc2l0aW9uWSk7XHJcbiAgICBjdHguZmlsbFJlY3QodGhpcy50aWxlUG9zaXRpb25YLCB0aGlzLnRpbGVQb3NpdGlvblksIHNyYy53aWR0aCwgc3JjLmhlaWdodCk7XHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaWxlU3ByaXRlQ2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZXNwcml0ZS9UaWxlU3ByaXRlQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQnVpbGRHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vQnVpbGRHYW1lT2JqZWN0Jyk7XHJcbnZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdENyZWF0b3InKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG52YXIgVGlsZVNwcml0ZSA9IHJlcXVpcmUoJy4vVGlsZVNwcml0ZScpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RDcmVhdG9yIGNvbnRleHQuXHJcblxyXG5HYW1lT2JqZWN0Q3JlYXRvci5yZWdpc3RlcigndGlsZVNwcml0ZScsIGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHZhciB4ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd4JywgMCk7XHJcbiAgICB2YXIgeSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAneScsIDApO1xyXG4gICAgdmFyIHdpZHRoID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd3aWR0aCcsIDUxMik7XHJcbiAgICB2YXIgaGVpZ2h0ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdoZWlnaHQnLCA1MTIpO1xyXG4gICAgdmFyIGtleSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAna2V5JywgJycpO1xyXG4gICAgdmFyIGZyYW1lID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmcmFtZScsICcnKTtcclxuXHJcbiAgICB2YXIgdGlsZSA9IG5ldyBUaWxlU3ByaXRlKHRoaXMuc2NlbmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGtleSwgZnJhbWUpO1xyXG5cclxuICAgIEJ1aWxkR2FtZU9iamVjdCh0aGlzLnNjZW5lLCB0aWxlLCBjb25maWcpO1xyXG5cclxuICAgIHJldHVybiB0aWxlO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlc3ByaXRlL1RpbGVTcHJpdGVDcmVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1NTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRpbGVTcHJpdGUgPSByZXF1aXJlKCcuL1RpbGVTcHJpdGUnKTtcclxudmFyIEdhbWVPYmplY3RGYWN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vc2NlbmUvcGx1Z2lucy9HYW1lT2JqZWN0RmFjdG9yeScpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RGYWN0b3J5IGNvbnRleHQuXHJcbi8vICBcclxuLy8gIFRoZXJlIGFyZSBzZXZlcmFsIHByb3BlcnRpZXMgYXZhaWxhYmxlIHRvIHVzZTpcclxuLy8gIFxyXG4vLyAgdGhpcy5zY2VuZSAtIGEgcmVmZXJlbmNlIHRvIHRoZSBTY2VuZSB0aGF0IG93bnMgdGhlIEdhbWVPYmplY3RGYWN0b3J5XHJcbi8vICB0aGlzLmRpc3BsYXlMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIERpc3BsYXkgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG4vLyAgdGhpcy51cGRhdGVMaXN0IC0gYSByZWZlcmVuY2UgdG8gdGhlIFVwZGF0ZSBMaXN0IHRoZSBTY2VuZSBvd25zXHJcblxyXG5HYW1lT2JqZWN0RmFjdG9yeS5yZWdpc3RlcigndGlsZVNwcml0ZScsIGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBrZXksIGZyYW1lKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5kaXNwbGF5TGlzdC5hZGQobmV3IFRpbGVTcHJpdGUodGhpcy5zY2VuZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwga2V5LCBmcmFtZSkpO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlc3ByaXRlL1RpbGVTcHJpdGVGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA1NTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlcldlYkdMID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvTk9PUCcpO1xyXG52YXIgcmVuZGVyQ2FudmFzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvTk9PUCcpO1xyXG5cclxuaWYgKFdFQkdMX1JFTkRFUkVSKVxyXG57XHJcbiAgICByZW5kZXJXZWJHTCA9IHJlcXVpcmUoJy4vVGlsZVNwcml0ZVdlYkdMUmVuZGVyZXInKTtcclxufVxyXG5cclxuaWYgKENBTlZBU19SRU5ERVJFUilcclxue1xyXG4gICAgcmVuZGVyQ2FudmFzID0gcmVxdWlyZSgnLi9UaWxlU3ByaXRlQ2FudmFzUmVuZGVyZXInKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgcmVuZGVyV2ViR0w6IHJlbmRlcldlYkdMLFxyXG4gICAgcmVuZGVyQ2FudmFzOiByZW5kZXJDYW52YXNcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZXNwcml0ZS9UaWxlU3ByaXRlUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgVGlsZVNwcml0ZVdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKEdhbWVPYmplY3QuUkVOREVSX01BU0sgIT09IHNyYy5yZW5kZXJGbGFncyB8fCAoc3JjLmNhbWVyYUZpbHRlciA+IDAgJiYgKHNyYy5jYW1lcmFGaWx0ZXIgJiBjYW1lcmEuX2lkKSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHNyYy51cGRhdGVUaWxlVGV4dHVyZSgpO1xyXG5cclxuICAgIHJlbmRlcmVyLnRpbGVCYXRjaC5hZGRUaWxlU3ByaXRlKHNyYywgY2FtZXJhKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZVNwcml0ZVdlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZXNwcml0ZS9UaWxlU3ByaXRlV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdENyZWF0b3InKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG52YXIgWm9uZSA9IHJlcXVpcmUoJy4vWm9uZScpO1xyXG5cclxuLy8gIFdoZW4gcmVnaXN0ZXJpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uICd0aGlzJyByZWZlcnMgdG8gdGhlIEdhbWVPYmplY3RDcmVhdG9yIGNvbnRleHQuXHJcblxyXG5HYW1lT2JqZWN0Q3JlYXRvci5yZWdpc3Rlcignem9uZScsIGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHZhciB4ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd4JywgMCk7XHJcbiAgICB2YXIgeSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAneScsIDApO1xyXG4gICAgdmFyIHdpZHRoID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd3aWR0aCcsIDEpO1xyXG4gICAgdmFyIGhlaWdodCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnaGVpZ2h0Jywgd2lkdGgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgWm9uZSh0aGlzLnNjZW5lLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvem9uZS9ab25lQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBab25lID0gcmVxdWlyZSgnLi9ab25lJyk7XHJcbnZhciBHYW1lT2JqZWN0RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdEZhY3RvcnknKTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0RmFjdG9yeSBjb250ZXh0LlxyXG4vLyAgXHJcbi8vICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9wZXJ0aWVzIGF2YWlsYWJsZSB0byB1c2U6XHJcbi8vICBcclxuLy8gIHRoaXMuc2NlbmUgLSBhIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhhdCBvd25zIHRoZSBHYW1lT2JqZWN0RmFjdG9yeVxyXG4vLyAgdGhpcy5kaXNwbGF5TGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBEaXNwbGF5IExpc3QgdGhlIFNjZW5lIG93bnNcclxuLy8gIHRoaXMudXBkYXRlTGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBVcGRhdGUgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG5cclxuR2FtZU9iamVjdEZhY3RvcnkucmVnaXN0ZXIoJ3pvbmUnLCBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuZGlzcGxheUxpc3QuYWRkKG5ldyBab25lKHRoaXMuc2NlbmUsIHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvem9uZS9ab25lRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBcmVhID0gZnVuY3Rpb24gKGNpcmNsZSlcclxue1xyXG4gICAgcmV0dXJuIChjaXJjbGUucmFkaXVzID4gMCkgPyBNYXRoLlBJICogY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMgOiAwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBcmVhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL0FyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDU1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2lyY3VtZmVyZW5jZSA9IGZ1bmN0aW9uIChjaXJjbGUpXHJcbntcclxuICAgIHJldHVybiAyICogKE1hdGguUEkgKiBjaXJjbGUucmFkaXVzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VtZmVyZW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2NpcmNsZS9DaXJjdW1mZXJlbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogUmV0dXJucyBhIFBvaW50IG9iamVjdCBjb250YWluaW5nIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IG9uIHRoZSBjaXJjdW1mZXJlbmNlIG9mIHRoZSBDaXJjbGUgYmFzZWQgb24gdGhlIGdpdmVuIGFuZ2xlLlxyXG4qL1xyXG52YXIgQ2lyY3VtZmVyZW5jZVBvaW50ID0gZnVuY3Rpb24gKGNpcmNsZSwgYW5nbGUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgb3V0LnggPSBjaXJjbGUueCArIChjaXJjbGUucmFkaXVzICogTWF0aC5jb3MoYW5nbGUpKTtcclxuICAgIG91dC55ID0gY2lyY2xlLnkgKyAoY2lyY2xlLnJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VtZmVyZW5jZVBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL0NpcmN1bWZlcmVuY2VQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDaXJjbGUgPSByZXF1aXJlKCcuL0NpcmNsZScpO1xyXG5cclxudmFyIENsb25lID0gZnVuY3Rpb24gKHNvdXJjZSlcclxue1xyXG4gICAgcmV0dXJuIG5ldyBDaXJjbGUoc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2UucmFkaXVzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9jaXJjbGUvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgQ29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChjaXJjbGUsIHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gQ29udGFpbnMoY2lyY2xlLCBwb2ludC54LCBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1NjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChjaXJjbGUsIHJlY3QpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgQ29udGFpbnMoY2lyY2xlLCByZWN0LngsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QucmlnaHQsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QueCwgcmVjdC5ib3R0b20pICYmXHJcbiAgICAgICAgQ29udGFpbnMoY2lyY2xlLCByZWN0LnJpZ2h0LCByZWN0LmJvdHRvbSlcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2NpcmNsZS9Db250YWluc1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxyXG4qL1xyXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxyXG57XHJcbiAgICByZXR1cm4gZGVzdC5zZXRUbyhzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS5yYWRpdXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2NpcmNsZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gNTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAoY2lyY2xlLCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgY2lyY2xlLnggPT09IHRvQ29tcGFyZS54ICYmXHJcbiAgICAgICAgY2lyY2xlLnkgPT09IHRvQ29tcGFyZS55ICYmXHJcbiAgICAgICAgY2lyY2xlLnJhZGl1cyA9PT0gdG9Db21wYXJlLnJhZGl1c1xyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gNTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgR2V0Qm91bmRzID0gZnVuY3Rpb24gKGNpcmNsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFJlY3RhbmdsZSgpOyB9XHJcblxyXG4gICAgb3V0LnggPSBjaXJjbGUubGVmdDtcclxuICAgIG91dC55ID0gY2lyY2xlLnRvcDtcclxuICAgIG91dC53aWR0aCA9IGNpcmNsZS5kaWFtZXRlcjtcclxuICAgIG91dC5oZWlnaHQgPSBjaXJjbGUuZGlhbWV0ZXI7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qm91bmRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL0dldEJvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gNTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXQgPSBmdW5jdGlvbiAoY2lyY2xlLCB4LCB5KVxyXG57XHJcbiAgICBjaXJjbGUueCArPSB4O1xyXG4gICAgY2lyY2xlLnkgKz0geTtcclxuXHJcbiAgICByZXR1cm4gY2lyY2xlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9jaXJjbGUvT2Zmc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA1Njhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldFBvaW50ID0gZnVuY3Rpb24gKGNpcmNsZSwgcG9pbnQpXHJcbntcclxuICAgIGNpcmNsZS54ICs9IHBvaW50Lng7XHJcbiAgICBjaXJjbGUueSArPSBwb2ludC55O1xyXG5cclxuICAgIHJldHVybiBjaXJjbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL09mZnNldFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1Njlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLkNpcmNsZVxyXG5cclxudmFyIENpcmNsZSA9IHJlcXVpcmUoJy4vQ2lyY2xlJyk7XHJcblxyXG5DaXJjbGUuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xyXG5DaXJjbGUuQ2lyY3VtZmVyZW5jZSA9IHJlcXVpcmUoJy4vQ2lyY3VtZmVyZW5jZScpO1xyXG5DaXJjbGUuQ2lyY3VtZmVyZW5jZVBvaW50ID0gcmVxdWlyZSgnLi9DaXJjdW1mZXJlbmNlUG9pbnQnKTtcclxuQ2lyY2xlLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5DaXJjbGUuQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcbkNpcmNsZS5Db250YWluc1BvaW50ID0gcmVxdWlyZSgnLi9Db250YWluc1BvaW50Jyk7XHJcbkNpcmNsZS5Db250YWluc1JlY3QgPSByZXF1aXJlKCcuL0NvbnRhaW5zUmVjdCcpO1xyXG5DaXJjbGUuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcbkNpcmNsZS5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5DaXJjbGUuR2V0Qm91bmRzID0gcmVxdWlyZSgnLi9HZXRCb3VuZHMnKTtcclxuQ2lyY2xlLk9mZnNldCA9IHJlcXVpcmUoJy4vT2Zmc2V0Jyk7XHJcbkNpcmNsZS5PZmZzZXRQb2ludCA9IHJlcXVpcmUoJy4vT2Zmc2V0UG9pbnQnKTtcclxuQ2lyY2xlLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2NpcmNsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBcmVhID0gZnVuY3Rpb24gKGVsbGlwc2UpXHJcbntcclxuICAgIGlmIChlbGxpcHNlLmlzRW1wdHkoKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgdW5pdHMgc3F1YXJlZFxyXG4gICAgcmV0dXJuIChlbGxpcHNlLmdldE1ham9yUmFkaXVzKCkgKiBlbGxpcHNlLmdldE1pbm9yUmFkaXVzKCkgKiBNYXRoLlBJKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXJlYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2VsbGlwc2UvQXJlYS5qc1xuLy8gbW9kdWxlIGlkID0gNTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFJldHVybnMgYSBQb2ludCBvYmplY3QgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgY2lyY3VtZmVyZW5jZSBvZiB0aGUgRWxsaXBzZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gYW5nbGUuXHJcbiovXHJcbnZhciBDaXJjdW1mZXJlbmNlUG9pbnQgPSBmdW5jdGlvbiAoZWxsaXBzZSwgYW5nbGUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgdmFyIGEgPSBlbGxpcHNlLndpZHRoIC8gMjtcclxuICAgIHZhciBiID0gZWxsaXBzZS5oZWlnaHQgLyAyO1xyXG5cclxuICAgIG91dC54ID0gZWxsaXBzZS54ICsgYSAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgIG91dC55ID0gZWxsaXBzZS55ICsgYiAqIE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjdW1mZXJlbmNlUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9lbGxpcHNlL0NpcmN1bWZlcmVuY2VQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFbGxpcHNlID0gcmVxdWlyZSgnLi9FbGxpcHNlJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IEVsbGlwc2Uoc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2VsbGlwc2UvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgQ29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChlbGxpcHNlLCBwb2ludClcclxue1xyXG4gICAgcmV0dXJuIENvbnRhaW5zKGVsbGlwc2UsIHBvaW50LngsIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vZWxsaXBzZS9Db250YWluc1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1NzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChlbGxpcHNlLCByZWN0KVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QueCwgcmVjdC55KSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QucmlnaHQsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhlbGxpcHNlLCByZWN0LngsIHJlY3QuYm90dG9tKSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNSZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vZWxsaXBzZS9Db250YWluc1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxyXG57XHJcbiAgICByZXR1cm4gZGVzdC5zZXRUbyhzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vZWxsaXBzZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gNTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAoZWxsaXBzZSwgdG9Db21wYXJlKVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIGVsbGlwc2UueCA9PT0gdG9Db21wYXJlLnggJiZcclxuICAgICAgICBlbGxpcHNlLnkgPT09IHRvQ29tcGFyZS55ICYmXHJcbiAgICAgICAgZWxsaXBzZS53aWR0aCA9PT0gdG9Db21wYXJlLndpZHRoICYmXHJcbiAgICAgICAgZWxsaXBzZS5oZWlnaHQgPT09IHRvQ29tcGFyZS5oZWlnaHRcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2VsbGlwc2UvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA1Nzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4uL3JlY3RhbmdsZS9SZWN0YW5nbGUnKTtcclxuXHJcbnZhciBHZXRCb3VuZHMgPSBmdW5jdGlvbiAoZWxsaXBzZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFJlY3RhbmdsZSgpOyB9XHJcblxyXG4gICAgb3V0LnggPSBlbGxpcHNlLnggLSBlbGxpcHNlLndpZHRoO1xyXG4gICAgb3V0LnkgPSBlbGxpcHNlLnkgLSBlbGxpcHNlLmhlaWdodDtcclxuICAgIG91dC53aWR0aCA9IGVsbGlwc2Uud2lkdGg7XHJcbiAgICBvdXQuaGVpZ2h0ID0gZWxsaXBzZS5oZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qm91bmRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vZWxsaXBzZS9HZXRCb3VuZHMuanNcbi8vIG1vZHVsZSBpZCA9IDU3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKGVsbGlwc2UsIHgsIHkpXHJcbntcclxuICAgIGVsbGlwc2UueCArPSB4O1xyXG4gICAgZWxsaXBzZS55ICs9IHk7XHJcblxyXG4gICAgcmV0dXJuIGVsbGlwc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2VsbGlwc2UvT2Zmc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA1Nzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldFBvaW50ID0gZnVuY3Rpb24gKGVsbGlwc2UsIHBvaW50KVxyXG57XHJcbiAgICBlbGxpcHNlLnggKz0gcG9pbnQueDtcclxuICAgIGVsbGlwc2UueSArPSBwb2ludC55O1xyXG5cclxuICAgIHJldHVybiBlbGxpcHNlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2VsbGlwc2UvT2Zmc2V0UG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDU4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdlb20uRWxsaXBzZVxyXG5cclxudmFyIEVsbGlwc2UgPSByZXF1aXJlKCcuL0VsbGlwc2UnKTtcclxuXHJcbkVsbGlwc2UuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xyXG5FbGxpcHNlLkNpcmN1bWZlcmVuY2VQb2ludCA9IHJlcXVpcmUoJy4vQ2lyY3VtZmVyZW5jZVBvaW50Jyk7XHJcbkVsbGlwc2UuQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcbkVsbGlwc2UuQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcbkVsbGlwc2UuQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xyXG5FbGxpcHNlLkNvbnRhaW5zUmVjdCA9IHJlcXVpcmUoJy4vQ29udGFpbnNSZWN0Jyk7XHJcbkVsbGlwc2UuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcbkVsbGlwc2UuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcclxuRWxsaXBzZS5HZXRCb3VuZHMgPSByZXF1aXJlKCcuL0dldEJvdW5kcycpO1xyXG5FbGxpcHNlLk9mZnNldCA9IHJlcXVpcmUoJy4vT2Zmc2V0Jyk7XHJcbkVsbGlwc2UuT2Zmc2V0UG9pbnQgPSByZXF1aXJlKCcuL09mZnNldFBvaW50Jyk7XHJcbkVsbGlwc2UuUmFuZG9tID0gcmVxdWlyZSgnLi9SYW5kb20nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRWxsaXBzZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2VsbGlwc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzdGFuY2VCZXR3ZWVuID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZUJldHdlZW4nKTtcclxuXHJcbnZhciBDaXJjbGVUb0NpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGVBLCBjaXJjbGVCKVxyXG57XHJcbiAgICByZXR1cm4gKERpc3RhbmNlQmV0d2VlbihjaXJjbGVBLngsIGNpcmNsZUEueSwgY2lyY2xlQi54LCBjaXJjbGVCLnkpIDw9IChjaXJjbGVBLnJhZGl1cyArIGNpcmNsZUIucmFkaXVzKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZVRvQ2lyY2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDaXJjbGVUb1JlY3RhbmdsZSA9IGZ1bmN0aW9uIChjaXJjbGUsIHJlY3QpXHJcbntcclxuICAgIHZhciBoYWxmV2lkdGggPSByZWN0LndpZHRoIC8gMjtcclxuICAgIHZhciBoYWxmSGVpZ2h0ID0gcmVjdC5oZWlnaHQgLyAyO1xyXG5cclxuICAgIHZhciBjeCA9IE1hdGguYWJzKGNpcmNsZS54IC0gcmVjdC54IC0gaGFsZldpZHRoKTtcclxuICAgIHZhciB4RGlzdCA9IGhhbGZXaWR0aCArIGNpcmNsZS5yYWRpdXM7XHJcblxyXG4gICAgaWYgKGN4IDw9IGhhbGZXaWR0aCB8fCBjeCA+IHhEaXN0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY3kgPSBNYXRoLmFicyhjaXJjbGUueSAtIHJlY3QueSAtIGhhbGZIZWlnaHQpO1xyXG4gICAgdmFyIHlEaXN0ID0gaGFsZkhlaWdodCArIGNpcmNsZS5yYWRpdXM7XHJcblxyXG4gICAgaWYgKGN5IDw9IGhhbGZIZWlnaHQgfHwgY3kgPiB5RGlzdClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhDb3JuZXJEaXN0ID0gY3ggLSBoYWxmV2lkdGg7XHJcbiAgICB2YXIgeUNvcm5lckRpc3QgPSBjeSAtIGhhbGZIZWlnaHQ7XHJcbiAgICB2YXIgeENvcm5lckRpc3RTcSA9IHhDb3JuZXJEaXN0ICogeENvcm5lckRpc3Q7XHJcbiAgICB2YXIgeUNvcm5lckRpc3RTcSA9IHlDb3JuZXJEaXN0ICogeUNvcm5lckRpc3Q7XHJcbiAgICB2YXIgbWF4Q29ybmVyRGlzdFNxID0gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXM7XHJcblxyXG4gICAgcmV0dXJuICh4Q29ybmVyRGlzdFNxICsgeUNvcm5lckRpc3RTcSA8PSBtYXhDb3JuZXJEaXN0U3EpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGVUb1JlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDU4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi4vcmVjdGFuZ2xlL1JlY3RhbmdsZScpO1xyXG52YXIgUmVjdGFuZ2xlVG9SZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZVRvUmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qiwgb3V0cHV0KVxyXG57XHJcbiAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHsgb3V0cHV0ID0gbmV3IFJlY3RhbmdsZSgpOyB9XHJcblxyXG4gICAgaWYgKFJlY3RhbmdsZVRvUmVjdGFuZ2xlKHJlY3RBLCByZWN0QikpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LnggPSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KTtcclxuICAgICAgICBvdXRwdXQueSA9IE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpO1xyXG4gICAgICAgIG91dHB1dC53aWR0aCA9IE1hdGgubWluKHJlY3RBLnJpZ2h0LCByZWN0Qi5yaWdodCkgLSBvdXRwdXQueDtcclxuICAgICAgICBvdXRwdXQuaGVpZ2h0ID0gTWF0aC5taW4ocmVjdEEuYm90dG9tLCByZWN0Qi5ib3R0b20pIC0gb3V0cHV0Lnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDU4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDaGVja3MgZm9yIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBMaW5lIGFuZCBhIFJlY3RhbmdsZSBzaGFwZSwgb3IgYSByZWN0YW5nbGUtbGlrZVxyXG4qIG9iamVjdCwgd2l0aCBwdWJsaWMgYHhgLCBgeWAsIGByaWdodGAgYW5kIGBib3R0b21gIHByb3BlcnRpZXMsIHN1Y2ggYXMgYSBTcHJpdGUgb3IgQm9keS5cclxuKlxyXG4qIEFuIGludGVyc2VjdGlvbiBpcyBjb25zaWRlcmVkIHZhbGlkIGlmOlxyXG4qXHJcbiogVGhlIGxpbmUgc3RhcnRzIHdpdGhpbiwgb3IgZW5kcyB3aXRoaW4sIHRoZSBSZWN0YW5nbGUuXHJcbiogVGhlIGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIG9uZSBvZiB0aGUgNCByZWN0YW5nbGUgZWRnZXMuXHJcbipcclxuKiBUaGUgZm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIGZ1bmN0aW9uIHJlY3RhbmdsZXMgYXJlIGNvbnNpZGVyZWQgJ3NvbGlkJy5cclxuKi9cclxudmFyIExpbmVUb1JlY3RhbmdsZSA9IGZ1bmN0aW9uIChsaW5lLCByZWN0KVxyXG57XHJcbiAgICB2YXIgeDEgPSBsaW5lLngxO1xyXG4gICAgdmFyIHkxID0gbGluZS55MjtcclxuXHJcbiAgICB2YXIgeDIgPSBsaW5lLngyO1xyXG4gICAgdmFyIHkyID0gbGluZS55MjtcclxuXHJcbiAgICB2YXIgYngxID0gcmVjdC54O1xyXG4gICAgdmFyIGJ5MSA9IHJlY3QueTtcclxuICAgIHZhciBieDIgPSByZWN0LnJpZ2h0O1xyXG4gICAgdmFyIGJ5MiA9IHJlY3QuYm90dG9tO1xyXG5cclxuICAgIHZhciB0ID0gMDtcclxuXHJcbiAgICAvLyAgSWYgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgbGluZSBpcyBpbnNpZGUgdGhlIHJlY3QgdGhlbiB3ZSBhc3N1bWVcclxuICAgIC8vICBjb2xsaXNpb24sIGFzIHJlY3RzIGFyZSBzb2xpZCBmb3Igb3VyIHVzZS1jYXNlLlxyXG5cclxuICAgIGlmICgoeDEgPj0gYngxICYmIHgxIDw9IGJ4MiAmJiB5MSA+PSBieTEgJiYgeTEgPD0gYnkyKSB8fFxyXG4gICAgICAgICh4MiA+PSBieDEgJiYgeDIgPD0gYngyICYmIHkyID49IGJ5MSAmJiB5MiA8PSBieTIpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh4MSA8IGJ4MSAmJiB4MiA+PSBieDEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIExlZnQgZWRnZVxyXG4gICAgICAgIHQgPSB5MSArICh5MiAtIHkxKSAqIChieDEgLSB4MSkgLyAoeDIgLSB4MSk7XHJcblxyXG4gICAgICAgIGlmICh0ID4gYnkxICYmIHQgPD0gYnkyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoeDEgPiBieDIgJiYgeDIgPD0gYngyKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBSaWdodCBlZGdlXHJcbiAgICAgICAgdCA9IHkxICsgKHkyIC0geTEpICogKGJ4MiAtIHgxKSAvICh4MiAtIHgxKTtcclxuXHJcbiAgICAgICAgaWYgKHQgPj0gYnkxICYmIHQgPD0gYnkyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh5MSA8IGJ5MSAmJiB5MiA+PSBieTEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRvcCBlZGdlXHJcbiAgICAgICAgdCA9IHgxICsgKHgyIC0geDEpICogKGJ5MSAtIHkxKSAvICh5MiAtIHkxKTtcclxuXHJcbiAgICAgICAgaWYgKHQgPj0gYngxICYmIHQgPD0gYngyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoeTEgPiBieTIgJiYgeTIgPD0gYnkyKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBCb3R0b20gZWRnZVxyXG4gICAgICAgIHQgPSB4MSArICh4MiAtIHgxKSAqIChieTIgLSB5MSkgLyAoeTIgLSB5MSk7XHJcblxyXG4gICAgICAgIGlmICh0ID49IGJ4MSAmJiB0IDw9IGJ4MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVUb1JlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvUmVjdGFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA1ODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50VG9MaW5lID0gcmVxdWlyZSgnLi9Qb2ludFRvTGluZScpO1xyXG5cclxudmFyIFBvaW50VG9MaW5lU2VnbWVudCA9IGZ1bmN0aW9uIChwb2ludCwgbGluZSlcclxue1xyXG4gICAgaWYgKCFQb2ludFRvTGluZShwb2ludCwgbGluZSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4TWluID0gTWF0aC5taW4obGluZS54MSwgbGluZS54Mik7XHJcbiAgICB2YXIgeE1heCA9IE1hdGgubWF4KGxpbmUueDEsIGxpbmUueDIpO1xyXG4gICAgdmFyIHlNaW4gPSBNYXRoLm1pbihsaW5lLnkxLCBsaW5lLnkyKTtcclxuICAgIHZhciB5TWF4ID0gTWF0aC5tYXgobGluZS55MSwgbGluZS55Mik7XHJcblxyXG4gICAgcmV0dXJuICgocG9pbnQueCA+PSB4TWluICYmIHBvaW50LnggPD0geE1heCkgJiYgKHBvaW50LnkgPj0geU1pbiAmJiBwb2ludC55IDw9IHlNYXgpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb0xpbmVTZWdtZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZVNlZ21lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDU4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIExpbmVUb0xpbmUgPSByZXF1aXJlKCcuL0xpbmVUb0xpbmUnKTtcclxudmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi4vcmVjdGFuZ2xlL0NvbnRhaW5zJyk7XHJcbnZhciBDb250YWluc0FycmF5ID0gcmVxdWlyZSgnLi4vdHJpYW5nbGUvQ29udGFpbnNBcnJheScpO1xyXG52YXIgRGVjb21wb3NlID0gcmVxdWlyZSgnLi4vcmVjdGFuZ2xlL0RlY29tcG9zZScpO1xyXG5cclxudmFyIFJlY3RhbmdsZVRvVHJpYW5nbGUgPSBmdW5jdGlvbiAocmVjdCwgdHJpYW5nbGUpXHJcbntcclxuICAgIC8vICBGaXJzdCB0aGUgY2hlYXBlc3Qgb25lczpcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgICAgdHJpYW5nbGUubGVmdCA+IHJlY3QucmlnaHQgfHxcclxuICAgICAgICB0cmlhbmdsZS5yaWdodCA8IHJlY3QubGVmdCB8fFxyXG4gICAgICAgIHRyaWFuZ2xlLnRvcCA+IHJlY3QuYm90dG9tIHx8XHJcbiAgICAgICAgdHJpYW5nbGUuYm90dG9tIDwgcmVjdC50b3ApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0cmlBID0gdHJpYW5nbGUuZ2V0TGluZUEoKTtcclxuICAgIHZhciB0cmlCID0gdHJpYW5nbGUuZ2V0TGluZUIoKTtcclxuICAgIHZhciB0cmlDID0gdHJpYW5nbGUuZ2V0TGluZUMoKTtcclxuXHJcbiAgICAvLyAgQXJlIGFueSBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzIHdpdGhpbiB0aGUgcmVjdGFuZ2xlP1xyXG5cclxuICAgIGlmIChDb250YWlucyhyZWN0LCB0cmlBLngxLCB0cmlBLnkxKSB8fCBDb250YWlucyhyZWN0LCB0cmlBLngyLCB0cmlBLnkyKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQ29udGFpbnMocmVjdCwgdHJpQi54MSwgdHJpQi55MSkgfHwgQ29udGFpbnMocmVjdCwgdHJpQi54MiwgdHJpQi55MikpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKENvbnRhaW5zKHJlY3QsIHRyaUMueDEsIHRyaUMueTEpIHx8IENvbnRhaW5zKHJlY3QsIHRyaUMueDIsIHRyaUMueTIpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBDaGVhcCB0ZXN0cyBvdmVyLCBub3cgdG8gc2VlIGlmIGFueSBvZiB0aGUgbGluZXMgaW50ZXJzZWN0IC4uLlxyXG5cclxuICAgIHZhciByZWN0QSA9IHJlY3QuZ2V0TGluZUEoKTtcclxuICAgIHZhciByZWN0QiA9IHJlY3QuZ2V0TGluZUIoKTtcclxuICAgIHZhciByZWN0QyA9IHJlY3QuZ2V0TGluZUMoKTtcclxuICAgIHZhciByZWN0RCA9IHJlY3QuZ2V0TGluZUQoKTtcclxuXHJcbiAgICBpZiAoTGluZVRvTGluZSh0cmlBLCByZWN0QSkgfHwgTGluZVRvTGluZSh0cmlBLCByZWN0QikgfHwgTGluZVRvTGluZSh0cmlBLCByZWN0QykgfHwgTGluZVRvTGluZSh0cmlBLCByZWN0RCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKExpbmVUb0xpbmUodHJpQiwgcmVjdEEpIHx8IExpbmVUb0xpbmUodHJpQiwgcmVjdEIpIHx8IExpbmVUb0xpbmUodHJpQiwgcmVjdEMpIHx8IExpbmVUb0xpbmUodHJpQiwgcmVjdEQpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChMaW5lVG9MaW5lKHRyaUMsIHJlY3RBKSB8fCBMaW5lVG9MaW5lKHRyaUMsIHJlY3RCKSB8fCBMaW5lVG9MaW5lKHRyaUMsIHJlY3RDKSB8fCBMaW5lVG9MaW5lKHRyaUMsIHJlY3REKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgTm9uZSBvZiB0aGUgbGluZXMgaW50ZXJzZWN0LCBzbyBhcmUgYW55IHJlY3RhbmdsZSBwb2ludHMgd2l0aGluIHRoZSB0cmlhbmdsZT9cclxuXHJcbiAgICB2YXIgcG9pbnRzID0gRGVjb21wb3NlKHJlY3QpO1xyXG4gICAgdmFyIHdpdGhpbiA9IENvbnRhaW5zQXJyYXkodHJpYW5nbGUsIHBvaW50cywgdHJ1ZSk7XHJcblxyXG4gICAgcmV0dXJuICh3aXRoaW4ubGVuZ3RoID4gMCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZVRvVHJpYW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvVHJpYW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDU4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlVG9WYWx1ZXMgPSBmdW5jdGlvbiAocmVjdCwgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCB0b2xlcmFuY2UpXHJcbntcclxuICAgIGlmICh0b2xlcmFuY2UgPT09IHVuZGVmaW5lZCkgeyB0b2xlcmFuY2UgPSAwOyB9XHJcblxyXG4gICAgcmV0dXJuICEoXHJcbiAgICAgICAgbGVmdCA+IHJlY3QucmlnaHQgKyB0b2xlcmFuY2UgfHxcclxuICAgICAgICByaWdodCA8IHJlY3QubGVmdCAtIHRvbGVyYW5jZSB8fFxyXG4gICAgICAgIHRvcCA+IHJlY3QuYm90dG9tICsgdG9sZXJhbmNlIHx8XHJcbiAgICAgICAgYm90dG9tIDwgcmVjdC50b3AgLSB0b2xlcmFuY2VcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZVRvVmFsdWVzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1ZhbHVlcy5qc1xuLy8gbW9kdWxlIGlkID0gNTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgTGluZVRvQ2lyY2xlID0gcmVxdWlyZSgnLi9MaW5lVG9DaXJjbGUnKTtcclxudmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi4vdHJpYW5nbGUvQ29udGFpbnMnKTtcclxuXHJcbnZhciBUcmlhbmdsZVRvQ2lyY2xlID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBjaXJjbGUpXHJcbntcclxuICAgICAvLyAgRmlyc3QgdGhlIGNoZWFwZXN0IG9uZXM6XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAgIHRyaWFuZ2xlLmxlZnQgPiBjaXJjbGUucmlnaHQgfHxcclxuICAgICAgICB0cmlhbmdsZS5yaWdodCA8IGNpcmNsZS5sZWZ0IHx8XHJcbiAgICAgICAgdHJpYW5nbGUudG9wID4gY2lyY2xlLmJvdHRvbSB8fFxyXG4gICAgICAgIHRyaWFuZ2xlLmJvdHRvbSA8IGNpcmNsZS50b3ApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChDb250YWlucyh0cmlhbmdsZSwgY2lyY2xlLngsIGNpcmNsZS55KSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTGluZVRvQ2lyY2xlKHRyaWFuZ2xlLmdldExpbmVBKCksIGNpcmNsZSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKExpbmVUb0NpcmNsZSh0cmlhbmdsZS5nZXRMaW5lQigpLCBjaXJjbGUpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChMaW5lVG9DaXJjbGUodHJpYW5nbGUuZ2V0TGluZUMoKSwgY2lyY2xlKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyaWFuZ2xlVG9DaXJjbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9pbnRlcnNlY3RzL1RyaWFuZ2xlVG9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDU4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIExpbmVUb0xpbmUgPSByZXF1aXJlKCcuL0xpbmVUb0xpbmUnKTtcclxudmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi4vdHJpYW5nbGUvQ29udGFpbnMnKTtcclxuXHJcbnZhciBUcmlhbmdsZVRvTGluZSA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgbGluZSlcclxue1xyXG4gICAgLy8gIElmIHRoZSBUcmlhbmdsZSBjb250YWlucyBlaXRoZXIgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludCBvZiB0aGUgbGluZSwgaXQgaW50ZXJzZWN0c1xyXG4gICAgaWYgKENvbnRhaW5zKHRyaWFuZ2xlLCBsaW5lLmdldFBvaW50QSgpKSB8fCBDb250YWlucyh0cmlhbmdsZSwgbGluZS5nZXRQb2ludEIoKSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIE5vdyBjaGVjayB0aGUgbGluZSBhZ2FpbnN0IGVhY2ggbGluZSBvZiB0aGUgVHJpYW5nbGVcclxuICAgIGlmIChMaW5lVG9MaW5lKHRyaWFuZ2xlLmdldExpbmVBKCksIGxpbmUpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChMaW5lVG9MaW5lKHRyaWFuZ2xlLmdldExpbmVCKCksIGxpbmUpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChMaW5lVG9MaW5lKHRyaWFuZ2xlLmdldExpbmVDKCksIGxpbmUpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJpYW5nbGVUb0xpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9pbnRlcnNlY3RzL1RyaWFuZ2xlVG9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1OTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBMaW5lVG9MaW5lID0gcmVxdWlyZSgnLi9MaW5lVG9MaW5lJyk7XHJcbnZhciBDb250YWluc0FycmF5ID0gcmVxdWlyZSgnLi4vdHJpYW5nbGUvQ29udGFpbnNBcnJheScpO1xyXG52YXIgRGVjb21wb3NlID0gcmVxdWlyZSgnLi4vdHJpYW5nbGUvRGVjb21wb3NlJyk7XHJcblxyXG52YXIgVHJpYW5nbGVUb1RyaWFuZ2xlID0gZnVuY3Rpb24gKHRyaWFuZ2xlQSwgdHJpYW5nbGVCKVxyXG57XHJcbiAgICAvLyAgRmlyc3QgdGhlIGNoZWFwZXN0IG9uZXM6XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAgIHRyaWFuZ2xlQS5sZWZ0ID4gdHJpYW5nbGVCLnJpZ2h0IHx8XHJcbiAgICAgICAgdHJpYW5nbGVBLnJpZ2h0IDwgdHJpYW5nbGVCLmxlZnQgfHxcclxuICAgICAgICB0cmlhbmdsZUEudG9wID4gdHJpYW5nbGVCLmJvdHRvbSB8fFxyXG4gICAgICAgIHRyaWFuZ2xlQS5ib3R0b20gPCB0cmlhbmdsZUIudG9wKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGluZUFBID0gdHJpYW5nbGVBLmdldExpbmVBKCk7XHJcbiAgICB2YXIgbGluZUFCID0gdHJpYW5nbGVBLmdldExpbmVCKCk7XHJcbiAgICB2YXIgbGluZUFDID0gdHJpYW5nbGVBLmdldExpbmVDKCk7XHJcblxyXG4gICAgdmFyIGxpbmVCQSA9IHRyaWFuZ2xlQi5nZXRMaW5lQSgpO1xyXG4gICAgdmFyIGxpbmVCQiA9IHRyaWFuZ2xlQi5nZXRMaW5lQigpO1xyXG4gICAgdmFyIGxpbmVCQyA9IHRyaWFuZ2xlQi5nZXRMaW5lQygpO1xyXG5cclxuICAgIC8vICBOb3cgY2hlY2sgdGhlIGxpbmVzIGFnYWluc3QgZWFjaCBsaW5lIG9mIFRyaWFuZ2xlQlxyXG4gICAgaWYgKExpbmVUb0xpbmUobGluZUFBLCBsaW5lQkEpIHx8IExpbmVUb0xpbmUobGluZUFBLCBsaW5lQkIpIHx8IExpbmVUb0xpbmUobGluZUFBLCBsaW5lQkMpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChMaW5lVG9MaW5lKGxpbmVBQiwgbGluZUJBKSB8fCBMaW5lVG9MaW5lKGxpbmVBQiwgbGluZUJCKSB8fCBMaW5lVG9MaW5lKGxpbmVBQiwgbGluZUJDKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTGluZVRvTGluZShsaW5lQUMsIGxpbmVCQSkgfHwgTGluZVRvTGluZShsaW5lQUMsIGxpbmVCQikgfHwgTGluZVRvTGluZShsaW5lQUMsIGxpbmVCQykpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIE5vcGUsIHNvIGNoZWNrIHRvIHNlZSBpZiBhbnkgb2YgdGhlIHBvaW50cyBvZiB0cmlhbmdsZUEgYXJlIHdpdGhpbiB0cmlhbmdsZUJcclxuXHJcbiAgICB2YXIgcG9pbnRzID0gRGVjb21wb3NlKHRyaWFuZ2xlQSk7XHJcbiAgICB2YXIgd2l0aGluID0gQ29udGFpbnNBcnJheSh0cmlhbmdsZUIsIHBvaW50cywgdHJ1ZSk7XHJcblxyXG4gICAgaWYgKHdpdGhpbi5sZW5ndGggPiAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBGaW5hbGx5IGNoZWNrIHRvIHNlZSBpZiBhbnkgb2YgdGhlIHBvaW50cyBvZiB0cmlhbmdsZUIgYXJlIHdpdGhpbiB0cmlhbmdsZUFcclxuXHJcbiAgICBwb2ludHMgPSBEZWNvbXBvc2UodHJpYW5nbGVCKTtcclxuICAgIHdpdGhpbiA9IENvbnRhaW5zQXJyYXkodHJpYW5nbGVBLCBwb2ludHMsIHRydWUpO1xyXG5cclxuICAgIGlmICh3aXRoaW4ubGVuZ3RoID4gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyaWFuZ2xlVG9UcmlhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2ludGVyc2VjdHMvVHJpYW5nbGVUb1RyaWFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA1OTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLkludGVyc2VjdHNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIENpcmNsZVRvQ2lyY2xlOiByZXF1aXJlKCcuL0NpcmNsZVRvQ2lyY2xlJyksXHJcbiAgICBDaXJjbGVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9DaXJjbGVUb1JlY3RhbmdsZScpLFxyXG4gICAgR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uOiByZXF1aXJlKCcuL0dldFJlY3RhbmdsZUludGVyc2VjdGlvbicpLFxyXG4gICAgTGluZVRvQ2lyY2xlOiByZXF1aXJlKCcuL0xpbmVUb0NpcmNsZScpLFxyXG4gICAgTGluZVRvTGluZTogcmVxdWlyZSgnLi9MaW5lVG9MaW5lJyksXHJcbiAgICBMaW5lVG9SZWN0YW5nbGU6IHJlcXVpcmUoJy4vTGluZVRvUmVjdGFuZ2xlJyksXHJcbiAgICBQb2ludFRvTGluZTogcmVxdWlyZSgnLi9Qb2ludFRvTGluZScpLFxyXG4gICAgUG9pbnRUb0xpbmVTZWdtZW50OiByZXF1aXJlKCcuL1BvaW50VG9MaW5lU2VnbWVudCcpLFxyXG4gICAgUmVjdGFuZ2xlVG9SZWN0YW5nbGU6IHJlcXVpcmUoJy4vUmVjdGFuZ2xlVG9SZWN0YW5nbGUnKSxcclxuICAgIFJlY3RhbmdsZVRvVHJpYW5nbGU6IHJlcXVpcmUoJy4vUmVjdGFuZ2xlVG9UcmlhbmdsZScpLFxyXG4gICAgUmVjdGFuZ2xlVG9WYWx1ZXM6IHJlcXVpcmUoJy4vUmVjdGFuZ2xlVG9WYWx1ZXMnKSxcclxuICAgIFRyaWFuZ2xlVG9DaXJjbGU6IHJlcXVpcmUoJy4vVHJpYW5nbGVUb0NpcmNsZScpLFxyXG4gICAgVHJpYW5nbGVUb0xpbmU6IHJlcXVpcmUoJy4vVHJpYW5nbGVUb0xpbmUnKSxcclxuICAgIFRyaWFuZ2xlVG9UcmlhbmdsZTogcmVxdWlyZSgnLi9UcmlhbmdsZVRvVHJpYW5nbGUnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2ludGVyc2VjdHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENlbnRlck9uID0gZnVuY3Rpb24gKGxpbmUsIHgsIHkpXHJcbntcclxuICAgIHZhciB0eCA9IHggLSAoKGxpbmUueDEgKyBsaW5lLngyKSAvIDIpO1xyXG4gICAgdmFyIHR5ID0geSAtICgobGluZS55MSArIGxpbmUueTIpIC8gMik7XHJcblxyXG4gICAgbGluZS54MSArPSB0eDtcclxuICAgIGxpbmUueTEgKz0gdHk7XHJcblxyXG4gICAgbGluZS54MiArPSB0eDtcclxuICAgIGxpbmUueTIgKz0gdHk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlbnRlck9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9DZW50ZXJPbi5qc1xuLy8gbW9kdWxlIGlkID0gNTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaW5lID0gcmVxdWlyZSgnLi9MaW5lJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IExpbmUoc291cmNlLngxLCBzb3VyY2UueTEsIHNvdXJjZS54Miwgc291cmNlLnkyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA1OTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvcHlGcm9tID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdClcclxue1xyXG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngxLCBzb3VyY2UueTEsIHNvdXJjZS54Miwgc291cmNlLnkyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL0NvcHlGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSA1OTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFscyA9IGZ1bmN0aW9uIChsaW5lLCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgbGluZS54MSA9PT0gdG9Db21wYXJlLngxICYmXHJcbiAgICAgICAgbGluZS55MSA9PT0gdG9Db21wYXJlLnkxICYmXHJcbiAgICAgICAgbGluZS54MiA9PT0gdG9Db21wYXJlLngyICYmXHJcbiAgICAgICAgbGluZS55MiA9PT0gdG9Db21wYXJlLnkyXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFcXVhbHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gNTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgR2V0TWlkUG9pbnQgPSBmdW5jdGlvbiAobGluZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBvdXQueCA9IChsaW5lLngxICsgbGluZS54MikgLyAyO1xyXG4gICAgb3V0LnkgPSAobGluZS55MSArIGxpbmUueTIpIC8gMjtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRNaWRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvR2V0TWlkUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDU5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcclxudmFyIEFuZ2xlID0gcmVxdWlyZSgnLi9BbmdsZScpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xyXG5cclxudmFyIEdldE5vcm1hbCA9IGZ1bmN0aW9uIChsaW5lLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIHZhciBhID0gQW5nbGUobGluZSkgLSBNQVRIX0NPTlNULlRBVTtcclxuXHJcbiAgICBvdXQueCA9IE1hdGguY29zKGEpO1xyXG4gICAgb3V0LnkgPSBNYXRoLnNpbihhKTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXROb3JtYWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL0dldE5vcm1hbC5qc1xuLy8gbW9kdWxlIGlkID0gNTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBHZXQgYSBwb2ludCBvbiB0aGUgZ2l2ZW4gbGluZSAncHJvZ3Jlc3MnIHBlcmNlbnRhZ2UgYWxvbmcgaXRzIGxlbmd0aC5cclxuLy8gIHByb2dyZXNzIGlzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxyXG5cclxudmFyIEdldFBvaW50ID0gZnVuY3Rpb24gKGxpbmUsIHByb2dyZXNzKVxyXG57XHJcbiAgICB2YXIgeCA9IGxpbmUueDEgKyAobGluZS54MiAtIGxpbmUueDEpICogcHJvZ3Jlc3M7XHJcbiAgICB2YXIgeSA9IGxpbmUueTEgKyAobGluZS55MiAtIGxpbmUueTEpICogcHJvZ3Jlc3M7XHJcblxyXG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvR2V0UG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDU5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSGVpZ2h0ID0gZnVuY3Rpb24gKGxpbmUpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmFicyhsaW5lLnkxIC0gbGluZS55Mik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhlaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvSGVpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA2MDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExlbmd0aCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChsaW5lLngyIC0gbGluZS54MSkgKiAobGluZS54MiAtIGxpbmUueDEpICsgKGxpbmUueTIgLSBsaW5lLnkxKSAqIChsaW5lLnkyIC0gbGluZS55MSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMZW5ndGg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL0xlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gNjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XHJcblxyXG52YXIgTm9ybWFsWCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5jb3MoQW5nbGUobGluZSkgLSBNQVRIX0NPTlNULlRBVSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbFg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL05vcm1hbFguanNcbi8vIG1vZHVsZSBpZCA9IDYwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcclxudmFyIEFuZ2xlID0gcmVxdWlyZSgnLi9BbmdsZScpO1xyXG5cclxudmFyIE5vcm1hbFkgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGguc2luKEFuZ2xlKGxpbmUpIC0gTUFUSF9DT05TVC5UQVUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9Ob3JtYWxZLmpzXG4vLyBtb2R1bGUgaWQgPSA2MDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldCA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5KVxyXG57XHJcbiAgICBsaW5lLngxICs9IHg7XHJcbiAgICBsaW5lLnkxICs9IHk7XHJcblxyXG4gICAgbGluZS54MiArPSB4O1xyXG4gICAgbGluZS55MiArPSB5O1xyXG5cclxuICAgIHJldHVybiBsaW5lO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL09mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gNjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJwU2xvcGUgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIC0oKGxpbmUueDIgLSBsaW5lLngxKSAvIChsaW5lLnkyIC0gbGluZS55MSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJwU2xvcGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL1BlcnBTbG9wZS5qc1xuLy8gbW9kdWxlIGlkID0gNjA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxudmFyIE5vcm1hbEFuZ2xlID0gcmVxdWlyZSgnLi9Ob3JtYWxBbmdsZScpO1xyXG5cclxuLyoqXHJcbiogUmV0dXJucyB0aGUgcmVmbGVjdGVkIGFuZ2xlIGJldHdlZW4gdHdvIGxpbmVzLlxyXG4qIFRoaXMgaXMgdGhlIG91dGdvaW5nIGFuZ2xlIGJhc2VkIG9uIHRoZSBhbmdsZSBvZiBMaW5lIDEgYW5kIHRoZSBub3JtYWxBbmdsZSBvZiBMaW5lIDIuXHJcbiovXHJcbnZhciBSZWZsZWN0QW5nbGUgPSBmdW5jdGlvbiAobGluZUEsIGxpbmVCKVxyXG57XHJcbiAgICByZXR1cm4gKDIgKiBOb3JtYWxBbmdsZShsaW5lQikgLSBNYXRoLlBJIC0gQW5nbGUobGluZUEpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdEFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9SZWZsZWN0QW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDYwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm90YXRlQXJvdW5kWFkgPSByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZFhZJyk7XHJcblxyXG52YXIgUm90YXRlID0gZnVuY3Rpb24gKGxpbmUsIGFuZ2xlKVxyXG57XHJcbiAgICB2YXIgeCA9IChsaW5lLngxICsgbGluZS54MikgLyAyO1xyXG4gICAgdmFyIHkgPSAobGluZS55MSArIGxpbmUueTIpIC8gMjtcclxuXHJcbiAgICByZXR1cm4gUm90YXRlQXJvdW5kWFkobGluZSwgeCwgeSwgYW5nbGUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL1JvdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNjA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcclxuXHJcbnZhciBSb3RhdGVBcm91bmRQb2ludCA9IGZ1bmN0aW9uIChsaW5lLCBwb2ludCwgYW5nbGUpXHJcbntcclxuICAgIHJldHVybiBSb3RhdGVBcm91bmRYWShsaW5lLCBwb2ludC54LCBwb2ludC55LCBhbmdsZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9Sb3RhdGVBcm91bmRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRUb0FuZ2xlID0gZnVuY3Rpb24gKGxpbmUsIHgsIHksIGFuZ2xlLCBsZW5ndGgpXHJcbntcclxuICAgIGxpbmUueDEgPSB4O1xyXG4gICAgbGluZS55MSA9IHk7XHJcblxyXG4gICAgbGluZS54MiA9IHggKyAoTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoKTtcclxuICAgIGxpbmUueTIgPSB5ICsgKE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aCk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFRvQW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL1NldFRvQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDYwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2xvcGUgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIChsaW5lLnkyIC0gbGluZS55MSkgLyAobGluZS54MiAtIGxpbmUueDEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbG9wZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvU2xvcGUuanNcbi8vIG1vZHVsZSBpZCA9IDYxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgV2lkdGggPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKGxpbmUueDEgLSBsaW5lLngyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2lkdGg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL1dpZHRoLmpzXG4vLyBtb2R1bGUgaWQgPSA2MTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLkxpbmVcclxuXHJcbnZhciBMaW5lID0gcmVxdWlyZSgnLi9MaW5lJyk7XHJcblxyXG5MaW5lLkFuZ2xlID0gcmVxdWlyZSgnLi9BbmdsZScpO1xyXG5MaW5lLkNlbnRlck9uID0gcmVxdWlyZSgnLi9DZW50ZXJPbicpO1xyXG5MaW5lLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5MaW5lLkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xyXG5MaW5lLkVxdWFscyA9IHJlcXVpcmUoJy4vRXF1YWxzJyk7XHJcbkxpbmUuR2V0TWlkUG9pbnQgPSByZXF1aXJlKCcuL0dldE1pZFBvaW50Jyk7XHJcbkxpbmUuR2V0Tm9ybWFsID0gcmVxdWlyZSgnLi9HZXROb3JtYWwnKTtcclxuTGluZS5HZXRQb2ludCA9IHJlcXVpcmUoJy4vR2V0UG9pbnQnKTtcclxuTGluZS5HZXRQb2ludHNPbkxpbmUgPSByZXF1aXJlKCcuL0dldFBvaW50c09uTGluZScpO1xyXG5MaW5lLkhlaWdodCA9IHJlcXVpcmUoJy4vSGVpZ2h0Jyk7XHJcbkxpbmUuTGVuZ3RoID0gcmVxdWlyZSgnLi9MZW5ndGgnKTtcclxuTGluZS5Ob3JtYWxBbmdsZSA9IHJlcXVpcmUoJy4vTm9ybWFsQW5nbGUnKTtcclxuTGluZS5Ob3JtYWxYID0gcmVxdWlyZSgnLi9Ob3JtYWxYJyk7XHJcbkxpbmUuTm9ybWFsWSA9IHJlcXVpcmUoJy4vTm9ybWFsWScpO1xyXG5MaW5lLk9mZnNldCA9IHJlcXVpcmUoJy4vT2Zmc2V0Jyk7XHJcbkxpbmUuUGVycFNsb3BlID0gcmVxdWlyZSgnLi9QZXJwU2xvcGUnKTtcclxuTGluZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xyXG5MaW5lLlJlZmxlY3RBbmdsZSA9IHJlcXVpcmUoJy4vUmVmbGVjdEFuZ2xlJyk7XHJcbkxpbmUuUm90YXRlID0gcmVxdWlyZSgnLi9Sb3RhdGUnKTtcclxuTGluZS5Sb3RhdGVBcm91bmRQb2ludCA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kUG9pbnQnKTtcclxuTGluZS5Sb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcclxuTGluZS5TZXRUb0FuZ2xlID0gcmVxdWlyZSgnLi9TZXRUb0FuZ2xlJyk7XHJcbkxpbmUuU2xvcGUgPSByZXF1aXJlKCcuL1Nsb3BlJyk7XHJcbkxpbmUuV2lkdGggPSByZXF1aXJlKCcuL1dpZHRoJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2MTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEFkZCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcclxue1xyXG4gICAgcG9pbnQueCArPSB4O1xyXG4gICAgcG9pbnQueSArPSB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvQWRkLmpzXG4vLyBtb2R1bGUgaWQgPSA2MTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENlaWwgPSBmdW5jdGlvbiAocG9pbnQpXHJcbntcclxuICAgIHJldHVybiBwb2ludC5zZXRUbyhNYXRoLmNlaWwocG9pbnQueCksIE1hdGguY2VpbChwb2ludC55KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlaWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9DZWlsLmpzXG4vLyBtb2R1bGUgaWQgPSA2MTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxudmFyIENsb25lID0gZnVuY3Rpb24gKHNvdXJjZSlcclxue1xyXG4gICAgcmV0dXJuIG5ldyBQb2ludChzb3VyY2UueCwgc291cmNlLnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA2MTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ29waWVzIHRoZSB4LCB5IGFuZCBkaWFtZXRlciBwcm9wZXJ0aWVzIGZyb20gYW55IGdpdmVuIG9iamVjdCB0byB0aGlzIENpcmNsZS5cclxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cclxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXHJcbiogQHJldHVybiB7Q2lyY2xlfSBUaGlzIENpcmNsZSBvYmplY3QuXHJcbiovXHJcbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDYxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3Jvc3MgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIpXHJcbntcclxuICAgIHJldHVybiAoKHBvaW50QS54ICogcG9pbnRCLnkpIC0gKHBvaW50QS55ICogcG9pbnRCLngpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3Jvc3M7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9Dcm9zcy5qc1xuLy8gbW9kdWxlIGlkID0gNjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXZpZGUgPSBmdW5jdGlvbiAocG9pbnQsIHgsIHkpXHJcbntcclxuICAgIHBvaW50LnggLz0geDtcclxuICAgIHBvaW50LnkgLz0geTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpdmlkZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0RpdmlkZS5qc1xuLy8gbW9kdWxlIGlkID0gNjE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAocG9pbnQsIHRvQ29tcGFyZSlcclxue1xyXG4gICAgcmV0dXJuIChwb2ludC54ID09PSB0b0NvbXBhcmUueCAmJiBwb2ludC55ID09PSB0b0NvbXBhcmUueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gNjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9vciA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKE1hdGguZmxvb3IocG9pbnQueCksIE1hdGguZmxvb3IocG9pbnQueSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0Zsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSA2MjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxudmFyIEdldENlbnRyb2lkID0gZnVuY3Rpb24gKHBvaW50cywgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldENlbnRyb2lkIHBvaW50cyBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGxlbiA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZXRDZW50cm9pZCBwb2ludHMgYXJyYXkgbXVzdCBub3QgYmUgZW1wdHknKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlbiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IHBvaW50c1swXS54O1xyXG4gICAgICAgIG91dC55ID0gcG9pbnRzWzBdLnk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dC54ICs9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICBvdXQueSArPSBwb2ludHNbaV0ueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG91dC54IC89IGxlbjtcclxuICAgICAgICBvdXQueSAvPSBsZW47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Q2VudHJvaWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9HZXRDZW50cm9pZC5qc1xuLy8gbW9kdWxlIGlkID0gNjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcclxuXHJcbnZhciBJbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50QiwgdCwgb3V0KVxyXG57XHJcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7IHQgPSAwOyB9XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBvdXQueCA9IHBvaW50QS54ICsgKChwb2ludEIueCAtIHBvaW50QS54KSAqIHQpO1xyXG4gICAgb3V0LnkgPSBwb2ludEEueSArICgocG9pbnRCLnkgLSBwb2ludEEueSkgKiB0KTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcnBvbGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0ludGVycG9sYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEludmVydCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKHBvaW50LnksIHBvaW50LngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnZlcnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9JbnZlcnQuanNcbi8vIG1vZHVsZSBpZCA9IDYyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgTmVnYXRpdmUgPSBmdW5jdGlvbiAocG9pbnQsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgcmV0dXJuIG91dC5zZXRUbygtcG9pbnQueCwgLXBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOZWdhdGl2ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L05lZ2F0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE5vcm1hbGl6ZVJpZ2h0SGFuZCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKHBvaW50LnkgKiAtMSwgcG9pbnQueCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbGl6ZVJpZ2h0SGFuZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L05vcm1hbGl6ZVJpZ2h0SGFuZC5qc1xuLy8gbW9kdWxlIGlkID0gNjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJwID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oLXBvaW50LnksIHBvaW50LngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvUGVycC5qc1xuLy8gbW9kdWxlIGlkID0gNjI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEb3QgPSByZXF1aXJlKCcuL0RvdCcpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcbnZhciBHZXRNYWduaXR1ZGVTcSA9IHJlcXVpcmUoJy4vR2V0TWFnbml0dWRlU3EnKTtcclxuXHJcbnZhciBQcm9qZWN0ID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIHZhciBhbXQgPSBEb3QocG9pbnRBLCBwb2ludEIpIC8gR2V0TWFnbml0dWRlU3EocG9pbnRCKTtcclxuXHJcbiAgICBpZiAoYW10ICE9PSAwKVxyXG4gICAge1xyXG4gICAgICAgIG91dC54ID0gYW10ICogcG9pbnRCLng7XHJcbiAgICAgICAgb3V0LnkgPSBhbXQgKiBwb2ludEIueTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvUHJvamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEb3QgPSByZXF1aXJlKCcuL0RvdCcpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgUHJvamVjdFVuaXQgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIGFtdCA9IERvdChwb2ludEEsIHBvaW50Qik7XHJcblxyXG4gICAgaWYgKGFtdCAhPT0gMClcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IGFtdCAqIHBvaW50Qi54O1xyXG4gICAgICAgIG91dC55ID0gYW10ICogcG9pbnRCLnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdFVuaXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9Qcm9qZWN0VW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gNjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSUGVycCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKHBvaW50LnksIC1wb2ludC54KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUlBlcnA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9SUGVycC5qc1xuLy8gbW9kdWxlIGlkID0gNjI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBOb3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xyXG52YXIgTXVsdGlwbHkgPSByZXF1aXJlKCcuL011bHRpcGx5Jyk7XHJcblxyXG52YXIgU2V0TWFnbml0dWRlID0gZnVuY3Rpb24gKHBvaW50LCBtYWduaXR1ZGUpXHJcbntcclxuICAgIE5vcm1hbGl6ZShwb2ludCk7XHJcblxyXG4gICAgcmV0dXJuIE11bHRpcGx5KHBvaW50LCBtYWduaXR1ZGUsIG1hZ25pdHVkZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldE1hZ25pdHVkZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qc1xuLy8gbW9kdWxlIGlkID0gNjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdWJ0cmFjdCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcclxue1xyXG4gICAgcG9pbnQueCAtPSB4O1xyXG4gICAgcG9pbnQueSAtPSB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3VidHJhY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9TdWJ0cmFjdC5qc1xuLy8gbW9kdWxlIGlkID0gNjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5Qb2ludFxyXG5cclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxuUG9pbnQuQWRkID0gcmVxdWlyZSgnLi9BZGQnKTtcclxuUG9pbnQuQ2VpbCA9IHJlcXVpcmUoJy4vQ2VpbCcpO1xyXG5Qb2ludC5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuUG9pbnQuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcblBvaW50LkNyb3NzID0gcmVxdWlyZSgnLi9Dcm9zcycpO1xyXG5Qb2ludC5EaXZpZGUgPSByZXF1aXJlKCcuL0RpdmlkZScpO1xyXG5Qb2ludC5Eb3QgPSByZXF1aXJlKCcuL0RvdCcpO1xyXG5Qb2ludC5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5Qb2ludC5GbG9vciA9IHJlcXVpcmUoJy4vRmxvb3InKTtcclxuUG9pbnQuR2V0Q2VudHJvaWQgPSByZXF1aXJlKCcuL0dldENlbnRyb2lkJyk7XHJcblBvaW50LkdldE1hZ25pdHVkZSA9IHJlcXVpcmUoJy4vR2V0TWFnbml0dWRlJyk7XHJcblBvaW50LkdldE1hZ25pdHVkZVNxID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGVTcScpO1xyXG5Qb2ludC5JbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vSW50ZXJwb2xhdGUnKTtcclxuUG9pbnQuSW52ZXJ0ID0gcmVxdWlyZSgnLi9JbnZlcnQnKTtcclxuUG9pbnQuTXVsdGlwbHkgPSByZXF1aXJlKCcuL011bHRpcGx5Jyk7XHJcblBvaW50Lk5lZ2F0aXZlID0gcmVxdWlyZSgnLi9OZWdhdGl2ZScpO1xyXG5Qb2ludC5Ob3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xyXG5Qb2ludC5Ob3JtYWxpemVSaWdodEhhbmQgPSByZXF1aXJlKCcuL05vcm1hbGl6ZVJpZ2h0SGFuZCcpO1xyXG5Qb2ludC5QZXJwID0gcmVxdWlyZSgnLi9QZXJwJyk7XHJcblBvaW50LlByb2plY3QgPSByZXF1aXJlKCcuL1Byb2plY3QnKTtcclxuUG9pbnQuUHJvamVjdFVuaXQgPSByZXF1aXJlKCcuL1Byb2plY3RVbml0Jyk7XHJcblBvaW50LlJQZXJwID0gcmVxdWlyZSgnLi9SUGVycCcpO1xyXG5Qb2ludC5TZXRNYWduaXR1ZGUgPSByZXF1aXJlKCcuL1NldE1hZ25pdHVkZScpO1xyXG5Qb2ludC5TdWJ0cmFjdCA9IHJlcXVpcmUoJy4vU3VidHJhY3QnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi9Qb2x5Z29uJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAocG9seWdvbilcclxue1xyXG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHBvbHlnb24ucG9pbnRzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2x5Z29uL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA2MzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocG9seWdvbiwgcG9pbnQpXHJcbntcclxuICAgIHJldHVybiBDb250YWlucyhwb2x5Z29uLCBwb2ludC54LCBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNjM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgR2V0QUFCQiA9IGZ1bmN0aW9uIChwb2x5Z29uKVxyXG57XHJcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcclxuICAgIHZhciBtYXhYID0gLW1pblg7XHJcbiAgICB2YXIgbWF4WSA9IC1taW5ZO1xyXG4gICAgdmFyIHA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBwID0gcG9seWdvbi5wb2ludHNbaV07XHJcblxyXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBwLngpO1xyXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwLnkpO1xyXG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLngpO1xyXG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBwLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogbWluWCxcclxuICAgICAgICB5OiBtaW5ZLFxyXG4gICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcclxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBQUJCO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9seWdvbi9HZXRBQUJCLmpzXG4vLyBtb2R1bGUgaWQgPSA2MzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEV4cG9ydCB0aGUgcG9pbnRzIGFzIGFuIGFycmF5IG9mIGZsYXQgbnVtYmVycywgZm9sbG93aW5nIHRoZSBzZXF1ZW5jZSBbIHgseSwgeCx5LCB4LHkgXVxyXG4gKi9cclxudmFyIEdldE51bWJlckFycmF5ID0gZnVuY3Rpb24gKHBvbHlnb24sIG91dHB1dClcclxue1xyXG4gICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7IG91dHB1dCA9IFtdOyB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQucHVzaChwb2x5Z29uLnBvaW50c1tpXS54KTtcclxuICAgICAgICBvdXRwdXQucHVzaChwb2x5Z29uLnBvaW50c1tpXS55KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXROdW1iZXJBcnJheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvbHlnb24vR2V0TnVtYmVyQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDYzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdlb20uUG9seWdvblxyXG5cclxudmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcclxuXHJcblBvbHlnb24uQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcblBvbHlnb24uQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblBvbHlnb24uQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xyXG5Qb2x5Z29uLkdldEFBQkIgPSByZXF1aXJlKCcuL0dldEFBQkInKTtcclxuUG9seWdvbi5HZXROdW1iZXJBcnJheSA9IHJlcXVpcmUoJy4vR2V0TnVtYmVyQXJyYXknKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvbHlnb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQXJlYSA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZXR1cm4gcmVjdC53aWR0aCAqIHJlY3QuaGVpZ2h0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBcmVhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0FyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDYzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbCA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZWN0LnggPSBNYXRoLmNlaWwocmVjdC54KTtcclxuICAgIHJlY3QueSA9IE1hdGguY2VpbChyZWN0LnkpO1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZWlsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDYzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbEFsbCA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZWN0LnggPSBNYXRoLmNlaWwocmVjdC54KTtcclxuICAgIHJlY3QueSA9IE1hdGguY2VpbChyZWN0LnkpO1xyXG4gICAgcmVjdC53aWR0aCA9IE1hdGguY2VpbChyZWN0LndpZHRoKTtcclxuICAgIHJlY3QuaGVpZ2h0ID0gTWF0aC5jZWlsKHJlY3QuaGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VpbEFsbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9DZWlsQWxsLmpzXG4vLyBtb2R1bGUgaWQgPSA2NDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA2NDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocmVjdCwgcG9pbnQpXHJcbntcclxuICAgIHJldHVybiBDb250YWlucyhyZWN0LCBwb2ludC54LCBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9Db250YWluc1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2NDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIENoZWNrcyBpZiByZWN0QiBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIHJlY3RBXHJcblxyXG52YXIgQ29udGFpbnNSZWN0ID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qilcclxue1xyXG4gICAgLy8gIFZvbHVtZSBjaGVjayAoaWYgcmVjdEIgdm9sdW1lID4gcmVjdEEgdGhlbiByZWN0QSBjYW5ub3QgY29udGFpbiBpdClcclxuICAgIGlmICgocmVjdEIud2lkdGggKiByZWN0Qi5oZWlnaHQpID4gKHJlY3RBLndpZHRoICogcmVjdEEuaGVpZ2h0KSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICAocmVjdEIueCA+IHJlY3RBLnggJiYgcmVjdEIueCA8IHJlY3RBLnJpZ2h0KSAmJlxyXG4gICAgICAgIChyZWN0Qi5yaWdodCA+IHJlY3RBLnggJiYgcmVjdEIucmlnaHQgPCByZWN0QS5yaWdodCkgJiZcclxuICAgICAgICAocmVjdEIueSA+IHJlY3RBLnkgJiYgcmVjdEIueSA8IHJlY3RBLmJvdHRvbSkgJiYgXHJcbiAgICAgICAgKHJlY3RCLmJvdHRvbSA+IHJlY3RBLnkgJiYgcmVjdEIuYm90dG9tIDwgcmVjdEEuYm90dG9tKVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNSZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNjQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDY0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKHJlY3QsIHRvQ29tcGFyZSlcclxue1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICByZWN0LnggPT09IHRvQ29tcGFyZS54ICYmXHJcbiAgICAgICAgcmVjdC55ID09PSB0b0NvbXBhcmUueSAmJlxyXG4gICAgICAgIHJlY3Qud2lkdGggPT09IHRvQ29tcGFyZS53aWR0aCAmJlxyXG4gICAgICAgIHJlY3QuaGVpZ2h0ID09PSB0b0NvbXBhcmUuaGVpZ2h0XHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFcXVhbHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEFzcGVjdFJhdGlvID0gcmVxdWlyZSgnLi9HZXRBc3BlY3RSYXRpbycpO1xyXG5cclxuLy8gIEZpdHMgdGhlIHRhcmdldCByZWN0YW5nbGUgaW50byB0aGUgc291cmNlIHJlY3RhbmdsZS5cclxuLy8gIFByZXNlcnZlcyBhc3BlY3QgcmF0aW8uXHJcbi8vICBTY2FsZXMgYW5kIGNlbnRlcnMgdGhlIHRhcmdldCByZWN0YW5nbGUgdG8gdGhlIHNvdXJjZSByZWN0YW5nbGVcclxuXHJcbnZhciBGaXRJbnNpZGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpXHJcbntcclxuICAgIHZhciByYXRpbyA9IEdldEFzcGVjdFJhdGlvKHRhcmdldCk7XHJcblxyXG4gICAgaWYgKHJhdGlvIDwgR2V0QXNwZWN0UmF0aW8oc291cmNlKSlcclxuICAgIHtcclxuICAgICAgICAvLyAgVGFsbGVyIHRoYW4gV2lkZVxyXG4gICAgICAgIHRhcmdldC5zZXRTaXplKHNvdXJjZS5oZWlnaHQgKiByYXRpbywgc291cmNlLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFdpZGVyIHRoYW4gVGFsbFxyXG4gICAgICAgIHRhcmdldC5zZXRTaXplKHNvdXJjZS53aWR0aCwgc291cmNlLndpZHRoICogcmF0aW8pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXQuc2V0UG9zaXRpb24oXHJcbiAgICAgICAgKHNvdXJjZS5yaWdodCAvIDIpIC0gKHRhcmdldC53aWR0aCAvIDIpLFxyXG4gICAgICAgIChzb3VyY2UuYm90dG9tIC8gMikgLSAodGFyZ2V0LmhlaWdodCAvIDIpXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaXRJbnNpZGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvRml0SW5zaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEFzcGVjdFJhdGlvID0gcmVxdWlyZSgnLi9HZXRBc3BlY3RSYXRpbycpO1xyXG5cclxuLy8gIEZpdHMgdGhlIHRhcmdldCByZWN0YW5nbGUgYXJvdW5kIHRoZSBzb3VyY2UgcmVjdGFuZ2xlLlxyXG4vLyAgUHJlc2VydmVzIGFzcGVjdCByYXRpb24uXHJcbi8vICBTY2FsZXMgYW5kIGNlbnRlcnMgdGhlIHRhcmdldCByZWN0YW5nbGUgdG8gdGhlIHNvdXJjZSByZWN0YW5nbGVcclxuXHJcbnZhciBGaXRPdXRzaWRlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKVxyXG57XHJcbiAgICB2YXIgcmF0aW8gPSBHZXRBc3BlY3RSYXRpbyh0YXJnZXQpO1xyXG5cclxuICAgIGlmIChyYXRpbyA+IEdldEFzcGVjdFJhdGlvKHNvdXJjZSkpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFdpZGVyIHRoYW4gVGFsbFxyXG4gICAgICAgIHRhcmdldC5zZXRTaXplKHNvdXJjZS5oZWlnaHQgKiByYXRpbywgc291cmNlLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRhbGxlciB0aGFuIFdpZGVcclxuICAgICAgICB0YXJnZXQuc2V0U2l6ZShzb3VyY2Uud2lkdGgsIHNvdXJjZS53aWR0aCAqIHJhdGlvKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0LnNldFBvc2l0aW9uKFxyXG4gICAgICAgIChzb3VyY2UucmlnaHQgLyAyKSAtIHRhcmdldC53aWR0aCAvIDIsXHJcbiAgICAgICAgKHNvdXJjZS5ib3R0b20gLyAyKSAtIHRhcmdldC5oZWlnaHQgLyAyXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaXRPdXRzaWRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0ZpdE91dHNpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDY0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvb3IgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmVjdC54ID0gTWF0aC5mbG9vcihyZWN0LngpO1xyXG4gICAgcmVjdC55ID0gTWF0aC5mbG9vcihyZWN0LnkpO1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9GbG9vci5qc1xuLy8gbW9kdWxlIGlkID0gNjQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9vckFsbCA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZWN0LnggPSBNYXRoLmZsb29yKHJlY3QueCk7XHJcbiAgICByZWN0LnkgPSBNYXRoLmZsb29yKHJlY3QueSk7XHJcbiAgICByZWN0LndpZHRoID0gTWF0aC5mbG9vcihyZWN0LndpZHRoKTtcclxuICAgIHJlY3QuaGVpZ2h0ID0gTWF0aC5mbG9vcihyZWN0LmhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yQWxsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0Zsb29yQWxsLmpzXG4vLyBtb2R1bGUgaWQgPSA2NDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFRoZSBjZW50ZXIgb2YgdGhlIFJlY3RhbmdsZSBvYmplY3QsIGV4cHJlc3NlZCBhcyBhIFBvaW50IG9iamVjdCBcclxuXHJcbnZhciBHZXRDZW50ZXIgPSBmdW5jdGlvbiAocmVjdCwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuXHJcbiAgICBvdXQueCA9IHJlY3QucmlnaHQgLyAyO1xyXG4gICAgb3V0LnkgPSByZWN0LmJvdHRvbSAvIDI7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Q2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0dldENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGUgc2l6ZSBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCwgZXhwcmVzc2VkIGFzIGEgUG9pbnQgb2JqZWN0IFxyXG4vLyAgd2l0aCB0aGUgdmFsdWVzIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXMuXHJcblxyXG52YXIgR2V0U2l6ZSA9IGZ1bmN0aW9uIChyZWN0LCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIG91dC54ID0gcmVjdC53aWR0aDtcclxuICAgIG91dC55ID0gcmVjdC5oZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0U2l6ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9HZXRTaXplLmpzXG4vLyBtb2R1bGUgaWQgPSA2NTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENlbnRlck9uID0gcmVxdWlyZSgnLi9DZW50ZXJPbicpO1xyXG5cclxuLy8gIEluY3JlYXNlcyB0aGUgc2l6ZSBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCBieSB0aGUgc3BlY2lmaWVkIGFtb3VudHMuXHJcbi8vICBUaGUgY2VudGVyIHBvaW50IG9mIHRoZSBSZWN0YW5nbGUgb2JqZWN0IHN0YXlzIHRoZSBzYW1lLCBhbmQgaXRzIHNpemUgaW5jcmVhc2VzIFxyXG4vLyAgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IGJ5IHRoZSB4IHZhbHVlLCBhbmQgdG8gdGhlIHRvcCBhbmQgdGhlIGJvdHRvbSBieSB0aGUgeSB2YWx1ZS5cclxuXHJcbnZhciBJbmZsYXRlID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIHZhciBjeCA9IHJlY3QuY2VudGVyWDtcclxuICAgIHZhciBjeSA9IHJlY3QuY2VudGVyWTtcclxuXHJcbiAgICByZWN0LnNldFNpemUocmVjdC53aWR0aCArICh4ICogMiksIHJlY3QuaGVpZ2h0ICsgKHkgKiAyKSk7XHJcblxyXG4gICAgcmV0dXJuIENlbnRlck9uKHJlY3QsIGN4LCBjeSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluZmxhdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvSW5mbGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNjUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBNZXJnZXMgdGhlIHRhcmdldCBSZWN0YW5nbGUgd2l0aCBhIGxpc3Qgb2YgcG9pbnRzLlxyXG4vLyAgVGhlIHBvaW50cyBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzLlxyXG5cclxudmFyIE1lcmdlUG9pbnRzID0gZnVuY3Rpb24gKHRhcmdldCwgcG9pbnRzKVxyXG57XHJcbiAgICB2YXIgbWluWCA9IHRhcmdldC54O1xyXG4gICAgdmFyIG1heFggPSB0YXJnZXQucmlnaHQ7XHJcbiAgICB2YXIgbWluWSA9IHRhcmdldC55O1xyXG4gICAgdmFyIG1heFkgPSB0YXJnZXQuYm90dG9tO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBwb2ludHNbaV0ueCk7XHJcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHBvaW50c1tpXS54KTtcclxuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcG9pbnRzW2ldLnkpO1xyXG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBwb2ludHNbaV0ueSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0LnggPSBtaW5YO1xyXG4gICAgdGFyZ2V0LnkgPSBtaW5ZO1xyXG4gICAgdGFyZ2V0LndpZHRoID0gbWF4WCAtIG1pblg7XHJcbiAgICB0YXJnZXQuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVyZ2VQb2ludHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VQb2ludHMuanNcbi8vIG1vZHVsZSBpZCA9IDY1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgTWVyZ2VzIHNvdXJjZSByZWN0YW5nbGUgaW50byB0YXJnZXQgcmVjdGFuZ2xlIGFuZCByZXR1cm5zIHRhcmdldFxyXG4vLyAgTmVpdGhlciByZWN0IHNob3VsZCBoYXZlIG5lZ2F0aXZlIHdpZHRocyBvciBoZWlnaHRzXHJcblxyXG52YXIgTWVyZ2VSZWN0ID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKVxyXG57XHJcbiAgICB2YXIgbWluWCA9IE1hdGgubWluKHRhcmdldC54LCBzb3VyY2UueCk7XHJcbiAgICB2YXIgbWF4WCA9IE1hdGgubWF4KHRhcmdldC5yaWdodCwgc291cmNlLnJpZ2h0KTtcclxuXHJcbiAgICB0YXJnZXQueCA9IG1pblg7XHJcbiAgICB0YXJnZXQud2lkdGggPSBtYXhYIC0gbWluWDtcclxuXHJcbiAgICB2YXIgbWluWSA9IE1hdGgubWluKHRhcmdldC55LCBzb3VyY2UueSk7XHJcbiAgICB2YXIgbWF4WSA9IE1hdGgubWF4KHRhcmdldC5ib3R0b20sIHNvdXJjZS5ib3R0b20pO1xyXG5cclxuICAgIHRhcmdldC55ID0gbWluWTtcclxuICAgIHRhcmdldC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVJlY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBNZXJnZVhZID0gZnVuY3Rpb24gKHRhcmdldCwgeCwgeSlcclxue1xyXG4gICAgdmFyIG1pblggPSBNYXRoLm1pbih0YXJnZXQueCwgeCk7XHJcbiAgICB2YXIgbWF4WCA9IE1hdGgubWF4KHRhcmdldC5yaWdodCwgeCk7XHJcblxyXG4gICAgdGFyZ2V0LnggPSBtaW5YO1xyXG4gICAgdGFyZ2V0LndpZHRoID0gbWF4WCAtIG1pblg7XHJcblxyXG4gICAgdmFyIG1pblkgPSBNYXRoLm1pbih0YXJnZXQueSwgeSk7XHJcbiAgICB2YXIgbWF4WSA9IE1hdGgubWF4KHRhcmdldC5ib3R0b20sIHkpO1xyXG5cclxuICAgIHRhcmdldC55ID0gbWluWTtcclxuICAgIHRhcmdldC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVhZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL01lcmdlWFkuanNcbi8vIG1vZHVsZSBpZCA9IDY1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIHJlY3QueCArPSB4O1xyXG4gICAgcmVjdC55ICs9IHk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9PZmZzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDY1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0UG9pbnQgPSBmdW5jdGlvbiAocmVjdCwgcG9pbnQpXHJcbntcclxuICAgIHJlY3QueCArPSBwb2ludC54O1xyXG4gICAgcmVjdC55ICs9IHBvaW50Lnk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL09mZnNldFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2NTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE92ZXJsYXBzID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qilcclxue1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICByZWN0QS54IDwgcmVjdEIucmlnaHQgJiYgXHJcbiAgICAgICAgcmVjdEEucmlnaHQgPiByZWN0Qi54ICYmIFxyXG4gICAgICAgIHJlY3RBLnkgPCByZWN0Qi5ib3R0b20gJiYgXHJcbiAgICAgICAgcmVjdEEuYm90dG9tID4gcmVjdEIueVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxhcHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvT3ZlcmxhcHMuanNcbi8vIG1vZHVsZSBpZCA9IDY1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcclxuXHJcbi8vICBkZWcgPSBkZWdyZWVzICgwLTM2MClcclxuXHJcbnZhciBQZXJpbWV0ZXJQb2ludCA9IGZ1bmN0aW9uIChyZWN0LCBkZWcsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgdmFyIHRoZXRhID0gZGVnICogTUFUSF9DT05TVC5ERUdfVE9fUkFEO1xyXG5cclxuICAgIHdoaWxlICh0aGV0YSA8IC1NYXRoLlBJKVxyXG4gICAge1xyXG4gICAgICAgIHRoZXRhICs9IE1BVEhfQ09OU1QuUEkyO1xyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlICh0aGV0YSA+IE1hdGguUEkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhldGEgLT0gTUFUSF9DT05TVC5QSTI7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlY3RBdGFuID0gTWF0aC5hdGFuMihyZWN0LmhlaWdodCwgcmVjdC53aWR0aCk7XHJcbiAgICB2YXIgdGFuVGhldGEgPSBNYXRoLnRhbih0aGV0YSk7XHJcbiAgICB2YXIgdGhldGFCb3VuZHMgPSBNYXRoLlBJIC0gcmVjdEF0YW47XHJcbiAgICB2YXIgcmVnaW9uO1xyXG4gICAgdmFyIHhGYWN0b3IgPSAxO1xyXG4gICAgdmFyIHlGYWN0b3IgPSAxO1xyXG5cclxuICAgIGlmICh0aGV0YSA+IC1yZWN0QXRhbiAmJiB0aGV0YSA8PSByZWN0QXRhbilcclxuICAgIHtcclxuICAgICAgICByZWdpb24gPSAxO1xyXG4gICAgICAgIHlGYWN0b3IgPSAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoZXRhID4gcmVjdEF0YW4gJiYgdGhldGEgPD0gdGhldGFCb3VuZHMpXHJcbiAgICB7XHJcbiAgICAgICAgcmVnaW9uID0gMjtcclxuICAgICAgICB5RmFjdG9yID0gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGV0YSA+IHRoZXRhQm91bmRzIHx8IHRoZXRhIDw9IC10aGV0YUJvdW5kcylcclxuICAgIHtcclxuICAgICAgICByZWdpb24gPSAzO1xyXG4gICAgICAgIHhGYWN0b3IgPSAtMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZWdpb24gPSA0O1xyXG4gICAgICAgIHhGYWN0b3IgPSAtMTtcclxuICAgIH1cclxuXHJcbiAgICBvdXQueCA9IHJlY3QueCArIChyZWN0LndpZHRoIC8gMik7XHJcbiAgICBvdXQueSA9IHJlY3QueSArIChyZWN0LmhlaWdodCAvIDIpO1xyXG5cclxuICAgIGlmIChyZWdpb24gPT09IDEgfHwgcmVnaW9uID09PSAzKVxyXG4gICAge1xyXG4gICAgICAgIG91dC54ICs9IHhGYWN0b3IgKiAocmVjdC53aWR0aCAvIDIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIlowXCJcclxuICAgICAgICBvdXQueSArPSB5RmFjdG9yICogKHJlY3Qud2lkdGggLyAyKSAqIHRhblRoZXRhO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIG91dC54ICs9IHhGYWN0b3IgKiAocmVjdC5oZWlnaHQgLyAoMiAqIHRhblRoZXRhKSk7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJaMVwiXHJcbiAgICAgICAgb3V0LnkgKz0geUZhY3RvciAqIChyZWN0LmhlaWdodCAvIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBlcmltZXRlclBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL1BlcmltZXRlclBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2NTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU2NhbGVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoaXMgUmVjdGFuZ2xlIGJ5IHRoZSBnaXZlbiBhbW91bnRzLlxyXG4qL1xyXG52YXIgU2NhbGUgPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcclxue1xyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgIHJlY3Qud2lkdGggKj0geDtcclxuICAgIHJlY3QuaGVpZ2h0ICo9IHk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL1NjYWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgVW5pb24gPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBvdXRwdXQpXHJcbntcclxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSBSZWN0YW5nbGUoKTsgfVxyXG5cclxuICAgIHZhciB4ID0gTWF0aC5taW4ocmVjdEEueCwgcmVjdEIueCk7XHJcbiAgICB2YXIgeSA9IE1hdGgubWluKHJlY3RBLnksIHJlY3RCLnkpO1xyXG5cclxuICAgIHJldHVybiBvdXRwdXQuc2V0KFxyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeSxcclxuICAgICAgICBNYXRoLm1heChyZWN0QS5yaWdodCwgcmVjdEIucmlnaHQpIC0geCxcclxuICAgICAgICBNYXRoLm1heChyZWN0QS5ib3R0b20sIHJlY3RCLmJvdHRvbSkgLSB5XHJcbiAgICApO1xyXG4gICAgXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVuaW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL1VuaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2NjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLlJlY3RhbmdsZVxyXG5cclxudmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XHJcblxyXG5SZWN0YW5nbGUuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xyXG5SZWN0YW5nbGUuQ2VpbCA9IHJlcXVpcmUoJy4vQ2VpbCcpO1xyXG5SZWN0YW5nbGUuQ2VpbEFsbCA9IHJlcXVpcmUoJy4vQ2VpbEFsbCcpO1xyXG5SZWN0YW5nbGUuQ2VudGVyT24gPSByZXF1aXJlKCcuL0NlbnRlck9uJyk7XHJcblJlY3RhbmdsZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuUmVjdGFuZ2xlLkNvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5SZWN0YW5nbGUuQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xyXG5SZWN0YW5nbGUuQ29udGFpbnNSZWN0ID0gcmVxdWlyZSgnLi9Db250YWluc1JlY3QnKTtcclxuUmVjdGFuZ2xlLkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xyXG5SZWN0YW5nbGUuRGVjb21wb3NlID0gcmVxdWlyZSgnLi9EZWNvbXBvc2UnKTtcclxuUmVjdGFuZ2xlLkVxdWFscyA9IHJlcXVpcmUoJy4vRXF1YWxzJyk7XHJcblJlY3RhbmdsZS5GaXRJbnNpZGUgPSByZXF1aXJlKCcuL0ZpdEluc2lkZScpO1xyXG5SZWN0YW5nbGUuRml0T3V0c2lkZSA9IHJlcXVpcmUoJy4vRml0T3V0c2lkZScpO1xyXG5SZWN0YW5nbGUuRmxvb3IgPSByZXF1aXJlKCcuL0Zsb29yJyk7XHJcblJlY3RhbmdsZS5GbG9vckFsbCA9IHJlcXVpcmUoJy4vRmxvb3JBbGwnKTtcclxuUmVjdGFuZ2xlLkdldEFzcGVjdFJhdGlvID0gcmVxdWlyZSgnLi9HZXRBc3BlY3RSYXRpbycpO1xyXG5SZWN0YW5nbGUuR2V0Q2VudGVyID0gcmVxdWlyZSgnLi9HZXRDZW50ZXInKTtcclxuUmVjdGFuZ2xlLkdldFNpemUgPSByZXF1aXJlKCcuL0dldFNpemUnKTtcclxuUmVjdGFuZ2xlLkluZmxhdGUgPSByZXF1aXJlKCcuL0luZmxhdGUnKTtcclxuUmVjdGFuZ2xlLk1hcmNoaW5nQW50cyA9IHJlcXVpcmUoJy4vTWFyY2hpbmdBbnRzJyk7XHJcblJlY3RhbmdsZS5NZXJnZVBvaW50cyA9IHJlcXVpcmUoJy4vTWVyZ2VQb2ludHMnKTtcclxuUmVjdGFuZ2xlLk1lcmdlUmVjdCA9IHJlcXVpcmUoJy4vTWVyZ2VSZWN0Jyk7XHJcblJlY3RhbmdsZS5NZXJnZVhZID0gcmVxdWlyZSgnLi9NZXJnZVhZJyk7XHJcblJlY3RhbmdsZS5PZmZzZXQgPSByZXF1aXJlKCcuL09mZnNldCcpO1xyXG5SZWN0YW5nbGUuT2Zmc2V0UG9pbnQgPSByZXF1aXJlKCcuL09mZnNldFBvaW50Jyk7XHJcblJlY3RhbmdsZS5PdmVybGFwcyA9IHJlcXVpcmUoJy4vT3ZlcmxhcHMnKTtcclxuUmVjdGFuZ2xlLlBlcmltZXRlciA9IHJlcXVpcmUoJy4vUGVyaW1ldGVyJyk7XHJcblJlY3RhbmdsZS5QZXJpbWV0ZXJQb2ludCA9IHJlcXVpcmUoJy4vUGVyaW1ldGVyUG9pbnQnKTtcclxuUmVjdGFuZ2xlLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XHJcblJlY3RhbmdsZS5TY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKTtcclxuUmVjdGFuZ2xlLlVuaW9uID0gcmVxdWlyZSgnLi9VbmlvbicpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgMkQgYXJlYSBvZiBhIHRyaWFuZ2xlLiBUaGUgYXJlYSB2YWx1ZSBpcyBhbHdheXMgbm9uLW5lZ2F0aXZlLlxyXG5cclxudmFyIEFyZWEgPSBmdW5jdGlvbiAodHJpYW5nbGUpXHJcbntcclxuICAgIHZhciB4MSA9IHRyaWFuZ2xlLngxO1xyXG4gICAgdmFyIHkxID0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgdmFyIHgyID0gdHJpYW5nbGUueDI7XHJcbiAgICB2YXIgeTIgPSB0cmlhbmdsZS55MjtcclxuXHJcbiAgICB2YXIgeDMgPSB0cmlhbmdsZS54MztcclxuICAgIHZhciB5MyA9IHRyaWFuZ2xlLnkzO1xyXG5cclxuICAgIHJldHVybiBNYXRoLmFicygoKHgzIC0geDEpICogKHkyIC0geTEpIC0gKHgyIC0geDEpICogKHkzIC0geTEpKSAvIDIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBcmVhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQXJlYS5qc1xuLy8gbW9kdWxlIGlkID0gNjYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUcmlhbmdsZSA9IHJlcXVpcmUoJy4vVHJpYW5nbGUnKTtcclxuXHJcbi8vIEJ1aWxkcyBhbiBlcXVpbGF0ZXJhbCB0cmlhbmdsZS5cclxuLy8gSW4gdGhlIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLCBhbGwgdGhlIHNpZGVzIGFyZSB0aGUgc2FtZSBsZW5ndGggKGNvbmdydWVudClcclxuLy8gYW5kIGFsbCB0aGUgYW5nbGVzIGFyZSB0aGUgc2FtZSBzaXplIChjb25ncnVlbnQpLlxyXG5cclxuLy8gIFRoZSB4L3kgc3BlY2lmaWVzIHRoZSB0b3AtbWlkZGxlIG9mIHRoZSB0cmlhbmdsZSAoeDEveTEpIGFuZCBsZW5ndGhcclxuLy8gIGlzIHRoZSBsZW5ndGggb2YgZWFjaCBzaWRlXHJcblxyXG52YXIgQnVpbGRFcXVpbGF0ZXJhbCA9IGZ1bmN0aW9uICh4LCB5LCBsZW5ndGgpXHJcbntcclxuICAgIHZhciBoZWlnaHQgPSBsZW5ndGggKiAoTWF0aC5zcXJ0KDMpIC8gMik7XHJcblxyXG4gICAgdmFyIHgxID0geDtcclxuICAgIHZhciB5MSA9IHk7XHJcblxyXG4gICAgdmFyIHgyID0geCArIChsZW5ndGggLyAyKTtcclxuICAgIHZhciB5MiA9IHkgKyBoZWlnaHQ7XHJcblxyXG4gICAgdmFyIHgzID0geCAtIChsZW5ndGggLyAyKTtcclxuICAgIHZhciB5MyA9IHkgKyBoZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUcmlhbmdsZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQnVpbGRFcXVpbGF0ZXJhbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL0J1aWxkRXF1aWxhdGVyYWwuanNcbi8vIG1vZHVsZSBpZCA9IDY2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRWFyQ3V0ID0gcmVxdWlyZSgnLi4vcG9seWdvbi9FYXJjdXQnKTtcclxudmFyIFRyaWFuZ2xlID0gcmVxdWlyZSgnLi9UcmlhbmdsZScpO1xyXG5cclxudmFyIEJ1aWxkRnJvbVBvbHlnb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZXMsIHNjYWxlWCwgc2NhbGVZLCBvdXQpXHJcbntcclxuICAgIGlmIChob2xlcyA9PT0gdW5kZWZpbmVkKSB7IGhvbGVzID0gbnVsbDsgfVxyXG4gICAgaWYgKHNjYWxlWCA9PT0gdW5kZWZpbmVkKSB7IHNjYWxlWCA9IDE7IH1cclxuICAgIGlmIChzY2FsZVkgPT09IHVuZGVmaW5lZCkgeyBzY2FsZVkgPSAxOyB9XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gW107IH1cclxuXHJcbiAgICB2YXIgdHJpcyA9IEVhckN1dChkYXRhLCBob2xlcyk7XHJcblxyXG4gICAgdmFyIGE7XHJcbiAgICB2YXIgYjtcclxuICAgIHZhciBjO1xyXG5cclxuICAgIHZhciB4MTtcclxuICAgIHZhciB5MTtcclxuXHJcbiAgICB2YXIgeDI7XHJcbiAgICB2YXIgeTI7XHJcblxyXG4gICAgdmFyIHgzO1xyXG4gICAgdmFyIHkzO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJpcy5sZW5ndGg7IGkgKz0gMylcclxuICAgIHtcclxuICAgICAgICBhID0gdHJpc1tpXTtcclxuICAgICAgICBiID0gdHJpc1tpICsgMV07XHJcbiAgICAgICAgYyA9IHRyaXNbaSArIDJdO1xyXG5cclxuICAgICAgICB4MSA9IGRhdGFbYSAqIDJdICogc2NhbGVYO1xyXG4gICAgICAgIHkxID0gZGF0YVsoYSAqIDIpICsgMV0gKiBzY2FsZVk7XHJcblxyXG4gICAgICAgIHgyID0gZGF0YVtiICogMl0gKiBzY2FsZVg7XHJcbiAgICAgICAgeTIgPSBkYXRhWyhiICogMikgKyAxXSAqIHNjYWxlWTtcclxuXHJcbiAgICAgICAgeDMgPSBkYXRhW2MgKiAyXSAqIHNjYWxlWDtcclxuICAgICAgICB5MyA9IGRhdGFbKGMgKiAyKSArIDFdICogc2NhbGVZO1xyXG5cclxuICAgICAgICBvdXQucHVzaChuZXcgVHJpYW5nbGUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkRnJvbVBvbHlnb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9CdWlsZEZyb21Qb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSA2NjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRyaWFuZ2xlID0gcmVxdWlyZSgnLi9UcmlhbmdsZScpO1xyXG5cclxuLy8gIEJ1aWxkcyBhIHJpZ2h0IHRyaWFuZ2xlLCB3aXRoIG9uZSA5MCBkZWdyZWUgYW5nbGUgYW5kIHR3byBhY3V0ZSBhbmdsZXNcclxuLy8gIFRoZSB4L3kgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIDkwIGRlZ3JlZSBhbmdsZSAoYW5kIHdpbGwgbWFwIHRvIHgxL3kxIGluIHRoZSByZXN1bHRpbmcgVHJpYW5nbGUpXHJcbi8vICB3L2ggY2FuIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGFuZCByZXByZXNlbnQgdGhlIGxlbmd0aCBvZiBlYWNoIHNpZGVcclxuXHJcbnZhciBCdWlsZFJpZ2h0ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbntcclxuICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyAgaGVpZ2h0ID0gd2lkdGg7IH1cclxuXHJcbiAgICAvLyAgOTAgZGVncmVlIGFuZ2xlXHJcbiAgICB2YXIgeDEgPSB4O1xyXG4gICAgdmFyIHkxID0geTtcclxuXHJcbiAgICB2YXIgeDIgPSB4O1xyXG4gICAgdmFyIHkyID0geSAtIGhlaWdodDtcclxuXHJcbiAgICB2YXIgeDMgPSB4ICsgd2lkdGg7XHJcbiAgICB2YXIgeTMgPSB5O1xyXG5cclxuICAgIHJldHVybiBuZXcgVHJpYW5nbGUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkUmlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9CdWlsZFJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENlbnRyb2lkID0gcmVxdWlyZSgnLi9DZW50cm9pZCcpO1xyXG52YXIgT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcclxuXHJcbnZhciBDZW50ZXJPbiA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgeCwgeSwgY2VudGVyRnVuYylcclxue1xyXG4gICAgaWYgKGNlbnRlckZ1bmMgPT09IHVuZGVmaW5lZCkgeyBjZW50ZXJGdW5jID0gQ2VudHJvaWQ7IH1cclxuXHJcbiAgICAvLyAgR2V0IHRoZSBjZW50ZXIgb2YgdGhlIHRyaWFuZ2xlXHJcbiAgICB2YXIgY2VudGVyID0gY2VudGVyRnVuYyh0cmlhbmdsZSk7XHJcblxyXG4gICAgLy8gIERpZmZlcmVuY2VcclxuICAgIHZhciBkaWZmWCA9IHggLSBjZW50ZXIueDtcclxuICAgIHZhciBkaWZmWSA9IHkgLSBjZW50ZXIueTtcclxuXHJcbiAgICByZXR1cm4gT2Zmc2V0KHRyaWFuZ2xlLCBkaWZmWCwgZGlmZlkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2Njdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEFkYXB0ZWQgZnJvbSBodHRwOi8vYmpvcm5oYXJydGVsbC5naXRodWIuaW8vanN0cy9kb2MvYXBpL2pzdHNfZ2VvbV9UcmlhbmdsZS5qcy5odG1sXHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgMngyIG1hdHJpeC4gVXNlcyBzdGFuZGFyZCBkb3VibGUtcHJlY2lzaW9uXHJcbiAqIGFyaXRobWV0aWMsIHNvIGlzIHN1c2NlcHRpYmxlIHRvIHJvdW5kLW9mZiBlcnJvci5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9XHJcbiAqICAgICAgICAgIG0wMCB0aGUgWzAsMF0gZW50cnkgb2YgdGhlIG1hdHJpeC5cclxuICogQHBhcmFtIHtOdW1iZXJ9XHJcbiAqICAgICAgICAgIG0wMSB0aGUgWzAsMV0gZW50cnkgb2YgdGhlIG1hdHJpeC5cclxuICogQHBhcmFtIHtOdW1iZXJ9XHJcbiAqICAgICAgICAgIG0xMCB0aGUgWzEsMF0gZW50cnkgb2YgdGhlIG1hdHJpeC5cclxuICogQHBhcmFtIHtOdW1iZXJ9XHJcbiAqICAgICAgICAgIG0xMSB0aGUgWzEsMV0gZW50cnkgb2YgdGhlIG1hdHJpeC5cclxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgZGV0ZXJtaW5hbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXQgKG0wMCwgbTAxLCBtMTAsIG0xMSlcclxue1xyXG4gICAgcmV0dXJuIChtMDAgKiBtMTEpIC0gKG0wMSAqIG0xMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgY2lyY3VtY2VudHJlIG9mIGEgdHJpYW5nbGUuIFRoZSBjaXJjdW1jZW50cmUgaXMgdGhlIGNlbnRyZSBvZlxyXG4gKiB0aGUgY2lyY3VtY2lyY2xlLCB0aGUgc21hbGxlc3QgY2lyY2xlIHdoaWNoIGVuY2xvc2VzIHRoZSB0cmlhbmdsZS4gSXQgaXMgYWxzb1xyXG4gKiB0aGUgY29tbW9uIGludGVyc2VjdGlvbiBwb2ludCBvZiB0aGUgcGVycGVuZGljdWxhciBiaXNlY3RvcnMgb2YgdGhlIHNpZGVzIG9mXHJcbiAqIHRoZSB0cmlhbmdsZSwgYW5kIGlzIHRoZSBvbmx5IHBvaW50IHdoaWNoIGhhcyBlcXVhbCBkaXN0YW5jZSB0byBhbGwgdGhyZWVcclxuICogdmVydGljZXMgb2YgdGhlIHRyaWFuZ2xlLlxyXG4gKiA8cD5cclxuICogVGhpcyBtZXRob2QgdXNlcyBhbiBhbGdvcml0aG0gZHVlIHRvIEouUi5TaGV3Y2h1ayB3aGljaCB1c2VzIG5vcm1hbGl6YXRpb24gdG9cclxuICogdGhlIG9yaWdpbiB0byBpbXByb3ZlIHRoZSBhY2N1cmFjeSBvZiBjb21wdXRhdGlvbi4gKFNlZSA8aT5MZWN0dXJlIE5vdGVzIG9uXHJcbiAqIEdlb21ldHJpYyBSb2J1c3RuZXNzPC9pPiwgSm9uYXRoYW4gUmljaGFyZCBTaGV3Y2h1aywgMTk5OSkuXHJcbiAqL1xyXG52YXIgQ2lyY3VtQ2VudGVyID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIHZhciBjeCA9IHRyaWFuZ2xlLngzO1xyXG4gICAgdmFyIGN5ID0gdHJpYW5nbGUueTM7XHJcblxyXG4gICAgdmFyIGF4ID0gdHJpYW5nbGUueDEgLSBjeDtcclxuICAgIHZhciBheSA9IHRyaWFuZ2xlLnkxIC0gY3k7XHJcblxyXG4gICAgdmFyIGJ4ID0gdHJpYW5nbGUueDIgLSBjeDtcclxuICAgIHZhciBieSA9IHRyaWFuZ2xlLnkyIC0gY3k7XHJcblxyXG4gICAgdmFyIGRlbm9tID0gMiAqIGRldChheCwgYXksIGJ4LCBieSk7XHJcbiAgICB2YXIgbnVteCA9IGRldChheSwgYXggKiBheCArIGF5ICogYXksIGJ5LCBieCAqIGJ4ICsgYnkgKiBieSk7XHJcbiAgICB2YXIgbnVteSA9IGRldChheCwgYXggKiBheCArIGF5ICogYXksIGJ4LCBieCAqIGJ4ICsgYnkgKiBieSk7XHJcblxyXG4gICAgb3V0LnggPSBjeCAtIG51bXggLyBkZW5vbTtcclxuICAgIG91dC55ID0gY3kgKyBudW15IC8gZGVub207XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VtQ2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQ2lyY3VtQ2VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2Njhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tdXRvby81NjE3NjkxXHJcblxyXG52YXIgQ2lyY3VtQ2lyY2xlID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAsIHJhZGl1czogMCB9OyB9XHJcblxyXG4gICAgLy8gIEFcclxuICAgIHZhciB4MSA9IHRyaWFuZ2xlLngxO1xyXG4gICAgdmFyIHkxID0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgLy8gIEJcclxuICAgIHZhciB4MiA9IHRyaWFuZ2xlLngyO1xyXG4gICAgdmFyIHkyID0gdHJpYW5nbGUueTI7XHJcblxyXG4gICAgLy8gIENcclxuICAgIHZhciB4MyA9IHRyaWFuZ2xlLngzO1xyXG4gICAgdmFyIHkzID0gdHJpYW5nbGUueTM7XHJcblxyXG4gICAgdmFyIEEgPSB4MiAtIHgxO1xyXG4gICAgdmFyIEIgPSB5MiAtIHkxO1xyXG4gICAgdmFyIEMgPSB4MyAtIHgxO1xyXG4gICAgdmFyIEQgPSB5MyAtIHkxO1xyXG4gICAgdmFyIEUgPSBBICogKHgxICsgeDIpICsgQiAqICh5MSArIHkyKTtcclxuICAgIHZhciBGID0gQyAqICh4MSArIHgzKSArIEQgKiAoeTEgKyB5Myk7XHJcbiAgICB2YXIgRyA9IDIgKiAoQSAqICh5MyAtIHkyKSAtIEIgKiAoeDMgLSB4MikpO1xyXG5cclxuICAgIHZhciBkeDtcclxuICAgIHZhciBkeTtcclxuXHJcbiAgICAvLyAgSWYgdGhlIHBvaW50cyBvZiB0aGUgdHJpYW5nbGUgYXJlIGNvbGxpbmVhciwgdGhlbiBqdXN0IGZpbmQgdGhlXHJcbiAgICAvLyAgZXh0cmVtZXMgYW5kIHVzZSB0aGUgbWlkcG9pbnQgYXMgdGhlIGNlbnRlciBvZiB0aGUgY2lyY3VtY2lyY2xlLlxyXG5cclxuICAgIGlmIChNYXRoLmFicyhHKSA8IDAuMDAwMDAxKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBtaW5YID0gTWF0aC5taW4oeDEsIHgyLCB4Myk7XHJcbiAgICAgICAgdmFyIG1pblkgPSBNYXRoLm1pbih5MSwgeTIsIHkzKTtcclxuICAgICAgICBkeCA9IChNYXRoLm1heCh4MSwgeDIsIHgzKSAtIG1pblgpICogMC41O1xyXG4gICAgICAgIGR5ID0gKE1hdGgubWF4KHkxLCB5MiwgeTMpIC0gbWluWSkgKiAwLjU7XHJcblxyXG4gICAgICAgIG91dC54ID0gbWluWCArIGR4O1xyXG4gICAgICAgIG91dC55ID0gbWluWSArIGR5O1xyXG4gICAgICAgIG91dC5yYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIG91dC54ID0gKEQgKiBFIC0gQiAqIEYpIC8gRztcclxuICAgICAgICBvdXQueSA9IChBICogRiAtIEMgKiBFKSAvIEc7XHJcbiAgICAgICAgZHggPSBvdXQueCAtIHgxO1xyXG4gICAgICAgIGR5ID0gb3V0LnkgLSB5MTtcclxuICAgICAgICBvdXQucmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjdW1DaXJjbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9DaXJjdW1DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDY2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVHJpYW5nbGUgPSByZXF1aXJlKCcuL1RyaWFuZ2xlJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFRyaWFuZ2xlKHNvdXJjZS54MSwgc291cmNlLnkxLCBzb3VyY2UueDIsIHNvdXJjZS55Miwgc291cmNlLngzLCBzb3VyY2UueTMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA2NzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAodHJpYW5nbGUsIHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gQ29udGFpbnModHJpYW5nbGUsIHBvaW50LngsIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQ29udGFpbnNQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54MSwgc291cmNlLnkxLCBzb3VyY2UueDIsIHNvdXJjZS55Miwgc291cmNlLngzLCBzb3VyY2UueTMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL0NvcHlGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSA2NzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFscyA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgdG9Db21wYXJlKVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHRyaWFuZ2xlLngxID09PSB0b0NvbXBhcmUueDEgJiZcclxuICAgICAgICB0cmlhbmdsZS55MSA9PT0gdG9Db21wYXJlLnkxICYmXHJcbiAgICAgICAgdHJpYW5nbGUueDIgPT09IHRvQ29tcGFyZS54MiAmJlxyXG4gICAgICAgIHRyaWFuZ2xlLnkyID09PSB0b0NvbXBhcmUueTIgJiZcclxuICAgICAgICB0cmlhbmdsZS54MyA9PT0gdG9Db21wYXJlLngzICYmXHJcbiAgICAgICAgdHJpYW5nbGUueTMgPT09IHRvQ29tcGFyZS55M1xyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xyXG52YXIgSW5DZW50ZXIgPSByZXF1aXJlKCcuL0luQ2VudGVyJyk7XHJcblxyXG52YXIgUm90YXRlID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBhbmdsZSlcclxue1xyXG4gICAgdmFyIHBvaW50ID0gSW5DZW50ZXIodHJpYW5nbGUpO1xyXG5cclxuICAgIHJldHVybiBSb3RhdGVBcm91bmRYWSh0cmlhbmdsZSwgcG9pbnQueCwgcG9pbnQueSwgYW5nbGUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9Sb3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDY3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm90YXRlQXJvdW5kWFkgPSByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZFhZJyk7XHJcblxyXG52YXIgUm90YXRlQXJvdW5kUG9pbnQgPSBmdW5jdGlvbiAodHJpYW5nbGUsIHBvaW50LCBhbmdsZSlcclxue1xyXG4gICAgcmV0dXJuIFJvdGF0ZUFyb3VuZFhZKHRyaWFuZ2xlLCBwb2ludC54LCBwb2ludC55LCBhbmdsZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvUm90YXRlQXJvdW5kUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDY3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdlb20uVHJpYW5nbGVcclxuXHJcbnZhciBUcmlhbmdsZSA9IHJlcXVpcmUoJy4vVHJpYW5nbGUnKTtcclxuXHJcblRyaWFuZ2xlLkFyZWEgPSByZXF1aXJlKCcuL0FyZWEnKTtcclxuVHJpYW5nbGUuQnVpbGRFcXVpbGF0ZXJhbCA9IHJlcXVpcmUoJy4vQnVpbGRFcXVpbGF0ZXJhbCcpO1xyXG5UcmlhbmdsZS5CdWlsZEZyb21Qb2x5Z29uID0gcmVxdWlyZSgnLi9CdWlsZEZyb21Qb2x5Z29uJyk7XHJcblRyaWFuZ2xlLkJ1aWxkUmlnaHQgPSByZXF1aXJlKCcuL0J1aWxkUmlnaHQnKTtcclxuVHJpYW5nbGUuQ2VudGVyT24gPSByZXF1aXJlKCcuL0NlbnRlck9uJyk7XHJcblRyaWFuZ2xlLkNlbnRyb2lkID0gcmVxdWlyZSgnLi9DZW50cm9pZCcpO1xyXG5UcmlhbmdsZS5DaXJjdW1DZW50ZXIgPSByZXF1aXJlKCcuL0NpcmN1bUNlbnRlcicpO1xyXG5UcmlhbmdsZS5DaXJjdW1DaXJjbGUgPSByZXF1aXJlKCcuL0NpcmN1bUNpcmNsZScpO1xyXG5UcmlhbmdsZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuVHJpYW5nbGUuQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblRyaWFuZ2xlLkNvbnRhaW5zQXJyYXkgPSByZXF1aXJlKCcuL0NvbnRhaW5zQXJyYXknKTtcclxuVHJpYW5nbGUuQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xyXG5UcmlhbmdsZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcclxuVHJpYW5nbGUuRGVjb21wb3NlID0gcmVxdWlyZSgnLi9EZWNvbXBvc2UnKTtcclxuVHJpYW5nbGUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcclxuVHJpYW5nbGUuSW5DZW50ZXIgPSByZXF1aXJlKCcuL0luQ2VudGVyJyk7XHJcblRyaWFuZ2xlLk9mZnNldCA9IHJlcXVpcmUoJy4vT2Zmc2V0Jyk7XHJcblRyaWFuZ2xlLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XHJcblRyaWFuZ2xlLlJvdGF0ZSA9IHJlcXVpcmUoJy4vUm90YXRlJyk7XHJcblRyaWFuZ2xlLlJvdGF0ZUFyb3VuZFBvaW50ID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRQb2ludCcpO1xyXG5UcmlhbmdsZS5Sb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJpYW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRha2VzIHRoZSBhdmVyYWdlIG9mIHRoZSBzb3VyY2UgYW5kIGJhY2tkcm9wIGNvbG9ycy5cclxuKi9cclxudmFyIEF2ZXJhZ2UgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChhICsgYikgLyAyO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBdmVyYWdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvQXZlcmFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFN1YnRyYWN0cyB0aGUgZGFya2VyIG9mIHRoZSB0d28gY29uc3RpdHVlbnQgY29sb3JzIGZyb20gdGhlIGxpZ2h0ZXIuXHJcbiogXHJcbiogUGFpbnRpbmcgd2l0aCB3aGl0ZSBpbnZlcnRzIHRoZSBiYWNrZHJvcCBjb2xvcjsgcGFpbnRpbmcgd2l0aCBibGFjayBwcm9kdWNlcyBubyBjaGFuZ2UuIFxyXG4qL1xyXG52YXIgRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaWZmZXJlbmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvRGlmZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gNjc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFByb2R1Y2VzIGFuIGVmZmVjdCBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIERpZmZlcmVuY2UgbW9kZSwgYnV0IGxvd2VyIGluIGNvbnRyYXN0LiBcclxuKiBQYWludGluZyB3aXRoIHdoaXRlIGludmVydHMgdGhlIGJhY2tkcm9wIGNvbG9yOyBwYWludGluZyB3aXRoIGJsYWNrIHByb2R1Y2VzIG5vIGNoYW5nZS4gXHJcbiovXHJcbnZhciBFeGNsdXNpb24gPSAgZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBhICsgYiAtIDIgKiBhICogYiAvIDI1NTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXhjbHVzaW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvRXhjbHVzaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2Nzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlZmxlY3QgPSByZXF1aXJlKCcuL1JlZmxlY3QnKTtcclxuXHJcbi8qKlxyXG4qIEdsb3cgYmxlbmQgbW9kZS4gVGhpcyBtb2RlIGlzIGEgdmFyaWF0aW9uIG9mIHJlZmxlY3QgbW9kZSB3aXRoIHRoZSBzb3VyY2UgYW5kIGJhY2tkcm9wIGNvbG9ycyBzd2FwcGVkLlxyXG4qL1xyXG52YXIgR2xvdyA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gUmVmbGVjdChiLCBhKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2xvdztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL0dsb3cuanNcbi8vIG1vZHVsZSBpZCA9IDY4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT3ZlcmxheSA9IHJlcXVpcmUoJy4vT3ZlcmxheScpO1xyXG5cclxuLyoqXHJcbiogTXVsdGlwbGllcyBvciBzY3JlZW5zIHRoZSBjb2xvcnMsIGRlcGVuZGluZyBvbiB0aGUgc291cmNlIGNvbG9yIHZhbHVlLiBcclxuKiBcclxuKiBJZiB0aGUgc291cmNlIGNvbG9yIGlzIGxpZ2h0ZXIgdGhhbiAwLjUsIHRoZSBiYWNrZHJvcCBpcyBsaWdodGVuZWQsIGFzIGlmIGl0IHdlcmUgc2NyZWVuZWQ7IFxyXG4qIHRoaXMgaXMgdXNlZnVsIGZvciBhZGRpbmcgaGlnaGxpZ2h0cyB0byBhIHNjZW5lLiBcclxuKiBcclxuKiBJZiB0aGUgc291cmNlIGNvbG9yIGlzIGRhcmtlciB0aGFuIDAuNSwgdGhlIGJhY2tkcm9wIGlzIGRhcmtlbmVkLCBhcyBpZiBpdCB3ZXJlIG11bHRpcGxpZWQ7IFxyXG4qIHRoaXMgaXMgdXNlZnVsIGZvciBhZGRpbmcgc2hhZG93cyB0byBhIHNjZW5lLiBcclxuKiBcclxuKiBUaGUgZGVncmVlIG9mIGxpZ2h0ZW5pbmcgb3IgZGFya2VuaW5nIGlzIHByb3BvcnRpb25hbCB0byB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgY29sb3IgYW5kIDAuNTsgXHJcbiogaWYgaXQgaXMgZXF1YWwgdG8gMC41LCB0aGUgYmFja2Ryb3AgaXMgdW5jaGFuZ2VkLlxyXG4qIFxyXG4qIFBhaW50aW5nIHdpdGggcHVyZSBibGFjayBvciB3aGl0ZSBwcm9kdWNlcyBwdXJlIGJsYWNrIG9yIHdoaXRlLiBUaGUgZWZmZWN0IGlzIHNpbWlsYXIgdG8gc2hpbmluZyBhIGhhcnNoIHNwb3RsaWdodCBvbiB0aGUgYmFja2Ryb3AuIFxyXG4qL1xyXG52YXIgSGFyZExpZ2h0ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBPdmVybGF5KGIsIGEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYXJkTGlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9IYXJkTGlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDY4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVml2aWRMaWdodCA9IHJlcXVpcmUoJy4vVml2aWRMaWdodCcpO1xyXG5cclxuLyoqXHJcbiogUnVucyBibGVuZFZpdmlkTGlnaHQgb24gdGhlIHNvdXJjZSBhbmQgYmFja2Ryb3AgY29sb3JzLlxyXG4qIElmIHRoZSByZXN1bHRpbmcgY29sb3IgaXMgMTI4IG9yIG1vcmUsIGl0IHJlY2VpdmVzIGEgdmFsdWUgb2YgMjU1OyBpZiBsZXNzIHRoYW4gMTI4LCBhIHZhbHVlIG9mIDAuXHJcbiogVGhlcmVmb3JlLCBhbGwgYmxlbmRlZCBwaXhlbHMgaGF2ZSByZWQsIGdyZWVuLCBhbmQgYmx1ZSBjaGFubmVsIHZhbHVlcyBvZiBlaXRoZXIgMCBvciAyNTUuXHJcbiogVGhpcyBjaGFuZ2VzIGFsbCBwaXhlbHMgdG8gcHJpbWFyeSBhZGRpdGl2ZSBjb2xvcnMgKHJlZCwgZ3JlZW4sIG9yIGJsdWUpLCB3aGl0ZSwgb3IgYmxhY2suXHJcbiovXHJcbnZhciBIYXJkTWl4ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoVml2aWRMaWdodChhLCBiKSA8IDEyOCkgPyAwIDogMjU1O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYXJkTWl4O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvSGFyZE1peC5qc1xuLy8gbW9kdWxlIGlkID0gNjgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaW5lYXJCdXJuID0gcmVxdWlyZSgnLi9MaW5lYXJCdXJuJyk7XHJcbnZhciBMaW5lYXJEb2RnZSA9IHJlcXVpcmUoJy4vTGluZWFyRG9kZ2UnKTtcclxuXHJcbi8qKlxyXG4qIFRoaXMgYmxlbmQgbW9kZSBjb21iaW5lcyBMaW5lYXIgRG9kZ2UgYW5kIExpbmVhciBCdXJuIChyZXNjYWxlZCBzbyB0aGF0IG5ldXRyYWwgY29sb3JzIGJlY29tZSBtaWRkbGUgZ3JheSkuXHJcbiogRG9kZ2UgYXBwbGllcyB0byB2YWx1ZXMgb2YgdG9wIGxheWVyIGxpZ2h0ZXIgdGhhbiBtaWRkbGUgZ3JheSwgYW5kIGJ1cm4gdG8gZGFya2VyIHZhbHVlcy5cclxuKiBUaGUgY2FsY3VsYXRpb24gc2ltcGxpZmllcyB0byB0aGUgc3VtIG9mIGJvdHRvbSBsYXllciBhbmQgdHdpY2UgdGhlIHRvcCBsYXllciwgc3VidHJhY3QgMTI4LiBUaGUgY29udHJhc3QgZGVjcmVhc2VzLlxyXG4qL1xyXG52YXIgTGluZWFyTGlnaHQgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiIDwgMTI4KSA/IExpbmVhckJ1cm4oYSwgMiAqIGIpIDogTGluZWFyRG9kZ2UoYSwgKDIgKiAoYiAtIDEyOCkpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZWFyTGlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaW5lYXJMaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNjgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIE11bHRpcGxpZXMgdGhlIGJhY2tkcm9wIGFuZCBzb3VyY2UgY29sb3IgdmFsdWVzLlxyXG4qIFRoZSByZXN1bHQgY29sb3IgaXMgYWx3YXlzIGF0IGxlYXN0IGFzIGRhcmsgYXMgZWl0aGVyIG9mIHRoZSB0d28gY29uc3RpdHVlbnRcclxuKiBjb2xvcnMuIE11bHRpcGx5aW5nIGFueSBjb2xvciB3aXRoIGJsYWNrIHByb2R1Y2VzIGJsYWNrO1xyXG4qIG11bHRpcGx5aW5nIHdpdGggd2hpdGUgbGVhdmVzIHRoZSBvcmlnaW5hbCBjb2xvciB1bmNoYW5nZWQuXHJcbiovXHJcbnZhciBNdWx0aXBseSA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGEgKiBiKSAvIDI1NTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTXVsdGlwbHk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9NdWx0aXBseS5qc1xuLy8gbW9kdWxlIGlkID0gNjg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIE5lZ2F0aW9uIGJsZW5kIG1vZGUuXHJcbiovXHJcbnZhciBOZWdhdGlvbiA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gMjU1IC0gTWF0aC5hYnMoMjU1IC0gYSAtIGIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOZWdhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL05lZ2F0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2ODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQmxlbmRzIHRoZSBzb3VyY2UgY29sb3IsIGlnbm9yaW5nIHRoZSBiYWNrZHJvcC5cclxuKi9cclxudmFyIE5vcm1hbCA9IGZ1bmN0aW9uIChhKVxyXG57XHJcbiAgICByZXR1cm4gYTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvTm9ybWFsLmpzXG4vLyBtb2R1bGUgaWQgPSA2ODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogUGhvZW5peCBibGVuZCBtb2RlLiBUaGlzIHN1YnRyYWN0cyB0aGUgbGlnaHRlciBjb2xvciBmcm9tIHRoZSBkYXJrZXIgY29sb3IsIGFuZCBhZGRzIDI1NSwgZ2l2aW5nIGEgYnJpZ2h0IHJlc3VsdC5cclxuKi9cclxudmFyIFBob2VuaXggPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIE1hdGgubWluKGEsIGIpIC0gTWF0aC5tYXgoYSwgYikgKyAyNTU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBob2VuaXg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9QaG9lbml4LmpzXG4vLyBtb2R1bGUgaWQgPSA2ODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERhcmtlbiA9IHJlcXVpcmUoJy4vRGFya2VuJyk7XHJcbnZhciBMaWdodGVuID0gcmVxdWlyZSgnLi9MaWdodGVuJyk7XHJcblxyXG4vKipcclxuKiBJZiB0aGUgYmFja2Ryb3AgY29sb3IgKGxpZ2h0IHNvdXJjZSkgaXMgbGlnaHRlciB0aGFuIDUwJSwgdGhlIGJsZW5kRGFya2VuIG1vZGUgaXMgdXNlZCwgYW5kIGNvbG9ycyBsaWdodGVyIHRoYW4gdGhlIGJhY2tkcm9wIGNvbG9yIGRvIG5vdCBjaGFuZ2UuXHJcbiogSWYgdGhlIGJhY2tkcm9wIGNvbG9yIGlzIGRhcmtlciB0aGFuIDUwJSBncmF5LCBjb2xvcnMgbGlnaHRlciB0aGFuIHRoZSBibGVuZCBjb2xvciBhcmUgcmVwbGFjZWQsIGFuZCBjb2xvcnMgZGFya2VyIHRoYW4gdGhlIGJsZW5kIGNvbG9yIGRvIG5vdCBjaGFuZ2UuXHJcbiovXHJcbnZhciBQaW5MaWdodCA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGIgPCAxMjgpID8gRGFya2VuKGEsIDIgKiBiKSA6IExpZ2h0ZW4oYSwgKDIgKiAoYiAtIDEyOCkpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGluTGlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9QaW5MaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNjg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIE11bHRpcGxpZXMgdGhlIGNvbXBsZW1lbnRzIG9mIHRoZSBiYWNrZHJvcCBhbmQgc291cmNlIGNvbG9yIHZhbHVlcywgdGhlbiBjb21wbGVtZW50cyB0aGUgcmVzdWx0LlxyXG4qIFRoZSByZXN1bHQgY29sb3IgaXMgYWx3YXlzIGF0IGxlYXN0IGFzIGxpZ2h0IGFzIGVpdGhlciBvZiB0aGUgdHdvIGNvbnN0aXR1ZW50IGNvbG9ycy4gXHJcbiogU2NyZWVuaW5nIGFueSBjb2xvciB3aXRoIHdoaXRlIHByb2R1Y2VzIHdoaXRlOyBzY3JlZW5pbmcgd2l0aCBibGFjayBsZWF2ZXMgdGhlIG9yaWdpbmFsIGNvbG9yIHVuY2hhbmdlZC4gXHJcbiovXHJcbnZhciBTY3JlZW4gPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIDI1NSAtICgoKDI1NSAtIGEpICogKDI1NSAtIGIpKSA+PiA4KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NyZWVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvU2NyZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA2ODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogRGFya2VucyBvciBsaWdodGVucyB0aGUgY29sb3JzLCBkZXBlbmRpbmcgb24gdGhlIHNvdXJjZSBjb2xvciB2YWx1ZS4gXHJcbiogXHJcbiogSWYgdGhlIHNvdXJjZSBjb2xvciBpcyBsaWdodGVyIHRoYW4gMC41LCB0aGUgYmFja2Ryb3AgaXMgbGlnaHRlbmVkLCBhcyBpZiBpdCB3ZXJlIGRvZGdlZDsgXHJcbiogdGhpcyBpcyB1c2VmdWwgZm9yIGFkZGluZyBoaWdobGlnaHRzIHRvIGEgc2NlbmUuIFxyXG4qIFxyXG4qIElmIHRoZSBzb3VyY2UgY29sb3IgaXMgZGFya2VyIHRoYW4gMC41LCB0aGUgYmFja2Ryb3AgaXMgZGFya2VuZWQsIGFzIGlmIGl0IHdlcmUgYnVybmVkIGluLiBcclxuKiBUaGUgZGVncmVlIG9mIGxpZ2h0ZW5pbmcgb3IgZGFya2VuaW5nIGlzIHByb3BvcnRpb25hbCB0byB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgY29sb3IgYW5kIDAuNTsgXHJcbiogaWYgaXQgaXMgZXF1YWwgdG8gMC41LCB0aGUgYmFja2Ryb3AgaXMgdW5jaGFuZ2VkLlxyXG4qIFxyXG4qIFBhaW50aW5nIHdpdGggcHVyZSBibGFjayBvciB3aGl0ZSBwcm9kdWNlcyBhIGRpc3RpbmN0bHkgZGFya2VyIG9yIGxpZ2h0ZXIgYXJlYSwgYnV0IGRvZXMgbm90IHJlc3VsdCBpbiBwdXJlIGJsYWNrIG9yIHdoaXRlLiBcclxuKiBUaGUgZWZmZWN0IGlzIHNpbWlsYXIgdG8gc2hpbmluZyBhIGRpZmZ1c2VkIHNwb3RsaWdodCBvbiB0aGUgYmFja2Ryb3AuIFxyXG4qL1xyXG52YXIgU29mdExpZ2h0ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoYiA8IDEyOCkgPyAoMiAqICgoYSA+PiAxKSArIDY0KSkgKiAoYiAvIDI1NSkgOiAyNTUgLSAoMiAqICgyNTUgLSAoKGEgPj4gMSkgKyA2NCkpICogKDI1NSAtIGIpIC8gMjU1KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU29mdExpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvU29mdExpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA2OTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HcmFwaGljcy5CbGVuZE1vZGVzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBBZGQ6IHJlcXVpcmUoJy4vQWRkJyksXHJcbiAgICBBdmVyYWdlOiByZXF1aXJlKCcuL0F2ZXJhZ2UnKSxcclxuICAgIENvbG9yQnVybjogcmVxdWlyZSgnLi9Db2xvckJ1cm4nKSxcclxuICAgIENvbG9yRG9kZ2U6IHJlcXVpcmUoJy4vQ29sb3JEb2RnZScpLFxyXG4gICAgRGFya2VuOiByZXF1aXJlKCcuL0RhcmtlbicpLFxyXG4gICAgRGlmZmVyZW5jZTogcmVxdWlyZSgnLi9EaWZmZXJlbmNlJyksXHJcbiAgICBFeGNsdXNpb246IHJlcXVpcmUoJy4vRXhjbHVzaW9uJyksXHJcbiAgICBHbG93OiByZXF1aXJlKCcuL0dsb3cnKSxcclxuICAgIEhhcmRMaWdodDogcmVxdWlyZSgnLi9IYXJkTGlnaHQnKSxcclxuICAgIEhhcmRNaXg6IHJlcXVpcmUoJy4vSGFyZE1peCcpLFxyXG4gICAgTGlnaHRlbjogcmVxdWlyZSgnLi9MaWdodGVuJyksXHJcbiAgICBMaW5lYXJCdXJuOiByZXF1aXJlKCcuL0xpbmVhckJ1cm4nKSxcclxuICAgIExpbmVhckRvZGdlOiByZXF1aXJlKCcuL0xpbmVhckRvZGdlJyksXHJcbiAgICBMaW5lYXJMaWdodDogcmVxdWlyZSgnLi9MaW5lYXJMaWdodCcpLFxyXG4gICAgTXVsdGlwbHk6IHJlcXVpcmUoJy4vTXVsdGlwbHknKSxcclxuICAgIE5lZ2F0aW9uOiByZXF1aXJlKCcuL05lZ2F0aW9uJyksXHJcbiAgICBOb3JtYWw6IHJlcXVpcmUoJy4vTm9ybWFsJyksXHJcbiAgICBPdmVybGF5OiByZXF1aXJlKCcuL092ZXJsYXknKSxcclxuICAgIFBob2VuaXg6IHJlcXVpcmUoJy4vUGhvZW5peCcpLFxyXG4gICAgUGluTGlnaHQ6IHJlcXVpcmUoJy4vUGluTGlnaHQnKSxcclxuICAgIFJlZmxlY3Q6IHJlcXVpcmUoJy4vUmVmbGVjdCcpLFxyXG4gICAgU2NyZWVuOiByZXF1aXJlKCcuL1NjcmVlbicpLFxyXG4gICAgU29mdExpZ2h0OiByZXF1aXJlKCcuL1NvZnRMaWdodCcpLFxyXG4gICAgU3VidHJhY3Q6IHJlcXVpcmUoJy4vU3VidHJhY3QnKSxcclxuICAgIFZpdmlkTGlnaHQ6IHJlcXVpcmUoJy4vVml2aWRMaWdodCcpXHJcbiAgICBcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2OTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbG9yID0gcmVxdWlyZSgnLi9Db2xvcicpO1xyXG5cclxudmFyIENTU01hcCA9IHtcclxuICAgIGFsaWNlYmx1ZTogWyAyNDAsIDI0OCwgMjQ1IF0sXHJcbiAgICBhbnRpcXVld2hpdGU6IFsgMjUwLCAyMzUsIDIxNSBdLFxyXG4gICAgYXF1YTogWyAwLCAyNTUsIDI1NSBdLFxyXG4gICAgYXF1YW1hcmluZTogWyAxMjcsIDI1NSwgMjEyIF0sXHJcbiAgICBhenVyZTogWyAyNDAsIDI1NSwgMjU1IF0sXHJcbiAgICBiZWlnZTogWyAyNDUsIDI0NSwgMjIwIF0sXHJcbiAgICBiaXNxdWU6IFsgMjU1LCAyMjgsIDE5NiBdLFxyXG4gICAgYmxhY2s6IFsgMCwgMCwgMCBdLFxyXG4gICAgYmxhbmNoZWRhbG1vbmQ6IFsgMjU1LCAyMzUsIDIwNSBdLFxyXG4gICAgYmx1ZTogWyAwLCAwLCAyNTUgXSxcclxuICAgIGJsdWV2aW9sZXQ6IFsgMTM4LCA0MywgMjI2IF0sXHJcbiAgICBicm93bjogWyAxNjUsIDQyLCA0MiBdLFxyXG4gICAgYnVybHl3b29kOiBbIDIyMiwgMTg0LCAzNSBdLFxyXG4gICAgY2FkZXRibHVlOiBbIDk1LCAxNTgsIDE2MCBdLFxyXG4gICAgY2hhcnRyZXVzZTogWyAxMjcsIDI1NSwgMCBdLFxyXG4gICAgY2hvY29sYXRlOiBbIDIxMCwgMTA1LCAzMCBdLFxyXG4gICAgY29yYWw6IFsgMjU1LCAxMjcsIDgwIF0sXHJcbiAgICBjb3JuZmxvd2VyYmx1ZTogWyAxMDAsIDE0OSwgMjM3IF0sXHJcbiAgICBjb3Juc2lsazogWyAyNTUsIDI0OCwgMjIwIF0sXHJcbiAgICBjcmltc29uOiBbIDIyMCwgMjAsIDYwIF0sXHJcbiAgICBkYXJrYmx1ZTogWyAwLCAwLCAxMzkgXSxcclxuICAgIGRhcmtjeWFuOiBbIDAsIDEzOSwgMTM5IF0sXHJcbiAgICBkYXJrZ29sZGVucm9kOiBbIDE4NCwgMTM0LCAxMSBdLFxyXG4gICAgZGFya2dyYXk6IFsgMTY5LCAxNjksIDE2OSBdLFxyXG4gICAgZGFya2dyZWVuOiBbIDAsIDEwMCwgMCBdLFxyXG4gICAgZGFya2dyZXk6IFsgMTY5LCAxNjksIDE2OSBdLFxyXG4gICAgZGFya2toYWtpOiBbIDE4OSwgMTgzLCAxMDcgXSxcclxuICAgIGRhcmttYWdlbnRhOiBbIDEzOSwgMCwgMTM5IF0sXHJcbiAgICBkYXJrb2xpdmVncmVlbjogWyA4NSwgMTA3LCA0NyBdLFxyXG4gICAgZGFya29yYW5nZTogWyAyNTUsIDE0MCwgMCBdLFxyXG4gICAgZGFya29yY2hpZDogWyAxNTMsIDUwLCAyMDQgXSxcclxuICAgIGRhcmtyZWQ6IFsgMTM5LCAwLCAwIF0sXHJcbiAgICBkYXJrc2FsbW9uOiBbIDIzMywgMTUwLCAxMjIgXSxcclxuICAgIGRhcmtzZWFncmVlbjogWyAxNDMsIDE4OCwgMTQzIF0sXHJcbiAgICBkYXJrc2xhdGVibHVlOiBbIDcyLCA2MSwgMTM5IF0sXHJcbiAgICBkYXJrc2xhdGVncmF5OiBbIDQ3LCA3OSwgNzkgXSxcclxuICAgIGRhcmtzbGF0ZWdyZXk6IFsgNDcsIDc5LCA3OSBdLFxyXG4gICAgZGFya3R1cnF1b2lzZTogWyAwLCAyMDYsIDIwOSBdLFxyXG4gICAgZGFya3Zpb2xldDogWyAxNDgsIDAsIDIxMSBdLFxyXG4gICAgZGVlcHBpbms6IFsgMjU1LCAyMCwgMTQ3IF0sXHJcbiAgICBkZWVwc2t5Ymx1ZTogWyAwLCAxOTEsIDI1NSBdLFxyXG4gICAgZGltZ3JheTogWyAxMDUsIDEwNSwgMTA1IF0sXHJcbiAgICBkaW1ncmV5OiBbIDEwNSwgMTA1LCAxMDUgXSxcclxuICAgIGRvZGdlcmJsdWU6IFsgMzAsIDE0NCwgMjU1IF0sXHJcbiAgICBmaXJlYnJpY2s6IFsgMTc4LCAzNCwgMzQgXSxcclxuICAgIGZsb3JhbHdoaXRlOiBbIDI1NSwgMjUwLCAyNDAgXSxcclxuICAgIGZvcmVzdGdyZWVuOiBbIDM0LCAxMzksIDM0IF0sXHJcbiAgICBmdWNoc2lhOiBbIDI1NSwgMCwgMjU1IF0sXHJcbiAgICBnYWluc2Jvcm86IFsgMjIwLCAyMjAsIDIyMCBdLFxyXG4gICAgZ2hvc3R3aGl0ZTogWyAyNDgsIDI0OCwgMjU1IF0sXHJcbiAgICBnb2xkOiBbIDI1NSwgMjE1LCAwIF0sXHJcbiAgICBnb2xkZW5yb2Q6IFsgMjE4LCAxNjUsIDMyIF0sXHJcbiAgICBncmF5OiBbIDEyOCwgMTI4LCAxMjggXSxcclxuICAgIGdyZWVuOiBbIDAsIDEyOCwgMCBdLFxyXG4gICAgZ3JlZW55ZWxsb3c6IFsgMTczLCAyNTUsIDQ3IF0sXHJcbiAgICBncmV5OiBbIDEyOCwgMTI4LCAxMjggXSxcclxuICAgIGhvbmV5ZGV3OiBbIDI0MCwgMjU1LCAyNDAgXSxcclxuICAgIGhvdHBpbms6IFsgMjU1LCAxMDUsIDE4MCBdLFxyXG4gICAgaW5kaWFucmVkOiBbIDIwNSwgOTIsIDkyIF0sXHJcbiAgICBpbmRpZ286IFsgNzUsIDAsIDEzMCBdLFxyXG4gICAgaXZvcnk6IFsgMjU1LCAyNTUsIDI0MCBdLFxyXG4gICAga2hha2k6IFsgMjQwLCAyMzAsIDE0MCBdLFxyXG4gICAgbGF2ZW5kZXI6IFsgMjMwLCAyMzAsIDI1MCBdLFxyXG4gICAgbGF2ZW5kZXJibHVzaDogWyAyNTUsIDI0MCwgMjQ1IF0sXHJcbiAgICBsYXduZ3JlZW46IFsgMTI0LCAyNTIsIDAgXSxcclxuICAgIGxlbW9uY2hpZmZvbjogWyAyNTUsIDI1MCwgMjA1IF0sXHJcbiAgICBsaWdodGJsdWU6IFsgMTczLCAyMTYsIDIzMCBdLFxyXG4gICAgbGlnaHRjb3JhbDogWyAyNDAsIDEyOCwgMTI4IF0sXHJcbiAgICBsaWdodGN5YW46IFsgMjI0LCAyNTUsIDI1NSBdLFxyXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsgMjUwLCAyNTAsIDIxMCBdLFxyXG4gICAgbGlnaHRncmF5OiBbIDIxMSwgMjExLCAyMTEgXSxcclxuICAgIGxpZ2h0Z3JlZW46IFsgMTQ0LCAyMzgsIDE0NCBdLFxyXG4gICAgbGlnaHRncmV5OiBbIDIxMSwgMjExLCAyMTEgXSxcclxuICAgIGxpZ2h0cGluazogWyAyNTUsIDE4MiwgMTkzIF0sXHJcbiAgICBsaWdodHNhbG1vbjogWyAyNTUsIDE2MCwgMTIyIF0sXHJcbiAgICBsaWdodHNlYWdyZWVuOiBbIDMyLCAxNzgsIDE3MCBdLFxyXG4gICAgbGlnaHRza3libHVlOiBbIDEzNSwgMjA2LCAyNTAgXSxcclxuICAgIGxpZ2h0c2xhdGVncmF5OiBbIDExOSwgMTM2LCAxNTMgXSxcclxuICAgIGxpZ2h0c2xhdGVncmV5OiBbIDExOSwgMTM2LCAxNTMgXSxcclxuICAgIGxpZ2h0c3RlZWxibHVlOiBbIDE3NiwgMTk2LCAyMjIgXSxcclxuICAgIGxpZ2h0eWVsbG93OiBbIDI1NSwgMjU1LCAyMjQgXSxcclxuICAgIGxpbWU6IFsgMCwgMjU1LCAwIF0sXHJcbiAgICBsaW1lZ3JlZW46IFsgNTAsIDIwNSwgNTAgXSxcclxuICAgIGxpbmVuOiBbIDI1MCwgMjQwLCAyMzAgXSxcclxuICAgIG1hcm9vbjogWyAxMjgsIDAsIDAgXSxcclxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFsgMTAyLCAyMDUsIDE3MCBdLFxyXG4gICAgbWVkaXVtYmx1ZTogWyAwLCAwLCAyMDUgXSxcclxuICAgIG1lZGl1bW9yY2hpZDogWyAxODYsIDg1LCAyMTEgXSxcclxuICAgIG1lZGl1bXB1cnBsZTogWyAxNDcsIDExMiwgMjE5IF0sXHJcbiAgICBtZWRpdW1zZWFncmVlbjogWyA2MCwgMTc5LCAxMTMgXSxcclxuICAgIG1lZGl1bXNsYXRlYmx1ZTogWyAxMjMsIDEwNCwgMjM4IF0sXHJcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogWyAwLCAyNTAsIDE1NCBdLFxyXG4gICAgbWVkaXVtdHVycXVvaXNlOiBbIDcyLCAyMDksIDIwNCBdLFxyXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBbIDE5OSwgMjEsIDEzMyBdLFxyXG4gICAgbWlkbmlnaHRibHVlOiBbIDI1LCAyNSwgMTEyIF0sXHJcbiAgICBtaW50Y3JlYW06IFsgMjQ1LCAyNTUsIDI1MCBdLFxyXG4gICAgbWlzdHlyb3NlOiBbIDI1NSwgMjI4LCAyMjUgXSxcclxuICAgIG1vY2Nhc2luOiBbIDI1NSwgMjI4LCAxODEgXSxcclxuICAgIG5hdmFqb3doaXRlOiBbIDI1NSwgMjIyLCAxNzMgXSxcclxuICAgIG5hdnk6IFsgMCwgMCwgMTI4IF0sXHJcbiAgICBvbGRsYWNlOiBbIDI1MywgMjQ1LCAyMzAgXSxcclxuICAgIG9saXZlOiBbIDEyOCwgMTI4LCAwIF0sXHJcbiAgICBvbGl2ZWRyYWI6IFsgMTA3LCAxNDIsIDM1IF0sXHJcbiAgICBvcmFuZ2U6IFsgMjU1LCAxNjUsIDAgXSxcclxuICAgIG9yYW5nZXJlZDogWyAyNTUsIDY5LCAwIF0sXHJcbiAgICBvcmNoaWQ6IFsgMjE4LCAxMTIsIDIxNCBdLFxyXG4gICAgcGFsZWdvbGRlbnJvZDogWyAyMzgsIDIzMiwgMTcwIF0sXHJcbiAgICBwYWxlZ3JlZW46IFsgMTUyLCAyNTEsIDE1MiBdLFxyXG4gICAgcGFsZXR1cnF1b2lzZTogWyAxNzUsIDIzOCwgMjM4IF0sXHJcbiAgICBwYWxldmlvbGV0cmVkOiBbIDIxOSwgMTEyLCAxNDcgXSxcclxuICAgIHBhcGF5YXdoaXA6IFsgMjU1LCAyMzksIDIxMyBdLFxyXG4gICAgcGVhY2hwdWZmOiBbIDI1NSwgMjE4LCAxODUgXSxcclxuICAgIHBlcnU6IFsgMjA1LCAxMzMsIDYzIF0sXHJcbiAgICBwaW5rOiBbIDI1NSwgMTkyLCAyMDMgXSxcclxuICAgIHBsdW06IFsgMjIxLCAxNjAsIDIyMSBdLFxyXG4gICAgcG93ZGVyYmx1ZTogWyAxNzYsIDIyNCwgMjMwIF0sXHJcbiAgICBwdXJwbGU6IFsgMTI4LCAwLCAxMjggXSxcclxuICAgIHJlYmVjY2FwdXJwbGU6IFsgMTAyLCA1MSwgMTUzIF0sXHJcbiAgICByZWQ6IFsgMjU1LCAwLCAwIF0sXHJcbiAgICByb3N5YnJvd246IFsgMTg4LCAxNDMsIDE0MyBdLFxyXG4gICAgcm95YWxibHVlOiBbIDY1LCAxMDUsIDIyNSBdLFxyXG4gICAgc2FkZGxlYnJvd246IFsgMTM5LCA2OSwgMTkgXSxcclxuICAgIHNhbG1vbjogWyAyNTAsIDEyOCwgMTE0IF0sXHJcbiAgICBzYW5keWJyb3duOiBbIDI0NCwgMTY0LCA5NiBdLFxyXG4gICAgc2VhZ3JlZW46IFsgNDYsIDEzOSwgODcgXSxcclxuICAgIHNlYXNoZWxsOiBbIDI1NSwgMjQ1LCAyMzggXSxcclxuICAgIHNpZW5uYTogWyAxNjAsIDgyLCA0NSBdLFxyXG4gICAgc2lsdmVyOiBbIDE5MiwgMTkyLCAxMjkgXSxcclxuICAgIHNreWJsdWU6IFsgMTM1LCAyMDYsIDIzNSBdLFxyXG4gICAgc2xhdGVibHVlOiBbIDEwNiwgOTAsIDIwNSBdLFxyXG4gICAgc2xhdGVncmF5OiBbIDExMiwgMTI4LCAxNDQgXSxcclxuICAgIHNsYXRlZ3JleTogWyAxMTIsIDEyOCwgMTQ0IF0sXHJcbiAgICBzbm93OiBbIDI1NSwgMjUwLCAyNTAgXSxcclxuICAgIHNwcmluZ2dyZWVuOiBbIDAsIDI1NSwgMTI3IF0sXHJcbiAgICBzdGVlbGJsdWU6IFsgNzAsIDEzMCwgMTgwIF0sXHJcbiAgICB0YW46IFsgMjEwLCAxODAsIDE0MCBdLFxyXG4gICAgdGVhbDogWyAwLCAxMjgsIDEyOCBdLFxyXG4gICAgdGhpc3RsZTogWyAyMTYsIDE5MSwgMjE2IF0sXHJcbiAgICB0b21hdG86IFsgMjU1LCA5OSwgNzEgXSxcclxuICAgIHR1cnF1b2lzZTogWyA2NCwgMjI0LCAyMDggXSxcclxuICAgIHZpb2xldDogWyAyMzgsIDEzMCwgMjM4IF0sXHJcbiAgICB3aGVhdDogWyAyNDUsIDIyMiwgMTc5IF0sXHJcbiAgICB3aGl0ZTogWyAyNTUsIDI1NSwgMjU1IF0sXHJcbiAgICB3aGl0ZXNtb2tlOiBbIDI0NSwgMjQ1LCAyNDUgXSxcclxuICAgIHllbGxvdzogWyAyNTUsIDI1NSwgMCBdLFxyXG4gICAgeWVsbG93Z3JlZW46IFsgMTU0LCAyMDUsIDUwIF1cclxufTtcclxuXHJcbnZhciBDU1NUb0NvbG9yID0gZnVuY3Rpb24gKG5hbWUpXHJcbntcclxuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgdmFyIGNvbG9yID0gbmV3IENvbG9yKCk7XHJcbiAgICB2YXIgZW50cnkgPSBDU1NNYXBbbmFtZV07XHJcblxyXG4gICAgaWYgKGVudHJ5KVxyXG4gICAge1xyXG4gICAgICAgIGNvbG9yLnNldFRvKGVudHJ5WzBdLCBlbnRyeVsxXSwgZW50cnlbMl0sIDI1NSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbG9yO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDU1NUb0NvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL0NTU1RvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDY5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29sb3JUb1JHQkEgPSBmdW5jdGlvbiAoY29sb3IpXHJcbntcclxuICAgIHZhciBvdXRwdXQgPSB7XHJcbiAgICAgICAgcjogY29sb3IgPj4gMTYgJiAweEZGLFxyXG4gICAgICAgIGc6IGNvbG9yID4+IDggJiAweEZGLFxyXG4gICAgICAgIGI6IGNvbG9yICYgMHhGRixcclxuICAgICAgICBhOiAyNTVcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGNvbG9yID4gMTY3NzcyMTUpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LmEgPSBjb2xvciA+Pj4gMjQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29sb3JUb1JHQkE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvQ29sb3JUb1JHQkEuanNcbi8vIG1vZHVsZSBpZCA9IDY5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29sb3IgPSByZXF1aXJlKCcuL0NvbG9yJyk7XHJcbnZhciBIdWVUb0NvbXBvbmVudCA9IHJlcXVpcmUoJy4vSHVlVG9Db21wb25lbnQnKTtcclxuXHJcbnZhciBIU0xUb0NvbG9yID0gZnVuY3Rpb24gKGgsIHMsIGwpXHJcbntcclxuICAgIC8vIGFjaHJvbWF0aWMgYnkgZGVmYXVsdFxyXG4gICAgdmFyIHIgPSBsO1xyXG4gICAgdmFyIGcgPSBsO1xyXG4gICAgdmFyIGIgPSBsO1xyXG5cclxuICAgIGlmIChzICE9PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBxID0gKGwgPCAwLjUpID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xyXG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xyXG5cclxuICAgICAgICByID0gSHVlVG9Db21wb25lbnQocCwgcSwgaCArIDEgLyAzKTtcclxuICAgICAgICBnID0gSHVlVG9Db21wb25lbnQocCwgcSwgaCk7XHJcbiAgICAgICAgYiA9IEh1ZVRvQ29tcG9uZW50KHAsIHEsIGggLSAxIC8gMyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbG9yID0gbmV3IENvbG9yKCk7XHJcblxyXG4gICAgcmV0dXJuIGNvbG9yLnNldEdMVG8ociwgZywgYiwgMSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhTTFRvQ29sb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvSFNMVG9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gNjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBIU1ZUb1JHQiA9IHJlcXVpcmUoJy4vSFNWVG9SR0InKTtcclxuXHJcbi8qKlxyXG4qIEdldCBIU1YgY29sb3Igd2hlZWwgdmFsdWVzIGluIGFuIGFycmF5IHdoaWNoIHdpbGwgYmUgMzYwIGVsZW1lbnRzIGluIHNpemUuXHJcbiovXHJcbnZhciBIU1ZDb2xvcldoZWVsID0gZnVuY3Rpb24gKHMsIHYpXHJcbntcclxuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHsgcyA9IDE7IH1cclxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHsgdiA9IDE7IH1cclxuXHJcbiAgICB2YXIgY29sb3JzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPD0gMzU5OyBjKyspXHJcbiAgICB7XHJcbiAgICAgICAgY29sb3JzLnB1c2goSFNWVG9SR0IoYyAvIDM1OSwgcywgdikpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb2xvcnM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhTVkNvbG9yV2hlZWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvSFNWQ29sb3JXaGVlbC5qc1xuLy8gbW9kdWxlIGlkID0gNjk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaW5lYXIgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2ludGVycG9sYXRpb24vTGluZWFySW50ZXJwb2xhdGlvbicpO1xyXG5cclxudmFyIFJHQldpdGhSR0IgPSBmdW5jdGlvbiAocjEsIGcxLCBiMSwgcjIsIGcyLCBiMiwgbGVuZ3RoLCBpbmRleClcclxue1xyXG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IDEwMDsgfVxyXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XHJcblxyXG4gICAgdmFyIHQgPSBpbmRleCAvIGxlbmd0aDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHI6IExpbmVhcihyMSwgcjIsIHQpLFxyXG4gICAgICAgIGc6IExpbmVhcihnMSwgZzIsIHQpLFxyXG4gICAgICAgIGI6IExpbmVhcihiMSwgYjIsIHQpXHJcbiAgICB9O1xyXG59O1xyXG5cclxudmFyIENvbG9yV2l0aENvbG9yID0gZnVuY3Rpb24gKGNvbG9yMSwgY29sb3IyLCBsZW5ndGgsIGluZGV4KVxyXG57XHJcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsgbGVuZ3RoID0gMTAwOyB9XHJcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IDA7IH1cclxuXHJcbiAgICByZXR1cm4gUkdCV2l0aFJHQihjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iLCBjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iLCBsZW5ndGgsIGluZGV4KTtcclxufTtcclxuXHJcbnZhciBDb2xvcldpdGhSR0IgPSBmdW5jdGlvbiAoY29sb3IsIHIsIGcsIGIsIGxlbmd0aCwgaW5kZXgpXHJcbntcclxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSAxMDA7IH1cclxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gMDsgfVxyXG5cclxuICAgIHJldHVybiBSR0JXaXRoUkdCKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIHIsIGcsIGIsIGxlbmd0aCwgaW5kZXgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgUkdCV2l0aFJHQjogUkdCV2l0aFJHQixcclxuICAgIENvbG9yV2l0aFJHQjogQ29sb3JXaXRoUkdCLFxyXG4gICAgQ29sb3JXaXRoQ29sb3I6IENvbG9yV2l0aENvbG9yXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL0ludGVycG9sYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA2OTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTViAoaHVlLCBzYXR1cmF0aW9uIGFuZCB2YWx1ZSkuXHJcbiogQ29udmVyc2lvbiBmb3J1bWxhIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXHJcbiogQXNzdW1lcyBSR0IgdmFsdWVzIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBhbmQgcmV0dXJucyBoLCBzIGFuZCB2IGluIHRoZSBzZXQgWzAsIDFdLlxyXG4qIEJhc2VkIG9uIGNvZGUgYnkgTWljaGFlbCBKYWNrc29uIChodHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbilcclxuKi9cclxudmFyIFJHQlRvSFNWID0gZnVuY3Rpb24gKHIsIGcsIGIpXHJcbntcclxuICAgIHIgLz0gMjU1O1xyXG4gICAgZyAvPSAyNTU7XHJcbiAgICBiIC89IDI1NTtcclxuXHJcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XHJcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XHJcbiAgICB2YXIgZCA9IG1heCAtIG1pbjtcclxuXHJcbiAgICAvLyBhY2hyb21hdGljIGJ5IGRlZmF1bHRcclxuICAgIHZhciBoID0gMDtcclxuICAgIHZhciBzID0gKG1heCA9PT0gMCkgPyAwIDogZCAvIG1heDtcclxuICAgIHZhciB2ID0gbWF4O1xyXG5cclxuICAgIGlmIChtYXggIT09IG1pbilcclxuICAgIHtcclxuICAgICAgICBpZiAobWF4ID09PSByKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKChnIDwgYikgPyA2IDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1heCA9PT0gZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1heCA9PT0gYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBoIC89IDY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgaDogaCwgczogcywgdjogdiB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSR0JUb0hTVjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9jb2xvci9SR0JUb0hTVi5qc1xuLy8gbW9kdWxlIGlkID0gNjk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb21wb25lbnRUb0hleCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50VG9IZXgnKTtcclxuXHJcbnZhciBSR0JUb1N0cmluZyA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhLCBwcmVmaXgpXHJcbntcclxuICAgIGlmIChhID09PSB1bmRlZmluZWQpIHsgYSA9IDI1NTsgfVxyXG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7IHByZWZpeCA9ICcjJzsgfVxyXG5cclxuICAgIGlmIChwcmVmaXggPT09ICcjJylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gJyMnICsgKCgxIDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAnMHgnICsgQ29tcG9uZW50VG9IZXgoYSkgKyBDb21wb25lbnRUb0hleChyKSArIENvbXBvbmVudFRvSGV4KGcpICsgQ29tcG9uZW50VG9IZXgoYik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJHQlRvU3RyaW5nO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL1JHQlRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA2OThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW4gPSByZXF1aXJlKCcuLi8uLi9tYXRoL0JldHdlZW4nKTtcclxuXHJcbnZhciBSYW5kb21SR0IgPSBmdW5jdGlvbiAobWluLCBtYXgpXHJcbntcclxuICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkgeyBtaW4gPSAwOyB9XHJcbiAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHsgbWF4ID0gMjU1OyB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByOiBCZXR3ZWVuKG1pbiwgbWF4KSxcclxuICAgICAgICBnOiBCZXR3ZWVuKG1pbiwgbWF4KSxcclxuICAgICAgICBiOiBCZXR3ZWVuKG1pbiwgbWF4KVxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tUkdCO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL1JhbmRvbVJHQi5qc1xuLy8gbW9kdWxlIGlkID0gNjk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR3JhcGhpY3MuQ29sb3JcclxuXHJcbnZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3InKTtcclxuXHJcbkNvbG9yLkNvbG9yVG9SR0JBID0gcmVxdWlyZSgnLi9Db2xvclRvUkdCQScpO1xyXG5Db2xvci5Db21wb25lbnRUb0hleCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50VG9IZXgnKTtcclxuQ29sb3IuQ1NTVG9Db2xvciA9IHJlcXVpcmUoJy4vQ1NTVG9Db2xvcicpO1xyXG5Db2xvci5HZXRDb2xvciA9IHJlcXVpcmUoJy4vR2V0Q29sb3InKTtcclxuQ29sb3IuR2V0Q29sb3IzMiA9IHJlcXVpcmUoJy4vR2V0Q29sb3IzMicpO1xyXG5Db2xvci5IZXhTdHJpbmdUb0NvbG9yID0gcmVxdWlyZSgnLi9IZXhTdHJpbmdUb0NvbG9yJyk7XHJcbkNvbG9yLkhTTFRvQ29sb3IgPSByZXF1aXJlKCcuL0hTTFRvQ29sb3InKTtcclxuQ29sb3IuSFNWQ29sb3JXaGVlbCA9IHJlcXVpcmUoJy4vSFNWQ29sb3JXaGVlbCcpO1xyXG5Db2xvci5IU1ZUb1JHQiA9IHJlcXVpcmUoJy4vSFNWVG9SR0InKTtcclxuQ29sb3IuSHVlVG9Db21wb25lbnQgPSByZXF1aXJlKCcuL0h1ZVRvQ29tcG9uZW50Jyk7XHJcbkNvbG9yLkludGVnZXJUb0NvbG9yID0gcmVxdWlyZSgnLi9JbnRlZ2VyVG9Db2xvcicpO1xyXG5Db2xvci5JbnRlZ2VyVG9SR0IgPSByZXF1aXJlKCcuL0ludGVnZXJUb1JHQicpO1xyXG5Db2xvci5JbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vSW50ZXJwb2xhdGUnKTtcclxuQ29sb3IuUmFuZG9tUkdCID0gcmVxdWlyZSgnLi9SYW5kb21SR0InKTtcclxuQ29sb3IuUkdCU3RyaW5nVG9Db2xvciA9IHJlcXVpcmUoJy4vUkdCU3RyaW5nVG9Db2xvcicpO1xyXG5Db2xvci5SR0JUb0hTViA9IHJlcXVpcmUoJy4vUkdCVG9IU1YnKTtcclxuQ29sb3IuUkdCVG9TdHJpbmcgPSByZXF1aXJlKCcuL1JHQlRvU3RyaW5nJyk7XHJcbkNvbG9yLlZhbHVlVG9Db2xvciA9IHJlcXVpcmUoJy4vVmFsdWVUb0NvbG9yJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3MDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5JbnB1dC5Qb2ludGVyXHJcblxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG5cclxuLy8gIERPTSBldmVudCBidXR0b24gdmFsdWU6XHJcbi8vIEEgbnVtYmVyIHJlcHJlc2VudGluZyBhIGdpdmVuIGJ1dHRvbjpcclxuLy8gMDogTWFpbiBidXR0b24gcHJlc3NlZCwgdXN1YWxseSB0aGUgbGVmdCBidXR0b24gb3IgdGhlIHVuLWluaXRpYWxpemVkIHN0YXRlXHJcbi8vIDE6IEF1eGlsaWFyeSBidXR0b24gcHJlc3NlZCwgdXN1YWxseSB0aGUgd2hlZWwgYnV0dG9uIG9yIHRoZSBtaWRkbGUgYnV0dG9uIChpZiBwcmVzZW50KVxyXG4vLyAyOiBTZWNvbmRhcnkgYnV0dG9uIHByZXNzZWQsIHVzdWFsbHkgdGhlIHJpZ2h0IGJ1dHRvblxyXG4vLyAzOiBGb3VydGggYnV0dG9uLCB0eXBpY2FsbHkgdGhlIEJyb3dzZXIgQmFjayBidXR0b25cclxuLy8gNDogRmlmdGggYnV0dG9uLCB0eXBpY2FsbHkgdGhlIEJyb3dzZXIgRm9yd2FyZCBidXR0b25cclxuLy8gRm9yIGEgbW91c2UgY29uZmlndXJlZCBmb3IgbGVmdC1oYW5kZWQgdXNlLCB0aGUgYnV0dG9uIGFjdGlvbnMgYXJlIHJldmVyc2VkLiBJbiB0aGlzIGNhc2UsIHRoZSB2YWx1ZXMgYXJlIHJlYWQgZnJvbSByaWdodCB0byBsZWZ0LlxyXG5cclxudmFyIFBvaW50ZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gUG9pbnRlciAobWFuYWdlciwgaWQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50O1xyXG5cclxuICAgICAgICAvLyAgVGhlIGNhbWVyYSB0aGUgUG9pbnRlciBpbnRlcmFjdGVkIHdpdGggZHVyaW5nIGl0cyBsYXN0IHVwZGF0ZVxyXG4gICAgICAgIC8vICBBIFBvaW50ZXIgY2FuIG9ubHkgZXZlciBpbnRlcmFjdCB3aXRoIDEgY2FtZXJhIGF0IG9uY2UsIHdoaWNoIHdpbGwgYmUgdGhlIHRvcC1tb3N0IGNhbWVyYVxyXG4gICAgICAgIC8vICBpbiB0aGUgbGlzdCBzaG91bGQgbXVsdGlwbGUgY2FtZXJhcyBiZSBwb3NpdGlvbmVkIG9uLXRvcCBvZiBlYWNoIG90aGVyLlxyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gMCAgOiBObyBidXR0b24gb3IgdW4taW5pdGlhbGl6ZWRcclxuICAgICAgICAvLyAxICA6IExlZnQgYnV0dG9uXHJcbiAgICAgICAgLy8gMiAgOiBSaWdodCBidXR0b25cclxuICAgICAgICAvLyA0ICA6IFdoZWVsIGJ1dHRvbiBvciBtaWRkbGUgYnV0dG9uXHJcbiAgICAgICAgLy8gOCAgOiA0dGggYnV0dG9uICh0eXBpY2FsbHkgdGhlIFwiQnJvd3NlciBCYWNrXCIgYnV0dG9uKVxyXG4gICAgICAgIC8vIDE2IDogNXRoIGJ1dHRvbiAodHlwaWNhbGx5IHRoZSBcIkJyb3dzZXIgRm9yd2FyZFwiIGJ1dHRvbilcclxuICAgICAgICB0aGlzLmJ1dHRvbnMgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgIHRoaXMueSA9IDA7XHJcblxyXG4gICAgICAgIC8vICBDb29yZGluYXRlcyBhbmQgdGltZSBvZiB0aGUgcG9pbnRlciB3aGVuIEJ1dHRvbiAxIChsZWZ0IGJ1dHRvbiksIG9yIFRvdWNoLCB3YXMgcHJlc3NlZCwgdXNlZCBmb3IgZHJhZ2dpbmcgb2JqZWN0c1xyXG4gICAgICAgIHRoaXMuZG93blggPSAwO1xyXG4gICAgICAgIHRoaXMuZG93blkgPSAwO1xyXG4gICAgICAgIHRoaXMuZG93blRpbWUgPSAwO1xyXG5cclxuICAgICAgICAvLyAgQ29vcmRpbmF0ZXMgYW5kIHRpbWUgb2YgdGhlIHBvaW50ZXIgd2hlbiBCdXR0b24gMSAobGVmdCBidXR0b24pLCBvciBUb3VjaCwgd2FzIHJlbGVhc2VkLCB1c2VkIGZvciBkcmFnZ2luZyBvYmplY3RzXHJcbiAgICAgICAgdGhpcy51cFggPSAwO1xyXG4gICAgICAgIHRoaXMudXBZID0gMDtcclxuICAgICAgICB0aGlzLnVwVGltZSA9IDA7XHJcblxyXG4gICAgICAgIC8vICBJcyB0aGUgcHJpbWFyeSBidXR0b24gZG93bj8gKHVzdWFsbHkgYnV0dG9uIDAsIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbilcclxuICAgICAgICB0aGlzLnByaW1hcnlEb3duID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vICAwID0gTm90IGRyYWdnaW5nIGFueXRoaW5nXHJcbiAgICAgICAgLy8gIDEgPSBCZWluZyBjaGVja2VkIGlmIGRyYWdnaW5nXHJcbiAgICAgICAgLy8gIDIgPSBEcmFnZ2luZyBzb21ldGhpbmdcclxuICAgICAgICB0aGlzLmRyYWdTdGF0ZSA9IDA7XHJcblxyXG4gICAgICAgIC8vICBJcyAqYW55KiBidXR0b24gb24gdGhpcyBwb2ludGVyIGNvbnNpZGVyZWQgYXMgYmVpbmcgZG93bj9cclxuICAgICAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuanVzdERvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmp1c3RVcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuanVzdE1vdmVkID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYnV0dG9ucyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuanVzdERvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmp1c3RVcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuanVzdE1vdmVkID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50LCB0aW1lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gdGhpcy5tYW5hZ2VyLnRyYW5zZm9ybVgoZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVgpO1xyXG4gICAgICAgIHRoaXMueSA9IHRoaXMubWFuYWdlci50cmFuc2Zvcm1ZKGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZKTtcclxuXHJcbiAgICAgICAgdGhpcy5qdXN0TW92ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZTogZnVuY3Rpb24gKGV2ZW50LCB0aW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChldmVudC5idXR0b25zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25zID0gZXZlbnQuYnV0dG9ucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gdGhpcy5tYW5hZ2VyLnRyYW5zZm9ybVgoZXZlbnQucGFnZVgpO1xyXG4gICAgICAgIHRoaXMueSA9IHRoaXMubWFuYWdlci50cmFuc2Zvcm1ZKGV2ZW50LnBhZ2VZKTtcclxuXHJcbiAgICAgICAgdGhpcy5qdXN0TW92ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgZG93bjogZnVuY3Rpb24gKGV2ZW50LCB0aW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChldmVudC5idXR0b25zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25zID0gZXZlbnQuYnV0dG9ucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gdGhpcy5tYW5hZ2VyLnRyYW5zZm9ybVgoZXZlbnQucGFnZVgpO1xyXG4gICAgICAgIHRoaXMueSA9IHRoaXMubWFuYWdlci50cmFuc2Zvcm1ZKGV2ZW50LnBhZ2VZKTtcclxuXHJcbiAgICAgICAgLy8gIDA6IE1haW4gYnV0dG9uIHByZXNzZWQsIHVzdWFsbHkgdGhlIGxlZnQgYnV0dG9uIG9yIHRoZSB1bi1pbml0aWFsaXplZCBzdGF0ZVxyXG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnByaW1hcnlEb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5kb3duWCA9IHRoaXMueDtcclxuICAgICAgICAgICAgdGhpcy5kb3duWSA9IHRoaXMueTtcclxuICAgICAgICAgICAgdGhpcy5kb3duVGltZSA9IHRpbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmp1c3REb3duID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzRG93biA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQsIHRpbWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5idXR0b25zID0gMTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG5cclxuICAgICAgICB0aGlzLnggPSB0aGlzLm1hbmFnZXIudHJhbnNmb3JtWChldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCk7XHJcbiAgICAgICAgdGhpcy55ID0gdGhpcy5tYW5hZ2VyLnRyYW5zZm9ybVkoZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkpO1xyXG5cclxuICAgICAgICB0aGlzLnByaW1hcnlEb3duID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRvd25YID0gdGhpcy54O1xyXG4gICAgICAgIHRoaXMuZG93blkgPSB0aGlzLnk7XHJcbiAgICAgICAgdGhpcy5kb3duVGltZSA9IHRpbWU7XHJcblxyXG4gICAgICAgIHRoaXMuanVzdERvd24gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaXNEb3duID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwOiBmdW5jdGlvbiAoZXZlbnQsIHRpbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMgPSBldmVudC5idXR0b25zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG5cclxuICAgICAgICB0aGlzLnggPSB0aGlzLm1hbmFnZXIudHJhbnNmb3JtWChldmVudC5wYWdlWCk7XHJcbiAgICAgICAgdGhpcy55ID0gdGhpcy5tYW5hZ2VyLnRyYW5zZm9ybVkoZXZlbnQucGFnZVkpO1xyXG5cclxuICAgICAgICAvLyAgMDogTWFpbiBidXR0b24gcHJlc3NlZCwgdXN1YWxseSB0aGUgbGVmdCBidXR0b24gb3IgdGhlIHVuLWluaXRpYWxpemVkIHN0YXRlXHJcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeURvd24gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy51cFggPSB0aGlzLng7XHJcbiAgICAgICAgICAgIHRoaXMudXBZID0gdGhpcy55O1xyXG4gICAgICAgICAgICB0aGlzLnVwVGltZSA9IHRpbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmp1c3RVcCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQsIHRpbWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5idXR0b25zID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG5cclxuICAgICAgICB0aGlzLnggPSB0aGlzLm1hbmFnZXIudHJhbnNmb3JtWChldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCk7XHJcbiAgICAgICAgdGhpcy55ID0gdGhpcy5tYW5hZ2VyLnRyYW5zZm9ybVkoZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkpO1xyXG5cclxuICAgICAgICB0aGlzLnByaW1hcnlEb3duID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy51cFggPSB0aGlzLng7XHJcbiAgICAgICAgdGhpcy51cFkgPSB0aGlzLnk7XHJcbiAgICAgICAgdGhpcy51cFRpbWUgPSB0aW1lO1xyXG5cclxuICAgICAgICB0aGlzLmp1c3RVcCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIG5vQnV0dG9uRG93bjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuYnV0dG9ucyA9PT0gMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGxlZnRCdXR0b25Eb3duOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5idXR0b25zICYgMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJpZ2h0QnV0dG9uRG93bjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuYnV0dG9ucyAmIDIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtaWRkbGVCdXR0b25Eb3duOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5idXR0b25zICYgNCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJhY2tCdXR0b25Eb3duOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5idXR0b25zICYgOCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZvcndhcmRCdXR0b25Eb3duOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5idXR0b25zICYgMTYpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvUG9pbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUYXRhciBTTkVTIFVTQiBDb250cm9sbGVyXHJcbi8vICBVU0IgR2FtZXBhZCAgKFNUQU5EQVJEIEdBTUVQQUQgVmVuZG9yOiAwMDc5IFByb2R1Y3Q6IDAwMTEpXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBVUDogMTIsXHJcbiAgICBET1dOOiAxMyxcclxuICAgIExFRlQ6IDE0LFxyXG4gICAgUklHSFQ6IDE1LFxyXG5cclxuICAgIFNFTEVDVDogOCxcclxuICAgIFNUQVJUOiA5LFxyXG5cclxuICAgIEI6IDAsXHJcbiAgICBBOiAxLFxyXG4gICAgWTogMixcclxuICAgIFg6IDMsXHJcblxyXG4gICAgTEVGVF9TSE9VTERFUjogNCxcclxuICAgIFJJR0hUX1NIT1VMREVSOiA1XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2dhbWVwYWQvY29uZmlncy9TTkVTX1VTQl9Db250cm9sbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFNvbnkgUGxheVN0YXRpb24gRHVhbFNob2NrIDQgKHYyKSB3aXJlbGVzcyBjb250cm9sbGVyXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBVUDogMTIsXHJcbiAgICBET1dOOiAxMyxcclxuICAgIExFRlQ6IDE0LFxyXG4gICAgUklHSFQ6IDE1LFxyXG5cclxuICAgIFNIQVJFOiA4LFxyXG4gICAgT1BUSU9OUzogOSxcclxuICAgIFBTOiAxNixcclxuICAgIFRPVUNIQkFSOiAxNyxcclxuXHJcbiAgICBYOiAwLFxyXG4gICAgQ0lSQ0xFOiAxLFxyXG4gICAgU1FVQVJFOiAyLFxyXG4gICAgVFJJQU5HTEU6IDMsXHJcblxyXG4gICAgTDE6IDQsXHJcbiAgICBSMTogNSxcclxuICAgIEwyOiA2LFxyXG4gICAgUjI6IDcsXHJcbiAgICBMMzogMTAsXHJcbiAgICBSMzogMTEsXHJcblxyXG4gICAgTEVGVF9TVElDS19IOiAwLFxyXG4gICAgTEVGVF9TVElDS19WOiAxLFxyXG4gICAgUklHSFRfU1RJQ0tfSDogMixcclxuICAgIFJJR0hUX1NUSUNLX1Y6IDNcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvZ2FtZXBhZC9jb25maWdzL1NvbnlfUGxheVN0YXRpb25fRHVhbFNob2NrXzQuanNcbi8vIG1vZHVsZSBpZCA9IDcwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLklucHV0LkdhbWVwYWQuQ29uZmlnc1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgRFVBTFNIT0NLXzQ6IHJlcXVpcmUoJy4vU29ueV9QbGF5U3RhdGlvbl9EdWFsU2hvY2tfNCcpLFxyXG4gICAgU05FU19VU0I6IHJlcXVpcmUoJy4vU05FU19VU0JfQ29udHJvbGxlcicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2dhbWVwYWQvY29uZmlncy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIEdhbWVwYWRDb25uZWN0ZWRFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBHYW1lcGFkQ29ubmVjdGVkRXZlbnQgKGdhbWVwYWQsIG5hdGl2ZUV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ0dBTUVQQURfQ09OTkVDVEVEX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5hdGl2ZUV2ZW50O1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVwYWQgPSBnYW1lcGFkO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVwYWRDb25uZWN0ZWRFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9nYW1lcGFkL2V2ZW50cy9HYW1lcGFkQ29ubmVjdGVkRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDcwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBHYW1lcGFkRGlzY29ubmVjdGVkRXZlbnQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEV2ZW50LFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR2FtZXBhZERpc2Nvbm5lY3RlZEV2ZW50IChnYW1lcGFkLCBuYXRpdmVFdmVudClcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdHQU1FUEFEX0RJU0NPTk5FQ1RFRF9FVkVOVCcpO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEgPSBuYXRpdmVFdmVudDtcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lcGFkID0gZ2FtZXBhZDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lcGFkRGlzY29ubmVjdGVkRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvZ2FtZXBhZC9ldmVudHMvR2FtZXBhZERpc2Nvbm5lY3RlZEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3MDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgR2FtZXBhZERvd25FdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBHYW1lcGFkRG93bkV2ZW50IChnYW1lcGFkLCBidXR0b24sIHZhbHVlLCBuYXRpdmVFdmVudClcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdHQU1FUEFEX0RPV05fRVZFTlQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmF0aXZlRXZlbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZXBhZCA9IGdhbWVwYWQ7XHJcbiAgICAgICAgdGhpcy5idXR0b24gPSBidXR0b247XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVwYWREb3duRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvZ2FtZXBhZC9ldmVudHMvR2FtZXBhZERvd25FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIEdhbWVwYWRVcEV2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBFdmVudCxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEdhbWVwYWRVcEV2ZW50IChnYW1lcGFkLCBidXR0b24sIHZhbHVlLCBuYXRpdmVFdmVudClcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdHQU1FUEFEX1VQX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5hdGl2ZUV2ZW50O1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVwYWQgPSBnYW1lcGFkO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uID0gYnV0dG9uO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lcGFkVXBFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9nYW1lcGFkL2V2ZW50cy9HYW1lcGFkVXBFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuSW5wdXQuR2FtZXBhZFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQXhpczogcmVxdWlyZSgnLi9BeGlzJyksXHJcbiAgICBCdXR0b246IHJlcXVpcmUoJy4vQnV0dG9uJyksXHJcbiAgICBHYW1lcGFkOiByZXF1aXJlKCcuL0dhbWVwYWQnKSxcclxuICAgIEdhbWVwYWRNYW5hZ2VyOiByZXF1aXJlKCcuL0dhbWVwYWRNYW5hZ2VyJyksXHJcbiAgICBcclxuICAgIENvbmZpZ3M6IHJlcXVpcmUoJy4vY29uZmlncy8nKVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2dhbWVwYWQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDcwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLklucHV0Lkdsb2JhbElucHV0TWFuYWdlclxyXG5cclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxudmFyIEdhbWVwYWQgPSByZXF1aXJlKCcuLi9nYW1lcGFkL0dhbWVwYWRNYW5hZ2VyJyk7XHJcbnZhciBHZXRUcmFuc2Zvcm1lZFBvaW50ID0gcmVxdWlyZSgnLi9pbmMvR2V0VHJhbnNmb3JtZWRQb2ludCcpO1xyXG52YXIgSGl0VGVzdCA9IHJlcXVpcmUoJy4vaW5jL0hpdFRlc3QnKTtcclxudmFyIEtleWJvYXJkID0gcmVxdWlyZSgnLi4va2V5Ym9hcmQvS2V5Ym9hcmRNYW5hZ2VyJyk7XHJcbnZhciBNb3VzZSA9IHJlcXVpcmUoJy4uL21vdXNlL01vdXNlTWFuYWdlcicpO1xyXG52YXIgTW91c2VFdmVudCA9IHJlcXVpcmUoJy4uL21vdXNlL2V2ZW50cy8nKTtcclxudmFyIFBvaW50ZXIgPSByZXF1aXJlKCcuLi9Qb2ludGVyJyk7XHJcbnZhciBQb2ludFNjcmVlblRvV29ybGRIaXRUZXN0ID0gcmVxdWlyZSgnLi9pbmMvUG9pbnRTY3JlZW5Ub1dvcmxkSGl0VGVzdCcpO1xyXG52YXIgUG9pbnRXaXRoaW5HYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi9pbmMvUG9pbnRXaXRoaW5HYW1lT2JqZWN0Jyk7XHJcbnZhciBUb3VjaCA9IHJlcXVpcmUoJy4uL3RvdWNoL1RvdWNoTWFuYWdlcicpO1xyXG52YXIgVHJhbnNmb3JtTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXgnKTtcclxuXHJcbnZhciBHbG9iYWxJbnB1dE1hbmFnZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR2xvYmFsSW5wdXRNYW5hZ2VyIChnYW1lLCBjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICAgICAgdGhpcy5jYW52YXM7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG5cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICAgICAgLy8gICBTdGFuZGFyZCBGSUZPIHF1ZXVlXHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG5cclxuICAgICAgICAvLyAgTGlzdGVuZXJzICh3aWxsIGJlIGJhc2VkIG9uIGNvbmZpZylcclxuICAgICAgICB0aGlzLmtleWJvYXJkID0gbmV3IEtleWJvYXJkKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcyk7XHJcbiAgICAgICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaCh0aGlzKTtcclxuICAgICAgICB0aGlzLmdhbWVwYWQgPSBuZXcgR2FtZXBhZCh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5hY3RpdmVQb2ludGVyID0gbmV3IFBvaW50ZXIodGhpcywgMCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2NhbGUgPSB7IHg6IDEsIHk6IDEgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fdGVtcE1hdHJpeCA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKTtcclxuICAgICAgICB0aGlzLl90ZW1wUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICB0aGlzLl90ZW1wSGl0VGVzdCA9IFtdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIEJvb3QgaGFuZGxlciBpcyBjYWxsZWQgYnkgUGhhc2VyLkdhbWUgd2hlbiBpdCBmaXJzdCBzdGFydHMgdXAuXHJcbiAgICAqIFRoZSByZW5kZXJlciBpcyBhdmFpbGFibGUgYnkgbm93LlxyXG4gICAgKi9cclxuICAgIGJvb3Q6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLmdhbWUuY2FudmFzO1xyXG5cclxuICAgICAgICB0aGlzLmtleWJvYXJkLmJvb3QoKTtcclxuICAgICAgICB0aGlzLm1vdXNlLmJvb3QoKTtcclxuICAgICAgICB0aGlzLnRvdWNoLmJvb3QoKTtcclxuICAgICAgICB0aGlzLmdhbWVwYWQuYm9vdCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICh0aW1lLCBkZWx0YSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmtleWJvYXJkLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuZ2FtZXBhZC51cGRhdGUoKTtcclxuXHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucXVldWUubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyAgQ3VycmVudGx5IGp1c3QgMSBwb2ludGVyIHN1cHBvcnRlZFxyXG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5hY3RpdmVQb2ludGVyO1xyXG5cclxuICAgICAgICBwb2ludGVyLnJlc2V0KCk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8IGxlbiA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2NhbGUueCA9IHRoaXMuZ2FtZS5jb25maWcud2lkdGggLyB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aDtcclxuICAgICAgICB0aGlzLnNjYWxlLnkgPSB0aGlzLmdhbWUuY29uZmlnLmhlaWdodCAvIHRoaXMuY2FudmFzLm9mZnNldEhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gIENsZWFycyB0aGUgcXVldWUgYXJyYXksIGFuZCBhbHNvIG1lYW5zIHdlIGRvbid0IHdvcmsgb24gYXJyYXkgZGF0YSB0aGF0IGNvdWxkIHBvdGVudGlhbGx5XHJcbiAgICAgICAgLy8gIGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgcHJvY2Vzc2luZyBwaGFzZVxyXG4gICAgICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWUuc3BsaWNlKDAsIGxlbik7XHJcblxyXG4gICAgICAgIC8vICBQcm9jZXNzIHRoZSBldmVudCBxdWV1ZSwgZGlzcGF0Y2hpbmcgYWxsIG9mIHRoZSBldmVudHMgdGhhdCBoYXZlIHN0b3JlZCB1cFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBxdWV1ZVtpXTtcclxuXHJcbiAgICAgICAgICAgIC8vICBUT0RPOiBNb3ZlIHRvIENPTlNUcyBzbyB3ZSBjYW4gZG8gaW50ZWdlciBjb21wYXJpc29ucyBpbnN0ZWFkIG9mIHN0cmluZ3MuXHJcbiAgICAgICAgICAgIC8vICBUT0RPOiBSZW1vdmUgdGhlIE1vdXNlRXZlbnQgZXZlbnRzLiBEZXZzIHNob3VsZCB1c2UgUG9pbnRlciBldmVudHMgaW5zdGVhZC5cclxuICAgICAgICAgICAgc3dpdGNoIChldmVudC50eXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLm1vdmUoZXZlbnQsIHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBNb3VzZUV2ZW50Lk1PVkUoZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRvd24oZXZlbnQsIHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBNb3VzZUV2ZW50LkRPV04oZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtb3VzZXVwJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci51cChldmVudCwgdGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IE1vdXNlRXZlbnQuVVAoZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICd0b3VjaG1vdmUnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLnRvdWNobW92ZShldmVudCwgdGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAndG91Y2hzdGFydCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIudG91Y2hzdGFydChldmVudCwgdGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAndG91Y2hlbmQnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLnRvdWNoZW5kKGV2ZW50LCB0aW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VHJhbnNmb3JtZWRQb2ludDogZnVuY3Rpb24gKGdhbWVPYmplY3QsIHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIEdldFRyYW5zZm9ybWVkUG9pbnQodGhpcy5fdGVtcE1hdHJpeCwgZ2FtZU9iamVjdCwgeCwgeSwgdGhpcy5fdGVtcFBvaW50KTtcclxuICAgIH0sXHJcblxyXG4gICAgcG9pbnRXaXRoaW5HYW1lT2JqZWN0OiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgeCwgeSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gUG9pbnRXaXRoaW5HYW1lT2JqZWN0KGdhbWVPYmplY3QsIHgsIHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBoaXRUZXN0OiBmdW5jdGlvbiAoZ2FtZU9iamVjdHMsIHgsIHksIGNhbWVyYSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gSGl0VGVzdCh0aGlzLl90ZW1wTWF0cml4LCB4LCB5LCBnYW1lT2JqZWN0cywgY2FtZXJhLCB0aGlzLl90ZW1wSGl0VGVzdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHBvaW50U2NyZWVuVG9Xb3JsZEhpdFRlc3Q6IGZ1bmN0aW9uIChnYW1lT2JqZWN0cywgeCwgeSwgY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBQb2ludFNjcmVlblRvV29ybGRIaXRUZXN0KHRoaXMuX3RlbXBNYXRyaXgsIHgsIHksIGdhbWVPYmplY3RzLCBjYW1lcmEsIHRoaXMuX3RlbXBIaXRUZXN0KTtcclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNmb3JtWDogZnVuY3Rpb24gKHBhZ2VYKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAocGFnZVggLSB0aGlzLmNhbnZhcy5vZmZzZXRMZWZ0KSAqIHRoaXMuc2NhbGUueDtcclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNmb3JtWTogZnVuY3Rpb24gKHBhZ2VZKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAocGFnZVkgLSB0aGlzLmNhbnZhcy5vZmZzZXRUb3ApICogdGhpcy5zY2FsZS55O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRPZmZzZXRYOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5vZmZzZXRMZWZ0O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRPZmZzZXRZOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5vZmZzZXRUb3A7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFNjYWxlWDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nYW1lLmNvbmZpZy53aWR0aCAvIHRoaXMuY2FudmFzLm9mZnNldFdpZHRoO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTY2FsZVk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FtZS5jb25maWcuaGVpZ2h0IC8gdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0O1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdsb2JhbElucHV0TWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9nbG9iYWwvR2xvYmFsSW5wdXRNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFRyYW5zZm9ybWVkUG9pbnQgPSByZXF1aXJlKCcuL0dldFRyYW5zZm9ybWVkUG9pbnQnKTtcclxudmFyIFBvaW50V2l0aGluSGl0QXJlYSA9IHJlcXVpcmUoJy4vUG9pbnRXaXRoaW5IaXRBcmVhJyk7XHJcblxyXG4vLyAgV2lsbCBhbHdheXMgcmV0dXJuIGFuIGFycmF5LlxyXG4vLyAgQXJyYXkgY29udGFpbnMgbWF0Y2hpbmcgSW50ZXJhY3RpdmUgT2JqZWN0cy5cclxuLy8gIEFycmF5IHdpbGwgYmUgZW1wdHkgaWYgbm8gb2JqZWN0cyB3ZXJlIG1hdGNoZWQuXHJcblxyXG52YXIgSGl0VGVzdCA9IGZ1bmN0aW9uICh0ZW1wTWF0cml4LCB4LCB5LCBnYW1lT2JqZWN0cywgY2FtZXJhLCBvdXRwdXQpXHJcbntcclxuICAgIHZhciBjYW1lcmFXID0gY2FtZXJhLndpZHRoO1xyXG4gICAgdmFyIGNhbWVyYUggPSBjYW1lcmEuaGVpZ2h0O1xyXG5cclxuICAgIG91dHB1dC5sZW5ndGggPSAwO1xyXG5cclxuICAgIGlmICghKHggPj0gY2FtZXJhLnggJiYgeSA+PSBjYW1lcmEueSAmJiB4IDw9IGNhbWVyYS54ICsgY2FtZXJhVyAmJiB5IDw9IGNhbWVyYS55ICsgY2FtZXJhSCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2NyZWVuUG9pbnQgPSBjYW1lcmEuY2FtZXJhVG9TY3JlZW4oeyB4OiB4LCB5OiB5IH0pO1xyXG4gICAgdmFyIGN1bGxlZEdhbWVPYmplY3RzID0gY2FtZXJhLmN1bGwoZ2FtZU9iamVjdHMpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VsbGVkR2FtZU9iamVjdHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdhbWVPYmplY3QgPSBjdWxsZWRHYW1lT2JqZWN0c1tpXTtcclxuXHJcbiAgICAgICAgaWYgKCFnYW1lT2JqZWN0LmlucHV0LmVuYWJsZWQgfHwgIWdhbWVPYmplY3Qud2lsbFJlbmRlcigpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcG9pbnQgPSBHZXRUcmFuc2Zvcm1lZFBvaW50KFxyXG4gICAgICAgICAgICB0ZW1wTWF0cml4LFxyXG4gICAgICAgICAgICBnYW1lT2JqZWN0LFxyXG4gICAgICAgICAgICBzY3JlZW5Qb2ludC54ICsgY2FtZXJhLnNjcm9sbFggKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3RvclgsXHJcbiAgICAgICAgICAgIHNjcmVlblBvaW50LnkgKyBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWVxyXG4gICAgICAgICk7XHJcbiAgIFxyXG4gICAgICAgIGlmIChQb2ludFdpdGhpbkhpdEFyZWEoZ2FtZU9iamVjdCwgcG9pbnQueCwgcG9pbnQueSwgY2FtZXJhKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGdhbWVPYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIaXRUZXN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2dsb2JhbC9pbmMvSGl0VGVzdC5qc1xuLy8gbW9kdWxlIGlkID0gNzExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRUcmFuc2Zvcm1lZFBvaW50ID0gcmVxdWlyZSgnLi9HZXRUcmFuc2Zvcm1lZFBvaW50Jyk7XHJcbnZhciBQb2ludFdpdGhpbkdhbWVPYmplY3QgPSByZXF1aXJlKCcuL1BvaW50V2l0aGluR2FtZU9iamVjdCcpO1xyXG5cclxuLy8gIFdpbGwgYWx3YXlzIHJldHVybiBhbiBhcnJheS5cclxuLy8gIEFycmF5IGNvbnRhaW5zIG1hdGNoaW5nIEdhbWUgT2JqZWN0cy5cclxuLy8gIEFycmF5IHdpbGwgYmUgZW1wdHkgaWYgbm8gb2JqZWN0cyB3ZXJlIG1hdGNoZWQuXHJcblxyXG52YXIgUG9pbnRTY3JlZW5Ub1dvcmxkSGl0VGVzdCA9IGZ1bmN0aW9uICh0ZW1wTWF0cml4LCB4LCB5LCBnYW1lT2JqZWN0QXJyYXksIGNhbWVyYSwgb3V0cHV0KSBcclxue1xyXG4gICAgdmFyIGxlbmd0aCA9IGdhbWVPYmplY3RBcnJheS5sZW5ndGg7XHJcbiAgICB2YXIgc2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYO1xyXG4gICAgdmFyIHNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWTtcclxuICAgIHZhciBjYW1lcmFXID0gY2FtZXJhLndpZHRoO1xyXG4gICAgdmFyIGNhbWVyYUggPSBjYW1lcmEuaGVpZ2h0O1xyXG5cclxuICAgIG91dHB1dC5sZW5ndGggPSAwO1xyXG5cclxuICAgIGlmICghKHggPj0gY2FtZXJhLnggJiYgeSA+PSBjYW1lcmEueSAmJlxyXG4gICAgICAgIHggPD0gY2FtZXJhLnggKyBjYW1lcmFXICYmIHkgPD0gY2FtZXJhLnkgKyBjYW1lcmFIKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY3JlZW5Qb2ludCA9IGNhbWVyYS5jYW1lcmFUb1NjcmVlbih7eDogeCwgeTogeX0pO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGdhbWVPYmplY3RBcnJheSkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGN1bGxlZCA9IGNhbWVyYS5jdWxsKGdhbWVPYmplY3RBcnJheSk7XHJcbiAgICAgICAgdmFyIGN1bGxlZExlbmd0aCA9IGN1bGxlZC5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjdWxsZWRMZW5ndGg7ICsraW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gY3VsbGVkW2luZGV4XTtcclxuICAgICAgICAgICAgdmFyIHRwb2ludCA9IEdldFRyYW5zZm9ybWVkUG9pbnQodGVtcE1hdHJpeCwgb2JqZWN0LCBzY3JlZW5Qb2ludC54ICsgc2Nyb2xsWCAqIG9iamVjdC5zY3JvbGxGYWN0b3JYLCBzY3JlZW5Qb2ludC55ICsgc2Nyb2xsWSAqIG9iamVjdC5zY3JvbGxGYWN0b3JZKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChQb2ludFdpdGhpbkdhbWVPYmplY3Qob2JqZWN0LCB0cG9pbnQueCwgdHBvaW50LnkpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvYmplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvYmplY3QgPSBnYW1lT2JqZWN0QXJyYXk7XHJcblxyXG4gICAgICAgIHZhciB0cG9pbnQgPSBHZXRUcmFuc2Zvcm1lZFBvaW50KHRlbXBNYXRyaXgsIG9iamVjdCwgc2NyZWVuUG9pbnQueCArIHNjcm9sbFggKiBvYmplY3Quc2Nyb2xsRmFjdG9yWCwgc2NyZWVuUG9pbnQueSArIHNjcm9sbFkgKiBvYmplY3Quc2Nyb2xsRmFjdG9yWSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKFBvaW50V2l0aGluR2FtZU9iamVjdChvYmplY3QsIHRwb2ludC54LCB0cG9pbnQueSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChvYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFNjcmVlblRvV29ybGRIaXRUZXN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2dsb2JhbC9pbmMvUG9pbnRTY3JlZW5Ub1dvcmxkSGl0VGVzdC5qc1xuLy8gbW9kdWxlIGlkID0gNzEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICB4L3kgTVVTVCBiZSB0cmFuc2xhdGVkIGJlZm9yZSBiZWluZyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbixcclxuLy8gIHVubGVzcyB0aGUgZ2FtZU9iamVjdCBpcyBndWFyYW50ZWVkIHRvIG5vdCBiZSByb3RhdGVkIG9yIHNjYWxlZCBpbiBhbnkgd2F5XHJcblxyXG52YXIgUG9pbnRXaXRoaW5IaXRBcmVhID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHgsIHksIGNhbWVyYSlcclxue1xyXG4gICAgdmFyIGlucHV0ID0gZ2FtZU9iamVjdC5pbnB1dDtcclxuXHJcbiAgICAvLyBpZiAoIWlucHV0KVxyXG4gICAgLy8ge1xyXG4gICAgLy8gICAgIHJldHVybiBmYWxzZTtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyAgTm9ybWFsaXplIHRoZSBvcmlnaW5cclxuICAgIHggKz0gZ2FtZU9iamVjdC5kaXNwbGF5T3JpZ2luWDtcclxuICAgIHkgKz0gZ2FtZU9iamVjdC5kaXNwbGF5T3JpZ2luWTtcclxuXHJcbiAgICBpZiAoaW5wdXQuaGl0QXJlYUNhbGxiYWNrKGlucHV0LmhpdEFyZWEsIHgsIHksIGdhbWVPYmplY3QpKVxyXG4gICAge1xyXG4gICAgICAgIGlucHV0LmxvY2FsWCA9IHg7XHJcbiAgICAgICAgaW5wdXQubG9jYWxZID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFdpdGhpbkhpdEFyZWE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvZ2xvYmFsL2luYy9Qb2ludFdpdGhpbkhpdEFyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDcxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUmV0dXJuIGJvb2xlYW4gKHRydWUgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBjb21ibywgZmFsc2UgaWYgbm90KVxyXG5cclxudmFyIEFkdmFuY2VLZXlDb21ibyA9IGZ1bmN0aW9uIChldmVudCwgY29tYm8pXHJcbntcclxuICAgIGNvbWJvLnRpbWVMYXN0TWF0Y2hlZCA9IGV2ZW50LnRpbWVTdGFtcDtcclxuICAgIGNvbWJvLmluZGV4Kys7XHJcblxyXG4gICAgaWYgKGNvbWJvLmluZGV4ID09PSBjb21iby5zaXplKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGNvbWJvLmN1cnJlbnQgPSBjb21iby5rZXlDb2Rlc1tjb21iby5pbmRleF07XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZHZhbmNlS2V5Q29tYm87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQva2V5Ym9hcmQvY29tYm8vQWR2YW5jZUtleUNvbWJvLmpzXG4vLyBtb2R1bGUgaWQgPSA3MTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgS2V5Q29tYm9NYXRjaEV2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBFdmVudCxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEtleUNvbWJvTWF0Y2hFdmVudCAoa2V5Q29tYm8sIGtleWJvYXJkRXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCAnS0VZX0NPTUJPX01BVENIX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0ga2V5Q29tYm87XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IGtleWJvYXJkRXZlbnQ7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS2V5Q29tYm9NYXRjaEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2NvbWJvL0tleUNvbWJvTWF0Y2hFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZXNldEtleUNvbWJvID0gZnVuY3Rpb24gKGNvbWJvKVxyXG57XHJcbiAgICBjb21iby5jdXJyZW50ID0gY29tYm8ua2V5Q29kZXNbMF07XHJcbiAgICBjb21iby5pbmRleCA9IDA7XHJcbiAgICBjb21iby50aW1lTGFzdE1hdGNoZWQgPSAwO1xyXG4gICAgY29tYm8ubWF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgY29tYm8udGltZU1hdGNoZWQgPSAwO1xyXG5cclxuICAgIHJldHVybiBjb21ibztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzZXRLZXlDb21ibztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9jb21iby9SZXNldEtleUNvbWJvLmpzXG4vLyBtb2R1bGUgaWQgPSA3MTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgS2V5RG93bkV2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBFdmVudCxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEtleURvd25FdmVudCAoa2V5Ym9hcmRFdmVudClcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdLRVlfRE9XTl9FVkVOVCcpO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEgPSBrZXlib2FyZEV2ZW50O1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleURvd25FdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9ldmVudHMvS2V5RG93bkV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3MTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgS2V5VXBFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBLZXlVcEV2ZW50IChrZXlib2FyZEV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ0tFWV9VUF9FVkVOVCcpO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEgPSBrZXlib2FyZEV2ZW50O1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleVVwRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQva2V5Ym9hcmQvZXZlbnRzL0tleVVwRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDcxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxudmFyIEtleUNvZGVzID0gcmVxdWlyZSgnLi8uLi9rZXlzL0tleUNvZGVzJyk7XHJcblxyXG52YXIgZXZlbnRzID0ge1xyXG4gICAgS0VZX0RPV05fRVZFTlQ6IHJlcXVpcmUoJy4vS2V5RG93bkV2ZW50JyksXHJcbiAgICBLRVlfVVBfRVZFTlQ6IHJlcXVpcmUoJy4vS2V5VXBFdmVudCcpLFxyXG4gICAgX1VQOiBbXSxcclxuICAgIF9ET1dOOiBbXVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlS2V5RXZlbnQgKHR5cGUpXHJcbntcclxuICAgIHZhciBLZXlFdmVudCA9IGZ1bmN0aW9uIChrZXlib2FyZEV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IGtleWJvYXJkRXZlbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIEtleUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuICAgIEtleUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleUV2ZW50O1xyXG5cclxuICAgIHJldHVybiBLZXlFdmVudDtcclxufVxyXG5cclxuLy8gIEluamVjdCB0aGUgS2V5Q29kZSBldmVudHNcclxuXHJcbmZvciAodmFyIGNvZGUgaW4gS2V5Q29kZXMpXHJcbntcclxuICAgIC8vICBUaGUgS2V5IERvd24gRXZlbnQgVHlwZXNcclxuXHJcbiAgICB2YXIgZG93blR5cGUgPSAnS0VZX0RPV05fJyArIGNvZGU7XHJcbiAgICB2YXIgdXBUeXBlID0gJ0tFWV9VUF8nICsgY29kZTtcclxuXHJcbiAgICBldmVudHMuX0RPV05bS2V5Q29kZXNbY29kZV1dID0gY3JlYXRlS2V5RXZlbnQoZG93blR5cGUpO1xyXG4gICAgZXZlbnRzLl9VUFtLZXlDb2Rlc1tjb2RlXV0gPSBjcmVhdGVLZXlFdmVudCh1cFR5cGUpO1xyXG5cclxuICAgIC8vICBNb3JlIGZyaWVuZGx5IGFsaWFzZXMgdG8gdGhlIG1haW4gZXZlbnRzXHJcbiAgICBldmVudHNbZG93blR5cGVdID0gZXZlbnRzLl9ET1dOW0tleUNvZGVzW2NvZGVdXTtcclxuICAgIGV2ZW50c1t1cFR5cGVdID0gZXZlbnRzLl9VUFtLZXlDb2Rlc1tjb2RlXV07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXZlbnRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2V2ZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuSW5wdXQuS2V5Ym9hcmRcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEtleWJvYXJkTWFuYWdlcjogcmVxdWlyZSgnLi9LZXlib2FyZE1hbmFnZXInKSxcclxuXHJcbiAgICBLZXk6IHJlcXVpcmUoJy4va2V5cy9LZXknKSxcclxuICAgIEtleUNvZGVzOiByZXF1aXJlKCcuL2tleXMvS2V5Q29kZXMnKSxcclxuXHJcbiAgICBLZXlDb21ibzogcmVxdWlyZSgnLi9jb21iby9LZXlDb21ibycpLFxyXG5cclxuICAgIEp1c3REb3duOiByZXF1aXJlKCcuL2tleXMvSnVzdERvd24nKSxcclxuICAgIEp1c3RVcDogcmVxdWlyZSgnLi9rZXlzL0p1c3RVcCcpLFxyXG4gICAgRG93bkR1cmF0aW9uOiByZXF1aXJlKCcuL2tleXMvRG93bkR1cmF0aW9uJyksXHJcbiAgICBVcER1cmF0aW9uOiByZXF1aXJlKCcuL2tleXMvVXBEdXJhdGlvbicpXHJcbiAgICBcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFJldHVybnMgYHRydWVgIGlmIHRoZSBLZXkgd2FzIHByZXNzZWQgZG93biB3aXRoaW4gdGhlIGBkdXJhdGlvbmAgdmFsdWUgZ2l2ZW4sIG9yIGBmYWxzZWAgaWYgaXQgZWl0aGVyIGlzbid0IGRvd24sXHJcbiogb3Igd2FzIHByZXNzZWQgZG93biBsb25nZXIgYWdvIHRoYW4gdGhlbiBnaXZlbiBkdXJhdGlvbi5cclxuKi9cclxudmFyIERvd25EdXJhdGlvbiA9IGZ1bmN0aW9uIChrZXksIGR1cmF0aW9uKVxyXG57XHJcbiAgICBpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkgeyBkdXJhdGlvbiA9IDUwOyB9XHJcblxyXG4gICAgcmV0dXJuIChrZXkuaXNEb3duICYmIGtleS5kdXJhdGlvbiA8IGR1cmF0aW9uKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRG93bkR1cmF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2tleXMvRG93bkR1cmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGp1c3REb3duIHZhbHVlIGFsbG93cyB5b3UgdG8gdGVzdCBpZiB0aGlzIEtleSBoYXMganVzdCBiZWVuIHByZXNzZWQgZG93biBvciBub3QuXHJcbiogV2hlbiB5b3UgY2hlY2sgdGhpcyB2YWx1ZSBpdCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgdGhlIEtleSBpcyBkb3duLCBvdGhlcndpc2UgYGZhbHNlYC5cclxuKiBZb3UgY2FuIG9ubHkgY2FsbCBqdXN0RG93biBvbmNlIHBlciBrZXkgcHJlc3MuIEl0IHdpbGwgb25seSByZXR1cm4gYHRydWVgIG9uY2UsIHVudGlsIHRoZSBLZXkgaXMgcmVsZWFzZWQgYW5kIHByZXNzZWQgZG93biBhZ2Fpbi5cclxuKiBUaGlzIGFsbG93cyB5b3UgdG8gdXNlIGl0IGluIHNpdHVhdGlvbnMgd2hlcmUgeW91IHdhbnQgdG8gY2hlY2sgaWYgdGhpcyBrZXkgaXMgZG93biB3aXRob3V0IHVzaW5nIGEgU2lnbmFsLCBzdWNoIGFzIGluIGEgY29yZSBnYW1lIGxvb3AuXHJcbiovXHJcbnZhciBKdXN0RG93biA9IGZ1bmN0aW9uIChrZXkpXHJcbntcclxuICAgIHZhciBjdXJyZW50ID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKGtleS5pc0Rvd24pXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVudCA9IGtleS5fanVzdERvd247XHJcbiAgICAgICAga2V5Ll9qdXN0RG93biA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjdXJyZW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKdXN0RG93bjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9rZXlzL0p1c3REb3duLmpzXG4vLyBtb2R1bGUgaWQgPSA3MjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGp1c3RVcCB2YWx1ZSBhbGxvd3MgeW91IHRvIHRlc3QgaWYgdGhpcyBLZXkgaGFzIGp1c3QgYmVlbiByZWxlYXNlZCBvciBub3QuXHJcbiogV2hlbiB5b3UgY2hlY2sgdGhpcyB2YWx1ZSBpdCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgdGhlIEtleSBpcyB1cCwgb3RoZXJ3aXNlIGBmYWxzZWAuXHJcbiogWW91IGNhbiBvbmx5IGNhbGwganVzdFVwIG9uY2UgcGVyIGtleSByZWxlYXNlLiBJdCB3aWxsIG9ubHkgcmV0dXJuIGB0cnVlYCBvbmNlLCB1bnRpbCB0aGUgS2V5IGlzIHByZXNzZWQgZG93biBhbmQgcmVsZWFzZWQgYWdhaW4uXHJcbiogVGhpcyBhbGxvd3MgeW91IHRvIHVzZSBpdCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdSB3YW50IHRvIGNoZWNrIGlmIHRoaXMga2V5IGlzIHVwIHdpdGhvdXQgdXNpbmcgYSBTaWduYWwsIHN1Y2ggYXMgaW4gYSBjb3JlIGdhbWUgbG9vcC5cclxuKi9cclxudmFyIEp1c3RVcCA9IGZ1bmN0aW9uIChrZXkpXHJcbntcclxuICAgIHZhciBjdXJyZW50ID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKGtleS5pc0Rvd24pXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVudCA9IGtleS5fanVzdFVwO1xyXG4gICAgICAgIGtleS5fanVzdFVwID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGN1cnJlbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEp1c3RVcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9rZXlzL0p1c3RVcC5qc1xuLy8gbW9kdWxlIGlkID0gNzIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgUHJvY2Vzc0tleURvd24gPSBmdW5jdGlvbiAoa2V5LCBldmVudClcclxue1xyXG4gICAga2V5Lm9yaWdpbmFsRXZlbnQgPSBldmVudDtcclxuXHJcbiAgICBpZiAoa2V5LnByZXZlbnREZWZhdWx0KVxyXG4gICAge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFrZXkuZW5hYmxlZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAga2V5LmFsdEtleSA9IGV2ZW50LmFsdEtleTtcclxuICAgIGtleS5jdHJsS2V5ID0gZXZlbnQuY3RybEtleTtcclxuICAgIGtleS5zaGlmdEtleSA9IGV2ZW50LnNoaWZ0S2V5O1xyXG4gICAga2V5LmxvY2F0aW9uID0gZXZlbnQubG9jYXRpb247XHJcblxyXG4gICAga2V5LmlzRG93biA9IHRydWU7XHJcbiAgICBrZXkuaXNVcCA9IGZhbHNlO1xyXG4gICAga2V5LnRpbWVEb3duID0gZXZlbnQudGltZVN0YW1wO1xyXG4gICAga2V5LmR1cmF0aW9uID0gMDtcclxuICAgIGtleS5yZXBlYXRzKys7XHJcblxyXG4gICAga2V5Ll9qdXN0RG93biA9IHRydWU7XHJcbiAgICBrZXkuX2p1c3RVcCA9IGZhbHNlO1xyXG5cclxuICAgIHJldHVybiBrZXk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NLZXlEb3duO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2tleXMvUHJvY2Vzc0tleURvd24uanNcbi8vIG1vZHVsZSBpZCA9IDcyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFByb2Nlc3NLZXlVcCA9IGZ1bmN0aW9uIChrZXksIGV2ZW50KVxyXG57XHJcbiAgICBrZXkub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xyXG5cclxuICAgIGlmIChrZXkucHJldmVudERlZmF1bHQpXHJcbiAgICB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWtleS5lbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBrZXkuaXNEb3duID0gZmFsc2U7XHJcbiAgICBrZXkuaXNVcCA9IHRydWU7XHJcbiAgICBrZXkudGltZVVwID0gZXZlbnQudGltZVN0YW1wO1xyXG4gICAga2V5LmR1cmF0aW9uID0ga2V5LnRpbWVVcCAtIGtleS50aW1lRG93bjtcclxuICAgIGtleS5yZXBlYXRzID0gMDtcclxuXHJcbiAgICBrZXkuX2p1c3REb3duID0gZmFsc2U7XHJcbiAgICBrZXkuX2p1c3RVcCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGtleTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc0tleVVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2tleXMvUHJvY2Vzc0tleVVwLmpzXG4vLyBtb2R1bGUgaWQgPSA3MjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIEtleSB3YXMgcmVsZWFzZWQgd2l0aGluIHRoZSBgZHVyYXRpb25gIHZhbHVlIGdpdmVuLCBvciBgZmFsc2VgIGlmIGl0IGVpdGhlciBpc24ndCB1cCxcclxuKiBvciB3YXMgcmVsZWFzZWQgbG9uZ2VyIGFnbyB0aGFuIHRoZW4gZ2l2ZW4gZHVyYXRpb24uXHJcbiovXHJcbnZhciBVcER1cmF0aW9uID0gZnVuY3Rpb24gKGtleSwgZHVyYXRpb24pXHJcbntcclxuICAgIGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7IGR1cmF0aW9uID0gNTA7IH1cclxuXHJcbiAgICByZXR1cm4gKGtleS5pc1VwICYmIGtleS5kdXJhdGlvbiA8IGR1cmF0aW9uKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXBEdXJhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9rZXlzL1VwRHVyYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDcyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG5cclxuLy8gIERyYWcgRXZlbnRzXHJcbi8vICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTF9EcmFnX2FuZF9Ecm9wX0FQSVxyXG4vLyAgTW91c2UgRXZlbnRzXHJcbi8vICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudFxyXG5cclxudmFyIFNjZW5lSW5wdXRNYW5hZ2VyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFNjZW5lSW5wdXRNYW5hZ2VyIChzY2VuZSlcclxuICAgIHtcclxuICAgICAgICAvLyAgVGhlIFNjZW5lIHRoYXQgb3ducyB0aGlzIHBsdWdpblxyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuXHJcbiAgICAgICAgLy8gIEdsb2JhbElucHV0TWFuYWdlclxyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IHNjZW5lLnN5cy5nYW1lLmlucHV0O1xyXG5cclxuICAgICAgICAvLyAgQSByZWZlcmVuY2UgdG8gdGhpcy5zY2VuZS5zeXMuZGlzcGxheUxpc3QgKHNldCBpbiBib290KVxyXG4gICAgICAgIHRoaXMuZGlzcGxheUxpc3Q7XHJcblxyXG4gICAgICAgIC8vICBBIHJlZmVyZW5jZSB0byB0aGUgdGhpcy5zY2VuZS5zeXMuY2FtZXJhcyAoc2V0IGluIGJvb3QpXHJcbiAgICAgICAgdGhpcy5jYW1lcmFzO1xyXG5cclxuICAgICAgICAvLyAgU2hvdWxkIHVzZSBTY2VuZSBldmVudCBkaXNwYXRjaGVyP1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5tYW5hZ2VyLmV2ZW50cztcclxuXHJcbiAgICAgICAgLy8gIFByb3h5IHJlZmVyZW5jZXMgYXZhaWxhYmxlIHZpYSB0aGUgU2NlbmVcclxuICAgICAgICB0aGlzLmtleWJvYXJkID0gdGhpcy5tYW5hZ2VyLmtleWJvYXJkO1xyXG4gICAgICAgIHRoaXMubW91c2UgPSB0aGlzLm1hbmFnZXIubW91c2U7XHJcbiAgICAgICAgdGhpcy5nYW1lcGFkID0gdGhpcy5tYW5hZ2VyLmdhbWVwYWQ7XHJcblxyXG4gICAgICAgIC8vICBPbmx5IGZpcmUgY2FsbGJhY2tzIGFuZCBldmVudHMgb24gdGhlIHRvcC1tb3N0IEdhbWUgT2JqZWN0IGluIHRoZSBkaXNwbGF5IGxpc3QgKGVtdWxhdGluZyBET00gYmVoYXZpb3IpXHJcbiAgICAgICAgLy8gIGFuZCBpZ25vcmUgYW55IEdPcyBiZWxvdyBpdCwgb3IgY2FsbCB0aGVtIGFsbD9cclxuICAgICAgICB0aGlzLnRvcE9ubHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyAgSG93IG9mdGVuIHNob3VsZCB0aGUgcG9pbnRlciBpbnB1dCBiZSBjaGVja2VkP1xyXG4gICAgICAgIC8vICBUaW1lIGdpdmVuIGluIG1zXHJcbiAgICAgICAgLy8gIFBvaW50ZXIgd2lsbCAqYWx3YXlzKiBiZSBjaGVja2VkIGlmIGl0IGhhcyBiZWVuIG1vdmVkIGJ5IHRoZSB1c2VyLlxyXG4gICAgICAgIC8vICBUaGlzIGNvbnRyb2xzIGhvdyBvZnRlbiBpdCB3aWxsIGJlIHBvbGxlZCBpZiBpdCBoYXNuJ3QgYmVlbiBtb3ZlZC5cclxuICAgICAgICAvLyAgU2V0IHRvIDAgdG8gcG9sbCBjb25zdGFudGx5LiBTZXQgdG8gLTEgdG8gb25seSBwb2xsIG9uIHVzZXIgbW92ZW1lbnQuXHJcbiAgICAgICAgdGhpcy5wb2xsUmF0ZSA9IC0xO1xyXG5cclxuICAgICAgICAvLyAgSW50ZXJuYWwgY291bnRlclxyXG4gICAgICAgIHRoaXMuX3BvbGxUaW1lciA9IDA7XHJcblxyXG4gICAgICAgIC8vICBUaGUgZGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHBvaW50ZXIgaGFzIHRvIG1vdmUgd2hpbGUgYmVpbmcgaGVsZCBkb3duLCBiZWZvcmUgaXQgdGhpbmtzIGl0IGlzIGJlaW5nIGRyYWdnZWQuXHJcbiAgICAgICAgdGhpcy5kcmFnRGlzdGFuY2VUaHJlc2hvbGQgPSAwO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGFtb3VudCBvZiB0aW1lLCBpbiBtcywgdGhlIHBvaW50ZXIgaGFzIHRvIGJlIGhlbGQgZG93biBiZWZvcmUgaXQgdGhpbmtzIGl0IGlzIGRyYWdnaW5nLlxyXG4gICAgICAgIHRoaXMuZHJhZ1RpbWVUaHJlc2hvbGQgPSAwO1xyXG5cclxuICAgICAgICAvLyAgVXNlZCB0byB0ZW1wb3JhcmlseSBzdG9yZSB0aGUgcmVzdWx0cyBvZiB0aGUgSGl0IFRlc3RcclxuICAgICAgICB0aGlzLl90ZW1wID0gW107XHJcblxyXG4gICAgICAgIC8vICBsaXN0OiBBIGxpc3Qgb2YgYWxsIEdhbWUgT2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBzZXQgdG8gYmUgaW50ZXJhY3RpdmVcclxuICAgICAgICB0aGlzLl9saXN0ID0gW107XHJcblxyXG4gICAgICAgIC8vICBwZW5kaW5nSW5zZXJ0aW9uOiBPYmplY3RzIHdhaXRpbmcgdG8gYmUgaW5zZXJ0ZWQgdG8gdGhlIGxpc3Qgb24gdGhlIG5leHQgY2FsbCB0byAnYmVnaW4nXHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0luc2VydGlvbiA9IFtdO1xyXG5cclxuICAgICAgICAvLyAgcGVuZGluZ1JlbW92YWw6IE9iamVjdHMgd2FpdGluZyB0byBiZSByZW1vdmVkIGZyb20gdGhlIGxpc3Qgb24gdGhlIG5leHQgY2FsbCB0byAnYmVnaW4nXHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlbW92YWwgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gIGRyYWdnYWJsZTogQSBsaXN0IG9mIGFsbCBHYW1lIE9iamVjdHMgdGhhdCBoYXZlIGJlZW4gZW5hYmxlZCBmb3IgZHJhZ2dpbmdcclxuICAgICAgICB0aGlzLl9kcmFnZ2FibGUgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gIGRyYWc6IEEgbGlzdCBvZiBhbGwgSW50ZXJhY3RpdmUgT2JqZWN0cyBjdXJyZW50bHkgY29uc2lkZXJlZCBhcyBiZWluZyAnZHJhZ2dhYmxlJyBieSBhbnkgcG9pbnRlciwgaW5kZXhlZCBieSBwb2ludGVyIElEXHJcbiAgICAgICAgdGhpcy5fZHJhZyA9IHsgMDogW10sIDE6IFtdLCAyOiBbXSwgMzogW10sIDQ6IFtdLCA1OiBbXSwgNjogW10sIDc6IFtdLCA4OiBbXSwgOTogW10gfTtcclxuXHJcbiAgICAgICAgLy8gIG92ZXI6IEEgbGlzdCBvZiBhbGwgSW50ZXJhY3RpdmUgT2JqZWN0cyBjdXJyZW50bHkgY29uc2lkZXJlZCBhcyBiZWluZyAnb3ZlcicgYnkgYW55IHBvaW50ZXIsIGluZGV4ZWQgYnkgcG9pbnRlciBJRFxyXG4gICAgICAgIHRoaXMuX292ZXIgPSB7IDA6IFtdLCAxOiBbXSwgMjogW10sIDM6IFtdLCA0OiBbXSwgNTogW10sIDY6IFtdLCA3OiBbXSwgODogW10sIDk6IFtdIH07XHJcblxyXG4gICAgICAgIHRoaXMuX3ZhbGlkVHlwZXMgPSBbICdvbkRvd24nLCAnb25VcCcsICdvbk92ZXInLCAnb25PdXQnLCAnb25Nb3ZlJywgJ29uRHJhZ1N0YXJ0JywgJ29uRHJhZycsICdvbkRyYWdFbmQnLCAnb25EcmFnRW50ZXInLCAnb25EcmFnTGVhdmUnLCAnb25EcmFnT3ZlcicsICdvbkRyb3AnIF07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBBZGQgb3B0aW9uIHRvIGdldCBhbGwgSU9zIHdpdGhpbiBhIFJlY3Qgb3IgQ2lyY2xlXHJcblxyXG4gICAgYm9vdDogcmVxdWlyZSgnLi9pbmMvQm9vdCcpLFxyXG4gICAgYmVnaW46IHJlcXVpcmUoJy4vaW5jL0JlZ2luJyksXHJcbiAgICBjbGVhcjogcmVxdWlyZSgnLi9pbmMvQ2xlYXInKSxcclxuICAgIHVwZGF0ZTogcmVxdWlyZSgnLi9pbmMvVXBkYXRlJyksXHJcbiAgICBoaXRUZXN0UG9pbnRlcjogcmVxdWlyZSgnLi9pbmMvSGl0VGVzdFBvaW50ZXInKSxcclxuICAgIGRpc2FibGU6IHJlcXVpcmUoJy4vaW5jL0Rpc2FibGUnKSxcclxuICAgIGVuYWJsZTogcmVxdWlyZSgnLi9pbmMvRW5hYmxlJyksXHJcbiAgICBxdWV1ZUZvckluc2VydGlvbjogcmVxdWlyZSgnLi9pbmMvUXVldWVGb3JJbnNlcnRpb24nKSxcclxuICAgIHF1ZXVlRm9yUmVtb3ZhbDogcmVxdWlyZSgnLi9pbmMvUXVldWVGb3JSZW1vdmFsJyksXHJcblxyXG4gICAgc2V0cG9sbFJhdGU6IHJlcXVpcmUoJy4vaW5jL1NldFBvbGxSYXRlJyksXHJcbiAgICBzZXRwb2xsQWx3YXlzOiByZXF1aXJlKCcuL2luYy9TZXRQb2xsQWx3YXlzJyksXHJcbiAgICBzZXRwb2xsT25Nb3ZlOiByZXF1aXJlKCcuL2luYy9TZXRQb2xsT25Nb3ZlJyksXHJcblxyXG4gICAgc2V0SGl0QXJlYTogcmVxdWlyZSgnLi9pbmMvU2V0SGl0QXJlYScpLFxyXG4gICAgc2V0SGl0QXJlYUNpcmNsZTogcmVxdWlyZSgnLi9pbmMvU2V0SGl0QXJlYUNpcmNsZScpLFxyXG4gICAgc2V0SGl0QXJlYUVsbGlwc2U6IHJlcXVpcmUoJy4vaW5jL1NldEhpdEFyZWFFbGxpcHNlJyksXHJcbiAgICBzZXRIaXRBcmVhRnJvbVRleHR1cmU6IHJlcXVpcmUoJy4vaW5jL1NldEhpdEFyZWFGcm9tVGV4dHVyZScpLFxyXG4gICAgc2V0SGl0QXJlYVJlY3RhbmdsZTogcmVxdWlyZSgnLi9pbmMvU2V0SGl0QXJlYVJlY3RhbmdsZScpLFxyXG4gICAgc2V0SGl0QXJlYVRyaWFuZ2xlOiByZXF1aXJlKCcuL2luYy9TZXRIaXRBcmVhVHJpYW5nbGUnKSxcclxuXHJcbiAgICBzZXREcmFnZ2FibGU6IHJlcXVpcmUoJy4vaW5jL1NldERyYWdnYWJsZScpLFxyXG5cclxuICAgIHNldENhbGxiYWNrOiByZXF1aXJlKCcuL2luYy9TZXRDYWxsYmFjaycpLFxyXG4gICAgc2V0Q2FsbGJhY2tzOiByZXF1aXJlKCcuL2luYy9TZXRDYWxsYmFja3MnKSxcclxuICAgIHNldE9uRG93bkNhbGxiYWNrOiByZXF1aXJlKCcuL2luYy9TZXRPbkRvd25DYWxsYmFjaycpLFxyXG4gICAgc2V0T25PdXRDYWxsYmFjazogcmVxdWlyZSgnLi9pbmMvU2V0T25PdXRDYWxsYmFjaycpLFxyXG4gICAgc2V0T25PdmVyQ2FsbGJhY2s6IHJlcXVpcmUoJy4vaW5jL1NldE9uT3ZlckNhbGxiYWNrJyksXHJcbiAgICBzZXRPblVwQ2FsbGJhY2s6IHJlcXVpcmUoJy4vaW5jL1NldE9uVXBDYWxsYmFjaycpLFxyXG4gICAgc2V0T25Nb3ZlQ2FsbGJhY2s6IHJlcXVpcmUoJy4vaW5jL1NldE9uTW92ZUNhbGxiYWNrJyksXHJcblxyXG4gICAgcHJvY2Vzc092ZXJPdXRFdmVudHM6IHJlcXVpcmUoJy4vaW5jL1Byb2Nlc3NPdmVyT3V0RXZlbnRzJyksXHJcbiAgICBwcm9jZXNzRG93bkV2ZW50czogcmVxdWlyZSgnLi9pbmMvUHJvY2Vzc0Rvd25FdmVudHMnKSxcclxuICAgIHByb2Nlc3NEcmFnRXZlbnRzOiByZXF1aXJlKCcuL2luYy9Qcm9jZXNzRHJhZ0V2ZW50cycpLFxyXG4gICAgcHJvY2Vzc1VwRXZlbnRzOiByZXF1aXJlKCcuL2luYy9Qcm9jZXNzVXBFdmVudHMnKSxcclxuICAgIHByb2Nlc3NNb3ZlRXZlbnRzOiByZXF1aXJlKCcuL2luYy9Qcm9jZXNzTW92ZUV2ZW50cycpLFxyXG4gICAgc29ydEdhbWVPYmplY3RzOiByZXF1aXJlKCcuL2luYy9Tb3J0R2FtZU9iamVjdHMnKSxcclxuICAgIHNvcnRJbnRlcmFjdGl2ZU9iamVjdHM6IHJlcXVpcmUoJy4vaW5jL1NvcnRJbnRlcmFjdGl2ZU9iamVjdHMnKSxcclxuICAgIHNvcnRIYW5kbGVyR086IHJlcXVpcmUoJy4vaW5jL1NvcnRIYW5kbGVyR08nKSxcclxuICAgIHNvcnRIYW5kbGVySU86IHJlcXVpcmUoJy4vaW5jL1NvcnRIYW5kbGVySU8nKSxcclxuXHJcbiAgICAvLyAgVGhlIHgveSBjb29yZGluYXRlcyBvZiB0aGUgQWN0aXZlUG9pbnRlciBiYXNlZCBvbiB0aGUgZmlyc3QgY2FtZXJhIGluIHRoZSBjYW1lcmEgbGlzdC5cclxuICAgIC8vICBUaGlzIGlzIG9ubHkgc2FmZSB0byB1c2UgaWYgeW91ciBnYW1lIGhhcyBqdXN0IDEgbm9uLXRyYW5zZm9ybWVkIGNhbWVyYSBhbmQgZG9lc24ndCB1c2UgbXVsdGktdG91Y2guXHJcbiAgICB4OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuYWN0aXZlUG9pbnRlci54O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHk6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5hY3RpdmVQb2ludGVyLnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFNjZW5lIHRoYXQgb3ducyB0aGlzIGlzIHNodXR0aW5nIGRvd25cclxuICAgIHNodXRkb3duOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3RlbXAubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9saXN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fZHJhZ2dhYmxlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlbW92YWwubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nSW5zZXJ0aW9uLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYWdbaV0gPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fb3ZlcltpXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEdhbWUgbGV2ZWwgbnVrZVxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNodXRkb3duKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2NlbmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jYW1lcmFzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmtleWJvYXJkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubW91c2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5nYW1lcGFkID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lSW5wdXRNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL1NjZW5lSW5wdXRNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3Mjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgRHJhZ0VuZEV2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBFdmVudCxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIERyYWdFbmRFdmVudCAocG9pbnRlciwgZ2FtZU9iamVjdCwgZHJvcHBlZClcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdEUkFHX0VORF9FVkVOVCcpO1xyXG5cclxuICAgICAgICAvLyAgVGhlIFBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50XHJcbiAgICAgICAgdGhpcy5wb2ludGVyID0gcG9pbnRlcjtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBuYXRpdmUgRE9NIGV2ZW50IChNb3VzZUV2ZW50LCBUb3VjaEV2ZW50LCBldGMpXHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHBvaW50ZXIuZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vICBUaGUgR2FtZSBPYmplY3QgdGhlIGV2ZW50IG9jY3VycmVkIG9uXHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBjYW1lcmEgb24gd2hpY2ggdGhlIGlucHV0IGV2ZW50IG9jY3VycmVkXHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBwb2ludGVyLmNhbWVyYTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBsb2NhbCB4L3kgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50IHdpdGhpbiB0aGUgR2FtZSBPYmplY3RcclxuICAgICAgICB0aGlzLnggPSBwb2ludGVyLng7XHJcbiAgICAgICAgdGhpcy55ID0gcG9pbnRlci55O1xyXG5cclxuICAgICAgICAvLyAgV2hlbiB0aGUgZHJhZyBlbmRlZCBkaWQgaXQgZmlyZSBhIHN1Y2Nlc3NmdWwgRFJPUCBldmVudCBmaXJzdD9cclxuICAgICAgICB0aGlzLmRyb3BwZWQgPSBkcm9wcGVkO1xyXG5cclxuICAgICAgICB0aGlzLmRyYWdYID0gZ2FtZU9iamVjdC5pbnB1dC5kcmFnWDtcclxuICAgICAgICB0aGlzLmRyYWdZID0gZ2FtZU9iamVjdC5pbnB1dC5kcmFnWTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEcmFnRW5kRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvZXZlbnRzL0RyYWdFbmRFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIERyYWdFbnRlckV2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBFdmVudCxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIERyYWdFbnRlckV2ZW50IChwb2ludGVyLCBnYW1lT2JqZWN0LCBkcm9wWm9uZSlcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdEUkFHX0VOVEVSX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIC8vICBUaGUgUG9pbnRlciB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnRcclxuICAgICAgICB0aGlzLnBvaW50ZXIgPSBwb2ludGVyO1xyXG5cclxuICAgICAgICAvLyAgVGhlIG5hdGl2ZSBET00gZXZlbnQgKE1vdXNlRXZlbnQsIFRvdWNoRXZlbnQsIGV0YylcclxuICAgICAgICB0aGlzLmV2ZW50ID0gcG9pbnRlci5ldmVudDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBHYW1lIE9iamVjdCB0aGUgZXZlbnQgb2NjdXJyZWQgb25cclxuICAgICAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xyXG5cclxuICAgICAgICAvLyAgVGhlIGNhbWVyYSBvbiB3aGljaCB0aGUgaW5wdXQgZXZlbnQgb2NjdXJyZWRcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IHBvaW50ZXIuY2FtZXJhO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGRyb3Agem9uZSB0aGUgZ2FtZSBvYmplY3Qgd2FzIGRyb3BwZWQgb25cclxuICAgICAgICB0aGlzLmRyb3Bab25lID0gZHJvcFpvbmU7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHJhZ0VudGVyRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvZXZlbnRzL0RyYWdFbnRlckV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3Mjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgRHJhZ0V2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBFdmVudCxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIERyYWdFdmVudCAocG9pbnRlciwgZ2FtZU9iamVjdClcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdEUkFHX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIC8vICBUaGUgUG9pbnRlciB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnRcclxuICAgICAgICB0aGlzLnBvaW50ZXIgPSBwb2ludGVyO1xyXG5cclxuICAgICAgICAvLyAgVGhlIG5hdGl2ZSBET00gZXZlbnQgKE1vdXNlRXZlbnQsIFRvdWNoRXZlbnQsIGV0YylcclxuICAgICAgICB0aGlzLmV2ZW50ID0gcG9pbnRlci5ldmVudDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBHYW1lIE9iamVjdCB0aGUgZXZlbnQgb2NjdXJyZWQgb25cclxuICAgICAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xyXG5cclxuICAgICAgICAvLyAgVGhlIGNhbWVyYSBvbiB3aGljaCB0aGUgaW5wdXQgZXZlbnQgb2NjdXJyZWRcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IHBvaW50ZXIuY2FtZXJhO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGxvY2FsIHgveSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnQgd2l0aGluIHRoZSBHYW1lIE9iamVjdFxyXG4gICAgICAgIHRoaXMueCA9IHBvaW50ZXIueDtcclxuICAgICAgICB0aGlzLnkgPSBwb2ludGVyLnk7XHJcblxyXG4gICAgICAgIC8vICBUaGUgbG9jYWwgeC95IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudCB3aXRoaW4gdGhlIEdhbWUgT2JqZWN0XHJcbiAgICAgICAgdGhpcy5kcmFnWCA9IHBvaW50ZXIueCAtIGdhbWVPYmplY3QuaW5wdXQuZHJhZ1g7XHJcbiAgICAgICAgdGhpcy5kcmFnWSA9IHBvaW50ZXIueSAtIGdhbWVPYmplY3QuaW5wdXQuZHJhZ1k7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHJhZ0V2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2V2ZW50cy9EcmFnRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDczMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBEcmFnTGVhdmVFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBEcmFnTGVhdmVFdmVudCAocG9pbnRlciwgZ2FtZU9iamVjdCwgZHJvcFpvbmUpXHJcbiAgICB7XHJcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCAnRFJBR19MRUFWRV9FVkVOVCcpO1xyXG5cclxuICAgICAgICAvLyAgVGhlIFBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50XHJcbiAgICAgICAgdGhpcy5wb2ludGVyID0gcG9pbnRlcjtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBuYXRpdmUgRE9NIGV2ZW50IChNb3VzZUV2ZW50LCBUb3VjaEV2ZW50LCBldGMpXHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHBvaW50ZXIuZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vICBUaGUgR2FtZSBPYmplY3QgdGhlIGV2ZW50IG9jY3VycmVkIG9uXHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBjYW1lcmEgb24gd2hpY2ggdGhlIGlucHV0IGV2ZW50IG9jY3VycmVkXHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBwb2ludGVyLmNhbWVyYTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBkcm9wIHpvbmUgdGhlIGdhbWUgb2JqZWN0IHdhcyBkcm9wcGVkIG9uXHJcbiAgICAgICAgdGhpcy5kcm9wWm9uZSA9IGRyb3Bab25lO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERyYWdMZWF2ZUV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2V2ZW50cy9EcmFnTGVhdmVFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIERyYWdPdmVyRXZlbnQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEV2ZW50LFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gRHJhZ092ZXJFdmVudCAocG9pbnRlciwgZ2FtZU9iamVjdCwgZHJvcFpvbmUpXHJcbiAgICB7XHJcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCAnRFJBR19PVkVSX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIC8vICBUaGUgUG9pbnRlciB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnRcclxuICAgICAgICB0aGlzLnBvaW50ZXIgPSBwb2ludGVyO1xyXG5cclxuICAgICAgICAvLyAgVGhlIG5hdGl2ZSBET00gZXZlbnQgKE1vdXNlRXZlbnQsIFRvdWNoRXZlbnQsIGV0YylcclxuICAgICAgICB0aGlzLmV2ZW50ID0gcG9pbnRlci5ldmVudDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBHYW1lIE9iamVjdCB0aGUgZXZlbnQgb2NjdXJyZWQgb25cclxuICAgICAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xyXG5cclxuICAgICAgICAvLyAgVGhlIGNhbWVyYSBvbiB3aGljaCB0aGUgaW5wdXQgZXZlbnQgb2NjdXJyZWRcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IHBvaW50ZXIuY2FtZXJhO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGRyb3Agem9uZSB0aGUgZ2FtZSBvYmplY3Qgd2FzIGRyb3BwZWQgb25cclxuICAgICAgICB0aGlzLmRyb3Bab25lID0gZHJvcFpvbmU7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHJhZ092ZXJFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9ldmVudHMvRHJhZ092ZXJFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIERyYWdTdGFydEV2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBFdmVudCxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIERyYWdTdGFydEV2ZW50IChwb2ludGVyLCBnYW1lT2JqZWN0KVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ0RSQUdfU1RBUlRfRVZFTlQnKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBQb2ludGVyIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudFxyXG4gICAgICAgIHRoaXMucG9pbnRlciA9IHBvaW50ZXI7XHJcblxyXG4gICAgICAgIC8vICBUaGUgbmF0aXZlIERPTSBldmVudCAoTW91c2VFdmVudCwgVG91Y2hFdmVudCwgZXRjKVxyXG4gICAgICAgIHRoaXMuZXZlbnQgPSBwb2ludGVyLmV2ZW50O1xyXG5cclxuICAgICAgICAvLyAgVGhlIEdhbWUgT2JqZWN0IHRoZSBldmVudCBvY2N1cnJlZCBvblxyXG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdCA9IGdhbWVPYmplY3Q7XHJcblxyXG4gICAgICAgIC8vICBUaGUgY2FtZXJhIG9uIHdoaWNoIHRoZSBpbnB1dCBldmVudCBvY2N1cnJlZFxyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gcG9pbnRlci5jYW1lcmE7XHJcblxyXG4gICAgICAgIC8vICBUaGUgbG9jYWwgeC95IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudCB3aXRoaW4gdGhlIEdhbWUgT2JqZWN0XHJcbiAgICAgICAgdGhpcy54ID0gcG9pbnRlci54O1xyXG4gICAgICAgIHRoaXMueSA9IHBvaW50ZXIueTtcclxuXHJcbiAgICAgICAgdGhpcy5kcmFnWCA9IGdhbWVPYmplY3QuaW5wdXQuZHJhZ1g7XHJcbiAgICAgICAgdGhpcy5kcmFnWSA9IGdhbWVPYmplY3QuaW5wdXQuZHJhZ1k7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHJhZ1N0YXJ0RXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvZXZlbnRzL0RyYWdTdGFydEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3MzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgRHJvcEV2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBFdmVudCxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIERyb3BFdmVudCAocG9pbnRlciwgZ2FtZU9iamVjdCwgZHJvcFpvbmUpXHJcbiAgICB7XHJcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCAnRFJPUF9FVkVOVCcpO1xyXG5cclxuICAgICAgICAvLyAgVGhlIFBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50XHJcbiAgICAgICAgdGhpcy5wb2ludGVyID0gcG9pbnRlcjtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBuYXRpdmUgRE9NIGV2ZW50IChNb3VzZUV2ZW50LCBUb3VjaEV2ZW50LCBldGMpXHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHBvaW50ZXIuZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vICBUaGUgR2FtZSBPYmplY3QgdGhlIGV2ZW50IG9jY3VycmVkIG9uXHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBjYW1lcmEgb24gd2hpY2ggdGhlIGlucHV0IGV2ZW50IG9jY3VycmVkXHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBwb2ludGVyLmNhbWVyYTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBkcm9wIHpvbmUgdGhlIGdhbWUgb2JqZWN0IHdhcyBkcm9wcGVkIG9uXHJcbiAgICAgICAgdGhpcy5kcm9wWm9uZSA9IGRyb3Bab25lO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERyb3BFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9ldmVudHMvRHJvcEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3MzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgR2FtZU9iamVjdERvd25FdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBHYW1lT2JqZWN0RG93bkV2ZW50IChwb2ludGVyLCBnYW1lT2JqZWN0KVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ0dBTUVfT0JKRUNUX0RPV05fRVZFTlQnKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBQb2ludGVyIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudFxyXG4gICAgICAgIHRoaXMucG9pbnRlciA9IHBvaW50ZXI7XHJcblxyXG4gICAgICAgIC8vICBUaGUgbmF0aXZlIERPTSBldmVudCAoTW91c2VFdmVudCwgVG91Y2hFdmVudCwgZXRjKVxyXG4gICAgICAgIHRoaXMuZXZlbnQgPSBwb2ludGVyLmV2ZW50O1xyXG5cclxuICAgICAgICAvLyAgVGhlIEdhbWUgT2JqZWN0IHRoZSBldmVudCBvY2N1cnJlZCBvblxyXG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdCA9IGdhbWVPYmplY3Q7XHJcblxyXG4gICAgICAgIC8vICBUaGUgY2FtZXJhIG9uIHdoaWNoIHRoZSBpbnB1dCBldmVudCBvY2N1cnJlZFxyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gcG9pbnRlci5jYW1lcmE7XHJcblxyXG4gICAgICAgIC8vICBUaGUgbG9jYWwgeC95IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudCB3aXRoaW4gdGhlIEdhbWUgT2JqZWN0XHJcbiAgICAgICAgdGhpcy54ID0gZ2FtZU9iamVjdC5pbnB1dC5sb2NhbFg7XHJcbiAgICAgICAgdGhpcy55ID0gZ2FtZU9iamVjdC5pbnB1dC5sb2NhbFk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZU9iamVjdERvd25FdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9ldmVudHMvR2FtZU9iamVjdERvd25FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIEdhbWVPYmplY3RNb3ZlRXZlbnQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEV2ZW50LFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR2FtZU9iamVjdE1vdmVFdmVudCAocG9pbnRlciwgZ2FtZU9iamVjdClcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdHQU1FX09CSkVDVF9NT1ZFX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIC8vICBUaGUgUG9pbnRlciB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnRcclxuICAgICAgICB0aGlzLnBvaW50ZXIgPSBwb2ludGVyO1xyXG5cclxuICAgICAgICAvLyAgVGhlIG5hdGl2ZSBET00gZXZlbnQgKE1vdXNlRXZlbnQsIFRvdWNoRXZlbnQsIGV0YylcclxuICAgICAgICB0aGlzLmV2ZW50ID0gcG9pbnRlci5ldmVudDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBHYW1lIE9iamVjdCB0aGUgZXZlbnQgb2NjdXJyZWQgb25cclxuICAgICAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xyXG5cclxuICAgICAgICAvLyAgVGhlIGNhbWVyYSBvbiB3aGljaCB0aGUgaW5wdXQgZXZlbnQgb2NjdXJyZWRcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IHBvaW50ZXIuY2FtZXJhO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGxvY2FsIHgveSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnQgd2l0aGluIHRoZSBHYW1lIE9iamVjdFxyXG4gICAgICAgIHRoaXMueCA9IGdhbWVPYmplY3QuaW5wdXQubG9jYWxYO1xyXG4gICAgICAgIHRoaXMueSA9IGdhbWVPYmplY3QuaW5wdXQubG9jYWxZO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVPYmplY3RNb3ZlRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvZXZlbnRzL0dhbWVPYmplY3RNb3ZlRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDczNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBHYW1lT2JqZWN0T3V0RXZlbnQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEV2ZW50LFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR2FtZU9iamVjdE91dEV2ZW50IChwb2ludGVyLCBnYW1lT2JqZWN0KVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ0dBTUVfT0JKRUNUX09VVF9FVkVOVCcpO1xyXG5cclxuICAgICAgICAvLyAgVGhlIFBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50XHJcbiAgICAgICAgdGhpcy5wb2ludGVyID0gcG9pbnRlcjtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBuYXRpdmUgRE9NIGV2ZW50IChNb3VzZUV2ZW50LCBUb3VjaEV2ZW50LCBldGMpXHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHBvaW50ZXIuZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vICBUaGUgR2FtZSBPYmplY3QgdGhlIGV2ZW50IG9jY3VycmVkIG9uXHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBjYW1lcmEgb24gd2hpY2ggdGhlIGlucHV0IGV2ZW50IG9jY3VycmVkXHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBwb2ludGVyLmNhbWVyYTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lT2JqZWN0T3V0RXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvZXZlbnRzL0dhbWVPYmplY3RPdXRFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIEdhbWVPYmplY3RPdmVyRXZlbnQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEV2ZW50LFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR2FtZU9iamVjdE92ZXJFdmVudCAocG9pbnRlciwgZ2FtZU9iamVjdClcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdHQU1FX09CSkVDVF9PVkVSX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIC8vICBUaGUgUG9pbnRlciB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnRcclxuICAgICAgICB0aGlzLnBvaW50ZXIgPSBwb2ludGVyO1xyXG5cclxuICAgICAgICAvLyAgVGhlIG5hdGl2ZSBET00gZXZlbnQgKE1vdXNlRXZlbnQsIFRvdWNoRXZlbnQsIGV0YylcclxuICAgICAgICB0aGlzLmV2ZW50ID0gcG9pbnRlci5ldmVudDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBHYW1lIE9iamVjdCB0aGUgZXZlbnQgb2NjdXJyZWQgb25cclxuICAgICAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xyXG5cclxuICAgICAgICAvLyAgVGhlIGNhbWVyYSBvbiB3aGljaCB0aGUgaW5wdXQgZXZlbnQgb2NjdXJyZWRcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IHBvaW50ZXIuY2FtZXJhO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGxvY2FsIHgveSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnQgd2l0aGluIHRoZSBHYW1lIE9iamVjdFxyXG4gICAgICAgIHRoaXMueCA9IGdhbWVPYmplY3QuaW5wdXQubG9jYWxYO1xyXG4gICAgICAgIHRoaXMueSA9IGdhbWVPYmplY3QuaW5wdXQubG9jYWxZO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVPYmplY3RPdmVyRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvZXZlbnRzL0dhbWVPYmplY3RPdmVyRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDczOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBHYW1lT2JqZWN0VXBFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBHYW1lT2JqZWN0VXBFdmVudCAocG9pbnRlciwgZ2FtZU9iamVjdClcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdHQU1FX09CSkVDVF9VUF9FVkVOVCcpO1xyXG5cclxuICAgICAgICAvLyAgVGhlIFBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50XHJcbiAgICAgICAgdGhpcy5wb2ludGVyID0gcG9pbnRlcjtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBuYXRpdmUgRE9NIGV2ZW50IChNb3VzZUV2ZW50LCBUb3VjaEV2ZW50LCBldGMpXHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHBvaW50ZXIuZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vICBUaGUgR2FtZSBPYmplY3QgdGhlIGV2ZW50IG9jY3VycmVkIG9uXHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBjYW1lcmEgb24gd2hpY2ggdGhlIGlucHV0IGV2ZW50IG9jY3VycmVkXHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBwb2ludGVyLmNhbWVyYTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBsb2NhbCB4L3kgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50IHdpdGhpbiB0aGUgR2FtZSBPYmplY3RcclxuICAgICAgICB0aGlzLnggPSBnYW1lT2JqZWN0LmlucHV0LmxvY2FsWDtcclxuICAgICAgICB0aGlzLnkgPSBnYW1lT2JqZWN0LmlucHV0LmxvY2FsWTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lT2JqZWN0VXBFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9ldmVudHMvR2FtZU9iamVjdFVwRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDczOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBQb2ludGVyRG93bkV2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBFdmVudCxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFBvaW50ZXJEb3duRXZlbnQgKHBvaW50ZXIsIGdhbWVPYmplY3RzKVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ1BPSU5URVJfRE9XTl9FVkVOVCcpO1xyXG5cclxuICAgICAgICAvLyAgVGhlIFBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50XHJcbiAgICAgICAgdGhpcy5wb2ludGVyID0gcG9pbnRlcjtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBuYXRpdmUgRE9NIGV2ZW50IChNb3VzZUV2ZW50LCBUb3VjaEV2ZW50LCBldGMpXHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHBvaW50ZXIuZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vICBUaGUgY2FtZXJhIG9uIHdoaWNoIHRoZSBpbnB1dCBldmVudCBvY2N1cnJlZFxyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gcG9pbnRlci5jYW1lcmE7XHJcblxyXG4gICAgICAgIC8vICBUaGUgeC95IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudFxyXG4gICAgICAgIHRoaXMueCA9IHBvaW50ZXIueDtcclxuICAgICAgICB0aGlzLnkgPSBwb2ludGVyLnk7XHJcblxyXG4gICAgICAgIC8vICBBbiBhcnJheSBvZiBhbGwgdGhlIGdhbWUgb2JqZWN0cyB0aGUgcG9pbnRlciBldmVudCBvY2N1cnJlZCBvbiBpbiBkaXNwbGF5IGxpc3Qgb3JkZXIuXHJcbiAgICAgICAgLy8gIFdpbGwgYmUgZW1wdHkgaWYgbm8gb2JqZWN0cyB3ZXJlIGludGVyYWN0ZWQgd2l0aC5cclxuICAgICAgICAvLyAgSWYgcG9wdWxhdGVkLCB0aGUgYm90dG9tIGVsZW1lbnQgKGxpc3RbMF0pIGlzIHRoZSBoaWdoZXN0IG9iamVjdCBvbiB0aGUgZGlzcGxheSBsaXN0LlxyXG4gICAgICAgIC8vICBJZiBJbnB1dE1hbmFnZXIudG9wT25seSBpcyB0cnVlIHRoaXMgYXJyYXkgd2lsbCBvbmx5IGNvbnRhaW4gb25lIGVsZW1lbnQuXHJcbiAgICAgICAgdGhpcy5saXN0ID0gZ2FtZU9iamVjdHM7XHJcblxyXG4gICAgICAgIC8vICBBIHJlZmVyZW5jZSB0byB0aGUgdG9wLW1vc3Qgb2JqZWN0IG9uIHRoZSBkaXNwbGF5IGxpc3QgKHNhbWUgYXMgZXZlbnQubGlzdFswXSlcclxuICAgICAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0c1swXTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludGVyRG93bkV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2V2ZW50cy9Qb2ludGVyRG93bkV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3NDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgUG9pbnRlck1vdmVFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBQb2ludGVyTW92ZUV2ZW50IChwb2ludGVyLCBnYW1lT2JqZWN0cylcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdQT0lOVEVSX01PVkVfRVZFTlQnKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBQb2ludGVyIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudFxyXG4gICAgICAgIHRoaXMucG9pbnRlciA9IHBvaW50ZXI7XHJcblxyXG4gICAgICAgIC8vICBUaGUgbmF0aXZlIERPTSBldmVudCAoTW91c2VFdmVudCwgVG91Y2hFdmVudCwgZXRjKVxyXG4gICAgICAgIHRoaXMuZXZlbnQgPSBwb2ludGVyLmV2ZW50O1xyXG5cclxuICAgICAgICAvLyAgVGhlIGNhbWVyYSBvbiB3aGljaCB0aGUgaW5wdXQgZXZlbnQgb2NjdXJyZWRcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IHBvaW50ZXIuY2FtZXJhO1xyXG5cclxuICAgICAgICAvLyAgVGhlIHgveSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnRcclxuICAgICAgICB0aGlzLnggPSBwb2ludGVyLng7XHJcbiAgICAgICAgdGhpcy55ID0gcG9pbnRlci55O1xyXG5cclxuICAgICAgICAvLyAgQW4gYXJyYXkgb2YgYWxsIHRoZSBnYW1lIG9iamVjdHMgdGhlIHBvaW50ZXIgZXZlbnQgb2NjdXJyZWQgb24gaW4gZGlzcGxheSBsaXN0IG9yZGVyLlxyXG4gICAgICAgIC8vICBXaWxsIGJlIGVtcHR5IGlmIG5vIG9iamVjdHMgd2VyZSBpbnRlcmFjdGVkIHdpdGguXHJcbiAgICAgICAgLy8gIElmIHBvcHVsYXRlZCwgdGhlIGJvdHRvbSBlbGVtZW50IChsaXN0WzBdKSBpcyB0aGUgaGlnaGVzdCBvYmplY3Qgb24gdGhlIGRpc3BsYXkgbGlzdC5cclxuICAgICAgICAvLyAgSWYgSW5wdXRNYW5hZ2VyLnRvcE9ubHkgaXMgdHJ1ZSB0aGlzIGFycmF5IHdpbGwgb25seSBjb250YWluIG9uZSBlbGVtZW50LlxyXG4gICAgICAgIHRoaXMubGlzdCA9IGdhbWVPYmplY3RzO1xyXG5cclxuICAgICAgICAvLyAgQSByZWZlcmVuY2UgdG8gdGhlIHRvcC1tb3N0IG9iamVjdCBvbiB0aGUgZGlzcGxheSBsaXN0IChhbHNvIHRoaXMubGlzdFswXSkuIFVuZGVmaW5lZCBpZiB0aGVyZSBpc24ndCBhbnkuXHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdHNbMF07XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRlck1vdmVFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9ldmVudHMvUG9pbnRlck1vdmVFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIFBvaW50ZXJPdXRFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBQb2ludGVyT3V0RXZlbnQgKHBvaW50ZXIsIGdhbWVPYmplY3RzKVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ1BPSU5URVJfT1VUX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIC8vICBUaGUgUG9pbnRlciB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnRcclxuICAgICAgICB0aGlzLnBvaW50ZXIgPSBwb2ludGVyO1xyXG5cclxuICAgICAgICAvLyAgVGhlIG5hdGl2ZSBET00gZXZlbnQgKE1vdXNlRXZlbnQsIFRvdWNoRXZlbnQsIGV0YylcclxuICAgICAgICB0aGlzLmV2ZW50ID0gcG9pbnRlci5ldmVudDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBjYW1lcmEgb24gd2hpY2ggdGhlIGlucHV0IGV2ZW50IG9jY3VycmVkXHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBwb2ludGVyLmNhbWVyYTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSB4L3kgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50XHJcbiAgICAgICAgdGhpcy54ID0gcG9pbnRlci54O1xyXG4gICAgICAgIHRoaXMueSA9IHBvaW50ZXIueTtcclxuXHJcbiAgICAgICAgLy8gIEFuIGFycmF5IG9mIGFsbCB0aGUgZ2FtZSBvYmplY3RzIHRoZSBwb2ludGVyIGV2ZW50IG9jY3VycmVkIG9uIGluIGRpc3BsYXkgbGlzdCBvcmRlci5cclxuICAgICAgICAvLyAgV2lsbCBiZSB1bmRlZmluZWQgaWYgbm8gb2JqZWN0cyB3ZXJlIGludGVyYWN0ZWQgd2l0aC5cclxuICAgICAgICAvLyAgSWYgcG9wdWxhdGVkLCB0aGUgYm90dG9tIGVsZW1lbnQgKGxpc3RbMF0pIGlzIHRoZSBoaWdoZXN0IG9iamVjdCBvbiB0aGUgZGlzcGxheSBsaXN0LlxyXG4gICAgICAgIC8vICBJZiBJbnB1dE1hbmFnZXIudG9wT25seSBpcyB0cnVlIHRoaXMgYXJyYXkgd2lsbCBvbmx5IGNvbnRhaW4gb25lIGVsZW1lbnQuXHJcbiAgICAgICAgdGhpcy5saXN0ID0gZ2FtZU9iamVjdHM7XHJcblxyXG4gICAgICAgIC8vICBBIHJlZmVyZW5jZSB0byB0aGUgdG9wLW1vc3Qgb2JqZWN0IG9uIHRoZSBkaXNwbGF5IGxpc3QgKGFsc28gdGhpcy5saXN0WzBdKVxyXG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdCA9IGdhbWVPYmplY3RzWzBdO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50ZXJPdXRFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9ldmVudHMvUG9pbnRlck91dEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3NDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgUG9pbnRlck92ZXJFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBQb2ludGVyT3ZlckV2ZW50IChwb2ludGVyLCBnYW1lT2JqZWN0cylcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdQT0lOVEVSX09WRVJfRVZFTlQnKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBQb2ludGVyIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudFxyXG4gICAgICAgIHRoaXMucG9pbnRlciA9IHBvaW50ZXI7XHJcblxyXG4gICAgICAgIC8vICBUaGUgbmF0aXZlIERPTSBldmVudCAoTW91c2VFdmVudCwgVG91Y2hFdmVudCwgZXRjKVxyXG4gICAgICAgIHRoaXMuZXZlbnQgPSBwb2ludGVyLmV2ZW50O1xyXG5cclxuICAgICAgICAvLyAgVGhlIGNhbWVyYSBvbiB3aGljaCB0aGUgaW5wdXQgZXZlbnQgb2NjdXJyZWRcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IHBvaW50ZXIuY2FtZXJhO1xyXG5cclxuICAgICAgICAvLyAgVGhlIHgveSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnRcclxuICAgICAgICB0aGlzLnggPSBwb2ludGVyLng7XHJcbiAgICAgICAgdGhpcy55ID0gcG9pbnRlci55O1xyXG5cclxuICAgICAgICAvLyAgQW4gYXJyYXkgb2YgYWxsIHRoZSBnYW1lIG9iamVjdHMgdGhlIHBvaW50ZXIgZXZlbnQgb2NjdXJyZWQgb24gaW4gZGlzcGxheSBsaXN0IG9yZGVyLlxyXG4gICAgICAgIC8vICBXaWxsIGJlIHVuZGVmaW5lZCBpZiBubyBvYmplY3RzIHdlcmUgaW50ZXJhY3RlZCB3aXRoLlxyXG4gICAgICAgIC8vICBJZiBwb3B1bGF0ZWQsIHRoZSBib3R0b20gZWxlbWVudCAobGlzdFswXSkgaXMgdGhlIGhpZ2hlc3Qgb2JqZWN0IG9uIHRoZSBkaXNwbGF5IGxpc3QuXHJcbiAgICAgICAgLy8gIElmIElucHV0TWFuYWdlci50b3BPbmx5IGlzIHRydWUgdGhpcyBhcnJheSB3aWxsIG9ubHkgY29udGFpbiBvbmUgZWxlbWVudC5cclxuICAgICAgICB0aGlzLmxpc3QgPSBnYW1lT2JqZWN0cztcclxuXHJcbiAgICAgICAgLy8gIEEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbW9zdCBvYmplY3Qgb24gdGhlIGRpc3BsYXkgbGlzdCAoYWxzbyB0aGlzLmxpc3RbMF0pXHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdHNbMF07XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRlck92ZXJFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9ldmVudHMvUG9pbnRlck92ZXJFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIFBvaW50ZXJVcEV2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBFdmVudCxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFBvaW50ZXJVcEV2ZW50IChwb2ludGVyLCBnYW1lT2JqZWN0cylcclxuICAgIHtcclxuICAgICAgICBFdmVudC5jYWxsKHRoaXMsICdQT0lOVEVSX1VQX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIC8vICBUaGUgUG9pbnRlciB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnRcclxuICAgICAgICB0aGlzLnBvaW50ZXIgPSBwb2ludGVyO1xyXG5cclxuICAgICAgICAvLyAgVGhlIG5hdGl2ZSBET00gZXZlbnQgKE1vdXNlRXZlbnQsIFRvdWNoRXZlbnQsIGV0YylcclxuICAgICAgICB0aGlzLmV2ZW50ID0gcG9pbnRlci5ldmVudDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBjYW1lcmEgb24gd2hpY2ggdGhlIGlucHV0IGV2ZW50IG9jY3VycmVkXHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBwb2ludGVyLmNhbWVyYTtcclxuXHJcbiAgICAgICAgLy8gIFRoZSB4L3kgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50XHJcbiAgICAgICAgdGhpcy54ID0gcG9pbnRlci54O1xyXG4gICAgICAgIHRoaXMueSA9IHBvaW50ZXIueTtcclxuXHJcbiAgICAgICAgLy8gIEFuIGFycmF5IG9mIGFsbCB0aGUgZ2FtZSBvYmplY3RzIHRoZSBwb2ludGVyIGV2ZW50IG9jY3VycmVkIG9uIGluIGRpc3BsYXkgbGlzdCBvcmRlci5cclxuICAgICAgICAvLyAgV2lsbCBiZSBlbXB0eSBpZiBubyBvYmplY3RzIHdlcmUgaW50ZXJhY3RlZCB3aXRoLlxyXG4gICAgICAgIC8vICBJZiBwb3B1bGF0ZWQsIHRoZSBib3R0b20gZWxlbWVudCAobGlzdFswXSkgaXMgdGhlIGhpZ2hlc3Qgb2JqZWN0IG9uIHRoZSBkaXNwbGF5IGxpc3QuXHJcbiAgICAgICAgLy8gIElmIElucHV0TWFuYWdlci50b3BPbmx5IGlzIHRydWUgdGhpcyBhcnJheSB3aWxsIG9ubHkgY29udGFpbiBvbmUgZWxlbWVudC5cclxuICAgICAgICB0aGlzLmxpc3QgPSBnYW1lT2JqZWN0cztcclxuXHJcbiAgICAgICAgLy8gIEEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbW9zdCBvYmplY3Qgb24gdGhlIGRpc3BsYXkgbGlzdCAoc2FtZSBhcyBldmVudC5saXN0WzBdKVxyXG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdCA9IGdhbWVPYmplY3RzWzBdO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50ZXJVcEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2V2ZW50cy9Qb2ludGVyVXBFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZWdpbiA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciByZW1vdmVMaXN0ID0gdGhpcy5fcGVuZGluZ1JlbW92YWw7XHJcbiAgICB2YXIgaW5zZXJ0TGlzdCA9IHRoaXMuX3BlbmRpbmdJbnNlcnRpb247XHJcblxyXG4gICAgdmFyIHRvUmVtb3ZlID0gcmVtb3ZlTGlzdC5sZW5ndGg7XHJcbiAgICB2YXIgdG9JbnNlcnQgPSBpbnNlcnRMaXN0Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAodG9SZW1vdmUgPT09IDAgJiYgdG9JbnNlcnQgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFF1aWNrIGJhaWxcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9saXN0O1xyXG5cclxuICAgIC8vICBEZWxldGUgb2xkIGdhbWVPYmplY3RzXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdhbWVPYmplY3QgPSByZW1vdmVMaXN0W2ldO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSBjdXJyZW50LmluZGV4T2YoZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gIFRPRE86IENsZWFyIGZyb20gX2RyYWdnYWJsZSwgX2RyYWcgYW5kIF9vdmVyIHRvb1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jbGVhcihnYW1lT2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIENsZWFyIHRoZSByZW1vdmFsIGxpc3RcclxuICAgIHJlbW92ZUxpc3QubGVuZ3RoID0gMDtcclxuXHJcbiAgICAvLyAgTW92ZSBwZW5kaW5nSW5zZXJ0aW9uIHRvIGxpc3QgKGFsc28gY2xlYXJzIHBlbmRpbmdJbnNlcnRpb24gYXQgdGhlIHNhbWUgdGltZSlcclxuICAgIHRoaXMuX2xpc3QgPSBjdXJyZW50LmNvbmNhdChpbnNlcnRMaXN0LnNwbGljZSgwKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJlZ2luO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9pbmMvQmVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDc0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQm9vdCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuY2FtZXJhcyA9IHRoaXMuc2NlbmUuc3lzLmNhbWVyYXM7XHJcblxyXG4gICAgdGhpcy5kaXNwbGF5TGlzdCA9IHRoaXMuc2NlbmUuc3lzLmRpc3BsYXlMaXN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCb290O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9Cb290LmpzXG4vLyBtb2R1bGUgaWQgPSA3NDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsZWFyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHZhciBpbnB1dCA9IGdhbWVPYmplY3QuaW5wdXQ7XHJcblxyXG4gICAgaW5wdXQuZ2FtZU9iamVjdCA9IHVuZGVmaW5lZDtcclxuICAgIGlucHV0LnRhcmdldCA9IHVuZGVmaW5lZDtcclxuICAgIGlucHV0LmhpdEFyZWEgPSB1bmRlZmluZWQ7XHJcbiAgICBpbnB1dC5oaXRBcmVhQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcbiAgICBpbnB1dC5jYWxsYmFja0NvbnRleHQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgZ2FtZU9iamVjdC5pbnB1dCA9IG51bGw7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsZWFyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9DbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gNzQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXNhYmxlID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIGdhbWVPYmplY3QuaW5wdXQuZW5hYmxlZCA9IGZhbHNlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaXNhYmxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9EaXNhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVuYWJsZSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBzaGFwZSwgY2FsbGJhY2spXHJcbntcclxuICAgIGlmIChnYW1lT2JqZWN0LmlucHV0KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBJZiBpdCBpcyBhbHJlYWR5IGhhcyBhbiBJbnRlcmFjdGl2ZU9iamVjdCB0aGVuIGp1c3QgZW5hYmxlIGl0IGFuZCByZXR1cm5cclxuICAgICAgICBnYW1lT2JqZWN0LmlucHV0LmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vICBDcmVhdGUgYW4gSW50ZXJhY3RpdmVPYmplY3QgYW5kIGVuYWJsZSBpdFxyXG4gICAgICAgIHRoaXMuc2V0SGl0QXJlYShnYW1lT2JqZWN0LCBzaGFwZSwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbmFibGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvaW5jL0VuYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBIaXRUZXN0UG9pbnRlciA9IGZ1bmN0aW9uIChwb2ludGVyKVxyXG57XHJcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5jYW1lcmFzLmdldENhbWVyYUJlbG93UG9pbnRlcihwb2ludGVyKTtcclxuXHJcbiAgICBpZiAoY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHBvaW50ZXIuY2FtZXJhID0gY2FtZXJhO1xyXG5cclxuICAgICAgICAvLyAgR2V0IGEgbGlzdCBvZiBhbGwgb2JqZWN0cyB0aGF0IGNhbiBiZSBzZWVuIGJ5IHRoZSBjYW1lcmEgYmVsb3cgdGhlIHBvaW50ZXIgaW4gdGhlIHNjZW5lIGFuZCBzdG9yZSBpbiAnb3V0cHV0JyBhcnJheS5cclxuICAgICAgICAvLyAgQWxsIG9iamVjdHMgaW4gdGhpcyBhcnJheSBhcmUgaW5wdXQgZW5hYmxlZCwgYXMgY2hlY2tlZCBieSB0aGUgaGl0VGVzdCBmdW5jdGlvbiwgc28gd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBsYXRlciBvbiBhcyB3ZWxsLlxyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuaGl0VGVzdCh0aGlzLl9saXN0LCBwb2ludGVyLngsIHBvaW50ZXIueSwgY2FtZXJhKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhpdFRlc3RQb2ludGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9IaXRUZXN0UG9pbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnRzJyk7XHJcblxyXG52YXIgUHJvY2Vzc0Rvd25FdmVudHMgPSBmdW5jdGlvbiAocG9pbnRlcilcclxue1xyXG4gICAgdmFyIGN1cnJlbnRseU92ZXIgPSB0aGlzLl90ZW1wO1xyXG5cclxuICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBJbnB1dEV2ZW50LlBPSU5URVJfRE9XTihwb2ludGVyLCBjdXJyZW50bHlPdmVyKSk7XHJcblxyXG4gICAgLy8gIEdvIHRocm91Z2ggYWxsIG9iamVjdHMgdGhlIHBvaW50ZXIgd2FzIG92ZXIgYW5kIGZpcmUgdGhlaXIgZXZlbnRzIC8gY2FsbGJhY2tzXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnRseU92ZXIubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdhbWVPYmplY3QgPSBjdXJyZW50bHlPdmVyW2ldO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgSW5wdXRFdmVudC5HQU1FX09CSkVDVF9ET1dOKHBvaW50ZXIsIGdhbWVPYmplY3QpKTtcclxuXHJcbiAgICAgICAgZ2FtZU9iamVjdC5pbnB1dC5vbkRvd24oZ2FtZU9iamVjdCwgcG9pbnRlciwgZ2FtZU9iamVjdC5pbnB1dC5sb2NhbFgsIGdhbWVPYmplY3QuaW5wdXQubG9jYWxZKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudG9wT25seSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc0Rvd25FdmVudHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvaW5jL1Byb2Nlc3NEb3duRXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3RhbmNlQmV0d2VlbiA9IHJlcXVpcmUoJy4uLy4uLy4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuJyk7XHJcbnZhciBJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnRzJyk7XHJcblxyXG52YXIgUHJvY2Vzc0RyYWdFdmVudHMgPSBmdW5jdGlvbiAocG9pbnRlciwgdGltZSlcclxue1xyXG4gICAgaWYgKHRoaXMuX2RyYWdnYWJsZS5sZW5ndGggPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRoZXJlIGFyZSBubyBkcmFnZ2FibGUgaXRlbXMsIHNvIGxldCdzIG5vdCBldmVuIGJvdGhlciBnb2luZyBmdXJ0aGVyXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGM7XHJcbiAgICB2YXIgZ2FtZU9iamVjdDtcclxuICAgIHZhciBsaXN0O1xyXG4gICAgdmFyIGlucHV0O1xyXG4gICAgdmFyIGN1cnJlbnRseU92ZXIgPSB0aGlzLl90ZW1wO1xyXG5cclxuICAgIC8vICAwID0gTm90IGRyYWdnaW5nIGFueXRoaW5nXHJcbiAgICAvLyAgMSA9IFByaW1hcnkgYnV0dG9uIGRvd24gYW5kIG9iamVjdHMgYmVsb3csIHNvIGNvbGxlY3QgYSBkcmFnbGlzdFxyXG4gICAgLy8gIDIgPSBQb2ludGVyIGJlaW5nIGNoZWNrZWQgaWYgbWVldHMgZHJhZyBjcml0ZXJpYVxyXG4gICAgLy8gIDMgPSBQb2ludGVyIG1lZXRzIGNyaXRlcmlhLCBub3RpZnkgdGhlIGRyYWdsaXN0XHJcbiAgICAvLyAgNCA9IFBvaW50ZXIgYWN0aXZlbHkgZHJhZ2dpbmcgdGhlIGRyYWdsaXN0IGFuZCBoYXMgbW92ZWRcclxuICAgIC8vICA1ID0gUG9pbnRlciBhY3RpdmVseSBkcmFnZ2luZyBidXQgaGFzIGJlZW4gcmVsZWFzZWQsIG5vdGlmeSBkcmFnbGlzdFxyXG5cclxuICAgIGlmIChwb2ludGVyLmRyYWdTdGF0ZSA9PT0gMCAmJiBwb2ludGVyLnByaW1hcnlEb3duICYmIHBvaW50ZXIuanVzdERvd24gJiYgY3VycmVudGx5T3Zlci5sZW5ndGggPiAwKVxyXG4gICAge1xyXG4gICAgICAgIHBvaW50ZXIuZHJhZ1N0YXRlID0gMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBvaW50ZXIuZHJhZ1N0YXRlID4gMCAmJiAhcG9pbnRlci5wcmltYXJ5RG93biAmJiBwb2ludGVyLmp1c3RVcClcclxuICAgIHtcclxuICAgICAgICBwb2ludGVyLmRyYWdTdGF0ZSA9IDU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFByb2Nlc3MgdGhlIHZhcmlvdXMgZHJhZyBzdGF0ZXNcclxuXHJcbiAgICAvLyAgMSA9IFByaW1hcnkgYnV0dG9uIGRvd24gYW5kIG9iamVjdHMgYmVsb3csIHNvIGNvbGxlY3QgYSBkcmFnbGlzdFxyXG4gICAgaWYgKHBvaW50ZXIuZHJhZ1N0YXRlID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBHZXQgZHJhZ2dhYmxlIG9iamVjdHMsIHNvcnQgdGhlbSwgcGljayB0aGUgdG9wIChvciBhbGwpIGFuZCBzdG9yZSB0aGVtIHNvbWV3aGVyZVxyXG4gICAgICAgIHZhciBkcmFnbGlzdCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VycmVudGx5T3Zlci5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QgPSBjdXJyZW50bHlPdmVyW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGdhbWVPYmplY3QuaW5wdXQuZHJhZ2dhYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkcmFnbGlzdC5wdXNoKGdhbWVPYmplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZHJhZ2xpc3QubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcG9pbnRlci5kcmFnU3RhdGUgPSAwO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkcmFnbGlzdC5sZW5ndGggPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zb3J0R2FtZU9iamVjdHMoZHJhZ2xpc3QpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudG9wT25seSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZHJhZ2xpc3Quc3BsaWNlKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgZHJhZ2xpc3Qgbm93IGNvbnRhaW5zIGFsbCBwb3RlbnRpYWwgY2FuZGlkYXRlcyBmb3IgZHJhZ2dpbmdcclxuICAgICAgICB0aGlzLl9kcmFnW3BvaW50ZXIuaWRdID0gZHJhZ2xpc3Q7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRyYWdEaXN0YW5jZVRocmVzaG9sZCA9PT0gMCAmJiB0aGlzLmRyYWdUaW1lVGhyZXNob2xkID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIE5vIGRyYWcgY3JpdGVyaWEsIHNvIHNuYXAgaW1tZWRpYXRlbHkgdG8gbW9kZSAzXHJcbiAgICAgICAgICAgIHBvaW50ZXIuZHJhZ1N0YXRlID0gMztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIENoZWNrIHRoZSBkaXN0YW5jZSAvIHRpbWVcclxuICAgICAgICAgICAgcG9pbnRlci5kcmFnU3RhdGUgPSAyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAgMiA9IFBvaW50ZXIgYmVpbmcgY2hlY2tlZCBpZiBtZWV0cyBkcmFnIGNyaXRlcmlhXHJcbiAgICBpZiAocG9pbnRlci5kcmFnU3RhdGUgPT09IDIpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEhhcyBpdCBtb3ZlZCBmYXIgZW5vdWdoIHRvIGJlIGNvbnNpZGVyZWQgYSBkcmFnP1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdEaXN0YW5jZVRocmVzaG9sZCA+IDAgJiYgRGlzdGFuY2VCZXR3ZWVuKHBvaW50ZXIueCwgcG9pbnRlci55LCBwb2ludGVyLmRvd25YLCBwb2ludGVyLmRvd25ZKSA+PSB0aGlzLmRyYWdEaXN0YW5jZVRocmVzaG9sZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBBbHJpZ2h0eSwgd2UndmUgZ290IGEgZHJhZyBnb2luZyBvbiAuLi5cclxuICAgICAgICAgICAgcG9pbnRlci5kcmFnU3RhdGUgPSAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEhlbGQgZG93biBsb25nIGVub3VnaCB0byBiZSBjb25zaWRlcmVkIGEgZHJhZz9cclxuICAgICAgICBpZiAodGhpcy5kcmFnVGltZVRocmVzaG9sZCA+IDAgJiYgKHRpbWUgPj0gcG9pbnRlci5kb3duVGltZSArIHRoaXMuZHJhZ1RpbWVUaHJlc2hvbGQpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEFscmlnaHR5LCB3ZSd2ZSBnb3QgYSBkcmFnIGdvaW5nIG9uIC4uLlxyXG4gICAgICAgICAgICBwb2ludGVyLmRyYWdTdGF0ZSA9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICAzID0gUG9pbnRlciBtZWV0cyBjcml0ZXJpYSBhbmQgaXMgZnJlc2hseSBkb3duLCBub3RpZnkgdGhlIGRyYWdsaXN0XHJcbiAgICBpZiAocG9pbnRlci5kcmFnU3RhdGUgPT09IDMpXHJcbiAgICB7XHJcbiAgICAgICAgbGlzdCA9IHRoaXMuX2RyYWdbcG9pbnRlci5pZF07XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2FtZU9iamVjdCA9IGxpc3RbaV07XHJcblxyXG4gICAgICAgICAgICBpbnB1dCA9IGdhbWVPYmplY3QuaW5wdXQ7XHJcblxyXG4gICAgICAgICAgICBpbnB1dC5kcmFnU3RhdGUgPSAyO1xyXG5cclxuICAgICAgICAgICAgaW5wdXQuZHJhZ1ggPSBwb2ludGVyLnggLSBnYW1lT2JqZWN0Lng7XHJcbiAgICAgICAgICAgIGlucHV0LmRyYWdZID0gcG9pbnRlci55IC0gZ2FtZU9iamVjdC55O1xyXG5cclxuICAgICAgICAgICAgaW5wdXQuZHJhZ1N0YXJ0WCA9IGdhbWVPYmplY3QueDtcclxuICAgICAgICAgICAgaW5wdXQuZHJhZ1N0YXJ0WSA9IGdhbWVPYmplY3QueTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBJbnB1dEV2ZW50LkRSQUdfU1RBUlQocG9pbnRlciwgZ2FtZU9iamVjdCkpO1xyXG5cclxuICAgICAgICAgICAgaW5wdXQub25EcmFnU3RhcnQoZ2FtZU9iamVjdCwgcG9pbnRlciwgaW5wdXQuZHJhZ1gsIGlucHV0LmRyYWdZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBvaW50ZXIuZHJhZ1N0YXRlID0gNDtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICA0ID0gUG9pbnRlciBhY3RpdmVseSBkcmFnZ2luZyB0aGUgZHJhZ2xpc3QgYW5kIGhhcyBtb3ZlZFxyXG4gICAgaWYgKHBvaW50ZXIuZHJhZ1N0YXRlID09PSA0ICYmIHBvaW50ZXIuanVzdE1vdmVkKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBMZXQncyBmaWx0ZXIgb3V0IGN1cnJlbnRseU92ZXIgZm9yIGRyb3Bab25lcyBvbmx5XHJcbiAgICAgICAgdmFyIGRyb3Bab25lcyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGMgPSAwOyBjIDwgY3VycmVudGx5T3Zlci5sZW5ndGg7IGMrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50bHlPdmVyW2NdLmlucHV0LmRyb3Bab25lKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkcm9wWm9uZXMucHVzaChjdXJyZW50bHlPdmVyW2NdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGlzdCA9IHRoaXMuX2RyYWdbcG9pbnRlci5pZF07XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2FtZU9iamVjdCA9IGxpc3RbaV07XHJcblxyXG4gICAgICAgICAgICBpbnB1dCA9IGdhbWVPYmplY3QuaW5wdXQ7XHJcblxyXG4gICAgICAgICAgICAvLyAgSWYgdGhpcyBHTyBoYXMgYSB0YXJnZXQgdGhlbiBsZXQncyBjaGVjayBpdFxyXG4gICAgICAgICAgICBpZiAoaW5wdXQudGFyZ2V0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBkcm9wWm9uZXMuaW5kZXhPZihpbnB1dC50YXJnZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICBHb3QgYSB0YXJnZXQsIGFyZSB3ZSBzdGlsbCBvdmVyIGl0P1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICBXZSdyZSBzdGlsbCBvdmVyIGl0LCBhbmQgaXQncyBzdGlsbCB0aGUgdG9wIG9mIHRoZSBkaXNwbGF5IGxpc3QsIHBoZXcgLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IElucHV0RXZlbnQuRFJBR19PVkVSKHBvaW50ZXIsIGdhbWVPYmplY3QsIGlucHV0LnRhcmdldCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICBTdGlsbCBvdmVyIGl0IGJ1dCBpdCdzIG5vIGxvbmdlciB0b3Agb2YgdGhlIGRpc3BsYXkgbGlzdCAodGFyZ2V0cyBtdXN0IGFsd2F5cyBiZSBhdCB0aGUgdG9wKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBJbnB1dEV2ZW50LkRSQUdfTEVBVkUocG9pbnRlciwgZ2FtZU9iamVjdCwgaW5wdXQudGFyZ2V0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnRhcmdldCA9IGRyb3Bab25lc1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IElucHV0RXZlbnQuRFJBR19FTlRFUihwb2ludGVyLCBnYW1lT2JqZWN0LCBpbnB1dC50YXJnZXQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgTm9wZSwgd2UndmUgbW92ZWQgb24gKG9yIHRoZSB0YXJnZXQgaGFzISksIGxlYXZlIHRoZSBvbGQgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IElucHV0RXZlbnQuRFJBR19MRUFWRShwb2ludGVyLCBnYW1lT2JqZWN0LCBpbnB1dC50YXJnZXQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIEFueXRoaW5nIG5ldyB0byByZXBsYWNlIGl0P1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICBZdXAhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyb3Bab25lc1swXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnRhcmdldCA9IGRyb3Bab25lc1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBJbnB1dEV2ZW50LkRSQUdfRU5URVIocG9pbnRlciwgZ2FtZU9iamVjdCwgaW5wdXQudGFyZ2V0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBOb3BlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpbnB1dC50YXJnZXQgJiYgZHJvcFpvbmVzWzBdKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC50YXJnZXQgPSBkcm9wWm9uZXNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IElucHV0RXZlbnQuRFJBR19FTlRFUihwb2ludGVyLCBnYW1lT2JqZWN0LCBpbnB1dC50YXJnZXQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IElucHV0RXZlbnQuRFJBRyhwb2ludGVyLCBnYW1lT2JqZWN0KSk7XHJcblxyXG4gICAgICAgICAgICBpbnB1dC5vbkRyYWcoZ2FtZU9iamVjdCwgcG9pbnRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICA1ID0gUG9pbnRlciBhY3RpdmVseSBkcmFnZ2luZyBidXQgaGFzIGJlZW4gcmVsZWFzZWQsIG5vdGlmeSBkcmFnbGlzdFxyXG4gICAgaWYgKHBvaW50ZXIuZHJhZ1N0YXRlID09PSA1KVxyXG4gICAge1xyXG4gICAgICAgIGxpc3QgPSB0aGlzLl9kcmFnW3BvaW50ZXIuaWRdO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QgPSBsaXN0W2ldO1xyXG5cclxuICAgICAgICAgICAgaW5wdXQgPSBnYW1lT2JqZWN0LmlucHV0O1xyXG5cclxuICAgICAgICAgICAgaW5wdXQuZHJhZ1N0YXRlID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlucHV0LmRyYWdYID0gaW5wdXQubG9jYWxYIC0gZ2FtZU9iamVjdC5kaXNwbGF5T3JpZ2luWDtcclxuICAgICAgICAgICAgaW5wdXQuZHJhZ1kgPSBpbnB1dC5sb2NhbFkgLSBnYW1lT2JqZWN0LmRpc3BsYXlPcmlnaW5ZO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRyb3BwZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbnB1dC50YXJnZXQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBJbnB1dEV2ZW50LkRST1AocG9pbnRlciwgZ2FtZU9iamVjdCwgaW5wdXQudGFyZ2V0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaW5wdXQudGFyZ2V0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBkcm9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIEFuZCBmaW5hbGx5IHRoZSBkcmFnZW5kIGV2ZW50XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgSW5wdXRFdmVudC5EUkFHX0VORChwb2ludGVyLCBnYW1lT2JqZWN0LCBkcm9wcGVkKSk7XHJcblxyXG4gICAgICAgICAgICBpbnB1dC5vbkRyYWdFbmQoZ2FtZU9iamVjdCwgcG9pbnRlciwgaW5wdXQuZHJhZ1gsIGlucHV0LmRyYWdZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBvaW50ZXIuZHJhZ1N0YXRlID0gMDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc0RyYWdFdmVudHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvaW5jL1Byb2Nlc3NEcmFnRXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIElucHV0RXZlbnQgPSByZXF1aXJlKCcuLi9ldmVudHMnKTtcclxuXHJcbnZhciBQcm9jZXNzTW92ZUV2ZW50cyA9IGZ1bmN0aW9uIChwb2ludGVyKVxyXG57XHJcbiAgICB2YXIgY3VycmVudGx5T3ZlciA9IHRoaXMuX3RlbXA7XHJcblxyXG4gICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IElucHV0RXZlbnQuUE9JTlRFUl9NT1ZFKHBvaW50ZXIsIGN1cnJlbnRseU92ZXIpKTtcclxuXHJcbiAgICAvLyAgR28gdGhyb3VnaCBhbGwgb2JqZWN0cyB0aGUgcG9pbnRlciB3YXMgb3ZlciBhbmQgZmlyZSB0aGVpciBldmVudHMgLyBjYWxsYmFja3NcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudGx5T3Zlci5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2FtZU9iamVjdCA9IGN1cnJlbnRseU92ZXJbaV07XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBJbnB1dEV2ZW50LkdBTUVfT0JKRUNUX01PVkUocG9pbnRlciwgZ2FtZU9iamVjdCkpO1xyXG5cclxuICAgICAgICBnYW1lT2JqZWN0LmlucHV0Lm9uTW92ZShnYW1lT2JqZWN0LCBwb2ludGVyLCBnYW1lT2JqZWN0LmlucHV0LmxvY2FsWCwgZ2FtZU9iamVjdC5pbnB1dC5sb2NhbFkpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy50b3BPbmx5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm9jZXNzTW92ZUV2ZW50cztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9pbmMvUHJvY2Vzc01vdmVFdmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDc1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4uL2V2ZW50cycpO1xyXG5cclxudmFyIFByb2Nlc3NPdmVyT3V0RXZlbnRzID0gZnVuY3Rpb24gKHBvaW50ZXIpXHJcbntcclxuICAgIHZhciBjdXJyZW50bHlPdmVyID0gdGhpcy5fdGVtcDtcclxuXHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBnYW1lT2JqZWN0O1xyXG4gICAgdmFyIGp1c3RPdXQgPSBbXTtcclxuICAgIHZhciBqdXN0T3ZlciA9IFtdO1xyXG4gICAgdmFyIHN0aWxsT3ZlciA9IFtdO1xyXG4gICAgdmFyIHByZXZpb3VzbHlPdmVyID0gdGhpcy5fb3Zlcltwb2ludGVyLmlkXTtcclxuXHJcbiAgICAvLyAgR28gdGhyb3VnaCBhbGwgb2JqZWN0cyB0aGUgcG9pbnRlciB3YXMgcHJldmlvdXNseSBvdmVyLCBhbmQgc2VlIGlmIGl0IHN0aWxsIGlzXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJldmlvdXNseU92ZXIubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZU9iamVjdCA9IHByZXZpb3VzbHlPdmVyW2ldO1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudGx5T3Zlci5pbmRleE9mKGdhbWVPYmplY3QpID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBOb3QgaW4gdGhlIGN1cnJlbnRseU92ZXIgYXJyYXlcclxuICAgICAgICAgICAganVzdE91dC5wdXNoKGdhbWVPYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSW4gdGhlIGN1cnJlbnRseU92ZXIgYXJyYXlcclxuICAgICAgICAgICAgc3RpbGxPdmVyLnB1c2goZ2FtZU9iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBHbyB0aHJvdWdoIHRoZSBoaXQgdGVzdCByZXN1bHRzXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY3VycmVudGx5T3Zlci5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBnYW1lT2JqZWN0ID0gY3VycmVudGx5T3ZlcltpXTtcclxuXHJcbiAgICAgICAgLy8gIElzIHRoaXMgbmV3bHkgb3Zlcj9cclxuXHJcbiAgICAgICAgaWYgKHByZXZpb3VzbHlPdmVyLmluZGV4T2YoZ2FtZU9iamVjdCkgPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAganVzdE92ZXIucHVzaChnYW1lT2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEJ5IHRoaXMgcG9pbnQgdGhlIGFycmF5cyBhcmUgZmlsbGVkLCBzbyBub3cgd2UgY2FuIHByb2Nlc3Mgd2hhdCBoYXBwZW5lZC4uLlxyXG5cclxuICAgIC8vICBQcm9jZXNzIHRoZSBKdXN0IE91dCBvYmplY3RzXHJcbiAgICB2YXIgdG90YWwgPSBqdXN0T3V0Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAodG90YWwgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc29ydEdhbWVPYmplY3RzKGp1c3RPdXQpO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgSW5wdXRFdmVudC5QT0lOVEVSX09VVChwb2ludGVyLCBqdXN0T3V0KSk7XHJcblxyXG4gICAgICAgIC8vICBDYWxsIG9uT3V0IGZvciBldmVyeXRoaW5nIGluIHRoZSBqdXN0T3V0IGFycmF5XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnYW1lT2JqZWN0ID0ganVzdE91dFtpXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBJbnB1dEV2ZW50LkdBTUVfT0JKRUNUX09VVChwb2ludGVyLCBnYW1lT2JqZWN0KSk7XHJcblxyXG4gICAgICAgICAgICBnYW1lT2JqZWN0LmlucHV0Lm9uT3V0KGdhbWVPYmplY3QsIHBvaW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudG9wT25seSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFByb2Nlc3MgdGhlIEp1c3QgT3ZlciBvYmplY3RzXHJcbiAgICB0b3RhbCA9IGp1c3RPdmVyLmxlbmd0aDtcclxuXHJcbiAgICBpZiAodG90YWwgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc29ydEdhbWVPYmplY3RzKGp1c3RPdmVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IElucHV0RXZlbnQuUE9JTlRFUl9PVkVSKHBvaW50ZXIsIGp1c3RPdmVyKSk7XHJcblxyXG4gICAgICAgIC8vICBDYWxsIG9uT3ZlciBmb3IgZXZlcnl0aGluZyBpbiB0aGUganVzdE92ZXIgYXJyYXlcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWw7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QgPSBqdXN0T3ZlcltpXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBJbnB1dEV2ZW50LkdBTUVfT0JKRUNUX09WRVIocG9pbnRlciwgZ2FtZU9iamVjdCkpO1xyXG5cclxuICAgICAgICAgICAgZ2FtZU9iamVjdC5pbnB1dC5vbk92ZXIoZ2FtZU9iamVjdCwgcG9pbnRlciwgZ2FtZU9iamVjdC5pbnB1dC5sb2NhbFgsIGdhbWVPYmplY3QuaW5wdXQubG9jYWxZKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRvcE9ubHkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBBZGQgdGhlIGNvbnRlbnRzIG9mIGp1c3RPdmVyIHRvIHRoZSBwcmV2aW91c2x5IG92ZXIgYXJyYXlcclxuICAgIHByZXZpb3VzbHlPdmVyID0gc3RpbGxPdmVyLmNvbmNhdChqdXN0T3Zlcik7XHJcblxyXG4gICAgLy8gIFRoZW4gc29ydCBpdCBpbnRvIGRpc3BsYXkgbGlzdCBvcmRlclxyXG4gICAgdGhpcy5fb3Zlcltwb2ludGVyLmlkXSA9IHRoaXMuc29ydEdhbWVPYmplY3RzKHByZXZpb3VzbHlPdmVyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc092ZXJPdXRFdmVudHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvaW5jL1Byb2Nlc3NPdmVyT3V0RXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIElucHV0RXZlbnQgPSByZXF1aXJlKCcuLi9ldmVudHMnKTtcclxuXHJcbnZhciBQcm9jZXNzVXBFdmVudHMgPSBmdW5jdGlvbiAocG9pbnRlcilcclxue1xyXG4gICAgdmFyIGN1cnJlbnRseU92ZXIgPSB0aGlzLl90ZW1wO1xyXG5cclxuICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBJbnB1dEV2ZW50LlBPSU5URVJfVVAocG9pbnRlciwgY3VycmVudGx5T3ZlcikpO1xyXG5cclxuICAgIC8vICBHbyB0aHJvdWdoIGFsbCBvYmplY3RzIHRoZSBwb2ludGVyIHdhcyBvdmVyIGFuZCBmaXJlIHRoZWlyIGV2ZW50cyAvIGNhbGxiYWNrc1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50bHlPdmVyLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnYW1lT2JqZWN0ID0gY3VycmVudGx5T3ZlcltpXTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IElucHV0RXZlbnQuR0FNRV9PQkpFQ1RfVVAocG9pbnRlciwgZ2FtZU9iamVjdCkpO1xyXG5cclxuICAgICAgICBnYW1lT2JqZWN0LmlucHV0Lm9uVXAoZ2FtZU9iamVjdCwgcG9pbnRlciwgZ2FtZU9iamVjdC5pbnB1dC5sb2NhbFgsIGdhbWVPYmplY3QuaW5wdXQubG9jYWxZKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudG9wT25seSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc1VwRXZlbnRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9Qcm9jZXNzVXBFdmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDc1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUXVldWVzIGEgR2FtZSBPYmplY3QgZm9yIGluc2VydGlvbiBpbnRvIHRoaXMgSW5wdXQgTWFuYWdlciBvbiB0aGUgbmV4dCB1cGRhdGUuXHJcbnZhciBRdWV1ZUZvckluc2VydGlvbiA9IGZ1bmN0aW9uIChjaGlsZClcclxue1xyXG4gICAgaWYgKHRoaXMuX3BlbmRpbmdJbnNlcnRpb24uaW5kZXhPZihjaGlsZCkgPT09IC0xICYmIHRoaXMuX2xpc3QuaW5kZXhPZihjaGlsZCkgPT09IC0xKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdJbnNlcnRpb24ucHVzaChjaGlsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlRm9ySW5zZXJ0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9RdWV1ZUZvckluc2VydGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBRdWV1ZXMgYSBHYW1lIE9iamVjdCBmb3IgcmVtb3ZhbCBmcm9tIHRoaXMgSW5wdXQgTWFuYWdlciBvbiB0aGUgbmV4dCB1cGRhdGUuXHJcbnZhciBRdWV1ZUZvclJlbW92YWwgPSBmdW5jdGlvbiAoY2hpbGQpXHJcbntcclxuICAgIHRoaXMuX3BlbmRpbmdSZW1vdmFsLnB1c2goY2hpbGQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZUZvclJlbW92YWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvaW5jL1F1ZXVlRm9yUmVtb3ZhbC5qc1xuLy8gbW9kdWxlIGlkID0gNzU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRDYWxsYmFjayA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0cywgdHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpXHJcbntcclxuICAgIGlmICh0aGlzLl92YWxpZFR5cGVzLmluZGV4T2YodHlwZSkgPT09IC0xKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShnYW1lT2JqZWN0cykpXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZU9iamVjdHMgPSBbIGdhbWVPYmplY3RzIF07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lT2JqZWN0cy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2FtZU9iamVjdCA9IGdhbWVPYmplY3RzW2ldO1xyXG5cclxuICAgICAgICBpZiAoZ2FtZU9iamVjdC5pbnB1dClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QuaW5wdXRbdHlwZV0gPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBnYW1lT2JqZWN0LmlucHV0LmNhbGxiYWNrQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhbGxiYWNrO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9TZXRDYWxsYmFjay5qc1xuLy8gbW9kdWxlIGlkID0gNzU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRGYXN0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QvR2V0RmFzdFZhbHVlJyk7XHJcblxyXG52YXIgU2V0Q2FsbGJhY2tzID0gZnVuY3Rpb24gKGdhbWVPYmplY3RzLCBjb25maWcpXHJcbntcclxuICAgIHZhciBvbkRvd24gPSBHZXRGYXN0VmFsdWUoY29uZmlnLCAnb25Eb3duJywgbnVsbCk7XHJcbiAgICB2YXIgb25VcCA9IEdldEZhc3RWYWx1ZShjb25maWcsICdvblVwJywgbnVsbCk7XHJcbiAgICB2YXIgb25PdmVyID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ29uT3ZlcicsIG51bGwpO1xyXG4gICAgdmFyIG9uT3V0ID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ29uT3V0JywgbnVsbCk7XHJcbiAgICB2YXIgb25Nb3ZlID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ29uTW92ZScsIG51bGwpO1xyXG4gICAgdmFyIGNvbnRleHQgPSBHZXRGYXN0VmFsdWUoY29uZmlnLCAnY29udGV4dCcsIG51bGwpO1xyXG5cclxuICAgIGlmIChvbkRvd24pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zZXRPbkRvd25DYWxsYmFjayhnYW1lT2JqZWN0cywgb25Eb3duLCBjb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob25VcClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNldE9uRG93bkNhbGxiYWNrKGdhbWVPYmplY3RzLCBvblVwLCBjb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob25PdmVyKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0T25Eb3duQ2FsbGJhY2soZ2FtZU9iamVjdHMsIG9uT3ZlciwgY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9uT3V0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0T25Eb3duQ2FsbGJhY2soZ2FtZU9iamVjdHMsIG9uT3V0LCBjb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob25Nb3ZlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0T25Nb3ZlQ2FsbGJhY2soZ2FtZU9iamVjdHMsIG9uTW92ZSwgY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhbGxiYWNrcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9pbmMvU2V0Q2FsbGJhY2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0cywgdmFsdWUpXHJcbntcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IHZhbHVlID0gdHJ1ZTsgfVxyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShnYW1lT2JqZWN0cykpXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZU9iamVjdHMgPSBbIGdhbWVPYmplY3RzIF07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lT2JqZWN0cy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2FtZU9iamVjdCA9IGdhbWVPYmplY3RzW2ldO1xyXG5cclxuICAgICAgICBnYW1lT2JqZWN0LmlucHV0LmRyYWdnYWJsZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9kcmFnZ2FibGUuaW5kZXhPZihnYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlICYmIGluZGV4ID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYWdnYWJsZS5wdXNoKGdhbWVPYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgaW5kZXggPiAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYWdnYWJsZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0RHJhZ2dhYmxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9TZXREcmFnZ2FibGUuanNcbi8vIG1vZHVsZSBpZCA9IDc2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW50ZXJhY3RpdmVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9JbnRlcmFjdGl2ZU9iamVjdCcpO1xyXG5cclxudmFyIFNldEhpdEFyZWEgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdHMsIHNoYXBlLCBjYWxsYmFjaylcclxue1xyXG4gICAgaWYgKHNoYXBlID09PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0SGl0QXJlYUZyb21UZXh0dXJlKGdhbWVPYmplY3RzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZ2FtZU9iamVjdHMpKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWVPYmplY3RzID0gWyBnYW1lT2JqZWN0cyBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FtZU9iamVjdHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdhbWVPYmplY3QgPSBnYW1lT2JqZWN0c1tpXTtcclxuXHJcbiAgICAgICAgZ2FtZU9iamVjdC5pbnB1dCA9IEludGVyYWN0aXZlT2JqZWN0KGdhbWVPYmplY3QsIHNoYXBlLCBjYWxsYmFjayk7XHJcblxyXG4gICAgICAgIHRoaXMucXVldWVGb3JJbnNlcnRpb24oZ2FtZU9iamVjdCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldEhpdEFyZWE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvaW5jL1NldEhpdEFyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDc2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2lyY2xlID0gcmVxdWlyZSgnLi4vLi4vLi4vZ2VvbS9jaXJjbGUvQ2lyY2xlJyk7XHJcbnZhciBDaXJjbGVDb250YWlucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2dlb20vY2lyY2xlL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgU2V0SGl0QXJlYUNpcmNsZSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0cywgeCwgeSwgcmFkaXVzLCBjYWxsYmFjaylcclxue1xyXG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHsgY2FsbGJhY2sgPSBDaXJjbGVDb250YWluczsgfVxyXG5cclxuICAgIHZhciBzaGFwZSA9IG5ldyBDaXJjbGUoeCwgeSwgcmFkaXVzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5zZXRIaXRBcmVhKGdhbWVPYmplY3RzLCBzaGFwZSwgY2FsbGJhY2spO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRIaXRBcmVhQ2lyY2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9TZXRIaXRBcmVhQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVsbGlwc2UgPSByZXF1aXJlKCcuLi8uLi8uLi9nZW9tL2VsbGlwc2UvRWxsaXBzZScpO1xyXG52YXIgRWxsaXBzZUNvbnRhaW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgU2V0SGl0QXJlYUVsbGlwc2UgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdHMsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNhbGxiYWNrKVxyXG57XHJcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkgeyBjYWxsYmFjayA9IEVsbGlwc2VDb250YWluczsgfVxyXG5cclxuICAgIHZhciBzaGFwZSA9IG5ldyBFbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnNldEhpdEFyZWEoZ2FtZU9iamVjdHMsIHNoYXBlLCBjYWxsYmFjayk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldEhpdEFyZWFFbGxpcHNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9TZXRIaXRBcmVhRWxsaXBzZS5qc1xuLy8gbW9kdWxlIGlkID0gNzYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJbnRlcmFjdGl2ZU9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL0ludGVyYWN0aXZlT2JqZWN0Jyk7XHJcbnZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi8uLi8uLi9nZW9tL3JlY3RhbmdsZS9SZWN0YW5nbGUnKTtcclxudmFyIFJlY3RhbmdsZUNvbnRhaW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnMnKTtcclxuXHJcbnZhciBTZXRIaXRBcmVhRnJvbVRleHR1cmUgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdHMsIGNhbGxiYWNrKVxyXG57XHJcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkgeyBjYWxsYmFjayA9IFJlY3RhbmdsZUNvbnRhaW5zOyB9XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGdhbWVPYmplY3RzKSlcclxuICAgIHtcclxuICAgICAgICBnYW1lT2JqZWN0cyA9IFsgZ2FtZU9iamVjdHMgXTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdhbWVPYmplY3RzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnYW1lT2JqZWN0ID0gZ2FtZU9iamVjdHNbaV07XHJcbiAgICAgICAgdmFyIGZyYW1lID0gZ2FtZU9iamVjdC5mcmFtZTtcclxuXHJcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKGZyYW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgd2lkdGggPSBmcmFtZS53aWR0aDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChnYW1lT2JqZWN0LndpZHRoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgd2lkdGggPSBnYW1lT2JqZWN0LndpZHRoO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBnYW1lT2JqZWN0LmhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh3aWR0aCAhPT0gMCAmJiBoZWlnaHQgIT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnYW1lT2JqZWN0LmlucHV0ID0gSW50ZXJhY3RpdmVPYmplY3QoZ2FtZU9iamVjdCwgbmV3IFJlY3RhbmdsZSgwLCAwLCB3aWR0aCwgaGVpZ2h0KSwgY2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5xdWV1ZUZvckluc2VydGlvbihnYW1lT2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldEhpdEFyZWFGcm9tVGV4dHVyZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9pbmMvU2V0SGl0QXJlYUZyb21UZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2dlb20vcmVjdGFuZ2xlL1JlY3RhbmdsZScpO1xyXG52YXIgUmVjdGFuZ2xlQ29udGFpbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9nZW9tL3JlY3RhbmdsZS9Db250YWlucycpO1xyXG5cclxudmFyIFNldEhpdEFyZWFSZWN0YW5nbGUgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdHMsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNhbGxiYWNrKVxyXG57XHJcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkgeyBjYWxsYmFjayA9IFJlY3RhbmdsZUNvbnRhaW5zOyB9XHJcblxyXG4gICAgdmFyIHNoYXBlID0gbmV3IFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5zZXRIaXRBcmVhKGdhbWVPYmplY3RzLCBzaGFwZSwgY2FsbGJhY2spO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRIaXRBcmVhUmVjdGFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9TZXRIaXRBcmVhUmVjdGFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRyaWFuZ2xlID0gcmVxdWlyZSgnLi4vLi4vLi4vZ2VvbS90cmlhbmdsZS9UcmlhbmdsZScpO1xyXG52YXIgVHJpYW5nbGVDb250YWlucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2dlb20vdHJpYW5nbGUvQ29udGFpbnMnKTtcclxuXHJcbnZhciBTZXRIaXRBcmVhVHJpYW5nbGUgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdHMsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGNhbGxiYWNrKVxyXG57XHJcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkgeyBjYWxsYmFjayA9IFRyaWFuZ2xlQ29udGFpbnM7IH1cclxuXHJcbiAgICB2YXIgc2hhcGUgPSBuZXcgVHJpYW5nbGUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc2V0SGl0QXJlYShnYW1lT2JqZWN0cywgc2hhcGUsIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0SGl0QXJlYVRyaWFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9TZXRIaXRBcmVhVHJpYW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDc2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0T25Eb3duQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdHMsIGNhbGxiYWNrLCBjb250ZXh0KVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5zZXRDYWxsYmFjayhnYW1lT2JqZWN0cywgJ29uRG93bicsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0T25Eb3duQ2FsbGJhY2s7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvaW5jL1NldE9uRG93bkNhbGxiYWNrLmpzXG4vLyBtb2R1bGUgaWQgPSA3Njdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldE9uTW92ZUNhbGxiYWNrID0gZnVuY3Rpb24gKGdhbWVPYmplY3RzLCBjYWxsYmFjaywgY29udGV4dClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0Q2FsbGJhY2soZ2FtZU9iamVjdHMsICdvbk1vdmUnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldE9uTW92ZUNhbGxiYWNrO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9TZXRPbk1vdmVDYWxsYmFjay5qc1xuLy8gbW9kdWxlIGlkID0gNzY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRPbk91dENhbGxiYWNrID0gZnVuY3Rpb24gKGdhbWVPYmplY3RzLCBjYWxsYmFjaywgY29udGV4dClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0Q2FsbGJhY2soZ2FtZU9iamVjdHMsICdvbk91dCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0T25PdXRDYWxsYmFjaztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9pbmMvU2V0T25PdXRDYWxsYmFjay5qc1xuLy8gbW9kdWxlIGlkID0gNzY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRPbk92ZXJDYWxsYmFjayA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0cywgY2FsbGJhY2ssIGNvbnRleHQpXHJcbntcclxuICAgIHJldHVybiB0aGlzLnNldENhbGxiYWNrKGdhbWVPYmplY3RzLCAnb25PdmVyJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRPbk92ZXJDYWxsYmFjaztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9pbmMvU2V0T25PdmVyQ2FsbGJhY2suanNcbi8vIG1vZHVsZSBpZCA9IDc3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0T25VcENhbGxiYWNrID0gZnVuY3Rpb24gKGdhbWVPYmplY3RzLCBjYWxsYmFjaywgY29udGV4dClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0Q2FsbGJhY2soZ2FtZU9iamVjdHMsICdvblVwJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRPblVwQ2FsbGJhY2s7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbG9jYWwvaW5jL1NldE9uVXBDYWxsYmFjay5qc1xuLy8gbW9kdWxlIGlkID0gNzcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRQb2xsQWx3YXlzID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5wb2xsUmF0ZSA9IDA7XHJcbiAgICB0aGlzLl9wb2xsVGltZXIgPSAwO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRQb2xsQWx3YXlzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9TZXRQb2xsQWx3YXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFBvbGxPbk1vdmUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLnBvbGxSYXRlID0gLTE7XHJcbiAgICB0aGlzLl9wb2xsVGltZXIgPSAwO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRQb2xsT25Nb3ZlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9TZXRQb2xsT25Nb3ZlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFBvbGxSYXRlID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICB0aGlzLnBvbGxSYXRlID0gdmFsdWU7XHJcbiAgICB0aGlzLl9wb2xsVGltZXIgPSAwO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRQb2xsUmF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9pbmMvU2V0UG9sbFJhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDc3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgR2l2ZW4gYW4gYXJyYXkgb2YgR2FtZSBPYmplY3RzLCBzb3J0IHRoZSBhcnJheSBhbmQgcmV0dXJuIGl0LFxyXG4vLyAgc28gdGhhdCB0aGUgb2JqZWN0cyBhcmUgaW4gaW5kZXggb3JkZXIgd2l0aCB0aGUgbG93ZXN0IGF0IHRoZSBib3R0b20uXHJcbnZhciBTb3J0R2FtZU9iamVjdHMgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdHMpXHJcbntcclxuICAgIGlmIChnYW1lT2JqZWN0cy5sZW5ndGggPCAyKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBnYW1lT2JqZWN0cztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNjZW5lLnN5cy5kZXB0aFNvcnQoKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdHMuc29ydCh0aGlzLnNvcnRIYW5kbGVyR08uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNvcnRHYW1lT2JqZWN0cztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9pbmMvU29ydEdhbWVPYmplY3RzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFJldHVybiB0aGUgY2hpbGQgbG93ZXN0IGRvd24gdGhlIGRpc3BsYXkgbGlzdCAod2l0aCB0aGUgc21hbGxlc3QgaW5kZXgpXHJcbnZhciBTb3J0SGFuZGxlckdPID0gZnVuY3Rpb24gKGNoaWxkQSwgY2hpbGRCKVxyXG57XHJcbiAgICAvLyAgVGhlIGhpZ2hlciB0aGUgaW5kZXgsIHRoZSBsb3dlciBkb3duIHRoZSBkaXNwbGF5IGxpc3QgdGhleSBhcmUuXHJcbiAgICAvLyAgU28gZW50cnkgMCB3aWxsIGJlIHRoZSB0b3AtbW9zdCBpdGVtICh2aXN1YWxseSlcclxuICAgIHZhciBpbmRleEEgPSB0aGlzLmRpc3BsYXlMaXN0LmdldEluZGV4KGNoaWxkQSk7XHJcbiAgICB2YXIgaW5kZXhCID0gdGhpcy5kaXNwbGF5TGlzdC5nZXRJbmRleChjaGlsZEIpO1xyXG5cclxuICAgIGlmIChpbmRleEEgPCBpbmRleEIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpbmRleEEgPiBpbmRleEIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBUZWNobmljYWxseSB0aGlzIHNob3VsZG4ndCBoYXBwZW4sIGJ1dCBpZiB0aGUgR08gd2Fzbid0IHBhcnQgb2YgdGhpcyBkaXNwbGF5IGxpc3QgdGhlbiBpdCdsbFxyXG4gICAgLy8gIGhhdmUgYW4gaW5kZXggb2YgLTEsIHNvIGluIHNvbWUgY2FzZXMgaXQgY2FuXHJcbiAgICByZXR1cm4gMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU29ydEhhbmRsZXJHTztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9pbmMvU29ydEhhbmRsZXJHTy5qc1xuLy8gbW9kdWxlIGlkID0gNzc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBSZXR1cm4gdGhlIGNoaWxkIGxvd2VzdCBkb3duIHRoZSBkaXNwbGF5IGxpc3QgKHdpdGggdGhlIHNtYWxsZXN0IGluZGV4KVxyXG52YXIgU29ydEhhbmRsZXJJTyA9IGZ1bmN0aW9uIChjaGlsZEEsIGNoaWxkQilcclxue1xyXG4gICAgLy8gIFRoZSBoaWdoZXIgdGhlIGluZGV4LCB0aGUgbG93ZXIgZG93biB0aGUgZGlzcGxheSBsaXN0IHRoZXkgYXJlLlxyXG4gICAgLy8gIFNvIGVudHJ5IDAgd2lsbCBiZSB0aGUgdG9wLW1vc3QgaXRlbSAodmlzdWFsbHkpXHJcbiAgICB2YXIgaW5kZXhBID0gdGhpcy5kaXNwbGF5TGlzdC5nZXRJbmRleChjaGlsZEEuZ2FtZU9iamVjdCk7XHJcbiAgICB2YXIgaW5kZXhCID0gdGhpcy5kaXNwbGF5TGlzdC5nZXRJbmRleChjaGlsZEIuZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgaWYgKGluZGV4QSA8IGluZGV4QilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGluZGV4QSA+IGluZGV4QilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFRlY2huaWNhbGx5IHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0IGlmIHRoZSBHTyB3YXNuJ3QgcGFydCBvZiB0aGlzIGRpc3BsYXkgbGlzdCB0aGVuIGl0J2xsXHJcbiAgICAvLyAgaGF2ZSBhbiBpbmRleCBvZiAtMSwgc28gaW4gc29tZSBjYXNlcyBpdCBjYW5cclxuICAgIHJldHVybiAwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTb3J0SGFuZGxlcklPO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9Tb3J0SGFuZGxlcklPLmpzXG4vLyBtb2R1bGUgaWQgPSA3Nzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEdpdmVuIGFuIGFycmF5IG9mIEludGVyYWN0aXZlIE9iamVjdHMsIHNvcnQgdGhlIGFycmF5IGFuZCByZXR1cm4gaXQsXHJcbi8vICBzbyB0aGF0IHRoZSBvYmplY3RzIGFyZSBpbiBpbmRleCBvcmRlciB3aXRoIHRoZSBsb3dlc3QgYXQgdGhlIGJvdHRvbS5cclxudmFyIFNvcnRJbnRlcmFjdGl2ZU9iamVjdHMgPSBmdW5jdGlvbiAoaW50ZXJhY3RpdmVPYmplY3RzKVxyXG57XHJcbiAgICBpZiAoaW50ZXJhY3RpdmVPYmplY3RzLmxlbmd0aCA8IDIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyYWN0aXZlT2JqZWN0cztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNjZW5lLnN5cy5kZXB0aFNvcnQoKTtcclxuXHJcbiAgICByZXR1cm4gaW50ZXJhY3RpdmVPYmplY3RzLnNvcnQodGhpcy5zb3J0SGFuZGxlcklPLmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTb3J0SW50ZXJhY3RpdmVPYmplY3RzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2xvY2FsL2luYy9Tb3J0SW50ZXJhY3RpdmVPYmplY3RzLmpzXG4vLyBtb2R1bGUgaWQgPSA3Nzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFVwZGF0ZSA9IGZ1bmN0aW9uICh0aW1lLCBkZWx0YSlcclxue1xyXG4gICAgdmFyIHBvaW50ZXIgPSB0aGlzLm1hbmFnZXIuYWN0aXZlUG9pbnRlcjtcclxuXHJcbiAgICB2YXIgcnVuVXBkYXRlID0gKHBvaW50ZXIuZGlydHkgfHwgdGhpcy5wb2xsUmF0ZSA9PT0gMCk7XHJcblxyXG4gICAgaWYgKHRoaXMucG9sbFJhdGUgPiAtMSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9wb2xsVGltZXIgLT0gZGVsdGE7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9wb2xsVGltZXIgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcnVuVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vICBEaXNjYXJkIHRpbWVyIGRpZmZcclxuICAgICAgICAgICAgdGhpcy5fcG9sbFRpbWVyID0gdGhpcy5wb2xsUmF0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJ1blVwZGF0ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLl90ZW1wID0gdGhpcy5oaXRUZXN0UG9pbnRlcihwb2ludGVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5zb3J0R2FtZU9iamVjdHModGhpcy5fdGVtcCk7XHJcblxyXG4gICAgICAgIHRoaXMucHJvY2Vzc0RyYWdFdmVudHMocG9pbnRlciwgdGltZSk7XHJcblxyXG4gICAgICAgIHRoaXMucHJvY2Vzc092ZXJPdXRFdmVudHMocG9pbnRlcik7XHJcblxyXG4gICAgICAgIGlmIChwb2ludGVyLmp1c3REb3duKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRG93bkV2ZW50cyhwb2ludGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwb2ludGVyLmp1c3RVcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1VwRXZlbnRzKHBvaW50ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBvaW50ZXIuanVzdE1vdmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTW92ZUV2ZW50cyhwb2ludGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVwZGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9sb2NhbC9pbmMvVXBkYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA3Nzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgTW91c2VEb3duRXZlbnQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEV2ZW50LFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gTW91c2VEb3duRXZlbnQgKG5hdGl2ZUV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ01PVVNFX0RPV05fRVZFTlQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmF0aXZlRXZlbnQ7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IG5hdGl2ZUV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgdGhpcy55ID0gbmF0aXZlRXZlbnQuY2xpZW50WTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZURvd25FdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9tb3VzZS9ldmVudHMvTW91c2VEb3duRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDc4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBNb3VzZU1vdmVFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBNb3VzZU1vdmVFdmVudCAobmF0aXZlRXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCAnTU9VU0VfTU9WRV9FVkVOVCcpO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEgPSBuYXRpdmVFdmVudDtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gbmF0aXZlRXZlbnQuY2xpZW50WDtcclxuICAgICAgICB0aGlzLnkgPSBuYXRpdmVFdmVudC5jbGllbnRZO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlTW92ZUV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L21vdXNlL2V2ZW50cy9Nb3VzZU1vdmVFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIE1vdXNlVXBFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBNb3VzZVVwRXZlbnQgKG5hdGl2ZUV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgJ01PVVNFX1VQX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5hdGl2ZUV2ZW50O1xyXG5cclxuICAgICAgICB0aGlzLnggPSBuYXRpdmVFdmVudC5jbGllbnRYO1xyXG4gICAgICAgIHRoaXMueSA9IG5hdGl2ZUV2ZW50LmNsaWVudFk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2VVcEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L21vdXNlL2V2ZW50cy9Nb3VzZVVwRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDc4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLklucHV0Lk1vdXNlLkV2ZW50c1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBET1dOOiByZXF1aXJlKCcuL01vdXNlRG93bkV2ZW50JyksXHJcbiAgICBVUDogcmVxdWlyZSgnLi9Nb3VzZVVwRXZlbnQnKSxcclxuICAgIE1PVkU6IHJlcXVpcmUoJy4vTW91c2VNb3ZlRXZlbnQnKVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L21vdXNlL2V2ZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuSW5wdXQuTW91c2VcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE1vdXNlTWFuYWdlcjogcmVxdWlyZSgnLi9Nb3VzZU1hbmFnZXInKSBcclxuICAgICAgIFxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L21vdXNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3ODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHNcclxuLy8gaHR0cHM6Ly9wYXRyaWNraGxhdWtlLmdpdGh1Yi5pby90b3VjaC90ZXN0cy9yZXN1bHRzL1xyXG4vLyBodHRwczovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi9tb2JpbGUvdG91Y2gvXHJcblxyXG52YXIgVG91Y2hNYW5hZ2VyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFRvdWNoTWFuYWdlciAoaW5wdXRNYW5hZ2VyKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IGlucHV0TWFuYWdlcjtcclxuXHJcbiAgICAgICAgLy8gQHByb3BlcnR5IHtib29sZWFufSBjYXB0dXJlIC0gSWYgdHJ1ZSB0aGUgRE9NIGV2ZW50cyB3aWxsIGhhdmUgZXZlbnQucHJldmVudERlZmF1bHQgYXBwbGllZCB0byB0aGVtLCBpZiBmYWxzZSB0aGV5IHdpbGwgcHJvcGFnYXRlIGZ1bGx5LlxyXG4gICAgICAgIHRoaXMuY2FwdHVyZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy50YXJnZXQ7XHJcblxyXG4gICAgICAgIHRoaXMuaGFuZGxlcjtcclxuICAgIH0sXHJcblxyXG4gICAgYm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5tYW5hZ2VyLmNvbmZpZztcclxuXHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gY29uZmlnLmlucHV0VG91Y2g7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBjb25maWcuaW5wdXRUb3VjaEV2ZW50VGFyZ2V0O1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLm1hbmFnZXIuZ2FtZS5jYW52YXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydExpc3RlbmVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5tYW5hZ2VyLnF1ZXVlO1xyXG5cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdGVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGV2ZW50IGFscmVhZHkgaGFuZGxlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhldmVudCk7XHJcblxyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jYXB0dXJlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3BMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVyKTtcclxuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG91Y2hNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L3RvdWNoL1RvdWNoTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBTZXQgPSByZXF1aXJlKCcuLi9zdHJ1Y3RzL1NldCcpO1xyXG52YXIgWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL1hIUlNldHRpbmdzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnRzLycpO1xyXG4vLyB2YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG52YXIgUGFyc2VYTUxCaXRtYXBGb250ID0gcmVxdWlyZSgnLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9QYXJzZVhNTEJpdG1hcEZvbnQnKTtcclxuXHJcbi8vICBQaGFzZXIuTG9hZGVyLkJhc2VMb2FkZXJcclxuXHJcbi8vICBUbyBmaW5pc2ggdGhlIGxvYWRlciAuLi5cclxuLy8gIFxyXG4vLyAgMykgUHJvZ3Jlc3MgdXBkYXRlXHJcblxyXG52YXIgQmFzZUxvYWRlciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBCYXNlTG9hZGVyIChzY2VuZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gc2NlbmUuc3lzLmV2ZW50cztcclxuXHJcbiAgICAgICAgLy8gIE1vdmUgdG8gYSAnc2V0VVJMJyBtZXRob2Q/XHJcbiAgICAgICAgdGhpcy5iYXNlVVJMID0gJyc7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gJyc7XHJcblxyXG4gICAgICAgIC8vICBSZWFkIGZyb20gR2FtZSAvIFNjZW5lIENvbmZpZ1xyXG4gICAgICAgIHRoaXMuZW5hYmxlUGFyYWxsZWwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubWF4UGFyYWxsZWxEb3dubG9hZHMgPSA0O1xyXG5cclxuICAgICAgICAvLyAgeGhyIHNwZWNpZmljIGdsb2JhbCBzZXR0aW5ncyAoY2FuIGJlIG92ZXJyaWRkZW4gb24gYSBwZXItZmlsZSBiYXNpcylcclxuICAgICAgICB0aGlzLnhociA9IFhIUlNldHRpbmdzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmluZmxpZ2h0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuZmFpbGVkID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMucXVldWUgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gbmV3IFNldCgpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuTE9BREVSX0lETEU7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBhdGg6IGZ1bmN0aW9uIChwYXRoKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChwYXRoLnN1YnN0cigtMSkgIT09ICcvJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLmNvbmNhdCgnLycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEZpbGU6IGZ1bmN0aW9uIChmaWxlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1JlYWR5KCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmaWxlLnBhdGggPSB0aGlzLnBhdGg7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdC5zZXQoZmlsZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgSXMgdGhlIExvYWRlciBhY3RpdmVseSBsb2FkaW5nIChvciBwcm9jZXNzaW5nIGxvYWRlZCBmaWxlcylcclxuICAgIGlzTG9hZGluZzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09IENPTlNULkxPQURFUl9MT0FESU5HIHx8IHRoaXMuc3RhdGUgPT09IENPTlNULkxPQURFUl9QUk9DRVNTSU5HKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIElzIHRoZSBMb2FkZXIgcmVhZHkgdG8gc3RhcnQgYSBuZXcgbG9hZD9cclxuICAgIGlzUmVhZHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlID09PSBDT05TVC5MT0FERVJfSURMRSB8fCB0aGlzLnN0YXRlID09PSBDT05TVC5MT0FERVJfQ09NUExFVEUgfHwgdGhpcy5zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX0ZBSUxFRCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc2NlbmUuc3lzLnNldHRpbmdzLmtleSwgJy0gQmFzZUxvYWRlciBzdGFydC4gRmlsZXMgdG8gbG9hZDonLCB0aGlzLmxpc3Quc2l6ZSk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5pc1JlYWR5KCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuTE9BREVSX1NUQVJUX0VWRU5UKHRoaXMpKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGlzdC5zaXplID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZExvYWRpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkxPQURFUl9MT0FESU5HO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWlsZWQuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5pbmZsaWdodC5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmRlYnVnID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xvYWRRdWV1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwcm9jZXNzTG9hZFF1ZXVlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCc9PT09PT09PSBCYXNlTG9hZGVyIHByb2Nlc3NMb2FkUXVldWUnKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnTGlzdCBzaXplJywgdGhpcy5saXN0LnNpemUpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuaW5mbGlnaHQuc2l6ZSwgJ2l0ZW1zIHN0aWxsIGluIGZsaWdodC4gQ2FuIGxvYWQgYW5vdGhlcicsICh0aGlzLm1heFBhcmFsbGVsRG93bmxvYWRzIC0gdGhpcy5pbmZsaWdodC5zaXplKSk7XHJcblxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdC5lYWNoKGZ1bmN0aW9uIChmaWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfUEVORElORyAmJiBfdGhpcy5pbmZsaWdodC5zaXplIDwgX3RoaXMubWF4UGFyYWxsZWxEb3dubG9hZHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmluZmxpZ2h0LnNldChmaWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5saXN0LmRlbGV0ZShmaWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkRmlsZShmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF90aGlzLmluZmxpZ2h0LnNpemUgPT09IF90aGlzLm1heFBhcmFsbGVsRG93bmxvYWRzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgVGVsbHMgdGhlIFNldCBpdGVyYXRvciB0byBhYm9ydFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgcHJpdmF0ZVxyXG4gICAgbG9hZEZpbGU6IGZ1bmN0aW9uIChmaWxlKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMT0FESU5HJywgZmlsZS5rZXkpO1xyXG5cclxuICAgICAgICAvLyAgSWYgdGhlIGZpbGUgZG9lc24ndCBoYXZlIGl0cyBvd24gY3Jvc3NPcmlnaW4gc2V0LFxyXG4gICAgICAgIC8vICB3ZSdsbCB1c2UgdGhlIExvYWRlcnMgKHdoaWNoIGlzIHVuZGVmaW5lZCBieSBkZWZhdWx0KVxyXG4gICAgICAgIGlmICghZmlsZS5jcm9zc09yaWdpbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmlsZS5sb2FkKHRoaXMubmV4dEZpbGUuYmluZCh0aGlzKSwgdGhpcy5iYXNlVVJMKTtcclxuICAgIH0sXHJcblxyXG4gICAgbmV4dEZpbGU6IGZ1bmN0aW9uIChwcmV2aW91c0ZpbGUsIHN1Y2Nlc3MpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xPQURFRDonLCBwcmV2aW91c0ZpbGUuc3JjLCBzdWNjZXNzKTtcclxuXHJcbiAgICAgICAgLy8gIE1vdmUgdGhlIGZpbGUgdGhhdCBqdXN0IGxvYWRlZCBmcm9tIHRoZSBpbmZsaWdodCBsaXN0IHRvIHRoZSBxdWV1ZSBvciBmYWlsZWQgU2V0XHJcblxyXG4gICAgICAgIGlmIChzdWNjZXNzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5zZXQocHJldmlvdXNGaWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5mYWlsZWQuc2V0KHByZXZpb3VzRmlsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmluZmxpZ2h0LmRlbGV0ZShwcmV2aW91c0ZpbGUpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5saXN0LnNpemUgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ25leHRGaWxlIC0gc3RpbGwgc29tZXRoaW5nIGluIHRoZSBsaXN0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xvYWRRdWV1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmluZmxpZ2h0LnNpemUgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbmV4dEZpbGUgY2FsbGluZyBmaW5pc2hlZExvYWRpbmcnKTtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZExvYWRpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmlzaGVkTG9hZGluZzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tPiBCYXNlTG9hZGVyLmZpbmlzaGVkTG9hZGluZyBQUk9DRVNTSU5HJywgdGhpcy5xdWV1ZS5zaXplLCAnZmlsZXMnKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkxPQURFUl9QUk9DRVNTSU5HO1xyXG5cclxuICAgICAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5xdWV1ZS5lYWNoKGZ1bmN0aW9uIChmaWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyVjIENhbGxpbmcgcHJvY2VzcyBvbiAnICsgZmlsZS5rZXksICdjb2xvcjogIzAwMDAwMDsgYmFja2dyb3VuZDogI2ZmZmYwMDsnKTtcclxuXHJcbiAgICAgICAgICAgIGZpbGUub25Qcm9jZXNzKF90aGlzLnByb2Nlc3NVcGRhdGUuYmluZChfdGhpcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIEZpbGUgd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZ1xyXG4gICAgcHJvY2Vzc1VwZGF0ZTogZnVuY3Rpb24gKGZpbGUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0+IHByb2Nlc3NVcGRhdGUnLCBmaWxlLmtleSwgZmlsZS5zdGF0ZSk7XHJcblxyXG4gICAgICAgIC8vICBUaGlzIGZpbGUgaGFzIGZhaWxlZCB0byBsb2FkLCBzbyBtb3ZlIGl0IHRvIHRoZSBmYWlsZWQgU2V0XHJcbiAgICAgICAgaWYgKGZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfRVJST1JFRClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkLnNldChmaWxlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmaWxlLmxpbmtGaWxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRlbGV0ZShmaWxlLmxpbmtGaWxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlRnJvbVF1ZXVlKGZpbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIElmIHdlIGdvdCBoZXJlLCB0aGVuIHRoZSBmaWxlIGxvYWRlZFxyXG5cclxuICAgICAgICAvLyAgU3BlY2lhbCBoYW5kbGluZyBmb3IgbXVsdGktcGFydCBmaWxlc1xyXG5cclxuICAgICAgICBpZiAoZmlsZS5saW5rRmlsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChmaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX0NPTVBMRVRFICYmIGZpbGUubGlua0ZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfQ09NUExFVEUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBQYXJ0bmVyIGhhcyBsb2FkZWQsIHNvIGFkZCB0aGVtIGJvdGggdG8gU3RvcmFnZVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoeyB0eXBlOiBmaWxlLmxpbmtUeXBlLCBmaWxlQTogZmlsZSwgZmlsZUI6IGZpbGUubGlua0ZpbGUgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kZWxldGUoZmlsZS5saW5rRmlsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tUXVldWUoZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldChmaWxlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVF1ZXVlKGZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlRnJvbVF1ZXVlOiBmdW5jdGlvbiAoZmlsZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnF1ZXVlLmRlbGV0ZShmaWxlKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucXVldWUuc2l6ZSA9PT0gMCAmJiB0aGlzLnN0YXRlID09PSBDT05TVC5MT0FERVJfUFJPQ0VTU0lORylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBXZSd2ZSBwcm9jZXNzZWQgYWxsIHRoZSBmaWxlcyB3ZSBsb2FkZWRcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3NDb21wbGV0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnNjZW5lLnN5cy5zZXR0aW5ncy5rZXksICctIExvYWRlciBDb21wbGV0ZS4gTG9hZGVkOicsIHRoaXMuc3RvcmFnZS5zaXplLCAnRmFpbGVkOicsIHRoaXMuZmFpbGVkLnNpemUpO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3QuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmluZmxpZ2h0LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLnByb2Nlc3NDYWxsYmFjaygpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuTE9BREVSX0NPTVBMRVRFO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuTE9BREVSX0NPTVBMRVRFX0VWRU5UKHRoaXMpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFRoZSBMb2FkZXIgaGFzIGZpbmlzaGVkXHJcbiAgICBwcm9jZXNzQ2FsbGJhY2s6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5zaXplID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFRoZSBnbG9iYWwgVGV4dHVyZSBNYW5hZ2VyXHJcbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5zY2VuZS5zeXMuY2FjaGU7XHJcbiAgICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy5zY2VuZS5zeXMudGV4dHVyZXM7XHJcbiAgICAgICAgdmFyIGFuaW1zID0gdGhpcy5zY2VuZS5zeXMuYW5pbXM7XHJcblxyXG4gICAgICAgIC8vICBQcm9jZXNzIG11bHRpYXRsYXMgZ3JvdXBzIGZpcnN0XHJcblxyXG4gICAgICAgIHZhciBmaWxlO1xyXG4gICAgICAgIHZhciBmaWxlQTtcclxuICAgICAgICB2YXIgZmlsZUI7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9tdWx0aWxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VzID0gW107XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5fbXVsdGlsaXN0W2tleV07XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZpbGUgPSB0aGlzLnN0b3JhZ2UuZ2V0KCdrZXknLCBrZXlzW2ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS50eXBlID09PSAnaW1hZ2UnKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLnB1c2goZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlsZS50eXBlID09PSAnanNvbicpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5kZWxldGUoZmlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vICBEbyB3ZSBoYXZlIGV2ZXJ5dGhpbmcgbmVlZGVkP1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2VzLmxlbmd0aCArIGRhdGEubGVuZ3RoID09PSBrZXlzLmxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFl1cCwgYWRkIHRoZW0gdG8gdGhlIFRleHR1cmUgTWFuYWdlclxyXG5cclxuICAgICAgICAgICAgICAgIC8vICBJcyB0aGUgZGF0YSBKU09OIEhhc2ggb3IgSlNPTiBBcnJheT9cclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbMF0uZnJhbWVzKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhc0pTT05BcnJheShrZXksIGltYWdlcywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkQXRsYXNKU09OSGFzaChrZXksIGltYWdlcywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBQcm9jZXNzIGFsbCBvZiB0aGUgZmlsZXNcclxuXHJcbiAgICAgICAgLy8gIEJlY2F1c2UgQW5pbWF0aW9uSlNPTiBtYXkgcmVxdWlyZSBpbWFnZXMgdG8gYmUgbG9hZGVkIGZpcnN0LCB3ZSBwcm9jZXNzIHRoZW0gbGFzdFxyXG4gICAgICAgIHZhciBhbmltSlNPTiA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnN0b3JhZ2UuZWFjaChmdW5jdGlvbiAoZmlsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZmlsZS50eXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhbmltYXRpb25KU09OJzpcclxuICAgICAgICAgICAgICAgICAgICBhbmltSlNPTi5wdXNoKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N2Zyc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdodG1sJzpcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRJbWFnZShmaWxlLmtleSwgZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdhdGxhc2pzb24nOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmaWxlQSA9IGZpbGUuZmlsZUE7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZUIgPSBmaWxlLmZpbGVCO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUEudHlwZSA9PT0gJ2ltYWdlJylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZEF0bGFzKGZpbGVBLmtleSwgZmlsZUEuZGF0YSwgZmlsZUIuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZEF0bGFzKGZpbGVCLmtleSwgZmlsZUIuZGF0YSwgZmlsZUEuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3VuaXR5YXRsYXMnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmaWxlQSA9IGZpbGUuZmlsZUE7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZUIgPSBmaWxlLmZpbGVCO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUEudHlwZSA9PT0gJ2ltYWdlJylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZFVuaXR5QXRsYXMoZmlsZUEua2V5LCBmaWxlQS5kYXRhLCBmaWxlQi5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkVW5pdHlBdGxhcyhmaWxlQi5rZXksIGZpbGVCLmRhdGEsIGZpbGVBLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdiaXRtYXBmb250JzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZUEgPSBmaWxlLmZpbGVBO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVCID0gZmlsZS5maWxlQjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVBLnR5cGUgPT09ICdpbWFnZScpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5iaXRtYXBGb250LmFkZChmaWxlQi5rZXksIHsgZGF0YTogUGFyc2VYTUxCaXRtYXBGb250KGZpbGVCLmRhdGEpLCB0ZXh0dXJlOiBmaWxlQS5rZXksIGZyYW1lOiBudWxsIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRJbWFnZShmaWxlQS5rZXksIGZpbGVBLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5iaXRtYXBGb250LmFkZChmaWxlQS5rZXksIHsgZGF0YTogUGFyc2VYTUxCaXRtYXBGb250KGZpbGVBLmRhdGEpLCB0ZXh0dXJlOiBmaWxlQi5rZXksIGZyYW1lOiBudWxsIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRJbWFnZShmaWxlQi5rZXksIGZpbGVCLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdzcHJpdGVzaGVldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkU3ByaXRlU2hlZXQoZmlsZS5rZXksIGZpbGUuZGF0YSwgZmlsZS5jb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmpzb24uYWRkKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3htbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUueG1sLmFkZChmaWxlLmtleSwgZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZS50ZXh0LmFkZChmaWxlLmtleSwgZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdiaW5hcnknOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmJpbmFyeS5hZGQoZmlsZS5rZXksIGZpbGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc291bmQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnNvdW5kLmFkZChmaWxlLmtleSwgZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdnbHNsJzpcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zaGFkZXIuYWRkKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGFuaW1KU09OLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbmltcy5mcm9tSlNPTihmaWxlLmRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5saXN0LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5pbmZsaWdodC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuZmFpbGVkLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGwoJ0xPQURFUl9TVEFSVF9FVkVOVCcpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbCgnTE9BREVSX0NPTVBMRVRFX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIHRoaXMudGFnID0gJyc7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gJyc7XHJcbiAgICAgICAgdGhpcy5iYXNlVVJMID0gJyc7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5MT0FERVJfSURMRTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkxPQURFUl9ERVNUUk9ZRUQ7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFzZUxvYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvQmFzZUxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRVUkwgPSBmdW5jdGlvbiAoZmlsZSwgYmFzZVVSTClcclxue1xyXG4gICAgaWYgKCFmaWxlLnVybClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpbGUudXJsLm1hdGNoKC9eKD86YmxvYjp8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfFxcL1xcLykvKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmlsZS51cmw7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VVUkwgKyBmaWxlLnVybDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VVJMO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9HZXRVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDc4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWVyZ2VYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vTWVyZ2VYSFJTZXR0aW5ncycpO1xyXG5cclxudmFyIFhIUkxvYWRlciA9IGZ1bmN0aW9uIChmaWxlLCBnbG9iYWxYSFJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGNvbmZpZyA9IE1lcmdlWEhSU2V0dGluZ3MoZ2xvYmFsWEhSU2V0dGluZ3MsIGZpbGUueGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbiAgICB4aHIub3BlbignR0VUJywgZmlsZS5zcmMsIGNvbmZpZy5hc3luYywgY29uZmlnLnVzZXIsIGNvbmZpZy5wYXNzd29yZCk7XHJcblxyXG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGZpbGUueGhyU2V0dGluZ3MucmVzcG9uc2VUeXBlO1xyXG4gICAgeGhyLnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcclxuXHJcbiAgICBpZiAoY29uZmlnLmhlYWRlciAmJiBjb25maWcuaGVhZGVyVmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoY29uZmlnLmhlYWRlciwgY29uZmlnLmhlYWRlclZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0LCB0aGUgeGhyLnJlc3BvbnNlIHByb3BlcnR5IHdpbGwgY29udGFpbiB0aGUgcmVxdWVzdGVkIGRhdGEgYXMgYSBET01TdHJpbmcsIEFycmF5QnVmZmVyLCBCbG9iLCBvciBEb2N1bWVudCAoZGVwZW5kaW5nIG9uIHdoYXQgd2FzIHNldCBmb3IgcmVzcG9uc2VUeXBlLilcclxuXHJcbiAgICB4aHIub25sb2FkID0gZmlsZS5vbkxvYWQuYmluZChmaWxlKTtcclxuICAgIHhoci5vbmVycm9yID0gZmlsZS5vbkVycm9yLmJpbmQoZmlsZSk7XHJcbiAgICB4aHIub25wcm9ncmVzcyA9IGZpbGUub25Qcm9ncmVzcy5iaW5kKGZpbGUpO1xyXG5cclxuICAgIC8vICBUaGlzIGlzIHRoZSBvbmx5IHN0YW5kYXJkIG1ldGhvZCwgdGhlIG9uZXMgYWJvdmUgYXJlIGJyb3dzZXIgYWRkaXRpb25zIChtYXliZSBub3QgdW5pdmVyc2FsPylcclxuICAgIC8vIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2VcclxuXHJcbiAgICB4aHIuc2VuZCgpO1xyXG5cclxuICAgIHJldHVybiB4aHI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvWEhSTG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3ODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgTG9hZGVyQ29tcGxldGVFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBMb2FkZXJDb21wbGV0ZUV2ZW50IChsb2FkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCAnTE9BREVSX0NPTVBMRVRFX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbG9hZGVyO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlckNvbXBsZXRlRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2V2ZW50cy9Mb2FkZXJDb21wbGV0ZUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3ODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgTG9hZGVyU3RhcnRFdmVudCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRXZlbnQsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBMb2FkZXJTdGFydEV2ZW50IChsb2FkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCAnTE9BREVSX1NUQVJUX0VWRU5UJyk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbG9hZGVyO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlclN0YXJ0RXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2V2ZW50cy9Mb2FkZXJTdGFydEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3OTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgTE9BREVSX1NUQVJUX0VWRU5UOiByZXF1aXJlKCcuL0xvYWRlclN0YXJ0RXZlbnQnKSxcclxuICAgIExPQURFUl9DT01QTEVURV9FVkVOVDogcmVxdWlyZSgnLi9Mb2FkZXJDb21wbGV0ZUV2ZW50JylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2V2ZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBKU09ORmlsZSA9IHJlcXVpcmUoJy4vSlNPTkZpbGUuanMnKTtcclxuXHJcbnZhciBBbmltYXRpb25KU09ORmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBqc29uID0gbmV3IEpTT05GaWxlKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncyk7XHJcblxyXG4gICAgLy8gIE92ZXJyaWRlIHRoZSBGaWxlIHR5cGVcclxuICAgIGpzb24udHlwZSA9ICdhbmltYXRpb25KU09OJztcclxuXHJcbiAgICByZXR1cm4ganNvbjtcclxufTtcclxuXHJcbkFuaW1hdGlvbkpTT05GaWxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChsb2FkZXIsIGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBJZiBpdCdzIGFuIGFycmF5IGl0IGhhcyB0byBiZSBhbiBhcnJheSBvZiBPYmplY3RzLCBzbyB3ZSBnZXQgZXZlcnl0aGluZyBvdXQgb2YgdGhlICdrZXknIG9iamVjdFxyXG4gICAgICAgICAgICBsb2FkZXIuYWRkRmlsZShuZXcgQW5pbWF0aW9uSlNPTkZpbGUoa2V5W2ldLCB1cmwsIGxvYWRlci5wYXRoLCB4aHJTZXR0aW5ncykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBsb2FkZXIuYWRkRmlsZShuZXcgQW5pbWF0aW9uSlNPTkZpbGUoa2V5LCB1cmwsIGxvYWRlci5wYXRoLCB4aHJTZXR0aW5ncykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBGb3IgbWV0aG9kIGNoYWluaW5nXHJcbiAgICByZXR1cm4gbG9hZGVyO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb25KU09ORmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvZmlsZXR5cGVzL0FuaW1hdGlvbkpTT05GaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEltYWdlRmlsZSA9IHJlcXVpcmUoJy4vSW1hZ2VGaWxlLmpzJyk7XHJcbnZhciBKU09ORmlsZSA9IHJlcXVpcmUoJy4vSlNPTkZpbGUuanMnKTtcclxuXHJcbnZhciBBdGxhc0pTT05GaWxlID0gZnVuY3Rpb24gKGtleSwgdGV4dHVyZVVSTCwgYXRsYXNVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlRmlsZShrZXksIHRleHR1cmVVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncyk7XHJcbiAgICB2YXIgZGF0YSA9IG5ldyBKU09ORmlsZShrZXksIGF0bGFzVVJMLCBwYXRoLCBhdGxhc1hoclNldHRpbmdzKTtcclxuXHJcbiAgICAvLyAgTGluayB0aGVtIHRvZ2V0aGVyXHJcbiAgICBpbWFnZS5saW5rRmlsZSA9IGRhdGE7XHJcbiAgICBkYXRhLmxpbmtGaWxlID0gaW1hZ2U7XHJcblxyXG4gICAgLy8gIFNldCB0aGUgdHlwZVxyXG4gICAgaW1hZ2UubGlua1R5cGUgPSAnYXRsYXNqc29uJztcclxuICAgIGRhdGEubGlua1R5cGUgPSAnYXRsYXNqc29uJztcclxuXHJcbiAgICByZXR1cm4geyB0ZXh0dXJlOiBpbWFnZSwgZGF0YTogZGF0YSB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBdGxhc0pTT05GaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG52YXIgR2V0RmFzdFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldEZhc3RWYWx1ZScpO1xyXG5cclxuLy8gIFBoYXNlci5Mb2FkZXIuRmlsZVR5cGVzLkJpbmFyeUZpbGVcclxuXHJcbnZhciBCaW5hcnlGaWxlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBGaWxlLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQmluYXJ5RmlsZSAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmaWxlS2V5ID0gKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSA/IGtleSA6IEdldEZhc3RWYWx1ZShrZXksICdrZXknLCAnJyk7XHJcblxyXG4gICAgICAgIHZhciBmaWxlQ29uZmlnID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnYmluYXJ5JyxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBHZXRGYXN0VmFsdWUoa2V5LCAnZXh0ZW5zaW9uJywgJ2JpbicpLFxyXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXHJcbiAgICAgICAgICAgIGtleTogZmlsZUtleSxcclxuICAgICAgICAgICAgdXJsOiBHZXRGYXN0VmFsdWUoa2V5LCAnZmlsZScsIHVybCksXHJcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgICAgIHhoclNldHRpbmdzOiBHZXRGYXN0VmFsdWUoa2V5LCAneGhyJywgeGhyU2V0dGluZ3MpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgRmlsZS5jYWxsKHRoaXMsIGZpbGVDb25maWcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblByb2Nlc3M6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnhockxvYWRlci5yZXNwb25zZTtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKHRoaXMpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5CaW5hcnlGaWxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChsb2FkZXIsIGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBJZiBpdCdzIGFuIGFycmF5IGl0IGhhcyB0byBiZSBhbiBhcnJheSBvZiBPYmplY3RzLCBzbyB3ZSBnZXQgZXZlcnl0aGluZyBvdXQgb2YgdGhlICdrZXknIG9iamVjdFxyXG4gICAgICAgICAgICBsb2FkZXIuYWRkRmlsZShuZXcgQmluYXJ5RmlsZShrZXlbaV0sIHVybCwgbG9hZGVyLnBhdGgsIHhoclNldHRpbmdzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGxvYWRlci5hZGRGaWxlKG5ldyBCaW5hcnlGaWxlKGtleSwgdXJsLCBsb2FkZXIucGF0aCwgeGhyU2V0dGluZ3MpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRm9yIG1ldGhvZCBjaGFpbmluZ1xyXG4gICAgcmV0dXJuIGxvYWRlcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmluYXJ5RmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDc5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW1hZ2VGaWxlID0gcmVxdWlyZSgnLi9JbWFnZUZpbGUuanMnKTtcclxudmFyIFhNTEZpbGUgPSByZXF1aXJlKCcuL1hNTEZpbGUuanMnKTtcclxuXHJcbnZhciBCaXRtYXBGb250RmlsZSA9IGZ1bmN0aW9uIChrZXksIHRleHR1cmVVUkwsIHhtbFVSTCwgcGF0aCwgdGV4dHVyZVhoclNldHRpbmdzLCB4bWxYaHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlRmlsZShrZXksIHRleHR1cmVVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncyk7XHJcbiAgICB2YXIgZGF0YSA9IG5ldyBYTUxGaWxlKGtleSwgeG1sVVJMLCBwYXRoLCB4bWxYaHJTZXR0aW5ncyk7XHJcblxyXG4gICAgLy8gIExpbmsgdGhlbSB0b2dldGhlclxyXG4gICAgaW1hZ2UubGlua0ZpbGUgPSBkYXRhO1xyXG4gICAgZGF0YS5saW5rRmlsZSA9IGltYWdlO1xyXG5cclxuICAgIC8vICBTZXQgdGhlIHR5cGVcclxuICAgIGltYWdlLmxpbmtUeXBlID0gJ2JpdG1hcGZvbnQnO1xyXG4gICAgZGF0YS5saW5rVHlwZSA9ICdiaXRtYXBmb250JztcclxuXHJcbiAgICByZXR1cm4geyB0ZXh0dXJlOiBpbWFnZSwgZGF0YTogZGF0YSB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaXRtYXBGb250RmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvZmlsZXR5cGVzL0JpdG1hcEZvbnRGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcbnZhciBHZXRGYXN0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0RmFzdFZhbHVlJyk7XHJcblxyXG4vLyAgUGhhc2VyLkxvYWRlci5GaWxlVHlwZXMuR0xTTEZpbGVcclxuXHJcbnZhciBHTFNMRmlsZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogRmlsZSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEdMU0xGaWxlIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZpbGVLZXkgPSAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpID8ga2V5IDogR2V0RmFzdFZhbHVlKGtleSwgJ2tleScsICcnKTtcclxuXHJcbiAgICAgICAgdmFyIGZpbGVDb25maWcgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdnbHNsJyxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBHZXRGYXN0VmFsdWUoa2V5LCAnZXh0ZW5zaW9uJywgJ2dsc2wnKSxcclxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXHJcbiAgICAgICAgICAgIGtleTogZmlsZUtleSxcclxuICAgICAgICAgICAgdXJsOiBHZXRGYXN0VmFsdWUoa2V5LCAnZmlsZScsIHVybCksXHJcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgICAgIHhoclNldHRpbmdzOiBHZXRGYXN0VmFsdWUoa2V5LCAneGhyJywgeGhyU2V0dGluZ3MpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgRmlsZS5jYWxsKHRoaXMsIGZpbGVDb25maWcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblByb2Nlc3M6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQ7XHJcblxyXG4gICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgICAgICBjYWxsYmFjayh0aGlzKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuR0xTTEZpbGUuY3JlYXRlID0gZnVuY3Rpb24gKGxvYWRlciwga2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIElmIGl0J3MgYW4gYXJyYXkgaXQgaGFzIHRvIGJlIGFuIGFycmF5IG9mIE9iamVjdHMsIHNvIHdlIGdldCBldmVyeXRoaW5nIG91dCBvZiB0aGUgJ2tleScgb2JqZWN0XHJcbiAgICAgICAgICAgIGxvYWRlci5hZGRGaWxlKG5ldyBHTFNMRmlsZShrZXlbaV0sIHVybCwgbG9hZGVyLnBhdGgsIHhoclNldHRpbmdzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGxvYWRlci5hZGRGaWxlKG5ldyBHTFNMRmlsZShrZXksIHVybCwgbG9hZGVyLnBhdGgsIHhoclNldHRpbmdzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZvciBtZXRob2QgY2hhaW5pbmdcclxuICAgIHJldHVybiBsb2FkZXI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdMU0xGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDc5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxudmFyIEdldEZhc3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRGYXN0VmFsdWUnKTtcclxuXHJcbi8vICBQaGFzZXIuTG9hZGVyLkZpbGVUeXBlcy5IVE1MRmlsZVxyXG5cclxudmFyIEhUTUxGaWxlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBGaWxlLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gSFRNTEZpbGUgKGtleSwgdXJsLCB3aWR0aCwgaGVpZ2h0LCBwYXRoLCB4aHJTZXR0aW5ncylcclxuICAgIHtcclxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDUxMjsgfVxyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSA1MTI7IH1cclxuXHJcbiAgICAgICAgdmFyIGZpbGVLZXkgPSAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpID8ga2V5IDogR2V0RmFzdFZhbHVlKGtleSwgJ2tleScsICcnKTtcclxuXHJcbiAgICAgICAgdmFyIGZpbGVDb25maWcgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBHZXRGYXN0VmFsdWUoa2V5LCAnZXh0ZW5zaW9uJywgJ2h0bWwnKSxcclxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXHJcbiAgICAgICAgICAgIGtleTogZmlsZUtleSxcclxuICAgICAgICAgICAgdXJsOiBHZXRGYXN0VmFsdWUoa2V5LCAnZmlsZScsIHVybCksXHJcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgICAgIHhoclNldHRpbmdzOiBHZXRGYXN0VmFsdWUoa2V5LCAneGhyJywgeGhyU2V0dGluZ3MpLFxyXG4gICAgICAgICAgICBjb25maWc6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBGaWxlLmNhbGwodGhpcywgZmlsZUNvbmZpZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uUHJvY2VzczogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgICAgIHZhciB3ID0gdGhpcy5jb25maWcud2lkdGg7XHJcbiAgICAgICAgdmFyIGggPSB0aGlzLmNvbmZpZy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0gW107XHJcblxyXG4gICAgICAgIGRhdGEucHVzaCgnPHN2ZyB3aWR0aD1cIicgKyB3ICsgJ3B4XCIgaGVpZ2h0PVwiJyArIGggKyAncHhcIiB2aWV3Qm94PVwiMCAwICcgKyB3ICsgJyAnICsgaCArICdcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+Jyk7XHJcbiAgICAgICAgZGF0YS5wdXNoKCc8Zm9yZWlnbk9iamVjdCB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+Jyk7XHJcbiAgICAgICAgZGF0YS5wdXNoKCc8Ym9keSB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj4nKTtcclxuICAgICAgICBkYXRhLnB1c2godGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICBkYXRhLnB1c2goJzwvYm9keT4nKTtcclxuICAgICAgICBkYXRhLnB1c2goJzwvZm9yZWlnbk9iamVjdD4nKTtcclxuICAgICAgICBkYXRhLnB1c2goJzwvc3ZnPicpO1xyXG5cclxuICAgICAgICB2YXIgc3ZnID0gWyBkYXRhLmpvaW4oJ1xcbicpIF07XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdHJ5XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihzdmcsIHsgdHlwZTogJ2ltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCcgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0VSUk9SRUQ7XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjayhfdGhpcyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLm9ubG9hZCA9IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKF90aGlzLmRhdGEuc3JjKTtcclxuXHJcbiAgICAgICAgICAgIF90aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKF90aGlzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEub25lcnJvciA9IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKF90aGlzLmRhdGEuc3JjKTtcclxuXHJcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gQ09OU1QuRklMRV9FUlJPUkVEO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5IVE1MRmlsZS5jcmVhdGUgPSBmdW5jdGlvbiAobG9hZGVyLCBrZXksIHVybCwgd2lkdGgsIGhlaWdodCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSWYgaXQncyBhbiBhcnJheSBpdCBoYXMgdG8gYmUgYW4gYXJyYXkgb2YgT2JqZWN0cywgc28gd2UgZ2V0IGV2ZXJ5dGhpbmcgb3V0IG9mIHRoZSAna2V5JyBvYmplY3RcclxuICAgICAgICAgICAgbG9hZGVyLmFkZEZpbGUobmV3IEhUTUxGaWxlKGtleVtpXSwgdXJsLCB3aWR0aCwgaGVpZ2h0LCBsb2FkZXIucGF0aCwgeGhyU2V0dGluZ3MpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgbG9hZGVyLmFkZEZpbGUobmV3IEhUTUxGaWxlKGtleSwgdXJsLCB3aWR0aCwgaGVpZ2h0LCBsb2FkZXIucGF0aCwgeGhyU2V0dGluZ3MpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRm9yIG1ldGhvZCBjaGFpbmluZ1xyXG4gICAgcmV0dXJuIGxvYWRlcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSFRNTEZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2ZpbGV0eXBlcy9IVE1MRmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG52YXIgR2V0RmFzdFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldEZhc3RWYWx1ZScpO1xyXG5cclxuLy8gIFBoYXNlci5Mb2FkZXIuRmlsZVR5cGVzLlNWR0ZpbGVcclxuXHJcbnZhciBTVkdGaWxlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBGaWxlLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gU1ZHRmlsZSAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmaWxlS2V5ID0gKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSA/IGtleSA6IEdldEZhc3RWYWx1ZShrZXksICdrZXknLCAnJyk7XHJcblxyXG4gICAgICAgIHZhciBmaWxlQ29uZmlnID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnc3ZnJyxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBHZXRGYXN0VmFsdWUoa2V5LCAnZXh0ZW5zaW9uJywgJ3N2ZycpLFxyXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgICAga2V5OiBmaWxlS2V5LFxyXG4gICAgICAgICAgICB1cmw6IEdldEZhc3RWYWx1ZShrZXksICdmaWxlJywgdXJsKSxcclxuICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgeGhyU2V0dGluZ3M6IEdldEZhc3RWYWx1ZShrZXksICd4aHInLCB4aHJTZXR0aW5ncylcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBGaWxlLmNhbGwodGhpcywgZmlsZUNvbmZpZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uUHJvY2VzczogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgICAgIHZhciBzdmcgPSBbIHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlVGV4dCBdO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRyeVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgd2luZG93LkJsb2Ioc3ZnLCB7IHR5cGU6ICdpbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgnIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gQ09OU1QuRklMRV9FUlJPUkVEO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XHJcblxyXG4gICAgICAgIHZhciByZXRyeSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGEub25sb2FkID0gZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoX3RoaXMuZGF0YS5zcmMpO1xyXG5cclxuICAgICAgICAgICAgX3RoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YS5vbmVycm9yID0gZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoX3RoaXMuZGF0YS5zcmMpO1xyXG5cclxuICAgICAgICAgICAgLy8gIFNhZmFyaSA4IHJlLXRyeVxyXG4gICAgICAgICAgICBpZiAoIXJldHJ5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXRyeSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHVybCA9ICdkYXRhOmltYWdlL3N2Zyt4bWwsJyArIGVuY29kZVVSSUNvbXBvbmVudChzdmcuam9pbignJykpO1xyXG5cclxuICAgICAgICAgICAgICAgIF90aGlzLmRhdGEuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh1cmwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0VSUk9SRUQ7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcblNWR0ZpbGUuY3JlYXRlID0gZnVuY3Rpb24gKGxvYWRlciwga2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIElmIGl0J3MgYW4gYXJyYXkgaXQgaGFzIHRvIGJlIGFuIGFycmF5IG9mIE9iamVjdHMsIHNvIHdlIGdldCBldmVyeXRoaW5nIG91dCBvZiB0aGUgJ2tleScgb2JqZWN0XHJcbiAgICAgICAgICAgIGxvYWRlci5hZGRGaWxlKG5ldyBTVkdGaWxlKGtleVtpXSwgdXJsLCBsb2FkZXIucGF0aCwgeGhyU2V0dGluZ3MpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgbG9hZGVyLmFkZEZpbGUobmV3IFNWR0ZpbGUoa2V5LCB1cmwsIGxvYWRlci5wYXRoLCB4aHJTZXR0aW5ncykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBGb3IgbWV0aG9kIGNoYWluaW5nXHJcbiAgICByZXR1cm4gbG9hZGVyO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTVkdGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9maWxldHlwZXMvU1ZHRmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG52YXIgR2V0RmFzdFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldEZhc3RWYWx1ZScpO1xyXG5cclxuLy8gIFBoYXNlci5Mb2FkZXIuRmlsZVR5cGVzLlNjcmlwdEZpbGVcclxuXHJcbnZhciBTY3JpcHRGaWxlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBGaWxlLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gU2NyaXB0RmlsZSAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmaWxlS2V5ID0gKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSA/IGtleSA6IEdldEZhc3RWYWx1ZShrZXksICdrZXknLCAnJyk7XHJcblxyXG4gICAgICAgIHZhciBmaWxlQ29uZmlnID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnc2NyaXB0JyxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBHZXRGYXN0VmFsdWUoa2V5LCAnZXh0ZW5zaW9uJywgJ2pzJyksXHJcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxyXG4gICAgICAgICAgICBrZXk6IGZpbGVLZXksXHJcbiAgICAgICAgICAgIHVybDogR2V0RmFzdFZhbHVlKGtleSwgJ2ZpbGUnLCB1cmwpLFxyXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgICAgICB4aHJTZXR0aW5nczogR2V0RmFzdFZhbHVlKGtleSwgJ3hocicsIHhoclNldHRpbmdzKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIEZpbGUuY2FsbCh0aGlzLCBmaWxlQ29uZmlnKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Qcm9jZXNzOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICAgICAgdGhpcy5kYXRhLmxhbmd1YWdlID0gJ2phdmFzY3JpcHQnO1xyXG4gICAgICAgIHRoaXMuZGF0YS50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICAgICAgdGhpcy5kYXRhLmRlZmVyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kYXRhLnRleHQgPSB0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQ7XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5kYXRhKTtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKHRoaXMpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5TY3JpcHRGaWxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChsb2FkZXIsIGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBJZiBpdCdzIGFuIGFycmF5IGl0IGhhcyB0byBiZSBhbiBhcnJheSBvZiBPYmplY3RzLCBzbyB3ZSBnZXQgZXZlcnl0aGluZyBvdXQgb2YgdGhlICdrZXknIG9iamVjdFxyXG4gICAgICAgICAgICBsb2FkZXIuYWRkRmlsZShuZXcgU2NyaXB0RmlsZShrZXlbaV0sIHVybCwgbG9hZGVyLnBhdGgsIHhoclNldHRpbmdzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGxvYWRlci5hZGRGaWxlKG5ldyBTY3JpcHRGaWxlKGtleSwgdXJsLCBsb2FkZXIucGF0aCwgeGhyU2V0dGluZ3MpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRm9yIG1ldGhvZCBjaGFpbmluZ1xyXG4gICAgcmV0dXJuIGxvYWRlcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NyaXB0RmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvZmlsZXR5cGVzL1NjcmlwdEZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDc5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW1hZ2VGaWxlID0gcmVxdWlyZSgnLi9JbWFnZUZpbGUuanMnKTtcclxuXHJcbi8vICBjb25maWcgY2FuIGluY2x1ZGU6IGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgbWFyZ2luLCBzcGFjaW5nXHJcblxyXG52YXIgU3ByaXRlU2hlZXQgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIGNvbmZpZywgcGF0aCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZUZpbGUoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzLCBjb25maWcpO1xyXG5cclxuICAgIC8vICBPdmVycmlkZSB0aGUgRmlsZSB0eXBlXHJcbiAgICBpbWFnZS50eXBlID0gJ3Nwcml0ZXNoZWV0JztcclxuXHJcbiAgICByZXR1cm4gaW1hZ2U7XHJcbn07XHJcblxyXG5TcHJpdGVTaGVldC5jcmVhdGUgPSBmdW5jdGlvbiAobG9hZGVyLCBrZXksIHVybCwgY29uZmlnLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBJZiBpdCdzIGFuIGFycmF5IGl0IGhhcyB0byBiZSBhbiBhcnJheSBvZiBPYmplY3RzLCBzbyB3ZSBnZXQgZXZlcnl0aGluZyBvdXQgb2YgdGhlICdrZXknIG9iamVjdFxyXG4gICAgICAgICAgICBsb2FkZXIuYWRkRmlsZShuZXcgU3ByaXRlU2hlZXQoa2V5W2ldLCB1cmwsIG51bGwsIGxvYWRlci5wYXRoLCB4aHJTZXR0aW5ncykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBsb2FkZXIuYWRkRmlsZShuZXcgU3ByaXRlU2hlZXQoa2V5LCB1cmwsIGNvbmZpZywgbG9hZGVyLnBhdGgsIHhoclNldHRpbmdzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZvciBtZXRob2QgY2hhaW5pbmdcclxuICAgIHJldHVybiBsb2FkZXI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZVNoZWV0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9maWxldHlwZXMvU3ByaXRlU2hlZXQuanNcbi8vIG1vZHVsZSBpZCA9IDgwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW1hZ2VGaWxlID0gcmVxdWlyZSgnLi9JbWFnZUZpbGUuanMnKTtcclxudmFyIFRleHRGaWxlID0gcmVxdWlyZSgnLi9UZXh0RmlsZS5qcycpO1xyXG5cclxudmFyIFVuaXR5QXRsYXNGaWxlID0gZnVuY3Rpb24gKGtleSwgdGV4dHVyZVVSTCwgYXRsYXNVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlRmlsZShrZXksIHRleHR1cmVVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncyk7XHJcbiAgICB2YXIgZGF0YSA9IG5ldyBUZXh0RmlsZShrZXksIGF0bGFzVVJMLCBwYXRoLCBhdGxhc1hoclNldHRpbmdzKTtcclxuXHJcbiAgICAvLyAgTGluayB0aGVtIHRvZ2V0aGVyXHJcbiAgICBpbWFnZS5saW5rRmlsZSA9IGRhdGE7XHJcbiAgICBkYXRhLmxpbmtGaWxlID0gaW1hZ2U7XHJcblxyXG4gICAgLy8gIFNldCB0aGUgdHlwZVxyXG4gICAgaW1hZ2UubGlua1R5cGUgPSAndW5pdHlhdGxhcyc7XHJcbiAgICBkYXRhLmxpbmtUeXBlID0gJ3VuaXR5YXRsYXMnO1xyXG5cclxuICAgIHJldHVybiB7IHRleHR1cmU6IGltYWdlLCBkYXRhOiBkYXRhIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXR5QXRsYXNGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9maWxldHlwZXMvVW5pdHlBdGxhc0ZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDgwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQXZlcmFnZSA9IGZ1bmN0aW9uICh2YWx1ZXMpXHJcbntcclxuICAgIHZhciBzdW0gPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHN1bSArPSAoK3ZhbHVlc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN1bSAvIHZhbHVlcy5sZW5ndGg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF2ZXJhZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9BdmVyYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENlaWxUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgcGxhY2UsIGJhc2UpXHJcbntcclxuICAgIGlmIChwbGFjZSA9PT0gdW5kZWZpbmVkKSB7IHBsYWNlID0gMDsgfVxyXG4gICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkgeyBiYXNlID0gMTA7IH1cclxuXHJcbiAgICB2YXIgcCA9IE1hdGgucG93KGJhc2UsIC1wbGFjZSk7XHJcblxyXG4gICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSAqIHApIC8gcDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VpbFRvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvQ2VpbFRvLmpzXG4vLyBtb2R1bGUgaWQgPSA4MDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlmZmVyZW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL0RpZmZlcmVuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDgwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvYXRCZXR3ZWVuID0gZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9hdEJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9GbG9hdEJldHdlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDgwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvb3JUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgcGxhY2UsIGJhc2UpXHJcbntcclxuICAgIGlmIChwbGFjZSA9PT0gdW5kZWZpbmVkKSB7IHBsYWNlID0gMDsgfVxyXG4gICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkgeyBiYXNlID0gMTA7IH1cclxuXHJcbiAgICB2YXIgcCA9IE1hdGgucG93KGJhc2UsIC1wbGFjZSk7XHJcblxyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUgKiBwKSAvIHA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yVG87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9GbG9vclRvLmpzXG4vLyBtb2R1bGUgaWQgPSA4MDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIGRpc3RhbmNlIC0gdXN1YWxseSBpbiBwaXhlbHNcclxuLy8gIHRpbWUgLSBob3cgbG9uZyBzaG91bGQgaXQgdGFrZSB0byBjb3ZlciB0aGUgZGlzdGFuY2U/IEluIHNlY29uZHNcclxuLy8gIFJldHVybnMgdGhlIGFtb3VudCB5b3Ugd2lsbCBuZWVkIHRvIGluY3JlbWVudCBieSBlYWNoIHN0ZXAgdG8gY292ZXIgdGhlIGRpc3RhbmNlIGluIHRoZSB0aW1lIGdpdmVuXHJcbnZhciBHZXRTcGVlZCA9IGZ1bmN0aW9uIChkaXN0YW5jZSwgdGltZSlcclxue1xyXG4gICAgcmV0dXJuIChkaXN0YW5jZSAvIHRpbWUpIC8gMTAwMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0U3BlZWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9HZXRTcGVlZC5qc1xuLy8gbW9kdWxlIGlkID0gODA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJc0V2ZW4gPSBmdW5jdGlvbiAodmFsdWUpXHJcbntcclxuICAgIC8vIFVzZSBhYnN0cmFjdCBlcXVhbGl0eSA9PSBmb3IgXCJpcyBudW1iZXJcIiB0ZXN0XHJcbiAgICByZXR1cm4gKHZhbHVlID09IHBhcnNlRmxvYXQodmFsdWUpKSA/ICEodmFsdWUgJSAyKSA6IHZvaWQgMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXNFdmVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvSXNFdmVuLmpzXG4vLyBtb2R1bGUgaWQgPSA4MDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIElzRXZlblN0cmljdCA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgLy8gVXNlIHN0cmljdCBlcXVhbGl0eSA9PT0gZm9yIFwiaXMgbnVtYmVyXCIgdGVzdFxyXG4gICAgcmV0dXJuICh2YWx1ZSA9PT0gcGFyc2VGbG9hdCh2YWx1ZSkpID8gISh2YWx1ZSAlIDIpIDogdm9pZCAwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJc0V2ZW5TdHJpY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9Jc0V2ZW5TdHJpY3QuanNcbi8vIG1vZHVsZSBpZCA9IDgwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIE1heEFkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgYW1vdW50LCBtYXgpXHJcbntcclxuICAgIHJldHVybiBNYXRoLm1pbih2YWx1ZSArIGFtb3VudCwgbWF4KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWF4QWRkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvTWF4QWRkLmpzXG4vLyBtb2R1bGUgaWQgPSA4MTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1pblN1YiA9IGZ1bmN0aW9uICh2YWx1ZSwgYW1vdW50LCBtaW4pXHJcbntcclxuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSAtIGFtb3VudCwgbWluKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWluU3ViO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvTWluU3ViLmpzXG4vLyBtb2R1bGUgaWQgPSA4MTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFdvcmsgb3V0IHdoYXQgJSB2YWx1ZSBpcyBvZiB0aGUgcmFuZ2UgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuLy8gIElmIG1heCBpc24ndCBnaXZlbiB0aGVuIHlvdSBnZXQgdGhlICUgb2YgdmFsdWUgdG8gbWluLlxyXG4vLyAgWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgYW4gdXBwZXJNYXgsIHdoaWNoIGlzIGEgbWlkLXdheSBwb2ludCBpbiB0aGUgcmFuZ2VcclxuLy8gIHRoYXQgcmVwcmVzZW50cyAxMDAlLCBhZnRlciB3aGljaCB0aGUgJSBzdGFydHMgdG8gZ28gZG93biB0byB6ZXJvIGFnYWluLlxyXG5cclxudmFyIFBlcmNlbnQgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4LCB1cHBlck1heClcclxue1xyXG4gICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7IG1heCA9IG1pbiArIDE7IH1cclxuXHJcbiAgICB2YXIgcGVyY2VudGFnZSA9ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcclxuXHJcbiAgICBpZiAocGVyY2VudGFnZSA+IDEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHVwcGVyTWF4ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwZXJjZW50YWdlID0gKCh1cHBlck1heCAtIHZhbHVlKSkgLyAodXBwZXJNYXggLSBtYXgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBlcmNlbnRhZ2UgPCAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwZXJjZW50YWdlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwZXJjZW50YWdlID0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwZXJjZW50YWdlIDwgMClcclxuICAgIHtcclxuICAgICAgICBwZXJjZW50YWdlID0gMDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGVyY2VudGFnZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGVyY2VudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL1BlcmNlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDgxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgUmFkVG9EZWcgPSBmdW5jdGlvbiAocmFkaWFucylcclxue1xyXG4gICAgcmV0dXJuIHJhZGlhbnMgKiBDT05TVC5SQURfVE9fREVHO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYWRUb0RlZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL1JhZFRvRGVnLmpzXG4vLyBtb2R1bGUgaWQgPSA4MTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJhbmRvbVhZID0gZnVuY3Rpb24gKHZlY3Rvciwgc2NhbGUpXHJcbntcclxuICAgIGlmIChzY2FsZSA9PT0gdW5kZWZpbmVkKSB7IHNjYWxlID0gMTsgfVxyXG5cclxuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xyXG5cclxuICAgIHZlY3Rvci54ID0gTWF0aC5jb3MocikgKiBzY2FsZTtcclxuICAgIHZlY3Rvci55ID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcclxuXHJcbiAgICByZXR1cm4gdmVjdG9yO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21YWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL1JhbmRvbVhZLmpzXG4vLyBtb2R1bGUgaWQgPSA4MTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIHAgPSBQb2ludCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXHJcblxyXG52YXIgUm90YXRlID0gZnVuY3Rpb24gKHBvaW50LCBhbmdsZSlcclxue1xyXG4gICAgdmFyIHggPSBwb2ludC54O1xyXG4gICAgdmFyIHkgPSBwb2ludC55O1xyXG5cclxuICAgIHBvaW50LnggPSAoeCAqIE1hdGguY29zKGFuZ2xlKSkgLSAoeSAqIE1hdGguc2luKGFuZ2xlKSk7XHJcbiAgICBwb2ludC55ID0gKHggKiBNYXRoLnNpbihhbmdsZSkpICsgKHkgKiBNYXRoLmNvcyhhbmdsZSkpO1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvUm90YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIHAgPSBQb2ludCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXHJcblxyXG52YXIgUm90YXRlQXJvdW5kID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5LCBhbmdsZSlcclxue1xyXG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICB2YXIgdHggPSBwb2ludC54IC0geDtcclxuICAgIHZhciB0eSA9IHBvaW50LnkgLSB5O1xyXG5cclxuICAgIHBvaW50LnggPSB0eCAqIGMgLSB0eSAqIHMgKyB4O1xyXG4gICAgcG9pbnQueSA9IHR4ICogcyArIHR5ICogYyArIHk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9Sb3RhdGVBcm91bmQuanNcbi8vIG1vZHVsZSBpZCA9IDgxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm91bmRUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgcGxhY2UsIGJhc2UpXHJcbntcclxuICAgIGlmIChwbGFjZSA9PT0gdW5kZWZpbmVkKSB7IHBsYWNlID0gMDsgfVxyXG4gICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkgeyBiYXNlID0gMTA7IH1cclxuXHJcbiAgICB2YXIgcCA9IE1hdGgucG93KGJhc2UsIC1wbGFjZSk7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwKSAvIHA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kVG87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9Sb3VuZFRvLmpzXG4vLyBtb2R1bGUgaWQgPSA4MTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBTaW5Db3NUYWJsZUdlbmVyYXRvciA9IGZ1bmN0aW9uIChsZW5ndGgsIHNpbkFtcCwgY29zQW1wLCBmcmVxdWVuY3kpXHJcbntcclxuICAgIGlmIChzaW5BbXAgPT09IHVuZGVmaW5lZCkgeyBzaW5BbXAgPSAxOyB9XHJcbiAgICBpZiAoY29zQW1wID09PSB1bmRlZmluZWQpIHsgY29zQW1wID0gMTsgfVxyXG4gICAgaWYgKGZyZXF1ZW5jeSA9PT0gdW5kZWZpbmVkKSB7IGZyZXF1ZW5jeSA9IDE7IH1cclxuXHJcbiAgICBmcmVxdWVuY3kgKj0gTWF0aC5QSSAvIGxlbmd0aDtcclxuXHJcbiAgICB2YXIgY29zID0gW107XHJcbiAgICB2YXIgc2luID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBsZW5ndGg7IGMrKylcclxuICAgIHtcclxuICAgICAgICBjb3NBbXAgLT0gc2luQW1wICogZnJlcXVlbmN5O1xyXG4gICAgICAgIHNpbkFtcCArPSBjb3NBbXAgKiBmcmVxdWVuY3k7XHJcblxyXG4gICAgICAgIGNvc1tjXSA9IGNvc0FtcDtcclxuICAgICAgICBzaW5bY10gPSBzaW5BbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzaW46IHNpbixcclxuICAgICAgICBjb3M6IGNvcyxcclxuICAgICAgICBsZW5ndGg6IGxlbmd0aFxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2luQ29zVGFibGVHZW5lcmF0b3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9TaW5Db3NUYWJsZUdlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gODE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENoZWNrcyBpZiB0d28gdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZSBvZiBlYWNoIG90aGVyLlxyXG4qXHJcbiogQHBhcmFtIHtudW1iZXJ9IGEgLSBUaGUgZmlyc3QgbnVtYmVyIHRvIGNoZWNrXHJcbiogQHBhcmFtIHtudW1iZXJ9IGIgLSBUaGUgc2Vjb25kIG51bWJlciB0byBjaGVja1xyXG4qIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgLSBUaGUgdG9sZXJhbmNlLiBBbnl0aGluZyBlcXVhbCB0byBvciBsZXNzIHRoYW4gdGhpcyBpcyBjb25zaWRlcmVkIHdpdGhpbiB0aGUgcmFuZ2UuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGlzIDw9IHRvbGVyYW5jZSBvZiBiLlxyXG4qL1xyXG52YXIgV2l0aGluID0gZnVuY3Rpb24gKGEsIGIsIHRvbGVyYW5jZSlcclxue1xyXG4gICAgcmV0dXJuIChNYXRoLmFicyhhIC0gYikgPD0gdG9sZXJhbmNlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2l0aGluO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvV2l0aGluLmpzXG4vLyBtb2R1bGUgaWQgPSA4MTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCZXR3ZWVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvYW5nbGUvQmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gODIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZXR3ZWVuUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMihwb2ludDIueSAtIHBvaW50MS55LCBwb2ludDIueCAtIHBvaW50MS54KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlblBvaW50cztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2FuZ2xlL0JldHdlZW5Qb2ludHMuanNcbi8vIG1vZHVsZSBpZCA9IDgyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlblBvaW50c1kgPSBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50Mi54IC0gcG9pbnQxLngsIHBvaW50Mi55IC0gcG9pbnQxLnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCZXR3ZWVuUG9pbnRzWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2FuZ2xlL0JldHdlZW5Qb2ludHNZLmpzXG4vLyBtb2R1bGUgaWQgPSA4MjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW5ZID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih4MiAtIHgxLCB5MiAtIHkxKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV0d2Vlblk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9hbmdsZS9CZXR3ZWVuWS5qc1xuLy8gbW9kdWxlIGlkID0gODIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBOb3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xyXG5cclxudmFyIFJldmVyc2UgPSBmdW5jdGlvbiAoYW5nbGUpXHJcbntcclxuICAgIHJldHVybiBOb3JtYWxpemUoYW5nbGUgKyBNYXRoLlBJKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmV2ZXJzZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2FuZ2xlL1JldmVyc2UuanNcbi8vIG1vZHVsZSBpZCA9IDgyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcblxyXG4vKipcclxuKiBSb3RhdGVzIGN1cnJlbnRBbmdsZSB0b3dhcmRzIHRhcmdldEFuZ2xlLCB0YWtpbmcgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGRpc3RhbmNlLlxyXG4qIFRoZSBsZXJwIGFyZ3VtZW50IGlzIHRoZSBhbW91bnQgdG8gcm90YXRlIGJ5IGluIHRoaXMgY2FsbC5cclxuKiBcclxuKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEFuZ2xlIC0gVGhlIGN1cnJlbnQgYW5nbGUsIGluIHJhZGlhbnMuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHRhcmdldEFuZ2xlIC0gVGhlIHRhcmdldCBhbmdsZSB0byByb3RhdGUgdG8sIGluIHJhZGlhbnMuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtsZXJwPTAuMDVdIC0gVGhlIGxlcnAgdmFsdWUgdG8gYWRkIHRvIHRoZSBjdXJyZW50IGFuZ2xlLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGFkanVzdGVkIGFuZ2xlLlxyXG4qL1xyXG52YXIgUm90YXRlVG8gPSBmdW5jdGlvbiAoY3VycmVudEFuZ2xlLCB0YXJnZXRBbmdsZSwgbGVycClcclxue1xyXG4gICAgaWYgKGxlcnAgPT09IHVuZGVmaW5lZCkgeyBsZXJwID0gMC4wNTsgfVxyXG5cclxuICAgIGlmIChjdXJyZW50QW5nbGUgPT09IHRhcmdldEFuZ2xlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50QW5nbGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKHRhcmdldEFuZ2xlIC0gY3VycmVudEFuZ2xlKSA8PSBsZXJwIHx8IE1hdGguYWJzKHRhcmdldEFuZ2xlIC0gY3VycmVudEFuZ2xlKSA+PSAoTUFUSF9DT05TVC5QSTIgLSBsZXJwKSlcclxuICAgIHtcclxuICAgICAgICBjdXJyZW50QW5nbGUgPSB0YXJnZXRBbmdsZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZiAoTWF0aC5hYnModGFyZ2V0QW5nbGUgLSBjdXJyZW50QW5nbGUpID4gTWF0aC5QSSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRBbmdsZSA8IGN1cnJlbnRBbmdsZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0QW5nbGUgKz0gTUFUSF9DT05TVC5QSTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRBbmdsZSAtPSBNQVRIX0NPTlNULlBJMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRhcmdldEFuZ2xlID4gY3VycmVudEFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3VycmVudEFuZ2xlICs9IGxlcnA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhcmdldEFuZ2xlIDwgY3VycmVudEFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3VycmVudEFuZ2xlIC09IGxlcnA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjdXJyZW50QW5nbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZVRvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvYW5nbGUvUm90YXRlVG8uanNcbi8vIG1vZHVsZSBpZCA9IDgyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBHZXRzIHRoZSBzaG9ydGVzdCBhbmdsZSBiZXR3ZWVuIGBhbmdsZTFgIGFuZCBgYW5nbGUyYC5cclxuKiBCb3RoIGFuZ2xlcyBtdXN0IGJlIGluIHRoZSByYW5nZSAtMTgwIHRvIDE4MCwgd2hpY2ggaXMgdGhlIHNhbWUgY2xhbXBlZFxyXG4qIHJhbmdlIHRoYXQgYHNwcml0ZS5hbmdsZWAgdXNlcywgc28geW91IGNhbiBwYXNzIGluIHR3byBzcHJpdGUgYW5nbGVzIHRvXHJcbiogdGhpcyBtZXRob2QsIGFuZCBnZXQgdGhlIHNob3J0ZXN0IGFuZ2xlIGJhY2sgYmV0d2VlbiB0aGUgdHdvIG9mIHRoZW0uXHJcbipcclxuKiBUaGUgYW5nbGUgcmV0dXJuZWQgd2lsbCBiZSBpbiB0aGUgc2FtZSByYW5nZS4gSWYgdGhlIHJldHVybmVkIGFuZ2xlIGlzXHJcbiogZ3JlYXRlciB0aGFuIDAgdGhlbiBpdCdzIGEgY291bnRlci1jbG9ja3dpc2Ugcm90YXRpb24sIGlmIDwgMCB0aGVuIGl0J3NcclxuKiBhIGNsb2Nrd2lzZSByb3RhdGlvbi5cclxuKiBcclxuKiBAcGFyYW0ge251bWJlcn0gYW5nbGUxIC0gVGhlIGZpcnN0IGFuZ2xlLiBJbiB0aGUgcmFuZ2UgLTE4MCB0byAxODAuXHJcbiogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlMiAtIFRoZSBzZWNvbmQgYW5nbGUuIEluIHRoZSByYW5nZSAtMTgwIHRvIDE4MC5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzaG9ydGVzdCBhbmdsZSwgaW4gZGVncmVlcy4gSWYgZ3JlYXRlciB0aGFuIHplcm8gaXQncyBhIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLlxyXG4qL1xyXG52YXIgU2hvcnRlc3RCZXR3ZWVuID0gZnVuY3Rpb24gKGFuZ2xlMSwgYW5nbGUyKVxyXG57XHJcbiAgICB2YXIgZGlmZmVyZW5jZSA9IGFuZ2xlMiAtIGFuZ2xlMTtcclxuXHJcbiAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGltZXMgPSBNYXRoLmZsb29yKChkaWZmZXJlbmNlIC0gKC0xODApKSAvIDM2MCk7XHJcblxyXG4gICAgcmV0dXJuIGRpZmZlcmVuY2UgLSAodGltZXMgKiAzNjApO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hvcnRlc3RCZXR3ZWVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvYW5nbGUvU2hvcnRlc3RCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA4MjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQmV0d2VlbjogcmVxdWlyZSgnLi9CZXR3ZWVuJyksXHJcbiAgICBCZXR3ZWVuWTogcmVxdWlyZSgnLi9CZXR3ZWVuWScpLFxyXG4gICAgQmV0d2VlblBvaW50czogcmVxdWlyZSgnLi9CZXR3ZWVuUG9pbnRzJyksXHJcbiAgICBCZXR3ZWVuUG9pbnRzWTogcmVxdWlyZSgnLi9CZXR3ZWVuUG9pbnRzWScpLFxyXG4gICAgUmV2ZXJzZTogcmVxdWlyZSgnLi9SZXZlcnNlJyksXHJcbiAgICBSb3RhdGVUbzogcmVxdWlyZSgnLi9Sb3RhdGVUbycpLFxyXG4gICAgU2hvcnRlc3RCZXR3ZWVuOiByZXF1aXJlKCcuL1Nob3J0ZXN0QmV0d2VlbicpLFxyXG4gICAgTm9ybWFsaXplOiByZXF1aXJlKCcuL05vcm1hbGl6ZScpLFxyXG4gICAgV3JhcDogcmVxdWlyZSgnLi9XcmFwJyksXHJcbiAgICBXcmFwRGVncmVlczogcmVxdWlyZSgnLi9XcmFwRGVncmVlcycpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvYW5nbGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDgyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzdGFuY2VQb3dlciA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgcG93KVxyXG57XHJcbiAgICBpZiAocG93ID09PSB1bmRlZmluZWQpIHsgcG93ID0gMjsgfVxyXG5cclxuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDIgLSB4MSwgcG93KSArIE1hdGgucG93KHkyIC0geTEsIHBvdykpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZVBvd2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VQb3dlci5qc1xuLy8gbW9kdWxlIGlkID0gODI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXN0YW5jZVNxdWFyZWQgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbntcclxuICAgIHZhciBkeCA9IHgxIC0geDI7XHJcbiAgICB2YXIgZHkgPSB5MSAtIHkyO1xyXG5cclxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VTcXVhcmVkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VTcXVhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA4Mjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQmV0d2VlbjogcmVxdWlyZSgnLi9EaXN0YW5jZUJldHdlZW4nKSxcclxuICAgIFBvd2VyOiByZXF1aXJlKCcuL0Rpc3RhbmNlUG93ZXInKSxcclxuICAgIFNxdWFyZWQ6IHJlcXVpcmUoJy4vRGlzdGFuY2VTcXVhcmVkJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9kaXN0YW5jZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCYWNrID0gcmVxdWlyZSgnLi9CYWNrJyk7XHJcbnZhciBCb3VuY2UgPSByZXF1aXJlKCcuL0JvdW5jZScpO1xyXG52YXIgQ2lyY3VsYXIgPSByZXF1aXJlKCcuL0NpcmN1bGFyJyk7XHJcbnZhciBDdWJpYyA9IHJlcXVpcmUoJy4vQ3ViaWMnKTtcclxudmFyIEVsYXN0aWMgPSByZXF1aXJlKCcuL0VsYXN0aWMnKTtcclxudmFyIEV4cG8gPSByZXF1aXJlKCcuL0V4cG8nKTtcclxudmFyIExpbmVhciA9IHJlcXVpcmUoJy4vTGluZWFyJyk7XHJcbnZhciBRdWFkcmF0aWMgPSByZXF1aXJlKCcuL1F1YWRyYXRpYycpO1xyXG52YXIgUXVhcnRpYyA9IHJlcXVpcmUoJy4vUXVhcnRpYycpO1xyXG52YXIgUXVpbnRpYyA9IHJlcXVpcmUoJy4vUXVpbnRpYycpO1xyXG52YXIgU2luZSA9IHJlcXVpcmUoJy4vU2luZScpO1xyXG5cclxuLy8gIEVhc2VNYXBcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgUG93ZXIwOiBMaW5lYXIsXHJcbiAgICBQb3dlcjE6IFF1YWRyYXRpYy5PdXQsXHJcbiAgICBQb3dlcjI6IEN1YmljLk91dCxcclxuICAgIFBvd2VyMzogUXVhcnRpYy5PdXQsXHJcbiAgICBQb3dlcjQ6IFF1aW50aWMuT3V0LFxyXG5cclxuICAgIExpbmVhcjogTGluZWFyLFxyXG4gICAgUXVhZDogUXVhZHJhdGljLk91dCxcclxuICAgIEN1YmljOiBDdWJpYy5PdXQsXHJcbiAgICBRdWFydDogUXVhcnRpYy5PdXQsXHJcbiAgICBRdWludDogUXVpbnRpYy5PdXQsXHJcbiAgICBTaW5lOiBTaW5lLk91dCxcclxuICAgIEV4cG86IEV4cG8uT3V0LFxyXG4gICAgQ2lyYzogQ2lyY3VsYXIuT3V0LFxyXG4gICAgRWxhc3RpYzogRWxhc3RpYy5PdXQsXHJcbiAgICBCYWNrOiBCYWNrLk91dCxcclxuICAgIEJvdW5jZTogQm91bmNlLk91dCxcclxuXHJcbiAgICAnUXVhZC5lYXNlSW4nOiBRdWFkcmF0aWMuSW4sXHJcbiAgICAnQ3ViaWMuZWFzZUluJzogQ3ViaWMuSW4sXHJcbiAgICAnUXVhcnQuZWFzZUluJzogUXVhcnRpYy5JbixcclxuICAgICdRdWludC5lYXNlSW4nOiBRdWludGljLkluLFxyXG4gICAgJ1NpbmUuZWFzZUluJzogU2luZS5JbixcclxuICAgICdFeHBvLmVhc2VJbic6IEV4cG8uSW4sXHJcbiAgICAnQ2lyYy5lYXNlSW4nOiBDaXJjdWxhci5JbixcclxuICAgICdFbGFzdGljLmVhc2VJbic6IEVsYXN0aWMuSW4sXHJcbiAgICAnQmFjay5lYXNlSW4nOiBCYWNrLkluLFxyXG4gICAgJ0JvdW5jZS5lYXNlSW4nOiBCb3VuY2UuSW4sXHJcblxyXG4gICAgJ1F1YWQuZWFzZU91dCc6IFF1YWRyYXRpYy5PdXQsXHJcbiAgICAnQ3ViaWMuZWFzZU91dCc6IEN1YmljLk91dCxcclxuICAgICdRdWFydC5lYXNlT3V0JzogUXVhcnRpYy5PdXQsXHJcbiAgICAnUXVpbnQuZWFzZU91dCc6IFF1aW50aWMuT3V0LFxyXG4gICAgJ1NpbmUuZWFzZU91dCc6IFNpbmUuT3V0LFxyXG4gICAgJ0V4cG8uZWFzZU91dCc6IEV4cG8uT3V0LFxyXG4gICAgJ0NpcmMuZWFzZU91dCc6IENpcmN1bGFyLk91dCxcclxuICAgICdFbGFzdGljLmVhc2VPdXQnOiBFbGFzdGljLk91dCxcclxuICAgICdCYWNrLmVhc2VPdXQnOiBCYWNrLk91dCxcclxuICAgICdCb3VuY2UuZWFzZU91dCc6IEJvdW5jZS5PdXQsXHJcblxyXG4gICAgJ1F1YWQuZWFzZUluT3V0JzogUXVhZHJhdGljLkluT3V0LFxyXG4gICAgJ0N1YmljLmVhc2VJbk91dCc6IEN1YmljLkluT3V0LFxyXG4gICAgJ1F1YXJ0LmVhc2VJbk91dCc6IFF1YXJ0aWMuSW5PdXQsXHJcbiAgICAnUXVpbnQuZWFzZUluT3V0JzogUXVpbnRpYy5Jbk91dCxcclxuICAgICdTaW5lLmVhc2VJbk91dCc6IFNpbmUuSW5PdXQsXHJcbiAgICAnRXhwby5lYXNlSW5PdXQnOiBFeHBvLkluT3V0LFxyXG4gICAgJ0NpcmMuZWFzZUluT3V0JzogQ2lyY3VsYXIuSW5PdXQsXHJcbiAgICAnRWxhc3RpYy5lYXNlSW5PdXQnOiBFbGFzdGljLkluT3V0LFxyXG4gICAgJ0JhY2suZWFzZUluT3V0JzogQmFjay5Jbk91dCxcclxuICAgICdCb3VuY2UuZWFzZUluT3V0JzogQm91bmNlLkluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZWFzaW5nL0Vhc2VNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDgzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbCA9IGZ1bmN0aW9uICh2YWx1ZSwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSAtIGVwc2lsb24pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZWlsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZnV6enkvQ2VpbC5qc1xuLy8gbW9kdWxlIGlkID0gODMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbCA9IGZ1bmN0aW9uIChhLCBiLCBlcHNpbG9uKVxyXG57XHJcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgZXBzaWxvbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9mdXp6eS9FcXVhbC5qc1xuLy8gbW9kdWxlIGlkID0gODMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9vciA9IGZ1bmN0aW9uIChhLCBiLCBlcHNpbG9uKVxyXG57XHJcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSArIGVwc2lsb24pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Z1enp5L0Zsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSA4MzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gKGEsIGIsIGVwc2lsb24pXHJcbntcclxuICAgIGlmIChlcHNpbG9uID09PSB1bmRlZmluZWQpIHsgZXBzaWxvbiA9IDAuMDAwMTsgfVxyXG5cclxuICAgIHJldHVybiBhID4gYiAtIGVwc2lsb247XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyZWF0ZXJUaGFuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZnV6enkvR3JlYXRlclRoYW4uanNcbi8vIG1vZHVsZSBpZCA9IDgzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGVzc1RoYW4gPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIGEgPCBiICsgZXBzaWxvbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGVzc1RoYW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9mdXp6eS9MZXNzVGhhbi5qc1xuLy8gbW9kdWxlIGlkID0gODM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIENlaWw6IHJlcXVpcmUoJy4vQ2VpbCcpLFxyXG4gICAgRXF1YWw6IHJlcXVpcmUoJy4vRXF1YWwnKSxcclxuICAgIEZsb29yOiByZXF1aXJlKCcuL0Zsb29yJyksXHJcbiAgICBHcmVhdGVyVGhhbjogcmVxdWlyZSgnLi9HcmVhdGVyVGhhbicpLFxyXG4gICAgTGVzc1RoYW46IHJlcXVpcmUoJy4vTGVzc1RoYW4nKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Z1enp5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4Mzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJlcm5zdGVpbiA9IHJlcXVpcmUoJy4uL0Jlcm5zdGVpbicpO1xyXG5cclxudmFyIEJlemllckludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodiwgaylcclxue1xyXG4gICAgdmFyIGIgPSAwO1xyXG4gICAgdmFyIG4gPSB2Lmxlbmd0aCAtIDE7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGIgKz0gTWF0aC5wb3coMSAtIGssIG4gLSBpKSAqIE1hdGgucG93KGssIGkpICogdltpXSAqIEJlcm5zdGVpbihuLCBpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV6aWVySW50ZXJwb2xhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2ludGVycG9sYXRpb24vQmV6aWVySW50ZXJwb2xhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gODM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYXRtdWxsUm9tID0gcmVxdWlyZSgnLi4vQ2F0bXVsbFJvbScpO1xyXG5cclxudmFyIENhdG11bGxSb21JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHYsIGspXHJcbntcclxuICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xyXG4gICAgdmFyIGYgPSBtICogaztcclxuICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcclxuXHJcbiAgICBpZiAodlswXSA9PT0gdlttXSlcclxuICAgIHtcclxuICAgICAgICBpZiAoayA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpID0gTWF0aC5mbG9vcihmID0gbSAqICgxICsgaykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIENhdG11bGxSb20oZiAtIGksIHZbKGkgLSAxICsgbSkgJSBtXSwgdltpXSwgdlsoaSArIDEpICUgbV0sIHZbKGkgKyAyKSAlIG1dKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZiAoayA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdlswXSAtIChDYXRtdWxsUm9tKC1mLCB2WzBdLCB2WzBdLCB2WzFdLCB2WzFdKSAtIHZbMF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGsgPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZbbV0gLSAoQ2F0bXVsbFJvbShmIC0gbSwgdlttXSwgdlttXSwgdlttIC0gMV0sIHZbbSAtIDFdKSAtIHZbbV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIENhdG11bGxSb20oZiAtIGksIHZbaSA/IGkgLSAxIDogMF0sIHZbaV0sIHZbbSA8IGkgKyAxID8gbSA6IGkgKyAxXSwgdlttIDwgaSArIDIgPyBtIDogaSArIDJdKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2F0bXVsbFJvbUludGVycG9sYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9pbnRlcnBvbGF0aW9uL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA4Mzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5NYXRoLkludGVycG9sYXRpb25cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEJlemllcjogcmVxdWlyZSgnLi9CZXppZXJJbnRlcnBvbGF0aW9uJyksXHJcbiAgICBDYXRtdWxsUm9tOiByZXF1aXJlKCcuL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uJyksXHJcbiAgICBDdWJpY0JlemllcjogcmVxdWlyZSgnLi9DdWJpY0JlemllckludGVycG9sYXRpb24nKSxcclxuICAgIExpbmVhcjogcmVxdWlyZSgnLi9MaW5lYXJJbnRlcnBvbGF0aW9uJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9pbnRlcnBvbGF0aW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4NDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIElzIHZhbHVlIGEgcG93ZXIgb2YgMj9cclxuXHJcbnZhciBJc1ZhbHVlUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgcmV0dXJuICh2YWx1ZSA+IDAgJiYgKHZhbHVlICYgKHZhbHVlIC0gMSkpID09PSAwKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXNWYWx1ZVBvd2VyT2ZUd287XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9wb3cyL0lzVmFsdWVQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSA4NDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgR2V0TmV4dDogcmVxdWlyZSgnLi9HZXRQb3dlck9mVHdvJyksXHJcbiAgICBJc1NpemU6IHJlcXVpcmUoJy4vSXNTaXplUG93ZXJPZlR3bycpLFxyXG4gICAgSXNWYWx1ZTogcmVxdWlyZSgnLi9Jc1ZhbHVlUG93ZXJPZlR3bycpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvcG93Mi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwQ2VpbCA9IGZ1bmN0aW9uICh2YWx1ZSwgZ2FwLCBzdGFydClcclxue1xyXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XHJcblxyXG4gICAgaWYgKGdhcCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFsdWUgLT0gc3RhcnQ7XHJcbiAgICB2YWx1ZSA9IGdhcCAqIE1hdGguY2VpbCh2YWx1ZSAvIGdhcCk7XHJcblxyXG4gICAgcmV0dXJuIHN0YXJ0ICsgdmFsdWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBDZWlsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvc25hcC9TbmFwQ2VpbC5qc1xuLy8gbW9kdWxlIGlkID0gODQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwRmxvb3IgPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXHJcbntcclxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxyXG5cclxuICAgIGlmIChnYXAgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlIC09IHN0YXJ0O1xyXG4gICAgdmFsdWUgPSBnYXAgKiBNYXRoLmZsb29yKHZhbHVlIC8gZ2FwKTtcclxuXHJcbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU25hcEZsb29yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvc25hcC9TbmFwRmxvb3IuanNcbi8vIG1vZHVsZSBpZCA9IDg0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU25hcFRvID0gZnVuY3Rpb24gKHZhbHVlLCBnYXAsIHN0YXJ0KVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuXHJcbiAgICBpZiAoZ2FwID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZSAtPSBzdGFydDtcclxuICAgIHZhbHVlID0gZ2FwICogTWF0aC5yb3VuZCh2YWx1ZSAvIGdhcCk7XHJcblxyXG4gICAgcmV0dXJuIHN0YXJ0ICsgdmFsdWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBUbztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL3NuYXAvU25hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSA4NDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2VpbDogcmVxdWlyZSgnLi9TbmFwQ2VpbCcpLFxyXG4gICAgRmxvb3I6IHJlcXVpcmUoJy4vU25hcEZsb29yJyksXHJcbiAgICBUbzogcmVxdWlyZSgnLi9TbmFwVG8nKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL3NuYXAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQmFzZWQgb24gdGhlIHRocmVlLmpzIEN1cnZlIGNsYXNzZXMgY3JlYXRlZCBieSBbeno4NV0oaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZylcclxuXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBMaW5lQ3VydmUgPSByZXF1aXJlKCcuL2N1cnZlcy9saW5lL0xpbmVDdXJ2ZScpO1xyXG52YXIgVmVjdG9yMiA9IHJlcXVpcmUoJy4uL21hdGgvVmVjdG9yMicpO1xyXG5cclxuLy8gIExvY2FsIGNhY2hlIHZhcnNcclxuXHJcbnZhciB0bXBWZWMyQSA9IG5ldyBWZWN0b3IyKCk7XHJcbi8vIHZhciB0bXBWZWMyQiA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG52YXIgUGF0aCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBQYXRoICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdXJ2ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5jYWNoZUxlbmd0aHMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gQXV0b21hdGljYWxseSBjbG9zZXMgdGhlIHBhdGhcclxuICAgICAgICB0aGlzLmF1dG9DbG9zZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgSWYgeDIveTIgYXJlIG5vdCBnaXZlbiB0aGVuIGl0IGNyZWF0ZXMgYSBsaW5lIGJldHdlZW4gdGhlIHByZXZpb3VzIGN1cnZlIGVuZCBwb2ludCAob3IgMHgwKSBhbmQgeDEseTFcclxuICAgIGFkZExpbmVDdXJ2ZTogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4MiA9PT0gdW5kZWZpbmVkICYmIHkyID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQ3JlYXRlIGEgbGluZSBmcm9tIHRoZSBwcmV2aW91cyBlbmQgcG9pbnQgdG8geDEveTFcclxuICAgICAgICAgICAgeDIgPSB4MTtcclxuICAgICAgICAgICAgeTIgPSB5MTtcclxuXHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmdldEVuZFBvaW50KHRtcFZlYzJBKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VydmVzLnB1c2gobmV3IExpbmVDdXJ2ZShbIGVuZC54LCBlbmQueSwgeDIsIHkyIF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJ2ZXMucHVzaChuZXcgTGluZUN1cnZlKFsgeDEsIHkxLCB4MiwgeTIgXSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGN1cnZlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RW5kUG9pbnQ6IGZ1bmN0aW9uIChvdXQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBWZWN0b3IyKCk7IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VydmVzLmxlbmd0aCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnZlc1t0aGlzLmN1cnZlcy5sZW5ndGggLSAxXS5nZXRQb2ludCgxLCBvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXQuc2V0KDAsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH0sXHJcblxyXG4gICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxyXG4gICAgICAgIHZhciBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbMF0uZ2V0UG9pbnQoMCk7XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbdGhpcy5jdXJ2ZXMubGVuZ3RoIC0gMV0uZ2V0UG9pbnQoMSk7XHJcblxyXG4gICAgICAgIGlmICghc3RhcnRQb2ludC5lcXVhbHMoZW5kUG9pbnQpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRoaXMgd2lsbCBjb3B5IGEgcmVmZXJlbmNlIHRvIHRoZSB2ZWN0b3JzLCB3aGljaCBwcm9iYWJseSBpc24ndCBzZW5zaWJsZVxyXG4gICAgICAgICAgICB0aGlzLmN1cnZlcy5wdXNoKG5ldyBMaW5lQ3VydmUoZW5kUG9pbnQsIHN0YXJ0UG9pbnQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cclxuICAgIC8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcclxuICAgIC8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcclxuXHJcbiAgICAvLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXHJcbiAgICAvLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcclxuICAgIC8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcclxuICAgIC8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxyXG5cclxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAodCwgb3V0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgVmVjdG9yMigpOyB9XHJcblxyXG4gICAgICAgIHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgdmFyIGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cclxuXHJcbiAgICAgICAgd2hpbGUgKGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGN1cnZlTGVuZ3Roc1tpXSA+PSBkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGN1cnZlTGVuZ3Roc1tpXSAtIGQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudExlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHUgPSAoc2VnbWVudExlbmd0aCA9PT0gMCkgPyAwIDogMSAtIGRpZmYgLyBzZWdtZW50TGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHUsIG91dCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXHJcbiAgICAvLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcclxuICAgIC8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcclxuXHJcbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cclxuICAgICAgICByZXR1cm4gbGVuc1tsZW5zLmxlbmd0aCAtIDFdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYWNoZUxlbmd0aHMgbXVzdCBiZSByZWNhbGN1bGF0ZWQuXHJcbiAgICB1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2FjaGVMZW5ndGhzID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXHJcbiAgICAvLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxyXG5cclxuICAgIGdldEN1cnZlTGVuZ3RoczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXHJcbiAgICAgICAgLy8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XHJcblxyXG4gICAgICAgIHZhciBsZW5ndGhzID0gW107XHJcbiAgICAgICAgdmFyIHN1bXMgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY3VydmVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3VtcyArPSB0aGlzLmN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgIGxlbmd0aHMucHVzaChzdW1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcclxuXHJcbiAgICAgICAgcmV0dXJuIGxlbmd0aHM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFNwYWNlZFBvaW50czogZnVuY3Rpb24gKGRpdmlzaW9ucylcclxuICAgIHtcclxuICAgICAgICBpZiAoZGl2aXNpb25zID09PSB1bmRlZmluZWQpIHsgZGl2aXNpb25zID0gNDA7IH1cclxuXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkaXZpc2lvbnM7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoaXMuZ2V0UG9pbnQoaSAvIGRpdmlzaW9ucykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b0Nsb3NlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBvaW50czogZnVuY3Rpb24gKGRpdmlzaW9ucylcclxuICAgIHtcclxuICAgICAgICBpZiAoZGl2aXNpb25zID09PSB1bmRlZmluZWQpIHsgZGl2aXNpb25zID0gMTI7IH1cclxuXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHZhciBsYXN0O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY3VydmVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbaV07XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGN1cnZlLmdldFJlc29sdXRpb24oZGl2aXNpb25zKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwdHMgPSBjdXJ2ZS5nZXRQb2ludHMocmVzb2x1dGlvbik7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gcHRzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QuZXF1YWxzKHBvaW50KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmVzIG5vIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgZHVwbGljYXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0ID0gcG9pbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSAmJiBwb2ludHMubGVuZ3RoID4gMSAmJiAhcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5lcXVhbHMocG9pbnRzWzBdKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50c1swXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhdGg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGF0aHMvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gODQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBCYXNlZCBvbiB0aGUgdGhyZWUuanMgQ3VydmUgY2xhc3NlcyBjcmVhdGVkIGJ5IFt6ejg1XShodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nKVxyXG5cclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEN1YmljQmV6aWVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0N1YmljQmV6aWVySW50ZXJwb2xhdGlvbicpO1xyXG52YXIgQ3VydmUgPSByZXF1aXJlKCcuLi9DdXJ2ZScpO1xyXG52YXIgVmVjdG9yMiA9IHJlcXVpcmUoJy4uLy4uLy4uL21hdGgvVmVjdG9yMicpO1xyXG5cclxuLy8gIFBoYXNlci5DdXJ2ZXMuQ3ViaWNCZXppZXJcclxuXHJcbnZhciBDdWJpY0JlemllckN1cnZlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBDdXJ2ZSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEN1YmljQmV6aWVyQ3VydmUgKHYwLCB2MSwgdjIsIHYzKVxyXG4gICAge1xyXG4gICAgICAgIEN1cnZlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMudjAgPSB2MDtcclxuICAgICAgICB0aGlzLnYxID0gdjE7XHJcbiAgICAgICAgdGhpcy52MiA9IHYyO1xyXG4gICAgICAgIHRoaXMudjMgPSB2MztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVzb2x1dGlvbjogZnVuY3Rpb24gKGRpdmlzaW9ucylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZGl2aXNpb25zO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQb2ludDogZnVuY3Rpb24gKHQsIG91dClcclxuICAgIHtcclxuICAgICAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFZlY3RvcjIoKTsgfVxyXG5cclxuICAgICAgICB2YXIgdjAgPSB0aGlzLnYwO1xyXG4gICAgICAgIHZhciB2MSA9IHRoaXMudjE7XHJcbiAgICAgICAgdmFyIHYyID0gdGhpcy52MjtcclxuICAgICAgICB2YXIgdjMgPSB0aGlzLnYzO1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0LnNldChDdWJpY0Jlemllcih0LCB2MC54LCB2MS54LCB2Mi54LCB2My54KSwgQ3ViaWNCZXppZXIodCwgdjAueSwgdjEueSwgdjIueSwgdjMueSkpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEN1YmljQmV6aWVyQ3VydmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGF0aHMvY3VydmVzL2N1YmljYmV6aWVyL0N1YmljQmV6aWVyQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDg0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQmFzZWQgb24gdGhlIHRocmVlLmpzIEN1cnZlIGNsYXNzZXMgY3JlYXRlZCBieSBbeno4NV0oaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZylcclxuXHJcbnZhciBDdXJ2ZSA9IHJlcXVpcmUoJy4uL0N1cnZlJyk7XHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBEZWdUb1JhZCA9IHJlcXVpcmUoJy4uLy4uLy4uL21hdGgvRGVnVG9SYWQnKTtcclxudmFyIFZlY3RvcjIgPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoL1ZlY3RvcjInKTtcclxuXHJcbi8vICBQaGFzZXIuQ3VydmVzLkVsbGlwc2VcclxuXHJcbnZhciBFbGxpcHNlQ3VydmUgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEN1cnZlLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gRWxsaXBzZUN1cnZlICh4LCB5LCB4UmFkaXVzLCB5UmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlLCByb3RhdGlvbilcclxuICAgIHtcclxuICAgICAgICBpZiAoeVJhZGl1cyA9PT0gdW5kZWZpbmVkKSB7IHlSYWRpdXMgPSB4UmFkaXVzOyB9XHJcbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPT09IHVuZGVmaW5lZCkgeyBzdGFydEFuZ2xlID0gMDsgfVxyXG4gICAgICAgIGlmIChlbmRBbmdsZSA9PT0gdW5kZWZpbmVkKSB7IGVuZEFuZ2xlID0gMzYwOyB9XHJcbiAgICAgICAgaWYgKGNsb2Nrd2lzZSA9PT0gdW5kZWZpbmVkKSB7IGNsb2Nrd2lzZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKHJvdGF0aW9uID09PSB1bmRlZmluZWQpIHsgcm90YXRpb24gPSAwOyB9XHJcblxyXG4gICAgICAgIEN1cnZlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgdGhpcy54UmFkaXVzID0geFJhZGl1cztcclxuICAgICAgICB0aGlzLnlSYWRpdXMgPSB5UmFkaXVzO1xyXG5cclxuICAgICAgICAvLyAgUmFkaWFuc1xyXG4gICAgICAgIHRoaXMuc3RhcnRBbmdsZSA9IERlZ1RvUmFkKHN0YXJ0QW5nbGUpO1xyXG4gICAgICAgIHRoaXMuZW5kQW5nbGUgPSBEZWdUb1JhZChlbmRBbmdsZSk7XHJcblxyXG4gICAgICAgIC8vICBCb29sZWFuIChhbnRpLWNsb2Nrd2lzZSBkaXJlY3Rpb24pXHJcbiAgICAgICAgdGhpcy5jbG9ja3dpc2UgPSBjbG9ja3dpc2U7XHJcblxyXG4gICAgICAgIC8vICBUaGUgcm90YXRpb24gb2YgdGhlIGFyY1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSBEZWdUb1JhZChyb3RhdGlvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFJlc29sdXRpb246IGZ1bmN0aW9uIChkaXZpc2lvbnMpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGRpdmlzaW9ucyAqIDI7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAodCwgb3V0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgVmVjdG9yMigpOyB9XHJcblxyXG4gICAgICAgIHZhciB0d29QaSA9IE1hdGguUEkgKiAyO1xyXG4gICAgICAgIHZhciBkZWx0YUFuZ2xlID0gdGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZTtcclxuICAgICAgICB2YXIgc2FtZVBvaW50cyA9IE1hdGguYWJzKCBkZWx0YUFuZ2xlICkgPCBOdW1iZXIuRVBTSUxPTjtcclxuXHJcbiAgICAgICAgLy8gZW5zdXJlcyB0aGF0IGRlbHRhQW5nbGUgaXMgMCAuLiAyIFBJXHJcbiAgICAgICAgd2hpbGUgKGRlbHRhQW5nbGUgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsdGFBbmdsZSArPSB0d29QaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlIChkZWx0YUFuZ2xlID4gdHdvUGkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWx0YUFuZ2xlIC09IHR3b1BpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlbHRhQW5nbGUgPCBOdW1iZXIuRVBTSUxPTilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzYW1lUG9pbnRzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YUFuZ2xlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhQW5nbGUgPSB0d29QaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2xvY2t3aXNlICYmICEgc2FtZVBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YUFuZ2xlID09PSB0d29QaSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGVsdGFBbmdsZSA9IC0gdHdvUGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLnN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuICAgICAgICB2YXIgeCA9IHRoaXMueCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucm90YXRpb24gIT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY29zID0gTWF0aC5jb3ModGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGlzLnJvdGF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0eCA9IHggLSB0aGlzLng7XHJcbiAgICAgICAgICAgIHZhciB0eSA9IHkgLSB0aGlzLnk7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXHJcbiAgICAgICAgICAgIHggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgdGhpcy54O1xyXG4gICAgICAgICAgICB5ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIHRoaXMueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXQuc2V0KHgsIHkpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVsbGlwc2VDdXJ2ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYXRocy9jdXJ2ZXMvZWxsaXBzZS9FbGxpcHNlQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDg0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQmFzZWQgb24gdGhlIHRocmVlLmpzIEN1cnZlIGNsYXNzZXMgY3JlYXRlZCBieSBbeno4NV0oaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZylcclxuXHJcbnZhciBDYXRtdWxsUm9tID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aC9DYXRtdWxsUm9tJyk7XHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDdXJ2ZSA9IHJlcXVpcmUoJy4uL0N1cnZlJyk7XHJcbnZhciBWZWN0b3IyID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aC9WZWN0b3IyJyk7XHJcblxyXG4vLyAgUGhhc2VyLkN1cnZlcy5TcGxpbmVcclxuXHJcbnZhciBTcGxpbmVDdXJ2ZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogQ3VydmUsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICAvLyAgQXJyYXkgb2YgdmVjMnNcclxuICAgIGZ1bmN0aW9uIFNwbGluZUN1cnZlIChwb2ludHMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHBvaW50cyA9PT0gdW5kZWZpbmVkKSB7IHBvaW50cyA9IFtdOyB9XHJcblxyXG4gICAgICAgIEN1cnZlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbiAoZGl2aXNpb25zKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBkaXZpc2lvbnMgKiB0aGlzLnBvaW50cy5sZW5ndGg7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBvaW50OiBmdW5jdGlvbiAodCwgb3V0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgVmVjdG9yMigpOyB9XHJcblxyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuXHJcbiAgICAgICAgdmFyIHBvaW50ID0gKHBvaW50cy5sZW5ndGggLSAxKSAqIHQ7XHJcblxyXG4gICAgICAgIHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IocG9pbnQpO1xyXG5cclxuICAgICAgICB2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcbiAgICAgICAgdmFyIHAwID0gcG9pbnRzWyAoaW50UG9pbnQgPT09IDApID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcclxuICAgICAgICB2YXIgcDEgPSBwb2ludHNbIGludFBvaW50IF07XHJcbiAgICAgICAgdmFyIHAyID0gcG9pbnRzWyAoaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMikgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xyXG4gICAgICAgIHZhciBwMyA9IHBvaW50c1sgKGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMpID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dC5zZXQoQ2F0bXVsbFJvbSh3ZWlnaHQsIHAwLngsIHAxLngsIHAyLngsIHAzLngpLCBDYXRtdWxsUm9tKHdlaWdodCwgcDAueSwgcDEueSwgcDIueSwgcDMueSkpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwbGluZUN1cnZlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhdGhzL2N1cnZlcy9zcGxpbmUvU3BsaW5lQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDg1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL3BvbHlmaWxscycpO1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG52YXIgRXh0ZW5kID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QvRXh0ZW5kJyk7XHJcblxyXG4vLyAgVGhpcyBvYmplY3QgaXMgZXhwb3J0ZWQgZ2xvYmFsbHlcclxuXHJcbi8qXHJcbnZhciBQaGFzZXIgPSB7XHJcblxyXG4gICAgR2FtZTogcmVxdWlyZSgnLi9ib290L0dhbWUnKVxyXG5cclxufTtcclxuKi9cclxuXHJcbnZhciBQaGFzZXIgPSB7XHJcblxyXG4gICAgQWN0aW9uczogcmVxdWlyZSgnLi9hY3Rpb25zLycpLFxyXG5cclxuICAgIENyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUvJyksXHJcblxyXG4gICAgQ2FtZXJhczogcmVxdWlyZSgnLi9jYW1lcmEvJyksXHJcblxyXG4gICAgRE9NOiByZXF1aXJlKCcuL2RvbS8nKSxcclxuXHJcbiAgICBHYW1lOiByZXF1aXJlKCcuL2Jvb3QvR2FtZScpLFxyXG5cclxuICAgIEV2ZW50OiByZXF1aXJlKCcuL2V2ZW50cy9FdmVudCcpLFxyXG4gICAgRXZlbnREaXNwYXRjaGVyOiByZXF1aXJlKCcuL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKSxcclxuXHJcbiAgICBNYXRoOiByZXF1aXJlKCcuL21hdGgnKSxcclxuXHJcbiAgICBHZW9tOiByZXF1aXJlKCcuL2dlb20nKSxcclxuXHJcbiAgICBHcmFwaGljczogcmVxdWlyZSgnLi9ncmFwaGljcycpLFxyXG5cclxuICAgIElucHV0OiByZXF1aXJlKCcuL2lucHV0JyksXHJcblxyXG4gICAgR2FtZU9iamVjdHM6IHJlcXVpcmUoJy4vZ2FtZW9iamVjdHMnKSxcclxuXHJcbiAgICBTY2VuZTogcmVxdWlyZSgnLi9zY2VuZS9sb2NhbC9TY2VuZScpLFxyXG5cclxuICAgIExvYWRlcjoge1xyXG5cclxuICAgICAgICBJbWFnZUZpbGU6IHJlcXVpcmUoJy4vbG9hZGVyL2ZpbGV0eXBlcy9JbWFnZUZpbGUnKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgU291bmQ6IHJlcXVpcmUoJy4vc291bmQnKSxcclxuXHJcbiAgICBTdHJ1Y3RzOiByZXF1aXJlKCcuL3N0cnVjdHMnKSxcclxuICAgIFxyXG4gICAgQ3VydmVzOiByZXF1aXJlKCcuL3BhdGhzL2N1cnZlcycpLFxyXG5cclxuICAgIFBhdGhzOiByZXF1aXJlKCcuL3BhdGhzJyksXHJcblxyXG4gICAgLy8gUGh5c2ljczogcmVxdWlyZSgnLi9waHlzaWNzJyksXHJcblxyXG4gICAgQ2xhc3M6IHJlcXVpcmUoJy4vdXRpbHMvQ2xhc3MnKSxcclxuXHJcbiAgICBVdGlsczogcmVxdWlyZSgnLi91dGlscycpXHJcblxyXG59O1xyXG5cclxuLy8gICBNZXJnZSBpbiB0aGUgY29uc3RzXHJcblxyXG5QaGFzZXIgPSBFeHRlbmQoZmFsc2UsIFBoYXNlciwgQ09OU1QpO1xyXG5cclxuLy8gIEV4cG9ydCBpdFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQaGFzZXI7XHJcblxyXG5nbG9iYWwuUGhhc2VyID0gUGhhc2VyO1xyXG5cclxuLypcclxuICogXCJEb2N1bWVudGF0aW9uIGlzIGxpa2Ugc2V4OiAgd2hlbiBpdCBpcyBnb29kLCBpdCBpcyB2ZXJ5LCB2ZXJ5IGdvb2Q7XHJcbiAqIGFuZCB3aGVuIGl0IGlzIGJhZCwgaXQgaXMgYmV0dGVyIHRoYW4gbm90aGluZy5cIlxyXG4gKiAgLS0gRGljayBCcmFuZG9uXHJcbiAqL1xyXG5cclxuLypcclxuICogXCJTb21ldGltZXMsIHRoZSBlbGVnYW50IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgYSBmdW5jdGlvbi5cclxuICogTm90IGEgbWV0aG9kLiBOb3QgYSBjbGFzcy4gTm90IGEgZnJhbWV3b3JrLiBKdXN0IGEgZnVuY3Rpb24uXCJcclxuICogIC0tIEpvaG4gQ2FybWFja1xyXG4gKi9cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waGFzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlBoeXNpY3MuSW1wYWN0LkJvZHlcclxuXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDT0xMSURFUyA9IHJlcXVpcmUoJy4vQ09MTElERVMnKTtcclxudmFyIEdldFZlbG9jaXR5ID0gcmVxdWlyZSgnLi9HZXRWZWxvY2l0eScpO1xyXG52YXIgVFlQRSA9IHJlcXVpcmUoJy4vVFlQRScpO1xyXG52YXIgVXBkYXRlTW90aW9uID0gcmVxdWlyZSgnLi9VcGRhdGVNb3Rpb24nKTtcclxuXHJcbi8qKlxyXG4qIEFuIEltcGFjdC5qcyBjb21wYXRpYmxlIHBoeXNpY3MgYm9keS5cclxuKiBUaGlzIHJlLWNyZWF0ZXMgdGhlIHByb3BlcnRpZXMgeW91J2QgZ2V0IG9uIGFuIEVudGl0eSBhbmQgdGhlIG1hdGggbmVlZGVkIHRvIHVwZGF0ZSB0aGVtLlxyXG4qL1xyXG5cclxudmFyIEJvZHkgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQm9keSAod29ybGQsIHgsIHksIHN4LCBzeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoc3ggPT09IHVuZGVmaW5lZCkgeyBzeCA9IDE2OyB9XHJcbiAgICAgICAgaWYgKHN5ID09PSB1bmRlZmluZWQpIHsgc3kgPSBzeDsgfVxyXG5cclxuICAgICAgICB0aGlzLndvcmxkID0gd29ybGQ7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdCA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMucGFyZW50O1xyXG5cclxuICAgICAgICB0aGlzLmlkID0gd29ybGQuZ2V0TmV4dElEKCk7XHJcblxyXG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xyXG5cclxuICAgICAgICB0aGlzLnNpemUgPSB7IHg6IHN4LCB5OiBzeSB9O1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgdGhpcy5wb3MgPSB7IHg6IHgsIHk6IHkgfTtcclxuICAgICAgICB0aGlzLmxhc3QgPSB7IHg6IHgsIHk6IHkgfTtcclxuICAgICAgICB0aGlzLnZlbCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIHRoaXMuYWNjZWwgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICB0aGlzLmZyaWN0aW9uID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgdGhpcy5tYXhWZWwgPSB7IHg6IHdvcmxkLmRlZmF1bHRzLm1heFZlbG9jaXR5WCwgeTogd29ybGQuZGVmYXVsdHMubWF4VmVsb2NpdHlZIH07XHJcblxyXG4gICAgICAgIHRoaXMuc3RhbmRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5ncmF2aXR5RmFjdG9yID0gd29ybGQuZGVmYXVsdHMuZ3Jhdml0eUZhY3RvcjtcclxuICAgICAgICB0aGlzLmJvdW5jaW5lc3MgPSB3b3JsZC5kZWZhdWx0cy5ib3VuY2luZXNzO1xyXG4gICAgICAgIHRoaXMubWluQm91bmNlVmVsb2NpdHkgPSB3b3JsZC5kZWZhdWx0cy5taW5Cb3VuY2VWZWxvY2l0eTtcclxuXHJcbiAgICAgICAgdGhpcy5hY2NlbEdyb3VuZCA9IDA7XHJcbiAgICAgICAgdGhpcy5hY2NlbEFpciA9IDA7XHJcbiAgICAgICAgdGhpcy5qdW1wU3BlZWQgPSAwO1xyXG4gICAgXHJcbiAgICAgICAgdGhpcy50eXBlID0gVFlQRS5OT05FO1xyXG4gICAgICAgIHRoaXMuY2hlY2tBZ2FpbnN0ID0gVFlQRS5OT05FO1xyXG4gICAgICAgIHRoaXMuY29sbGlkZXMgPSBDT0xMSURFUy5ORVZFUjtcclxuXHJcbiAgICAgICAgdGhpcy5kZWJ1Z1Nob3dCb2R5ID0gd29ybGQuZGVmYXVsdHMuZGVidWdTaG93Qm9keTtcclxuICAgICAgICB0aGlzLmRlYnVnU2hvd1ZlbG9jaXR5ID0gd29ybGQuZGVmYXVsdHMuZGVidWdTaG93VmVsb2NpdHk7XHJcbiAgICAgICAgdGhpcy5kZWJ1Z0JvZHlDb2xvciA9IHdvcmxkLmRlZmF1bHRzLmJvZHlEZWJ1Z0NvbG9yO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrO1xyXG4gICAgXHJcbiAgICAgICAgLy8gIG1pbiA0NCBkZWcsIG1heCAxMzYgZGVnXHJcbiAgICAgICAgdGhpcy5zbG9wZVN0YW5kaW5nID0geyBtaW46IDAuNzY3OTQ0ODcwODc3NTA1LCBtYXg6IDIuMzczNjQ3NzgyNzEyMjg4NCB9O1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wb3MgPSB7IHg6IHgsIHk6IHkgfTtcclxuICAgICAgICB0aGlzLmxhc3QgPSB7IHg6IHgsIHk6IHkgfTtcclxuICAgICAgICB0aGlzLnZlbCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIHRoaXMuYWNjZWwgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICB0aGlzLmZyaWN0aW9uID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgdGhpcy5tYXhWZWwgPSB7IHg6IDEwMCwgeTogMTAwIH07XHJcblxyXG4gICAgICAgIHRoaXMuc3RhbmRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5ncmF2aXR5RmFjdG9yID0gMTtcclxuICAgICAgICB0aGlzLmJvdW5jaW5lc3MgPSAwO1xyXG4gICAgICAgIHRoaXMubWluQm91bmNlVmVsb2NpdHkgPSA0MDtcclxuXHJcbiAgICAgICAgdGhpcy5hY2NlbEdyb3VuZCA9IDA7XHJcbiAgICAgICAgdGhpcy5hY2NlbEFpciA9IDA7XHJcbiAgICAgICAgdGhpcy5qdW1wU3BlZWQgPSAwO1xyXG4gICAgXHJcbiAgICAgICAgdGhpcy50eXBlID0gVFlQRS5OT05FO1xyXG4gICAgICAgIHRoaXMuY2hlY2tBZ2FpbnN0ID0gVFlQRS5OT05FO1xyXG4gICAgICAgIHRoaXMuY29sbGlkZXMgPSBDT0xMSURFUy5ORVZFUjtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGVsdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zO1xyXG5cclxuICAgICAgICB0aGlzLmxhc3QueCA9IHBvcy54O1xyXG4gICAgICAgIHRoaXMubGFzdC55ID0gcG9zLnk7XHJcblxyXG4gICAgICAgIHRoaXMudmVsLnkgKz0gdGhpcy53b3JsZC5ncmF2aXR5ICogZGVsdGEgKiB0aGlzLmdyYXZpdHlGYWN0b3I7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy52ZWwueCA9IEdldFZlbG9jaXR5KGRlbHRhLCB0aGlzLnZlbC54LCB0aGlzLmFjY2VsLngsIHRoaXMuZnJpY3Rpb24ueCwgdGhpcy5tYXhWZWwueCk7XHJcbiAgICAgICAgdGhpcy52ZWwueSA9IEdldFZlbG9jaXR5KGRlbHRhLCB0aGlzLnZlbC55LCB0aGlzLmFjY2VsLnksIHRoaXMuZnJpY3Rpb24ueSwgdGhpcy5tYXhWZWwueSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG14ID0gdGhpcy52ZWwueCAqIGRlbHRhO1xyXG4gICAgICAgIHZhciBteSA9IHRoaXMudmVsLnkgKiBkZWx0YTtcclxuXHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMud29ybGQuY29sbGlzaW9uTWFwLnRyYWNlKHBvcy54LCBwb3MueSwgbXgsIG15LCB0aGlzLnNpemUueCwgdGhpcy5zaXplLnkpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oYW5kbGVNb3ZlbWVudFRyYWNlKHJlcykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBVcGRhdGVNb3Rpb24odGhpcywgcmVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBnbyA9IHRoaXMuZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgaWYgKGdvKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ28ueCA9IChwb3MueCAtIHRoaXMub2Zmc2V0LngpICsgZ28uZGlzcGxheU9yaWdpblggKiBnby5zY2FsZVg7XHJcbiAgICAgICAgICAgIGdvLnkgPSAocG9zLnkgLSB0aGlzLm9mZnNldC55KSArIGdvLmRpc3BsYXlPcmlnaW5ZICogZ28uc2NhbGVZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlQ2FsbGJhY2spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZHJhd0RlYnVnOiBmdW5jdGlvbiAoZ3JhcGhpYylcclxuICAgIHtcclxuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3M7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRlYnVnU2hvd0JvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBncmFwaGljLmxpbmVTdHlsZSgxLCB0aGlzLmRlYnVnQm9keUNvbG9yLCAxKTtcclxuICAgICAgICAgICAgZ3JhcGhpYy5zdHJva2VSZWN0KHBvcy54LCBwb3MueSwgdGhpcy5zaXplLngsIHRoaXMuc2l6ZS55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRlYnVnU2hvd1ZlbG9jaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHggPSBwb3MueCArIHRoaXMuc2l6ZS54IC8gMjtcclxuICAgICAgICAgICAgdmFyIHkgPSBwb3MueSArIHRoaXMuc2l6ZS55IC8gMjtcclxuXHJcbiAgICAgICAgICAgIGdyYXBoaWMubGluZVN0eWxlKDEsIHRoaXMud29ybGQuZGVmYXVsdHMudmVsb2NpdHlEZWJ1Z0NvbG9yLCAxKTtcclxuICAgICAgICAgICAgZ3JhcGhpYy5saW5lQmV0d2Vlbih4LCB5LCB4ICsgdGhpcy52ZWwueCwgeSArIHRoaXMudmVsLnkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgd2lsbERyYXdEZWJ1ZzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZGVidWdTaG93Qm9keSB8fCB0aGlzLmRlYnVnU2hvd1ZlbG9jaXR5KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2tpcEhhc2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICghdGhpcy5lbmFibGVkIHx8ICh0aGlzLnR5cGUgPT09IDAgJiYgdGhpcy5jaGVja0FnYWluc3QgPT09IDAgJiYgdGhpcy5jb2xsaWRlcyA9PT0gMCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b3VjaGVzOiBmdW5jdGlvbiAob3RoZXIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICEoXHJcbiAgICAgICAgICAgIHRoaXMucG9zLnggPj0gb3RoZXIucG9zLnggKyBvdGhlci5zaXplLnggfHxcclxuICAgICAgICAgICAgdGhpcy5wb3MueCArIHRoaXMuc2l6ZS54IDw9IG90aGVyLnBvcy54IHx8XHJcbiAgICAgICAgICAgIHRoaXMucG9zLnkgPj0gb3RoZXIucG9zLnkgKyBvdGhlci5zaXplLnkgfHxcclxuICAgICAgICAgICAgdGhpcy5wb3MueSArIHRoaXMuc2l6ZS55IDw9IG90aGVyLnBvcy55XHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRTaXplOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBvcy54ID0geDtcclxuICAgICAgICB0aGlzLnBvcy55ID0geTtcclxuICAgICAgICB0aGlzLnNpemUueCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuc2l6ZS55ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgc2l6ZTogeyB4OiB0aGlzLnNpemUueCwgeTogdGhpcy5zaXplLnkgfSxcclxuICAgICAgICAgICAgcG9zOiB7IHg6IHRoaXMucG9zLngsIHk6IHRoaXMucG9zLnkgfSxcclxuICAgICAgICAgICAgdmVsOiB7IHg6IHRoaXMudmVsLngsIHk6IHRoaXMudmVsLnkgfSxcclxuICAgICAgICAgICAgYWNjZWw6IHsgeDogdGhpcy5hY2NlbC54LCB5OiB0aGlzLmFjY2VsLnkgfSxcclxuICAgICAgICAgICAgZnJpY3Rpb246IHsgeDogdGhpcy5mcmljdGlvbi54LCB5OiB0aGlzLmZyaWN0aW9uLnkgfSxcclxuICAgICAgICAgICAgbWF4VmVsOiB7IHg6IHRoaXMubWF4VmVsLngsIHk6IHRoaXMubWF4VmVsLnkgfSxcclxuICAgICAgICAgICAgZ3Jhdml0eUZhY3RvcjogdGhpcy5ncmF2aXR5RmFjdG9yLFxyXG4gICAgICAgICAgICBib3VuY2luZXNzOiB0aGlzLmJvdW5jaW5lc3MsXHJcbiAgICAgICAgICAgIG1pbkJvdW5jZVZlbG9jaXR5OiB0aGlzLm1pbkJvdW5jZVZlbG9jaXR5LFxyXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIGNoZWNrQWdhaW5zdDogdGhpcy5jaGVja0FnYWluc3QsXHJcbiAgICAgICAgICAgIGNvbGxpZGVzOiB0aGlzLmNvbGxpZGVzXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0sXHJcblxyXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uIChjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRPRE9cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgY29kZVxyXG4gICAgY2hlY2s6IGZ1bmN0aW9uIChvdGhlcilcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgY29kZVxyXG4gICAgY29sbGlkZVdpdGg6IGZ1bmN0aW9uIChvdGhlciwgYXhpcylcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuX2NvbGxpZGVDYWxsYmFjaylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9jb2xsaWRlQ2FsbGJhY2suY2FsbCh0aGlzLnBhcmVudC5fY2FsbGJhY2tTY29wZSwgdGhpcywgb3RoZXIsIGF4aXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgY29kZSBidXQgbXVzdCByZXR1cm4gYSBib29sZWFuXHJcbiAgICBoYW5kbGVNb3ZlbWVudFRyYWNlOiBmdW5jdGlvbiAocmVzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLndvcmxkID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJvZHk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvQm9keS5qc1xuLy8gbW9kdWxlIGlkID0gODUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuUGh5c2ljcy5JbXBhY3QuQ29sbGlzaW9uTWFwXHJcblxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRGVmYXVsdERlZnMgPSByZXF1aXJlKCcuL0RlZmF1bHREZWZzJyk7XHJcblxyXG52YXIgQ29sbGlzaW9uTWFwID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIENvbGxpc2lvbk1hcCAodGlsZXNpemUsIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRpbGVzaXplID09PSB1bmRlZmluZWQpIHsgdGlsZXNpemUgPSAzMjsgfVxyXG5cclxuICAgICAgICB0aGlzLnRpbGVzaXplID0gdGlsZXNpemU7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IChBcnJheS5pc0FycmF5KGRhdGEpKSA/IGRhdGEgOiBbXTtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IChBcnJheS5pc0FycmF5KGRhdGEpKSA/IGRhdGFbMF0ubGVuZ3RoIDogMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IChBcnJheS5pc0FycmF5KGRhdGEpKSA/IGRhdGEubGVuZ3RoIDogMDtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0U2xvcGUgPSA1NTtcclxuXHJcbiAgICAgICAgdGhpcy50aWxlZGVmID0gRGVmYXVsdERlZnM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYWNlOiBmdW5jdGlvbiAoeCwgeSwgdngsIHZ5LCBvYmplY3RXaWR0aCwgb2JqZWN0SGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIC8vIFNldCB1cCB0aGUgdHJhY2UtcmVzdWx0XHJcbiAgICAgICAgdmFyIHJlcyA9IHtcclxuICAgICAgICAgICAgY29sbGlzaW9uOiB7IHg6IGZhbHNlLCB5OiBmYWxzZSwgc2xvcGU6IGZhbHNlIH0sXHJcbiAgICAgICAgICAgIHBvczogeyB4OiB4ICsgdngsIHk6IHkgKyB2eSB9LFxyXG4gICAgICAgICAgICB0aWxlOiB7IHg6IDAsIHk6IDAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5kYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHN0ZXBzID0gTWF0aC5jZWlsKE1hdGgubWF4KE1hdGguYWJzKHZ4KSwgTWF0aC5hYnModnkpKSAvIHRoaXMudGlsZXNpemUpO1xyXG5cclxuICAgICAgICBpZiAoc3RlcHMgPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN4ID0gdnggLyBzdGVwcztcclxuICAgICAgICAgICAgdmFyIHN5ID0gdnkgLyBzdGVwcztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcHMgJiYgKHN4IHx8IHN5KTsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXAocmVzLCB4LCB5LCBzeCwgc3ksIG9iamVjdFdpZHRoLCBvYmplY3RIZWlnaHQsIHZ4LCB2eSwgaSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHggPSByZXMucG9zLng7XHJcbiAgICAgICAgICAgICAgICB5ID0gcmVzLnBvcy55O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZXMuY29sbGlzaW9uLngpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZ4ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzLmNvbGxpc2lvbi55KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2eSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcy5jb2xsaXNpb24uc2xvcGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGVwKHJlcywgeCwgeSwgdngsIHZ5LCBvYmplY3RXaWR0aCwgb2JqZWN0SGVpZ2h0LCB2eCwgdnksIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGVwOiBmdW5jdGlvbiAocmVzLCB4LCB5LCB2eCwgdnksIHdpZHRoLCBoZWlnaHQsIHJ2eCwgcnZ5LCBzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ID0gMDtcclxuICAgICAgICB2YXIgdGlsZVg7XHJcbiAgICAgICAgdmFyIHRpbGVZO1xyXG4gICAgICAgIHZhciB0aWxlc2l6ZSA9IHRoaXMudGlsZXNpemU7XHJcbiAgICAgICAgdmFyIG1hcFdpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICB2YXIgbWFwSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gIEhvcml6b250YWxcclxuICAgICAgICBpZiAodngpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcHhPZmZzZXRYID0gKHZ4ID4gMCA/IHdpZHRoIDogMCk7XHJcbiAgICAgICAgICAgIHZhciB0aWxlT2Zmc2V0WCA9ICh2eCA8IDAgPyB0aWxlc2l6ZSA6IDApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGZpcnN0VGlsZVkgPSBNYXRoLm1heChNYXRoLmZsb29yKHkgLyB0aWxlc2l6ZSksIDApO1xyXG4gICAgICAgICAgICB2YXIgbGFzdFRpbGVZID0gTWF0aC5taW4oTWF0aC5jZWlsKCh5ICsgaGVpZ2h0KSAvIHRpbGVzaXplKSwgbWFwSGVpZ2h0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRpbGVYID0gTWF0aC5mbG9vcigocmVzLnBvcy54ICsgcHhPZmZzZXRYKSAvIHRpbGVzaXplKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcmV2VGlsZVggPSBNYXRoLmZsb29yKCh4ICsgcHhPZmZzZXRYKSAvIHRpbGVzaXplKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdGVwID4gMCB8fCB0aWxlWCA9PT0gcHJldlRpbGVYIHx8IHByZXZUaWxlWCA8IDAgfHwgcHJldlRpbGVYID49IG1hcFdpZHRoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwcmV2VGlsZVggPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGlsZVggPj0gMCAmJiB0aWxlWCA8IG1hcFdpZHRoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHRpbGVZID0gZmlyc3RUaWxlWTsgdGlsZVkgPCBsYXN0VGlsZVk7IHRpbGVZKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZUaWxlWCAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5kYXRhW3RpbGVZXVtwcmV2VGlsZVhdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPiAxICYmIHQgPD0gdGhpcy5sYXN0U2xvcGUgJiYgdGhpcy5jaGVja0RlZihyZXMsIHQsIHgsIHksIHJ2eCwgcnZ5LCB3aWR0aCwgaGVpZ2h0LCBwcmV2VGlsZVgsIHRpbGVZKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHRoaXMuZGF0YVt0aWxlWV1bdGlsZVhdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PT0gMSB8fCB0ID4gdGhpcy5sYXN0U2xvcGUgfHwgKHQgPiAxICYmIHRoaXMuY2hlY2tEZWYocmVzLCB0LCB4LCB5LCBydngsIHJ2eSwgd2lkdGgsIGhlaWdodCwgdGlsZVgsIHRpbGVZKSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA+IDEgJiYgdCA8PSB0aGlzLmxhc3RTbG9wZSAmJiByZXMuY29sbGlzaW9uLnNsb3BlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmNvbGxpc2lvbi54ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnRpbGUueCA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wb3MueCA9ICh0aWxlWCAqIHRpbGVzaXplKSAtIHB4T2Zmc2V0WCArIHRpbGVPZmZzZXRYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcmVzLnBvcy54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydnggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vICBWZXJ0aWNhbFxyXG4gICAgICAgIGlmICh2eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBweE9mZnNldFkgPSAodnkgPiAwID8gaGVpZ2h0IDogMCk7XHJcbiAgICAgICAgICAgIHZhciB0aWxlT2Zmc2V0WSA9ICh2eSA8IDAgPyB0aWxlc2l6ZSA6IDApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGZpcnN0VGlsZVggPSBNYXRoLm1heChNYXRoLmZsb29yKHJlcy5wb3MueCAvIHRpbGVzaXplKSwgMCk7XHJcbiAgICAgICAgICAgIHZhciBsYXN0VGlsZVggPSBNYXRoLm1pbihNYXRoLmNlaWwoKHJlcy5wb3MueCArIHdpZHRoKSAvIHRpbGVzaXplKSwgbWFwV2lkdGgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGlsZVkgPSBNYXRoLmZsb29yKChyZXMucG9zLnkgKyBweE9mZnNldFkpIC8gdGlsZXNpemUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHByZXZUaWxlWSA9IE1hdGguZmxvb3IoKHkgKyBweE9mZnNldFkpIC8gdGlsZXNpemUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0ZXAgPiAwIHx8IHRpbGVZID09PSBwcmV2VGlsZVkgfHwgcHJldlRpbGVZIDwgMCB8fCBwcmV2VGlsZVkgPj0gbWFwSGVpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwcmV2VGlsZVkgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHRpbGVZID49IDAgJiYgdGlsZVkgPCBtYXBIZWlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodGlsZVggPSBmaXJzdFRpbGVYOyB0aWxlWCA8IGxhc3RUaWxlWDsgdGlsZVgrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRpbGVZICE9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB0aGlzLmRhdGFbcHJldlRpbGVZXVt0aWxlWF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA+IDEgJiYgdCA8PSB0aGlzLmxhc3RTbG9wZSAmJiB0aGlzLmNoZWNrRGVmKHJlcywgdCwgeCwgeSwgcnZ4LCBydnksIHdpZHRoLCBoZWlnaHQsIHRpbGVYLCBwcmV2VGlsZVkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5kYXRhW3RpbGVZXVt0aWxlWF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09PSAxIHx8IHQgPiB0aGlzLmxhc3RTbG9wZSB8fCAodCA+IDEgJiYgdGhpcy5jaGVja0RlZihyZXMsIHQsIHgsIHksIHJ2eCwgcnZ5LCB3aWR0aCwgaGVpZ2h0LCB0aWxlWCwgdGlsZVkpKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID4gMSAmJiB0IDw9IHRoaXMubGFzdFNsb3BlICYmIHJlcy5jb2xsaXNpb24uc2xvcGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuY29sbGlzaW9uLnkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMudGlsZS55ID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnBvcy55ID0gdGlsZVkgKiB0aWxlc2l6ZSAtIHB4T2Zmc2V0WSArIHRpbGVPZmZzZXRZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY2hlY2tEZWY6IGZ1bmN0aW9uIChyZXMsIHQsIHgsIHksIHZ4LCB2eSwgd2lkdGgsIGhlaWdodCwgdGlsZVgsIHRpbGVZKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkZWYgPSB0aGlzLnRpbGVkZWZbdF07XHJcblxyXG4gICAgICAgIGlmICghZGVmKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRpbGVzaXplID0gdGhpcy50aWxlc2l6ZTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbHggPSAodGlsZVggKyBkZWZbMF0pICogdGlsZXNpemU7XHJcbiAgICAgICAgdmFyIGx5ID0gKHRpbGVZICsgZGVmWzFdKSAqIHRpbGVzaXplO1xyXG4gICAgICAgIHZhciBsdnggPSAoZGVmWzJdIC0gZGVmWzBdKSAqIHRpbGVzaXplO1xyXG4gICAgICAgIHZhciBsdnkgPSAoZGVmWzNdIC0gZGVmWzFdKSAqIHRpbGVzaXplO1xyXG4gICAgICAgIHZhciBzb2xpZCA9IGRlZls0XTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdHggPSB4ICsgdnggKyAobHZ5IDwgMCA/IHdpZHRoIDogMCkgLSBseDtcclxuICAgICAgICB2YXIgdHkgPSB5ICsgdnkgKyAobHZ4ID4gMCA/IGhlaWdodCA6IDApIC0gbHk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGx2eCAqIHR5IC0gbHZ5ICogdHggPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZ4ICogLWx2eSArIHZ5ICogbHZ4IDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvbGlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KGx2eCAqIGx2eCArIGx2eSAqIGx2eSk7XHJcbiAgICAgICAgICAgIHZhciBueCA9IGx2eSAvIGxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIG55ID0gLWx2eCAvIGxlbmd0aDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBwcm9qID0gdHggKiBueCArIHR5ICogbnk7XHJcbiAgICAgICAgICAgIHZhciBweCA9IG54ICogcHJvajtcclxuICAgICAgICAgICAgdmFyIHB5ID0gbnkgKiBwcm9qO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHB4ICogcHggKyBweSAqIHB5ID49IHZ4ICogdnggKyB2eSAqIHZ5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc29saWQgfHwgKGx2eCAqICh0eSAtIHZ5KSAtIGx2eSAqICh0eCAtIHZ4KSA8IDAuNSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJlcy5wb3MueCA9IHggKyB2eCAtIHB4O1xyXG4gICAgICAgICAgICByZXMucG9zLnkgPSB5ICsgdnkgLSBweTtcclxuICAgICAgICAgICAgcmVzLmNvbGxpc2lvbi5zbG9wZSA9IHsgeDogbHZ4LCB5OiBsdnksIG54OiBueCwgbnk6IG55IH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvbk1hcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9Db2xsaXNpb25NYXAuanNcbi8vIG1vZHVsZSBpZCA9IDg1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSCA9IDAuNTtcclxudmFyIE4gPSAxIC8gMztcclxudmFyIE0gPSAyIC8gMztcclxuXHJcbi8vICBUaWxlIElEIHRvIFNsb3BlIGRlZnMuXHJcbi8vICBGaXJzdCA0IGVsZW1lbnRzID0gbGluZSBkYXRhLCBmaW5hbCA9IHNvbGlkIG9yIG5vbi1zb2xpZCBiZWhpbmQgdGhlIGxpbmVcclxuICAgIFxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICAyOiBbIDAsIDEsIDEsIDAsIHRydWUgXSxcclxuICAgIDM6IFsgMCwgMSwgMSwgSCwgdHJ1ZSBdLFxyXG4gICAgNDogWyAwLCBILCAxLCAwLCB0cnVlIF0sXHJcbiAgICA1OiBbIDAsIDEsIDEsIE0sIHRydWUgXSxcclxuICAgIDY6IFsgMCwgTSwgMSwgTiwgdHJ1ZSBdLFxyXG4gICAgNzogWyAwLCBOLCAxLCAwLCB0cnVlIF0sXHJcbiAgICA4OiBbIEgsIDEsIDAsIDAsIHRydWUgXSxcclxuICAgIDk6IFsgMSwgMCwgSCwgMSwgdHJ1ZSBdLFxyXG4gICAgMTA6IFsgSCwgMSwgMSwgMCwgdHJ1ZSBdLFxyXG4gICAgMTE6IFsgMCwgMCwgSCwgMSwgdHJ1ZSBdLFxyXG4gICAgMTI6IFsgMCwgMCwgMSwgMCwgZmFsc2UgXSxcclxuICAgIDEzOiBbIDEsIDEsIDAsIDAsIHRydWUgXSxcclxuICAgIDE0OiBbIDEsIEgsIDAsIDAsIHRydWUgXSxcclxuICAgIDE1OiBbIDEsIDEsIDAsIEgsIHRydWUgXSxcclxuICAgIDE2OiBbIDEsIE4sIDAsIDAsIHRydWUgXSxcclxuICAgIDE3OiBbIDEsIE0sIDAsIE4sIHRydWUgXSxcclxuICAgIDE4OiBbIDEsIDEsIDAsIE0sIHRydWUgXSxcclxuICAgIDE5OiBbIDEsIDEsIEgsIDAsIHRydWUgXSxcclxuICAgIDIwOiBbIEgsIDAsIDAsIDEsIHRydWUgXSxcclxuICAgIDIxOiBbIDAsIDEsIEgsIDAsIHRydWUgXSxcclxuICAgIDIyOiBbIEgsIDAsIDEsIDEsIHRydWUgXSxcclxuICAgIDIzOiBbIDEsIDEsIDAsIDEsIGZhbHNlIF0sXHJcbiAgICAyNDogWyAwLCAwLCAxLCAxLCB0cnVlIF0sXHJcbiAgICAyNTogWyAwLCAwLCAxLCBILCB0cnVlIF0sXHJcbiAgICAyNjogWyAwLCBILCAxLCAxLCB0cnVlIF0sXHJcbiAgICAyNzogWyAwLCAwLCAxLCBOLCB0cnVlIF0sXHJcbiAgICAyODogWyAwLCBOLCAxLCBNLCB0cnVlIF0sXHJcbiAgICAyOTogWyAwLCBNLCAxLCAxLCB0cnVlIF0sXHJcbiAgICAzMDogWyBOLCAxLCAwLCAwLCB0cnVlIF0sXHJcbiAgICAzMTogWyAxLCAwLCBNLCAxLCB0cnVlIF0sXHJcbiAgICAzMjogWyBNLCAxLCAxLCAwLCB0cnVlIF0sXHJcbiAgICAzMzogWyAwLCAwLCBOLCAxLCB0cnVlIF0sXHJcbiAgICAzNDogWyAxLCAwLCAxLCAxLCBmYWxzZSBdLFxyXG4gICAgMzU6IFsgMSwgMCwgMCwgMSwgdHJ1ZSBdLFxyXG4gICAgMzY6IFsgMSwgSCwgMCwgMSwgdHJ1ZSBdLFxyXG4gICAgMzc6IFsgMSwgMCwgMCwgSCwgdHJ1ZSBdLFxyXG4gICAgMzg6IFsgMSwgTSwgMCwgMSwgdHJ1ZSBdLFxyXG4gICAgMzk6IFsgMSwgTiwgMCwgTSwgdHJ1ZSBdLFxyXG4gICAgNDA6IFsgMSwgMCwgMCwgTiwgdHJ1ZSBdLFxyXG4gICAgNDE6IFsgTSwgMSwgTiwgMCwgdHJ1ZSBdLFxyXG4gICAgNDI6IFsgTSwgMCwgTiwgMSwgdHJ1ZSBdLFxyXG4gICAgNDM6IFsgTiwgMSwgTSwgMCwgdHJ1ZSBdLFxyXG4gICAgNDQ6IFsgTiwgMCwgTSwgMSwgdHJ1ZSBdLFxyXG4gICAgNDU6IFsgMCwgMSwgMCwgMCwgZmFsc2UgXSxcclxuICAgIDUyOiBbIDEsIDEsIE0sIDAsIHRydWUgXSxcclxuICAgIDUzOiBbIE4sIDAsIDAsIDEsIHRydWUgXSxcclxuICAgIDU0OiBbIDAsIDEsIE4sIDAsIHRydWUgXSxcclxuICAgIDU1OiBbIE0sIDAsIDEsIDEsIHRydWUgXVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9EZWZhdWx0RGVmcy5qc1xuLy8gbW9kdWxlIGlkID0gODU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBJbXBhY3RCb2R5ID0gcmVxdWlyZSgnLi9JbXBhY3RCb2R5Jyk7XHJcbnZhciBJbXBhY3RJbWFnZSA9IHJlcXVpcmUoJy4vSW1wYWN0SW1hZ2UnKTtcclxudmFyIEltcGFjdFNwcml0ZSA9IHJlcXVpcmUoJy4vSW1wYWN0U3ByaXRlJyk7XHJcblxyXG52YXIgRmFjdG9yeSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBGYWN0b3J5ICh3b3JsZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLndvcmxkID0gd29ybGQ7XHJcblxyXG4gICAgICAgIHRoaXMuc3lzID0gd29ybGQuc2NlbmUuc3lzO1xyXG4gICAgfSxcclxuXHJcbiAgICBib2R5OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IEltcGFjdEJvZHkodGhpcy53b3JsZCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGltYWdlOiBmdW5jdGlvbiAoeCwgeSwga2V5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1wYWN0SW1hZ2UodGhpcy53b3JsZCwgeCwgeSwga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMuc3lzLmRpc3BsYXlMaXN0LmFkZChpbWFnZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgIH0sXHJcblxyXG4gICAgc3ByaXRlOiBmdW5jdGlvbiAoeCwgeSwga2V5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgc3ByaXRlID0gbmV3IEltcGFjdFNwcml0ZSh0aGlzLndvcmxkLCB4LCB5LCBrZXksIGZyYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5zeXMuZGlzcGxheUxpc3QuYWRkKHNwcml0ZSk7XHJcbiAgICAgICAgdGhpcy5zeXMudXBkYXRlTGlzdC5hZGQoc3ByaXRlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNwcml0ZTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L0ZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDg1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhbXAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL0NsYW1wJyk7XHJcblxyXG52YXIgR2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoZGVsdGEsIHZlbCwgYWNjZWwsIGZyaWN0aW9uLCBtYXgpXHJcbntcclxuICAgIGlmIChhY2NlbClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gQ2xhbXAodmVsICsgYWNjZWwgKiBkZWx0YSwgLW1heCwgbWF4KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZyaWN0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmcmljdGlvbkRlbHRhID0gZnJpY3Rpb24gKiBkZWx0YTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodmVsIC0gZnJpY3Rpb25EZWx0YSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdmVsIC0gZnJpY3Rpb25EZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmVsICsgZnJpY3Rpb25EZWx0YSA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdmVsICsgZnJpY3Rpb25EZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBDbGFtcCh2ZWwsIC1tYXgsIG1heCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFZlbG9jaXR5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L0dldFZlbG9jaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSA4NTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIE1lcmdlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L01lcmdlJyk7XHJcbnZhciBXb3JsZCA9IHJlcXVpcmUoJy4vV29ybGQnKTtcclxudmFyIEZhY3RvcnkgPSByZXF1aXJlKCcuL0ZhY3RvcnknKTtcclxuXHJcbnZhciBJbXBhY3QgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gSW1wYWN0IChwaHlzaWNzTWFuYWdlciwgY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG5cclxuICAgICAgICBwaHlzaWNzTWFuYWdlci53b3JsZCA9IG5ldyBXb3JsZChwaHlzaWNzTWFuYWdlci5zY2VuZSwgY29uZmlnKTtcclxuXHJcbiAgICAgICAgcGh5c2ljc01hbmFnZXIuYWRkID0gbmV3IEZhY3RvcnkocGh5c2ljc01hbmFnZXIud29ybGQpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltcGFjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9JbXBhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDg1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMnKTtcclxuXHJcbnZhciBJbXBhY3RCb2R5ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFjY2VsZXJhdGlvbixcclxuICAgICAgICBDb21wb25lbnRzLkJvZHlTY2FsZSxcclxuICAgICAgICBDb21wb25lbnRzLkJvZHlUeXBlLFxyXG4gICAgICAgIENvbXBvbmVudHMuQm91bmNlLFxyXG4gICAgICAgIENvbXBvbmVudHMuQ2hlY2tBZ2FpbnN0LFxyXG4gICAgICAgIENvbXBvbmVudHMuQ29sbGlkZXMsXHJcbiAgICAgICAgQ29tcG9uZW50cy5EZWJ1ZyxcclxuICAgICAgICBDb21wb25lbnRzLkZyaWN0aW9uLFxyXG4gICAgICAgIENvbXBvbmVudHMuR3Jhdml0eSxcclxuICAgICAgICBDb21wb25lbnRzLk9mZnNldCxcclxuICAgICAgICBDb21wb25lbnRzLlNldEdhbWVPYmplY3QsXHJcbiAgICAgICAgQ29tcG9uZW50cy5WZWxvY2l0eVxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIC8vICB4L3kgaXMgdGhlIHRvcC1sZWZ0IG9mIHRoZSBCb2R5XHJcbiAgICBmdW5jdGlvbiBJbXBhY3RCb2R5ICh3b3JsZCwgeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJvZHkgPSB3b3JsZC5jcmVhdGUoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuYm9keS5wYXJlbnQgPSB0aGlzO1xyXG5cclxuICAgICAgICAvLyAgTG9jYWwgcmVmZXJlbmNlcyB0byB0aGUgQm9keSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5ib2R5LnNpemU7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLmJvZHkub2Zmc2V0O1xyXG4gICAgICAgIHRoaXMudmVsID0gdGhpcy5ib2R5LnZlbDtcclxuICAgICAgICB0aGlzLmFjY2VsID0gdGhpcy5ib2R5LmFjY2VsO1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb24gPSB0aGlzLmJvZHkuZnJpY3Rpb247XHJcbiAgICAgICAgdGhpcy5tYXhWZWwgPSB0aGlzLmJvZHkubWF4VmVsO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltcGFjdEJvZHk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvSW1wYWN0Qm9keS5qc1xuLy8gbW9kdWxlIGlkID0gODU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4vY29tcG9uZW50cycpO1xyXG52YXIgSW1hZ2UgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZScpO1xyXG5cclxudmFyIEltcGFjdEltYWdlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBJbWFnZSxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFjY2VsZXJhdGlvbixcclxuICAgICAgICBDb21wb25lbnRzLkJvZHlTY2FsZSxcclxuICAgICAgICBDb21wb25lbnRzLkJvZHlUeXBlLFxyXG4gICAgICAgIENvbXBvbmVudHMuQm91bmNlLFxyXG4gICAgICAgIENvbXBvbmVudHMuQ2hlY2tBZ2FpbnN0LFxyXG4gICAgICAgIENvbXBvbmVudHMuQ29sbGlkZXMsXHJcbiAgICAgICAgQ29tcG9uZW50cy5EZWJ1ZyxcclxuICAgICAgICBDb21wb25lbnRzLkZyaWN0aW9uLFxyXG4gICAgICAgIENvbXBvbmVudHMuR3Jhdml0eSxcclxuICAgICAgICBDb21wb25lbnRzLk9mZnNldCxcclxuICAgICAgICBDb21wb25lbnRzLlNldEdhbWVPYmplY3QsXHJcbiAgICAgICAgQ29tcG9uZW50cy5WZWxvY2l0eVxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIC8vICB4L3kgaXMgdGhlIGNlbnRlciBvZiB0aGUgSW1hZ2UgLyBCb2R5LCBqdXN0IGxpa2Ugb3RoZXIgZGVmYXVsdCBHYW1lIE9iamVjdHNcclxuICAgIGZ1bmN0aW9uIEltcGFjdEltYWdlICh3b3JsZCwgeCwgeSwgdGV4dHVyZSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgSW1hZ2UuY2FsbCh0aGlzLCB3b3JsZC5zY2VuZSwgeCwgeSwgdGV4dHVyZSwgZnJhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmJvZHkgPSB3b3JsZC5jcmVhdGUoeCAtIHRoaXMuZnJhbWUuY2VudGVyWCwgeSAtIHRoaXMuZnJhbWUuY2VudGVyWSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLmJvZHkucGFyZW50ID0gdGhpcztcclxuICAgICAgICB0aGlzLmJvZHkuZ2FtZU9iamVjdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8vICBMb2NhbCByZWZlcmVuY2VzIHRvIHRoZSBCb2R5IHByb3BlcnRpZXNcclxuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmJvZHkuc2l6ZTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMuYm9keS5vZmZzZXQ7XHJcbiAgICAgICAgdGhpcy52ZWwgPSB0aGlzLmJvZHkudmVsO1xyXG4gICAgICAgIHRoaXMuYWNjZWwgPSB0aGlzLmJvZHkuYWNjZWw7XHJcbiAgICAgICAgdGhpcy5mcmljdGlvbiA9IHRoaXMuYm9keS5mcmljdGlvbjtcclxuICAgICAgICB0aGlzLm1heFZlbCA9IHRoaXMuYm9keS5tYXhWZWw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1wYWN0SW1hZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvSW1wYWN0SW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDg1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMnKTtcclxudmFyIFNwcml0ZSA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGUnKTtcclxuXHJcbnZhciBJbXBhY3RTcHJpdGUgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IFNwcml0ZSxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFjY2VsZXJhdGlvbixcclxuICAgICAgICBDb21wb25lbnRzLkJvZHlTY2FsZSxcclxuICAgICAgICBDb21wb25lbnRzLkJvZHlUeXBlLFxyXG4gICAgICAgIENvbXBvbmVudHMuQm91bmNlLFxyXG4gICAgICAgIENvbXBvbmVudHMuQ2hlY2tBZ2FpbnN0LFxyXG4gICAgICAgIENvbXBvbmVudHMuQ29sbGlkZXMsXHJcbiAgICAgICAgQ29tcG9uZW50cy5EZWJ1ZyxcclxuICAgICAgICBDb21wb25lbnRzLkZyaWN0aW9uLFxyXG4gICAgICAgIENvbXBvbmVudHMuR3Jhdml0eSxcclxuICAgICAgICBDb21wb25lbnRzLk9mZnNldCxcclxuICAgICAgICBDb21wb25lbnRzLlNldEdhbWVPYmplY3QsXHJcbiAgICAgICAgQ29tcG9uZW50cy5WZWxvY2l0eVxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIC8vICB4L3kgaXMgdGhlIGNlbnRlciBvZiB0aGUgU3ByaXRlIC8gQm9keSwganVzdCBsaWtlIG90aGVyIGRlZmF1bHQgR2FtZSBPYmplY3RzXHJcbiAgICBmdW5jdGlvbiBJbXBhY3RTcHJpdGUgKHdvcmxkLCB4LCB5LCB0ZXh0dXJlLCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBTcHJpdGUuY2FsbCh0aGlzLCB3b3JsZC5zY2VuZSwgeCwgeSwgdGV4dHVyZSwgZnJhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmJvZHkgPSB3b3JsZC5jcmVhdGUoeCAtIHRoaXMuZnJhbWUuY2VudGVyWCwgeSAtIHRoaXMuZnJhbWUuY2VudGVyWSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLmJvZHkucGFyZW50ID0gdGhpcztcclxuICAgICAgICB0aGlzLmJvZHkuZ2FtZU9iamVjdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8vICBMb2NhbCByZWZlcmVuY2VzIHRvIHRoZSBCb2R5IHByb3BlcnRpZXNcclxuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmJvZHkuc2l6ZTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMuYm9keS5vZmZzZXQ7XHJcbiAgICAgICAgdGhpcy52ZWwgPSB0aGlzLmJvZHkudmVsO1xyXG4gICAgICAgIHRoaXMuYWNjZWwgPSB0aGlzLmJvZHkuYWNjZWw7XHJcbiAgICAgICAgdGhpcy5mcmljdGlvbiA9IHRoaXMuYm9keS5mcmljdGlvbjtcclxuICAgICAgICB0aGlzLm1heFZlbCA9IHRoaXMuYm9keS5tYXhWZWw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1wYWN0U3ByaXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L0ltcGFjdFNwcml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gODYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgU2VwZXJhdGVYID0gZnVuY3Rpb24gKHdvcmxkLCBsZWZ0LCByaWdodCwgd2Vhaylcclxue1xyXG4gICAgdmFyIG51ZGdlID0gbGVmdC5wb3MueCArIGxlZnQuc2l6ZS54IC0gcmlnaHQucG9zLng7XHJcbiAgICBcclxuICAgIC8vIFdlIGhhdmUgYSB3ZWFrIGVudGl0eSwgc28ganVzdCBtb3ZlIHRoaXMgb25lXHJcbiAgICBpZiAod2VhaylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3Ryb25nID0gKGxlZnQgPT09IHdlYWspID8gcmlnaHQgOiBsZWZ0O1xyXG5cclxuICAgICAgICB3ZWFrLnZlbC54ID0gLXdlYWsudmVsLnggKiB3ZWFrLmJvdW5jaW5lc3MgKyBzdHJvbmcudmVsLng7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc1dlYWsgPSB3b3JsZC5jb2xsaXNpb25NYXAudHJhY2Uod2Vhay5wb3MueCwgd2Vhay5wb3MueSwgd2VhayA9PT0gbGVmdCA/IC1udWRnZSA6IG51ZGdlLCAwLCB3ZWFrLnNpemUueCwgd2Vhay5zaXplLnkpO1xyXG5cclxuICAgICAgICB3ZWFrLnBvcy54ID0gcmVzV2Vhay5wb3MueDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgdjIgPSAobGVmdC52ZWwueCAtIHJpZ2h0LnZlbC54KSAvIDI7XHJcblxyXG4gICAgICAgIGxlZnQudmVsLnggPSAtdjI7XHJcbiAgICAgICAgcmlnaHQudmVsLnggPSB2MjtcclxuICAgIFxyXG4gICAgICAgIHZhciByZXNMZWZ0ID0gd29ybGQuY29sbGlzaW9uTWFwLnRyYWNlKGxlZnQucG9zLngsIGxlZnQucG9zLnksIC1udWRnZSAvIDIsIDAsIGxlZnQuc2l6ZS54LCBsZWZ0LnNpemUueSk7XHJcblxyXG4gICAgICAgIGxlZnQucG9zLnggPSBNYXRoLmZsb29yKHJlc0xlZnQucG9zLngpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXNSaWdodCA9IHdvcmxkLmNvbGxpc2lvbk1hcC50cmFjZShyaWdodC5wb3MueCwgcmlnaHQucG9zLnksIG51ZGdlIC8gMiwgMCwgcmlnaHQuc2l6ZS54LCByaWdodC5zaXplLnkpO1xyXG5cclxuICAgICAgICByaWdodC5wb3MueCA9IE1hdGguY2VpbChyZXNSaWdodC5wb3MueCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNlcGVyYXRlWDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9TZXBlcmF0ZVguanNcbi8vIG1vZHVsZSBpZCA9IDg2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFNlcGVyYXRlWSA9IGZ1bmN0aW9uICh3b3JsZCwgdG9wLCBib3R0b20sIHdlYWspXHJcbntcclxuICAgIHZhciBudWRnZSA9ICh0b3AucG9zLnkgKyB0b3Auc2l6ZS55IC0gYm90dG9tLnBvcy55KTtcclxuICAgIHZhciBudWRnZVg7XHJcbiAgICB2YXIgcmVzVG9wO1xyXG4gICAgXHJcbiAgICBpZiAod2VhaylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3Ryb25nID0gKHRvcCA9PT0gd2VhaykgPyBib3R0b20gOiB0b3A7XHJcblxyXG4gICAgICAgIHdlYWsudmVsLnkgPSAtd2Vhay52ZWwueSAqIHdlYWsuYm91bmNpbmVzcyArIHN0cm9uZy52ZWwueTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSaWRpbmcgb24gYSBwbGF0Zm9ybT9cclxuICAgICAgICBudWRnZVggPSAwO1xyXG5cclxuICAgICAgICBpZiAod2VhayA9PT0gdG9wICYmIE1hdGguYWJzKHdlYWsudmVsLnkgLSBzdHJvbmcudmVsLnkpIDwgd2Vhay5taW5Cb3VuY2VWZWxvY2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHdlYWsuc3RhbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBudWRnZVggPSBzdHJvbmcudmVsLnggKiB3b3JsZC5kZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc1dlYWsgPSB3b3JsZC5jb2xsaXNpb25NYXAudHJhY2Uod2Vhay5wb3MueCwgd2Vhay5wb3MueSwgbnVkZ2VYLCB3ZWFrID09PSB0b3AgPyAtbnVkZ2UgOiBudWRnZSwgd2Vhay5zaXplLngsIHdlYWsuc2l6ZS55KTtcclxuXHJcbiAgICAgICAgd2Vhay5wb3MueSA9IHJlc1dlYWsucG9zLnk7XHJcbiAgICAgICAgd2Vhay5wb3MueCA9IHJlc1dlYWsucG9zLng7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh3b3JsZC5ncmF2aXR5ICYmIChib3R0b20uc3RhbmRpbmcgfHwgdG9wLnZlbC55ID4gMCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmVzVG9wID0gd29ybGQuY29sbGlzaW9uTWFwLnRyYWNlKHRvcC5wb3MueCwgdG9wLnBvcy55LCAwLCAtKHRvcC5wb3MueSArIHRvcC5zaXplLnkgLSBib3R0b20ucG9zLnkpLCB0b3Auc2l6ZS54LCB0b3Auc2l6ZS55KTtcclxuXHJcbiAgICAgICAgdG9wLnBvcy55ID0gcmVzVG9wLnBvcy55O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0b3AuYm91bmNpbmVzcyA+IDAgJiYgdG9wLnZlbC55ID4gdG9wLm1pbkJvdW5jZVZlbG9jaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdG9wLnZlbC55ICo9IC10b3AuYm91bmNpbmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdG9wLnN0YW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdG9wLnZlbC55ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHYyID0gKHRvcC52ZWwueSAtIGJvdHRvbS52ZWwueSkgLyAyO1xyXG5cclxuICAgICAgICB0b3AudmVsLnkgPSAtdjI7XHJcbiAgICAgICAgYm90dG9tLnZlbC55ID0gdjI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbnVkZ2VYID0gYm90dG9tLnZlbC54ICogd29ybGQuZGVsdGE7XHJcblxyXG4gICAgICAgIHJlc1RvcCA9IHdvcmxkLmNvbGxpc2lvbk1hcC50cmFjZSh0b3AucG9zLngsIHRvcC5wb3MueSwgbnVkZ2VYLCAtbnVkZ2UgLyAyLCB0b3Auc2l6ZS54LCB0b3Auc2l6ZS55KTtcclxuXHJcbiAgICAgICAgdG9wLnBvcy55ID0gcmVzVG9wLnBvcy55O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXNCb3R0b20gPSB3b3JsZC5jb2xsaXNpb25NYXAudHJhY2UoYm90dG9tLnBvcy54LCBib3R0b20ucG9zLnksIDAsIG51ZGdlIC8gMiwgYm90dG9tLnNpemUueCwgYm90dG9tLnNpemUueSk7XHJcblxyXG4gICAgICAgIGJvdHRvbS5wb3MueSA9IHJlc0JvdHRvbS5wb3MueTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VwZXJhdGVZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L1NlcGVyYXRlWS5qc1xuLy8gbW9kdWxlIGlkID0gODYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXBlcmF0ZVggPSByZXF1aXJlKCcuL1NlcGVyYXRlWCcpO1xyXG52YXIgU2VwZXJhdGVZID0gcmVxdWlyZSgnLi9TZXBlcmF0ZVknKTtcclxudmFyIENPTExJREVTID0gcmVxdWlyZSgnLi9DT0xMSURFUycpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcclxuXHJcbi8vICBJbXBhY3QgUGh5c2ljcyBTb2x2ZXJcclxuXHJcbnZhciBTb2x2ZXIgPSBmdW5jdGlvbiAod29ybGQsIGJvZHlBLCBib2R5Qilcclxue1xyXG4gICAgdmFyIHdlYWsgPSBudWxsO1xyXG5cclxuICAgIGlmIChib2R5QS5jb2xsaWRlcyA9PT0gQ09MTElERVMuTElURSB8fCBib2R5Qi5jb2xsaWRlcyA9PT0gQ09MTElERVMuRklYRUQpXHJcbiAgICB7XHJcbiAgICAgICAgd2VhayA9IGJvZHlBO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYm9keUIuY29sbGlkZXMgPT09IENPTExJREVTLkxJVEUgfHwgYm9keUEuY29sbGlkZXMgPT09IENPTExJREVTLkZJWEVEKVxyXG4gICAge1xyXG4gICAgICAgIHdlYWsgPSBib2R5QjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYm9keUEubGFzdC54ICsgYm9keUEuc2l6ZS54ID4gYm9keUIubGFzdC54ICYmIGJvZHlBLmxhc3QueCA8IGJvZHlCLmxhc3QueCArIGJvZHlCLnNpemUueClcclxuICAgIHtcclxuICAgICAgICBpZiAoYm9keUEubGFzdC55IDwgYm9keUIubGFzdC55KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2VwZXJhdGVZKHdvcmxkLCBib2R5QSwgYm9keUIsIHdlYWspO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTZXBlcmF0ZVkod29ybGQsIGJvZHlCLCBib2R5QSwgd2Vhayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBib2R5QS5jb2xsaWRlV2l0aChib2R5QiwgJ3knKTtcclxuICAgICAgICBib2R5Qi5jb2xsaWRlV2l0aChib2R5QSwgJ3knKTtcclxuXHJcbiAgICAgICAgd29ybGQuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudHMuQ09MTElERShib2R5QSwgYm9keUIsICd5JykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYm9keUEubGFzdC55ICsgYm9keUEuc2l6ZS55ID4gYm9keUIubGFzdC55ICYmIGJvZHlBLmxhc3QueSA8IGJvZHlCLmxhc3QueSArIGJvZHlCLnNpemUueSlcclxuICAgIHtcclxuICAgICAgICBpZiAoYm9keUEubGFzdC54IDwgYm9keUIubGFzdC54KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2VwZXJhdGVYKHdvcmxkLCBib2R5QSwgYm9keUIsIHdlYWspO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTZXBlcmF0ZVgod29ybGQsIGJvZHlCLCBib2R5QSwgd2Vhayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBib2R5QS5jb2xsaWRlV2l0aChib2R5QiwgJ3gnKTtcclxuICAgICAgICBib2R5Qi5jb2xsaWRlV2l0aChib2R5QSwgJ3gnKTtcclxuXHJcbiAgICAgICAgd29ybGQuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudHMuQ09MTElERShib2R5QSwgYm9keUIsICd4JykpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTb2x2ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvU29sdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gU2V0IHVwIHRoZSB0cmFjZS1yZXN1bHRcclxuLy8gdmFyIHJlcyA9IHtcclxuLy8gICAgIGNvbGxpc2lvbjoge3g6IGZhbHNlLCB5OiBmYWxzZSwgc2xvcGU6IGZhbHNlfSxcclxuLy8gICAgIHBvczoge3g6IHgsIHk6IHl9LFxyXG4vLyAgICAgdGlsZToge3g6IDAsIHk6IDB9XHJcbi8vIH07XHJcblxyXG52YXIgVXBkYXRlTW90aW9uID0gZnVuY3Rpb24gKGJvZHksIHJlcylcclxue1xyXG4gICAgYm9keS5zdGFuZGluZyA9IGZhbHNlO1xyXG5cclxuICAgIC8vICBZXHJcbiAgICBpZiAocmVzLmNvbGxpc2lvbi55KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChib2R5LmJvdW5jaW5lc3MgPiAwICYmIE1hdGguYWJzKGJvZHkudmVsLnkpID4gYm9keS5taW5Cb3VuY2VWZWxvY2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJvZHkudmVsLnkgKj0gLWJvZHkuYm91bmNpbmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGJvZHkudmVsLnkgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib2R5LnN0YW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYm9keS52ZWwueSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBYXHJcbiAgICBpZiAocmVzLmNvbGxpc2lvbi54KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChib2R5LmJvdW5jaW5lc3MgPiAwICYmIE1hdGguYWJzKGJvZHkudmVsLngpID4gYm9keS5taW5Cb3VuY2VWZWxvY2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJvZHkudmVsLnggKj0gLWJvZHkuYm91bmNpbmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYm9keS52ZWwueCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBTTE9QRVxyXG4gICAgaWYgKHJlcy5jb2xsaXNpb24uc2xvcGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHMgPSByZXMuY29sbGlzaW9uLnNsb3BlO1xyXG4gICAgICAgXHJcbiAgICAgICAgaWYgKGJvZHkuYm91bmNpbmVzcyA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcHJvaiA9IGJvZHkudmVsLnggKiBzLm54ICsgYm9keS52ZWwueSAqIHMubnk7XHJcblxyXG4gICAgICAgICAgICBib2R5LnZlbC54ID0gKGJvZHkudmVsLnggLSBzLm54ICogcHJvaiAqIDIpICogYm9keS5ib3VuY2luZXNzO1xyXG4gICAgICAgICAgICBib2R5LnZlbC55ID0gKGJvZHkudmVsLnkgLSBzLm55ICogcHJvaiAqIDIpICogYm9keS5ib3VuY2luZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoU3F1YXJlZCA9IHMueCAqIHMueCArIHMueSAqIHMueTtcclxuICAgICAgICAgICAgdmFyIGRvdCA9IChib2R5LnZlbC54ICogcy54ICsgYm9keS52ZWwueSAqIHMueSkgLyBsZW5ndGhTcXVhcmVkO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYm9keS52ZWwueCA9IHMueCAqIGRvdDtcclxuICAgICAgICAgICAgYm9keS52ZWwueSA9IHMueSAqIGRvdDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIocy54LCBzLnkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFuZ2xlID4gYm9keS5zbG9wZVN0YW5kaW5nLm1pbiAmJiBhbmdsZSA8IGJvZHkuc2xvcGVTdGFuZGluZy5tYXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJvZHkuc3RhbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGJvZHkucG9zLnggPSByZXMucG9zLng7XHJcbiAgICBib2R5LnBvcy55ID0gcmVzLnBvcy55O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVcGRhdGVNb3Rpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvVXBkYXRlTW90aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA4NjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5QaHlzaWNzLkltcGFjdC5Xb3JsZFxyXG5cclxudmFyIEJvZHkgPSByZXF1aXJlKCcuL0JvZHknKTtcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENPTExJREVTID0gcmVxdWlyZSgnLi9DT0xMSURFUycpO1xyXG52YXIgQ29sbGlzaW9uTWFwID0gcmVxdWlyZSgnLi9Db2xsaXNpb25NYXAnKTtcclxudmFyIEdldEZhc3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRGYXN0VmFsdWUnKTtcclxudmFyIFNldCA9IHJlcXVpcmUoJy4uLy4uL3N0cnVjdHMvU2V0Jyk7XHJcbnZhciBTb2x2ZXIgPSByZXF1aXJlKCcuL1NvbHZlcicpO1xyXG52YXIgVFlQRSA9IHJlcXVpcmUoJy4vVFlQRScpO1xyXG5cclxudmFyIFdvcmxkID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFdvcmxkIChzY2VuZSwgY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBzY2VuZS5zeXMuZXZlbnRzO1xyXG5cclxuICAgICAgICB0aGlzLmJvZGllcyA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5ncmF2aXR5ID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ2dyYXZpdHknLCAwKTtcclxuXHJcbiAgICAgICAgLy8gIFNwYXRpYWwgaGFzaCBjZWxsIGRpbWVuc2lvbnNcclxuICAgICAgICB0aGlzLmNlbGxTaXplID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ2NlbGxTaXplJywgNjQpO1xyXG5cclxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcCA9IG5ldyBDb2xsaXNpb25NYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy50aW1lU2NhbGUgPSBHZXRGYXN0VmFsdWUoY29uZmlnLCAndGltZVNjYWxlJywgMSk7XHJcblxyXG4gICAgICAgIC8vICBJbXBhY3RzIG1heGltdW0gdGltZSBzdGVwIGlzIDIwIGZwcy5cclxuICAgICAgICB0aGlzLm1heFN0ZXAgPSBHZXRGYXN0VmFsdWUoY29uZmlnLCAnbWF4U3RlcCcsIDAuMDUpO1xyXG5cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmRyYXdEZWJ1ZyA9IEdldEZhc3RWYWx1ZShjb25maWcsICdkZWJ1ZycsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgdGhpcy5kZWJ1Z0dyYXBoaWM7XHJcblxyXG4gICAgICAgIHZhciBfbWF4VmVsb2NpdHkgPSBHZXRGYXN0VmFsdWUoY29uZmlnLCAnbWF4VmVsb2NpdHknLCAxMDApO1xyXG5cclxuICAgICAgICB0aGlzLmRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICBkZWJ1Z1Nob3dCb2R5OiBHZXRGYXN0VmFsdWUoY29uZmlnLCAnZGVidWdTaG93Qm9keScsIHRydWUpLFxyXG4gICAgICAgICAgICBkZWJ1Z1Nob3dWZWxvY2l0eTogR2V0RmFzdFZhbHVlKGNvbmZpZywgJ2RlYnVnU2hvd1ZlbG9jaXR5JywgdHJ1ZSksXHJcbiAgICAgICAgICAgIGJvZHlEZWJ1Z0NvbG9yOiBHZXRGYXN0VmFsdWUoY29uZmlnLCAnZGVidWdCb2R5Q29sb3InLCAweGZmMDBmZiksXHJcbiAgICAgICAgICAgIHZlbG9jaXR5RGVidWdDb2xvcjogR2V0RmFzdFZhbHVlKGNvbmZpZywgJ2RlYnVnVmVsb2NpdHlDb2xvcicsIDB4MDBmZjAwKSxcclxuICAgICAgICAgICAgbWF4VmVsb2NpdHlYOiBHZXRGYXN0VmFsdWUoY29uZmlnLCAnbWF4VmVsb2NpdHlYJywgX21heFZlbG9jaXR5KSxcclxuICAgICAgICAgICAgbWF4VmVsb2NpdHlZOiBHZXRGYXN0VmFsdWUoY29uZmlnLCAnbWF4VmVsb2NpdHlZJywgX21heFZlbG9jaXR5KSxcclxuICAgICAgICAgICAgbWluQm91bmNlVmVsb2NpdHk6IEdldEZhc3RWYWx1ZShjb25maWcsICdtaW5Cb3VuY2VWZWxvY2l0eScsIDQwKSxcclxuICAgICAgICAgICAgZ3Jhdml0eUZhY3RvcjogR2V0RmFzdFZhbHVlKGNvbmZpZywgJ2dyYXZpdHlGYWN0b3InLCAxKSxcclxuICAgICAgICAgICAgYm91bmNpbmVzczogR2V0RmFzdFZhbHVlKGNvbmZpZywgJ2JvdW5jaW5lc3MnLCAwKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IHdhbGxzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIDQgd2FsbCBib2RpZXMgdGhhdCBib3VuZCB0aGUgcGh5c2ljcyB3b3JsZC5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud2FsbHMgPSB7IGxlZnQ6IG51bGwsIHJpZ2h0OiBudWxsLCB0b3A6IG51bGwsIGJvdHRvbTogbnVsbCB9O1xyXG4gICAgXHJcbiAgICAgICAgdGhpcy5kZWx0YSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuX2xhc3RJZCA9IDA7XHJcblxyXG4gICAgICAgIGlmIChHZXRGYXN0VmFsdWUoY29uZmlnLCAnc2V0Qm91bmRzJywgZmFsc2UpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGJvdW5kc0NvbmZpZyA9IGNvbmZpZ1snc2V0Qm91bmRzJ107XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJvdW5kc0NvbmZpZyA9PT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBHZXRGYXN0VmFsdWUoYm91bmRzQ29uZmlnLCAneCcsIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBHZXRGYXN0VmFsdWUoYm91bmRzQ29uZmlnLCAneScsIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gR2V0RmFzdFZhbHVlKGJvdW5kc0NvbmZpZywgJ3dpZHRoJywgc2NlbmUuc3lzLmdhbWUuY29uZmlnLndpZHRoKTtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBHZXRGYXN0VmFsdWUoYm91bmRzQ29uZmlnLCAnaGVpZ2h0Jywgc2NlbmUuc3lzLmdhbWUuY29uZmlnLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhpY2tuZXNzID0gR2V0RmFzdFZhbHVlKGJvdW5kc0NvbmZpZywgJ3RoaWNrbmVzcycsIDY0KTtcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gR2V0RmFzdFZhbHVlKGJvdW5kc0NvbmZpZywgJ2xlZnQnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IEdldEZhc3RWYWx1ZShib3VuZHNDb25maWcsICdyaWdodCcsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IEdldEZhc3RWYWx1ZShib3VuZHNDb25maWcsICd0b3AnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBHZXRGYXN0VmFsdWUoYm91bmRzQ29uZmlnLCAnYm90dG9tJywgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRCb3VuZHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpY2tuZXNzLCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5kcmF3RGVidWcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURlYnVnR3JhcGhpYygpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q29sbGlzaW9uTWFwOiBmdW5jdGlvbiAodGlsZXNpemUsIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXAgPSBuZXcgQ29sbGlzaW9uTWFwKHRpbGVzaXplLCBkYXRhKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlzaW9uTWFwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0cyB0aGUgYm91bmRzIG9mIHRoZSBQaHlzaWNzIHdvcmxkIHRvIG1hdGNoIHRoZSBnaXZlbiB3b3JsZCBwaXhlbCBkaW1lbnNpb25zLlxyXG4gICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgc2V0IHdoaWNoICd3YWxscycgdG8gY3JlYXRlOiBsZWZ0LCByaWdodCwgdG9wIG9yIGJvdHRvbS5cclxuICAgICogSWYgbm9uZSBvZiB0aGUgd2FsbHMgYXJlIGdpdmVuIGl0IHdpbGwgZGVmYXVsdCB0byB1c2UgdGhlIHdhbGxzIHNldHRpbmdzIGl0IGhhZCBwcmV2aW91c2x5LlxyXG4gICAgKiBJLmUuIGlmIHlvdSBwcmV2aW91c2x5IHRvbGQgaXQgdG8gbm90IGhhdmUgdGhlIGxlZnQgb3IgcmlnaHQgd2FsbHMsIGFuZCB5b3UgdGhlbiBhZGp1c3QgdGhlIHdvcmxkIHNpemVcclxuICAgICogdGhlIG5ld2x5IGNyZWF0ZWQgYm91bmRzIHdpbGwgYWxzbyBub3QgaGF2ZSB0aGUgbGVmdCBhbmQgcmlnaHQgd2FsbHMuXHJcbiAgICAqIEV4cGxpY2l0bHkgc3RhdGUgdGhlbSBpbiB0aGUgcGFyYW1ldGVycyB0byBvdmVycmlkZSB0aGlzLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5QaHlzaWNzLlAyI3NldEJvdW5kc1xyXG4gICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgYm91bmRzLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgYm91bmRzLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGJvdW5kcy5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kcy5cclxuICAgICogQHBhcmFtIHtib29sZWFufSBbbGVmdD10cnVlXSAtIElmIHRydWUgd2lsbCBjcmVhdGUgdGhlIGxlZnQgYm91bmRzIHdhbGwuXHJcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JpZ2h0PXRydWVdIC0gSWYgdHJ1ZSB3aWxsIGNyZWF0ZSB0aGUgcmlnaHQgYm91bmRzIHdhbGwuXHJcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RvcD10cnVlXSAtIElmIHRydWUgd2lsbCBjcmVhdGUgdGhlIHRvcCBib3VuZHMgd2FsbC5cclxuICAgICogQHBhcmFtIHtib29sZWFufSBbYm90dG9tPXRydWVdIC0gSWYgdHJ1ZSB3aWxsIGNyZWF0ZSB0aGUgYm90dG9tIGJvdW5kcyB3YWxsLlxyXG4gICAgKi9cclxuICAgIHNldEJvdW5kczogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaWNrbmVzcywgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSAwOyB9XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSB0aGlzLnNjZW5lLnN5cy5nYW1lLmNvbmZpZy53aWR0aDsgfVxyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSB0aGlzLnNjZW5lLnN5cy5nYW1lLmNvbmZpZy5oZWlnaHQ7IH1cclxuICAgICAgICBpZiAodGhpY2tuZXNzID09PSB1bmRlZmluZWQpIHsgdGhpY2tuZXNzID0gNjQ7IH1cclxuICAgICAgICBpZiAobGVmdCA9PT0gdW5kZWZpbmVkKSB7IGxlZnQgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKHJpZ2h0ID09PSB1bmRlZmluZWQpIHsgcmlnaHQgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKHRvcCA9PT0gdW5kZWZpbmVkKSB7IHRvcCA9IHRydWU7IH1cclxuICAgICAgICBpZiAoYm90dG9tID09PSB1bmRlZmluZWQpIHsgYm90dG9tID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVdhbGwobGVmdCwgJ2xlZnQnLCB4IC0gdGhpY2tuZXNzLCB5LCB0aGlja25lc3MsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVXYWxsKHJpZ2h0LCAncmlnaHQnLCB4ICsgd2lkdGgsIHksIHRoaWNrbmVzcywgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVdhbGwodG9wLCAndG9wJywgeCwgeSAtIHRoaWNrbmVzcywgd2lkdGgsIHRoaWNrbmVzcyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVXYWxsKGJvdHRvbSwgJ2JvdHRvbScsIHgsIHkgKyBoZWlnaHQsIHdpZHRoLCB0aGlja25lc3MpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIHBvc2l0aW9uID0gJ2xlZnQnLCAncmlnaHQnLCAndG9wJyBvciAnYm90dG9tJ1xyXG4gICAgdXBkYXRlV2FsbDogZnVuY3Rpb24gKGFkZCwgcG9zaXRpb24sIHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHdhbGwgPSB0aGlzLndhbGxzW3Bvc2l0aW9uXTtcclxuXHJcbiAgICAgICAgaWYgKGFkZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh3YWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB3YWxsLnJlc2V0U2l6ZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FsbHNbcG9zaXRpb25dID0gdGhpcy5jcmVhdGUoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhbGxzW3Bvc2l0aW9uXS5uYW1lID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhbGxzW3Bvc2l0aW9uXS5ncmF2aXR5RmFjdG9yID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FsbHNbcG9zaXRpb25dLmNvbGxpZGVzID0gQ09MTElERVMuRklYRUQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHdhbGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9kaWVzLnJlbW92ZSh3YWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy53YWxsc1twb3NpdGlvbl0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlRGVidWdHcmFwaGljOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBncmFwaGljID0gdGhpcy5zY2VuZS5zeXMuYWRkLmdyYXBoaWNzKHsgeDogMCwgeTogMCB9KTtcclxuXHJcbiAgICAgICAgZ3JhcGhpYy5zZXRaKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcclxuXHJcbiAgICAgICAgdGhpcy5kZWJ1Z0dyYXBoaWMgPSBncmFwaGljO1xyXG5cclxuICAgICAgICB0aGlzLmRyYXdEZWJ1ZyA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiBncmFwaGljO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXROZXh0SUQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RJZCsrO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uICh4LCB5LCBzaXplWCwgc2l6ZVkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh0aGlzLCB4LCB5LCBzaXplWCwgc2l6ZVkpO1xyXG5cclxuICAgICAgICB0aGlzLmJvZGllcy5zZXQoYm9keSk7XHJcblxyXG4gICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgfSxcclxuXHJcbiAgICBwYXVzZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc3VtZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAodGltZSwgZGVsdGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgdGhpcy5ib2RpZXMuc2l6ZSA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBJbXBhY3QgdXNlcyBhIGRpdmlkZWQgZGVsdGEgdmFsdWUgdGhhdCBpcyBjbGFtcGVkIHRvIHRoZSBtYXhTdGVwICgyMGZwcykgbWF4aW11bVxyXG4gICAgICAgIHRoaXMuZGVsdGEgPSBNYXRoLm1pbihkZWx0YSAvIDEwMDAsIHRoaXMubWF4U3RlcCkgKiB0aGlzLnRpbWVTY2FsZTtcclxuXHJcbiAgICAgICAgLy8gIFVwZGF0ZSBhbGwgYWN0aXZlIGJvZGllc1xyXG5cclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgYm9keTtcclxuICAgICAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXMuZW50cmllcztcclxuICAgICAgICB2YXIgbGVuID0gYm9kaWVzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaGFzaCA9IHt9O1xyXG4gICAgICAgIHZhciBzaXplID0gdGhpcy5jZWxsU2l6ZTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChib2R5LmVuYWJsZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJvZHkudXBkYXRlKHRoaXMuZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgUnVuIGNvbGxpc2lvbiBhZ2FpbnN0IHRoZW0gYWxsIG5vdyB0aGV5J3JlIGluIHRoZSBuZXcgcG9zaXRpb25zIGZyb20gdGhlIHVwZGF0ZVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFib2R5LnNraXBIYXNoKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tIYXNoKGJvZHksIGhhc2gsIHNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5kcmF3RGVidWcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSB0aGlzLmRlYnVnR3JhcGhpYztcclxuXHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHkud2lsbERyYXdEZWJ1ZygpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuZHJhd0RlYnVnKGdyYXBoaWNzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENoZWNrIHRoZSBib2R5IGFnYWluc3QgdGhlIHNwYXRpYWwgaGFzaFxyXG4gICAgY2hlY2tIYXNoOiBmdW5jdGlvbiAoYm9keSwgaGFzaCwgc2l6ZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgY2hlY2tlZCA9IHt9O1xyXG5cclxuICAgICAgICB2YXIgeG1pbiA9IE1hdGguZmxvb3IoYm9keS5wb3MueCAvIHNpemUpO1xyXG4gICAgICAgIHZhciB5bWluID0gTWF0aC5mbG9vcihib2R5LnBvcy55IC8gc2l6ZSk7XHJcbiAgICAgICAgdmFyIHhtYXggPSBNYXRoLmZsb29yKChib2R5LnBvcy54ICsgYm9keS5zaXplLngpIC8gc2l6ZSkgKyAxO1xyXG4gICAgICAgIHZhciB5bWF4ID0gTWF0aC5mbG9vcigoYm9keS5wb3MueSArIGJvZHkuc2l6ZS55KSAvIHNpemUpICsgMTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeCA9IHhtaW47IHggPCB4bWF4OyB4KyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0geW1pbjsgeSA8IHltYXg7IHkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNoW3hdKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hbeF0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoW3hdW3ldID0gWyBib2R5IF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaGFzaFt4XVt5XSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoW3hdW3ldID0gWyBib2R5IF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBoYXNoW3hdW3ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNlbGwubGVuZ3RoOyBjKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS50b3VjaGVzKGNlbGxbY10pICYmICFjaGVja2VkW2NlbGxbY10uaWRdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkW2NlbGxbY10uaWRdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQm9kaWVzKGJvZHksIGNlbGxbY10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjZWxsLnB1c2goYm9keSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNoZWNrQm9kaWVzOiBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKVxyXG4gICAge1xyXG4gICAgICAgIC8vICAyIGZpeGVkIGJvZGllcyB3b24ndCBkbyBhbnl0aGluZ1xyXG4gICAgICAgIGlmIChib2R5QS5jb2xsaWRlcyA9PT0gQ09MTElERVMuRklYRUQgJiYgYm9keUIuY29sbGlkZXMgPT09IENPTExJREVTLkZJWEVEKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIGJpdHdpc2UgY2hlY2tzXHJcbiAgICAgICAgaWYgKGJvZHlBLmNoZWNrQWdhaW5zdCAmIGJvZHlCLnR5cGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2R5QS5jaGVjayhib2R5Qik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChib2R5Qi5jaGVja0FnYWluc3QgJiBib2R5QS50eXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYm9keUIuY2hlY2soYm9keUEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoYm9keUEuY29sbGlkZXMgJiYgYm9keUIuY29sbGlkZXMgJiYgYm9keUEuY29sbGlkZXMgKyBib2R5Qi5jb2xsaWRlcyA+IENPTExJREVTLkFDVElWRSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNvbHZlcih0aGlzLCBib2R5QSwgYm9keUIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vICBIZWxwZXJzIC8vXHJcbiAgICAvLy8vLy8vLy8vLy8vL1xyXG5cclxuICAgIHNldENvbGxpZGVzTmV2ZXI6IGZ1bmN0aW9uIChib2RpZXMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2RpZXNbaV0uY29sbGlkZXMgPSBDT0xMSURFUy5ORVZFUjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRMaXRlOiBmdW5jdGlvbiAoYm9kaWVzKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYm9kaWVzW2ldLmNvbGxpZGVzID0gQ09MTElERVMuTElURTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQYXNzaXZlOiBmdW5jdGlvbiAoYm9kaWVzKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYm9kaWVzW2ldLmNvbGxpZGVzID0gQ09MTElERVMuUEFTU0lWRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBY3RpdmU6IGZ1bmN0aW9uIChib2RpZXMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2RpZXNbaV0uY29sbGlkZXMgPSBDT0xMSURFUy5BQ1RJVkU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Rml4ZWQ6IGZ1bmN0aW9uIChib2RpZXMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2RpZXNbaV0uY29sbGlkZXMgPSBDT0xMSURFUy5GSVhFRDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUeXBlTm9uZTogZnVuY3Rpb24gKGJvZGllcylcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJvZGllc1tpXS50eXBlID0gVFlQRS5OT05FO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFR5cGVBOiBmdW5jdGlvbiAoYm9kaWVzKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYm9kaWVzW2ldLnR5cGUgPSBUWVBFLkE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VHlwZUI6IGZ1bmN0aW9uIChib2RpZXMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2RpZXNbaV0udHlwZSA9IFRZUEUuQjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBdnNCOiBmdW5jdGlvbiAoYm9kaWVzKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYm9kaWVzW2ldLnR5cGUgPSBUWVBFLkE7XHJcbiAgICAgICAgICAgIGJvZGllc1tpXS5jaGVja0FnYWluc3QgPSBUWVBFLkI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0QnZzQTogZnVuY3Rpb24gKGJvZGllcylcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJvZGllc1tpXS50eXBlID0gVFlQRS5CO1xyXG4gICAgICAgICAgICBib2RpZXNbaV0uY2hlY2tBZ2FpbnN0ID0gVFlQRS5BO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENoZWNrQWdhaW5zdE5vbmU6IGZ1bmN0aW9uIChib2RpZXMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2RpZXNbaV0uY2hlY2tBZ2FpbnN0ID0gVFlQRS5OT05FO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENoZWNrQWdhaW5zdEE6IGZ1bmN0aW9uIChib2RpZXMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2RpZXNbaV0uY2hlY2tBZ2FpbnN0ID0gVFlQRS5BO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENoZWNrQWdhaW5zdEI6IGZ1bmN0aW9uIChib2RpZXMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2RpZXNbaV0uY2hlY2tBZ2FpbnN0ID0gVFlQRS5CO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5ib2RpZXMuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5ib2RpZXMgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV29ybGQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvV29ybGQuanNcbi8vIG1vZHVsZSBpZCA9IDg2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQWNjZWxlcmF0aW9uID0ge1xyXG5cclxuICAgIHNldEFjY2VsZXJhdGlvblg6IGZ1bmN0aW9uICh4KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWNjZWwueCA9IHg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBY2NlbGVyYXRpb25ZOiBmdW5jdGlvbiAoeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFjY2VsLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0QWNjZWxlcmF0aW9uOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFjY2VsLnggPSB4O1xyXG4gICAgICAgIHRoaXMuYWNjZWwueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWNjZWxlcmF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvQWNjZWxlcmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA4NjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJvZHlTY2FsZSA9IHtcclxuXHJcbiAgICBzZXRCb2R5U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IHdpZHRoOyB9XHJcblxyXG4gICAgICAgIHRoaXMuYm9keS5zaXplLnggPSBNYXRoLnJvdW5kKHdpZHRoKTtcclxuICAgICAgICB0aGlzLmJvZHkuc2l6ZS55ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Qm9keVNjYWxlOiBmdW5jdGlvbiAoc2NhbGVYLCBzY2FsZVkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNjYWxlWSA9PT0gdW5kZWZpbmVkKSB7IHNjYWxlWSA9IHNjYWxlWDsgfVxyXG5cclxuICAgICAgICB2YXIgZ2FtZU9iamVjdCA9IHRoaXMuYm9keS5nYW1lT2JqZWN0O1xyXG5cclxuICAgICAgICBpZiAoZ2FtZU9iamVjdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3Quc2V0U2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Qm9keVNpemUoZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Quc2NhbGVYLCBnYW1lT2JqZWN0LmhlaWdodCAqIGdhbWVPYmplY3Quc2NhbGVZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Qm9keVNpemUodGhpcy5ib2R5LnNpemUueCAqIHNjYWxlWCwgdGhpcy5ib2R5LnNpemUueSAqIHNjYWxlWSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm9keVNjYWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvQm9keVNjYWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4Njdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRZUEUgPSByZXF1aXJlKCcuLi9UWVBFJyk7XHJcblxyXG52YXIgQm9keVR5cGUgPSB7XHJcblxyXG4gICAgZ2V0Qm9keVR5cGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS50eXBlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUeXBlTm9uZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJvZHkudHlwZSA9IFRZUEUuTk9ORTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFR5cGVBOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYm9keS50eXBlID0gVFlQRS5BO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VHlwZUI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib2R5LnR5cGUgPSBUWVBFLkI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm9keVR5cGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvY29tcG9uZW50cy9Cb2R5VHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gODY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCb3VuY2UgPSB7XHJcblxyXG4gICAgc2V0Qm91bmNlOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib2R5LmJvdW5jaW5lc3MgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldE1pbkJvdW5jZVZlbG9jaXR5OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib2R5Lm1pbkJvdW5jZVZlbG9jaXR5ID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBib3VuY2U6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ib3VuY2luZXNzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ib2R5LmJvdW5jaW5lc3MgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm91bmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvQm91bmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA4Njlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRZUEUgPSByZXF1aXJlKCcuLi9UWVBFJyk7XHJcblxyXG52YXIgQ2hlY2tBZ2FpbnN0ID0ge1xyXG5cclxuICAgIHNldEF2c0I6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zZXRUeXBlQSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRDaGVja0FnYWluc3RCKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEJ2c0E6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zZXRUeXBlQigpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRDaGVja0FnYWluc3RBKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENoZWNrQWdhaW5zdE5vbmU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib2R5LmNoZWNrQWdhaW5zdCA9IFRZUEUuTk9ORTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENoZWNrQWdhaW5zdEE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib2R5LmNoZWNrQWdhaW5zdCA9IFRZUEUuQTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENoZWNrQWdhaW5zdEI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib2R5LmNoZWNrQWdhaW5zdCA9IFRZUEUuQjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNoZWNrQWdhaW5zdDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LmNoZWNrQWdhaW5zdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keS5jaGVja0FnYWluc3QgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2hlY2tBZ2FpbnN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvQ2hlY2tBZ2FpbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA4NzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTExJREVTID0gcmVxdWlyZSgnLi4vQ09MTElERVMnKTtcclxuXHJcbnZhciBDb2xsaWRlcyA9IHtcclxuXHJcbiAgICBfY29sbGlkZUNhbGxiYWNrOiBudWxsLFxyXG4gICAgX2NhbGxiYWNrU2NvcGU6IG51bGwsXHJcblxyXG4gICAgc2V0Q29sbGlkZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX2NvbGxpZGVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuICAgICAgICBpZiAoc2NvcGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja1Njb3BlID0gc2NvcGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q29sbGlkZXNOZXZlcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJvZHkuY29sbGlkZXMgPSBDT0xMSURFUy5ORVZFUjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldExpdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib2R5LmNvbGxpZGVzID0gQ09MTElERVMuTElURTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBhc3NpdmU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib2R5LmNvbGxpZGVzID0gQ09MTElERVMuUEFTU0lWRTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEFjdGl2ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJvZHkuY29sbGlkZXMgPSBDT0xMSURFUy5BQ1RJVkU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGaXhlZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJvZHkuY29sbGlkZXMgPSBDT0xMSURFUy5GSVhFRDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbGxpZGVzOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuY29sbGlkZXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkuY29sbGlkZXMgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29sbGlkZXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvY29tcG9uZW50cy9Db2xsaWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gODcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEZWJ1ZyA9IHtcclxuXHJcbiAgICBzZXREZWJ1ZzogZnVuY3Rpb24gKHNob3dCb2R5LCBzaG93VmVsb2NpdHksIGJvZHlDb2xvcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRlYnVnU2hvd0JvZHkgPSBzaG93Qm9keTtcclxuICAgICAgICB0aGlzLmRlYnVnU2hvd1ZlbG9jaXR5ID0gc2hvd1ZlbG9jaXR5O1xyXG4gICAgICAgIHRoaXMuZGVidWdCb2R5Q29sb3IgPSBib2R5Q29sb3I7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXREZWJ1Z0JvZHlDb2xvcjogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYm9keS5kZWJ1Z0JvZHlDb2xvciA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGVidWdTaG93Qm9keToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LmRlYnVnU2hvd0JvZHk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkuZGVidWdTaG93Qm9keSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRlYnVnU2hvd1ZlbG9jaXR5OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuZGVidWdTaG93VmVsb2NpdHk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkuZGVidWdTaG93VmVsb2NpdHkgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkZWJ1Z0JvZHlDb2xvcjoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LmRlYnVnQm9keUNvbG9yO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ib2R5LmRlYnVnQm9keUNvbG9yID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlYnVnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvRGVidWcuanNcbi8vIG1vZHVsZSBpZCA9IDg3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRnJpY3Rpb24gPSB7XHJcblxyXG4gICAgc2V0RnJpY3Rpb25YOiBmdW5jdGlvbiAoeClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZyaWN0aW9uLnggPSB4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJpY3Rpb25ZOiBmdW5jdGlvbiAoeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZyaWN0aW9uLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnJpY3Rpb246IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb24ueCA9IHg7XHJcbiAgICAgICAgdGhpcy5mcmljdGlvbi55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGcmljdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9jb21wb25lbnRzL0ZyaWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA4NzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdyYXZpdHkgPSB7XHJcblxyXG4gICAgc2V0R3Jhdml0eTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYm9keS5ncmF2aXR5RmFjdG9yID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBncmF2aXR5OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuZ3Jhdml0eUZhY3RvcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keS5ncmF2aXR5RmFjdG9yID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXZpdHk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvY29tcG9uZW50cy9HcmF2aXR5LmpzXG4vLyBtb2R1bGUgaWQgPSA4NzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldCA9IHtcclxuXHJcbiAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYm9keS5vZmZzZXQueCA9IHg7XHJcbiAgICAgICAgdGhpcy5ib2R5Lm9mZnNldC55ID0geTtcclxuXHJcbiAgICAgICAgaWYgKHdpZHRoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRCb2R5U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvT2Zmc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA4NzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldEdhbWVPYmplY3QgPSB7XHJcblxyXG4gICAgc2V0R2FtZU9iamVjdDogZnVuY3Rpb24gKGdhbWVPYmplY3QsIHN5bmMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHN5bmMgPT09IHVuZGVmaW5lZCkgeyBzeW5jID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgICBpZiAoZ2FtZU9iamVjdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keS5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzeW5jKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNHYW1lT2JqZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ib2R5LmdhbWVPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHN5bmNHYW1lT2JqZWN0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnYW1lT2JqZWN0ID0gdGhpcy5ib2R5LmdhbWVPYmplY3Q7XHJcblxyXG4gICAgICAgIGlmIChnYW1lT2JqZWN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRCb2R5U2l6ZShnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5zY2FsZVgsIGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5zY2FsZVkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRHYW1lT2JqZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvU2V0R2FtZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gODc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBWZWxvY2l0eSA9IHtcclxuXHJcbiAgICBzZXRWZWxvY2l0eVg6IGZ1bmN0aW9uICh4KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudmVsLnggPSB4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VmVsb2NpdHlZOiBmdW5jdGlvbiAoeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnZlbC55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFZlbG9jaXR5OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnZlbC54ID0geDtcclxuICAgICAgICB0aGlzLnZlbC55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldE1heFZlbG9jaXR5OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMubWF4VmVsLnggPSB4O1xyXG4gICAgICAgIHRoaXMubWF4VmVsLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlbG9jaXR5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2NvbXBvbmVudHMvVmVsb2NpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDg3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBDb2xsaWRlRXZlbnQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEV2ZW50LFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQ29sbGlkZUV2ZW50IChib2R5QSwgYm9keUIsIGF4aXMpXHJcbiAgICB7XHJcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCAnQ09MTElERV9FVkVOVCcpO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGZpcnN0IGJvZHkgaW52b2x2ZWQgaW4gdGhlIGNvbGxpc2lvbl1cclxuICAgICAgICB0aGlzLmJvZHlBID0gYm9keUE7XHJcblxyXG4gICAgICAgIC8vICBUaGUgc2Vjb25kIGJvZHkgaW52b2x2ZWQgaW4gdGhlIGNvbGxpc2lvbl1cclxuICAgICAgICB0aGlzLmJvZHlCID0gYm9keUI7XHJcblxyXG4gICAgICAgIC8vICBUaGUgR2FtZSBPYmplY3QgYXNzb2NpYXRlZCB3aXRoIGJvZHlBIChpZiBhbnkpXHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0QSA9IGJvZHlBLmdhbWVPYmplY3Q7XHJcblxyXG4gICAgICAgIC8vICBUaGUgR2FtZSBPYmplY3QgYXNzb2NpYXRlZCB3aXRoIGJvZHlCIChpZiBhbnkpXHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0QiA9IGJvZHlCLmdhbWVPYmplY3Q7XHJcblxyXG4gICAgICAgIC8vICBFaXRoZXIgJ3gnIG9yICd5J1xyXG4gICAgICAgIHRoaXMuYXhpcyA9IGF4aXM7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29sbGlkZUV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2V2ZW50cy9Db2xsaWRlRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDg3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlBoeXNpY3MuSW1wYWN0LkV2ZW50c1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ09MTElERTogcmVxdWlyZSgnLi9Db2xsaWRlRXZlbnQnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9ldmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBBIHBvbHlmaWxsIGZvciBBcnJheS5mb3JFYWNoXHJcbiogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaFxyXG4qL1xyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKVxyXG57XHJcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNBcmcgKi8pXHJcbiAgICB7XHJcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcclxuICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZnVuICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiB0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wb2x5ZmlsbHMvQXJyYXkuZm9yRWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gODgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEEgcG9seWZpbGwgZm9yIEFycmF5LmlzQXJyYXlcclxuKi9cclxuaWYgKCFBcnJheS5pc0FycmF5KVxyXG57XHJcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKGFyZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcG9seWZpbGxzL0FycmF5LmlzQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDg4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBDb3B5cmlnaHQgMjAxMyBDaHJpcyBXaWxzb25cclxuXHJcbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXHJcblxyXG4vKlxyXG5cclxuVGhpcyBtb25rZXlwYXRjaCBsaWJyYXJ5IGlzIGludGVuZGVkIHRvIGJlIGluY2x1ZGVkIGluIHByb2plY3RzIHRoYXQgYXJlXHJcbndyaXR0ZW4gdG8gdGhlIHByb3BlciBBdWRpb0NvbnRleHQgc3BlYyAoaW5zdGVhZCBvZiB3ZWJraXRBdWRpb0NvbnRleHQpLFxyXG5hbmQgdGhhdCB1c2UgdGhlIG5ldyBuYW1pbmcgYW5kIHByb3BlciBiaXRzIG9mIHRoZSBXZWIgQXVkaW8gQVBJIChlLmcuXHJcbnVzaW5nIEJ1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKSBpbnN0ZWFkIG9mIEJ1ZmZlclNvdXJjZU5vZGUubm90ZU9uKCkpLCBidXQgbWF5XHJcbmhhdmUgdG8gcnVuIG9uIHN5c3RlbXMgdGhhdCBvbmx5IHN1cHBvcnQgdGhlIGRlcHJlY2F0ZWQgYml0cy5cclxuXHJcblRoaXMgbGlicmFyeSBzaG91bGQgYmUgaGFybWxlc3MgdG8gaW5jbHVkZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0c1xyXG51bnByZWZpeGVkIFwiQXVkaW9Db250ZXh0XCIsIGFuZC9vciBpZiBpdCBzdXBwb3J0cyB0aGUgbmV3IG5hbWVzLlxyXG5cclxuVGhlIHBhdGNoZXMgdGhpcyBsaWJyYXJ5IGhhbmRsZXM6XHJcbmlmIHdpbmRvdy5BdWRpb0NvbnRleHQgaXMgdW5zdXBwb3J0ZWQsIGl0IHdpbGwgYmUgYWxpYXNlZCB0byB3ZWJraXRBdWRpb0NvbnRleHQoKS5cclxuaWYgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0YXJ0KCkgaXMgdW5pbXBsZW1lbnRlZCwgaXQgd2lsbCBiZSByb3V0ZWQgdG8gbm90ZU9uKCkgb3Jcclxubm90ZUdyYWluT24oKSwgZGVwZW5kaW5nIG9uIHBhcmFtZXRlcnMuXHJcblxyXG5UaGUgZm9sbG93aW5nIGFsaWFzZXMgb25seSB0YWtlIGVmZmVjdCBpZiB0aGUgbmV3IG5hbWVzIGFyZSBub3QgYWxyZWFkeSBpbiBwbGFjZTpcclxuXHJcbkF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdG9wKCkgaXMgYWxpYXNlZCB0byBub3RlT2ZmKClcclxuQXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKSBpcyBhbGlhc2VkIHRvIGNyZWF0ZUdhaW5Ob2RlKClcclxuQXVkaW9Db250ZXh0LmNyZWF0ZURlbGF5KCkgaXMgYWxpYXNlZCB0byBjcmVhdGVEZWxheU5vZGUoKVxyXG5BdWRpb0NvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKCkgaXMgYWxpYXNlZCB0byBjcmVhdGVKYXZhU2NyaXB0Tm9kZSgpXHJcbkF1ZGlvQ29udGV4dC5jcmVhdGVQZXJpb2RpY1dhdmUoKSBpcyBhbGlhc2VkIHRvIGNyZWF0ZVdhdmVUYWJsZSgpXHJcbk9zY2lsbGF0b3JOb2RlLnN0YXJ0KCkgaXMgYWxpYXNlZCB0byBub3RlT24oKVxyXG5Pc2NpbGxhdG9yTm9kZS5zdG9wKCkgaXMgYWxpYXNlZCB0byBub3RlT2ZmKClcclxuT3NjaWxsYXRvck5vZGUuc2V0UGVyaW9kaWNXYXZlKCkgaXMgYWxpYXNlZCB0byBzZXRXYXZlVGFibGUoKVxyXG5BdWRpb1BhcmFtLnNldFRhcmdldEF0VGltZSgpIGlzIGFsaWFzZWQgdG8gc2V0VGFyZ2V0VmFsdWVBdFRpbWUoKVxyXG5cclxuVGhpcyBsaWJyYXJ5IGRvZXMgTk9UIHBhdGNoIHRoZSBlbnVtZXJhdGVkIHR5cGUgY2hhbmdlcywgYXMgaXQgaXNcclxucmVjb21tZW5kZWQgaW4gdGhlIHNwZWNpZmljYXRpb24gdGhhdCBpbXBsZW1lbnRhdGlvbnMgc3VwcG9ydCBib3RoIGludGVnZXJcclxuYW5kIHN0cmluZyB0eXBlcyBmb3IgQXVkaW9QYW5uZXJOb2RlLnBhbm5pbmdNb2RlbCwgQXVkaW9QYW5uZXJOb2RlLmRpc3RhbmNlTW9kZWxcclxuQmlxdWFkRmlsdGVyTm9kZS50eXBlIGFuZCBPc2NpbGxhdG9yTm9kZS50eXBlLlxyXG5cclxuKi9cclxuKGZ1bmN0aW9uIChnbG9iYWwsIGV4cG9ydHMsIHBlcmYpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGZ1bmN0aW9uIGZpeFNldFRhcmdldChwYXJhbSkge1xyXG4gICAgaWYgKCFwYXJhbSlcdC8vIGlmIE5ZSSwganVzdCByZXR1cm5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKCFwYXJhbS5zZXRUYXJnZXRBdFRpbWUpXHJcbiAgICAgIHBhcmFtLnNldFRhcmdldEF0VGltZSA9IHBhcmFtLnNldFRhcmdldFZhbHVlQXRUaW1lO1xyXG4gIH1cclxuXHJcbiAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0QXVkaW9Db250ZXh0JykgJiZcclxuICAgICAgIXdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnQXVkaW9Db250ZXh0JykpIHtcclxuICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3ZWJraXRBdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgaWYgKCFBdWRpb0NvbnRleHQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjcmVhdGVHYWluJykpXHJcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2Fpbk5vZGU7XHJcbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZURlbGF5JykpXHJcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXkgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5Tm9kZTtcclxuICAgIGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlU2NyaXB0UHJvY2Vzc29yJykpXHJcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlU2NyaXB0UHJvY2Vzc29yID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVKYXZhU2NyaXB0Tm9kZTtcclxuICAgIGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlUGVyaW9kaWNXYXZlJykpXHJcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUGVyaW9kaWNXYXZlID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVXYXZlVGFibGU7XHJcblxyXG5cclxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlR2FpbiA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbjtcclxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlR2FpbigpO1xyXG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5nYWluKTtcclxuICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlRGVsYXkgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5O1xyXG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheSA9IGZ1bmN0aW9uKG1heERlbGF5VGltZSkge1xyXG4gICAgICB2YXIgbm9kZSA9IG1heERlbGF5VGltZSA/IHRoaXMuaW50ZXJuYWxfY3JlYXRlRGVsYXkobWF4RGVsYXlUaW1lKSA6IHRoaXMuaW50ZXJuYWxfY3JlYXRlRGVsYXkoKTtcclxuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGVsYXlUaW1lKTtcclxuICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlQnVmZmVyU291cmNlID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCdWZmZXJTb3VyY2U7XHJcbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJ1ZmZlclNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgIGlmICghbm9kZS5zdGFydCkge1xyXG4gICAgICAgIG5vZGUuc3RhcnQgPSBmdW5jdGlvbiAoIHdoZW4sIG9mZnNldCwgZHVyYXRpb24gKSB7XHJcbiAgICAgICAgICBpZiAoIG9mZnNldCB8fCBkdXJhdGlvbiApXHJcbiAgICAgICAgICAgIHRoaXMubm90ZUdyYWluT24oIHdoZW4gfHwgMCwgb2Zmc2V0LCBkdXJhdGlvbiApO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLm5vdGVPbiggd2hlbiB8fCAwICk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0ID0gbm9kZS5zdGFydDtcclxuICAgICAgICBub2RlLnN0YXJ0ID0gZnVuY3Rpb24oIHdoZW4sIG9mZnNldCwgZHVyYXRpb24gKSB7XHJcbiAgICAgICAgICBpZiggdHlwZW9mIGR1cmF0aW9uICE9PSAndW5kZWZpbmVkJyApXHJcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCwgb2Zmc2V0LCBkdXJhdGlvbiApO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0KCB3aGVuIHx8IDAsIG9mZnNldCB8fCAwICk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIW5vZGUuc3RvcCkge1xyXG4gICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICggd2hlbiApIHtcclxuICAgICAgICAgIHRoaXMubm90ZU9mZiggd2hlbiB8fCAwICk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub2RlLmludGVybmFsX3N0b3AgPSBub2RlLnN0b3A7XHJcbiAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24oIHdoZW4gKSB7XHJcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AoIHdoZW4gfHwgMCApO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUucGxheWJhY2tSYXRlKTtcclxuICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlRHluYW1pY3NDb21wcmVzc29yID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3I7XHJcbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XHJcbiAgICAgIGZpeFNldFRhcmdldChub2RlLnRocmVzaG9sZCk7XHJcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmtuZWUpO1xyXG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5yYXRpbyk7XHJcbiAgICAgIGZpeFNldFRhcmdldChub2RlLnJlZHVjdGlvbik7XHJcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmF0dGFjayk7XHJcbiAgICAgIGZpeFNldFRhcmdldChub2RlLnJlbGVhc2UpO1xyXG4gICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVCaXF1YWRGaWx0ZXIgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJpcXVhZEZpbHRlcjtcclxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQmlxdWFkRmlsdGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcclxuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZnJlcXVlbmN5KTtcclxuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGV0dW5lKTtcclxuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuUSk7XHJcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmdhaW4pO1xyXG4gICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoICdjcmVhdGVPc2NpbGxhdG9yJyApKSB7XHJcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlT3NjaWxsYXRvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvcjtcclxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVPc2NpbGxhdG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZU9zY2lsbGF0b3IoKTtcclxuICAgICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcclxuICAgICAgICAgIG5vZGUuc3RhcnQgPSBmdW5jdGlvbiAoIHdoZW4gKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm90ZU9uKCB3aGVuIHx8IDAgKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQgPSBub2RlLnN0YXJ0O1xyXG4gICAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICggd2hlbiApIHtcclxuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdGFydCggd2hlbiB8fCAwKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbm9kZS5zdG9wKSB7XHJcbiAgICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiAoIHdoZW4gKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm90ZU9mZiggd2hlbiB8fCAwICk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AgPSBub2RlLnN0b3A7XHJcbiAgICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiggd2hlbiApIHtcclxuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wKCB3aGVuIHx8IDAgKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbm9kZS5zZXRQZXJpb2RpY1dhdmUpXHJcbiAgICAgICAgICBub2RlLnNldFBlcmlvZGljV2F2ZSA9IG5vZGUuc2V0V2F2ZVRhYmxlO1xyXG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLmZyZXF1ZW5jeSk7XHJcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGV0dW5lKTtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQnKSAmJlxyXG4gICAgICAhd2luZG93Lmhhc093blByb3BlcnR5KCdPZmZsaW5lQXVkaW9Db250ZXh0JykpIHtcclxuICAgIHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0ID0gd2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dDtcclxuICB9XHJcblxyXG59KHdpbmRvdykpO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wb2x5ZmlsbHMvQXVkaW9Db250ZXh0TW9ua2V5UGF0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDg4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBBIHBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxyXG4qL1xyXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XHJcblxyXG4gICAgLyoganNoaW50IGZyZWV6ZTogZmFsc2UgKi9cclxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IHRoaXMgOiB0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gKGZ1bmN0aW9uIEYocHJvdG8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm90bylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGLnByb3RvdHlwZSA9IHByb3RvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgc3VwZXJuZXc6IHRydWUgKi9cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKHRhcmdldC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kO1xyXG4gICAgICAgIH07XHJcbiAgICB9KSgpO1xyXG59XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BvbHlmaWxscy9GdW5jdGlvbi5iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA4ODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gRVM2IE1hdGgudHJ1bmMgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jXHJcbmlmICghTWF0aC50cnVuYykge1xyXG4gICAgTWF0aC50cnVuYyA9IGZ1bmN0aW9uIHRydW5jKHgpIHtcclxuICAgICAgICByZXR1cm4geCA8IDAgPyBNYXRoLmNlaWwoeCkgOiBNYXRoLmZsb29yKHgpO1xyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BvbHlmaWxscy9NYXRoLnRydW5jLmpzXG4vLyBtb2R1bGUgaWQgPSA4ODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogTG93LWJ1ZGdldCBGbG9hdDMyQXJyYXkga25vY2stb2ZmLCBzdWl0YWJsZSBmb3IgdXNlIHdpdGggUDIuanMgaW4gSUU5XHJcbiogU291cmNlOiBodHRwOi8vd3d3Lmh0bWw1Z2FtZWRldnMuY29tL3RvcGljLzU5ODgtcGhhc2VyLTEyLWllOS9cclxuKiBDYW1lcm9uIEZvYWxlIChodHRwOi8vd3d3LmtpYmlidS5jb20pXHJcbiovXHJcbmlmICh0eXBlb2Ygd2luZG93LlVpbnQzMkFycmF5ICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHdpbmRvdy5VaW50MzJBcnJheSAhPT0gXCJvYmplY3RcIilcclxue1xyXG4gICAgdmFyIENoZWFwQXJyYXkgPSBmdW5jdGlvbih0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwcm90byA9IG5ldyBBcnJheSgpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuXHJcbiAgICAgICAgd2luZG93W3R5cGVdID0gZnVuY3Rpb24oYXJnKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mKGFyZykgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LmNhbGwodGhpcywgYXJnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gYXJnO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LmNhbGwodGhpcywgYXJnLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBhcmcubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gYXJnW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgd2luZG93W3R5cGVdLnByb3RvdHlwZSA9IHByb3RvO1xyXG4gICAgICAgIHdpbmRvd1t0eXBlXS5jb25zdHJ1Y3RvciA9IHdpbmRvd1t0eXBlXTtcclxuICAgIH07XHJcblxyXG4gICAgQ2hlYXBBcnJheSgnRmxvYXQzMkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnVWludDMyQXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdVaW50MTZBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ0ludDE2QXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdBcnJheUJ1ZmZlcicpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BvbHlmaWxscy9VaW50MzJBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gODg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBBbHNvIGZpeCBmb3IgdGhlIGFic2VudCBjb25zb2xlIGluIElFOVxyXG4gKi9cclxuaWYgKCF3aW5kb3cuY29uc29sZSlcclxue1xyXG4gICAgd2luZG93LmNvbnNvbGUgPSB7fTtcclxuICAgIHdpbmRvdy5jb25zb2xlLmxvZyA9IHdpbmRvdy5jb25zb2xlLmFzc2VydCA9IGZ1bmN0aW9uKCl7fTtcclxuICAgIHdpbmRvdy5jb25zb2xlLndhcm4gPSB3aW5kb3cuY29uc29sZS5hc3NlcnQgPSBmdW5jdGlvbigpe307XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wb2x5ZmlsbHMvY29uc29sZS5qc1xuLy8gbW9kdWxlIGlkID0gODg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBwZXJmb3JtYW5jZS5ub3dcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgaWYgKCdwZXJmb3JtYW5jZScgaW4gd2luZG93ID09PSBmYWxzZSlcclxuICAgIHtcclxuICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgVGhhbmtzIElFOFxyXG4gICAgRGF0ZS5ub3cgPSAoRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICgnbm93JyBpbiB3aW5kb3cucGVyZm9ybWFuY2UgPT09IGZhbHNlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uIG5vdyAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wb2x5ZmlsbHMvcGVyZm9ybWFuY2Uubm93LmpzXG4vLyBtb2R1bGUgaWQgPSA4ODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gUmVmZXJlbmNlczpcclxuLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTU3OTY3MVxyXG4vLyBodHRwOi8vdXBkYXRlcy5odG1sNXJvY2tzLmNvbS8yMDEyLzA1L3JlcXVlc3RBbmltYXRpb25GcmFtZS1BUEktbm93LXdpdGgtc3ViLW1pbGxpc2Vjb25kLXByZWNpc2lvblxyXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90aW1oYWxsLzQwNzg2MTRcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0ZpbmFuY2lhbC1UaW1lcy9wb2x5ZmlsbC1zZXJ2aWNlL3RyZWUvbWFzdGVyL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuXHJcbi8vIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCBCcm93c2VyZml5XHJcbi8vIEJyb3dzZXJpZnkgYXV0b21hdGljYWxseSBkZXRlY3RzIHRoZSB1c2Ugb2YgYGdsb2JhbGAgYW5kIHBhc3NlcyB0aGVcclxuLy8gY29ycmVjdCByZWZlcmVuY2Ugb2YgYGdsb2JhbGAsIGBzZWxmYCwgYW5kIGZpbmFsbHkgYHdpbmRvd2BcclxuXHJcbi8vIERhdGUubm93XHJcbmlmICghKERhdGUubm93ICYmIERhdGUucHJvdG90eXBlLmdldFRpbWUpKSB7XHJcbiAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBwZXJmb3JtYW5jZS5ub3dcclxuaWYgKCEoZ2xvYmFsLnBlcmZvcm1hbmNlICYmIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cpKSB7XHJcbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIGlmICghZ2xvYmFsLnBlcmZvcm1hbmNlKSB7XHJcbiAgICAgICAgZ2xvYmFsLnBlcmZvcm1hbmNlID0ge307XHJcbiAgICB9XHJcbiAgICBnbG9iYWwucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xyXG4gICAgfTtcclxufVxyXG5cclxuLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbnZhciBsYXN0VGltZSA9IERhdGUubm93KCk7XHJcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcclxuXHJcbmZvcih2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XHJcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XHJcbiAgICAgICAgZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcbn1cclxuXHJcbmlmICghZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xyXG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICdpcyBub3QgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgZGVsYXkgPSAxNiArIGxhc3RUaW1lIC0gY3VycmVudFRpbWU7XHJcblxyXG4gICAgICAgIGlmIChkZWxheSA8IDApIHtcclxuICAgICAgICAgICAgZGVsYXkgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyZW50VGltZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsYXN0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcclxuICAgICAgICB9LCBkZWxheSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5pZiAoIWdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xyXG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDg4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmxpdEltYWdlID0gcmVxdWlyZSgnLi91dGlscy9CbGl0SW1hZ2UnKTtcclxudmFyIENhbnZhc1NuYXBzaG90ID0gcmVxdWlyZSgnLi4vc25hcHNob3QvQ2FudmFzU25hcHNob3QnKTtcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcclxudmFyIERyYXdJbWFnZSA9IHJlcXVpcmUoJy4vdXRpbHMvRHJhd0ltYWdlJyk7XHJcbnZhciBHZXRCbGVuZE1vZGVzID0gcmVxdWlyZSgnLi91dGlscy9HZXRCbGVuZE1vZGVzJyk7XHJcbnZhciBHZXRDb250ZXh0ID0gcmVxdWlyZSgnLi4vLi4vY2FudmFzL0dldENvbnRleHQnKTtcclxudmFyIFNjYWxlTW9kZXMgPSByZXF1aXJlKCcuLi9TY2FsZU1vZGVzJyk7XHJcbnZhciBTbW9vdGhpbmcgPSByZXF1aXJlKCcuLi8uLi9kb20vU21vb3RoaW5nJyk7XHJcblxyXG52YXIgQ2FudmFzUmVuZGVyZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIgKGdhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJvcGVydHkge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIEdhbWUuXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG5cclxuICAgICAgICAvLyAgTmVlZGVkP1xyXG4gICAgICAgIHRoaXMudHlwZSA9IENPTlNULkNBTlZBUztcclxuXHJcbiAgICAgICAgdGhpcy5kcmF3Q291bnQgPSAwO1xyXG5cclxuICAgICAgICAvLyAgUmVhZCBhbGwgdGhlIGZvbGxvd2luZyBmcm9tIGdhbWUgY29uZmlnIChvciBTY2VuZSBjb25maWc/KVxyXG4gICAgICAgIC8vIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgIC8vIHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcclxuICAgICAgICAvLyB0aGlzLmF1dG9SZXNpemUgPSBmYWxzZTtcclxuICAgICAgICAvLyB0aGlzLnJvdW5kUGl4ZWxzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcblxyXG4gICAgICAgIHRoaXMuc2NhbGVNb2RlID0gKGdhbWUuY29uZmlnLnBpeGVsQXJ0KSA/IFNjYWxlTW9kZXMuTkVBUkVTVCA6IFNjYWxlTW9kZXMuTElORUFSO1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVDYW52YXMgPSBnYW1lLmNhbnZhcztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhbnZhcyAyZCBjb250ZXh0IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB3aXRoXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbnRleHRcclxuICAgICAgICAgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdhbWVDb250ZXh0ID0gR2V0Q29udGV4dCh0aGlzLmdhbWVDYW52YXMpO1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVDb25maWcgPSBnYW1lLmNvbmZpZztcclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29udGV4dCA9IHRoaXMuZ2FtZUNvbnRleHQ7XHJcblxyXG4gICAgICAgIC8vICBNYXAgdG8gdGhlIHJlcXVpcmVkIGZ1bmN0aW9uXHJcbiAgICAgICAgdGhpcy5kcmF3SW1hZ2UgPSBEcmF3SW1hZ2U7XHJcbiAgICAgICAgdGhpcy5ibGl0SW1hZ2UgPSBCbGl0SW1hZ2U7XHJcblxyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlcyA9IEdldEJsZW5kTW9kZXMoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50QWxwaGEgPSAxO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2NhbGVNb2RlID0gMDtcclxuXHJcbiAgICAgICAgLy8gdGhpcy50aW50TWV0aG9kID0gdGhpcy50aW50V2l0aFBlclBpeGVsO1xyXG5cclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBSZXNpemUgdGhlIG1haW4gZ2FtZSBjYW52YXNcclxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzO1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVDYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuZ2FtZUNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZUNhbnZhcy5zdHlsZS53aWR0aCA9ICh0aGlzLndpZHRoIC8gcmVzKSArICdweCc7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZUNhbnZhcy5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgLyByZXMpICsgJ3B4JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBSZXNpemluZyBhIGNhbnZhcyB3aWxsIHJlc2V0IGltYWdlU21vb3RoaW5nRW5hYmxlZCAoYW5kIHByb2JhYmx5IG90aGVyIHByb3BlcnRpZXMpXHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVNb2RlID09PSBTY2FsZU1vZGVzLk5FQVJFU1QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTbW9vdGhpbmcuZGlzYWJsZSh0aGlzLmdhbWVDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZENvbnRleHRMb3N0Q2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQ29udGV4dFJlc3RvcmVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIHJlc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCbGVuZE1vZGU6IGZ1bmN0aW9uIChibGVuZE1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJsZW5kTW9kZSAhPT0gYmxlbmRNb2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRCbGVuZE1vZGU7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEFscGhhOiBmdW5jdGlvbiAoYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFscGhhICE9PSBhbHBoYSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QWxwaGEgPSBhbHBoYTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRBbHBoYTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGwgYXQgdGhlIHN0YXJ0IG9mIHRoZSByZW5kZXIgbG9vcFxyXG4gICAgcHJlUmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCclYyByZW5kZXIgc3RhcnQgJywgJ2NvbG9yOiAjZmZmZmZmOyBiYWNrZ3JvdW5kOiAjMDBmZjAwOycpO1xyXG5cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5nYW1lQ29udGV4dDtcclxuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5nYW1lQ29uZmlnO1xyXG5cclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5jbGVhckJlZm9yZVJlbmRlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZy50cmFuc3BhcmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb25maWcuYmFja2dyb3VuZENvbG9yLnJnYmE7XHJcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBBZGQgUHJlLXJlbmRlciBob29rXHJcblxyXG4gICAgICAgIHRoaXMuZHJhd0NvdW50ID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBTY2VuZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtQaGFzZXIuU2NlbmV9IHNjZW5lIC0gVGhlIFNjZW5lIHRvIGJlIHJlbmRlcmVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVycG9sYXRpb25QZXJjZW50YWdlIC0gVGhlIGN1bXVsYXRpdmUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXNuJ3QgYmVlbiBzaW11bGF0ZWQgeWV0LCBkaXZpZGVkXHJcbiAgICAgKiAgIGJ5IHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IHdpbGwgYmUgc2ltdWxhdGVkIHRoZSBuZXh0IHRpbWUgdXBkYXRlKClcclxuICAgICAqICAgcnVucy4gVXNlZnVsIGZvciBpbnRlcnBvbGF0aW5nIGZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoc2NlbmUsIGNoaWxkcmVuLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIC8vIHZhciB3ID0gc2NlbmUuc3lzLndpZHRoO1xyXG4gICAgICAgIC8vIHZhciBoID0gc2NlbmUuc3lzLmhlaWdodDtcclxuICAgICAgICB2YXIgY3R4ID0gc2NlbmUuc3lzLmNvbnRleHQ7XHJcbiAgICAgICAgdmFyIHNldHRpbmdzID0gc2NlbmUuc3lzLnNldHRpbmdzO1xyXG4gICAgICAgIHZhciBzY2lzc29yID0gKGNhbWVyYS54ICE9PSAwIHx8IGNhbWVyYS55ICE9PSAwIHx8IGNhbWVyYS53aWR0aCAhPT0gY3R4LmNhbnZhcy53aWR0aCB8fCBjYW1lcmEuaGVpZ2h0ICE9PSBjdHguY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgdmFyIGxpc3QgPSBjaGlsZHJlbi5saXN0O1xyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gY3R4O1xyXG5cclxuICAgICAgICAvLyAgSWYgdGhlIGFscGhhIG9yIGJsZW5kIG1vZGUgZGlkbid0IGNoYW5nZSBzaW5jZSB0aGUgbGFzdCByZW5kZXIsIHRoZW4gZG9uJ3Qgc2V0IHRoZW0gYWdhaW4gKHNhdmVzIDIgb3BzKVxyXG5cclxuICAgICAgICBpZiAoIWNhbWVyYS50cmFuc3BhcmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjYW1lcmEuYmFja2dyb3VuZENvbG9yLnJnYmE7XHJcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW1lcmEud2lkdGgsIGNhbWVyYS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFscGhhICE9PSAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QWxwaGEgPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJsZW5kTW9kZSAhPT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2NhbGVNb2RlID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5kcmF3Q291bnQgKz0gbGlzdC5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChzY2lzc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgucmVjdChjYW1lcmEueCwgY2FtZXJhLnksIGNhbWVyYS53aWR0aCwgY2FtZXJhLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtYXRyaXggPSBjYW1lcmEubWF0cml4Lm1hdHJpeDtcclxuXHJcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLCBtYXRyaXhbM10sIG1hdHJpeFs0XSwgbWF0cml4WzVdKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBsaXN0Lmxlbmd0aDsgYysrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gbGlzdFtjXTtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkLnJlbmRlckNhbnZhcyh0aGlzLCBjaGlsZCwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQ2FsbCB0aGUgU2NlbmUucmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgc2NlbmUucmVuZGVyLmNhbGwoc2NlbmUsIGN0eCwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcblxyXG4gICAgICAgIGlmIChjYW1lcmEuX2ZhZGVBbHBoYSA+IDAgfHwgY2FtZXJhLl9mbGFzaEFscGhhID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGZhZGUgcmVuZGVyaW5nXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKCcgKyAoY2FtZXJhLl9mYWRlUmVkICogMjU1KSArICcsJyArIChjYW1lcmEuX2ZhZGVHcmVlbiAqIDI1NSkgKyAnLCcgKyAoY2FtZXJhLl9mYWRlQmx1ZSAqIDI1NSkgKyAnKSc7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGNhbWVyYS5fZmFkZUFscGhhO1xyXG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoY2FtZXJhLngsIGNhbWVyYS55LCBjYW1lcmEud2lkdGgsIGNhbWVyYS5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gZmxhc2ggcmVuZGVyaW5nXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKCcgKyAoY2FtZXJhLl9mbGFzaFJlZCAqIDI1NSkgKyAnLCcgKyAoY2FtZXJhLl9mbGFzaEdyZWVuICogMjU1KSArICcsJyArIChjYW1lcmEuX2ZsYXNoQmx1ZSAqIDI1NSkgKyAnKSc7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGNhbWVyYS5fZmxhc2hBbHBoYTtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGNhbWVyYS54LCBjYW1lcmEueSwgY2FtZXJhLndpZHRoLCBjYW1lcmEuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBSZXNldCB0aGUgY2FtZXJhIHNjaXNzb3JcclxuICAgICAgICBpZiAoc2Npc3NvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vICBCbGFzdCBpdCB0byB0aGUgR2FtZSBDYW52YXMgKGlmIG5lZWRlZClcclxuICAgICAgICAvLyBpZiAoc2V0dGluZ3MucmVuZGVyVG9UZXh0dXJlKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAgICAgLy8gdGhpcy5nYW1lQ29udGV4dC5kcmF3SW1hZ2Uoc2NlbmUuc3lzLmNhbnZhcywgMCwgMCwgdywgaCwgc2V0dGluZ3MueCwgc2V0dGluZ3MueSwgdywgaCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfSxcclxuXHJcbiAgICBwb3N0UmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCclYyByZW5kZXIgZW5kICcsICdjb2xvcjogI2ZmZmZmZjsgYmFja2dyb3VuZDogI2ZmMDAwMDsnKTtcclxuXHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2FtZUNvbnRleHQ7XHJcblxyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudEFscGhhID0gMTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSAwO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zbmFwc2hvdENhbGxiYWNrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrKENhbnZhc1NuYXBzaG90KHRoaXMuZ2FtZUNhbnZhcykpO1xyXG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEFkZCBQb3N0LXJlbmRlciBob29rXHJcbiAgICB9LFxyXG5cclxuICAgIHNuYXBzaG90OiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIENhbnZhcyBET00gZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcclxuICAgICAqIEBwYXJhbSBbcmVtb3ZlZ2FtZUNhbnZhcz10cnVlXSB7Ym9vbGVhbn0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBDYW52YXNQb29sXHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZUNhbnZhcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5nYW1lQ29udGV4dCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvY2FudmFzL0NhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4ODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbi8vICBObyBzY2FsaW5nLCBhbmNob3IsIHJvdGF0aW9uIG9yIGVmZmVjdHMsIGxpdGVyYWxseSBkcmF3cyB0aGUgZnJhbWUgZGlyZWN0bHkgdG8gdGhlIGNhbnZhc1xyXG52YXIgQmxpdEltYWdlID0gZnVuY3Rpb24gKGR4LCBkeSwgZnJhbWUsIGNhbWVyYSlcclxue1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY3VycmVudENvbnRleHQ7XHJcbiAgICB2YXIgY2QgPSBmcmFtZS5jYW52YXNEYXRhO1xyXG5cclxuICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgZnJhbWUuc291cmNlLmltYWdlLFxyXG4gICAgICAgIGNkLnN4LFxyXG4gICAgICAgIGNkLnN5LFxyXG4gICAgICAgIGNkLnNXaWR0aCxcclxuICAgICAgICBjZC5zSGVpZ2h0LFxyXG4gICAgICAgIGR4IC0gY2FtZXJhLnNjcm9sbFgsXHJcbiAgICAgICAgZHkgLSBjYW1lcmEuc2Nyb2xsWSxcclxuICAgICAgICBjZC5kV2lkdGgsXHJcbiAgICAgICAgY2QuZEhlaWdodFxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxpdEltYWdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL2NhbnZhcy91dGlscy9CbGl0SW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDg5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIERyYXdJbWFnZSA9IGZ1bmN0aW9uIChzcmMsIGNhbWVyYSlcclxue1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY3VycmVudENvbnRleHQ7XHJcbiAgICB2YXIgZnJhbWUgPSBzcmMuZnJhbWU7XHJcbiAgICB2YXIgY2QgPSBmcmFtZS5jYW52YXNEYXRhO1xyXG5cclxuICAgIC8vICBCbGVuZCBNb2RlXHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEJsZW5kTW9kZSAhPT0gc3JjLmJsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSBzcmMuYmxlbmRNb2RlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmJsZW5kTW9kZXNbc3JjLmJsZW5kTW9kZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFscGhhXHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEFscGhhICE9PSBzcmMuYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTbW9vdGhpbmdcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50U2NhbGVNb2RlICE9PSBzcmMuc2NhbGVNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNjYWxlTW9kZSA9IHNyYy5zY2FsZU1vZGU7XHJcbiAgICAgICAgLy8gY3R4W3RoaXMuc21vb3RoUHJvcGVydHldID0gKHNvdXJjZS5zY2FsZU1vZGUgPT09IFNjYWxlTW9kZXMuTElORUFSKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZHggPSBmcmFtZS54O1xyXG4gICAgdmFyIGR5ID0gZnJhbWUueTtcclxuXHJcbiAgICB2YXIgZnggPSAxO1xyXG4gICAgdmFyIGZ5ID0gMTtcclxuXHJcbiAgICBpZiAoc3JjLmZsaXBYKVxyXG4gICAge1xyXG4gICAgICAgIGZ4ID0gLTE7XHJcbiAgICAgICAgZHggLT0gY2QuZFdpZHRoIC0gc3JjLmRpc3BsYXlPcmlnaW5YO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGR4IC09IHNyYy5kaXNwbGF5T3JpZ2luWDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3JjLmZsaXBZKVxyXG4gICAge1xyXG4gICAgICAgIGZ5ID0gLTE7XHJcbiAgICAgICAgZHkgLT0gY2QuZEhlaWdodCAtIHNyYy5kaXNwbGF5T3JpZ2luWTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBkeSAtPSBzcmMuZGlzcGxheU9yaWdpblk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFBlcmZvcm0gTWF0cml4IElUUlNcclxuXHJcbiAgICBjdHguc2F2ZSgpO1xyXG5cclxuICAgIGN0eC50cmFuc2xhdGUoc3JjLnggLSBjYW1lcmEuc2Nyb2xsWCAqIHNyYy5zY3JvbGxGYWN0b3JYLCBzcmMueSAtIGNhbWVyYS5zY3JvbGxZICogc3JjLnNjcm9sbEZhY3RvclkpO1xyXG5cclxuICAgIGN0eC5yb3RhdGUoc3JjLnJvdGF0aW9uKTtcclxuXHJcbiAgICBjdHguc2NhbGUoc3JjLnNjYWxlWCwgc3JjLnNjYWxlWSk7XHJcbiAgICBjdHguc2NhbGUoZngsIGZ5KTtcclxuXHJcbiAgICBjdHguZHJhd0ltYWdlKGZyYW1lLnNvdXJjZS5pbWFnZSwgY2Quc3gsIGNkLnN5LCBjZC5zV2lkdGgsIGNkLnNIZWlnaHQsIGR4LCBkeSwgY2QuZFdpZHRoLCBjZC5kSGVpZ2h0KTtcclxuXHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEcmF3SW1hZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0RyYXdJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gODkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtb2RlcyA9IHJlcXVpcmUoJy4uLy4uL0JsZW5kTW9kZXMnKTtcclxudmFyIENhbnZhc0ZlYXR1cmVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZGV2aWNlL0NhbnZhc0ZlYXR1cmVzJyk7XHJcblxyXG52YXIgR2V0QmxlbmRNb2RlcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBvdXRwdXQgPSBbXTtcclxuICAgIHZhciB1c2VOZXcgPSBDYW52YXNGZWF0dXJlcy5zdXBwb3J0TmV3QmxlbmRNb2RlcztcclxuXHJcbiAgICBvdXRwdXRbbW9kZXMuTk9STUFMXSA9ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuQUREXSA9ICdsaWdodGVyJztcclxuICAgIG91dHB1dFttb2Rlcy5NVUxUSVBMWV0gPSAodXNlTmV3KSA/ICdtdWx0aXBseScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLlNDUkVFTl0gPSAodXNlTmV3KSA/ICdzY3JlZW4nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5PVkVSTEFZXSA9ICh1c2VOZXcpID8gJ292ZXJsYXknIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5EQVJLRU5dID0gKHVzZU5ldykgPyAnZGFya2VuJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuTElHSFRFTl0gPSAodXNlTmV3KSA/ICdsaWdodGVuJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuQ09MT1JfRE9ER0VdID0gKHVzZU5ldykgPyAnY29sb3ItZG9kZ2UnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5DT0xPUl9CVVJOXSA9ICh1c2VOZXcpID8gJ2NvbG9yLWJ1cm4nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5IQVJEX0xJR0hUXSA9ICh1c2VOZXcpID8gJ2hhcmQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5TT0ZUX0xJR0hUXSA9ICh1c2VOZXcpID8gJ3NvZnQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5ESUZGRVJFTkNFXSA9ICh1c2VOZXcpID8gJ2RpZmZlcmVuY2UnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5FWENMVVNJT05dID0gKHVzZU5ldykgPyAnZXhjbHVzaW9uJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuSFVFXSA9ICh1c2VOZXcpID8gJ2h1ZScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLlNBVFVSQVRJT05dID0gKHVzZU5ldykgPyAnc2F0dXJhdGlvbicgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLkNPTE9SXSA9ICh1c2VOZXcpID8gJ2NvbG9yJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuTFVNSU5PU0lUWV0gPSAodXNlTmV3KSA/ICdsdW1pbm9zaXR5JyA6ICdzb3VyY2Utb3Zlcic7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0QmxlbmRNb2RlcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci9jYW52YXMvdXRpbHMvR2V0QmxlbmRNb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gODkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYW52YXNTbmFwc2hvdCA9IGZ1bmN0aW9uIChjYW52YXMpXHJcbntcclxuICAgIHZhciBzcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XHJcblxyXG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgaW1hZ2Uuc3JjID0gc3JjO1xyXG5cclxuICAgIHJldHVybiBpbWFnZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzU25hcHNob3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvc25hcHNob3QvQ2FudmFzU25hcHNob3QuanNcbi8vIG1vZHVsZSBpZCA9IDg5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgV2ViR0xTbmFwc2hvdCA9IGZ1bmN0aW9uIChzb3VyY2VDYW52YXMpXHJcbntcclxuICAgIHZhciBnbCA9IHNvdXJjZUNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKTtcclxuICAgIHZhciBwaXhlbHMgPSBuZXcgVWludDhBcnJheShnbC5kcmF3aW5nQnVmZmVyV2lkdGggKiBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0ICogNCk7XHJcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcclxuXHJcbiAgICAvLyAgQ2FudmFzUG9vbD9cclxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIHZhciBpbWFnZURhdGE7XHJcblxyXG4gICAgY2FudmFzLndpZHRoID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQ7XHJcblxyXG4gICAgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XHJcblxyXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5ICs9IDEpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHggKz0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzaSA9ICgoY2FudmFzLmhlaWdodCAtIHkpICogY2FudmFzLndpZHRoICsgeCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgZGkgPSAoeSAqIGNhbnZhcy53aWR0aCArIHgpICogNDtcclxuICAgICAgICAgICAgZGF0YVtkaSArIDBdID0gcGl4ZWxzW3NpICsgMF07XHJcbiAgICAgICAgICAgIGRhdGFbZGkgKyAxXSA9IHBpeGVsc1tzaSArIDFdO1xyXG4gICAgICAgICAgICBkYXRhW2RpICsgMl0gPSBwaXhlbHNbc2kgKyAyXTtcclxuICAgICAgICAgICAgZGF0YVtkaSArIDNdID0gcGl4ZWxzW3NpICsgM107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcclxuXHJcbiAgICB2YXIgc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpO1xyXG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgaW1hZ2Uuc3JjID0gc3JjO1xyXG5cclxuICAgIHJldHVybiBpbWFnZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2ViR0xTbmFwc2hvdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci9zbmFwc2hvdC9XZWJHTFNuYXBzaG90LmpzXG4vLyBtb2R1bGUgaWQgPSA4OTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIFJlc291cmNlcyA9IHJlcXVpcmUoJy4vcmVzb3VyY2VzJyk7XHJcblxyXG52YXIgUmVzb3VyY2VNYW5hZ2VyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFJlc291cmNlTWFuYWdlciAoZ2wpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xyXG5cclxuICAgICAgICAvLyAgTWF5YmUgYWRkIHBvb2xpbmcgaGVyZT9cclxuICAgICAgICB0aGlzLnNoYWRlckNhY2hlID0ge307XHJcbiAgICAgICAgdGhpcy5zaGFkZXJDb3VudCA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVJlbmRlclRhcmdldDogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGNvbG9yQnVmZmVyLCBkZXB0aFN0ZW5jaWxCdWZmZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB2YXIgZnJhbWVidWZmZXJPYmplY3QgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICAgIHZhciBkZXB0aFN0ZW5jaWxSZW5kZXJidWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHZhciBjb2xvclJlbmRlcmJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlID0gMDtcclxuXHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlck9iamVjdCk7XHJcblxyXG4gICAgICAgIGlmIChkZXB0aFN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCAmJiBkZXB0aFN0ZW5jaWxCdWZmZXIgIT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWxCdWZmZXIuaXNSZW5kZXJUZXh0dXJlID0gdHJ1ZTtcclxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgZGVwdGhTdGVuY2lsQnVmZmVyLnRleHR1cmUsIGRlcHRoU3RlbmNpbEJ1ZmZlci5taXBMZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbFJlbmRlcmJ1ZmZlck9iamVjdCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZGVwdGhTdGVuY2lsUmVuZGVyYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGRlcHRoU3RlbmNpbFJlbmRlcmJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29sb3JCdWZmZXIgIT09IHVuZGVmaW5lZCAmJiBjb2xvckJ1ZmZlciAhPT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbG9yQnVmZmVyLmlzUmVuZGVyVGV4dHVyZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgY29sb3JCdWZmZXIudGV4dHVyZSwgY29sb3JCdWZmZXIubWlwTGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb2xvclJlbmRlcmJ1ZmZlck9iamVjdCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgY29sb3JSZW5kZXJidWZmZXJPYmplY3QpO1xyXG4gICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuUkdCQTQsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlJFTkRFUkJVRkZFUiwgY29sb3JSZW5kZXJidWZmZXJPYmplY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29tcGxldGUgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbXBsZXRlICE9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSB7XHJcbiAgICAgICAgICAgICAgICAzNjA1NDogJ0luY29tcGxldGUgQXR0YWNobWVudCcsXHJcbiAgICAgICAgICAgICAgICAzNjA1NTogJ01pc3NpbmcgQXR0YWNobWVudCcsXHJcbiAgICAgICAgICAgICAgICAzNjA1NzogJ0luY29tcGxldGUgRGltZW5zaW9ucycsXHJcbiAgICAgICAgICAgICAgICAzNjA2MTogJ0ZyYW1lYnVmZmVyIFVuc3VwcG9ydGVkJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lYnVmZmVyIGluY29tcGxldGUuIEZyYW1lYnVmZmVyIHN0YXR1czogJyArIGVycm9yc1tjb21wbGV0ZV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZXMuUmVuZGVyVGFyZ2V0KFxyXG4gICAgICAgICAgICBmcmFtZWJ1ZmZlck9iamVjdCxcclxuICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcclxuICAgICAgICAgICAgKGNvbG9yQnVmZmVyID09PSB1bmRlZmluZWQgPyBudWxsIDogY29sb3JCdWZmZXIpLFxyXG4gICAgICAgICAgICAoZGVwdGhTdGVuY2lsQnVmZmVyID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwdGhTdGVuY2lsQnVmZmVyKVxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUJ1ZmZlcjogZnVuY3Rpb24gKHRhcmdldCwgaW5pdGlhbERhdGFPclNpemUsIGJ1ZmZlclVzYWdlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgdmFyIGJ1ZmZlck9iamVjdCA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIodGFyZ2V0LCBidWZmZXJPYmplY3QpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEodGFyZ2V0LCBpbml0aWFsRGF0YU9yU2l6ZSwgYnVmZmVyVXNhZ2UpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHRhcmdldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgZ2wuQVJSQVlfQlVGRkVSOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZXMuVmVydGV4QnVmZmVyKGdsLCBidWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VzLkluZGV4QnVmZmVyKGdsLCBidWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBCdWZmZXIgVGFyZ2V0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbiAobWlwTGV2ZWwsIG1pbkZpbHRlciwgbWFnRmlsdGVyLCB3cmFwVCwgd3JhcFMsIGZvcm1hdCwgcGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBtaW5GaWx0ZXIpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBtYWdGaWx0ZXIpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHdyYXBTKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB3cmFwVCk7XHJcblxyXG4gICAgICAgIGlmIChwaXhlbHMgPT09IG51bGwgfHwgcGl4ZWxzID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcExldmVsLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwTGV2ZWwsIGZvcm1hdCwgZm9ybWF0LCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpO1xyXG4gICAgICAgICAgICB3aWR0aCA9IHBpeGVscy53aWR0aDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gcGl4ZWxzLmhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlcy5UZXh0dXJlKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVTaGFkZXI6IGZ1bmN0aW9uIChzaGFkZXJOYW1lLCBzaGFkZXJTb3VyY2VzKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChzaGFkZXJOYW1lID09PSBudWxsIHx8IHNoYWRlck5hbWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNoYWRlck5hbWUgKz0gJ1NoYWRlcicgKyB0aGlzLnNoYWRlckNvdW50O1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlckNvdW50ICs9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIShzaGFkZXJOYW1lIGluIHRoaXMuc2hhZGVyQ2FjaGUpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICAgICAgdmFyIHByb2dyYW07XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0U2hhZGVyO1xyXG4gICAgICAgICAgICB2YXIgZnJhZ1NoYWRlcjtcclxuICAgICAgICAgICAgdmFyIHN0YXR1cztcclxuICAgICAgICAgICAgdmFyIGVycm9yO1xyXG4gICAgICAgICAgICB2YXIgc2hhZGVyO1xyXG5cclxuICAgICAgICAgICAgdmVydFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgICAgICAgZ2wuc2hhZGVyU291cmNlKHZlcnRTaGFkZXIsIHNoYWRlclNvdXJjZXMudmVydCk7XHJcbiAgICAgICAgICAgIGdsLmNvbXBpbGVTaGFkZXIodmVydFNoYWRlcik7XHJcblxyXG4gICAgICAgICAgICBzdGF0dXMgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xyXG4gICAgICAgICAgICBlcnJvciA9IGdsLmdldFNoYWRlckluZm9Mb2codmVydFNoYWRlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXN0YXR1cyAmJiBlcnJvciAmJiBlcnJvci5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBTaGFkZXIgQ29tcGlsYXRpb24gRXJyb3IuIFNoYWRlciBuYW1lOiAnICsgc2hhZGVyTmFtZSArICcuXFxuJyArIGVycm9yICsgJ1xcblxcbiBTaGFkZXIgc291cmNlOlxcbicgKyBzaGFkZXJTb3VyY2VzLnZlcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIGVycm9yLmxlbmd0aCA+IDEwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1ZlcnRleCBTaGFkZXIgQ29tcGlsYXRpb24gV2FybmluZy4gU2hhZGVyIG5hbWU6ICcgKyBzaGFkZXJOYW1lICsgJy5cXG4nICsgZXJyb3IgKyAnXFxuXFxuIFNoYWRlciBzb3VyY2U6XFxuJyArIHNoYWRlclNvdXJjZXMudmVydCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZyYWdTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgICAgICAgICAgZ2wuc2hhZGVyU291cmNlKGZyYWdTaGFkZXIsIHNoYWRlclNvdXJjZXMuZnJhZyk7XHJcbiAgICAgICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ1NoYWRlcik7XHJcblxyXG4gICAgICAgICAgICBzdGF0dXMgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ1NoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xyXG4gICAgICAgICAgICBlcnJvciA9IGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ1NoYWRlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXN0YXR1cyAmJiBlcnJvciAmJiBlcnJvci5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYWdtZW50IFNoYWRlciBDb21waWxhdGlvbiBFcnJvci4gU2hhZGVyIG5hbWU6ICcgKyBzaGFkZXJOYW1lICsgJy5cXG4nICsgZXJyb3IgKyAnXFxuXFxuIFNoYWRlciBzb3VyY2U6XFxuJyArIHNoYWRlclNvdXJjZXMuZnJhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgZXJyb3IubGVuZ3RoID4gMTApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRnJhZ21lbnQgU2hhZGVyIENvbXBpbGF0aW9uIFdhcm5pbmcuIFNoYWRlciBuYW1lOiAnICsgc2hhZGVyTmFtZSArICcuXFxuJyArIGVycm9yICsgJ1xcblxcbiBTaGFkZXIgc291cmNlOlxcbicgKyBzaGFkZXJTb3VyY2VzLmZyYWcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydFNoYWRlcik7XHJcbiAgICAgICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnU2hhZGVyKTtcclxuICAgICAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIGdsLnZhbGlkYXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcbiAgICAgICAgICAgIHN0YXR1cyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xyXG4gICAgICAgICAgICBlcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzdGF0dXMgJiYgZXJyb3IgJiYgZXJyb3IubGVuZ3RoID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9ncmFtIExpbmtpbmcgRXJyb3IuIFNoYWRlciBuYW1lOiAnICsgc2hhZGVyTmFtZSArICcuXFxuJyArIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBlcnJvci5sZW5ndGggPiAxMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQcm9ncmFtIExpbmtpbmcgV2FybmluZy4gU2hhZGVyIG5hbWU6ICcgKyBzaGFkZXJOYW1lICsgJy5cXG4nICsgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdGF0dXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyk7XHJcbiAgICAgICAgICAgIGVycm9yID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXN0YXR1cyAmJiBlcnJvciAmJiBlcnJvci5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2dyYW0gVmFsaWRhdGlvbiBFcnJvci4gU2hhZGVyIG5hbWU6ICcgKyBzaGFkZXJOYW1lICsgJy5cXG4nICsgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIGVycm9yLmxlbmd0aCA+IDEwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Byb2dyYW0gVmFsaWRhdGlvbiBXYXJuaW5nLiBTaGFkZXIgbmFtZTogJyArIHNoYWRlck5hbWUgKyAnLlxcbicgKyBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNoYWRlciA9IG5ldyBSZXNvdXJjZXMuU2hhZGVyKHNoYWRlck5hbWUsIGdsLCBwcm9ncmFtLCB2ZXJ0U2hhZGVyLCBmcmFnU2hhZGVyKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyQ2FjaGVbc2hhZGVyTmFtZV0gPSBzaGFkZXI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXJDYWNoZVtzaGFkZXJOYW1lXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGV0ZVNoYWRlcjogZnVuY3Rpb24gKHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICB2YXIgc3RvcmVkU2hhZGVyID0gdGhpcy5zaGFkZXJDYWNoZVtzaGFkZXIubmFtZV07XHJcblxyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgIGlmIChzdG9yZWRTaGFkZXIgIT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNoYWRlckNhY2hlW3NoYWRlci5uYW1lXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIudmVydGV4U2hhZGVyKTtcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyLmZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcclxuXHJcbiAgICAgICAgc2hhZGVyLnZlcnRleFNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgc2hhZGVyLmZyYWdtZW50U2hhZGVyID0gbnVsbDtcclxuICAgICAgICBzaGFkZXIucHJvZ3JhbSA9IG51bGw7XHJcbiAgICAgICAgc2hhZGVyLm5hbWUgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZWxldGVCdWZmZXI6IGZ1bmN0aW9uIChidWZmZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKGJ1ZmZlci5idWZmZXJPYmplY3QpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc291cmNlTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9SZXNvdXJjZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgKEBwaG90b25zdG9ybSlcclxuKiBAYXV0aG9yICAgICAgIEZlbGlwZSBBbGZvbnNvIChAYml0bmVuZmVyKVxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNyBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQmxlbmRNb2RlcyA9IHJlcXVpcmUoJy4uL0JsZW5kTW9kZXMnKTtcclxudmFyIEJsaXR0ZXJCYXRjaCA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL2JsaXR0ZXJiYXRjaC9CbGl0dGVyQmF0Y2gnKTtcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcclxudmFyIEVmZmVjdFJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvZWZmZWN0cmVuZGVyZXIvRWZmZWN0UmVuZGVyZXInKTtcclxudmFyIElzU2l6ZVBvd2VyT2ZUd28gPSByZXF1aXJlKCcuLi8uLi9tYXRoL3BvdzIvSXNTaXplUG93ZXJPZlR3bycpO1xyXG52YXIgUXVhZEJhdGNoID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvcXVhZGJhdGNoL1F1YWRCYXRjaCcpO1xyXG52YXIgUGFydGljbGVSZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3BhcnRpY2xlcmVuZGVyZXIvUGFydGljbGVSZW5kZXJlcicpO1xyXG52YXIgUmVzb3VyY2VNYW5hZ2VyID0gcmVxdWlyZSgnLi9SZXNvdXJjZU1hbmFnZXInKTtcclxudmFyIFJlc291cmNlcyA9IHJlcXVpcmUoJy4vcmVzb3VyY2VzJyk7XHJcbnZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vU2NhbGVNb2RlcycpO1xyXG52YXIgU2hhcGVCYXRjaCA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3NoYXBlYmF0Y2gvU2hhcGVCYXRjaCcpO1xyXG52YXIgU3ByaXRlQmF0Y2ggPSByZXF1aXJlKCcuL3JlbmRlcmVycy9zcHJpdGViYXRjaC9TcHJpdGVCYXRjaCcpO1xyXG52YXIgVGlsZUJhdGNoID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvdGlsZWJhdGNoL1RpbGVCYXRjaCcpO1xyXG52YXIgVGlsZW1hcFJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvdGlsZW1hcHJlbmRlcmVyL1RpbGVtYXBSZW5kZXJlcicpO1xyXG52YXIgV2ViR0xTbmFwc2hvdCA9IHJlcXVpcmUoJy4uL3NuYXBzaG90L1dlYkdMU25hcHNob3QnKTtcclxuXHJcbnZhciBXZWJHTFJlbmRlcmVyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIgKGdhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgIHRoaXMub25Db250ZXh0TG9zdENhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMub25Db250ZXh0UmVzdG9yZWRDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBDT05TVC5XRUJHTDtcclxuICAgICAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xyXG4gICAgICAgIHRoaXMudmlldy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gX3RoaXMub25Db250ZXh0TG9zdENhbGxiYWNrcztcclxuICAgICAgICAgICAgdmFyIHJlbmRlcmVycyA9IF90aGlzLnJlbmRlcmVyQXJyYXk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCByZW5kZXJlcnMubGVuZ3RoOyArK2luZGV4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlcnNbaW5kZXhdLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5jb250ZXh0TG9zdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjYWxsYmFja3MubGVuZ3RoOyArK2luZGV4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja3NbaW5kZXhdKF90aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHRoaXMudmlldy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IF90aGlzLm9uQ29udGV4dFJlc3RvcmVkQ2FsbGJhY2tzO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJlckFycmF5Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLnJlc291cmNlTWFuYWdlci5zaGFkZXJDYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5yZXNvdXJjZU1hbmFnZXIuc2hhZGVyQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5jb250ZXh0TG9zdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5pbml0KCk7XHJcbiAgICAgICAgICAgIF90aGlzLmdhbWUudGV4dHVyZXMuZWFjaChmdW5jdGlvbiAodGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0dXJlLnNvdXJjZS5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLnNvdXJjZVtpXS5pbml0KF90aGlzLmdhbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBudWxsKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNhbGxiYWNrcy5sZW5ndGg7ICsraW5kZXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpbmRleF0oX3RoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXHJcbiAgICAgICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgV2ViR0xDb250ZXh0T3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5jb250ZXh0TG9zdCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubWF4VGV4dHVyZXMgPSAxO1xyXG4gICAgICAgIHRoaXMubXVsdGlUZXh0dXJlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gbnVsbDtcclxuICAgICAgICB0aGlzLmV4dGVuc2lvbkxpc3QgPSB7fTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyQXJyYXkgPSBbXTtcclxuICAgICAgICB0aGlzLmJsaXR0ZXJCYXRjaCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hYVF1YWRCYXRjaCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVCYXRjaCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaGFwZUJhdGNoID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVmZmVjdFJlbmRlcmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyQ2FjaGUgPSB7fTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjayA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuc2Npc3NvciA9IHtcclxuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdsID0gdGhpcy52aWV3LmdldENvbnRleHQoJ3dlYmdsJywgdGhpcy5jb25maWcuV2ViR0xDb250ZXh0T3B0aW9ucykgfHwgdGhpcy52aWV3LmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHRoaXMuY29uZmlnLldlYkdMQ29udGV4dE9wdGlvbnMpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuZ2wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRMb3N0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJHTC4gVHJ5IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgIHRoaXMubG9zdENvbnRleHQgPSB0aGlzLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0Jyk7XHJcblxyXG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2FtZS5jb25maWcuYmFja2dyb3VuZENvbG9yO1xyXG5cclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IG5ldyBSZXNvdXJjZU1hbmFnZXIoZ2wpO1xyXG4gICAgXHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICBnbC5jbGVhckNvbG9yKGNvbG9yLnJlZEdMLCBjb2xvci5ncmVlbkdMLCBjb2xvci5ibHVlR0wsIGNvbG9yLmFscGhhR0wpO1xyXG5cclxuICAgICAgICAvLyAgTWFwIEJsZW5kIE1vZGVzXHJcblxyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlcyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAxNjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzLnB1c2goeyBmdW5jOiBbIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBIF0sIGVxdWF0aW9uOiBnbC5GVU5DX0FERCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBBZGRcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbMV0uZnVuYyA9IFsgZ2wuU1JDX0FMUEhBLCBnbC5EU1RfQUxQSEEgXTtcclxuXHJcbiAgICAgICAgLy8gIE11bHRpcGx5XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzWzJdLmZ1bmMgPSBbIGdsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSBdO1xyXG5cclxuICAgICAgICAvLyAgU2NyZWVuXHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzWzNdLmZ1bmMgPSBbIGdsLlNSQ19BTFBIQSwgZ2wuT05FIF07XHJcblxyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gLTE7XHJcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpO1xyXG4gICAgICAgIHRoaXMuYmxpdHRlckJhdGNoID0gdGhpcy5hZGRSZW5kZXJlcihuZXcgQmxpdHRlckJhdGNoKHRoaXMuZ2FtZSwgZ2wsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLnF1YWRCYXRjaCA9IHRoaXMuYWRkUmVuZGVyZXIobmV3IFF1YWRCYXRjaCh0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVCYXRjaCA9IHRoaXMuYWRkUmVuZGVyZXIobmV3IFNwcml0ZUJhdGNoKHRoaXMuZ2FtZSwgZ2wsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLnNoYXBlQmF0Y2ggPSB0aGlzLmFkZFJlbmRlcmVyKG5ldyBTaGFwZUJhdGNoKHRoaXMuZ2FtZSwgZ2wsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLmVmZmVjdFJlbmRlcmVyID0gdGhpcy5hZGRSZW5kZXJlcihuZXcgRWZmZWN0UmVuZGVyZXIodGhpcy5nYW1lLCBnbCwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMudGlsZUJhdGNoID0gdGhpcy5hZGRSZW5kZXJlcihuZXcgVGlsZUJhdGNoKHRoaXMuZ2FtZSwgZ2wsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlciA9IHRoaXMuYWRkUmVuZGVyZXIobmV3IFRpbGVtYXBSZW5kZXJlcih0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVJlbmRlcmVyID0gdGhpcy5hZGRSZW5kZXJlcihuZXcgUGFydGljbGVSZW5kZXJlcih0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSB0aGlzLnNwcml0ZUJhdGNoO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFZlcnRleEJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoMCk7XHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViR0xSZW5kZXJpbmdDb250ZXh0L2JsZW5kRnVuY1xyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMUmVuZGVyaW5nQ29udGV4dC9ibGVuZEZ1bmNTZXBhcmF0ZVxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMUmVuZGVyaW5nQ29udGV4dC9ibGVuZEVxdWF0aW9uXHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViR0xSZW5kZXJpbmdDb250ZXh0L2JsZW5kRXF1YXRpb25TZXBhcmF0ZVxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMUmVuZGVyaW5nQ29udGV4dC9ibGVuZENvbG9yXHJcbiAgICBhZGRCbGVuZE1vZGU6IGZ1bmN0aW9uIChmdW5jLCBlcXVhdGlvbilcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmJsZW5kTW9kZXMucHVzaCh7IGZ1bmM6IGZ1bmMsIGVxdWF0aW9uOiBlcXVhdGlvbiB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGluZGV4IC0gMTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlQmxlbmRNb2RlOiBmdW5jdGlvbiAoaW5kZXgsIGZ1bmMsIGVxdWF0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmJsZW5kTW9kZXNbaW5kZXhdKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW2luZGV4XS5mdW5jID0gZnVuYztcclxuXHJcbiAgICAgICAgICAgIGlmIChlcXVhdGlvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW2luZGV4XS5lcXVhdGlvbiA9IGVxdWF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQmxlbmRNb2RlOiBmdW5jdGlvbiAoaW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gMTYgJiYgdGhpcy5ibGVuZE1vZGVzW2luZGV4XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEV4dGVuc2lvbjogZnVuY3Rpb24gKG5hbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCEobmFtZSBpbiB0aGlzLmV4dGVuc2lvbkxpc3QpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25MaXN0W25hbWVdID0gdGhpcy5nbC5nZXRFeHRlbnNpb24obmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbkxpc3RbbmFtZV07XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZENvbnRleHRMb3N0Q2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5vbkNvbnRleHRMb3N0Q2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMub25Db250ZXh0TG9zdENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZENvbnRleHRSZXN0b3JlZENhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMub25Db250ZXh0UmVzdG9yZWRDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5vbkNvbnRleHRSZXN0b3JlZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVRleHR1cmU6IGZ1bmN0aW9uIChzb3VyY2UsIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgd2lkdGggPSBzb3VyY2UgPyBzb3VyY2Uud2lkdGggOiB3aWR0aDtcclxuICAgICAgICBoZWlnaHQgPSBzb3VyY2UgPyBzb3VyY2UuaGVpZ2h0IDogaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBnbC5ORUFSRVNUO1xyXG4gICAgICAgIHZhciB3cmFwID0gSXNTaXplUG93ZXJPZlR3byh3aWR0aCwgaGVpZ2h0KSA/IGdsLlJFUEVBVCA6IGdsLkNMQU1QX1RPX0VER0U7XHJcblxyXG4gICAgICAgIGlmICghc291cmNlLmdsVGV4dHVyZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2Uuc2NhbGVNb2RlID09PSBTY2FsZU1vZGVzLkxJTkVBUilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyID0gZ2wuTElORUFSO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZS5zY2FsZU1vZGUgPT09IFNjYWxlTW9kZXMuTkVBUkVTVCB8fCB0aGlzLmdhbWUuY29uZmlnLnBpeGVsQXJ0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBnbC5ORUFSRVNUO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNvdXJjZSAmJiB0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHR5cGVvZiBoZWlnaHQgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuZ2xUZXh0dXJlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlVGV4dHVyZShcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcCxcclxuICAgICAgICAgICAgICAgICAgICB3cmFwLFxyXG4gICAgICAgICAgICAgICAgICAgIGdsLlJHQkEsXHJcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc291cmNlLmdsVGV4dHVyZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVRleHR1cmUoXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHdyYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcCxcclxuICAgICAgICAgICAgICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5pbWFnZVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZVswXSA9IG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmU6IGZ1bmN0aW9uICh0ZXh0dXJlLCB1bml0KVxyXG4gICAge1xyXG4gICAgICAgIHVuaXQgPSB1bml0IHx8IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFRleHR1cmVbdW5pdF0gIT09IHRleHR1cmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB1bml0KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlICE9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLnRleHR1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHR1cmVbdW5pdF0gPSB0ZXh0dXJlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChyZW5kZXJlciwgdGV4dHVyZSwgcmVuZGVyVGFyZ2V0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZSh0ZXh0dXJlKTtcclxuICAgICAgICB0aGlzLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXIgfHwgdGhpcy5jdXJyZW50UmVuZGVyZXIuc2hvdWxkRmx1c2goKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSZW5kZXJUYXJnZXQ6IGZ1bmN0aW9uIChyZW5kZXJUYXJnZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlbmRlclRhcmdldCAhPT0gcmVuZGVyVGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZW5kZXJUYXJnZXQgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0LmZyYW1lYnVmZmVyT2JqZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyVGFyZ2V0LnNob3VsZENsZWFyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgcmVuZGVyVGFyZ2V0LmNsZWFyQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldC5zaG91bGRDbGVhciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlc29sdXRpb247XHJcblxyXG4gICAgICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hdXRvUmVzaXplKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLndpZHRoID0gKHRoaXMud2lkdGggLyByZXNvbHV0aW9uKSArICdweCc7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgLyByZXNvbHV0aW9uKSArICdweCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnJlbmRlcmVyQXJyYXkubGVuZ3RoOyBpIDwgbDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlckFycmF5W2ldLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlckFycmF5W2ldLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLmJpbmQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGwgYXQgdGhlIHN0YXJ0IG9mIHRoZSByZW5kZXIgbG9vcFxyXG4gICAgcHJlUmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBObyBwb2ludCByZW5kZXJpbmcgaWYgb3VyIGNvbnRleHQgaGFzIGJlZW4gYmxvd24gdXAhXHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dExvc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNldFJlbmRlclRhcmdldChudWxsKTtcclxuICAgICAgICAvLyAgQWRkIFByZS1yZW5kZXIgaG9va1xyXG5cclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2FtZS5jb25maWcuYmFja2dyb3VuZENvbG9yO1xyXG5cclxuICAgICAgICBnbC5jbGVhckNvbG9yKGNvbG9yLnJlZEdMLCBjb2xvci5ncmVlbkdMLCBjb2xvci5ibHVlR0wsIGNvbG9yLmFscGhhR0wpO1xyXG5cclxuICAgICAgICAvLyBTb21lIGRyaXZlcnMgcmVxdWlyZSB0byBjYWxsIGdsQ2xlYXJcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKEJsZW5kTW9kZXMuTk9STUFMKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgc2luZ2xlIFNjZW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5TY2VuZX0gc2NlbmUgLSBUaGUgU2NlbmUgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UgLSBUaGUgY3VtdWxhdGl2ZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhc24ndCBiZWVuIHNpbXVsYXRlZCB5ZXQsIGRpdmlkZWRcclxuICAgICAqICAgYnkgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgd2lsbCBiZSBzaW11bGF0ZWQgdGhlIG5leHQgdGltZSB1cGRhdGUoKVxyXG4gICAgICogICBydW5zLiBVc2VmdWwgZm9yIGludGVycG9sYXRpbmcgZnJhbWVzLlxyXG4gICAgICovXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChzY2VuZSwgY2hpbGRyZW4sIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dExvc3QpIHJldHVybjtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBxdWFkQmF0Y2ggPSB0aGlzLnF1YWRCYXRjaDtcclxuXHJcbiAgICAgICAgdGhpcy5zY2lzc29yLmVuYWJsZWQgPSAoY2FtZXJhLnggIT09IDAgfHwgY2FtZXJhLnkgIT09IDAgfHwgY2FtZXJhLndpZHRoICE9PSBnbC5jYW52YXMud2lkdGggfHwgY2FtZXJhLmhlaWdodCAhPT0gZ2wuY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zY2lzc29yLmVuYWJsZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2Npc3Nvci54ID0gY2FtZXJhLng7XHJcbiAgICAgICAgICAgIHRoaXMuc2Npc3Nvci55ID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAtIGNhbWVyYS55IC0gY2FtZXJhLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5zY2lzc29yLndpZHRoID0gY2FtZXJhLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLnNjaXNzb3IuaGVpZ2h0ID0gY2FtZXJhLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGdsLnNjaXNzb3IodGhpcy5zY2lzc29yLngsIHRoaXMuc2Npc3Nvci55LCB0aGlzLnNjaXNzb3Iud2lkdGgsIHRoaXMuc2Npc3Nvci5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhbWVyYS5iYWNrZ3JvdW5kQ29sb3IuYWxwaGFHTCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjYW1lcmEuYmFja2dyb3VuZENvbG9yO1xyXG5cclxuICAgICAgICAgICAgcXVhZEJhdGNoLmJpbmQoKTtcclxuXHJcbiAgICAgICAgICAgIHF1YWRCYXRjaC5hZGQoXHJcbiAgICAgICAgICAgICAgICBjYW1lcmEueCwgY2FtZXJhLnksIGNhbWVyYS53aWR0aCwgY2FtZXJhLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIGNvbG9yLnJlZEdMLCBjb2xvci5ncmVlbkdMLCBjb2xvci5ibHVlR0wsIGNvbG9yLmFscGhhR0xcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHF1YWRCYXRjaC5mbHVzaCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxpc3QgPSBjaGlsZHJlbi5saXN0O1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgKytpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGxpc3RbaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0dGluZyBibGVuZCBtb2RlIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmN1cnJlbnRSZW5kZXJlcjtcclxuICAgICAgICAgICAgdmFyIG5ld0JsZW5kTW9kZSA9IGNoaWxkLmJsZW5kTW9kZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJsZW5kTW9kZSAhPT0gbmV3QmxlbmRNb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuZmx1c2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYmxlbmQgPSB0aGlzLmJsZW5kTW9kZXNbbmV3QmxlbmRNb2RlXS5mdW5jO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKHRoaXMuYmxlbmRNb2Rlc1tuZXdCbGVuZE1vZGVdLmVxdWF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYmxlbmQubGVuZ3RoID4gMilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShibGVuZFswXSwgYmxlbmRbMV0sIGJsZW5kWzJdLCBibGVuZFszXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGJsZW5kWzBdLCBibGVuZFsxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBuZXdCbGVuZE1vZGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRyYXdpbmcgY2hpbGRcclxuICAgICAgICAgICAgY2hpbGQucmVuZGVyV2ViR0wodGhpcywgY2hpbGQsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpO1xyXG5cclxuICAgICAgICAgICAgcmVuZGVyZXIgPSB0aGlzLmN1cnJlbnRSZW5kZXJlcjtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZW5kZXJlci5pc0Z1bGwoKSB8fCByZW5kZXJlci5zaG91bGRGbHVzaCgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5mbHVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNhbWVyYS5fZmFkZUFscGhhID4gMCB8fCBjYW1lcmEuX2ZsYXNoQWxwaGEgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XHJcblxyXG4gICAgICAgICAgICBxdWFkQmF0Y2guYmluZCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gZmFkZSByZW5kZXJpbmdcclxuICAgICAgICAgICAgcXVhZEJhdGNoLmFkZChcclxuICAgICAgICAgICAgICAgIGNhbWVyYS54LCBjYW1lcmEueSwgY2FtZXJhLndpZHRoLCBjYW1lcmEuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mYWRlUmVkLFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mYWRlR3JlZW4sXHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuX2ZhZGVCbHVlLFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mYWRlQWxwaGFcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGZsYXNoIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICBxdWFkQmF0Y2guYWRkKFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLngsIGNhbWVyYS55LCBjYW1lcmEud2lkdGgsIGNhbWVyYS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuX2ZsYXNoUmVkLFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaEdyZWVuLFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaEJsdWUsXHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuX2ZsYXNoQWxwaGFcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHF1YWRCYXRjaC5mbHVzaCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2Npc3Nvci5lbmFibGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGxlZCBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXIgbG9vcCAodGlkeSB0aGluZ3MgdXAsIGV0YylcclxuICAgIHBvc3RSZW5kZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dExvc3QpIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc25hcHNob3RDYWxsYmFjaylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjayhXZWJHTFNuYXBzaG90KHRoaXMudmlldykpO1xyXG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEFkZCBQb3N0LXJlbmRlciBob29rXHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCclYyByZW5kZXIgZW5kICcsICdjb2xvcjogI2ZmZmZmZjsgYmFja2dyb3VuZDogI2ZmMDAwMDsnKTtcclxuICAgIH0sXHJcblxyXG4gICAgc25hcHNob3Q6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlRkJPOiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcbiAgICBzZXRCbGVuZE1vZGU6IGZ1bmN0aW9uIChuZXdCbGVuZE1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmN1cnJlbnRSZW5kZXJlcjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYmxlbmRNb2RlICE9PSBuZXdCbGVuZE1vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBibGVuZCA9IHRoaXMuYmxlbmRNb2Rlc1tuZXdCbGVuZE1vZGVdLmZ1bmM7XHJcblxyXG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKHRoaXMuYmxlbmRNb2Rlc1tuZXdCbGVuZE1vZGVdLmVxdWF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChibGVuZC5sZW5ndGggPiAyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShibGVuZFswXSwgYmxlbmRbMV0sIGJsZW5kWzJdLCBibGVuZFszXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoYmxlbmRbMF0sIGJsZW5kWzFdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBuZXdCbGVuZE1vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRSZW5kZXJlcjogZnVuY3Rpb24gKHJlbmRlcmVySW5zdGFuY2UpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5yZW5kZXJlckFycmF5LmluZGV4T2YocmVuZGVyZXJJbnN0YW5jZSk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyQXJyYXkucHVzaChyZW5kZXJlckluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVySW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dHVyZUZpbHRlck1vZGU6IGZ1bmN0aW9uICh0ZXh0dXJlLCBmaWx0ZXJNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgdmFyIGdsRmlsdGVyID0gWyBnbC5MSU5FQVIsIGdsLk5FQVJFU1QgXVtmaWx0ZXJNb2RlXTtcclxuXHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS50ZXh0dXJlKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xGaWx0ZXIpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbEZpbHRlcik7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRUZXh0dXJlWzBdICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5jdXJyZW50VGV4dHVyZVswXS50ZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBsb2FkQ2FudmFzVG9HUFU6IGZ1bmN0aW9uIChzcmNDYW52YXMsIGRzdFRleHR1cmUsIHNob3VsZFJlYWxsb2NhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgICAgaWYgKCFkc3RUZXh0dXJlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZHN0VGV4dHVyZSA9IG5ldyBSZXNvdXJjZXMuVGV4dHVyZShudWxsLCAwLCAwKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBPbmx5IGNhbGwgdGhpcyBvbmNlXHJcbiAgICAgICAgICAgIGRzdFRleHR1cmUudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkc3RUZXh0dXJlICE9IHRoaXMuY3VycmVudFRleHR1cmVbMF0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XHJcblxyXG4gICAgICAgIGlmICghc2hvdWxkUmVhbGxvY2F0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBVcGRhdGUgcmVzb3VyY2VcclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZHN0VGV4dHVyZS50ZXh0dXJlKTtcclxuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBzcmNDYW52YXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQWxsb2NhdGUgb3IgUmVhbGxvY2F0ZSByZXNvdXJjZVxyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBkc3RUZXh0dXJlLnRleHR1cmUpO1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHNyY0NhbnZhcyk7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICBkc3RUZXh0dXJlLndpZHRoID0gc3JjQ2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICBkc3RUZXh0dXJlLmhlaWdodCA9IHNyY0NhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgV2UgbXVzdCByZWJpbmQgb2xkIHRleHR1cmVcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VGV4dHVyZS5sZW5ndGggPiAwICYmIGRzdFRleHR1cmUgIT0gdGhpcy5jdXJyZW50VGV4dHVyZVswXSAmJiB0aGlzLmN1cnJlbnRUZXh0dXJlWzBdICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5jdXJyZW50VGV4dHVyZVswXS50ZXh0dXJlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkc3RUZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmxvc3RDb250ZXh0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5sb3N0Q29udGV4dC5sb3NlQ29udGV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdsID0gbnVsbDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBEYXRhQnVmZmVyMTYgPSByZXF1aXJlKCcuLi8uLi91dGlscy9EYXRhQnVmZmVyMTYnKTtcclxudmFyIERhdGFCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIzMicpO1xyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIFRleHR1cmVkQW5kQWxwaGFTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi9zaGFkZXJzL1RleHR1cmVkQW5kQWxwaGFTaGFkZXInKTtcclxuXHJcbnZhciBCbGl0dGVyQmF0Y2ggPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQmxpdHRlckJhdGNoIChnYW1lLCBnbCwgbWFuYWdlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuICAgICAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICAgICAgdGhpcy5tYXhQYXJ0aWNsZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFRleHR1cmUyRCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSBudWxsO1xyXG5cclxuICAgICAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXHJcbiAgICAgICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgV2ViR0xDb250ZXh0T3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdCh0aGlzLmdsQ29udGV4dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChnbClcclxuICAgIHtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBEYXRhQnVmZmVyMzIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5QQVJUSUNMRV9WRVJURVhfQ09VTlQgKiBDT05TVC5NQVhfUEFSVElDTEVTKTtcclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIxNihDT05TVC5JTkRFWF9TSVpFICogQ09OU1QuUEFSVElDTEVfSU5ERVhfQ09VTlQgKiBDT05TVC5NQVhfUEFSVElDTEVTKTtcclxuICAgICAgICB2YXIgc2hhZGVyID0gdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5jcmVhdGVTaGFkZXIoJ1RleHR1cmVkQW5kQWxwaGFTaGFkZXInLCBUZXh0dXJlZEFuZEFscGhhU2hhZGVyKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXJPYmplY3QgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdCA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSwgZ2wuU1RSRUFNX0RSQVcpO1xyXG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBzaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3ZpZXdfbWF0cml4Jyk7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciBtYXggPSBDT05TVC5NQVhfUEFSVElDTEVTICogQ09OU1QuUEFSVElDTEVfSU5ERVhfQ09VTlQ7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX3Bvc2l0aW9uJyksIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDApO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX3RleF9jb29yZCcpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCA4KTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3QuYWRkQXR0cmlidXRlKHNoYWRlci5nZXRBdHRyaWJMb2NhdGlvbignYV9hbHBoYScpLCAxLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAxNik7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBpbmRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0ID0gdmVydGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gdmlld01hdHJpeExvY2F0aW9uO1xyXG4gICAgICAgIHRoaXMubWF4UGFydGljbGVzID0gbWF4O1xyXG5cclxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULlBBUlRJQ0xFX0lOREVYX0NPVU5ULCBpbmRleEIgKz0gQ09OU1QuUEFSVElDTEVfVkVSVEVYX0NPVU5UKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMF0gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAxXSA9IGluZGV4QiArIDE7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDJdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgM10gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA0XSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDVdID0gaW5kZXhCICsgMztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluZGV4QnVmZmVyT2JqZWN0LnVwZGF0ZVJlc291cmNlKGluZGV4QnVmZmVyLCAwKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIHNob3VsZEZsdXNoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgaXNGdWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVMZW5ndGgoKSA+PSB0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBiaW5kOiBmdW5jdGlvbiAoc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChzaGFkZXIgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyLmJpbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2hhZGVyLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbiwgc2hhZGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QuYmluZCgpO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0LmJpbmQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmx1c2g6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRDb3VudCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5iaW5kKHNoYWRlcik7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QudXBkYXRlUmVzb3VyY2UodmVydGV4RGF0YUJ1ZmZlci5nZXRVc2VkQnVmZmVyQXNGbG9hdCgpLCAwKTtcclxuXHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5lbGVtZW50Q291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuXHJcbiAgICAgICAgdmVydGV4RGF0YUJ1ZmZlci5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24sIHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICB2YXIgYWN0aXZlU2hhZGVyID0gc2hhZGVyICE9PSB1bmRlZmluZWQgPyBzaGFkZXIgOiB0aGlzLnNoYWRlcjtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgYWN0aXZlU2hhZGVyLnNldENvbnN0YW50TWF0cml4NHg0KFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbixcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy5oZWlnaHQsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuZGVsZXRlU2hhZGVyKHRoaXMuc2hhZGVyKTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxpdHRlckJhdGNoO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9ibGl0dGVyYmF0Y2gvQmxpdHRlckJhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA4OTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0ge1xyXG5cclxuICAgIC8vIFZFUlRFWF9TSVpFID0gc2l6ZW9mKHZlYzIpICsgc2l6ZW9mKHZlYzIpICsgc2l6ZW9mKGZsb2F0KVxyXG4gICAgVkVSVEVYX1NJWkU6IDIwLFxyXG4gICAgSU5ERVhfU0laRTogMixcclxuICAgIFBBUlRJQ0xFX1ZFUlRFWF9DT1VOVDogNCxcclxuICAgIFBBUlRJQ0xFX0lOREVYX0NPVU5UOiA2LFxyXG5cclxuICAgIC8vIEhvdyBtYW55IDMyLWJpdCBjb21wb25lbnRzIGRvZXMgdGhlIHZlcnRleCBoYXZlLlxyXG4gICAgUEFSVElDTEVfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVDogNSxcclxuXHJcbiAgICAvLyBDYW4ndCBiZSBiaWdnZXIgdGhhbiAxMCwwMDAgc2luY2UgaW5kZXggYXJlIDE2LWJpdFxyXG4gICAgTUFYX1BBUlRJQ0xFUzogMjAwMCxcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9ibGl0dGVyYmF0Y2gvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDg5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBEYXRhQnVmZmVyMTYgPSByZXF1aXJlKCcuLi8uLi91dGlscy9EYXRhQnVmZmVyMTYnKTtcclxudmFyIERhdGFCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIzMicpO1xyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3NoYWRlcnMvVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyJyk7XHJcbnZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xyXG5cclxudmFyIEVmZmVjdFJlbmRlcmVyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEVmZmVjdFJlbmRlcmVyIChnYW1lLCBnbCwgbWFuYWdlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuICAgICAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICAgICAgdGhpcy5tYXhTcHJpdGVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRlbXBNYXRyaXggPSBuZXcgVHJhbnNmb3JtTWF0cml4KCk7XHJcblxyXG4gICAgICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0KHRoaXMuZ2xDb250ZXh0KTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGdsKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIzMihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULlFVQURfVkVSVEVYX0NPVU5UICogQ09OU1QuTUFYX1FVQURTKTtcclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIxNihDT05TVC5JTkRFWF9TSVpFICogQ09OU1QuUVVBRF9JTkRFWF9DT1VOVCAqIENPTlNULk1BWF9RVUFEUyk7XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlU2hhZGVyKCdUZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXInLCBUZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIpO1xyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlck9iamVjdCA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCksIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0ID0gdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpLCBnbC5TVFJFQU1fRFJBVyk7XHJcbiAgICAgICAgdmFyIHZpZXdNYXRyaXhMb2NhdGlvbiA9IHNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3Vfdmlld19tYXRyaXgnKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBpbmRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9RVUFEUyAqIENPTlNULlFVQURfSU5ERVhfQ09VTlQ7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBpbmRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0ID0gdmVydGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gdmlld01hdHJpeExvY2F0aW9uO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3QuYWRkQXR0cmlidXRlKHNoYWRlci5nZXRBdHRyaWJMb2NhdGlvbignYV9wb3NpdGlvbicpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAwKTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3QuYWRkQXR0cmlidXRlKHNoYWRlci5nZXRBdHRyaWJMb2NhdGlvbignYV90ZXhfY29vcmQnKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgOCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfY29sb3InKSwgMywgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDE2KTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3QuYWRkQXR0cmlidXRlKHNoYWRlci5nZXRBdHRyaWJMb2NhdGlvbignYV9hbHBoYScpLCAxLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAyMCk7XHJcblxyXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBpbmRleCBidWZmZXIgb25seSBvbmNlXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXhBID0gMCwgaW5kZXhCID0gMDsgaW5kZXhBIDwgbWF4OyBpbmRleEEgKz0gQ09OU1QuUVVBRF9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULlFVQURfVkVSVEVYX0NPVU5UKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMF0gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAxXSA9IGluZGV4QiArIDE7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDJdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgM10gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA0XSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDVdID0gaW5kZXhCICsgMztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluZGV4QnVmZmVyT2JqZWN0LnVwZGF0ZVJlc291cmNlKGluZGV4QnVmZmVyLCAwKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbik7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzaG91bGRGbHVzaDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlTGVuZ3RoKCkgPj0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoc2hhZGVyID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlci5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNoYWRlci5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24sIHNoYWRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0LmJpbmQoKTtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50Q291bnQgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuYmluZChzaGFkZXIpO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0LnVwZGF0ZVJlc291cmNlKHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSwgMCk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuZWxlbWVudENvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcblxyXG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uLCBzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFjdGl2ZVNoYWRlciA9IHNoYWRlciAhPT0gdW5kZWZpbmVkID8gc2hhZGVyIDogdGhpcy5zaGFkZXI7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXNvbHV0aW9uO1xyXG5cclxuICAgICAgICBhY3RpdmVTaGFkZXIuc2V0Q29uc3RhbnRNYXRyaXg0eDQoXHJcbiAgICAgICAgICAgIGFjdGl2ZVNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3Vfdmlld19tYXRyaXgnKSxcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy5oZWlnaHQsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXJFZmZlY3Q6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjYW1lcmEsIHRleHR1cmUsIHRleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgdGVtcE1hdHJpeCA9IHRoaXMudGVtcE1hdHJpeDtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0RjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdFUzMiA9IHZlcnRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGV4dHVyZVdpZHRoICogKGdhbWVPYmplY3QuZmxpcFggPyAtMSA6IDEpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0dXJlSGVpZ2h0ICogKGdhbWVPYmplY3QuZmxpcFkgPyAtMSA6IDEpO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gZ2FtZU9iamVjdC54IC0gY2FtZXJhLnNjcm9sbFggKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclg7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICB2YXIgc2NhbGVYID0gZ2FtZU9iamVjdC5zY2FsZVg7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IGdhbWVPYmplY3Quc2NhbGVZO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1nYW1lT2JqZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4TWF0cml4ID0gdGVtcE1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIHggPSAtZ2FtZU9iamVjdC5kaXNwbGF5T3JpZ2luWCArICgodGV4dHVyZVdpZHRoKSAqIChnYW1lT2JqZWN0LmZsaXBYID8gMSA6IDAuMCkpO1xyXG4gICAgICAgIHZhciB5ID0gLWdhbWVPYmplY3QuZGlzcGxheU9yaWdpblkgKyAoKHRleHR1cmVIZWlnaHQpICogKGdhbWVPYmplY3QuZmxpcFkgPyAxIDogMC4wKSk7XHJcbiAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xyXG4gICAgICAgIHZhciB5aCA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgICAgICB2YXIgc3JhLCBzcmIsIHNyYywgc3JkLCBzcmUsIHNyZiwgY21hLCBjbWIsIGNtYywgY21kLCBjbWUsIGNtZjtcclxuICAgICAgICB2YXIgYWxwaGEgPSBnYW1lT2JqZWN0LmFscGhhO1xyXG4gICAgICAgIHZhciB0aW50VEwgPSBnYW1lT2JqZWN0Ll90aW50VEw7XHJcbiAgICAgICAgdmFyIHRpbnRUUiA9IGdhbWVPYmplY3QuX3RpbnRUUjtcclxuICAgICAgICB2YXIgdGludEJMID0gZ2FtZU9iamVjdC5fdGludEJMO1xyXG4gICAgICAgIHZhciB0aW50QlIgPSBnYW1lT2JqZWN0Ll90aW50QlI7XHJcblxyXG4gICAgICAgIHRlbXBNYXRyaXguYXBwbHlJVFJTKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSk7XHJcblxyXG4gICAgICAgIHNyYSA9IHRlbXBNYXRyaXhNYXRyaXhbMF07XHJcbiAgICAgICAgc3JiID0gdGVtcE1hdHJpeE1hdHJpeFsxXTtcclxuICAgICAgICBzcmMgPSB0ZW1wTWF0cml4TWF0cml4WzJdO1xyXG4gICAgICAgIHNyZCA9IHRlbXBNYXRyaXhNYXRyaXhbM107XHJcbiAgICAgICAgc3JlID0gdGVtcE1hdHJpeE1hdHJpeFs0XTtcclxuICAgICAgICBzcmYgPSB0ZW1wTWF0cml4TWF0cml4WzVdO1xyXG5cclxuICAgICAgICBjbWEgPSBjYW1lcmFNYXRyaXhbMF07XHJcbiAgICAgICAgY21iID0gY2FtZXJhTWF0cml4WzFdO1xyXG4gICAgICAgIGNtYyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgICAgICBjbWQgPSBjYW1lcmFNYXRyaXhbM107XHJcbiAgICAgICAgY21lID0gY2FtZXJhTWF0cml4WzRdO1xyXG4gICAgICAgIGNtZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgbXZhID0gc3JhICogY21hICsgc3JiICogY21jO1xyXG4gICAgICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcclxuICAgICAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XHJcbiAgICAgICAgbXZkID0gc3JjICogY21iICsgc3JkICogY21kO1xyXG4gICAgICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcclxuICAgICAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHgwID0geCAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkwID0geCAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgxID0geCAqIG12YSArIHloICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MSA9IHggKiBtdmIgKyB5aCAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDIgPSB4dyAqIG12YSArIHloICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MiA9IHh3ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgzID0geHcgKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MyA9IHh3ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNldFJlbmRlcmVyKHRoaXMsIHRleHR1cmUsIGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCArPSA2O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vICBUb3AgTGVmdFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gMDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gMDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludFRMO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgLy8gIEJvdHRvbSBMZWZ0XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50Qkw7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICAvLyAgQm90dG9tIFJpZ2h0XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50QlI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICAvLyAgVG9wIFJpZ2h0XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50VFI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB0aGlzLmZsdXNoKGdhbWVPYmplY3QuZHN0U2hhZGVyKTtcclxuXHJcbiAgICAgICAgZ2FtZU9iamVjdC5kc3RSZW5kZXJUYXJnZXQuc2hvdWxkQ2xlYXIgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuZGVsZXRlU2hhZGVyKHRoaXMuc2hhZGVyKTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRWZmZWN0UmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL2VmZmVjdHJlbmRlcmVyL0VmZmVjdFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4OTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0ge1xyXG5cclxuICAgIC8vIFZFUlRFWF9TSVpFID0gKHNpemVvZih2ZWMyKSAqIDQpICsgKHNpemVvZihmbG9hdCkgKyBzaXplb2YodWludDMyKSlcclxuICAgIFZFUlRFWF9TSVpFOiAyNCxcclxuICAgIElOREVYX1NJWkU6IDIsXHJcbiAgICBRVUFEX1ZFUlRFWF9DT1VOVDogNCxcclxuICAgIFFVQURfSU5ERVhfQ09VTlQ6IDYsXHJcblxyXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXHJcbiAgICBRVUFEX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDYsXHJcblxyXG4gICAgLy8gQ2FuJ3QgYmUgYmlnZ2VyIHNpbmNlIGluZGV4IGFyZSAxNi1iaXRcclxuICAgIE1BWF9RVUFEUzogMlxyXG4gICAgXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9lZmZlY3RyZW5kZXJlci9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gOTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIERhdGFCdWZmZXIxNiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIxNicpO1xyXG52YXIgRGF0YUJ1ZmZlcjMyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvRGF0YUJ1ZmZlcjMyJyk7XHJcbnZhciBQSEFTRVJfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25zdCcpO1xyXG52YXIgUGFydGljbGVTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi9zaGFkZXJzL1BhcnRpY2xlU2hhZGVyJyk7XHJcbnZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xyXG5cclxudmFyIFBhcnRpY2xlUmVuZGVyZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gUGFydGljbGVSZW5kZXJlciAoZ2FtZSwgZ2wsIG1hbmFnZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBQSEFTRVJfQ09OU1QuV0VCR0w7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmdsQ29udGV4dCA9IGdsO1xyXG4gICAgICAgIHRoaXMubWF4U3ByaXRlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZW1wTWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG5cclxuICAgICAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXHJcbiAgICAgICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgV2ViR0xDb250ZXh0T3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdCh0aGlzLmdsQ29udGV4dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChnbClcclxuICAgIHtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBEYXRhQnVmZmVyMzIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5WRVJURVhfQ09VTlQgKiBDT05TVC5NQVgpO1xyXG4gICAgICAgIHZhciBpbmRleERhdGFCdWZmZXIgPSBuZXcgRGF0YUJ1ZmZlcjE2KENPTlNULklOREVYX1NJWkUgKiBDT05TVC5JTkRFWF9DT1VOVCAqIENPTlNULk1BWCk7XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlU2hhZGVyKCdQYXJ0aWNsZVNoYWRlcicsIFBhcnRpY2xlU2hhZGVyKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXJPYmplY3QgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdCA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSwgZ2wuU1RSRUFNX0RSQVcpO1xyXG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBzaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3ZpZXdfbWF0cml4Jyk7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciBtYXggPSBDT05TVC5NQVggKiBDT05TVC5JTkRFWF9DT1VOVDtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gaW5kZXhCdWZmZXJPYmplY3Q7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSB2ZXJ0ZXhCdWZmZXJPYmplY3Q7XHJcbiAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSB2aWV3TWF0cml4TG9jYXRpb247XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX3Bvc2l0aW9uJyksIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDApO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX3RleF9jb29yZCcpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCA4KTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3QuYWRkQXR0cmlidXRlKHNoYWRlci5nZXRBdHRyaWJMb2NhdGlvbignYV9jb2xvcicpLCA0LCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCBDT05TVC5WRVJURVhfU0laRSwgMTYpO1xyXG5cclxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULklOREVYX0NPVU5ULCBpbmRleEIgKz0gQ09OU1QuVkVSVEVYX0NPVU5UKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMF0gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAxXSA9IGluZGV4QiArIDE7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDJdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgM10gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA0XSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDVdID0gaW5kZXhCICsgMztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluZGV4QnVmZmVyT2JqZWN0LnVwZGF0ZVJlc291cmNlKGluZGV4QnVmZmVyLCAwKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIHNob3VsZEZsdXNoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzRnVsbCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNoYWRlciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uLCBzaGFkZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QuYmluZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmbHVzaDogZnVuY3Rpb24gKHNoYWRlciwgcmVuZGVyVGFyZ2V0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50Q291bnQgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChyZW5kZXJUYXJnZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJpbmQoc2hhZGVyKTtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC51cGRhdGVSZXNvdXJjZSh2ZXJ0ZXhEYXRhQnVmZmVyLmdldFVzZWRCdWZmZXJBc0Zsb2F0KCksIDApO1xyXG5cclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmVsZW1lbnRDb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG5cclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICAgICAgdmVydGV4RGF0YUJ1ZmZlci5jbGVhcigpO1xyXG5cclxuICAgICAgICBpZiAocmVuZGVyVGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24sIHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICB2YXIgYWN0aXZlU2hhZGVyID0gKHNoYWRlciAhPT0gdW5kZWZpbmVkKSA/IHNoYWRlciA6IHRoaXMuc2hhZGVyO1xyXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IChhY3RpdmVTaGFkZXIgPT09IHRoaXMuc2hhZGVyKSA/IHRoaXMudmlld01hdHJpeExvY2F0aW9uIDogYWN0aXZlU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndV92aWV3X21hdHJpeCcpO1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLnNldFByb2plY3Rpb25NYXRyaXgoYWN0aXZlU2hhZGVyLCBsb2NhdGlvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uIChzaGFkZXIsIGxvY2F0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHNoYWRlci5zZXRDb25zdGFudE1hdHJpeDR4NChcclxuICAgICAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMud2lkdGgsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAtMiAvIHRoaXMuaGVpZ2h0LCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZVNoYWRlcih0aGlzLnNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXJFbWl0dGVyOiBmdW5jdGlvbiAoZW1pdHRlciwgY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYXJ0aWNsZXMgPSBlbWl0dGVyLmFsaXZlO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWNsZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBmcmFtZSA9IGVtaXR0ZXIuZnJhbWU7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZiRjMyID0gZGF0YS5mbG9hdFZpZXc7XHJcbiAgICAgICAgdmFyIHZiVTMyID0gZGF0YS51aW50VmlldztcclxuICAgICAgICB2YXIgdnR4T2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgd2lkdGggPSBmcmFtZS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjYW1lcmFNYXRyaXggPSBjYW1lcmEubWF0cml4Lm1hdHJpeDtcclxuICAgICAgICB2YXIgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgICAgIHZhciBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICAgICAgdmFyIGNtYyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgICAgICB2YXIgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgICAgIHZhciBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICAgICAgdmFyIGNtZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuICAgICAgICB2YXIgZWxlbWVudENvdW50ID0gdGhpcy5lbGVtZW50Q291bnQ7XHJcbiAgICAgICAgdmFyIHV2cyA9IGZyYW1lLnV2cztcclxuICAgICAgICB2YXIgdTAgPSB1dnMueDA7XHJcbiAgICAgICAgdmFyIHYwID0gdXZzLnkwO1xyXG4gICAgICAgIHZhciB1MSA9IHV2cy54MTtcclxuICAgICAgICB2YXIgdjEgPSB1dnMueTE7XHJcbiAgICAgICAgdmFyIHUyID0gdXZzLngyO1xyXG4gICAgICAgIHZhciB2MiA9IHV2cy55MjtcclxuICAgICAgICB2YXIgdTMgPSB1dnMueDM7XHJcbiAgICAgICAgdmFyIHYzID0gdXZzLnkzO1xyXG4gICAgICAgIHZhciBveCA9IHdpZHRoICogMC41O1xyXG4gICAgICAgIHZhciBveSA9IGhlaWdodCAqIDAuNTtcclxuICAgICAgICB2YXIgcGFydGljbGVDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIGJhdGNoQ291bnQgPSBNYXRoLmNlaWwobGVuZ3RoIC8gQ09OU1QuTUFYKTtcclxuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZW1pdHRlci5yZW5kZXJUYXJnZXQ7XHJcbiAgICAgICAgdmFyIHRlbXBNYXRyaXggPSB0aGlzLnRlbXBNYXRyaXg7XHJcbiAgICAgICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgICAgICB2YXIgcGFydGljbGVPZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRSZW5kZXJlcih0aGlzLCBmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlLCBlbWl0dGVyLnJlbmRlclRhcmdldCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGJhdGNoSW5kZXggPSAwOyBiYXRjaEluZGV4IDwgYmF0Y2hDb3VudDsgKytiYXRjaEluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IE1hdGgubWluKGxlbmd0aCwgQ09OU1QuTUFYKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGJhdGNoU2l6ZTsgKytpbmRleClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpY2xlID0gcGFydGljbGVzW3BhcnRpY2xlT2Zmc2V0ICsgaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSAtb3g7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IC1veTtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZVggPSBwYXJ0aWNsZS5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVZID0gcGFydGljbGUuc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gcGFydGljbGUucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBwYXJ0aWNsZS5jb2xvcjtcclxuICAgICAgICAgICAgICAgIHZhciB4dyA9IHggKyB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciB5aCA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRlbXBNYXRyaXguYXBwbHlJVFJTKHBhcnRpY2xlLngsIHBhcnRpY2xlLnksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNyYSA9IHRlbXBNYXRyaXhNYXRyaXhbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3JiID0gdGVtcE1hdHJpeE1hdHJpeFsxXTtcclxuICAgICAgICAgICAgICAgIHZhciBzcmMgPSB0ZW1wTWF0cml4TWF0cml4WzJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNyZCA9IHRlbXBNYXRyaXhNYXRyaXhbM107XHJcbiAgICAgICAgICAgICAgICB2YXIgc3JlID0gdGVtcE1hdHJpeE1hdHJpeFs0XTtcclxuICAgICAgICAgICAgICAgIHZhciBzcmYgPSB0ZW1wTWF0cml4TWF0cml4WzVdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgICAgICAgICAgICAgIHZhciBtdmIgPSBzcmEgKiBjbWIgKyBzcmIgKiBjbWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXZjID0gc3JjICogY21hICsgc3JkICogY21jO1xyXG4gICAgICAgICAgICAgICAgdmFyIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgICAgICAgICAgICAgIHZhciBtdmUgPSBzcmUgKiBjbWEgKyBzcmYgKiBjbWMgKyBjbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXZmID0gc3JlICogY21iICsgc3JmICogY21kICsgY21mO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR4MCA9IHggKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5MCA9IHggKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR4MSA9IHggKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICAgICAgICAgIHZhciB0eTEgPSB4ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHgyID0geHcgKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICAgICAgICAgIHZhciB0eTIgPSB4dyAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR4MyA9IHh3ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICAgICAgICAgIHZhciB0eTMgPSB4dyAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcblxyXG4gICAgICAgICAgICAgICAgdnR4T2Zmc2V0ID0gZGF0YS5hbGxvY2F0ZSgyMCk7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50Q291bnQgKz0gNjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgVG9wIExlZnRcclxuICAgICAgICAgICAgICAgIHZiRjMyW3Z0eE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICAgICAgICAgIHZiRjMyW3Z0eE9mZnNldCsrXSA9IHR5MDtcclxuICAgICAgICAgICAgICAgIHZiRjMyW3Z0eE9mZnNldCsrXSA9IHUwO1xyXG4gICAgICAgICAgICAgICAgdmJGMzJbdnR4T2Zmc2V0KytdID0gdjA7XHJcbiAgICAgICAgICAgICAgICB2YlUzMlt2dHhPZmZzZXQrK10gPSBjb2xvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgQm90dG9tIExlZnRcclxuICAgICAgICAgICAgICAgIHZiRjMyW3Z0eE9mZnNldCsrXSA9IHR4MTtcclxuICAgICAgICAgICAgICAgIHZiRjMyW3Z0eE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICAgICAgICAgIHZiRjMyW3Z0eE9mZnNldCsrXSA9IHUxO1xyXG4gICAgICAgICAgICAgICAgdmJGMzJbdnR4T2Zmc2V0KytdID0gdjE7XHJcbiAgICAgICAgICAgICAgICB2YlUzMlt2dHhPZmZzZXQrK10gPSBjb2xvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgQm90dG9tIFJpZ2h0XHJcbiAgICAgICAgICAgICAgICB2YkYzMlt2dHhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgICAgICAgICB2YkYzMlt2dHhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgICAgICAgICB2YkYzMlt2dHhPZmZzZXQrK10gPSB1MjtcclxuICAgICAgICAgICAgICAgIHZiRjMyW3Z0eE9mZnNldCsrXSA9IHYyO1xyXG4gICAgICAgICAgICAgICAgdmJVMzJbdnR4T2Zmc2V0KytdID0gY29sb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFRvcCBSaWdodFxyXG4gICAgICAgICAgICAgICAgdmJGMzJbdnR4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgICAgICAgICAgdmJGMzJbdnR4T2Zmc2V0KytdID0gdHkzO1xyXG4gICAgICAgICAgICAgICAgdmJGMzJbdnR4T2Zmc2V0KytdID0gdTM7XHJcbiAgICAgICAgICAgICAgICB2YkYzMlt2dHhPZmZzZXQrK10gPSB2MztcclxuICAgICAgICAgICAgICAgIHZiVTMyW3Z0eE9mZnNldCsrXSA9IGNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcnRpY2xlT2Zmc2V0ICs9IGJhdGNoU2l6ZTtcclxuICAgICAgICAgICAgbGVuZ3RoIC09IGJhdGNoU2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSBlbGVtZW50Q291bnQ7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2godW5kZWZpbmVkLCByZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgICAgICBlbGVtZW50Q291bnQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3BhcnRpY2xlcmVuZGVyZXIvUGFydGljbGVSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gOTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHtcclxuICAgIC8qXHJcbiAgICBzdHJ1Y3QgdlxyXG4gICAge1xyXG4gICAgICAgIGZsb2F0IHBvc2l0aW9uWzJdO1xyXG4gICAgICAgIGZsb2F0IHRleF9jb29yZFsyXTtcclxuICAgICAgICB1bnNpZ25lZCBpbnQgY29sb3I7XHJcbiAgICB9O1xyXG4gICAgKi9cclxuICAgIFZFUlRFWF9TSVpFOiAyMCwgLyogc2l6ZW9mKHYpICovXHJcbiAgICBJTkRFWF9TSVpFOiAyLFxyXG4gICAgVkVSVEVYX0NPVU5UOiA0LFxyXG4gICAgSU5ERVhfQ09VTlQ6IDYsXHJcbiAgICBDT01QT05FTlQzMl9DT1VOVDogNSwgLyogc2l6ZW9mKHYpIC8gNCAqL1xyXG4gICAgTUFYOiAxNjAwMFxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvcGFydGljbGVyZW5kZXJlci9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gOTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIERhdGFCdWZmZXIxNiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIxNicpO1xyXG52YXIgRGF0YUJ1ZmZlcjMyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvRGF0YUJ1ZmZlcjMyJyk7XHJcbnZhciBQSEFTRVJfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25zdCcpO1xyXG52YXIgVW50ZXh0dXJlZEFuZFRpbnRlZFNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3NoYWRlcnMvVW50ZXh0dXJlZEFuZFRpbnRlZFNoYWRlcicpO1xyXG5cclxudmFyIFF1YWRCYXRjaCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBRdWFkQmF0Y2ggKGdhbWUsIGdsLCBtYW5hZ2VyKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICAgICAgdGhpcy50eXBlID0gUEhBU0VSX0NPTlNULldFQkdMO1xyXG4gICAgICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5nbENvbnRleHQgPSBnbDtcclxuICAgICAgICB0aGlzLm1heFF1YWRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0KHRoaXMuZ2xDb250ZXh0KTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGdsKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIzMihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULkFBUVVBRF9WRVJURVhfQ09VTlQgKiBDT05TVC5NQVhfQUFRVUFEKTtcclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIxNihDT05TVC5JTkRFWF9TSVpFICogQ09OU1QuQUFRVUFEX0lOREVYX0NPVU5UICogQ09OU1QuTUFYX0FBUVVBRCk7XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlU2hhZGVyKCdVbnRleHR1cmVkQW5kVGludGVkU2hhZGVyJywgVW50ZXh0dXJlZEFuZFRpbnRlZFNoYWRlcik7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0ID0gdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3QgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCksIGdsLlNUUkVBTV9EUkFXKTtcclxuICAgICAgICB2YXIgdmlld01hdHJpeExvY2F0aW9uID0gc2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndV92aWV3X21hdHJpeCcpO1xyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgbWF4ID0gQ09OU1QuTUFYX0FBUVVBRCAqIENPTlNULkFBUVVBRF9JTkRFWF9DT1VOVDtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfcG9zaXRpb24nKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfY29sb3InKSwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgOCk7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBpbmRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0ID0gdmVydGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gdmlld01hdHJpeExvY2F0aW9uO1xyXG5cclxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULkFBUVVBRF9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULkFBUVVBRF9WRVJURVhfQ09VTlQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAwXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMl0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAzXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNV0gPSBpbmRleEIgKyAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5kZXhCdWZmZXJPYmplY3QudXBkYXRlUmVzb3VyY2UoaW5kZXhCdWZmZXIsIDApO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2hvdWxkRmx1c2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIC8vIFRoZSB1c2VyIG11c3QgY2hlY2sgaWYgdGhlIGJ1ZmZlcnMgYXJlIGZ1bGwgYmVmb3JlIGZsdXNoaW5nXHJcbiAgICAgICAgLy8gdGhpcyBpcyB0byBnaXZlIGZyZWVkb20gb2Ygd2hlbiBzaG91bGQgdGhlIHJlbmRlcmVyIGZsdXNoLiB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgZmxvYXRCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZShDT05TVC5BQVFVQURfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVCAqIENPTlNULkFBUVVBRF9WRVJURVhfQ09VTlQpO1xyXG5cclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB4O1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHk7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gcmVkO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGdyZWVuO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGJsdWU7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHg7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSByZWQ7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gZ3JlZW47XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYmx1ZTtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geCArIHdpZHRoO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gcmVkO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGdyZWVuO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGJsdWU7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHggKyB3aWR0aDtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB5O1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHJlZDtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBncmVlbjtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBibHVlO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCArPSBDT05TVC5BQVFVQURfSU5ERVhfQ09VTlQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNoYWRlciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uLCBzaGFkZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QuYmluZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmbHVzaDogZnVuY3Rpb24gKHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudENvdW50ID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmJpbmQoc2hhZGVyKTtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC51cGRhdGVSZXNvdXJjZSh2ZXJ0ZXhEYXRhQnVmZmVyLmdldFVzZWRCdWZmZXJBc0Zsb2F0KCksIDApO1xyXG5cclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmVsZW1lbnRDb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uLCBzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFjdGl2ZVNoYWRlciA9IHNoYWRlciAhPT0gdW5kZWZpbmVkID8gc2hhZGVyIDogdGhpcy5zaGFkZXI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlc29sdXRpb247XHJcblxyXG4gICAgICAgIGFjdGl2ZVNoYWRlci5zZXRDb25zdGFudE1hdHJpeDR4NChcclxuICAgICAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24sXHJcbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMud2lkdGgsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAtMiAvIHRoaXMuaGVpZ2h0LCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZVNoYWRlcih0aGlzLnNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFF1YWRCYXRjaDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvcXVhZGJhdGNoL1F1YWRCYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gOTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHtcclxuXHJcbiAgICAvLyBWRVJURVhfU0laRSA9IHNpemVvZih2ZWMyKSArIHNpemVvZih2ZWM0KVxyXG4gICAgVkVSVEVYX1NJWkU6IDI0LFxyXG4gICAgSU5ERVhfU0laRTogMixcclxuICAgIEFBUVVBRF9WRVJURVhfQ09VTlQ6IDQsXHJcbiAgICBBQVFVQURfSU5ERVhfQ09VTlQ6IDYsXHJcblxyXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXHJcbiAgICBBQVFVQURfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVDogNixcclxuICAgIE1BWF9BQVFVQUQ6IDIwMDAsXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDT05TVDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvcXVhZGJhdGNoL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5MDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG52YXIgRGF0YUJ1ZmZlcjMyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvRGF0YUJ1ZmZlcjMyJyk7XHJcbnZhciBFYXJjdXQgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9nZW9tL3BvbHlnb24vRWFyY3V0Jyk7XHJcbnZhciBQSEFTRVJfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25zdCcpO1xyXG52YXIgVW50ZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi9zaGFkZXJzL1VudGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyJyk7XHJcblxyXG52YXIgU2hhcGVCYXRjaCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBTaGFwZUJhdGNoIChnYW1lLCBnbCwgbWFuYWdlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuICAgICAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICAgICAgdGhpcy5tYXhWZXJ0aWNlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRlbXBUcmlhbmdsZSA9IFtcclxuICAgICAgICAgICAge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCByZ2I6IDB4RkZGRkZGLCBhbHBoYTogMS4wfSxcclxuICAgICAgICAgICAge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCByZ2I6IDB4RkZGRkZGLCBhbHBoYTogMS4wfSxcclxuICAgICAgICAgICAge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCByZ2I6IDB4RkZGRkZGLCBhbHBoYTogMS4wfSxcclxuICAgICAgICAgICAge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCByZ2I6IDB4RkZGRkZGLCBhbHBoYTogMS4wfVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5pdCh0aGlzLmdsQ29udGV4dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChnbClcclxuICAgIHtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBEYXRhQnVmZmVyMzIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5NQVhfVkVSVElDRVMpO1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVNoYWRlcignVW50ZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXInLCBVbnRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlcik7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdCA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSwgZ2wuU1RSRUFNX0RSQVcpO1xyXG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBzaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3ZpZXdfbWF0cml4Jyk7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9WRVJUSUNFUztcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfcG9zaXRpb24nKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfY29sb3InKSwgNCwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX2FscGhhJyksIDEsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDEyKTtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IHZlcnRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuICAgICAgICB0aGlzLm1heFZlcnRpY2VzID0gbWF4O1xyXG4gICAgICAgIHRoaXMucG9seWdvbkNhY2hlID0gW107XHJcblxyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzaG91bGRGbHVzaDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlTGVuZ3RoKCkgPj0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoc2hhZGVyID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlci5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNoYWRlci5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24sIHNoYWRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhDb3VudCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYmluZChzaGFkZXIpO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0LnVwZGF0ZVJlc291cmNlKHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSwgMCk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCB0aGlzLnZlcnRleENvdW50KTtcclxuXHJcbiAgICAgICAgdmVydGV4RGF0YUJ1ZmZlci5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbiwgc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhY3RpdmVTaGFkZXIgPSBzaGFkZXIgIT09IHVuZGVmaW5lZCA/IHNoYWRlciA6IHRoaXMuc2hhZGVyO1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgYWN0aXZlU2hhZGVyLnNldENvbnN0YW50TWF0cml4NHg0KFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbixcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy5oZWlnaHQsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzXHJcbiAgICAvLyBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcblxyXG4gICAgLy8gbGluZSBwcm9wZXJ0aWVzXHJcbiAgICAvLyBheCwgYXksIGJ4LCBieSwgYUxpbmVXaWR0aCwgYkxpbmVXaWR0aCwgYUxpbmVDb2xvciwgYkxpbmVDb2xvciwgbGluZUFscGhhLFxyXG5cclxuICAgIC8vIHRyYW5zZm9ybVxyXG4gICAgLy8gYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcclxuICAgIC8vIGN1cnJlbnRNYXRyaXhcclxuICAgIGFkZExpbmU6IGZ1bmN0aW9uIChzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sIGF4LCBheSwgYngsIGJ5LCBhTGluZVdpZHRoLCBiTGluZVdpZHRoLCBhTGluZUNvbG9yLCBiTGluZUNvbG9yLCBsaW5lQWxwaGEsIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsIGN1cnJlbnRNYXRyaXgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMudmVydGV4Q291bnQgKyA2ID4gdGhpcy5tYXhWZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgKz0gNjtcclxuXHJcbiAgICAgICAgdmFyIGEwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbMF07XHJcbiAgICAgICAgdmFyIGIwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbMV07XHJcbiAgICAgICAgdmFyIGMwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbMl07XHJcbiAgICAgICAgdmFyIGQwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbM107XHJcbiAgICAgICAgdmFyIGUwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbNF07XHJcbiAgICAgICAgdmFyIGYwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbNV07XHJcbiAgICAgICAgdmFyIGEgPSBhMSAqIGEwICsgYjEgKiBjMDtcclxuICAgICAgICB2YXIgYiA9IGExICogYjAgKyBiMSAqIGQwO1xyXG4gICAgICAgIHZhciBjID0gYzEgKiBhMCArIGQxICogYzA7XHJcbiAgICAgICAgdmFyIGQgPSBjMSAqIGIwICsgZDEgKiBkMDtcclxuICAgICAgICB2YXIgZSA9IGUxICogYTAgKyBmMSAqIGMwICsgZTA7XHJcbiAgICAgICAgdmFyIGYgPSBlMSAqIGIwICsgZjEgKiBkMCArIGYwO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgZHggPSBieCAtIGF4O1xyXG4gICAgICAgIHZhciBkeSA9IGJ5IC0gYXk7XHJcbiAgICAgICAgdmFyIGxlbiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICAgICAgdmFyIGFsMCA9IGFMaW5lV2lkdGggKiAoYnkgLSBheSkgLyBsZW47XHJcbiAgICAgICAgdmFyIGFsMSA9IGFMaW5lV2lkdGggKiAoYXggLSBieCkgLyBsZW47XHJcbiAgICAgICAgdmFyIGJsMCA9IGJMaW5lV2lkdGggKiAoYnkgLSBheSkgLyBsZW47XHJcbiAgICAgICAgdmFyIGJsMSA9IGJMaW5lV2lkdGggKiAoYXggLSBieCkgLyBsZW47XHJcbiAgICAgICAgdmFyIGx4MCA9IGJ4IC0gYmwwO1xyXG4gICAgICAgIHZhciBseTAgPSBieSAtIGJsMTtcclxuICAgICAgICB2YXIgbHgxID0gYXggLSBhbDA7XHJcbiAgICAgICAgdmFyIGx5MSA9IGF5IC0gYWwxO1xyXG4gICAgICAgIHZhciBseDIgPSBieCArIGJsMDtcclxuICAgICAgICB2YXIgbHkyID0gYnkgKyBibDE7XHJcbiAgICAgICAgdmFyIGx4MyA9IGF4ICsgYWwwO1xyXG4gICAgICAgIHZhciBseTMgPSBheSArIGFsMTtcclxuICAgICAgICB2YXIgeDAgPSBseDAgKiBhICsgbHkwICogYyArIGU7XHJcbiAgICAgICAgdmFyIHkwID0gbHgwICogYiArIGx5MCAqIGQgKyBmO1xyXG4gICAgICAgIHZhciB4MSA9IGx4MSAqIGEgKyBseTEgKiBjICsgZTtcclxuICAgICAgICB2YXIgeTEgPSBseDEgKiBiICsgbHkxICogZCArIGY7XHJcbiAgICAgICAgdmFyIHgyID0gbHgyICogYSArIGx5MiAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB5MiA9IGx4MiAqIGIgKyBseTIgKiBkICsgZjtcclxuICAgICAgICB2YXIgeDMgPSBseDMgKiBhICsgbHkzICogYyArIGU7XHJcbiAgICAgICAgdmFyIHkzID0gbHgzICogYiArIGx5MyAqIGQgKyBmO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gYkxpbmVDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhTGluZUNvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGJMaW5lQ29sb3I7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gYUxpbmVDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhTGluZUNvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGJMaW5lQ29sb3I7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgeDAsIHkwLCBiTGluZUNvbG9yLFxyXG4gICAgICAgICAgICB4MSwgeTEsIGFMaW5lQ29sb3IsXHJcbiAgICAgICAgICAgIHgyLCB5MiwgYkxpbmVDb2xvcixcclxuICAgICAgICAgICAgeDMsIHkzLCBhTGluZUNvbG9yXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gR3JhcGhpY3MgR2FtZSBPYmplY3QgcHJvcGVydGllc1xyXG4gICAgLy8gc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG5cclxuICAgIC8vIFBhdGggcHJvcGVydGllc1xyXG4gICAgLy8gcGF0aCwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGxpbmVBbHBoYSxcclxuXHJcbiAgICAvLyB0cmFuc2Zvcm1cclxuICAgIC8vIGEsIGIsIGMsIGQsIGUsIGYsXHJcblxyXG4gICAgLy8gaXMgbGFzdCBjb25uZWN0aW9uXHJcbiAgICAvLyBpc0xhc3RQYXRoLFxyXG4gICAgLy8gY3VycmVudE1hdHJpeFxyXG4gICAgYWRkU3Ryb2tlUGF0aDogZnVuY3Rpb24gKHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbiwgcGF0aCwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGxpbmVBbHBoYSwgYSwgYiwgYywgZCwgZSwgZiwgaXNMYXN0UGF0aCwgY3VycmVudE1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgcG9pbnQwLCBwb2ludDE7XHJcbiAgICAgICAgdmFyIHBhdGhMZW5ndGggPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICB2YXIgcG9seWxpbmVzID0gdGhpcy5wb2x5Z29uQ2FjaGU7XHJcbiAgICAgICAgdmFyIGxhc3QsIGN1cnI7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlckYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQ7XHJcbiAgICAgICAgdmFyIGxpbmU7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHBhdGhJbmRleCA9IDA7IHBhdGhJbmRleCArIDEgPCBwYXRoTGVuZ3RoOyBwYXRoSW5kZXggKz0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBvaW50MCA9IHBhdGhbcGF0aEluZGV4XTtcclxuICAgICAgICAgICAgcG9pbnQxID0gcGF0aFtwYXRoSW5kZXggKyAxXTtcclxuXHJcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLmFkZExpbmUoXHJcbiAgICAgICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICBwb2ludDAueCwgcG9pbnQwLnksXHJcbiAgICAgICAgICAgICAgICBwb2ludDEueCwgcG9pbnQxLnksXHJcbiAgICAgICAgICAgICAgICBwb2ludDAud2lkdGggLyAyLCBwb2ludDEud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgcG9pbnQwLnJnYiwgcG9pbnQxLnJnYiwgbGluZUFscGhhLFxyXG4gICAgICAgICAgICAgICAgYSwgYiwgYywgZCwgZSwgZixcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXhcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHBvbHlsaW5lcy5wdXNoKGxpbmUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogUmVuZGVyIGpvaW50cyAqL1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMSwgcG9seWxpbmVzTGVuZ3RoID0gcG9seWxpbmVzLmxlbmd0aDsgaW5kZXggPCBwb2x5bGluZXNMZW5ndGg7ICsraW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52ZXJ0ZXhDb3VudCArIDYgPiB0aGlzLm1heFZlcnRpY2VzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxhc3QgPSBwb2x5bGluZXNbaW5kZXggLSAxXSB8fCBwb2x5bGluZXNbcG9seWxpbmVzTGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGN1cnIgPSBwb2x5bGluZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAyICsgMF07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAyICsgMV07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAyICsgMl07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGFzdFszICogMCArIDBdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGFzdFszICogMCArIDFdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gbGFzdFszICogMCArIDJdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGN1cnJbMyAqIDMgKyAwXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGN1cnJbMyAqIDMgKyAxXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGN1cnJbMyAqIDMgKyAyXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAwICsgMF07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAwICsgMV07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAwICsgMl07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGFzdFszICogMiArIDBdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGFzdFszICogMiArIDFdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gbGFzdFszICogMiArIDJdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGN1cnJbMyAqIDEgKyAwXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGN1cnJbMyAqIDEgKyAxXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGN1cnJbMyAqIDEgKyAyXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudmVydGV4Q291bnQgKz0gNjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBvbHlsaW5lcy5sZW5ndGggPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzXHJcbiAgICAvLyBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcblxyXG4gICAgLy8gUGF0aCBwcm9wZXJ0aWVzXHJcbiAgICAvLyBwYXRoLCBmaWxsQ29sb3IsIGZpbGxBbHBoYSxcclxuXHJcbiAgICAvLyB0cmFuc2Zvcm1cclxuICAgIC8vIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXHJcbiAgICAvLyBjdXJyZW50TWF0cml4XHJcbiAgICBhZGRGaWxsUGF0aDogZnVuY3Rpb24gKHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbiwgcGF0aCwgZmlsbENvbG9yLCBmaWxsQWxwaGEsIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsIGN1cnJlbnRNYXRyaXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xyXG4gICAgICAgIHZhciBwb2x5Z29uQ2FjaGUgPSB0aGlzLnBvbHlnb25DYWNoZTtcclxuICAgICAgICB2YXIgcG9seWdvbkluZGV4QXJyYXk7XHJcbiAgICAgICAgdmFyIHBvaW50O1xyXG4gICAgICAgIHZhciB2MCwgdjEsIHYyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQ7XHJcbiAgICAgICAgdmFyIHZlcnRleENvdW50ID0gdGhpcy52ZXJ0ZXhDb3VudDtcclxuICAgICAgICB2YXIgbWF4VmVydGljZXMgPSB0aGlzLm1heFZlcnRpY2VzO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MjtcclxuICAgICAgICB2YXIgdHgwLCB0eTAsIHR4MSwgdHkxLCB0eDIsIHR5MjtcclxuICAgICAgICB2YXIgYTAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFswXTtcclxuICAgICAgICB2YXIgYjAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFsxXTtcclxuICAgICAgICB2YXIgYzAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFsyXTtcclxuICAgICAgICB2YXIgZDAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFszXTtcclxuICAgICAgICB2YXIgZTAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFs0XTtcclxuICAgICAgICB2YXIgZjAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFs1XTtcclxuICAgICAgICB2YXIgYSA9IGExICogYTAgKyBiMSAqIGMwO1xyXG4gICAgICAgIHZhciBiID0gYTEgKiBiMCArIGIxICogZDA7XHJcbiAgICAgICAgdmFyIGMgPSBjMSAqIGEwICsgZDEgKiBjMDtcclxuICAgICAgICB2YXIgZCA9IGMxICogYjAgKyBkMSAqIGQwO1xyXG4gICAgICAgIHZhciBlID0gZTEgKiBhMCArIGYxICogYzAgKyBlMDtcclxuICAgICAgICB2YXIgZiA9IGUxICogYjAgKyBmMSAqIGQwICsgZjA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHBhdGhJbmRleCA9IDA7IHBhdGhJbmRleCA8IGxlbmd0aDsgKytwYXRoSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwb2ludCA9IHBhdGhbcGF0aEluZGV4XTtcclxuICAgICAgICAgICAgcG9seWdvbkNhY2hlLnB1c2gocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwb2x5Z29uSW5kZXhBcnJheSA9IEVhcmN1dChwb2x5Z29uQ2FjaGUpO1xyXG4gICAgICAgIGxlbmd0aCA9IHBvbHlnb25JbmRleEFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHYwID0gcG9seWdvbkluZGV4QXJyYXlbaW5kZXggKyAwXSAqIDI7XHJcbiAgICAgICAgICAgIHYxID0gcG9seWdvbkluZGV4QXJyYXlbaW5kZXggKyAxXSAqIDI7XHJcbiAgICAgICAgICAgIHYyID0gcG9seWdvbkluZGV4QXJyYXlbaW5kZXggKyAyXSAqIDI7XHJcblxyXG4gICAgICAgICAgICBpZiAodmVydGV4Q291bnQgKyAzID4gbWF4VmVydGljZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4Q291bnQgPSB2ZXJ0ZXhDb3VudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcclxuICAgICAgICAgICAgICAgIHZlcnRleENvdW50ID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgxMik7XHJcbiAgICAgICAgICAgIHZlcnRleENvdW50ICs9IDM7XHJcblxyXG4gICAgICAgICAgICB4MCA9IHBvbHlnb25DYWNoZVt2MCArIDBdO1xyXG4gICAgICAgICAgICB5MCA9IHBvbHlnb25DYWNoZVt2MCArIDFdO1xyXG4gICAgICAgICAgICB4MSA9IHBvbHlnb25DYWNoZVt2MSArIDBdO1xyXG4gICAgICAgICAgICB5MSA9IHBvbHlnb25DYWNoZVt2MSArIDFdO1xyXG4gICAgICAgICAgICB4MiA9IHBvbHlnb25DYWNoZVt2MiArIDBdO1xyXG4gICAgICAgICAgICB5MiA9IHBvbHlnb25DYWNoZVt2MiArIDFdO1xyXG5cclxuICAgICAgICAgICAgdHgwID0geDAgKiBhICsgeTAgKiBjICsgZTtcclxuICAgICAgICAgICAgdHkwID0geDAgKiBiICsgeTAgKiBkICsgZjtcclxuICAgICAgICAgICAgdHgxID0geDEgKiBhICsgeTEgKiBjICsgZTtcclxuICAgICAgICAgICAgdHkxID0geDEgKiBiICsgeTEgKiBkICsgZjtcclxuICAgICAgICAgICAgdHgyID0geDIgKiBhICsgeTIgKiBjICsgZTtcclxuICAgICAgICAgICAgdHkyID0geDIgKiBiICsgeTIgKiBkICsgZjtcclxuXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkxO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxBbHBoYTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gdmVydGV4Q291bnQ7XHJcblxyXG4gICAgICAgIHBvbHlnb25DYWNoZS5sZW5ndGggPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzXHJcbiAgICAvLyBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcblxyXG4gICAgLy8gUmVjdGFuZ2xlIHByb3BlcnRpZXNcclxuICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZpbGxDb2xvciwgZmlsbEFscGhhLFxyXG5cclxuICAgIC8vIHRyYW5zZm9ybVxyXG4gICAgLy8gYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcclxuICAgIC8vIGN1cnJlbnRNYXRyaXhcclxuICAgIGFkZEZpbGxSZWN0OiBmdW5jdGlvbiAoc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsQ29sb3IsIGZpbGxBbHBoYSwgYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSwgY3VycmVudE1hdHJpeClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhDb3VudCArIDYgPiB0aGlzLm1heFZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlckYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcclxuICAgICAgICB2YXIgeHcgPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcclxuICAgICAgICB2YXIgYTAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFswXTtcclxuICAgICAgICB2YXIgYjAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFsxXTtcclxuICAgICAgICB2YXIgYzAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFsyXTtcclxuICAgICAgICB2YXIgZDAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFszXTtcclxuICAgICAgICB2YXIgZTAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFs0XTtcclxuICAgICAgICB2YXIgZjAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFs1XTtcclxuICAgICAgICB2YXIgYSA9IGExICogYTAgKyBiMSAqIGMwO1xyXG4gICAgICAgIHZhciBiID0gYTEgKiBiMCArIGIxICogZDA7XHJcbiAgICAgICAgdmFyIGMgPSBjMSAqIGEwICsgZDEgKiBjMDtcclxuICAgICAgICB2YXIgZCA9IGMxICogYjAgKyBkMSAqIGQwO1xyXG4gICAgICAgIHZhciBlID0gZTEgKiBhMCArIGYxICogYzAgKyBlMDtcclxuICAgICAgICB2YXIgZiA9IGUxICogYjAgKyBmMSAqIGQwICsgZjA7XHJcbiAgICAgICAgdmFyIHR4MCA9IHggKiBhICsgeSAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB0eTAgPSB4ICogYiArIHkgKiBkICsgZjtcclxuICAgICAgICB2YXIgdHgxID0geCAqIGEgKyB5aCAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB0eTEgPSB4ICogYiArIHloICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4MiA9IHh3ICogYSArIHloICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5MiA9IHh3ICogYiArIHloICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4MyA9IHh3ICogYSArIHkgKiBjICsgZTtcclxuICAgICAgICB2YXIgdHkzID0geHcgKiBiICsgeSAqIGQgKyBmO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ICs9IDY7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEdyYXBoaWNzIEdhbWUgT2JqZWN0IHByb3BlcnRpZXNcclxuICAgIC8vIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcclxuXHJcbiAgICAvLyBUcmlhbmdsZSBwcm9wZXJ0aWVzXHJcbiAgICAvLyB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBmaWxsQ29sb3IsIGZpbGxBbHBoYSxcclxuXHJcbiAgICAvLyB0cmFuc2Zvcm1cclxuICAgIC8vIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXHJcbiAgICAvLyBjdXJyZW50TWF0cml4XHJcbiAgICBhZGRGaWxsVHJpYW5nbGU6IGZ1bmN0aW9uIChzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGZpbGxDb2xvciwgZmlsbEFscGhhLCBhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLCBjdXJyZW50TWF0cml4KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ICsgMyA+IHRoaXMubWF4VmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYTAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFswXTtcclxuICAgICAgICB2YXIgYjAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFsxXTtcclxuICAgICAgICB2YXIgYzAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFsyXTtcclxuICAgICAgICB2YXIgZDAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFszXTtcclxuICAgICAgICB2YXIgZTAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFs0XTtcclxuICAgICAgICB2YXIgZjAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFs1XTtcclxuICAgICAgICB2YXIgYSA9IGExICogYTAgKyBiMSAqIGMwO1xyXG4gICAgICAgIHZhciBiID0gYTEgKiBiMCArIGIxICogZDA7XHJcbiAgICAgICAgdmFyIGMgPSBjMSAqIGEwICsgZDEgKiBjMDtcclxuICAgICAgICB2YXIgZCA9IGMxICogYjAgKyBkMSAqIGQwO1xyXG4gICAgICAgIHZhciBlID0gZTEgKiBhMCArIGYxICogYzAgKyBlMDtcclxuICAgICAgICB2YXIgZiA9IGUxICogYjAgKyBmMSAqIGQwICsgZjA7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlckYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDEyKTtcclxuICAgICAgICB2YXIgdHgwID0geDAgKiBhICsgeTAgKiBjICsgZTtcclxuICAgICAgICB2YXIgdHkwID0geDAgKiBiICsgeTAgKiBkICsgZjtcclxuICAgICAgICB2YXIgdHgxID0geDEgKiBhICsgeTEgKiBjICsgZTtcclxuICAgICAgICB2YXIgdHkxID0geDEgKiBiICsgeTEgKiBkICsgZjtcclxuICAgICAgICB2YXIgdHgyID0geDIgKiBhICsgeTIgKiBjICsgZTtcclxuICAgICAgICB2YXIgdHkyID0geDIgKiBiICsgeTIgKiBkICsgZjtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxBbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxBbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxBbHBoYTtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCArPSAzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzXHJcbiAgICAvLyBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcblxyXG4gICAgLy8gVHJpYW5nbGUgcHJvcGVydGllc1xyXG4gICAgLy8geDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGxpbmVBbHBoYSxcclxuXHJcbiAgICAvLyB0cmFuc2Zvcm1cclxuICAgIC8vIGEsIGIsIGMsIGQsIGUsIGYsXHJcbiAgICAvLyBjdXJyZW50TWF0cml4XHJcbiAgICBhZGRTdHJva2VUcmlhbmdsZTogZnVuY3Rpb24gKHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbiwgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGxpbmVBbHBoYSwgYSwgYiwgYywgZCwgZSwgZiwgY3VycmVudE1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgdGVtcFRyaWFuZ2xlID0gdGhpcy50ZW1wVHJpYW5nbGU7XHJcblxyXG4gICAgICAgIHRlbXBUcmlhbmdsZVswXS54ID0geDA7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzBdLnkgPSB5MDtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMF0ud2lkdGggPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzBdLnJnYiA9IGxpbmVDb2xvcjtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMF0uYWxwaGEgPSBsaW5lQWxwaGE7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzFdLnggPSB4MTtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMV0ueSA9IHkxO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVsxXS53aWR0aCA9IGxpbmVXaWR0aDtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMV0ucmdiID0gbGluZUNvbG9yO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVsxXS5hbHBoYSA9IGxpbmVBbHBoYTtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMl0ueCA9IHgyO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVsyXS55ID0geTI7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzJdLndpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVsyXS5yZ2IgPSBsaW5lQ29sb3I7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzJdLmFscGhhID0gbGluZUFscGhhO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVszXS54ID0geDA7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzNdLnkgPSB5MDtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbM10ud2lkdGggPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzNdLnJnYiA9IGxpbmVDb2xvcjtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbM10uYWxwaGEgPSBsaW5lQWxwaGE7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkU3Ryb2tlUGF0aChcclxuICAgICAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgICAgICB0ZW1wVHJpYW5nbGUsIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEsXHJcbiAgICAgICAgICAgIGEsIGIsIGMsIGQsIGUsIGYsXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICBjdXJyZW50TWF0cml4XHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZVNoYWRlcih0aGlzLnNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYXBlQmF0Y2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3NoYXBlYmF0Y2gvU2hhcGVCYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gOTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHtcclxuXHJcbiAgICBWRVJURVhfU0laRTogMTYsXHJcblxyXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXHJcbiAgICBTSEFQRV9WRVJURVhfQ09NUE9ORU5UX0NPVU5UOiA0LFxyXG5cclxuICAgIC8vIENhbid0IGJlIGJpZ2dlciB0aGFuIDEwLDAwMCBzaW5jZSBpbmRleCBhcmUgMTYtYml0XHJcbiAgICBNQVhfVkVSVElDRVM6IDE2MDAwXHJcbiAgICBcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3NoYXBlYmF0Y2gvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDkwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBEYXRhQnVmZmVyMTYgPSByZXF1aXJlKCcuLi8uLi91dGlscy9EYXRhQnVmZmVyMTYnKTtcclxudmFyIERhdGFCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIzMicpO1xyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3NoYWRlcnMvVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyJyk7XHJcbnZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9nYW1lb2JqZWN0cy9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xyXG5cclxudmFyIFNwcml0ZUJhdGNoID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFNwcml0ZUJhdGNoIChnYW1lLCBnbCwgbWFuYWdlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuICAgICAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICAgICAgdGhpcy5tYXhTcHJpdGVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3RGb3JNZXNoID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZW1wTWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG5cclxuICAgICAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXHJcbiAgICAgICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgV2ViR0xDb250ZXh0T3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kcmF3SW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5sYXN0RHJhd0luZGV4ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdERyYXdpbmdNZXNoID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kcmF3aW5nTWVzaCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZ2wpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBuZXcgRGF0YUJ1ZmZlcjMyKENPTlNULlZFUlRFWF9TSVpFICogQ09OU1QuU1BSSVRFX1ZFUlRFWF9DT1VOVCAqIENPTlNULk1BWF9TUFJJVEVTKTtcclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIxNihDT05TVC5JTkRFWF9TSVpFICogQ09OU1QuU1BSSVRFX0lOREVYX0NPVU5UICogQ09OU1QuTUFYX1NQUklURVMpO1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVNoYWRlcignVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyJywgVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXJPYmplY3QgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0Rm9yTWVzaCA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCksIGdsLlNUUkVBTV9EUkFXKTtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0ID0gdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpLCBnbC5TVFJFQU1fRFJBVyk7XHJcbiAgICAgICAgdmFyIHZpZXdNYXRyaXhMb2NhdGlvbiA9IHNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3Vfdmlld19tYXRyaXgnKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBpbmRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9TUFJJVEVTICogQ09OU1QuU1BSSVRFX0lOREVYX0NPVU5UO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBpbmRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0Rm9yTWVzaCA9IGluZGV4QnVmZmVyT2JqZWN0Rm9yTWVzaDtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IHZlcnRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfcG9zaXRpb24nKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfdGV4X2Nvb3JkJyksIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX2NvbG9yJyksIDMsIGdsLlVOU0lHTkVEX0JZVEUsIHRydWUsIENPTlNULlZFUlRFWF9TSVpFLCAxNik7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfYWxwaGEnKSwgMSwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMjApO1xyXG5cclxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULlNQUklURV9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULlNQUklURV9WRVJURVhfQ09VTlQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAwXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMl0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAzXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNV0gPSBpbmRleEIgKyAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5kZXhCdWZmZXJPYmplY3QudXBkYXRlUmVzb3VyY2UoaW5kZXhCdWZmZXIsIDApO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2hvdWxkRmx1c2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhd0luZGV4ZWQgIT09IHRoaXMubGFzdERyYXdJbmRleGVkIHx8IHRoaXMubGFzdERyYXdpbmdNZXNoICE9PSB0aGlzLmRyYXdpbmdNZXNoIHx8IHRoaXMuaXNGdWxsKCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3REcmF3SW5kZXhlZCA9IHRoaXMuZHJhd0luZGV4ZWQ7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdERyYXdpbmdNZXNoID0gdGhpcy5kcmF3aW5nTWVzaDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlTGVuZ3RoKCkgPj0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoc2hhZGVyID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlci5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNoYWRlci5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24sIHNoYWRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoc2hhZGVyLCByZW5kZXJUYXJnZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRDb3VudCA9PT0gMCAmJiB0aGlzLnZlcnRleENvdW50ID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAocmVuZGVyVGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5iaW5kKHNoYWRlcik7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QudXBkYXRlUmVzb3VyY2UodmVydGV4RGF0YUJ1ZmZlci5nZXRVc2VkQnVmZmVyQXNGbG9hdCgpLCAwKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZHJhd0luZGV4ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kcmF3aW5nTWVzaClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdEZvck1lc2guYmluZCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdEZvck1lc2gudXBkYXRlUmVzb3VyY2UodGhpcy5pbmRleERhdGFCdWZmZXIuYnVmZmVyLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QuYmluZCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmVsZW1lbnRDb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgdGhpcy52ZXJ0ZXhDb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IDA7XHJcblxyXG4gICAgICAgIGlmIChyZW5kZXJUYXJnZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbiwgc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhY3RpdmVTaGFkZXIgPSAoc2hhZGVyICE9PSB1bmRlZmluZWQpID8gc2hhZGVyIDogdGhpcy5zaGFkZXI7XHJcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gKGFjdGl2ZVNoYWRlciA9PT0gdGhpcy5zaGFkZXIpID8gdGhpcy52aWV3TWF0cml4TG9jYXRpb24gOiBhY3RpdmVTaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3ZpZXdfbWF0cml4Jyk7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuc2V0UHJvamVjdGlvbk1hdHJpeChhY3RpdmVTaGFkZXIsIGxvY2F0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKHNoYWRlciwgbG9jYXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgc2hhZGVyLnNldENvbnN0YW50TWF0cml4NHg0KFxyXG4gICAgICAgICAgICBsb2NhdGlvbixcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy5oZWlnaHQsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuZGVsZXRlU2hhZGVyKHRoaXMuc2hhZGVyKTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZE1lc2hJbmRleGVkOiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4ID0gdGhpcy50ZW1wTWF0cml4O1xyXG4gICAgICAgIHZhciBmcmFtZSA9IGdhbWVPYmplY3QuZnJhbWU7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdEYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gZ2FtZU9iamVjdC54IC0gY2FtZXJhLnNjcm9sbFggKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclg7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICB2YXIgc2NhbGVYID0gZ2FtZU9iamVjdC5zY2FsZVg7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IGdhbWVPYmplY3Quc2NhbGVZO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1nYW1lT2JqZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4TWF0cml4ID0gdGVtcE1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmO1xyXG4gICAgICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdhbWVPYmplY3QudmVydGljZXM7XHJcbiAgICAgICAgdmFyIHV2ID0gZ2FtZU9iamVjdC51djtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciB0b3RhbFZlcnRpY2VzID0gKGxlbmd0aCAvIDIpfDA7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gdGhpcy5pbmRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBnYW1lT2JqZWN0LmluZGljZXM7XHJcbiAgICAgICAgdmFyIGNvbG9ycyA9IGdhbWVPYmplY3QuY29sb3JzO1xyXG4gICAgICAgIHZhciBhbHBoYXMgPSBnYW1lT2JqZWN0LmFscGhhcztcclxuICAgICAgICB2YXIgaW5kZXhMZW5ndGggPSBpbmRpY2VzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaW5kZXhPZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICB0ZW1wTWF0cml4LmFwcGx5SVRSUyh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVkpO1xyXG5cclxuICAgICAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XHJcbiAgICAgICAgc3JjID0gdGVtcE1hdHJpeE1hdHJpeFsyXTtcclxuICAgICAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XHJcbiAgICAgICAgc3JmID0gdGVtcE1hdHJpeE1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgICAgIGNtYiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgICAgICBjbWMgPSBjYW1lcmFNYXRyaXhbMl07XHJcbiAgICAgICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgICAgIGNtZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgICAgICBjbWYgPSBjYW1lcmFNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgICAgICBtdmIgPSBzcmEgKiBjbWIgKyBzcmIgKiBjbWQ7XHJcbiAgICAgICAgbXZjID0gc3JjICogY21hICsgc3JkICogY21jO1xyXG4gICAgICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgICAgICBtdmUgPSBzcmUgKiBjbWEgKyBzcmYgKiBjbWMgKyBjbWU7XHJcbiAgICAgICAgbXZmID0gc3JlICogY21iICsgc3JmICogY21kICsgY21mO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRSZW5kZXJlcih0aGlzLCBmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlLCBnYW1lT2JqZWN0LnJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgaW5kZXhPZmZzZXQgPSB0aGlzLnZlcnRleENvdW50O1xyXG4gICAgICAgIHRoaXMuZHJhd0luZGV4ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZHJhd2luZ01lc2ggPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgKz0gdG90YWxWZXJ0aWNlcztcclxuXHJcbiAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSh0b3RhbFZlcnRpY2VzICogNik7XHJcblxyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICB2YXIgaW5kZXgwO1xyXG5cclxuICAgICAgICBmb3IgKGluZGV4ID0gMCwgaW5kZXgwID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHZlcnRpY2VzW2luZGV4ICsgMF07XHJcbiAgICAgICAgICAgIHZhciB5ID0gdmVydGljZXNbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgdmFyIHR4ID0geCAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgICAgIHZhciB0eSA9IHggKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHg7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2W2luZGV4ICsgMF07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dltpbmRleCArIDFdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gY29sb3JzW2luZGV4MF07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYXNbaW5kZXgwXTtcclxuICAgICAgICAgICAgaW5kZXgwICs9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZWxlbWVudENvdW50ID0gdGhpcy5lbGVtZW50Q291bnQ7XHJcblxyXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGluZGV4TGVuZ3RoOyArK2luZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbZWxlbWVudENvdW50ICsgaW5kZXhdID0gaW5kZXhPZmZzZXQgKyBpbmRpY2VzW2luZGV4XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IGluZGV4TGVuZ3RoO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRNZXNoOiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4ID0gdGhpcy50ZW1wTWF0cml4O1xyXG4gICAgICAgIHZhciBmcmFtZSA9IGdhbWVPYmplY3QuZnJhbWU7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdEYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gZ2FtZU9iamVjdC54IC0gY2FtZXJhLnNjcm9sbFggKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclg7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICB2YXIgc2NhbGVYID0gZ2FtZU9iamVjdC5zY2FsZVg7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IGdhbWVPYmplY3Quc2NhbGVZO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1nYW1lT2JqZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4TWF0cml4ID0gdGVtcE1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmO1xyXG4gICAgICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdhbWVPYmplY3QudmVydGljZXM7XHJcbiAgICAgICAgdmFyIHV2ID0gZ2FtZU9iamVjdC51djtcclxuICAgICAgICB2YXIgY29sb3JzID0gZ2FtZU9iamVjdC5jb2xvcnM7XHJcbiAgICAgICAgdmFyIGFscGhhcyA9IGdhbWVPYmplY3QuYWxwaGFzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHRvdGFsVmVydGljZXMgPSAobGVuZ3RoIC8gMil8MDtcclxuXHJcbiAgICAgICAgdGVtcE1hdHJpeC5hcHBseUlUUlModHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgcm90YXRpb24sIHNjYWxlWCwgc2NhbGVZKTtcclxuXHJcbiAgICAgICAgc3JhID0gdGVtcE1hdHJpeE1hdHJpeFswXTtcclxuICAgICAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xyXG4gICAgICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XHJcbiAgICAgICAgc3JkID0gdGVtcE1hdHJpeE1hdHJpeFszXTtcclxuICAgICAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xyXG4gICAgICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgICAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICAgICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgICAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICAgICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xyXG5cclxuICAgICAgICBtdmEgPSBzcmEgKiBjbWEgKyBzcmIgKiBjbWM7XHJcbiAgICAgICAgbXZiID0gc3JhICogY21iICsgc3JiICogY21kO1xyXG4gICAgICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcclxuICAgICAgICBtdmQgPSBzcmMgKiBjbWIgKyBzcmQgKiBjbWQ7XHJcbiAgICAgICAgbXZlID0gc3JlICogY21hICsgc3JmICogY21jICsgY21lO1xyXG4gICAgICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc2V0UmVuZGVyZXIodGhpcywgZnJhbWUudGV4dHVyZS5zb3VyY2VbZnJhbWUuc291cmNlSW5kZXhdLmdsVGV4dHVyZSwgZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIHRoaXMuZHJhd0luZGV4ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRyYXdpbmdNZXNoID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ICs9IHRvdGFsVmVydGljZXM7XHJcblxyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUodG90YWxWZXJ0aWNlcyAqIDYpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGluZGV4MCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1tpbmRleCArIDBdO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHZlcnRpY2VzW2luZGV4ICsgMV07XHJcbiAgICAgICAgICAgIHZhciB0eCA9IHggKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgICAgICB2YXIgdHkgPSB4ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHk7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dltpbmRleCArIDBdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IGNvbG9yc1tpbmRleDBdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGFzW2luZGV4MF07XHJcbiAgICAgICAgICAgIGluZGV4MCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWRkVGlsZVRleHR1cmVSZWN0OiBmdW5jdGlvbiAodGV4dHVyZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYWxwaGEsIHRpbnQsIHNjcm9sbEZhY3RvclgsIHNjcm9sbEZhY3RvclksIHRleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodCwgcmVjdFgsIHJlY3RZLCByZWN0VywgcmVjdEgsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0VTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgeHcgPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcclxuICAgICAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmYsIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTIsIHR4MywgdHkzO1xyXG4gICAgICAgIHZhciBoYWxmVGlsZVdpZHRoID0gKHdpZHRoKSAqIDAuNTtcclxuICAgICAgICB2YXIgaGFsZlRpbGVIZWlnaHQgPSAoaGVpZ2h0KSAqIDAuNTtcclxuICAgICAgICB2YXIgdTAgPSAocmVjdFggLSAoaGFsZlRpbGVXaWR0aCAtIDAuNSkpIC8gdGV4dHVyZVdpZHRoO1xyXG4gICAgICAgIHZhciB2MCA9IChyZWN0WSAtIChoYWxmVGlsZUhlaWdodCAtIDAuNSkpIC8gdGV4dHVyZUhlaWdodDtcclxuICAgICAgICB2YXIgdTEgPSAocmVjdFggKyAoaGFsZlRpbGVXaWR0aCAtIDAuNSkpIC8gdGV4dHVyZVdpZHRoO1xyXG4gICAgICAgIHZhciB2MSA9IChyZWN0WSArIChoYWxmVGlsZUhlaWdodCAtIDAuNSkpIC8gdGV4dHVyZUhlaWdodDtcclxuICAgICAgICB2YXIgc2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYICogc2Nyb2xsRmFjdG9yWDtcclxuICAgICAgICB2YXIgc2Nyb2xsWSA9IGNhbWVyYS5zY3JvbGxZICogc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICBcclxuICAgICAgICBtdmEgPSBjYW1lcmFNYXRyaXhbMF07XHJcbiAgICAgICAgbXZiID0gY2FtZXJhTWF0cml4WzFdO1xyXG4gICAgICAgIG12YyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgICAgICBtdmQgPSBjYW1lcmFNYXRyaXhbM107XHJcbiAgICAgICAgbXZlID0gY2FtZXJhTWF0cml4WzRdO1xyXG4gICAgICAgIG12ZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgdHgwID0gKHggKiBtdmEgKyB5ICogbXZjICsgbXZlKSAtIHNjcm9sbFg7XHJcbiAgICAgICAgdHkwID0gKHggKiBtdmIgKyB5ICogbXZkICsgbXZmKSAtIHNjcm9sbFk7XHJcbiAgICAgICAgdHgxID0gKHggKiBtdmEgKyB5aCAqIG12YyArIG12ZSkgLSBzY3JvbGxYO1xyXG4gICAgICAgIHR5MSA9ICh4ICogbXZiICsgeWggKiBtdmQgKyBtdmYpIC0gc2Nyb2xsWTtcclxuICAgICAgICB0eDIgPSAoeHcgKiBtdmEgKyB5aCAqIG12YyArIG12ZSkgLSBzY3JvbGxYO1xyXG4gICAgICAgIHR5MiA9ICh4dyAqIG12YiArIHloICogbXZkICsgbXZmKSAtIHNjcm9sbFk7XHJcbiAgICAgICAgdHgzID0gKHh3ICogbXZhICsgeSAqIG12YyArIG12ZSkgLSBzY3JvbGxYO1xyXG4gICAgICAgIHR5MyA9ICh4dyAqIG12YiArIHkgKiBtdmQgKyBtdmYpIC0gc2Nyb2xsWTtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNldFJlbmRlcmVyKHRoaXMsIHRleHR1cmUsIHJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5kcmF3SW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kcmF3aW5nTWVzaCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IDY7XHJcbiAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyNCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdjA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHUwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB2MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHYxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdjA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRTcHJpdGVUZXh0dXJlUmVjdDogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNhbWVyYSwgdGV4dHVyZSwgcmVjdFgsIHJlY3RZLCByZWN0V2lkdGgsIHJlY3RIZWlnaHQsIHRleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgdGVtcE1hdHJpeCA9IHRoaXMudGVtcE1hdHJpeDtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0RjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdFUzMiA9IHZlcnRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdFdpZHRoICogKGdhbWVPYmplY3QuZmxpcFggPyAtMSA6IDEpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSByZWN0SGVpZ2h0ICogKGdhbWVPYmplY3QuZmxpcFkgPyAtMSA6IDEpO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gZ2FtZU9iamVjdC54IC0gY2FtZXJhLnNjcm9sbFggKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclg7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICB2YXIgc2NhbGVYID0gZ2FtZU9iamVjdC5zY2FsZVg7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IGdhbWVPYmplY3Quc2NhbGVZO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1nYW1lT2JqZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4TWF0cml4ID0gdGVtcE1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIHggPSAtZ2FtZU9iamVjdC5kaXNwbGF5T3JpZ2luWCArICgocmVjdFdpZHRoKSAqIChnYW1lT2JqZWN0LmZsaXBYID8gMSA6IDAuMCkpO1xyXG4gICAgICAgIHZhciB5ID0gLWdhbWVPYmplY3QuZGlzcGxheU9yaWdpblkgKyAoKHJlY3RIZWlnaHQpICogKGdhbWVPYmplY3QuZmxpcFkgPyAxIDogMC4wKSk7XHJcbiAgICAgICAgdmFyIHh3ID0geCArIHJlY3RXaWR0aDtcclxuICAgICAgICB2YXIgeWggPSB5ICsgcmVjdEhlaWdodDtcclxuICAgICAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmYsIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTIsIHR4MywgdHkzO1xyXG4gICAgICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgICAgIHZhciBhbHBoYVRMID0gZ2FtZU9iamVjdC5fYWxwaGFUTDtcclxuICAgICAgICB2YXIgYWxwaGFUUiA9IGdhbWVPYmplY3QuX2FscGhhVFI7XHJcbiAgICAgICAgdmFyIGFscGhhQkwgPSBnYW1lT2JqZWN0Ll9hbHBoYUJMO1xyXG4gICAgICAgIHZhciBhbHBoYUJSID0gZ2FtZU9iamVjdC5fYWxwaGFCUjtcclxuICAgICAgICB2YXIgdGludFRMID0gZ2FtZU9iamVjdC5fdGludFRMO1xyXG4gICAgICAgIHZhciB0aW50VFIgPSBnYW1lT2JqZWN0Ll90aW50VFI7XHJcbiAgICAgICAgdmFyIHRpbnRCTCA9IGdhbWVPYmplY3QuX3RpbnRCTDtcclxuICAgICAgICB2YXIgdGludEJSID0gZ2FtZU9iamVjdC5fdGludEJSO1xyXG4gICAgICAgIHZhciB1MCA9IDA7IC8vIHJlY3RYIC8gdGV4dHVyZVdpZHRoO1xyXG4gICAgICAgIHZhciB2MCA9IDA7IC8vIHJlY3RZIC8gdGV4dHVyZUhlaWdodDtcclxuICAgICAgICB2YXIgdTEgPSAxOyAvLyB1MCArIChyZWN0V2lkdGggLyB0ZXh0dXJlV2lkdGgpO1xyXG4gICAgICAgIHZhciB2MSA9IDE7IC8vIHYwICsgKHJlY3RIZWlnaHQgLyB0ZXh0dXJlSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGVtcE1hdHJpeC5hcHBseUlUUlModHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgcm90YXRpb24sIHNjYWxlWCwgc2NhbGVZKTtcclxuXHJcbiAgICAgICAgc3JhID0gdGVtcE1hdHJpeE1hdHJpeFswXTtcclxuICAgICAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xyXG4gICAgICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XHJcbiAgICAgICAgc3JkID0gdGVtcE1hdHJpeE1hdHJpeFszXTtcclxuICAgICAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xyXG4gICAgICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgICAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICAgICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgICAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICAgICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xyXG5cclxuICAgICAgICBtdmEgPSBzcmEgKiBjbWEgKyBzcmIgKiBjbWM7XHJcbiAgICAgICAgbXZiID0gc3JhICogY21iICsgc3JiICogY21kO1xyXG4gICAgICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcclxuICAgICAgICBtdmQgPSBzcmMgKiBjbWIgKyBzcmQgKiBjbWQ7XHJcbiAgICAgICAgbXZlID0gc3JlICogY21hICsgc3JmICogY21jICsgY21lO1xyXG4gICAgICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjtcclxuICAgICAgICBcclxuICAgICAgICB0eDAgPSB4ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTAgPSB4ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDEgPSB4ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkxID0geCAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MiA9IHh3ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkyID0geHcgKiBtdmIgKyB5aCAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDMgPSB4dyAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkzID0geHcgKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIuc2V0UmVuZGVyZXIodGhpcywgdGV4dHVyZSwgZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIHRoaXMuZHJhd0luZGV4ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZHJhd2luZ01lc2ggPSBmYWxzZTtcclxuICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCArPSA2O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vICBUb3AgTGVmdFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHYwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50VEw7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhVEw7XHJcblxyXG4gICAgICAgIC8vICBCb3R0b20gTGVmdFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHYxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50Qkw7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhQkw7XHJcblxyXG4gICAgICAgIC8vICBCb3R0b20gUmlnaHRcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHUxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB2MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludEJSO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYUJSO1xyXG5cclxuICAgICAgICAvLyAgVG9wIFJpZ2h0XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdjA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnRUUjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGFUUjtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkU3ByaXRlVGV4dHVyZTogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNhbWVyYSwgdGV4dHVyZSwgdGV4dHVyZVdpZHRoLCB0ZXh0dXJlSGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4ID0gdGhpcy50ZW1wTWF0cml4O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0VTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgd2lkdGggPSB0ZXh0dXJlV2lkdGggKiAoZ2FtZU9iamVjdC5mbGlwWCA/IC0xIDogMSk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRleHR1cmVIZWlnaHQgKiAoZ2FtZU9iamVjdC5mbGlwWSA/IC0xIDogMSk7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVggPSBnYW1lT2JqZWN0LnggLSBjYW1lcmEuc2Nyb2xsWCAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgICAgICB2YXIgdHJhbnNsYXRlWSA9IGdhbWVPYmplY3QueSAtIGNhbWVyYS5zY3JvbGxZICogZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JZO1xyXG4gICAgICAgIHZhciBzY2FsZVggPSBnYW1lT2JqZWN0LnNjYWxlWDtcclxuICAgICAgICB2YXIgc2NhbGVZID0gZ2FtZU9iamVjdC5zY2FsZVk7XHJcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gLWdhbWVPYmplY3Qucm90YXRpb247XHJcbiAgICAgICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgICAgICB2YXIgeCA9IC1nYW1lT2JqZWN0LmRpc3BsYXlPcmlnaW5YICsgKCh0ZXh0dXJlV2lkdGgpICogKGdhbWVPYmplY3QuZmxpcFggPyAxIDogMC4wKSk7XHJcbiAgICAgICAgdmFyIHkgPSAtZ2FtZU9iamVjdC5kaXNwbGF5T3JpZ2luWSArICgodGV4dHVyZUhlaWdodCkgKiAoZ2FtZU9iamVjdC5mbGlwWSA/IDEgOiAwLjApKTtcclxuICAgICAgICB2YXIgeHcgPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcclxuICAgICAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmYsIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTIsIHR4MywgdHkzO1xyXG4gICAgICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgICAgIHZhciBhbHBoYVRMID0gZ2FtZU9iamVjdC5fYWxwaGFUTDtcclxuICAgICAgICB2YXIgYWxwaGFUUiA9IGdhbWVPYmplY3QuX2FscGhhVFI7XHJcbiAgICAgICAgdmFyIGFscGhhQkwgPSBnYW1lT2JqZWN0Ll9hbHBoYUJMO1xyXG4gICAgICAgIHZhciBhbHBoYUJSID0gZ2FtZU9iamVjdC5fYWxwaGFCUjtcclxuICAgICAgICB2YXIgdGludFRMID0gZ2FtZU9iamVjdC5fdGludFRMO1xyXG4gICAgICAgIHZhciB0aW50VFIgPSBnYW1lT2JqZWN0Ll90aW50VFI7XHJcbiAgICAgICAgdmFyIHRpbnRCTCA9IGdhbWVPYmplY3QuX3RpbnRCTDtcclxuICAgICAgICB2YXIgdGludEJSID0gZ2FtZU9iamVjdC5fdGludEJSO1xyXG5cclxuICAgICAgICB0ZW1wTWF0cml4LmFwcGx5SVRSUyh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVkpO1xyXG5cclxuICAgICAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XHJcbiAgICAgICAgc3JjID0gdGVtcE1hdHJpeE1hdHJpeFsyXTtcclxuICAgICAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XHJcbiAgICAgICAgc3JmID0gdGVtcE1hdHJpeE1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgICAgIGNtYiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgICAgICBjbWMgPSBjYW1lcmFNYXRyaXhbMl07XHJcbiAgICAgICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgICAgIGNtZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgICAgICBjbWYgPSBjYW1lcmFNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgICAgICBtdmIgPSBzcmEgKiBjbWIgKyBzcmIgKiBjbWQ7XHJcbiAgICAgICAgbXZjID0gc3JjICogY21hICsgc3JkICogY21jO1xyXG4gICAgICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgICAgICBtdmUgPSBzcmUgKiBjbWEgKyBzcmYgKiBjbWMgKyBjbWU7XHJcbiAgICAgICAgbXZmID0gc3JlICogY21iICsgc3JmICogY21kICsgY21mO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHR4MCA9IHggKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MCA9IHggKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MSA9IHggKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTEgPSB4ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgyID0geHcgKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTIgPSB4dyAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MyA9IHh3ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTMgPSB4dyAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRSZW5kZXJlcih0aGlzLCB0ZXh0dXJlLCBnYW1lT2JqZWN0LnJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5kcmF3SW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kcmF3aW5nTWVzaCA9IGZhbHNlO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjQpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IDY7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gIFRvcCBMZWZ0XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50VEw7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhVEw7XHJcblxyXG4gICAgICAgIC8vICBCb3R0b20gTGVmdFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gMDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gMTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludEJMO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYUJMO1xyXG5cclxuICAgICAgICAvLyAgQm90dG9tIFJpZ2h0XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50QlI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhQlI7XHJcblxyXG4gICAgICAgIC8vICBUb3AgUmlnaHRcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnRUUjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGFUUjtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkU3ByaXRlOiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4ID0gdGhpcy50ZW1wTWF0cml4O1xyXG4gICAgICAgIHZhciBmcmFtZSA9IGdhbWVPYmplY3QuZnJhbWU7XHJcbiAgICAgICAgdmFyIGZvcmNlRmxpcFkgPSAoZnJhbWUudGV4dHVyZS5zb3VyY2VbZnJhbWUuc291cmNlSW5kZXhdLmdsVGV4dHVyZS5pc1JlbmRlclRleHR1cmUgPyB0cnVlIDogZmFsc2UpO1xyXG4gICAgICAgIHZhciBmbGlwWCA9IGdhbWVPYmplY3QuZmxpcFg7XHJcbiAgICAgICAgdmFyIGZsaXBZID0gZ2FtZU9iamVjdC5mbGlwWSBeIGZvcmNlRmxpcFk7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdEYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciB1dnMgPSBmcmFtZS51dnM7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGggKiAoZmxpcFggPyAtMSA6IDEpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBmcmFtZS5oZWlnaHQgKiAoZmxpcFkgPyAtMSA6IDEpO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gZ2FtZU9iamVjdC54IC0gY2FtZXJhLnNjcm9sbFggKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclg7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICB2YXIgc2NhbGVYID0gZ2FtZU9iamVjdC5zY2FsZVg7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IGdhbWVPYmplY3Quc2NhbGVZO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1nYW1lT2JqZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4TWF0cml4ID0gdGVtcE1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIHggPSAtZ2FtZU9iamVjdC5kaXNwbGF5T3JpZ2luWCArIGZyYW1lLnggKyAoKGZyYW1lLndpZHRoKSAqIChmbGlwWCA/IDEgOiAwLjApKTtcclxuICAgICAgICB2YXIgeSA9IC1nYW1lT2JqZWN0LmRpc3BsYXlPcmlnaW5ZICsgZnJhbWUueSArICgoZnJhbWUuaGVpZ2h0KSAqIChmbGlwWSA/IDEgOiAwLjApKTtcclxuICAgICAgICB2YXIgeHcgPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcclxuICAgICAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmYsIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTIsIHR4MywgdHkzO1xyXG4gICAgICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgICAgIHZhciBhbHBoYVRMID0gZ2FtZU9iamVjdC5fYWxwaGFUTDtcclxuICAgICAgICB2YXIgYWxwaGFUUiA9IGdhbWVPYmplY3QuX2FscGhhVFI7XHJcbiAgICAgICAgdmFyIGFscGhhQkwgPSBnYW1lT2JqZWN0Ll9hbHBoYUJMO1xyXG4gICAgICAgIHZhciBhbHBoYUJSID0gZ2FtZU9iamVjdC5fYWxwaGFCUjtcclxuICAgICAgICB2YXIgdGludFRMID0gZ2FtZU9iamVjdC5fdGludFRMO1xyXG4gICAgICAgIHZhciB0aW50VFIgPSBnYW1lT2JqZWN0Ll90aW50VFI7XHJcbiAgICAgICAgdmFyIHRpbnRCTCA9IGdhbWVPYmplY3QuX3RpbnRCTDtcclxuICAgICAgICB2YXIgdGludEJSID0gZ2FtZU9iamVjdC5fdGludEJSO1xyXG5cclxuICAgICAgICB0ZW1wTWF0cml4LmFwcGx5SVRSUyh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVkpO1xyXG5cclxuICAgICAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XHJcbiAgICAgICAgc3JjID0gdGVtcE1hdHJpeE1hdHJpeFsyXTtcclxuICAgICAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XHJcbiAgICAgICAgc3JmID0gdGVtcE1hdHJpeE1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgICAgIGNtYiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgICAgICBjbWMgPSBjYW1lcmFNYXRyaXhbMl07XHJcbiAgICAgICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgICAgIGNtZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgICAgICBjbWYgPSBjYW1lcmFNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgICAgICBtdmIgPSBzcmEgKiBjbWIgKyBzcmIgKiBjbWQ7XHJcbiAgICAgICAgbXZjID0gc3JjICogY21hICsgc3JkICogY21jO1xyXG4gICAgICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgICAgICBtdmUgPSBzcmUgKiBjbWEgKyBzcmYgKiBjbWMgKyBjbWU7XHJcbiAgICAgICAgbXZmID0gc3JlICogY21iICsgc3JmICogY21kICsgY21mO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHR4MCA9IHggKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MCA9IHggKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MSA9IHggKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTEgPSB4ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgyID0geHcgKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTIgPSB4dyAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MyA9IHh3ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTMgPSB4dyAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRSZW5kZXJlcih0aGlzLCBmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlLCBnYW1lT2JqZWN0LnJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5kcmF3SW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kcmF3aW5nTWVzaCA9IGZhbHNlO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjQpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IDY7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gIFRvcCBMZWZ0XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludFRMO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYVRMO1xyXG5cclxuICAgICAgICAvLyAgQm90dG9tIExlZnRcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50Qkw7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhQkw7XHJcblxyXG4gICAgICAgIC8vICBCb3R0b20gUmlnaHRcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50QlI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhQlI7XHJcblxyXG4gICAgICAgIC8vICBUb3AgUmlnaHRcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50VFI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhVFI7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ByaXRlQmF0Y2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3Nwcml0ZWJhdGNoL1Nwcml0ZUJhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA5MDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0ge1xyXG5cclxuICAgIC8vIFZFUlRFWF9TSVpFID0gKHNpemVvZih2ZWMyKSAqIDQpICsgKHNpemVvZihmbG9hdCkgKyBzaXplb2YodWludDMyKSlcclxuICAgIFZFUlRFWF9TSVpFOiAyNCxcclxuICAgIElOREVYX1NJWkU6IDIsXHJcbiAgICBTUFJJVEVfVkVSVEVYX0NPVU5UOiA0LFxyXG4gICAgU1BSSVRFX0lOREVYX0NPVU5UOiA2LFxyXG5cclxuICAgIC8vIEhvdyBtYW55IDMyLWJpdCBjb21wb25lbnRzIGRvZXMgdGhlIHZlcnRleCBoYXZlLlxyXG4gICAgU1BSSVRFX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDYsXHJcblxyXG4gICAgLy8gQ2FuJ3QgYmUgYmlnZ2VyIHNpbmNlIGluZGV4IGFyZSAxNi1iaXRcclxuICAgIE1BWF9TUFJJVEVTOiAyMDAwXHJcbiAgICBcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3Nwcml0ZWJhdGNoL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5MDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG52YXIgRGF0YUJ1ZmZlcjE2ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvRGF0YUJ1ZmZlcjE2Jyk7XHJcbnZhciBEYXRhQnVmZmVyMzIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9EYXRhQnVmZmVyMzInKTtcclxudmFyIFBIQVNFUl9DT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBUZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi9zaGFkZXJzL1RleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlcicpO1xyXG52YXIgVHJhbnNmb3JtTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vZ2FtZW9iamVjdHMvY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXgnKTtcclxuXHJcbnZhciBUaWxlQmF0Y2ggPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gVGlsZUJhdGNoIChnYW1lLCBnbCwgbWFuYWdlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuICAgICAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICAgICAgdGhpcy5tYXhTcHJpdGVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRlbXBNYXRyaXggPSBuZXcgVHJhbnNmb3JtTWF0cml4KCk7XHJcblxyXG4gICAgICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0KHRoaXMuZ2xDb250ZXh0KTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGdsKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIzMihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULlNQUklURV9WRVJURVhfQ09VTlQgKiBDT05TVC5NQVhfU1BSSVRFUyk7XHJcbiAgICAgICAgdmFyIGluZGV4RGF0YUJ1ZmZlciA9IG5ldyBEYXRhQnVmZmVyMTYoQ09OU1QuSU5ERVhfU0laRSAqIENPTlNULlNQUklURV9JTkRFWF9DT1VOVCAqIENPTlNULk1BWF9TUFJJVEVTKTtcclxuICAgICAgICB2YXIgc2hhZGVyID0gdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5jcmVhdGVTaGFkZXIoJ1RleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlcicsIFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlcik7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0ID0gdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3QgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCksIGdsLlNUUkVBTV9EUkFXKTtcclxuICAgICAgICB2YXIgdmlld01hdHJpeExvY2F0aW9uID0gc2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndV92aWV3X21hdHJpeCcpO1xyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgbWF4ID0gQ09OU1QuTUFYX1NQUklURVMgKiBDT05TVC5TUFJJVEVfSU5ERVhfQ09VTlQ7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBpbmRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0ID0gdmVydGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gdmlld01hdHJpeExvY2F0aW9uO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3QuYWRkQXR0cmlidXRlKHNoYWRlci5nZXRBdHRyaWJMb2NhdGlvbignYV9wb3NpdGlvbicpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAwKTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3QuYWRkQXR0cmlidXRlKHNoYWRlci5nZXRBdHRyaWJMb2NhdGlvbignYV90ZXhfY29vcmQnKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgOCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfY29sb3InKSwgMywgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDE2KTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3QuYWRkQXR0cmlidXRlKHNoYWRlci5nZXRBdHRyaWJMb2NhdGlvbignYV9hbHBoYScpLCAxLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAyMCk7XHJcblxyXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBpbmRleCBidWZmZXIgb25seSBvbmNlXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXhBID0gMCwgaW5kZXhCID0gMDsgaW5kZXhBIDwgbWF4OyBpbmRleEEgKz0gQ09OU1QuU1BSSVRFX0lOREVYX0NPVU5ULCBpbmRleEIgKz0gQ09OU1QuU1BSSVRFX1ZFUlRFWF9DT1VOVClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDBdID0gaW5kZXhCICsgMDtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMV0gPSBpbmRleEIgKyAxO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAyXSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDNdID0gaW5kZXhCICsgMDtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNF0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA1XSA9IGluZGV4QiArIDM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbmRleEJ1ZmZlck9iamVjdC51cGRhdGVSZXNvdXJjZShpbmRleEJ1ZmZlciwgMCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzaG91bGRGbHVzaDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlTGVuZ3RoKCkgPj0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoc2hhZGVyID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlci5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNoYWRlci5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24sIHNoYWRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0LmJpbmQoKTtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoc2hhZGVyLCByZW5kZXJUYXJnZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRDb3VudCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHJlbmRlclRhcmdldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYmluZChzaGFkZXIpO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0LnVwZGF0ZVJlc291cmNlKHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSwgMCk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuZWxlbWVudENvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcblxyXG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG5cclxuICAgICAgICBpZiAocmVuZGVyVGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24sIHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICB2YXIgYWN0aXZlU2hhZGVyID0gc2hhZGVyICE9PSB1bmRlZmluZWQgPyBzaGFkZXIgOiB0aGlzLnNoYWRlcjtcclxuICAgICAgICB2YXIgbG9jYXRpb24gPSBhY3RpdmVTaGFkZXIgPT0gdGhpcy5zaGFkZXIgPyB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA6IGFjdGl2ZVNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3Vfdmlld19tYXRyaXgnKTtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5zZXRQcm9qZWN0aW9uTWF0cml4KGFjdGl2ZVNoYWRlciwgbG9jYXRpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoc2hhZGVyLCBsb2NhdGlvbilcclxuICAgIHtcclxuICAgICAgICBzaGFkZXIuc2V0Q29uc3RhbnRNYXRyaXg0eDQoXHJcbiAgICAgICAgICAgIGxvY2F0aW9uLFxyXG4gICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIDIgLyB0aGlzLndpZHRoLCAwLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgLTIgLyB0aGlzLmhlaWdodCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIDAsIDEsIDEsXHJcbiAgICAgICAgICAgICAgICAtMSwgMSwgMCwgMFxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVTaGFkZXIodGhpcy5zaGFkZXIpO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QnVmZmVyT2JqZWN0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkVGlsZVNwcml0ZTogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNhbWVyYSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGVtcE1hdHJpeCA9IHRoaXMudGVtcE1hdHJpeDtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0RjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdFUzMiA9IHZlcnRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZ2FtZU9iamVjdC53aWR0aCAqIChnYW1lT2JqZWN0LmZsaXBYID8gLTEgOiAxKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gZ2FtZU9iamVjdC5oZWlnaHQgKiAoZ2FtZU9iamVjdC5mbGlwWSA/IC0xIDogMSk7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVggPSBnYW1lT2JqZWN0LnggLSBjYW1lcmEuc2Nyb2xsWCAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgICAgICB2YXIgdHJhbnNsYXRlWSA9IGdhbWVPYmplY3QueSAtIGNhbWVyYS5zY3JvbGxZICogZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JZO1xyXG4gICAgICAgIHZhciBzY2FsZVggPSBnYW1lT2JqZWN0LnNjYWxlWDtcclxuICAgICAgICB2YXIgc2NhbGVZID0gZ2FtZU9iamVjdC5zY2FsZVk7XHJcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gLWdhbWVPYmplY3Qucm90YXRpb247XHJcbiAgICAgICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgICAgICB2YXIgZGlzcGxheU9yaWdpblggPSBnYW1lT2JqZWN0Lm9yaWdpblggKiBnYW1lT2JqZWN0LndpZHRoO1xyXG4gICAgICAgIHZhciBkaXNwbGF5T3JpZ2luWSA9IGdhbWVPYmplY3Qub3JpZ2luWSAqIGdhbWVPYmplY3QuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB4ID0gLWRpc3BsYXlPcmlnaW5YICsgKChnYW1lT2JqZWN0LndpZHRoKSAqIChnYW1lT2JqZWN0LmZsaXBYID8gMSA6IDAuMCkpO1xyXG4gICAgICAgIHZhciB5ID0gLWRpc3BsYXlPcmlnaW5ZICsgKChnYW1lT2JqZWN0LmhlaWdodCkgKiAoZ2FtZU9iamVjdC5mbGlwWSA/IDEgOiAwLjApKTtcclxuICAgICAgICB2YXIgeHcgPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcclxuICAgICAgICB2YXIgdTAgPSAwO1xyXG4gICAgICAgIHZhciB2MCA9IDA7XHJcbiAgICAgICAgdmFyIHUxID0gd2lkdGggLyBnYW1lT2JqZWN0LmZyYW1lLndpZHRoO1xyXG4gICAgICAgIHZhciB2MSA9IGhlaWdodCAvIGdhbWVPYmplY3QuZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjYW1lcmFNYXRyaXggPSBjYW1lcmEubWF0cml4Lm1hdHJpeDtcclxuICAgICAgICB2YXIgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZiwgdHgwLCB0eTAsIHR4MSwgdHkxLCB0eDIsIHR5MiwgdHgzLCB0eTM7XHJcbiAgICAgICAgdmFyIHNyYSwgc3JiLCBzcmMsIHNyZCwgc3JlLCBzcmYsIGNtYSwgY21iLCBjbWMsIGNtZCwgY21lLCBjbWY7XHJcbiAgICAgICAgdmFyIGFscGhhID0gZ2FtZU9iamVjdC5hbHBoYTtcclxuICAgICAgICB2YXIgdGlsZVBvc2l0aW9uWCA9IGdhbWVPYmplY3QudGlsZVBvc2l0aW9uWCAvIGdhbWVPYmplY3QuZnJhbWUud2lkdGg7XHJcbiAgICAgICAgdmFyIHRpbGVQb3NpdGlvblkgPSBnYW1lT2JqZWN0LnRpbGVQb3NpdGlvblkgLyBnYW1lT2JqZWN0LmZyYW1lLmhlaWdodDtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IGdhbWVPYmplY3QudGlsZVRleHR1cmU7XHJcbiAgICAgICAgdmFyIHRpbnRUTCA9IGdhbWVPYmplY3QuX3RpbnRUTDtcclxuICAgICAgICB2YXIgdGludFRSID0gZ2FtZU9iamVjdC5fdGludFRSO1xyXG4gICAgICAgIHZhciB0aW50QkwgPSBnYW1lT2JqZWN0Ll90aW50Qkw7XHJcbiAgICAgICAgdmFyIHRpbnRCUiA9IGdhbWVPYmplY3QuX3RpbnRCUjtcclxuXHJcbiAgICAgICAgdGVtcE1hdHJpeC5hcHBseUlUUlModHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgcm90YXRpb24sIHNjYWxlWCwgc2NhbGVZKTtcclxuXHJcbiAgICAgICAgc3JhID0gdGVtcE1hdHJpeE1hdHJpeFswXTtcclxuICAgICAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xyXG4gICAgICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XHJcbiAgICAgICAgc3JkID0gdGVtcE1hdHJpeE1hdHJpeFszXTtcclxuICAgICAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xyXG4gICAgICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgICAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICAgICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgICAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICAgICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xyXG5cclxuICAgICAgICBtdmEgPSBzcmEgKiBjbWEgKyBzcmIgKiBjbWM7XHJcbiAgICAgICAgbXZiID0gc3JhICogY21iICsgc3JiICogY21kO1xyXG4gICAgICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcclxuICAgICAgICBtdmQgPSBzcmMgKiBjbWIgKyBzcmQgKiBjbWQ7XHJcbiAgICAgICAgbXZlID0gc3JlICogY21hICsgc3JmICogY21jICsgY21lO1xyXG4gICAgICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjtcclxuICAgICAgICBcclxuICAgICAgICB0eDAgPSB4ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTAgPSB4ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDEgPSB4ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkxID0geCAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MiA9IHh3ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkyID0geHcgKiBtdmIgKyB5aCAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDMgPSB4dyAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkzID0geHcgKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIuc2V0UmVuZGVyZXIodGhpcywgdGV4dHVyZSwgZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjQpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IDY7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gIFRvcCBMZWZ0XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1MCArIHRpbGVQb3NpdGlvblg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHYwICsgdGlsZVBvc2l0aW9uWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludFRMO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgLy8gIEJvdHRvbSBMZWZ0XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1MCArIHRpbGVQb3NpdGlvblg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHYxICsgdGlsZVBvc2l0aW9uWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gdGludEJMO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgLy8gIEJvdHRvbSBSaWdodFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdTEgKyB0aWxlUG9zaXRpb25YO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB2MSArIHRpbGVQb3NpdGlvblk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IHRpbnRCUjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIC8vICBUb3AgUmlnaHRcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHUxICsgdGlsZVBvc2l0aW9uWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdjAgKyB0aWxlUG9zaXRpb25ZO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50VFI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVCYXRjaDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvdGlsZWJhdGNoL1RpbGVCYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gOTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHtcclxuXHJcbiAgICAvLyBWRVJURVhfU0laRSA9IChzaXplb2YodmVjMikgKiA0KSArIChzaXplb2YoZmxvYXQpICsgc2l6ZW9mKHVpbnQzMikpXHJcbiAgICBWRVJURVhfU0laRTogMjQsXHJcbiAgICBJTkRFWF9TSVpFOiAyLFxyXG4gICAgU1BSSVRFX1ZFUlRFWF9DT1VOVDogNCxcclxuICAgIFNQUklURV9JTkRFWF9DT1VOVDogNixcclxuXHJcbiAgICAvLyBIb3cgbWFueSAzMi1iaXQgY29tcG9uZW50cyBkb2VzIHRoZSB2ZXJ0ZXggaGF2ZS5cclxuICAgIFNQUklURV9WRVJURVhfQ09NUE9ORU5UX0NPVU5UOiA2LFxyXG5cclxuICAgIC8vIENhbid0IGJlIGJpZ2dlciBzaW5jZSBpbmRleCBhcmUgMTYtYml0XHJcbiAgICBNQVhfU1BSSVRFUzogMjAwMFxyXG4gICAgXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy90aWxlYmF0Y2gvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDkxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBEYXRhQnVmZmVyMTYgPSByZXF1aXJlKCcuLi8uLi91dGlscy9EYXRhQnVmZmVyMTYnKTtcclxudmFyIERhdGFCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIzMicpO1xyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIFRpbGVtYXBTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi9zaGFkZXJzL1RpbGVtYXBTaGFkZXInKTtcclxuXHJcbnZhciBUaWxlbWFwUmVuZGVyZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gVGlsZW1hcFJlbmRlcmVyIChnYW1lLCBnbCwgbWFuYWdlcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuICAgICAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcclxuXHJcbiAgICAgICAgICAgIFdlYkdMQ29udGV4dE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIGFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZ2wpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlU2hhZGVyKCdUaWxlbWFwU2hhZGVyJywgVGlsZW1hcFNoYWRlcik7XHJcbiAgICAgICAgdmFyIHZpZXdNYXRyaXhMb2NhdGlvbiA9IHNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3Vfdmlld19tYXRyaXgnKTtcclxuICAgICAgICB2YXIgc2Nyb2xsTG9jYXRpb24gPSBzaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3Njcm9sbCcpO1xyXG4gICAgICAgIHZhciBzY3JvbGxGYWN0b3JMb2NhdGlvbiA9IHNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3Vfc2Nyb2xsX2ZhY3RvcicpO1xyXG4gICAgICAgIHZhciB0aWxlbWFwUG9zaXRpb25Mb2NhdGlvbiA9IHNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3VfdGlsZW1hcF9wb3NpdGlvbicpO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuICAgICAgICB0aGlzLnNjcm9sbExvY2F0aW9uID0gc2Nyb2xsTG9jYXRpb247XHJcbiAgICAgICAgdGhpcy5zY3JvbGxGYWN0b3JMb2NhdGlvbiA9IHNjcm9sbEZhY3RvckxvY2F0aW9uO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcFBvc2l0aW9uTG9jYXRpb24gPSB0aWxlbWFwUG9zaXRpb25Mb2NhdGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIHNob3VsZEZsdXNoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgaXNGdWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgXHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNoYWRlciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uLCBzaGFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZmx1c2g6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24sIHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICB2YXIgYWN0aXZlU2hhZGVyID0gc2hhZGVyICE9PSB1bmRlZmluZWQgPyBzaGFkZXIgOiB0aGlzLnNoYWRlcjtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgYWN0aXZlU2hhZGVyLnNldENvbnN0YW50TWF0cml4NHg0KFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbixcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy5oZWlnaHQsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuZGVsZXRlU2hhZGVyKHRoaXMuc2hhZGVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVtYXBSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvdGlsZW1hcHJlbmRlcmVyL1RpbGVtYXBSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gOTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDdXJyZW50SW5kZXhCdWZmZXIgPSBudWxsO1xyXG52YXIgSW5kZXhCdWZmZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gSW5kZXhCdWZmZXIgKGdsLCBidWZmZXJPYmplY3QpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyVGFyZ2V0ID0gZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XHJcbiAgICAgICAgdGhpcy5idWZmZXJPYmplY3QgPSBidWZmZXJPYmplY3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICBpZiAoQ3VycmVudEluZGV4QnVmZmVyICE9PSB0aGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ3VycmVudEluZGV4QnVmZmVyID0gdGhpcztcclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXJPYmplY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVJlc291cmNlOiBmdW5jdGlvbiAoYnVmZmVyRGF0YSwgb2Zmc2V0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgIGlmIChDdXJyZW50SW5kZXhCdWZmZXIgIT09IHRoaXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDdXJyZW50SW5kZXhCdWZmZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG9mZnNldCwgYnVmZmVyRGF0YSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5JbmRleEJ1ZmZlci5TZXREaXJ0eSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIEN1cnJlbnRJbmRleEJ1ZmZlciA9IG51bGw7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4QnVmZmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3Jlc291cmNlcy9JbmRleEJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gOTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoZnJhbWVidWZmZXJPYmplY3QsIHdpZHRoLCBoZWlnaHQsIGNvbG9yQnVmZmVyLCBkZXB0aFN0ZW5jaWxCdWZmZXIpXHJcbntcclxuICAgIHRoaXMuZnJhbWVidWZmZXJPYmplY3QgPSBmcmFtZWJ1ZmZlck9iamVjdDtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgdGhpcy5jb2xvckJ1ZmZlciA9IGNvbG9yQnVmZmVyO1xyXG4gICAgdGhpcy5kZXB0aFN0ZW5jaWxCdWZmZXIgPSBkZXB0aFN0ZW5jaWxCdWZmZXI7XHJcbiAgICB0aGlzLnNob3VsZENsZWFyID0gZmFsc2U7XHJcbiAgICB0aGlzLmNsZWFyQWxwaGEgPSAwLjA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlclRhcmdldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvUmVuZGVyVGFyZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA5MTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEN1cnJlbnRTaGFkZXIgPSBudWxsO1xyXG52YXIgU2hhZGVyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFNoYWRlciAobmFtZSwgZ2wsIHByb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XHJcbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmRBdHRyaWJMb2NhdGlvbjogZnVuY3Rpb24gKGluZGV4LCBuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgaW5kZXgsIG5hbWUpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uOiBmdW5jdGlvbiAobmFtZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0QXR0cmliTG9jYXRpb246IGZ1bmN0aW9uIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENvbnN0YW50RmxvYXQxOiBmdW5jdGlvbiAobG9jYXRpb24sIHgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMWYobG9jYXRpb24sIHgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50RmxvYXQyOiBmdW5jdGlvbiAobG9jYXRpb24sIHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMmYobG9jYXRpb24sIHgsIHkpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50RmxvYXQzOiBmdW5jdGlvbiAobG9jYXRpb24sIHgsIHksIHopXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtM2YobG9jYXRpb24sIHgsIHksIHopO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50RmxvYXQ0OiBmdW5jdGlvbiAobG9jYXRpb24sIHgsIHksIHosIHcpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtNGYobG9jYXRpb24sIHgsIHksIHosIHcpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50SW50MTogZnVuY3Rpb24gKGxvY2F0aW9uLCB4KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRDb25zdGFudEludDI6IGZ1bmN0aW9uIChsb2NhdGlvbiwgeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJpbmQoKTtcclxuICAgICAgICB0aGlzLmdsLnVuaWZvcm0yaShsb2NhdGlvbiwgeCwgeSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0Q29uc3RhbnRJbnQzOiBmdW5jdGlvbiAobG9jYXRpb24sIHgsIHksIHopXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtM2kobG9jYXRpb24sIHgsIHksIHopO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50SW50NDogZnVuY3Rpb24gKGxvY2F0aW9uLCB4LCB5LCB6LCB3KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTRpKGxvY2F0aW9uLCB4LCB5LCB6LCB3KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRDb25zdGFudE1hdHJpeDJ4MjogZnVuY3Rpb24gKGxvY2F0aW9uLCBmbG9hdEFycmF5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDJmdihsb2NhdGlvbiwgZmFsc2UsIGZsb2F0QXJyYXkpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50TWF0cml4M3gzOiBmdW5jdGlvbiAobG9jYXRpb24sIGZsb2F0QXJyYXkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgZmxvYXRBcnJheSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0Q29uc3RhbnRNYXRyaXg0eDQ6IGZ1bmN0aW9uIChsb2NhdGlvbiwgZmxvYXRBcnJheSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJpbmQoKTtcclxuICAgICAgICB0aGlzLmdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCBmbG9hdEFycmF5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEN1cnJlbnRTaGFkZXIgIT09IHRoaXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDdXJyZW50U2hhZGVyID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuU2hhZGVyLlNldERpcnR5ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgQ3VycmVudFNoYWRlciA9IG51bGw7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvU2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbnZhciBUZXh0dXJlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFRleHR1cmUgKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5pc1JlbmRlclRleHR1cmUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3Jlc291cmNlcy9UZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSA5MTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdCdWZmZXJTaGFkZXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgZnJhZyA9IFtcclxuICAgICAgICAnI2V4dGVuc2lvbiBHTF9FWFRfZHJhd19idWZmZXJzIDogcmVxdWlyZScsXHJcblxyXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG5cclxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdU1haW5UZXh0dXJlOycsXHJcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVOb3JtVGV4dHVyZTsnLFxyXG5cclxuICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMyB2X2NvbG9yOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdl9hbHBoYTsnLFxyXG5cclxuICAgICAgICAndm9pZCBtYWluKCknLFxyXG4gICAgICAgICd7JyxcclxuICAgICAgICAnICAgIHZlYzQgc3ByaXRlQ29sb3IgPSB0ZXh0dXJlMkQodU1haW5UZXh0dXJlLCB2X3RleF9jb29yZCkgKiB2ZWM0KHZfY29sb3IsIHZfYWxwaGEpOycsXHJcbiAgICAgICAgJyAgICB2ZWMzIHNwcml0ZU5vcm1hbCA9IHRleHR1cmUyRCh1Tm9ybVRleHR1cmUsIHZfdGV4X2Nvb3JkKS5yZ2I7JyxcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgJyAgICBnbF9GcmFnRGF0YVswXSA9IHNwcml0ZUNvbG9yOycsXHJcbiAgICAgICAgJyAgICBnbF9GcmFnRGF0YVsxXSA9IHZlYzQoc3ByaXRlTm9ybWFsLCBzcHJpdGVDb2xvci5hKTsnLFxyXG4gICAgICAgICd9J1xyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gZnJhZy5qb2luKCdcXG4nKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR0J1ZmZlclNoYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0dCdWZmZXJTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGlnaHRGcmFnbWVudFNoYWRlciA9IGZ1bmN0aW9uIChtYXhMaWdodHMpXHJcbntcclxuICAgIHZhciBmcmFnID0gW1xyXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG5cclxuICAgICAgICAnc3RydWN0IExpZ2h0JyxcclxuICAgICAgICAneycsXHJcbiAgICAgICAgJyAgICB2ZWMzIHBvc2l0aW9uOycsXHJcbiAgICAgICAgJyAgICB2ZWMzIGNvbG9yOycsXHJcbiAgICAgICAgJyAgICBmbG9hdCBhdHRlbnVhdGlvbjsnLFxyXG4gICAgICAgICcgICAgZmxvYXQgcmFkaXVzOycsXHJcbiAgICAgICAgJ307JyxcclxuXHJcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q2FtZXJhOyAvKiB4LCB5LCByb3RhdGlvbiwgem9vbSAqLycsXHJcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjsnLFxyXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1TWFpblRleHR1cmU7JyxcclxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdU5vcm1UZXh0dXJlOycsXHJcbiAgICAgICAgJ3VuaWZvcm0gdmVjMyB1QW1iaWVudExpZ2h0Q29sb3I7JyxcclxuICAgICAgICAndW5pZm9ybSBMaWdodCB1TGlnaHRzWycgKyBtYXhMaWdodHMgKyAnXTsnLFxyXG5cclxuICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMyB2X2NvbG9yOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdl9hbHBoYTsnLFxyXG5cclxuICAgICAgICAndm9pZCBtYWluKCknLFxyXG4gICAgICAgICd7JyxcclxuICAgICAgICAnICAgIHZlYzMgZmluYWxDb2xvciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7JyxcclxuICAgICAgICAnICAgIHZlYzQgc3ByaXRlQ29sb3IgPSB0ZXh0dXJlMkQodU1haW5UZXh0dXJlLCB2X3RleF9jb29yZCkgKiB2ZWM0KHZfY29sb3IsIHZfYWxwaGEpOycsXHJcbiAgICAgICAgJyAgICB2ZWMzIHNwcml0ZU5vcm1hbCA9IHRleHR1cmUyRCh1Tm9ybVRleHR1cmUsIHZfdGV4X2Nvb3JkKS5yZ2I7JyxcclxuICAgICAgICAnICAgIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKHZlYzMoc3ByaXRlTm9ybWFsICogMi4wIC0gMS4wKSk7JyxcclxuICAgICAgICAnICAgIHZlYzIgcmVzID0gdmVjMihtaW4odVJlc29sdXRpb24ueCwgdVJlc29sdXRpb24ueSkpICogdUNhbWVyYS53OycsXHJcblxyXG4gICAgICAgICcgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8ICcgKyBtYXhMaWdodHMgKyAnOyArK2luZGV4KScsXHJcbiAgICAgICAgJyAgICB7JyxcclxuICAgICAgICAnICAgICAgICBMaWdodCBsaWdodCA9IHVMaWdodHNbaW5kZXhdOycsXHJcbiAgICAgICAgJyAgICAgICAgdmVjMyBsaWdodERpciA9IHZlYzMoKGxpZ2h0LnBvc2l0aW9uLnh5IC8gcmVzKSAtIChnbF9GcmFnQ29vcmQueHkgLyByZXMpLCBsaWdodC5wb3NpdGlvbi56KTsnLFxyXG4gICAgICAgICcgICAgICAgIHZlYzMgbGlnaHROb3JtYWwgPSBub3JtYWxpemUobGlnaHREaXIpOycsXHJcbiAgICAgICAgJyAgICAgICAgZmxvYXQgZGlzdFRvU3VyZiA9IGxlbmd0aChsaWdodERpcikgKiB1Q2FtZXJhLnc7JyxcclxuICAgICAgICAnICAgICAgICBmbG9hdCBkaWZmdXNlRmFjdG9yID0gbWF4KGRvdChub3JtYWwsIGxpZ2h0Tm9ybWFsKSwgMC4wKTsnLFxyXG4gICAgICAgICcgICAgICAgIGZsb2F0IHJhZGl1cyA9IChsaWdodC5yYWRpdXMgLyByZXMueCAqIHVDYW1lcmEudykgKiB1Q2FtZXJhLnc7JyxcclxuICAgICAgICAnICAgICAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMCAtIGRpc3RUb1N1cmYgKiBkaXN0VG9TdXJmIC8gKHJhZGl1cyAqIHJhZGl1cyksIDAuMCwgMS4wKTsnLFxyXG4gICAgICAgICcgICAgICAgIHZlYzMgZGlmZnVzZSA9IGxpZ2h0LmNvbG9yICogc3ByaXRlQ29sb3IucmdiICogZGlmZnVzZUZhY3RvcjsnLFxyXG4gICAgICAgICcgICAgICAgIGZpbmFsQ29sb3IgKz0gYXR0ZW51YXRpb24gKiBkaWZmdXNlOycsXHJcbiAgICAgICAgJyAgICB9JyxcclxuXHJcbiAgICAgICAgJyAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVBbWJpZW50TGlnaHRDb2xvciArIGZpbmFsQ29sb3IsIHNwcml0ZUNvbG9yLmEpOycsXHJcbiAgICAgICAgJ30nXHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiBmcmFnLmpvaW4oJ1xcbicpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaWdodEZyYWdtZW50U2hhZGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvTGlnaHRGcmFnbWVudFNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gOTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXJ0aWNsZVNoYWRlciA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciB2ZXJ0ID0gW1xyXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG4gICAgICAgICd1bmlmb3JtIG1hdDQgdV92aWV3X21hdHJpeDsnLFxyXG5cclxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3RleF9jb29yZDsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yOycsXHJcblxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdl9jb2xvcjsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuXHJcbiAgICAgICAgJ3ZvaWQgbWFpbigpJyxcclxuICAgICAgICAneycsXHJcbiAgICAgICAgJyAgICBnbF9Qb3NpdGlvbiA9IHVfdmlld19tYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCwgMS4wKTsnLFxyXG5cclxuICAgICAgICAnICAgIHZfY29sb3IgPSBhX2NvbG9yOycsXHJcbiAgICAgICAgJyAgICB2X3RleF9jb29yZCA9IGFfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ30nXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBmcmFnID0gW1xyXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG5cclxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9tYWluX3NhbXBsZXI7JyxcclxuXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2X2NvbG9yOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleF9jb29yZDsnLFxyXG5cclxuICAgICAgICAndm9pZCBtYWluKCknLFxyXG4gICAgICAgICd7JyxcclxuICAgICAgICAnICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X21haW5fc2FtcGxlciwgdl90ZXhfY29vcmQpICogdl9jb2xvcjsnLFxyXG4gICAgICAgICd9J1xyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZlcnQ6IHZlcnQuam9pbignXFxuJyksXHJcbiAgICAgICAgZnJhZzogZnJhZy5qb2luKCdcXG4nKVxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGVTaGFkZXIoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1BhcnRpY2xlU2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBob25nMkRTaGFkZXJEZWZlcnJlZCA9IGZ1bmN0aW9uIChtYXhMaWdodHMpXHJcbntcclxuICAgIHZhciB2ZXJ0ID0gW1xyXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NpdGlvbjsnLFxyXG4gICAgICAgICd2b2lkIG1haW4oKScsXHJcbiAgICAgICAgJ3snLFxyXG4gICAgICAgICcgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHZlcnRleFBvc2l0aW9uLCAwLjAsIDEuMCk7JyxcclxuICAgICAgICAnfSdcclxuICAgIF07XHJcblxyXG4gICAgdmFyIGZyYWcgPSBbXHJcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXHJcblxyXG4gICAgICAgICdzdHJ1Y3QgTGlnaHQnLFxyXG4gICAgICAgICd7JyxcclxuICAgICAgICAnICAgIHZlYzMgcG9zaXRpb247JyxcclxuICAgICAgICAnICAgIHZlYzMgY29sb3I7JyxcclxuICAgICAgICAnICAgIGZsb2F0IGF0dGVudWF0aW9uOycsXHJcbiAgICAgICAgJyAgICBmbG9hdCByYWRpdXM7JyxcclxuICAgICAgICAnfTsnLFxyXG5cclxuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDYW1lcmE7IC8qIHgsIHksIHJvdGF0aW9uLCB6b29tICovJyxcclxuICAgICAgICAndW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uOycsXHJcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVHYnVmZmVyQ29sb3I7JyxcclxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdUdidWZmZXJOb3JtYWw7JyxcclxuICAgICAgICAndW5pZm9ybSB2ZWMzIHVBbWJpZW50TGlnaHRDb2xvcjsnLFxyXG4gICAgICAgICd1bmlmb3JtIExpZ2h0IHVMaWdodHNbJyArIG1heExpZ2h0cyArICddOycsXHJcblxyXG4gICAgICAgICd2b2lkIG1haW4oKScsXHJcbiAgICAgICAgJ3snLFxyXG4gICAgICAgICcgICAgdmVjMiB1diA9IHZlYzIoZ2xfRnJhZ0Nvb3JkLnh5IC8gdVJlc29sdXRpb24pOycsXHJcbiAgICAgICAgJyAgICB2ZWMzIGZpbmFsQ29sb3IgPSB2ZWMzKDAuMCwgMC4wLCAwLjApOycsXHJcbiAgICAgICAgJyAgICB2ZWM0IGdiQ29sb3IgPSB0ZXh0dXJlMkQodUdidWZmZXJDb2xvciwgdXYpOycsXHJcbiAgICAgICAgJyAgICB2ZWMzIGdiTm9ybWFsID0gdGV4dHVyZTJEKHVHYnVmZmVyTm9ybWFsLCB1dikucmdiOycsXHJcbiAgICAgICAgJyAgICB2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSh2ZWMzKGdiTm9ybWFsICogMi4wIC0gMS4wKSk7JyxcclxuICAgICAgICAnICAgIHZlYzIgcmVzID0gdmVjMihtaW4odVJlc29sdXRpb24ueCwgdVJlc29sdXRpb24ueSkpICogdUNhbWVyYS53OycsXHJcblxyXG4gICAgICAgICcgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8ICcgKyBtYXhMaWdodHMgKyAnOyArK2luZGV4KScsXHJcbiAgICAgICAgJyAgICB7ICAgICAgICAgICAgICAgICcsXHJcbiAgICAgICAgJyAgICAgICAgTGlnaHQgbGlnaHQgPSB1TGlnaHRzW2luZGV4XTsnLFxyXG4gICAgICAgICcgICAgICAgIHZlYzMgbGlnaHREaXIgPSB2ZWMzKChsaWdodC5wb3NpdGlvbi54eSAvIHJlcykgLSAoZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzKSwgbGlnaHQucG9zaXRpb24ueik7JyxcclxuICAgICAgICAnICAgICAgICB2ZWMzIGxpZ2h0Tm9ybWFsID0gbm9ybWFsaXplKGxpZ2h0RGlyKTsnLFxyXG4gICAgICAgICcgICAgICAgIGZsb2F0IGRpc3RUb1N1cmYgPSBsZW5ndGgobGlnaHREaXIpICogdUNhbWVyYS53OycsXHJcbiAgICAgICAgJyAgICAgICAgZmxvYXQgZGlmZnVzZUZhY3RvciA9IG1heChkb3Qobm9ybWFsLCBsaWdodE5vcm1hbCksIDAuMCk7JyxcclxuICAgICAgICAnICAgICAgICBmbG9hdCByYWRpdXMgPSAobGlnaHQucmFkaXVzIC8gcmVzLnggKiB1Q2FtZXJhLncpICogdUNhbWVyYS53OycsXHJcbiAgICAgICAgJyAgICAgICAgZmxvYXQgYXR0ZW51YXRpb24gPSBjbGFtcCgxLjAgLSBkaXN0VG9TdXJmICogZGlzdFRvU3VyZiAvIChyYWRpdXMgKiByYWRpdXMpLCAwLjAsIDEuMCk7JyxcclxuICAgICAgICAnICAgICAgICB2ZWMzIGRpZmZ1c2UgPSBsaWdodC5jb2xvciAqIGdiQ29sb3IucmdiICogZGlmZnVzZUZhY3RvcjsnLFxyXG4gICAgICAgICcgICAgICAgIGZpbmFsQ29sb3IgKz0gYXR0ZW51YXRpb24gKiBkaWZmdXNlOycsXHJcbiAgICAgICAgJyAgICB9JyxcclxuXHJcbiAgICAgICAgJyAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVBbWJpZW50TGlnaHRDb2xvciArIGZpbmFsQ29sb3IsIGdiQ29sb3IuYSk7JyxcclxuICAgICAgICAnfSdcclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2ZXJ0OiB2ZXJ0LmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIGZyYWc6IGZyYWcuam9pbignXFxuJylcclxuICAgIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBob25nMkRTaGFkZXJEZWZlcnJlZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1Bob25nMkRTaGFkZXJEZWZlcnJlZC5qc1xuLy8gbW9kdWxlIGlkID0gOTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgdmVydDogW1xyXG4gICAgICAgICd1bmlmb3JtIG1hdDQgdV92aWV3X21hdHJpeDsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2FscGhhOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleF9jb29yZDsnLFxyXG4gICAgICAgICd2YXJ5aW5nIGZsb2F0IHZfYWxwaGE7JyxcclxuICAgICAgICAndm9pZCBtYWluICgpIHsnLFxyXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHVfdmlld19tYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCwgMS4wKTsnLFxyXG4gICAgICAgICcgICB2X3RleF9jb29yZCA9IGFfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJyAgIHZfYWxwaGEgPSBhX2FscGhhOycsXHJcbiAgICAgICAgJ30nXHJcbiAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgZnJhZzogW1xyXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X3NhbXBsZXIyRDsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICAgICAndmFyeWluZyBmbG9hdCB2X2FscGhhOycsXHJcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9zYW1wbGVyMkQsIHZfdGV4X2Nvb3JkKSAqIHZlYzQoMS4wLCAxLjAsIDEuMCwgdl9hbHBoYSk7JyxcclxuICAgICAgICAnfSdcclxuICAgIF0uam9pbignXFxuJylcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1RleHR1cmVkQW5kQWxwaGFTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHZlcnQ6IFtcclxuICAgICAgICAndW5pZm9ybSBtYXQ0IHVfdmlld19tYXRyaXg7JyxcclxuICAgICAgICAndW5pZm9ybSB2ZWMyIHVfc2Nyb2xsOycsXHJcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Njcm9sbF9mYWN0b3I7JyxcclxuICAgICAgICAndW5pZm9ybSB2ZWMyIHVfdGlsZW1hcF9wb3NpdGlvbjsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleF9jb29yZDsnLFxyXG4gICAgICAgICd2b2lkIG1haW4gKCkgeycsXHJcbiAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdV92aWV3X21hdHJpeCAqIHZlYzQodV90aWxlbWFwX3Bvc2l0aW9uICsgYV9wb3NpdGlvbiArICh1X3Njcm9sbCAqIHVfc2Nyb2xsX2ZhY3RvciksIDEuMCwgMS4wKTsnLFxyXG4gICAgICAgICcgICB2X3RleF9jb29yZCA9IGFfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ30nXHJcbiAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgZnJhZzogW1xyXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X3NhbXBsZXIyRDsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICAgICAndm9pZCBtYWluKCkgeycsXHJcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3NhbXBsZXIyRCwgdl90ZXhfY29vcmQpOycsXHJcbiAgICAgICAgJ30nXHJcbiAgICBdLmpvaW4oJ1xcbicpXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9UaWxlbWFwU2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICB2ZXJ0OiBbXHJcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXHJcbiAgICAgICAgJ3VuaWZvcm0gbWF0NCB1X3ZpZXdfbWF0cml4OycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcclxuICAgICAgICAnYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9hbHBoYTsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdl9jb2xvcjsnLFxyXG4gICAgICAgICd2YXJ5aW5nIGZsb2F0IHZfYWxwaGE7JyxcclxuICAgICAgICAndm9pZCBtYWluICgpIHsnLFxyXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHVfdmlld19tYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCwgMS4wKTsnLFxyXG4gICAgICAgICcgICB2X2NvbG9yID0gYV9jb2xvcjsnLFxyXG4gICAgICAgICcgICB2X2FscGhhID0gYV9hbHBoYTsnLFxyXG4gICAgICAgICd9J1xyXG4gICAgXS5qb2luKCdcXG4nKSxcclxuICAgIGZyYWc6IFtcclxuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuICAgICAgICAndmFyeWluZyB2ZWM0IHZfY29sb3I7JyxcclxuICAgICAgICAndmFyeWluZyBmbG9hdCB2X2FscGhhOycsXHJcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZfY29sb3IuYmdyLCB2X2FscGhhKTsnLFxyXG4gICAgICAgICd9J1xyXG4gICAgXS5qb2luKCdcXG4nKVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVW50ZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHZlcnQ6IFtcclxuICAgICAgICAndW5pZm9ybSBtYXQ0IHVfdmlld19tYXRyaXg7JyxcclxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2X2NvbG9yOycsXHJcbiAgICAgICAgJ3ZvaWQgbWFpbiAoKSB7JyxcclxuICAgICAgICAnICAgZ2xfUG9zaXRpb24gPSB1X3ZpZXdfbWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAxLjAsIDEuMCk7JyxcclxuICAgICAgICAnICAgdl9jb2xvciA9IGFfY29sb3I7JyxcclxuICAgICAgICAnfSdcclxuICAgIF0uam9pbignXFxuJyksXHJcbiAgICBmcmFnOltcclxuICAgICAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcclxuICAgICAgICAndmFyeWluZyB2ZWM0IHZfY29sb3I7JyxcclxuICAgICAgICAndm9pZCBtYWluKCkgeycsXHJcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7JyxcclxuICAgICAgICAnfSdcclxuICAgIF0uam9pbignXFxuJylcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1VudGV4dHVyZWRBbmRUaW50ZWRTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgUEVORElORzogMCxcclxuICAgIElOU1RBTExFRDogMSxcclxuXHJcbiAgICBCT09UOiAwLFxyXG4gICAgSU5JVDogMSxcclxuICAgIFBSRUxPQUQ6IDIsXHJcbiAgICBDUkVBVEU6IDMsXHJcbiAgICBVUERBVEU6IDQsXHJcbiAgICBSRU5ERVI6IDUsXHJcbiAgICBTSFVURE9XTjogNlxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gOTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcblxyXG52YXIgR2xvYmFsU2NlbmVNYW5hZ2VyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEdsb2JhbFNjZW5lTWFuYWdlciAoZ2FtZSwgc2NlbmVDb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICAgICAgLy8gIEV2ZXJ5dGhpbmcga2VwdCBpbiBoZXJlXHJcbiAgICAgICAgdGhpcy5rZXlzID0ge307XHJcbiAgICAgICAgdGhpcy5zY2VuZXMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gIE9ubHkgYWN0aXZlIHNjZW5lcyBhcmUga2VwdCBpbiBoZXJlLiBUaGV5IGFyZSBtb3ZlZCBoZXJlIHdoZW4gc3RhcnRlZCwgYW5kIG1vdmVkIG91dCB3aGVuIG5vdC5cclxuICAgICAgICAvLyAgQWxsIHNjZW5lcyBhcmUgc3RvcmVkIGluIHRoZSBzY2VuZXMgYXJyYXksIHJlZ2FyZGxlc3Mgb2YgYmVpbmcgYWN0aXZlIG9yIG5vdC5cclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IFtdO1xyXG5cclxuICAgICAgICAvLyAgQSBzY2VuZSBwZW5kaW5nIHRvIGJlIGFkZGVkIHRvIHRoZSBTY2VuZSBNYW5hZ2VyIGlzIHN0b3JlZCBpbiBoZXJlIHVudGlsIHRoZSBtYW5hZ2VyIGhhcyB0aW1lIHRvIGFkZCBpdC5cclxuICAgICAgICB0aGlzLl9wZW5kaW5nID0gW107XHJcblxyXG4gICAgICAgIC8vICBBbiBhcnJheSBvZiBzY2VuZXMgd2FpdGluZyB0byBiZSBzdGFydGVkIG9uY2UgdGhlIGdhbWUgaGFzIGJvb3RlZFxyXG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gW107XHJcblxyXG4gICAgICAgIGlmIChzY2VuZUNvbmZpZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjZW5lQ29uZmlnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY2VuZUNvbmZpZy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgVGhlIGkgPT09IDAgcGFydCBqdXN0IHN0YXJ0cyB0aGUgZmlyc3QgU2NlbmUgZ2l2ZW5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnZGVmYXVsdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5lOiBzY2VuZUNvbmZpZ1tpXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1N0YXJ0OiAoaSA9PT0gMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjZW5lOiBzY2VuZUNvbmZpZyxcclxuICAgICAgICAgICAgICAgICAgICBhdXRvU3RhcnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge31cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IHJlcXVpcmUoJy4vaW5jL0FkZCcpLFxyXG4gICAgYm9vdDogcmVxdWlyZSgnLi9pbmMvQm9vdCcpLFxyXG4gICAgYm9vdFNjZW5lOiByZXF1aXJlKCcuL2luYy9Cb290U2NlbmUnKSxcclxuICAgIGJyaW5nVG9Ub3A6IHJlcXVpcmUoJy4vaW5jL0JyaW5nVG9Ub3AnKSxcclxuICAgIGNyZWF0ZTogcmVxdWlyZSgnLi9pbmMvQ3JlYXRlJyksXHJcbiAgICBjcmVhdGVTY2VuZURpc3BsYXk6IHJlcXVpcmUoJy4vaW5jL0NyZWF0ZVNjZW5lRGlzcGxheScpLFxyXG4gICAgY3JlYXRlU2NlbmVGcm9tRnVuY3Rpb246IHJlcXVpcmUoJy4vaW5jL0NyZWF0ZVNjZW5lRnJvbUZ1bmN0aW9uJyksXHJcbiAgICBjcmVhdGVTY2VuZUZyb21JbnN0YW5jZTogcmVxdWlyZSgnLi9pbmMvQ3JlYXRlU2NlbmVGcm9tSW5zdGFuY2UnKSxcclxuICAgIGNyZWF0ZVNjZW5lRnJvbU9iamVjdDogcmVxdWlyZSgnLi9pbmMvQ3JlYXRlU2NlbmVGcm9tT2JqZWN0JyksXHJcbiAgICBnZXRBY3RpdmVTY2VuZTogcmVxdWlyZSgnLi9pbmMvR2V0QWN0aXZlU2NlbmUnKSxcclxuICAgIGdldEFjdGl2ZVNjZW5lSW5kZXg6IHJlcXVpcmUoJy4vaW5jL0dldEFjdGl2ZVNjZW5lSW5kZXgnKSxcclxuICAgIGdldEFjdGl2ZVNjZW5lSW5kZXhCeUtleTogcmVxdWlyZSgnLi9pbmMvR2V0QWN0aXZlU2NlbmVJbmRleEJ5S2V5JyksXHJcbiAgICBnZXRLZXk6IHJlcXVpcmUoJy4vaW5jL0dldEtleScpLFxyXG4gICAgZ2V0U2NlbmU6IHJlcXVpcmUoJy4vaW5jL0dldFNjZW5lJyksXHJcbiAgICBnZXRTY2VuZUF0OiByZXF1aXJlKCcuL2luYy9HZXRTY2VuZUF0JyksXHJcbiAgICBnZXRTY2VuZUluZGV4OiByZXF1aXJlKCcuL2luYy9HZXRTY2VuZUluZGV4JyksXHJcbiAgICBnZXRTY2VuZUluZGV4QnlLZXk6IHJlcXVpcmUoJy4vaW5jL0dldFNjZW5lSW5kZXhCeUtleScpLFxyXG4gICAgaXNBY3RpdmU6IHJlcXVpcmUoJy4vaW5jL0lzQWN0aXZlJyksXHJcbiAgICBpc1NsZWVwaW5nOiByZXF1aXJlKCcuL2luYy9Jc1NsZWVwaW5nJyksXHJcbiAgICBsb2FkQ29tcGxldGU6IHJlcXVpcmUoJy4vaW5jL0xvYWRDb21wbGV0ZScpLFxyXG4gICAgbW92ZURvd246IHJlcXVpcmUoJy4vaW5jL01vdmVEb3duJyksXHJcbiAgICBtb3ZlVXA6IHJlcXVpcmUoJy4vaW5jL01vdmVVcCcpLFxyXG4gICAgcGF1c2U6IHJlcXVpcmUoJy4vaW5jL1BhdXNlJyksXHJcbiAgICBwYXlsb2FkQ29tcGxldGU6IHJlcXVpcmUoJy4vaW5jL1BheWxvYWRDb21wbGV0ZScpLFxyXG4gICAgcmVzdW1lOiByZXF1aXJlKCcuL2luYy9SZXN1bWUnKSxcclxuICAgIHNlbmRUb0JhY2s6IHJlcXVpcmUoJy4vaW5jL1NlbmRUb0JhY2snKSxcclxuICAgIHNldHVwQ2FsbGJhY2tzOiByZXF1aXJlKCcuL2luYy9TZXR1cENhbGxiYWNrcycpLFxyXG4gICAgc2xlZXA6IHJlcXVpcmUoJy4vaW5jL1NsZWVwJyksXHJcbiAgICBzdGFydDogcmVxdWlyZSgnLi9pbmMvU3RhcnQnKSxcclxuICAgIHN0b3A6IHJlcXVpcmUoJy4vaW5jL1N0b3AnKSxcclxuICAgIHN3YXA6IHJlcXVpcmUoJy4vaW5jL1N3YXAnKSxcclxuICAgIHN3YXBQb3NpdGlvbjogcmVxdWlyZSgnLi9pbmMvU3dhcFBvc2l0aW9uJyksXHJcbiAgICB3YWtlOiByZXF1aXJlKCcuL2luYy9XYWtlJylcclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHbG9iYWxTY2VuZU1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvZ2xvYmFsL0dsb2JhbFNjZW5lTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTY2VuZSA9IHJlcXVpcmUoJy4uLy4uL2xvY2FsL1NjZW5lJyk7XHJcblxyXG4vKipcclxuKiBBZGRzIGEgbmV3IFNjZW5lIGludG8gdGhlIEdsb2JhbFNjZW5lTWFuYWdlci4gWW91IG11c3QgZ2l2ZSBlYWNoIFNjZW5lIGEgdW5pcXVlIGtleSBieSB3aGljaCB5b3UnbGwgaWRlbnRpZnkgaXQuXHJcbiogVGhlIFNjZW5lIGNhbiBiZSBlaXRoZXIgYSBQaGFzZXIuU2NlbmUgb2JqZWN0IChvciBhbiBvYmplY3QgdGhhdCBleHRlbmRzIGl0KSwgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCBvciBhIGZ1bmN0aW9uLlxyXG4qIElmIGEgZnVuY3Rpb24gaXMgZ2l2ZW4gYSBuZXcgc2NlbmUgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZCBieSBjYWxsaW5nIGl0LlxyXG4qXHJcbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIEEgdW5pcXVlIGtleSB5b3UgdXNlIHRvIHJlZmVyZW5jZSB0aGlzIHNjZW5lLCBpLmUuIFwiTWFpbk1lbnVcIiwgXCJMZXZlbDFcIi5cclxuKiBAcGFyYW0ge1BoYXNlci5TY2VuZXxvYmplY3R8ZnVuY3Rpb259IHNjZW5lICAtIFRoZSBzY2VuZSB5b3Ugd2FudCB0byBzd2l0Y2ggdG8uXHJcbiogQHBhcmFtIHtib29sZWFufSBbYXV0b1N0YXJ0PWZhbHNlXSAgLSBJZiB0cnVlIHRoZSBTY2VuZSB3aWxsIGJlIHN0YXJ0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYWRkaW5nIGl0LlxyXG4qL1xyXG52YXIgQWRkID0gZnVuY3Rpb24gKGtleSwgc2NlbmVDb25maWcsIGF1dG9TdGFydClcclxue1xyXG4gICAgaWYgKGF1dG9TdGFydCA9PT0gdW5kZWZpbmVkKSB7IGF1dG9TdGFydCA9IGZhbHNlOyB9XHJcblxyXG4gICAgLy8gIGlmIG5vdCBib290ZWQsIHRoZW4gcHV0IHNjZW5lIGludG8gYSBob2xkaW5nIHBhdHRlcm5cclxuICAgIGlmICghdGhpcy5nYW1lLmlzQm9vdGVkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmcucHVzaCh7XHJcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLl9wZW5kaW5nLmxlbmd0aCxcclxuICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgIHNjZW5lOiBzY2VuZUNvbmZpZyxcclxuICAgICAgICAgICAgYXV0b1N0YXJ0OiBhdXRvU3RhcnRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHZhciBvayA9IGtleTtcclxuICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSwgc2NlbmVDb25maWcpO1xyXG5cclxuICAgIHZhciBuZXdTY2VuZTtcclxuXHJcbiAgICBpZiAoc2NlbmVDb25maWcgaW5zdGFuY2VvZiBTY2VuZSlcclxuICAgIHtcclxuICAgICAgICBuZXdTY2VuZSA9IHRoaXMuY3JlYXRlU2NlbmVGcm9tSW5zdGFuY2Uoa2V5LCBzY2VuZUNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NlbmVDb25maWcgPT09ICdvYmplY3QnKVxyXG4gICAge1xyXG4gICAgICAgIHNjZW5lQ29uZmlnLmtleSA9IGtleTtcclxuXHJcbiAgICAgICAgbmV3U2NlbmUgPSB0aGlzLmNyZWF0ZVNjZW5lRnJvbU9iamVjdChrZXksIHNjZW5lQ29uZmlnKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2VuZUNvbmZpZyA9PT0gJ2Z1bmN0aW9uJylcclxuICAgIHtcclxuICAgICAgICBuZXdTY2VuZSA9IHRoaXMuY3JlYXRlU2NlbmVGcm9tRnVuY3Rpb24oa2V5LCBzY2VuZUNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFJlcGxhY2Uga2V5IGluIGNhc2UgdGhlIHNjZW5lIGNoYW5nZWQgaXRcclxuICAgIGtleSA9IG5ld1NjZW5lLnN5cy5zZXR0aW5ncy5rZXk7XHJcblxyXG4gICAgdGhpcy5rZXlzW2tleV0gPSBuZXdTY2VuZTtcclxuXHJcbiAgICB0aGlzLnNjZW5lcy5wdXNoKG5ld1NjZW5lKTtcclxuXHJcbiAgICBpZiAoYXV0b1N0YXJ0IHx8IG5ld1NjZW5lLnN5cy5zZXR0aW5ncy5hY3RpdmUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2FtZS5pc0Jvb3RlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnQucHVzaChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3U2NlbmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL0FkZC5qc1xuLy8gbW9kdWxlIGlkID0gOTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBCb290IGhhbmRsZXIgaXMgY2FsbGVkIGJ5IFBoYXNlci5HYW1lIHdoZW4gaXQgZmlyc3Qgc3RhcnRzIHVwLlxyXG4qIFRoZSByZW5kZXJlciBpcyBhdmFpbGFibGUgYnkgbm93LlxyXG4qL1xyXG52YXIgQm9vdCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGVudHJ5O1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9wZW5kaW5nLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGVudHJ5ID0gdGhpcy5fcGVuZGluZ1tpXTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGQoZW50cnkua2V5LCBlbnRyeS5zY2VuZSwgZW50cnkuYXV0b1N0YXJ0KTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fc3RhcnQubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgZW50cnkgPSB0aGlzLl9zdGFydFtpXTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydChlbnRyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIENsZWFyIHRoZSBwZW5kaW5nIGxpc3RzXHJcbiAgICB0aGlzLl9zdGFydCA9IFtdO1xyXG4gICAgdGhpcy5fcGVuZGluZyA9IFtdO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCb290O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvQm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gOTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCb290U2NlbmUgPSBmdW5jdGlvbiAoc2NlbmUpXHJcbntcclxuICAgIGlmIChzY2VuZS5pbml0KVxyXG4gICAge1xyXG4gICAgICAgIHNjZW5lLmluaXQuY2FsbChzY2VuZSwgc2NlbmUuc3lzLnNldHRpbmdzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsb2FkZXIgPSBzY2VuZS5zeXMubG9hZDtcclxuICAgICAgICBcclxuICAgIGxvYWRlci5yZXNldCgpO1xyXG5cclxuICAgIGlmIChzY2VuZS5wcmVsb2FkKVxyXG4gICAge1xyXG4gICAgICAgIHNjZW5lLnByZWxvYWQodGhpcy5nYW1lKTtcclxuXHJcbiAgICAgICAgLy8gIElzIHRoZSBsb2FkZXIgZW1wdHk/XHJcbiAgICAgICAgaWYgKGxvYWRlci5saXN0LnNpemUgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZShzY2VuZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBTdGFydCB0aGUgbG9hZGVyIGdvaW5nIGFzIHdlIGhhdmUgc29tZXRoaW5nIGluIHRoZSBxdWV1ZVxyXG5cclxuICAgICAgICAgICAgbG9hZGVyLmV2ZW50cy5vbmNlKCdMT0FERVJfQ09NUExFVEVfRVZFTlQnLCB0aGlzLmxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgIGxvYWRlci5zdGFydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgTm8gcHJlbG9hZD8gVGhlbiB0aGVyZSB3YXMgbm90aGluZyB0byBsb2FkIGVpdGhlclxyXG4gICAgICAgIHRoaXMuY3JlYXRlKHNjZW5lKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm9vdFNjZW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvQm9vdFNjZW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA5Mjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIElmIHRoZSBhcmd1bWVudHMgYXJlIHN0cmluZ3MgdGhleSBhcmUgYXNzdW1lZCB0byBiZSBrZXlzLCBvdGhlcndpc2UgdGhleSBhcmUgU2NlbmUgb2JqZWN0c1xyXG4vLyAgWW91IGNhbiBvbmx5IHN3YXAgdGhlIHBvc2l0aW9ucyBvZiBBY3RpdmUgKHJlbmRlcmluZyAvIHVwZGF0aW5nKSBTY2VuZXMuIElmIGEgU2NlbmUgaXMgbm90IGFjdGl2ZSBpdCBjYW5ub3QgYmUgbW92ZWQuXHJcblxyXG52YXIgQnJpbmdUb1RvcCA9IGZ1bmN0aW9uIChzY2VuZSlcclxue1xyXG4gICAgdmFyIGluZGV4ID0gKHR5cGVvZiBzY2VuZSA9PT0gJ3N0cmluZycpID8gdGhpcy5nZXRBY3RpdmVTY2VuZUluZGV4QnlLZXkoc2NlbmUpIDogdGhpcy5nZXRBY3RpdmVTY2VuZUluZGV4KHNjZW5lKTtcclxuXHJcbiAgICBpZiAoaW5kZXggPCB0aGlzLmFjdGl2ZS5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuYWN0aXZlLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlW2ldLmluZGV4ID0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYWN0aXZlLnB1c2goeyBpbmRleDogaSwgc2NlbmU6IGVudHJ5WzBdLnNjZW5lIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCcmluZ1RvVG9wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvQnJpbmdUb1RvcC5qc1xuLy8gbW9kdWxlIGlkID0gOTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTb3J0U2NlbmVzID0gcmVxdWlyZSgnLi9Tb3J0U2NlbmVzJyk7XHJcblxyXG52YXIgQ3JlYXRlID0gZnVuY3Rpb24gKHNjZW5lKVxyXG57XHJcbiAgICAvLyAgSW5zZXJ0IGF0IHRoZSBjb3JyZWN0IGluZGV4LCBvciBpdCBqdXN0IGFsbCBnb2VzIHdyb25nIDopXHJcblxyXG4gICAgdmFyIGkgPSB0aGlzLmdldFNjZW5lSW5kZXgoc2NlbmUpO1xyXG5cclxuICAgIHRoaXMuYWN0aXZlLnB1c2goeyBpbmRleDogaSwgc2NlbmU6IHNjZW5lIH0pO1xyXG5cclxuICAgIC8vICBTb3J0IHRoZSAnYWN0aXZlJyBhcnJheSBiYXNlZCBvbiB0aGUgaW5kZXggcHJvcGVydHlcclxuICAgIHRoaXMuYWN0aXZlLnNvcnQoU29ydFNjZW5lcyk7XHJcblxyXG4gICAgaWYgKHNjZW5lLmNyZWF0ZSlcclxuICAgIHtcclxuICAgICAgICBzY2VuZS5jcmVhdGUuY2FsbChzY2VuZSwgc2NlbmUuc3lzLnNldHRpbmdzLmRhdGEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvZ2xvYmFsL2luYy9DcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDkzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2RvbS9DYW52YXNQb29sJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBHZXRDb250ZXh0ID0gcmVxdWlyZSgnLi4vLi4vLi4vY2FudmFzL0dldENvbnRleHQnKTtcclxudmFyIENhbnZhc0ludGVycG9sYXRpb24gPSByZXF1aXJlKCcuLi8uLi8uLi9kb20vQ2FudmFzSW50ZXJwb2xhdGlvbicpO1xyXG5cclxudmFyIENyZWF0ZVNjZW5lRGlzcGxheSA9IGZ1bmN0aW9uIChzY2VuZSlcclxue1xyXG4gICAgdmFyIHNldHRpbmdzID0gc2NlbmUuc3lzLnNldHRpbmdzO1xyXG5cclxuICAgIHZhciB3aWR0aCA9IHNldHRpbmdzLndpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IHNldHRpbmdzLmhlaWdodDtcclxuXHJcbiAgICB2YXIgY29uZmlnID0gdGhpcy5nYW1lLmNvbmZpZztcclxuXHJcbiAgICBpZiAoY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULkNBTlZBUylcclxuICAgIHtcclxuICAgICAgICBpZiAoc2V0dGluZ3MucmVuZGVyVG9UZXh0dXJlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2NlbmUuc3lzLmNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKHNjZW5lLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgc2NlbmUuc3lzLmNvbnRleHQgPSBHZXRDb250ZXh0KHNjZW5lLnN5cy5jYW52YXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzY2VuZS5zeXMuY2FudmFzID0gdGhpcy5nYW1lLmNhbnZhcztcclxuICAgICAgICAgICAgc2NlbmUuc3lzLmNvbnRleHQgPSB0aGlzLmdhbWUuY29udGV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBQaXhlbCBBcnQgbW9kZT9cclxuICAgICAgICBpZiAoY29uZmlnLnBpeGVsQXJ0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ2FudmFzSW50ZXJwb2xhdGlvbi5zZXRDcmlzcChzY2VuZS5zeXMuY2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVNjZW5lRGlzcGxheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL0NyZWF0ZVNjZW5lRGlzcGxheS5qc1xuLy8gbW9kdWxlIGlkID0gOTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTY2VuZSA9IHJlcXVpcmUoJy4uLy4uL2xvY2FsL1NjZW5lJyk7XHJcbnZhciBTeXN0ZW1zID0gcmVxdWlyZSgnLi4vLi4vbG9jYWwvU3lzdGVtcycpO1xyXG52YXIgTk9PUCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL05PT1AnKTtcclxuXHJcbnZhciBDcmVhdGVTY2VuZUZyb21GdW5jdGlvbiA9IGZ1bmN0aW9uIChrZXksIHNjZW5lKVxyXG57XHJcbiAgICB2YXIgbmV3U2NlbmUgPSBuZXcgc2NlbmUoKTtcclxuXHJcbiAgICBpZiAobmV3U2NlbmUgaW5zdGFuY2VvZiBTY2VuZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgY29uZmlnS2V5ID0gbmV3U2NlbmUuc3lzLnNldHRpbmdzLmtleTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZ0tleSAhPT0gJycpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXkgPSBjb25maWdLZXk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5rZXlzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgYSBTY2VuZSB3aXRoIGR1cGxpY2F0ZSBrZXk6ICcgKyBrZXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NlbmVGcm9tSW5zdGFuY2Uoa2V5LCBuZXdTY2VuZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgbmV3U2NlbmUuc3lzID0gbmV3IFN5c3RlbXMobmV3U2NlbmUpO1xyXG5cclxuICAgICAgICBuZXdTY2VuZS5zeXMuc2V0dGluZ3Mua2V5ID0ga2V5O1xyXG5cclxuICAgICAgICBuZXdTY2VuZS5zeXMuaW5pdCh0aGlzLmdhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZVNjZW5lRGlzcGxheShuZXdTY2VuZSk7XHJcblxyXG4gICAgICAgIC8vICBEZWZhdWx0IHJlcXVpcmVkIGZ1bmN0aW9uc1xyXG5cclxuICAgICAgICBpZiAoIW5ld1NjZW5lLmluaXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuZXdTY2VuZS5pbml0ID0gTk9PUDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghbmV3U2NlbmUucHJlbG9hZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld1NjZW5lLnByZWxvYWQgPSBOT09QO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFuZXdTY2VuZS5jcmVhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuZXdTY2VuZS5jcmVhdGUgPSBOT09QO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFuZXdTY2VuZS5zaHV0ZG93bilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld1NjZW5lLnNodXRkb3duID0gTk9PUDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghbmV3U2NlbmUudXBkYXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3U2NlbmUudXBkYXRlID0gTk9PUDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghbmV3U2NlbmUucmVuZGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3U2NlbmUucmVuZGVyID0gTk9PUDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdTY2VuZTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlU2NlbmVGcm9tRnVuY3Rpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvZ2xvYmFsL2luYy9DcmVhdGVTY2VuZUZyb21GdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gOTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDcmVhdGVTY2VuZUZyb21JbnN0YW5jZSA9IGZ1bmN0aW9uIChrZXksIG5ld1NjZW5lKVxyXG57XHJcbiAgICB2YXIgY29uZmlnS2V5ID0gbmV3U2NlbmUuc3lzLnNldHRpbmdzLmtleTtcclxuXHJcbiAgICBpZiAoY29uZmlnS2V5ICE9PSAnJylcclxuICAgIHtcclxuICAgICAgICBrZXkgPSBjb25maWdLZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgbmV3U2NlbmUuc3lzLnNldHRpbmdzLmtleSA9IGtleTtcclxuICAgIH1cclxuXHJcbiAgICBuZXdTY2VuZS5zeXMuaW5pdCh0aGlzLmdhbWUpO1xyXG5cclxuICAgIHRoaXMuY3JlYXRlU2NlbmVEaXNwbGF5KG5ld1NjZW5lKTtcclxuXHJcbiAgICByZXR1cm4gbmV3U2NlbmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVNjZW5lRnJvbUluc3RhbmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvQ3JlYXRlU2NlbmVGcm9tSW5zdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDkzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2NlbmUgPSByZXF1aXJlKCcuLi8uLi9sb2NhbC9TY2VuZScpO1xyXG5cclxudmFyIENyZWF0ZVNjZW5lRnJvbU9iamVjdCA9IGZ1bmN0aW9uIChrZXksIHNjZW5lQ29uZmlnKVxyXG57XHJcbiAgICB2YXIgbmV3U2NlbmUgPSBuZXcgU2NlbmUoc2NlbmVDb25maWcpO1xyXG5cclxuICAgIHZhciBjb25maWdLZXkgPSBuZXdTY2VuZS5zeXMuc2V0dGluZ3Mua2V5O1xyXG5cclxuICAgIGlmIChjb25maWdLZXkgIT09ICcnKVxyXG4gICAge1xyXG4gICAgICAgIGtleSA9IGNvbmZpZ0tleTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBuZXdTY2VuZS5zeXMuc2V0dGluZ3Mua2V5ID0ga2V5O1xyXG4gICAgfVxyXG5cclxuICAgIG5ld1NjZW5lLnN5cy5pbml0KHRoaXMuZ2FtZSk7XHJcblxyXG4gICAgdGhpcy5jcmVhdGVTY2VuZURpc3BsYXkobmV3U2NlbmUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnNldHVwQ2FsbGJhY2tzKG5ld1NjZW5lLCBzY2VuZUNvbmZpZyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVNjZW5lRnJvbU9iamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL0NyZWF0ZVNjZW5lRnJvbU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gOTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRBY3RpdmVTY2VuZSA9IGZ1bmN0aW9uIChrZXkpXHJcbntcclxuICAgIHZhciBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoa2V5KTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5zY2VuZSA9PT0gc2NlbmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBY3RpdmVTY2VuZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL0dldEFjdGl2ZVNjZW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA5MzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEFjdGl2ZVNjZW5lSW5kZXggPSBmdW5jdGlvbiAoc2NlbmUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLnNjZW5lID09PSBzY2VuZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVtpXS5pbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIC0xO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBY3RpdmVTY2VuZUluZGV4O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvR2V0QWN0aXZlU2NlbmVJbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRBY3RpdmVTY2VuZUluZGV4QnlLZXkgPSBmdW5jdGlvbiAoa2V5KVxyXG57XHJcbiAgICB2YXIgc2NlbmUgPSB0aGlzLmtleXNba2V5XTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5zY2VuZSA9PT0gc2NlbmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVbaV0uaW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAtMTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0QWN0aXZlU2NlbmVJbmRleEJ5S2V5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvR2V0QWN0aXZlU2NlbmVJbmRleEJ5S2V5LmpzXG4vLyBtb2R1bGUgaWQgPSA5Mzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNjZW5lID0gcmVxdWlyZSgnLi4vLi4vbG9jYWwvU2NlbmUnKTtcclxuXHJcbi8vICBwcml2YXRlXHJcbnZhciBHZXRLZXkgPSBmdW5jdGlvbiAoa2V5LCBzY2VuZUNvbmZpZylcclxue1xyXG4gICAgaWYgKCFrZXkpIHsga2V5ID0gJ2RlZmF1bHQnOyB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBzY2VuZUNvbmZpZyA9PT0gJ2Z1bmN0aW9uJylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2NlbmVDb25maWcgaW5zdGFuY2VvZiBTY2VuZSlcclxuICAgIHtcclxuICAgICAgICBrZXkgPSBzY2VuZUNvbmZpZy5zeXMuc2V0dGluZ3Mua2V5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHNjZW5lQ29uZmlnID09PSAnb2JqZWN0JyAmJiBzY2VuZUNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpXHJcbiAgICB7XHJcbiAgICAgICAga2V5ID0gc2NlbmVDb25maWcua2V5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBCeSB0aGlzIHBvaW50IGl0J3MgZWl0aGVyICdkZWZhdWx0JyBvciBleHRyYWN0ZWQgZnJvbSB0aGUgU2NlbmVcclxuXHJcbiAgICBpZiAodGhpcy5rZXlzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGEgU2NlbmUgd2l0aCBkdXBsaWNhdGUga2V5OiAnICsga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRLZXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvZ2xvYmFsL2luYy9HZXRLZXkuanNcbi8vIG1vZHVsZSBpZCA9IDkzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0U2NlbmUgPSBmdW5jdGlvbiAoa2V5KVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5rZXlzW2tleV07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFNjZW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvR2V0U2NlbmUuanNcbi8vIG1vZHVsZSBpZCA9IDkzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgR2V0cyB0aGUgQWN0aXZlIHNjZW5lIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxyXG5cclxudmFyIEdldFNjZW5lQXQgPSBmdW5jdGlvbiAoaW5kZXgpXHJcbntcclxuICAgIGlmICh0aGlzLmFjdGl2ZVtpbmRleF0pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlW2luZGV4XS5zY2VuZTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0U2NlbmVBdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL0dldFNjZW5lQXQuanNcbi8vIG1vZHVsZSBpZCA9IDk0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0U2NlbmVJbmRleCA9IGZ1bmN0aW9uIChzY2VuZSlcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuc2NlbmVzLmluZGV4T2Yoc2NlbmUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRTY2VuZUluZGV4O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvR2V0U2NlbmVJbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRTY2VuZUluZGV4QnlLZXkgPSBmdW5jdGlvbiAoa2V5KVxyXG57XHJcbiAgICB2YXIgc2NlbmUgPSB0aGlzLmtleXNba2V5XTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5zY2VuZXMuaW5kZXhPZihzY2VuZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFNjZW5lSW5kZXhCeUtleTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL0dldFNjZW5lSW5kZXhCeUtleS5qc1xuLy8gbW9kdWxlIGlkID0gOTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJc0FjdGl2ZSA9IGZ1bmN0aW9uIChrZXkpXHJcbntcclxuICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0QWN0aXZlU2NlbmUoa2V5KTtcclxuXHJcbiAgICByZXR1cm4gKGVudHJ5ICYmIGVudHJ5LnNjZW5lLnN5cy5zZXR0aW5ncy5hY3RpdmUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJc0FjdGl2ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL0lzQWN0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIElzU2xlZXBpbmcgPSBmdW5jdGlvbiAoa2V5KVxyXG57XHJcbiAgICB2YXIgZW50cnkgPSB0aGlzLmdldEFjdGl2ZVNjZW5lKGtleSk7XHJcblxyXG4gICAgaWYgKGVudHJ5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoIWVudHJ5LnNjZW5lLnN5cy5zZXR0aW5ncy5hY3RpdmUgJiYgIWVudHJ5LnNjZW5lLnN5cy5zZXR0aW5ncy52aXNpYmxlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElzU2xlZXBpbmc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvZ2xvYmFsL2luYy9Jc1NsZWVwaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA5NDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudClcclxue1xyXG4gICAgdmFyIHNjZW5lID0gZXZlbnQubG9hZGVyLnNjZW5lO1xyXG5cclxuICAgIHRoaXMuY3JlYXRlKHNjZW5lKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTG9hZENvbXBsZXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvTG9hZENvbXBsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIElmIHRoZSBhcmd1bWVudHMgYXJlIHN0cmluZ3MgdGhleSBhcmUgYXNzdW1lZCB0byBiZSBrZXlzLCBvdGhlcndpc2UgdGhleSBhcmUgU2NlbmUgb2JqZWN0c1xyXG4vLyAgWW91IGNhbiBvbmx5IHN3YXAgdGhlIHBvc2l0aW9ucyBvZiBBY3RpdmUgKHJlbmRlcmluZyAvIHVwZGF0aW5nKSBTY2VuZXMuIElmIGEgU2NlbmUgaXMgbm90IGFjdGl2ZSBpdCBjYW5ub3QgYmUgbW92ZWQuXHJcblxyXG52YXIgTW92ZURvd24gPSBmdW5jdGlvbiAoc2NlbmUpXHJcbntcclxuICAgIHZhciBpbmRleCA9ICh0eXBlb2Ygc2NlbmUgPT09ICdzdHJpbmcnKSA/IHRoaXMuZ2V0QWN0aXZlU2NlbmVJbmRleEJ5S2V5KHNjZW5lKSA6IHRoaXMuZ2V0QWN0aXZlU2NlbmVJbmRleChzY2VuZSk7XHJcblxyXG4gICAgaWYgKGluZGV4ID4gMClcclxuICAgIHtcclxuICAgICAgICB2YXIgc2NlbmVCID0gdGhpcy5nZXRTY2VuZUF0KGluZGV4IC0gMSk7XHJcblxyXG4gICAgICAgIGlmIChzY2VuZUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN3YXBQb3NpdGlvbihzY2VuZSwgc2NlbmVCKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vdmVEb3duO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvTW92ZURvd24uanNcbi8vIG1vZHVsZSBpZCA9IDk0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgSWYgdGhlIGFyZ3VtZW50cyBhcmUgc3RyaW5ncyB0aGV5IGFyZSBhc3N1bWVkIHRvIGJlIGtleXMsIG90aGVyd2lzZSB0aGV5IGFyZSBTY2VuZSBvYmplY3RzXHJcbi8vICBZb3UgY2FuIG9ubHkgc3dhcCB0aGUgcG9zaXRpb25zIG9mIEFjdGl2ZSAocmVuZGVyaW5nIC8gdXBkYXRpbmcpIFNjZW5lcy4gSWYgYSBTY2VuZSBpcyBub3QgYWN0aXZlIGl0IGNhbm5vdCBiZSBtb3ZlZC5cclxuXHJcbnZhciBNb3ZlVXAgPSBmdW5jdGlvbiAoc2NlbmUpXHJcbntcclxuICAgIHZhciBpbmRleCA9ICh0eXBlb2Ygc2NlbmUgPT09ICdzdHJpbmcnKSA/IHRoaXMuZ2V0QWN0aXZlU2NlbmVJbmRleEJ5S2V5KHNjZW5lKSA6IHRoaXMuZ2V0QWN0aXZlU2NlbmVJbmRleChzY2VuZSk7XHJcblxyXG4gICAgaWYgKGluZGV4ICE9PSAtMSAmJiBpbmRleCA8IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHNjZW5lQiA9IHRoaXMuZ2V0U2NlbmVBdChpbmRleCArIDEpO1xyXG5cclxuICAgICAgICBpZiAoc2NlbmVCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zd2FwUG9zaXRpb24oc2NlbmUsIHNjZW5lQik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb3ZlVXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvZ2xvYmFsL2luYy9Nb3ZlVXAuanNcbi8vIG1vZHVsZSBpZCA9IDk0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF1c2UgPSBmdW5jdGlvbiAoa2V5KVxyXG57XHJcbiAgICB2YXIgZW50cnkgPSB0aGlzLmdldEFjdGl2ZVNjZW5lKGtleSk7XHJcblxyXG4gICAgaWYgKGVudHJ5KVxyXG4gICAge1xyXG4gICAgICAgIGVudHJ5LnNjZW5lLnN5cy5wYXVzZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXVzZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL1BhdXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBheWxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudClcclxue1xyXG4gICAgdmFyIHNjZW5lID0gZXZlbnQubG9hZGVyLnNjZW5lO1xyXG5cclxuICAgIHRoaXMuYm9vdFNjZW5lKHNjZW5lKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGF5bG9hZENvbXBsZXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvUGF5bG9hZENvbXBsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlc3VtZSA9IGZ1bmN0aW9uIChrZXkpXHJcbntcclxuICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0QWN0aXZlU2NlbmUoa2V5KTtcclxuXHJcbiAgICBpZiAoZW50cnkpXHJcbiAgICB7XHJcbiAgICAgICAgZW50cnkuc2NlbmUuc3lzLnJlc3VtZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXN1bWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvZ2xvYmFsL2luYy9SZXN1bWUuanNcbi8vIG1vZHVsZSBpZCA9IDk1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgSWYgdGhlIGFyZ3VtZW50cyBhcmUgc3RyaW5ncyB0aGV5IGFyZSBhc3N1bWVkIHRvIGJlIGtleXMsIG90aGVyd2lzZSB0aGV5IGFyZSBTY2VuZSBvYmplY3RzXHJcbi8vICBZb3UgY2FuIG9ubHkgc3dhcCB0aGUgcG9zaXRpb25zIG9mIEFjdGl2ZSAocmVuZGVyaW5nIC8gdXBkYXRpbmcpIFNjZW5lcy4gSWYgYSBTY2VuZSBpcyBub3QgYWN0aXZlIGl0IGNhbm5vdCBiZSBtb3ZlZC5cclxuXHJcbnZhciBTZW5kVG9CYWNrID0gZnVuY3Rpb24gKHNjZW5lKVxyXG57XHJcbiAgICB2YXIgaW5kZXggPSAodHlwZW9mIHNjZW5lID09PSAnc3RyaW5nJykgPyB0aGlzLmdldEFjdGl2ZVNjZW5lSW5kZXhCeUtleShzY2VuZSkgOiB0aGlzLmdldEFjdGl2ZVNjZW5lSW5kZXgoc2NlbmUpO1xyXG5cclxuICAgIGlmIChpbmRleCA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5hY3RpdmUuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgICAgdGhpcy5hY3RpdmUudW5zaGlmdCh7IGluZGV4OiAwLCBzY2VuZTogZW50cnlbMF0uc2NlbmUgfSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVtpXS5pbmRleCA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZW5kVG9CYWNrO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvU2VuZFRvQmFjay5qc1xuLy8gbW9kdWxlIGlkID0gOTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgTk9PUCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL05PT1AnKTtcclxuXHJcbnZhciBTZXR1cENhbGxiYWNrcyA9IGZ1bmN0aW9uIChzY2VuZSwgc2NlbmVDb25maWcpXHJcbntcclxuICAgIGlmIChzY2VuZUNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7IHNjZW5lQ29uZmlnID0gc2NlbmU7IH1cclxuXHJcbiAgICAvLyAgRXh0cmFjdCBjYWxsYmFja3Mgb3Igc2V0IE5PT1BcclxuXHJcbiAgICBzY2VuZS5pbml0ID0gR2V0VmFsdWUoc2NlbmVDb25maWcsICdpbml0JywgTk9PUCk7XHJcbiAgICBzY2VuZS5wcmVsb2FkID0gR2V0VmFsdWUoc2NlbmVDb25maWcsICdwcmVsb2FkJywgTk9PUCk7XHJcbiAgICBzY2VuZS5jcmVhdGUgPSBHZXRWYWx1ZShzY2VuZUNvbmZpZywgJ2NyZWF0ZScsIE5PT1ApO1xyXG4gICAgc2NlbmUuc2h1dGRvd24gPSBHZXRWYWx1ZShzY2VuZUNvbmZpZywgJ3NodXRkb3duJywgTk9PUCk7XHJcblxyXG4gICAgLy8gIEdhbWUgTG9vcCBsZXZlbCBjYWxsYmFja3NcclxuXHJcbiAgICBzY2VuZS51cGRhdGUgPSBHZXRWYWx1ZShzY2VuZUNvbmZpZywgJ3VwZGF0ZScsIE5PT1ApO1xyXG4gICAgc2NlbmUucmVuZGVyID0gR2V0VmFsdWUoc2NlbmVDb25maWcsICdyZW5kZXInLCBOT09QKTtcclxuXHJcbiAgICByZXR1cm4gc2NlbmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldHVwQ2FsbGJhY2tzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvU2V0dXBDYWxsYmFja3MuanNcbi8vIG1vZHVsZSBpZCA9IDk1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2xlZXAgPSBmdW5jdGlvbiAoa2V5KVxyXG57XHJcbiAgICB2YXIgZW50cnkgPSB0aGlzLmdldEFjdGl2ZVNjZW5lKGtleSk7XHJcblxyXG4gICAgaWYgKGVudHJ5KVxyXG4gICAge1xyXG4gICAgICAgIGVudHJ5LnNjZW5lLnN5cy5zbGVlcCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbGVlcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL1NsZWVwLmpzXG4vLyBtb2R1bGUgaWQgPSA5NTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0YXJ0ID0gZnVuY3Rpb24gKGtleSwgZGF0YSlcclxue1xyXG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkgeyBkYXRhID0ge307IH1cclxuXHJcbiAgICAvLyAgaWYgbm90IGJvb3RlZCwgdGhlbiBwdXQgc2NlbmUgaW50byBhIGhvbGRpbmcgcGF0dGVyblxyXG4gICAgaWYgKCF0aGlzLmdhbWUuaXNCb290ZWQpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wZW5kaW5nLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fcGVuZGluZ1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5rZXkgPT09IGtleSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZW50cnkuYXV0b1N0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNjZW5lID0gdGhpcy5nZXRTY2VuZShrZXkpO1xyXG5cclxuICAgIGlmIChzY2VuZSlcclxuICAgIHtcclxuICAgICAgICAvLyAgQWxyZWFkeSBzdGFydGVkPyBOb3RoaW5nIG1vcmUgdG8gZG8gaGVyZSAuLi5cclxuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2NlbmUuc3lzLnN0YXJ0KGRhdGEpO1xyXG5cclxuICAgICAgICB2YXIgbG9hZGVyID0gc2NlbmUuc3lzLmxvYWQ7XHJcblxyXG4gICAgICAgIC8vICBGaWxlcyBwYXlsb2FkP1xyXG4gICAgICAgIGlmIChsb2FkZXIgJiYgQXJyYXkuaXNBcnJheShzY2VuZS5zeXMuc2V0dGluZ3MuZmlsZXMpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbG9hZGVyLnJlc2V0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobG9hZGVyLmxvYWRBcnJheShzY2VuZS5zeXMuc2V0dGluZ3MuZmlsZXMpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsb2FkZXIuZXZlbnRzLm9uY2UoJ0xPQURFUl9DT01QTEVURV9FVkVOVCcsIHRoaXMucGF5bG9hZENvbXBsZXRlLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxvYWRlci5zdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib290U2NlbmUoc2NlbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYm9vdFNjZW5lKHNjZW5lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXJ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvU3RhcnQuanNcbi8vIG1vZHVsZSBpZCA9IDk1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU29ydFNjZW5lcyA9IHJlcXVpcmUoJy4vU29ydFNjZW5lcycpO1xyXG5cclxudmFyIFN0b3AgPSBmdW5jdGlvbiAoa2V5KVxyXG57XHJcbiAgICB2YXIgZW50cnkgPSB0aGlzLmdldEFjdGl2ZVNjZW5lKGtleSk7XHJcblxyXG4gICAgaWYgKGVudHJ5KVxyXG4gICAge1xyXG4gICAgICAgIGVudHJ5LnNjZW5lLnN5cy5zaHV0ZG93bigpO1xyXG5cclxuICAgICAgICAvLyAgUmVtb3ZlIGZyb20gdGhlIGFjdGl2ZSBsaXN0XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5hY3RpdmUuaW5kZXhPZihlbnRyeSk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUuc29ydChTb3J0U2NlbmVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3A7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvZ2xvYmFsL2luYy9TdG9wLmpzXG4vLyBtb2R1bGUgaWQgPSA5NTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN3YXAgPSBmdW5jdGlvbiAoZnJvbSwgdG8pXHJcbntcclxuICAgIHRoaXMuc2xlZXAoZnJvbSk7XHJcblxyXG4gICAgaWYgKHRoaXMuaXNTbGVlcGluZyh0bykpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy53YWtlKHRvKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXJ0KHRvKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3dhcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL1N3YXAuanNcbi8vIG1vZHVsZSBpZCA9IDk1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU29ydFNjZW5lcyA9IHJlcXVpcmUoJy4vU29ydFNjZW5lcycpO1xyXG5cclxuLy8gIElmIHRoZSBhcmd1bWVudHMgYXJlIHN0cmluZ3MgdGhleSBhcmUgYXNzdW1lZCB0byBiZSBrZXlzLCBvdGhlcndpc2UgdGhleSBhcmUgU2NlbmUgb2JqZWN0c1xyXG4vLyAgWW91IGNhbiBvbmx5IHN3YXAgdGhlIHBvc2l0aW9ucyBvZiBBY3RpdmUgKHJlbmRlcmluZyAvIHVwZGF0aW5nKSBTY2VuZXMuIElmIGEgU2NlbmUgaXMgbm90IGFjdGl2ZSBpdCBjYW5ub3QgYmUgbW92ZWQuXHJcblxyXG52YXIgU3dhcFBvc2l0aW9uID0gZnVuY3Rpb24gKHNjZW5lMSwgc2NlbmUyKVxyXG57XHJcbiAgICBpZiAoc2NlbmUxID09PSBzY2VuZTIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbmRleDEgPSAodHlwZW9mIHNjZW5lMSA9PT0gJ3N0cmluZycpID8gdGhpcy5nZXRBY3RpdmVTY2VuZUluZGV4QnlLZXkoc2NlbmUxKSA6IHRoaXMuZ2V0QWN0aXZlU2NlbmVJbmRleChzY2VuZTEpO1xyXG4gICAgdmFyIGluZGV4MiA9ICh0eXBlb2Ygc2NlbmUyID09PSAnc3RyaW5nJykgPyB0aGlzLmdldEFjdGl2ZVNjZW5lSW5kZXhCeUtleShzY2VuZTIpIDogdGhpcy5nZXRBY3RpdmVTY2VuZUluZGV4KHNjZW5lMik7XHJcblxyXG4gICAgaWYgKGluZGV4MSAhPT0gLTEgJiYgaW5kZXgyICE9PSAtMSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZVtpbmRleDFdLmluZGV4ID0gaW5kZXgyO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlW2luZGV4Ml0uaW5kZXggPSBpbmRleDE7XHJcblxyXG4gICAgICAgIHRoaXMuYWN0aXZlLnNvcnQoU29ydFNjZW5lcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN3YXBQb3NpdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9nbG9iYWwvaW5jL1N3YXBQb3NpdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gOTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXYWtlID0gZnVuY3Rpb24gKGtleSlcclxue1xyXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5nZXRBY3RpdmVTY2VuZShrZXkpO1xyXG5cclxuICAgIGlmIChlbnRyeSlcclxuICAgIHtcclxuICAgICAgICBlbnRyeS5zY2VuZS5zeXMud2FrZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXYWtlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL2dsb2JhbC9pbmMvV2FrZS5qc1xuLy8gbW9kdWxlIGlkID0gOTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGVzZSBwcm9wZXJ0aWVzIGdldCBpbmplY3RlZCBpbnRvIHRoZSBTY2VuZSBhbmQgbWFwIHRvIGxvY2FsIHN5c3RlbXNcclxuLy8gIFRoZSBtYXAga2V5IGlzIHRoZSBsb2NhbCBzeXN0ZW0gcmVmZXJlbmNlLCB0aGUgdmFsdWUgaXMgdGhlIHByb3BlcnR5IHRoYXQgaXMgYWRkZWQgdG8gdGhlIFNjZW5lXHJcbi8vICBUaGVzZSBkZWZhdWx0cyBjYW4gYmUgbW9kaWZpZWQgdmlhIHRoZSBTY2VuZSBjb25maWcgb2JqZWN0XHJcblxyXG52YXIgSW5qZWN0aW9uTWFwID0ge1xyXG5cclxuICAgIGdhbWU6ICdnYW1lJyxcclxuXHJcbiAgICBhbmltczogJ2FuaW1zJyxcclxuICAgIGNhY2hlOiAnY2FjaGUnLFxyXG4gICAgcmVnaXN0cnk6ICdyZWdpc3RyeScsXHJcbiAgICB0ZXh0dXJlczogJ3RleHR1cmVzJyxcclxuXHJcbiAgICBhZGQ6ICdhZGQnLFxyXG4gICAgY2FtZXJhczogJ2NhbWVyYXMnLFxyXG4gICAgZGF0YTogJ2RhdGEnLFxyXG4gICAgZGlzcGxheUxpc3Q6ICdjaGlsZHJlbicsXHJcbiAgICBldmVudHM6ICdldmVudHMnLFxyXG4gICAgaW5wdXRNYW5hZ2VyOiAnaW5wdXQnLFxyXG4gICAgbG9hZDogJ2xvYWQnLFxyXG4gICAgbWFrZTogJ21ha2UnLFxyXG4gICAgcGh5c2ljc01hbmFnZXI6ICdwaHlzaWNzJyxcclxuICAgIHBvb2w6ICdwb29sJyxcclxuICAgIHNjZW5lTWFuYWdlcjogJ3NjZW5lJyxcclxuICAgIHRpbWU6ICd0aW1lJyxcclxuICAgIHR3ZWVuczogJ3R3ZWVucydcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluamVjdGlvbk1hcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9sb2NhbC9JbmplY3Rpb25NYXAuanNcbi8vIG1vZHVsZSBpZCA9IDk1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgU2NhbGVNb2RlcyA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVyL1NjYWxlTW9kZXMnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBJbmplY3Rpb25NYXAgPSByZXF1aXJlKCcuL0luamVjdGlvbk1hcCcpO1xyXG5cclxudmFyIFNldHRpbmdzID0ge1xyXG5cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25maWcgPSB7IGtleTogY29uZmlnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFBhc3MgdGhlICdoYXNPd25Qcm9wZXJ0eScgY2hlY2tzXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgICAgIHN0YXR1czogQ09OU1QuUEVORElORyxcclxuXHJcbiAgICAgICAgICAgIG9wOiBDT05TVC5CT09ULFxyXG5cclxuICAgICAgICAgICAga2V5OiBHZXRWYWx1ZShjb25maWcsICdrZXknLCAnJyksXHJcbiAgICAgICAgICAgIGFjdGl2ZTogR2V0VmFsdWUoY29uZmlnLCAnYWN0aXZlJywgZmFsc2UpLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBHZXRWYWx1ZShjb25maWcsICd2aXNpYmxlJywgdHJ1ZSksXHJcblxyXG4gICAgICAgICAgICAvLyAgTG9hZGVyIHBheWxvYWQgYXJyYXlcclxuXHJcbiAgICAgICAgICAgIGRhdGE6IHt9LFxyXG5cclxuICAgICAgICAgICAgZmlsZXM6IEdldFZhbHVlKGNvbmZpZywgJ2ZpbGVzJywgZmFsc2UpLFxyXG5cclxuICAgICAgICAgICAgLy8gIENhbWVyYXNcclxuXHJcbiAgICAgICAgICAgIGNhbWVyYXM6IEdldFZhbHVlKGNvbmZpZywgJ2NhbWVyYXMnLCBudWxsKSxcclxuXHJcbiAgICAgICAgICAgIC8vICBTY2VuZSBQcm9wZXJ0eSBJbmplY3Rpb24gTWFwXHJcblxyXG4gICAgICAgICAgICBtYXA6IEdldFZhbHVlKGNvbmZpZywgJ21hcCcsIEluamVjdGlvbk1hcCksXHJcblxyXG4gICAgICAgICAgICAvLyAgUGh5c2ljc1xyXG4gICAgICAgICAgICBwaHlzaWNzOiBHZXRWYWx1ZShjb25maWcsICdwaHlzaWNzJywge30pLFxyXG5cclxuICAgICAgICAgICAgLy8gIFNjZW5lIFJlbmRlciBTZXR0aW5ncyAoYXBwbGllcyBvbmx5IHRvIHRoaXMgU2NlbmUpXHJcblxyXG4gICAgICAgICAgICBzY2FsZU1vZGU6IEdldFZhbHVlKGNvbmZpZywgJ3NjYWxlTW9kZScsIFNjYWxlTW9kZXMuREVGQVVMVCksXHJcbiAgICAgICAgICAgIHJvdW5kUGl4ZWxzOiBHZXRWYWx1ZShjb25maWcsICdyb3VuZFBpeGVscycsIGZhbHNlKSxcclxuXHJcbiAgICAgICAgICAgIGRpcnR5UmVuZGVyOiBHZXRWYWx1ZShjb25maWcsICdkaXJ0eVJlbmRlcicsIGZhbHNlKSxcclxuICAgICAgICAgICAgcmVuZGVyVG9UZXh0dXJlOiBHZXRWYWx1ZShjb25maWcsICdyZW5kZXJUb1RleHR1cmUnLCBmYWxzZSksXHJcblxyXG4gICAgICAgICAgICAvLyAgVGhlIGZvbGxvd2luZyBvbmx5IGFwcGx5IGlmIHJlbmRlclRvVGV4dHVyZSBpcyB0cnVlXHJcblxyXG4gICAgICAgICAgICBhdXRvUmVzaXplOiBHZXRWYWx1ZShjb25maWcsICdhdXRvUmVzaXplJywgZmFsc2UpXHJcblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5ncztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9sb2NhbC9TZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gOTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBEYXRhID0gcmVxdWlyZSgnLi9EYXRhJyk7XHJcblxyXG52YXIgRGF0YVN0b3JlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIERhdGFTdG9yZSAoc2NlbmUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cyA9IHNjZW5lLnN5cy5ldmVudHM7XHJcblxyXG4gICAgICAgIHRoaXMuX2xpc3QgPSBbXTtcclxuICAgICAgICB0aGlzLl9kYXRhID0gW107XHJcbiAgICB9LFxyXG5cclxuICAgIGdldERhdGE6IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhO1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLl9saXN0LmluZGV4T2YoZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIGlmIChpZHggPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGF0YSA9IG5ldyBEYXRhKGdhbWVPYmplY3QsIHRoaXMuZXZlbnRzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3QucHVzaChnYW1lT2JqZWN0KTtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YS5wdXNoKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGF0YVtpZHhdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGtleSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShnYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGEuZ2V0KGtleSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGtleSwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhLnNldChrZXksIHZhbHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0QWxsOiBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShnYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGEuZ2V0QWxsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHF1ZXJ5OiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgc2VhcmNoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKGdhbWVPYmplY3QpO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YS5xdWVyeShzZWFyY2gpO1xyXG4gICAgfSxcclxuXHJcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBrZXksIGNhbGxiYWNrLCBzY29wZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShnYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGEuYmVmb3JlKGtleSwgY2FsbGJhY2ssIHNjb3BlKTtcclxuICAgIH0sXHJcblxyXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBrZXksIGNhbGxiYWNrLCBzY29wZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShnYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGEuYWZ0ZXIoa2V5LCBjYWxsYmFjaywgc2NvcGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY2FsbGJhY2ssIHNjb3BlLCBhcmdzKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKGdhbWVPYmplY3QpO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YS5lYWNoKGNhbGxiYWNrLCBzY29wZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1lcmdlOiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgZGF0YSwgb3ZlcndyaXRlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKGdhbWVPYmplY3QpO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YS5tZXJnZShkYXRhLCBvdmVyd3JpdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhLnJlbW92ZShrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhLnJlbW92ZUxpc3RlbmVycyhrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwb3A6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhLnBvcChrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXM6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhLmhhcyhrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhLnJlc2V0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZyZWV6ZTogZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgICAgIGRhdGEuZnJlZXplID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgdW5mcmVlemU6IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKGdhbWVPYmplY3QpO1xyXG5cclxuICAgICAgICBkYXRhLmZyZWV6ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBraWxsOiBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0Lmhhc093blByb3BlcnR5KGdhbWVPYmplY3QpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmxpc3RbZ2FtZU9iamVjdF07XHJcblxyXG4gICAgICAgICAgICBkYXRhLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RbZ2FtZU9iamVjdF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTdG9yZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9wbHVnaW5zL0RhdGFTdG9yZS5qc1xuLy8gbW9kdWxlIGlkID0gOTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vaW5wdXQvbG9jYWwvZXZlbnRzJyk7XHJcbnZhciBTY2VuZUlucHV0TWFuYWdlciA9IHJlcXVpcmUoJy4uLy4uL2lucHV0L2xvY2FsL1NjZW5lSW5wdXRNYW5hZ2VyJyk7XHJcblxyXG52YXIgSW5wdXRNYW5hZ2VyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBTY2VuZUlucHV0TWFuYWdlcixcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIElucHV0TWFuYWdlciAoc2NlbmUpXHJcbiAgICB7XHJcbiAgICAgICAgU2NlbmVJbnB1dE1hbmFnZXIuY2FsbCh0aGlzLCBzY2VuZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHBvaW50U2NyZWVuVG9Xb3JsZEhpdFRlc3Q6IGZ1bmN0aW9uIChnYW1lT2JqZWN0cywgeCwgeSwgY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIucG9pbnRTY3JlZW5Ub1dvcmxkSGl0VGVzdChnYW1lT2JqZWN0cywgeCwgeSwgY2FtZXJhKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dE1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvcGx1Z2lucy9JbnB1dE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDk2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmFzZUxvYWRlciA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9CYXNlTG9hZGVyJyk7XHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBOdW1iZXJBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5L051bWJlckFycmF5Jyk7XHJcblxyXG52YXIgQW5pbWF0aW9uSlNPTkZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0FuaW1hdGlvbkpTT05GaWxlJyk7XHJcbnZhciBBdGxhc0pTT05GaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9BdGxhc0pTT05GaWxlJyk7XHJcbnZhciBCaW5hcnlGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlJyk7XHJcbnZhciBCaXRtYXBGb250RmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvQml0bWFwRm9udEZpbGUnKTtcclxudmFyIEdMU0xGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9HTFNMRmlsZScpO1xyXG52YXIgSFRNTEZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0hUTUxGaWxlJyk7XHJcbnZhciBJbWFnZUZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZScpO1xyXG52YXIgSlNPTkZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0pTT05GaWxlJyk7XHJcbnZhciBTY3JpcHRGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9TY3JpcHRGaWxlJyk7XHJcbnZhciBTcHJpdGVTaGVldCA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvU3ByaXRlU2hlZXQnKTtcclxudmFyIFNWR0ZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL1NWR0ZpbGUnKTtcclxudmFyIFRleHRGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZScpO1xyXG52YXIgVW5pdHlBdGxhc0ZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL1VuaXR5QXRsYXNGaWxlJyk7XHJcbnZhciBYTUxGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlJyk7XHJcblxyXG52YXIgTG9hZGVyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBCYXNlTG9hZGVyLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gTG9hZGVyIChzY2VuZSlcclxuICAgIHtcclxuICAgICAgICBCYXNlTG9hZGVyLmNhbGwodGhpcywgc2NlbmUpO1xyXG5cclxuICAgICAgICB0aGlzLl9tdWx0aWxpc3QgPSB7fTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIGtleSBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nLCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb2Ygb2JqZWN0c1xyXG5cclxuICAgIGltYWdlOiBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBJbWFnZUZpbGUuY3JlYXRlKHRoaXMsIGtleSwgdXJsLCB4aHJTZXR0aW5ncyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFuaW1hdGlvbjogZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uSlNPTkZpbGUuY3JlYXRlKHRoaXMsIGtleSwgdXJsLCB4aHJTZXR0aW5ncyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGpzb246IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIEpTT05GaWxlLmNyZWF0ZSh0aGlzLCBrZXksIHVybCwgeGhyU2V0dGluZ3MpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzY3JpcHQ6IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIFNjcmlwdEZpbGUuY3JlYXRlKHRoaXMsIGtleSwgdXJsLCB4aHJTZXR0aW5ncyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHhtbDogZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gWE1MRmlsZS5jcmVhdGUodGhpcywga2V5LCB1cmwsIHhoclNldHRpbmdzKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmluYXJ5OiBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBCaW5hcnlGaWxlLmNyZWF0ZSh0aGlzLCBrZXksIHVybCwgeGhyU2V0dGluZ3MpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0ZXh0OiBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBUZXh0RmlsZS5jcmVhdGUodGhpcywga2V5LCB1cmwsIHhoclNldHRpbmdzKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2xzbDogZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gR0xTTEZpbGUuY3JlYXRlKHRoaXMsIGtleSwgdXJsLCB4aHJTZXR0aW5ncyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGh0bWw6IGZ1bmN0aW9uIChrZXksIHVybCwgd2lkdGgsIGhlaWdodCwgeGhyU2V0dGluZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIEhUTUxGaWxlLmNyZWF0ZSh0aGlzLCBrZXksIHVybCwgd2lkdGgsIGhlaWdodCwgeGhyU2V0dGluZ3MpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdmc6IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIFNWR0ZpbGUuY3JlYXRlKHRoaXMsIGtleSwgdXJsLCB4aHJTZXR0aW5ncyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBjb25maWcgY2FuIGluY2x1ZGU6IGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgbWFyZ2luLCBzcGFjaW5nXHJcbiAgICBzcHJpdGVzaGVldDogZnVuY3Rpb24gKGtleSwgdXJsLCBjb25maWcsIHhoclNldHRpbmdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBTcHJpdGVTaGVldC5jcmVhdGUodGhpcywga2V5LCB1cmwsIGNvbmZpZywgeGhyU2V0dGluZ3MpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyAgTXVsdGktRmlsZSBMb2FkZXJzXHJcbiAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgdW5pdHlBdGxhczogZnVuY3Rpb24gKGtleSwgdGV4dHVyZVVSTCwgYXRsYXNVUkwsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcclxuICAgIHtcclxuICAgICAgICAvLyAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczogJ3RleHR1cmUnIGFuZCAnZGF0YSdcclxuICAgICAgICB2YXIgZmlsZXMgPSBuZXcgVW5pdHlBdGxhc0ZpbGUoa2V5LCB0ZXh0dXJlVVJMLCBhdGxhc1VSTCwgdGhpcy5wYXRoLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIGF0bGFzWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZXMudGV4dHVyZSk7XHJcbiAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGVzLmRhdGEpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgYXRsYXM6IGZ1bmN0aW9uIChrZXksIHRleHR1cmVVUkwsIGF0bGFzVVJMLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIGF0bGFzWGhyU2V0dGluZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXM6ICd0ZXh0dXJlJyBhbmQgJ2RhdGEnXHJcbiAgICAgICAgdmFyIGZpbGVzID0gbmV3IEF0bGFzSlNPTkZpbGUoa2V5LCB0ZXh0dXJlVVJMLCBhdGxhc1VSTCwgdGhpcy5wYXRoLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIGF0bGFzWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZXMudGV4dHVyZSk7XHJcbiAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGVzLmRhdGEpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgYml0bWFwRm9udDogZnVuY3Rpb24gKGtleSwgdGV4dHVyZVVSTCwgeG1sVVJMLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIHhtbFhoclNldHRpbmdzKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiAndGV4dHVyZScgYW5kICdkYXRhJ1xyXG4gICAgICAgIHZhciBmaWxlcyA9IG5ldyBCaXRtYXBGb250RmlsZShrZXksIHRleHR1cmVVUkwsIHhtbFVSTCwgdGhpcy5wYXRoLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIHhtbFhoclNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGVzLnRleHR1cmUpO1xyXG4gICAgICAgIHRoaXMuYWRkRmlsZShmaWxlcy5kYXRhKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIG11bHRpYXRsYXM6IGZ1bmN0aW9uIChrZXksIHRleHR1cmVVUkxzLCBhdGxhc1VSTHMsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRleHR1cmVVUkxzID09PSAnbnVtYmVyJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHRleHR1cmVVUkxzO1xyXG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gKGF0bGFzVVJMcyA9PT0gdW5kZWZpbmVkKSA/ICcnIDogYXRsYXNVUkxzO1xyXG5cclxuICAgICAgICAgICAgdGV4dHVyZVVSTHMgPSBOdW1iZXJBcnJheSgwLCB0b3RhbCwga2V5ICsgc3VmZml4LCAnLnBuZycpO1xyXG4gICAgICAgICAgICBhdGxhc1VSTHMgPSBOdW1iZXJBcnJheSgwLCB0b3RhbCwga2V5ICsgc3VmZml4LCAnLmpzb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRleHR1cmVVUkxzKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZVVSTHMgPSBbIHRleHR1cmVVUkxzIF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhdGxhc1VSTHMpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhdGxhc1VSTHMgPSBbIGF0bGFzVVJMcyBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZmlsZTtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIG11bHRpS2V5O1xyXG5cclxuICAgICAgICB0aGlzLl9tdWx0aWxpc3Rba2V5XSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGV4dHVyZVVSTHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtdWx0aUtleSA9ICdfTUFfSU1HXycgKyBrZXkgKyAnXycgKyBpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBmaWxlID0gbmV3IEltYWdlRmlsZShtdWx0aUtleSwgdGV4dHVyZVVSTHNbaV0sIHRoaXMucGF0aCwgdGV4dHVyZVhoclNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkRmlsZShmaWxlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX211bHRpbGlzdFtrZXldLnB1c2gobXVsdGlLZXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF0bGFzVVJMcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG11bHRpS2V5ID0gJ19NQV9KU09OXycgKyBrZXkgKyAnXycgKyBpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBmaWxlID0gbmV3IEpTT05GaWxlKG11bHRpS2V5LCBhdGxhc1VSTHNbaV0sIHRoaXMucGF0aCwgYXRsYXNYaHJTZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9tdWx0aWxpc3Rba2V5XS5wdXNoKG11bHRpS2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGxvYWRBcnJheTogZnVuY3Rpb24gKGZpbGVzKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGVzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsZShmaWxlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAodGhpcy5saXN0LnNpemUgPiAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmlsZTogZnVuY3Rpb24gKGZpbGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGVudHJ5O1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGZpbGUudHlwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3Nwcml0ZXNoZWV0JzpcclxuICAgICAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5zcHJpdGVzaGVldChmaWxlLmtleSwgZmlsZS51cmwsIGZpbGUuY29uZmlnLCBmaWxlLnhoclNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnYXRsYXMnOlxyXG4gICAgICAgICAgICAgICAgZW50cnkgPSB0aGlzLmF0bGFzKGZpbGUua2V5LCBmaWxlLnRleHR1cmVVUkwsIGZpbGUuYXRsYXNVUkwsIGZpbGUudGV4dHVyZVhoclNldHRpbmdzLCBmaWxlLmF0bGFzWGhyU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdiaXRtYXBGb250JzpcclxuICAgICAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5iaXRtYXBGb250KGZpbGUua2V5LCBmaWxlLnRleHR1cmVVUkwsIGZpbGUueG1sVVJMLCBmaWxlLnRleHR1cmVYaHJTZXR0aW5ncywgZmlsZS54bWxYaHJTZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ211bHRpYXRsYXMnOlxyXG4gICAgICAgICAgICAgICAgZW50cnkgPSB0aGlzLm11bHRpYXRsYXMoZmlsZS5rZXksIGZpbGUudGV4dHVyZVVSTHMsIGZpbGUuYXRsYXNVUkxzLCBmaWxlLnRleHR1cmVYaHJTZXR0aW5ncywgZmlsZS5hdGxhc1hoclNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gIGltYWdlLCBqc29uLCB4bWwsIGJpbmFyeSwgdGV4dCwgZ2xzbCwgc3ZnXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBlbnRyeSA9IHRoaXNbZmlsZS50eXBlXShmaWxlLmtleSwgZmlsZS51cmwsIGZpbGUueGhyU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICB9XHJcbiAgICBcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9wbHVnaW5zL0xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gOTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgTWVyZ2UgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvTWVyZ2UnKTtcclxudmFyIE5PT1AgPSByZXF1aXJlKCcuLi8uLi91dGlscy9OT09QJyk7XHJcblxyXG4vLyAgUGh5c2ljcyBTeXN0ZW1zXHJcbnZhciBJbXBhY3QgPSByZXF1aXJlKCcuLi8uLi9waHlzaWNzL2ltcGFjdC9JbXBhY3QnKTtcclxuXHJcbnZhciBQaHlzaWNzTWFuYWdlciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBQaHlzaWNzTWFuYWdlciAoc2NlbmUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVDb25maWcgPSBzY2VuZS5zeXMuZ2FtZS5jb25maWcucGh5c2ljcztcclxuICAgICAgICB0aGlzLmRlZmF1bHRTeXN0ZW0gPSBzY2VuZS5zeXMuZ2FtZS5jb25maWcuZGVmYXVsdFBoeXNpY3NTeXN0ZW07XHJcbiAgICAgICAgdGhpcy5zY2VuZUNvbmZpZyA9IHNjZW5lLnN5cy5zZXR0aW5ncy5waHlzaWNzO1xyXG5cclxuICAgICAgICAvLyAgVGhpcyBnZXRzIHNldCB0byBhbiBpbnN0YW5jZSBvZiB0aGUgcGh5c2ljcyBzeXN0ZW0gZHVyaW5nIGJvb3RcclxuICAgICAgICB0aGlzLnN5c3RlbTtcclxuXHJcbiAgICAgICAgLy8gIFRoaXMgZ2V0cyBzZXQgYnkgdGhlIHBoeXNpY3Mgc3lzdGVtIGR1cmluZyBib290XHJcbiAgICAgICAgdGhpcy53b3JsZCA9IHsgdXBkYXRlOiBOT09QIH07XHJcblxyXG4gICAgICAgIC8vICBUaGlzIGdldHMgc2V0IGJ5IHRoZSBwaHlzaWNzIHN5c3RlbSBkdXJpbmcgYm9vdFxyXG4gICAgICAgIHRoaXMuYWRkO1xyXG4gICAgfSxcclxuXHJcbiAgICBib290OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzY2VuZVN5c3RlbSA9IEdldFZhbHVlKHRoaXMuc2NlbmVDb25maWcsICdzeXN0ZW0nLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5kZWZhdWx0U3lzdGVtICYmICFzY2VuZVN5c3RlbSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBObyBkZWZhdWx0IHBoeXNpY3Mgc3lzdGVtIG9yIHN5c3RlbSBpbiB0aGlzIHNjZW5lLCBzbyBhYm9ydFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgV2hpY2ggcGh5c2ljcyBzeXN0ZW0gYXJlIHdlIHVzaW5nIGluIHRoaXMgU2NlbmU/XHJcbiAgICAgICAgdmFyIHN5c3RlbSA9IChzY2VuZVN5c3RlbSAhPT0gZmFsc2UpID8gc2NlbmVTeXN0ZW0gOiB0aGlzLmRlZmF1bHRTeXN0ZW07XHJcblxyXG4gICAgICAgIC8vICBDcmVhdGUgdGhlIGNvbmZpZyBmb3IgaXRcclxuICAgICAgICB2YXIgY29uZmlnID0gTWVyZ2UodGhpcy5zY2VuZUNvbmZpZywgR2V0VmFsdWUodGhpcy5nYW1lQ29uZmlnLCBzeXN0ZW0sIHt9KSk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoc3lzdGVtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FzZSAnaW1wYWN0JzpcclxuICAgICAgICAgICAgICAgIHRoaXMuc3lzdGVtID0gbmV3IEltcGFjdCh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICh0aW1lLCBkZWx0YSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLndvcmxkLnVwZGF0ZSh0aW1lLCBkZWx0YSk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGh5c2ljc01hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvcGx1Z2lucy9QaHlzaWNzTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBPYmplY3RQb29sID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvcG9vbC9PYmplY3RQb29sJyk7XHJcbnZhciBTcHJpdGVQb29sID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvcG9vbC9TcHJpdGVQb29sJyk7XHJcblxyXG52YXIgUG9vbE1hbmFnZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gUG9vbE1hbmFnZXIgKHNjZW5lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuXHJcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gW107XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0luc2VydGlvbiA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZW1vdmFsID0gW107XHJcblxyXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChwb29sKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nSW5zZXJ0aW9uLnB1c2gocG9vbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS5wdXNoKHBvb2wpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVNwcml0ZVBvb2w6IGZ1bmN0aW9uIChtYXhTaXplLCBrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwb29sID0gbmV3IFNwcml0ZVBvb2wodGhpcywgbWF4U2l6ZSwga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkKHBvb2wpO1xyXG5cclxuICAgICAgICByZXR1cm4gcG9vbDtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlT2JqZWN0UG9vbDogZnVuY3Rpb24gKGNsYXNzVHlwZSwgbWF4U2l6ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAobWF4U2l6ZSA9PT0gdW5kZWZpbmVkKSB7IG1heFNpemUgPSAtMTsgfVxyXG5cclxuICAgICAgICB2YXIgcG9vbCA9IG5ldyBPYmplY3RQb29sKHRoaXMsIGNsYXNzVHlwZSwgbWF4U2l6ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkKHBvb2wpO1xyXG5cclxuICAgICAgICByZXR1cm4gcG9vbDtcclxuICAgIH0sXHJcblxyXG4gICAgYmVnaW46IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gdGhpcy5fcGVuZGluZ1JlbW92YWwubGVuZ3RoO1xyXG4gICAgICAgIHZhciB0b0luc2VydCA9IHRoaXMuX3BlbmRpbmdJbnNlcnRpb24ubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAodG9SZW1vdmUgPT09IDAgJiYgdG9JbnNlcnQgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUXVpY2sgYmFpbFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgcG9vbDtcclxuXHJcbiAgICAgICAgLy8gIERlbGV0ZSBvbGQgcG9vbHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9SZW1vdmU7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBvb2wgPSB0aGlzLl9wZW5kaW5nUmVtb3ZhbFtpXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2FjdGl2ZS5pbmRleE9mKHBvb2wpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwb29sLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBNb3ZlIHBlbmRpbmcgdG8gYWN0aXZlXHJcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdGhpcy5fYWN0aXZlLmNvbmNhdCh0aGlzLl9wZW5kaW5nSW5zZXJ0aW9uLnNwbGljZSgwKSk7XHJcblxyXG4gICAgICAgIC8vICBDbGVhciB0aGUgbGlzdHNcclxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVtb3ZhbC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdJbnNlcnRpb24ubGVuZ3RoID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAodGltZSwgZGVsdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcG9vbCA9IHRoaXMuX2FjdGl2ZVtpXTtcclxuXHJcbiAgICAgICAgICAgIHBvb2wudXBkYXRlLmNhbGwocG9vbCwgdGltZSwgZGVsdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBTY2VuZSB0aGF0IG93bnMgdGhpcyBQb29sIGlzIHNodXR0aW5nIGRvd25cclxuICAgIHNodXRkb3duOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fcGVuZGluZ0luc2VydGlvbi5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdJbnNlcnRpb25baV0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2FjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVtpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fcGVuZGluZ1JlbW92YWwubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVtb3ZhbFtpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9hY3RpdmUubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVtb3ZhbC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdJbnNlcnRpb24ubGVuZ3RoID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEdhbWUgbGV2ZWwgbnVrZVxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNodXRkb3duKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2NlbmUgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9vbE1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NlbmUvcGx1Z2lucy9Qb29sTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcblxyXG4vLyAgQSBwcm94eSBjbGFzcyB0byB0aGUgR2xvYmFsIFNjZW5lIE1hbmFnZXJcclxudmFyIFNjZW5lTWFuYWdlciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBTY2VuZU1hbmFnZXIgKHNjZW5lKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUaGUgU2NlbmUgdGhhdCBvd25zIHRoaXMgcGx1Z2luXHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2NlbmUuc3lzLnNldHRpbmdzO1xyXG5cclxuICAgICAgICB0aGlzLmtleSA9IHNjZW5lLnN5cy5zZXR0aW5ncy5rZXk7XHJcblxyXG4gICAgICAgIC8vICBHbG9iYWxTY2VuZU1hbmFnZXJcclxuICAgICAgICB0aGlzLm1hbmFnZXIgPSBzY2VuZS5zeXMuZ2FtZS5zY2VuZTtcclxuXHJcbiAgICAgICAgLy8gIFByaXZhdGVcclxuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX3F1ZXVlLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtYW5hZ2VyID0gdGhpcy5tYW5hZ2VyO1xyXG5cclxuICAgICAgICAvLyAgUHJvY2VzcyB0aGUgcXVldWVcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuX3F1ZXVlW2ldO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmFkZChhY3Rpb24ua2V5LCBhY3Rpb24uZGF0YSwgYWN0aW9uLmF1dG9TdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuc3RvcCh0aGlzLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5zdGFydChhY3Rpb24ua2V5LCBhY3Rpb24uZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGF1bmNoJzpcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLnN0YXJ0KGFjdGlvbi5rZXksIGFjdGlvbi5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdwYXVzZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5wYXVzZShhY3Rpb24ua2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZXN1bWUnOlxyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIucmVzdW1lKGFjdGlvbi5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0b3AnOlxyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuc3RvcChhY3Rpb24ua2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdzd2FwJzpcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLnN3YXAodGhpcy5rZXksIGFjdGlvbi5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vdmVVcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5tb3ZlVXAodGhpcy5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vdmVEb3duJzpcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLm1vdmVEb3duKHRoaXMua2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdicmluZ1RvVG9wJzpcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmJyaW5nVG9Ub3AodGhpcy5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlbmRUb0JhY2snOlxyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuc2VuZFRvQmFjayh0aGlzLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3dhcFBvc2l0aW9uJzpcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLnN3YXBQb3NpdGlvbih0aGlzLmtleSwgYWN0aW9uLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc2xlZXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuc2xlZXAoYWN0aW9uLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnd2FrZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci53YWtlKGFjdGlvbi5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU2h1dGRvd24gdGhpcyBTY2VuZSBhbmQgcnVuIHRoZSBnaXZlbiBvbmVcclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoa2V5LCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgeyBrZXkgPSB0aGlzLmtleTsgfVxyXG5cclxuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgdHlwZTogJ3N0YXJ0Jywga2V5OiBrZXksIGRhdGE6IGRhdGEgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQWRkIHRoZSBTY2VuZSBpbnRvIHRoZSBTY2VuZSBNYW5hZ2VyIGFuZCBzdGFydCBpdCBpZiAnYXV0b1N0YXJ0JyBpcyB0cnVlIG9yIHRoZSBTY2VuZSBjb25maWcgJ2FjdGl2ZScgcHJvcGVydHkgaXMgc2V0XHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChrZXksIHNjZW5lQ29uZmlnLCBhdXRvU3RhcnQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7IHR5cGU6ICdhZGQnLCBrZXk6IGtleSwgZGF0YTogc2NlbmVDb25maWcsIGF1dG9TdGFydDogYXV0b1N0YXJ0IH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIExhdW5jaCB0aGUgZ2l2ZW4gU2NlbmUgYW5kIHJ1biBpdCBpbiBwYXJhbGxlbCB3aXRoIHRoaXMgb25lXHJcbiAgICBsYXVuY2g6IGZ1bmN0aW9uIChrZXksIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7IGtleSA9IHRoaXMua2V5OyB9XHJcblxyXG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyB0eXBlOiAnbGF1bmNoJywga2V5OiBrZXksIGRhdGE6IGRhdGEgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUGF1c2UgdGhlIFNjZW5lIC0gdGhpcyBzdG9wcyB0aGUgdXBkYXRlIHN0ZXAgZnJvbSBoYXBwZW5pbmcgYnV0IGl0IHN0aWxsIHJlbmRlcnNcclxuICAgIHBhdXNlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgeyBrZXkgPSB0aGlzLmtleTsgfVxyXG5cclxuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgdHlwZTogJ3BhdXNlJywga2V5OiBrZXkgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUmVzdW1lIHRoZSBTY2VuZSAtIHN0YXJ0cyB0aGUgdXBkYXRlIGxvb3AgYWdhaW5cclxuICAgIHJlc3VtZTogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHsga2V5ID0gdGhpcy5rZXk7IH1cclxuXHJcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7IHR5cGU6ICdyZXN1bWUnLCBrZXk6IGtleSB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBNYWtlcyB0aGUgU2NlbmUgc2xlZXAgKG5vIHVwZGF0ZSwgbm8gcmVuZGVyKSBidXQgZG9lc24ndCBzaHV0ZG93blxyXG4gICAgc2xlZXA6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7IHR5cGU6ICdzbGVlcCcsIGtleToga2V5IH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIE1ha2VzIHRoZSBTY2VuZSB3YWtlLXVwIChzdGFydHMgdXBkYXRlIGFuZCByZW5kZXIpXHJcbiAgICB3YWtlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyB0eXBlOiAnd2FrZScsIGtleToga2V5IH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIE1ha2VzIHRoaXMgU2NlbmUgc2xlZXAgdGhlbiBzdGFydHMgdGhlIFNjZW5lIGdpdmVuXHJcbiAgICBzd2FwOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyB0eXBlOiAnc3dhcCcsIGtleToga2V5IH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFNodXRkb3duIHRoZSBTY2VuZSwgY2xlYXJpbmcgZGlzcGxheSBsaXN0LCB0aW1lcnMsIGV0Y1xyXG4gICAgc3RvcDogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHsga2V5ID0gdGhpcy5rZXk7IH1cclxuXHJcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7IHR5cGU6ICdzdG9wJywga2V5OiBrZXkgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncy52aXNpYmxlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzd2FwUG9zaXRpb246IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7IHR5cGU6ICdzd2FwUG9zaXRpb24nLCBrZXk6IGtleSB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZVVwOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyB0eXBlOiAnbW92ZVVwJyB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZURvd246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7IHR5cGU6ICdtb3ZlRG93bicgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJyaW5nVG9Ub3A6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7IHR5cGU6ICdicmluZ1RvVG9wJyB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgdHlwZTogJ3NlbmRUb0JhY2snIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRTY2VuZShrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc2l0aW9uVG86IGZ1bmN0aW9uIChrZXksIGR1cmF0aW9uKVxyXG4gICAge1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHsga2V5ID0gdGhpcy5rZXk7IH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5pc0FjdGl2ZShrZXkpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY2VuZS9wbHVnaW5zL1NjZW5lTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcblxyXG52YXIgVXBkYXRlTGlzdCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBVcGRhdGVMaXN0IChzY2VuZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcblxyXG4gICAgICAgIHRoaXMuX2xpc3QgPSBbXTtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nSW5zZXJ0aW9uID0gW107XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlbW92YWwgPSBbXTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0luc2VydGlvbi5wdXNoKGNoaWxkKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmVnaW46IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gdGhpcy5fcGVuZGluZ1JlbW92YWwubGVuZ3RoO1xyXG4gICAgICAgIHZhciB0b0luc2VydCA9IHRoaXMuX3BlbmRpbmdJbnNlcnRpb24ubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAodG9SZW1vdmUgPT09IDAgJiYgdG9JbnNlcnQgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUXVpY2sgYmFpbFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgLy8gIERlbGV0ZSBvbGQgZ2FtZU9iamVjdHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9SZW1vdmU7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QgPSB0aGlzLl9wZW5kaW5nUmVtb3ZhbFtpXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2xpc3QuaW5kZXhPZihnYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vICBQb29sIHRoZW0/XHJcbiAgICAgICAgICAgIC8vIGdhbWVPYmplY3QuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIE1vdmUgcGVuZGluZyB0byBhY3RpdmVcclxuICAgICAgICB0aGlzLl9saXN0ID0gdGhpcy5fbGlzdC5jb25jYXQodGhpcy5fcGVuZGluZ0luc2VydGlvbi5zcGxpY2UoMCkpO1xyXG5cclxuICAgICAgICAvLyAgQ2xlYXIgdGhlIGxpc3RzXHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlbW92YWwubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nSW5zZXJ0aW9uLmxlbmd0aCA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWUsIGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBnYW1lT2JqZWN0ID0gdGhpcy5fbGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChnYW1lT2JqZWN0LmFjdGl2ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdC5wcmVVcGRhdGUuY2FsbChnYW1lT2JqZWN0LCB0aW1lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2xpc3QuaW5kZXhPZihjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5fbGlzdC5sZW5ndGg7XHJcblxyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLl9saXN0W2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU2NlbmUgdGhhdCBvd25zIHRoaXMgQ2xvY2sgaXMgc2h1dHRpbmcgZG93blxyXG4gICAgc2h1dGRvd246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fbGlzdC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZW1vdmFsLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0luc2VydGlvbi5sZW5ndGggPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgR2FtZSBsZXZlbCBudWtlXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcclxuXHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVcGRhdGVMaXN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjZW5lL3BsdWdpbnMvVXBkYXRlTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gOTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQmV0d2VlbiA9IHJlcXVpcmUoJy4uLy4uL21hdGgvQmV0d2VlbicpO1xyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxuXHJcbi8vICBQaGFzZXIuU291bmQuRHluYW1pYy5GWFxyXG5cclxuLy8gIEJhc2VkIG9uIFNvdW5kLmpzIGJ5IEtpdHR5S2F0QXR0YWNrXHJcbi8vICBodHRwczovL2dpdGh1Yi5jb20va2l0dHlrYXRhdHRhY2svc291bmQuanNcclxuXHJcbi8vIGZyZXF1ZW5jeSwgICAgICAvL1RoZSBzb3VuZCdzIGZlcXVlbmN5IHBpdGNoIGluIEhlcnR6XHJcbi8vIGF0dGFjaywgICAgICAgICAgICAgIC8vVGhlIHRpbWUsIGluIHNlY29uZHMsIHRvIGZhZGUgdGhlIHNvdW5kIGluXHJcbi8vIGRlY2F5LCAgICAgICAgICAgICAgIC8vVGhlIHRpbWUsIGluIHNlY29uZHMsIHRvIGZhZGUgdGhlIHNvdW5kIG91dFxyXG4vLyB0eXBlLCAgICAgICAgICAgICAgICAvL3dhdmVmb3JtIHR5cGU6IFwic2luZVwiLCBcInRyaWFuZ2xlXCIsIFwic3F1YXJlXCIsIFwic2F3dG9vdGhcIlxyXG4vLyB2b2x1bWUsICAgICAgICAgLy9UaGUgc291bmQncyBtYXhpbXVtIHZvbHVtZVxyXG4vLyBwYW5WYWx1ZSwgICAgICAgICAgICAvL1RoZSBzcGVha2VyIHBhbi4gbGVmdDogLTEsIG1pZGRsZTogMCwgcmlnaHQ6IDFcclxuLy8gd2FpdCwgICAgICAgICAgICAgICAgLy9UaGUgdGltZSwgaW4gc2Vjb25kcywgdG8gd2FpdCBiZWZvcmUgcGxheWluZyB0aGUgc291bmRcclxuLy8gcGl0Y2hCZW5kLCAgICAgLy9UaGUgbnVtYmVyIG9mIEh6IGluIHdoaWNoIHRvIGJlbmQgdGhlIHNvdW5kJ3MgcGl0Y2ggZG93blxyXG4vLyByZXZlcnNlLCAgICAgICAgICAgICAvL0lmIGByZXZlcnNlYCBpcyB0cnVlIHRoZSBwaXRjaCB3aWxsIGJlbmQgdXBcclxuLy8gcmFuZG9tLCAgICAgICAgIC8vQSByYW5nZSwgaW4gSHosIHdpdGhpbiB3aGljaCB0byByYW5kb21pemUgdGhlIHBpdGNoXHJcbi8vIGRpc3NvbmFuY2UsICAgICAgICAgIC8vQSB2YWx1ZSBpbiBIei4gSXQgY3JlYXRlcyAyIGRpc3NvbmFudCBmcmVxdWVuY2llcyBhYm92ZSBhbmQgYmVsb3cgdGhlIHRhcmdldCBwaXRjaFxyXG4vLyBlY2hvLCAgICAgICAgICAgICAgICAvL0FuIGFycmF5OiBbZGVsYXlUaW1lSW5TZWNvbmRzLCBmZWVkYmFja1RpbWVJblNlY29uZHMsIGZpbHRlclZhbHVlSW5Iel1cclxuLy8gcmV2ZXJiLCAgICAgICAgICAgICAgLy9BbiBhcnJheTogW2R1cmF0aW9uSW5TZWNvbmRzLCBkZWNheVJhdGVJblNlY29uZHMsIHJldmVyc2VdXHJcbi8vIHRpbWVvdXQgICAgICAgICAgICAgIC8vQSBudW1iZXIsIGluIHNlY29uZHMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGR1cmF0aW9uIGZvciBzb3VuZCBlZmZlY3RzXHJcblxyXG52YXIgRlggPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gRlggKGN0eCwgY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gY3R4O1xyXG5cclxuICAgICAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlID0gR2V0VmFsdWUoY29uZmlnLCAnZnJlcXVlbmN5JywgMjAwKTtcclxuICAgICAgICB0aGlzLmF0dGFjayA9IEdldFZhbHVlKGNvbmZpZywgJ2F0dGFjaycsIDApO1xyXG4gICAgICAgIHRoaXMuZGVjYXkgPSBHZXRWYWx1ZShjb25maWcsICdkZWNheScsIDEpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IEdldFZhbHVlKGNvbmZpZywgJ3R5cGUnLCAnc2luZScpO1xyXG4gICAgICAgIHRoaXMudm9sdW1lVmFsdWUgPSBHZXRWYWx1ZShjb25maWcsICd2b2x1bWUnLCAxKTtcclxuICAgICAgICB0aGlzLnBhblZhbHVlID0gR2V0VmFsdWUoY29uZmlnLCAncGFuJywgMCk7XHJcbiAgICAgICAgdGhpcy53YWl0ID0gR2V0VmFsdWUoY29uZmlnLCAnd2FpdCcsIDApO1xyXG4gICAgICAgIHRoaXMucGl0Y2hCZW5kQW1vdW50ID0gR2V0VmFsdWUoY29uZmlnLCAncGl0Y2hCZW5kJywgMCk7XHJcbiAgICAgICAgdGhpcy5yZXZlcnNlID0gR2V0VmFsdWUoY29uZmlnLCAncmV2ZXJzZScsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLnJhbmRvbVZhbHVlID0gR2V0VmFsdWUoY29uZmlnLCAncmFuZG9tJywgMCk7XHJcbiAgICAgICAgdGhpcy5kaXNzb25hbmNlID0gR2V0VmFsdWUoY29uZmlnLCAnZGlzc29uYW5jZScsIDApO1xyXG4gICAgICAgIHRoaXMuZWNobyA9IEdldFZhbHVlKGNvbmZpZywgJ2VjaG8nLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5lY2hvRGVsYXkgPSBHZXRWYWx1ZShjb25maWcsICdlY2hvLmRlbGF5JywgMCk7XHJcbiAgICAgICAgdGhpcy5lY2hvRmVlZGJhY2sgPSBHZXRWYWx1ZShjb25maWcsICdlY2hvLmZlZWRiYWNrJywgMCk7XHJcbiAgICAgICAgdGhpcy5lY2hvRmlsdGVyID0gR2V0VmFsdWUoY29uZmlnLCAnZWNoby5maWx0ZXInLCAwKTtcclxuICAgICAgICB0aGlzLnJldmVyYiA9IEdldFZhbHVlKGNvbmZpZywgJ3JldmVyYicsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLnJldmVyYkR1cmF0aW9uID0gR2V0VmFsdWUoY29uZmlnLCAncmV2ZXJiLmR1cmF0aW9uJywgMCk7XHJcbiAgICAgICAgdGhpcy5yZXZlcmJEZWNheSA9IEdldFZhbHVlKGNvbmZpZywgJ3JldmVyYi5kZWNheScsIDApO1xyXG4gICAgICAgIHRoaXMucmV2ZXJiUmV2ZXJzZSA9IEdldFZhbHVlKGNvbmZpZywgJ3JldmVyYi5yZXZlcnNlJywgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMudGltZW91dCA9IEdldFZhbHVlKGNvbmZpZywgJ3RpbWVvdXQnLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHRoaXMudm9sdW1lID0gY3R4LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB0aGlzLnBhbiA9ICghY3R4LmNyZWF0ZVN0ZXJlb1Bhbm5lcikgPyBjdHguY3JlYXRlUGFubmVyKCkgOiBjdHguY3JlYXRlU3RlcmVvUGFubmVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMudm9sdW1lLmNvbm5lY3QodGhpcy5wYW4pO1xyXG4gICAgICAgIHRoaXMucGFuLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gIFNldCB0aGUgdmFsdWVzXHJcblxyXG4gICAgICAgIHRoaXMudm9sdW1lLmdhaW4udmFsdWUgPSB0aGlzLnZvbHVtZVZhbHVlO1xyXG5cclxuICAgICAgICBpZiAoIWN0eC5jcmVhdGVTdGVyZW9QYW5uZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBhbi5zZXRQb3NpdGlvbih0aGlzLnBhblZhbHVlLCAwLCAxIC0gTWF0aC5hYnModGhpcy5wYW5WYWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBhbi5wYW4udmFsdWUgPSB0aGlzLnBhblZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIENyZWF0ZSBhbiBvc2NpbGxhdG9yLCBnYWluIGFuZCBwYW4gbm9kZXMsIGFuZCBjb25uZWN0IHRoZW0gdG9nZXRoZXIgdG8gdGhlIGRlc3RpbmF0aW9uXHJcblxyXG4gICAgICAgIHZhciBvc2NpbGxhdG9yID0gY3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuXHJcbiAgICAgICAgb3NjaWxsYXRvci5jb25uZWN0KHRoaXMudm9sdW1lKTtcclxuICAgICAgICBvc2NpbGxhdG9yLnR5cGUgPSB0aGlzLnR5cGU7XHJcblxyXG4gICAgICAgIC8vICBPcHRpb25hbGx5IHJhbmRvbWl6ZSB0aGUgcGl0Y2ggaWYgYHJhbmRvbVZhbHVlYCA+IDAuXHJcbiAgICAgICAgLy8gIEEgcmFuZG9tIHBpdGNoIGlzIHNlbGVjdGVkIHRoYXQncyB3aXRoaW4gdGhlIHJhbmdlIHNwZWNpZmllZCBieSBgZnJlcXVlbmN5VmFsdWVgLlxyXG4gICAgICAgIC8vICBUaGUgcmFuZG9tIHBpdGNoIHdpbGwgYmUgZWl0aGVyIGFib3ZlIG9yIGJlbG93IHRoZSB0YXJnZXQgZnJlcXVlbmN5LlxyXG5cclxuICAgICAgICBpZiAodGhpcy5yYW5kb21WYWx1ZSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS52YWx1ZSA9IEJldHdlZW4oXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlIC0gdGhpcy5yYW5kb21WYWx1ZSAvIDIsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlICsgdGhpcy5yYW5kb21WYWx1ZSAvIDJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmZyZXF1ZW5jeVZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEFwcGx5IGVmZmVjdHNcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXR0YWNrID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmFkZUluKHRoaXMudm9sdW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZmFkZU91dCh0aGlzLnZvbHVtZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBpdGNoQmVuZEFtb3VudCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBpdGNoQmVuZChvc2NpbGxhdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVjaG8pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVjaG8odGhpcy52b2x1bWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucmV2ZXJiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRSZXZlcmIodGhpcy52b2x1bWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzc29uYW5jZSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFkZERpc3NvbmFuY2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucGxheShvc2NpbGxhdG9yKTtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgb3NjaWxsYXRvci5vbmVuZGVkID0gZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF90aGlzLnBhbi5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIF90aGlzLnZvbHVtZS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgcGxheTogZnVuY3Rpb24gKG9zY2lsbGF0b3IpXHJcbiAgICB7XHJcbiAgICAgICAgb3NjaWxsYXRvci5zdGFydCh0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCk7XHJcblxyXG4gICAgICAgIC8vT3NjaWxsYXRvcnMgaGF2ZSB0byBiZSBzdG9wcGVkIG90aGVyd2lzZSB0aGV5IGFjY3VtdWxhdGUgaW4gXHJcbiAgICAgICAgLy9tZW1vcnkgYW5kIHRheCB0aGUgQ1BVLiBUaGV5J2xsIGJlIHN0b3BwZWQgYWZ0ZXIgYSBkZWZhdWx0XHJcbiAgICAgICAgLy90aW1lb3V0IG9mIDIgc2Vjb25kcywgd2hpY2ggc2hvdWxkIGJlIGVub3VnaCBmb3IgbW9zdCBzb3VuZCBcclxuICAgICAgICAvL2VmZmVjdHMuIE92ZXJyaWRlIHRoaXMgaW4gdGhlIGBzb3VuZEVmZmVjdGAgcGFyYW1ldGVycyBpZiB5b3VcclxuICAgICAgICAvL25lZWQgYSBsb25nZXIgc291bmRcclxuXHJcbiAgICAgICAgb3NjaWxsYXRvci5zdG9wKHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgMik7XHJcbiAgICB9LFxyXG5cclxuICAgIGZhZGVJbjogZnVuY3Rpb24gKHZvbHVtZSlcclxuICAgIHtcclxuICAgICAgICB2b2x1bWUuZ2Fpbi52YWx1ZSA9IDA7XHJcblxyXG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0KTtcclxuXHJcbiAgICAgICAgdm9sdW1lLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy52b2x1bWVWYWx1ZSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZhZGVPdXQ6IGZ1bmN0aW9uICh2b2x1bWUpXHJcbiAgICB7XHJcbiAgICAgICAgdm9sdW1lLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy52b2x1bWVWYWx1ZSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayk7XHJcblxyXG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2sgKyB0aGlzLmRlY2F5KTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkUmV2ZXJiOiBmdW5jdGlvbiAodm9sdW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjb252b2x2ZXIgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcclxuXHJcbiAgICAgICAgY29udm9sdmVyLmJ1ZmZlciA9IHRoaXMuaW1wdWxzZVJlc3BvbnNlKHRoaXMucmV2ZXJiRHVyYXRpb24sIHRoaXMucmV2ZXJiRGVjYXksIHRoaXMucmV2ZXJiUmV2ZXJzZSwgdGhpcy5hdWRpb0NvbnRleHQpO1xyXG5cclxuICAgICAgICB2b2x1bWUuY29ubmVjdChjb252b2x2ZXIpO1xyXG5cclxuICAgICAgICBjb252b2x2ZXIuY29ubmVjdCh0aGlzLnBhbik7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEVjaG86IGZ1bmN0aW9uICh2b2x1bWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZlZWRiYWNrID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHZhciBkZWxheSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZURlbGF5KCk7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xyXG5cclxuICAgICAgICAvLyAgU2V0IHRoZSBub2RlIHZhbHVlc1xyXG5cclxuICAgICAgICBmZWVkYmFjay5nYWluLnZhbHVlID0gdGhpcy5lY2hvRmVlZGJhY2s7XHJcbiAgICAgICAgZGVsYXkuZGVsYXlUaW1lLnZhbHVlID0gdGhpcy5lY2hvRGVsYXk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVjaG9GaWx0ZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmaWx0ZXIuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5lY2hvRmlsdGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIENyZWF0ZSB0aGUgZGVsYXkgZmVlZGJhY2sgbG9vcCAod2l0aCBvcHRpb25hbCBmaWx0ZXJpbmcpXHJcblxyXG4gICAgICAgIGRlbGF5LmNvbm5lY3QoZmVlZGJhY2spO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lY2hvRmlsdGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmVlZGJhY2suY29ubmVjdChmaWx0ZXIpO1xyXG4gICAgICAgICAgICBmaWx0ZXIuY29ubmVjdChkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZlZWRiYWNrLmNvbm5lY3QoZGVsYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIENvbm5lY3QgdGhlIGRlbGF5IG5vZGUgdG8gdGhlIG9zY2lsbGF0b3Igdm9sdW1lIG5vZGVcclxuXHJcbiAgICAgICAgdm9sdW1lLmNvbm5lY3QoZGVsYXkpO1xyXG5cclxuICAgICAgICAvLyAgQ29ubmVjdCB0aGUgZGVsYXkgbm9kZSB0byB0aGUgbWFpbiBzb3VuZCBjaGFpbnMgcGFuIG5vZGUsXHJcbiAgICAgICAgLy8gIHNvIHRoYXQgdGhlIGVjaG8gZWZmZWN0IGlzIGRpcmVjdGVkIHRvIHRoZSBjb3JyZWN0IHNwZWFrZXJcclxuXHJcbiAgICAgICAgZGVsYXkuY29ubmVjdCh0aGlzLnBhbik7XHJcbiAgICB9LFxyXG5cclxuICAgIHBpdGNoQmVuZDogZnVuY3Rpb24gKG9zY2lsbGF0b3IpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZyZXF1ZW5jeSA9IG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMucmV2ZXJzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBJZiByZXZlcnNlIGlzIGZhbHNlLCBtYWtlIHRoZSBzb3VuZCBkcm9wIGluIHBpdGNoXHJcbiAgICAgICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGZyZXF1ZW5jeSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQpO1xyXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3kgLSB0aGlzLnBpdGNoQmVuZEFtb3VudCwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayArIHRoaXMuZGVjYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSWYgcmV2ZXJzZSBpcyB0cnVlLCBtYWtlIHRoZSBzb3VuZCByaXNlIGluIHBpdGNoXHJcbiAgICAgICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGZyZXF1ZW5jeSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQpO1xyXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3kgKyB0aGlzLnBpdGNoQmVuZEFtb3VudCwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayArIHRoaXMuZGVjYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZERpc3NvbmFuY2U6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIENyZWF0ZSB0d28gbW9yZSBvc2NpbGxhdG9ycyBhbmQgZ2FpbiBub2Rlc1xyXG5cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgICAgIHZhciBkMSA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcbiAgICAgICAgdmFyIGQyID0gY3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuICAgICAgICB2YXIgZDFWb2x1bWUgPSBjdHguY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHZhciBkMlZvbHVtZSA9IGN0eC5jcmVhdGVHYWluKCk7XHJcblxyXG4gICAgICAgIC8vICBTZXQgdGhlIHZvbHVtZSB0byB0aGUgYHZvbHVtZVZhbHVlYFxyXG4gICAgICAgIGQxVm9sdW1lLmdhaW4udmFsdWUgPSB0aGlzLnZvbHVtZVZhbHVlO1xyXG4gICAgICAgIGQyVm9sdW1lLmdhaW4udmFsdWUgPSB0aGlzLnZvbHVtZVZhbHVlO1xyXG5cclxuICAgICAgICAvLyAgQ29ubmVjdCB0aGUgb3NjaWxsYXRvcnMgdG8gdGhlIGdhaW4gYW5kIGRlc3RpbmF0aW9uIG5vZGVzXHJcbiAgICAgICAgZDEuY29ubmVjdChkMVZvbHVtZSk7XHJcbiAgICAgICAgZDIuY29ubmVjdChkMlZvbHVtZSk7XHJcblxyXG4gICAgICAgIGQxVm9sdW1lLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICBkMlZvbHVtZS5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcblxyXG4gICAgICAgIC8vICBTZXQgdGhlIHdhdmVmb3JtIHRvIFwic2F3dG9vdGhcIiBmb3IgYSBoYXJzaCBlZmZlY3RcclxuICAgICAgICBkMS50eXBlID0gJ3Nhd3Rvb3RoJztcclxuICAgICAgICBkMi50eXBlID0gJ3Nhd3Rvb3RoJztcclxuXHJcbiAgICAgICAgLy8gIE1ha2UgdGhlIHR3byBvc2NpbGxhdG9ycyBwbGF5IGF0IGZyZXF1ZW5jaWVzIGFib3ZlIGFuZCBiZWxvdyB0aGUgbWFpbiBzb3VuZCdzIGZyZXF1ZW5jeS5cclxuICAgICAgICAvLyAgVXNlIHdoYXRldmVyIHZhbHVlIHdhcyBzdXBwbGllZCBieSB0aGUgYGRpc3NvbmFuY2VgIGFyZ3VtZW50XHJcbiAgICAgICAgZDEuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5mcmVxdWVuY3lWYWx1ZSArIHRoaXMuZGlzc29uYW5jZTtcclxuICAgICAgICBkMi5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmZyZXF1ZW5jeVZhbHVlIC0gdGhpcy5kaXNzb25hbmNlO1xyXG5cclxuICAgICAgICAvLyAgRmFkZSBpbiAvIG91dCwgcGl0Y2ggYmVuZCBhbmQgcGxheSB0aGUgb3NjaWxsYXRvcnMgdG8gbWF0Y2ggdGhlIG1haW4gc291bmRcclxuICAgICAgICBpZiAodGhpcy5hdHRhY2sgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5mYWRlSW4oZDFWb2x1bWUpO1xyXG4gICAgICAgICAgICB0aGlzLmZhZGVJbihkMlZvbHVtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5kZWNheSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZhZGVPdXQoZDFWb2x1bWUpO1xyXG4gICAgICAgICAgICB0aGlzLmZhZGVPdXQoZDJWb2x1bWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucGl0Y2hCZW5kQW1vdW50ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucGl0Y2hCZW5kKGQxKTtcclxuICAgICAgICAgICAgdGhpcy5waXRjaEJlbmQoZDIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWNobylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWNobyhkMVZvbHVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWNobyhkMlZvbHVtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5yZXZlcmIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFJldmVyYihkMVZvbHVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUmV2ZXJiKGQyVm9sdW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucGxheShkMSk7XHJcbiAgICAgICAgdGhpcy5wbGF5KGQyKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW1wdWxzZVJlc3BvbnNlOiBmdW5jdGlvbiAoZHVyYXRpb24sIGRlY2F5LCByZXZlcnNlKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgKiBkdXJhdGlvbjtcclxuXHJcbiAgICAgICAgLy8gIENyZWF0ZSBhbiBhdWRpbyBidWZmZXIgKGFuIGVtcHR5IHNvdW5kIGNvbnRhaW5lcikgdG8gc3RvcmUgdGhlIHJldmVyYiBlZmZlY3QuXHJcbiAgICAgICAgdmFyIGltcHVsc2UgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoMiwgbGVuZ3RoLCB0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTtcclxuXHJcbiAgICAgICAgLy8gIFVzZSBgZ2V0Q2hhbm5lbERhdGFgIHRvIGluaXRpYWxpemUgZW1wdHkgYXJyYXlzIHRvIHN0b3JlIHNvdW5kIGRhdGEgZm9yIHRoZSBsZWZ0IGFuZCByaWdodCBjaGFubmVscy5cclxuICAgICAgICB2YXIgbGVmdCA9IGltcHVsc2UuZ2V0Q2hhbm5lbERhdGEoMCk7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gaW1wdWxzZS5nZXRDaGFubmVsRGF0YSgxKTtcclxuXHJcbiAgICAgICAgLy8gIExvb3AgdGhyb3VnaCBlYWNoIHNhbXBsZS1mcmFtZSBhbmQgZmlsbCB0aGUgY2hhbm5lbCBkYXRhIHdpdGggcmFuZG9tIG5vaXNlLlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQXBwbHkgdGhlIHJldmVyc2UgZWZmZWN0LCBpZiBgcmV2ZXJzZWAgaXMgYHRydWVgLlxyXG4gICAgICAgICAgICB2YXIgbiA9IChyZXZlcnNlKSA/IGxlbmd0aCAtIGkgOiBpO1xyXG5cclxuICAgICAgICAgICAgLy8gIEZpbGwgdGhlIGxlZnQgYW5kIHJpZ2h0IGNoYW5uZWxzIHdpdGggcmFuZG9tIHdoaXRlIG5vaXNlIHdoaWNoIGRlY2F5cyBleHBvbmVudGlhbGx5LlxyXG4gICAgICAgICAgICBsZWZ0W2ldID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBNYXRoLnBvdygxIC0gbiAvIGxlbmd0aCwgZGVjYXkpO1xyXG4gICAgICAgICAgICByaWdodFtpXSA9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogTWF0aC5wb3coMSAtIG4gLyBsZW5ndGgsIGRlY2F5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBSZXR1cm4gdGhlIGBpbXB1bHNlYC5cclxuICAgICAgICByZXR1cm4gaW1wdWxzZTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGWDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VuZC9keW5hbWljL0ZYLmpzXG4vLyBtb2R1bGUgaWQgPSA5Njhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5Tb3VuZC5EeW5hbWljXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBGWDogcmVxdWlyZSgnLi9GWCcpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdW5kL2R5bmFtaWMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDk2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCcuLi91dGlscy9hcnJheS9RdWlja1NlbGVjdCcpO1xyXG5cclxuLy8gIFBoYXNlci5TdHJ1Y3RzLlJUcmVlXHJcblxyXG4vKipcclxuICogUkJ1c2ggaXMgYSBoaWdoLXBlcmZvcm1hbmNlIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgMkQgc3BhdGlhbCBpbmRleGluZyBvZiBwb2ludHMgYW5kIHJlY3RhbmdsZXMuXHJcbiAqIEl0J3MgYmFzZWQgb24gYW4gb3B0aW1pemVkIFItdHJlZSBkYXRhIHN0cnVjdHVyZSB3aXRoIGJ1bGsgaW5zZXJ0aW9uIHN1cHBvcnQuXHJcbiAqXHJcbiAqIFNwYXRpYWwgaW5kZXggaXMgYSBzcGVjaWFsIGRhdGEgc3RydWN0dXJlIGZvciBwb2ludHMgYW5kIHJlY3RhbmdsZXMgdGhhdCBhbGxvd3MgeW91IHRvIHBlcmZvcm0gcXVlcmllcyBsaWtlXHJcbiAqIFwiYWxsIGl0ZW1zIHdpdGhpbiB0aGlzIGJvdW5kaW5nIGJveFwiIHZlcnkgZWZmaWNpZW50bHkgKGUuZy4gaHVuZHJlZHMgb2YgdGltZXMgZmFzdGVyIHRoYW4gbG9vcGluZyBvdmVyIGFsbCBpdGVtcykuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcmJ1c2ggKG1heEVudHJpZXMsIGZvcm1hdClcclxue1xyXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHJidXNoKSkgcmV0dXJuIG5ldyByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpO1xyXG5cclxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXHJcbiAgICB0aGlzLl9tYXhFbnRyaWVzID0gTWF0aC5tYXgoNCwgbWF4RW50cmllcyB8fCA5KTtcclxuICAgIHRoaXMuX21pbkVudHJpZXMgPSBNYXRoLm1heCgyLCBNYXRoLmNlaWwodGhpcy5fbWF4RW50cmllcyAqIDAuNCkpO1xyXG5cclxuICAgIGlmIChmb3JtYXQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5faW5pdEZvcm1hdChmb3JtYXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2xlYXIoKTtcclxufVxyXG5cclxucmJ1c2gucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxyXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcclxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XHJcblxyXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcclxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xyXG5cclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgdGhpcy5fYWxsKGNoaWxkLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbGxpZGVzOiBmdW5jdGlvbiAoYmJveClcclxuICAgIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcclxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XHJcblxyXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxyXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XHJcblxyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgbG9hZDogZnVuY3Rpb24gKGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLl9taW5FbnRyaWVzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSB0cmVlIHdpdGggdGhlIGdpdmVuIGRhdGEgZnJvbSBzY3JhdGNoIHVzaW5nIE9NVCBhbGdvcml0aG1cclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcclxuICAgICAgICAgICAgdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSwgbm9kZSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGVpZ2h0IDwgbm9kZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxyXG4gICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXHJcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlLCB0aGlzLmRhdGEuaGVpZ2h0IC0gbm9kZS5oZWlnaHQgLSAxLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIChpdGVtKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRm4pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXHJcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcclxuICAgICAgICAgICAgcGF0aCA9IFtdLFxyXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXHJcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XHJcblxyXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxyXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gZmluZEl0ZW0oaXRlbSwgbm9kZS5jaGlsZHJlbiwgZXF1YWxzRm4pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIGZvdW5kLCByZW1vdmUgdGhlIGl0ZW0gYW5kIGNvbmRlbnNlIHRyZWUgdXB3YXJkc1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uZGVuc2UocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cclxuICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHsgLy8gZ28gcmlnaHRcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxyXG5cclxuICAgIGNvbXBhcmVNaW5YOiBjb21wYXJlTm9kZU1pblgsXHJcbiAgICBjb21wYXJlTWluWTogY29tcGFyZU5vZGVNaW5ZLFxyXG5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRhOyB9LFxyXG5cclxuICAgIGZyb21KU09OOiBmdW5jdGlvbiAoZGF0YSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBfYWxsOiBmdW5jdGlvbiAobm9kZSwgcmVzdWx0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBub2RlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2guYXBwbHkobm9kZXNUb1NlYXJjaCwgbm9kZS5jaGlsZHJlbik7XHJcblxyXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIE4gPSByaWdodCAtIGxlZnQgKyAxLFxyXG4gICAgICAgICAgICBNID0gdGhpcy5fbWF4RW50cmllcyxcclxuICAgICAgICAgICAgbm9kZTtcclxuXHJcbiAgICAgICAgaWYgKE4gPD0gTSkge1xyXG4gICAgICAgICAgICAvLyByZWFjaGVkIGxlYWYgbGV2ZWw7IHJldHVybiBsZWFmXHJcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xyXG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcclxuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxyXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XHJcblxyXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXHJcbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKFtdKTtcclxuICAgICAgICBub2RlLmxlYWYgPSBmYWxzZTtcclxuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gc3BsaXQgdGhlIGl0ZW1zIGludG8gTSBtb3N0bHkgc3F1YXJlIHRpbGVzXHJcblxyXG4gICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXHJcbiAgICAgICAgICAgIE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKSxcclxuICAgICAgICAgICAgaSwgaiwgcmlnaHQyLCByaWdodDM7XHJcblxyXG4gICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBsZWZ0LCByaWdodCwgTjEsIHRoaXMuY29tcGFyZU1pblgpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XHJcblxyXG4gICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XHJcblxyXG4gICAgICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xyXG5cclxuICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XHJcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XHJcblxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpLCBsZW4sIGNoaWxkLCB0YXJnZXROb2RlLCBhcmVhLCBlbmxhcmdlbWVudCwgbWluQXJlYSwgbWluRW5sYXJnZW1lbnQ7XHJcblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBlbmxhcmdlbWVudCA9IGVubGFyZ2VkQXJlYShiYm94LCBjaGlsZCkgLSBhcmVhO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5sYXJnZW1lbnQgPCBtaW5FbmxhcmdlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBvbmUgd2l0aCB0aGUgc21hbGxlc3QgYXJlYVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfSxcclxuXHJcbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSwgbGV2ZWwsIGlzTm9kZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXHJcbiAgICAgICAgICAgIGJib3ggPSBpc05vZGUgPyBpdGVtIDogdG9CQm94KGl0ZW0pLFxyXG4gICAgICAgICAgICBpbnNlcnRQYXRoID0gW107XHJcblxyXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3Qgbm9kZSBmb3IgYWNjb21tb2RhdGluZyB0aGUgaXRlbSwgc2F2aW5nIGFsbCBub2RlcyBhbG9uZyB0aGUgcGF0aCB0b29cclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2Nob29zZVN1YnRyZWUoYmJveCwgdGhpcy5kYXRhLCBsZXZlbCwgaW5zZXJ0UGF0aCk7XHJcblxyXG4gICAgICAgIC8vIHB1dCB0aGUgaXRlbSBpbnRvIHRoZSBub2RlXHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcclxuXHJcbiAgICAgICAgLy8gc3BsaXQgb24gbm9kZSBvdmVyZmxvdzsgcHJvcGFnYXRlIHVwd2FyZHMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcclxuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwbGl0KGluc2VydFBhdGgsIGxldmVsKTtcclxuICAgICAgICAgICAgICAgIGxldmVsLS07XHJcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXHJcbiAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIGluc2VydFBhdGgsIGxldmVsKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gc3BsaXQgb3ZlcmZsb3dlZCBub2RlIGludG8gdHdvXHJcbiAgICBfc3BsaXQ6IGZ1bmN0aW9uIChpbnNlcnRQYXRoLCBsZXZlbClcclxuICAgIHtcclxuICAgICAgICB2YXIgbm9kZSA9IGluc2VydFBhdGhbbGV2ZWxdLFxyXG4gICAgICAgICAgICBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGgsXHJcbiAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xyXG5cclxuICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XHJcblxyXG4gICAgICAgIHZhciBzcGxpdEluZGV4ID0gdGhpcy5fY2hvb3NlU3BsaXRJbmRleChub2RlLCBtLCBNKTtcclxuXHJcbiAgICAgICAgdmFyIG5ld05vZGUgPSBjcmVhdGVOb2RlKG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCkpO1xyXG4gICAgICAgIG5ld05vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQ7XHJcbiAgICAgICAgbmV3Tm9kZS5sZWFmID0gbm9kZS5sZWFmO1xyXG5cclxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XHJcbiAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xyXG5cclxuICAgICAgICBpZiAobGV2ZWwpIGluc2VydFBhdGhbbGV2ZWwgLSAxXS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xyXG4gICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSlcclxuICAgIHtcclxuICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcclxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XHJcbiAgICAgICAgdGhpcy5kYXRhLmhlaWdodCA9IG5vZGUuaGVpZ2h0ICsgMTtcclxuICAgICAgICB0aGlzLmRhdGEubGVhZiA9IGZhbHNlO1xyXG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGksIGJib3gxLCBiYm94Miwgb3ZlcmxhcCwgYXJlYSwgbWluT3ZlcmxhcCwgbWluQXJlYSwgaW5kZXg7XHJcblxyXG4gICAgICAgIG1pbk92ZXJsYXAgPSBtaW5BcmVhID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xyXG4gICAgICAgICAgICBiYm94MSA9IGRpc3RCQm94KG5vZGUsIDAsIGksIHRoaXMudG9CQm94KTtcclxuICAgICAgICAgICAgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XHJcblxyXG4gICAgICAgICAgICBvdmVybGFwID0gaW50ZXJzZWN0aW9uQXJlYShiYm94MSwgYmJveDIpO1xyXG4gICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xyXG5cclxuICAgICAgICAgICAgLy8gY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gb3ZlcmxhcFxyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcclxuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG5cclxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcclxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblgsXHJcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcclxuICAgICAgICAgICAgeE1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblgpLFxyXG4gICAgICAgICAgICB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XHJcblxyXG4gICAgICAgIC8vIGlmIHRvdGFsIGRpc3RyaWJ1dGlvbnMgbWFyZ2luIHZhbHVlIGlzIG1pbmltYWwgZm9yIHgsIHNvcnQgYnkgbWluWCxcclxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXHJcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxyXG4gICAgX2FsbERpc3RNYXJnaW46IGZ1bmN0aW9uIChub2RlLCBtLCBNLCBjb21wYXJlKVxyXG4gICAge1xyXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcclxuXHJcbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxyXG4gICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXHJcbiAgICAgICAgICAgIHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpLFxyXG4gICAgICAgICAgICBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KSxcclxuICAgICAgICAgICAgaSwgY2hpbGQ7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xyXG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSBNIC0gbSAtIDE7IGkgPj0gbTsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgZXh0ZW5kKHJpZ2h0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcclxuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4ocmlnaHRCQm94KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtYXJnaW47XHJcbiAgICB9LFxyXG5cclxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXM6IGZ1bmN0aW9uIChiYm94LCBwYXRoLCBsZXZlbClcclxuICAgIHtcclxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcclxuICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLCBiYm94KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9jb25kZW5zZTogZnVuY3Rpb24gKHBhdGgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcGF0aCwgcmVtb3ZpbmcgZW1wdHkgbm9kZXMgYW5kIHVwZGF0aW5nIGJib3hlc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxyXG5cclxuICAgICAgICAvLyB1c2VzIGV2YWwtdHlwZSBmdW5jdGlvbiBjb21waWxhdGlvbiBpbnN0ZWFkIG9mIGp1c3QgYWNjZXB0aW5nIGEgdG9CQm94IGZ1bmN0aW9uXHJcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXHJcbiAgICAgICAgLy8gc28gdGhleSBzaG91bGQgYmUgZGVhZCBzaW1wbGUgYW5kIHdpdGhvdXQgaW5uZXIgY2FsbHNcclxuXHJcbiAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xyXG5cclxuICAgICAgICB0aGlzLmNvbXBhcmVNaW5YID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzBdKSk7XHJcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xyXG5cclxuICAgICAgICB0aGlzLnRvQkJveCA9IG5ldyBGdW5jdGlvbignYScsXHJcbiAgICAgICAgICAgICdyZXR1cm4ge21pblg6IGEnICsgZm9ybWF0WzBdICtcclxuICAgICAgICAgICAgJywgbWluWTogYScgKyBmb3JtYXRbMV0gK1xyXG4gICAgICAgICAgICAnLCBtYXhYOiBhJyArIGZvcm1hdFsyXSArXHJcbiAgICAgICAgICAgICcsIG1heFk6IGEnICsgZm9ybWF0WzNdICsgJ307Jyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmaW5kSXRlbSAoaXRlbSwgaXRlbXMsIGVxdWFsc0ZuKVxyXG57XHJcbiAgICBpZiAoIWVxdWFsc0ZuKSByZXR1cm4gaXRlbXMuaW5kZXhPZihpdGVtKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGVxdWFsc0ZuKGl0ZW0sIGl0ZW1zW2ldKSkgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cclxuZnVuY3Rpb24gY2FsY0JCb3ggKG5vZGUsIHRvQkJveClcclxue1xyXG4gICAgZGlzdEJCb3gobm9kZSwgMCwgbm9kZS5jaGlsZHJlbi5sZW5ndGgsIHRvQkJveCwgbm9kZSk7XHJcbn1cclxuXHJcbi8vIG1pbiBib3VuZGluZyByZWN0YW5nbGUgb2Ygbm9kZSBjaGlsZHJlbiBmcm9tIGsgdG8gcC0xXHJcbmZ1bmN0aW9uIGRpc3RCQm94IChub2RlLCBrLCBwLCB0b0JCb3gsIGRlc3ROb2RlKVxyXG57XHJcbiAgICBpZiAoIWRlc3ROb2RlKSBkZXN0Tm9kZSA9IGNyZWF0ZU5vZGUobnVsbCk7XHJcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XHJcbiAgICBkZXN0Tm9kZS5taW5ZID0gSW5maW5pdHk7XHJcbiAgICBkZXN0Tm9kZS5tYXhYID0gLUluZmluaXR5O1xyXG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcclxuICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgZXh0ZW5kKGRlc3ROb2RlLCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkZXN0Tm9kZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0ZW5kIChhLCBiKVxyXG57XHJcbiAgICBhLm1pblggPSBNYXRoLm1pbihhLm1pblgsIGIubWluWCk7XHJcbiAgICBhLm1pblkgPSBNYXRoLm1pbihhLm1pblksIGIubWluWSk7XHJcbiAgICBhLm1heFggPSBNYXRoLm1heChhLm1heFgsIGIubWF4WCk7XHJcbiAgICBhLm1heFkgPSBNYXRoLm1heChhLm1heFksIGIubWF4WSk7XHJcbiAgICByZXR1cm4gYTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5YIChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cclxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5ZIChhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cclxuXHJcbmZ1bmN0aW9uIGJib3hBcmVhIChhKSB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSAqIChhLm1heFkgLSBhLm1pblkpOyB9XHJcbmZ1bmN0aW9uIGJib3hNYXJnaW4gKGEpIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICsgKGEubWF4WSAtIGEubWluWSk7IH1cclxuXHJcbmZ1bmN0aW9uIGVubGFyZ2VkQXJlYSAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChNYXRoLm1heChiLm1heFgsIGEubWF4WCkgLSBNYXRoLm1pbihiLm1pblgsIGEubWluWCkpICpcclxuICAgICAgICAgICAoTWF0aC5tYXgoYi5tYXhZLCBhLm1heFkpIC0gTWF0aC5taW4oYi5taW5ZLCBhLm1pblkpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYSAoYSwgYilcclxue1xyXG4gICAgdmFyIG1pblggPSBNYXRoLm1heChhLm1pblgsIGIubWluWCksXHJcbiAgICAgICAgbWluWSA9IE1hdGgubWF4KGEubWluWSwgYi5taW5ZKSxcclxuICAgICAgICBtYXhYID0gTWF0aC5taW4oYS5tYXhYLCBiLm1heFgpLFxyXG4gICAgICAgIG1heFkgPSBNYXRoLm1pbihhLm1heFksIGIubWF4WSk7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXHJcbiAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF4WSAtIG1pblkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb250YWlucyAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIGEubWluWCA8PSBiLm1pblggJiZcclxuICAgICAgICAgICBhLm1pblkgPD0gYi5taW5ZICYmXHJcbiAgICAgICAgICAgYi5tYXhYIDw9IGEubWF4WCAmJlxyXG4gICAgICAgICAgIGIubWF4WSA8PSBhLm1heFk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVyc2VjdHMgKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBiLm1pblggPD0gYS5tYXhYICYmXHJcbiAgICAgICAgICAgYi5taW5ZIDw9IGEubWF4WSAmJlxyXG4gICAgICAgICAgIGIubWF4WCA+PSBhLm1pblggJiZcclxuICAgICAgICAgICBiLm1heFkgPj0gYS5taW5ZO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVOb2RlIChjaGlsZHJlbilcclxue1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXHJcbiAgICAgICAgaGVpZ2h0OiAxLFxyXG4gICAgICAgIGxlYWY6IHRydWUsXHJcbiAgICAgICAgbWluWDogSW5maW5pdHksXHJcbiAgICAgICAgbWluWTogSW5maW5pdHksXHJcbiAgICAgICAgbWF4WDogLUluZmluaXR5LFxyXG4gICAgICAgIG1heFk6IC1JbmZpbml0eVxyXG4gICAgfTtcclxufVxyXG5cclxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XHJcbi8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxyXG5cclxuZnVuY3Rpb24gbXVsdGlTZWxlY3QgKGFyciwgbGVmdCwgcmlnaHQsIG4sIGNvbXBhcmUpXHJcbntcclxuICAgIHZhciBzdGFjayA9IFtsZWZ0LCByaWdodF0sXHJcbiAgICAgICAgbWlkO1xyXG5cclxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XHJcblxyXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XHJcblxyXG4gICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmNlaWwoKHJpZ2h0IC0gbGVmdCkgLyBuIC8gMikgKiBuO1xyXG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XHJcblxyXG4gICAgICAgIHN0YWNrLnB1c2gobGVmdCwgbWlkLCBtaWQsIHJpZ2h0KTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByYnVzaDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdHJ1Y3RzL1JUcmVlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBFeHRlbmQgPSByZXF1aXJlKCcuLi91dGlscy9vYmplY3QvRXh0ZW5kJyk7XHJcblxyXG4vKipcclxuKiBBIEZyYW1lIGlzIGEgc2VjdGlvbiBvZiBhIFRleHR1cmUuXHJcbiovXHJcbnZhciBGcmFtZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBGcmFtZSAodGV4dHVyZSwgbmFtZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJvcGVydHkge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIFRleHR1cmUgdGhpcyBmcmFtZSBiZWxvbmdzIHRvLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoaXMgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XHJcblxyXG4gICAgICAgIHRoaXMuc291cmNlSW5kZXggPSBzb3VyY2VJbmRleDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY3V0WCAtIFggcG9zaXRpb24gd2l0aGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0IGZyb20uXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN1dFggPSB4O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRZIC0gWSBwb3NpdGlvbiB3aXRoaW4gdGhlIHNvdXJjZSBpbWFnZSB0byBjdXQgZnJvbS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3V0WSA9IHk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGN1dFdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBhcmVhIGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0LlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXRXaWR0aCA9IHdpZHRoO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBhcmVhIGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0LlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXRIZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBUaGUgWCByZW5kZXJpbmcgb2Zmc2V0IG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMueCA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSBUaGUgWSByZW5kZXJpbmcgb2Zmc2V0IG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMueSA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gVGhlIHJlbmRlcmluZyB3aWR0aCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIFRoZSByZW5kZXJpbmcgaGVpZ2h0IG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFRoZSByZW5kZXJpbmcgd2lkdGggb2YgdGhpcyBGcmFtZSwgdGFraW5nIHRyaW0gaW50byBhY2NvdW50LlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jZW50ZXJYID0gTWF0aC5mbG9vcih3aWR0aCAvIDIpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVuZGVyaW5nIGhlaWdodCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNlbnRlclkgPSBNYXRoLmZsb29yKGhlaWdodCAvIDIpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIElzIHRoaXMgZnJhbWUgaXMgcm90YXRlZCBvciBub3QgaW4gdGhlIFRleHR1cmU/XHJcbiAgICAgICAgKiBSb3RhdGlvbiBhbGxvd3MgeW91IHRvIHVzZSByb3RhdGVkIGZyYW1lcyBpbiB0ZXh0dXJlIGF0bGFzIHBhY2tpbmcuXHJcbiAgICAgICAgKiBJdCBoYXMgbm90aGluZyB0byBkbyB3aXRoIFNwcml0ZSByb3RhdGlvbi5cclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHJvdGF0ZWRcclxuICAgICAgICAqIEBkZWZhdWx0XHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJvdGF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gIE92ZXItcmlkZXMgdGhlIFJlbmRlcmVyIHNldHRpbmc/IC0xID0gdXNlIFJlbmRlcmVyIFNldHRpbmcsIDAgPSBObyByb3VuZGluZywgMSA9IFJvdW5kXHJcbiAgICAgICAgdGhpcy5hdXRvUm91bmQgPSAtMTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGUgdW4tbW9kaWZpZWQgc291cmNlIGZyYW1lLCB0cmltIGFuZCBVViBkYXRhLlxyXG4gICAgICAgICpcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKiBAcHJvcGVydHkge29iamVjdH0gZGF0YVxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0ge1xyXG4gICAgICAgICAgICBjdXQ6IHtcclxuICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgICAgICAgdzogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoOiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICByOiB4ICsgd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBiOiB5ICsgaGVpZ2h0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRyaW06IGZhbHNlLFxyXG4gICAgICAgICAgICBzb3VyY2VTaXplOiB7XHJcbiAgICAgICAgICAgICAgICB3OiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGg6IGhlaWdodFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzcHJpdGVTb3VyY2VTaXplOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgIHc6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaDogaGVpZ2h0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHV2czoge1xyXG4gICAgICAgICAgICAgICAgeDA6IDAsXHJcbiAgICAgICAgICAgICAgICB5MDogMCxcclxuICAgICAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICAgICAgeTE6IDAsXHJcbiAgICAgICAgICAgICAgICB4MjogMCxcclxuICAgICAgICAgICAgICAgIHkyOiAwLFxyXG4gICAgICAgICAgICAgICAgeDM6IDAsXHJcbiAgICAgICAgICAgICAgICB5MzogMFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByYWRpdXM6IDAuNSAqIE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSxcclxuICAgICAgICAgICAgZHJhd0ltYWdlOiB7XHJcbiAgICAgICAgICAgICAgICBzeDogeCxcclxuICAgICAgICAgICAgICAgIHN5OiB5LFxyXG4gICAgICAgICAgICAgICAgc1dpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIHNIZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgICAgIGRXaWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBkSGVpZ2h0OiBoZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlVVZzKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBJZiB0aGUgZnJhbWUgd2FzIHRyaW1tZWQgd2hlbiBhZGRlZCB0byB0aGUgVGV4dHVyZSBBdGxhcywgdGhpcyByZWNvcmRzIHRoZSB0cmltIGFuZCBzb3VyY2UgZGF0YS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuVGV4dHVyZUZyYW1lI3NldFRyaW1cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGFjdHVhbFdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBmcmFtZSBiZWZvcmUgYmVpbmcgdHJpbW1lZC5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGFjdHVhbEhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGZyYW1lIGJlZm9yZSBiZWluZyB0cmltbWVkLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdFggLSBUaGUgZGVzdGluYXRpb24gWCBwb3NpdGlvbiBvZiB0aGUgdHJpbW1lZCBmcmFtZSBmb3IgZGlzcGxheS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc3RZIC0gVGhlIGRlc3RpbmF0aW9uIFkgcG9zaXRpb24gb2YgdGhlIHRyaW1tZWQgZnJhbWUgZm9yIGRpc3BsYXkuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0V2lkdGggLSBUaGUgZGVzdGluYXRpb24gd2lkdGggb2YgdGhlIHRyaW1tZWQgZnJhbWUgZm9yIGRpc3BsYXkuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0SGVpZ2h0IC0gVGhlIGRlc3RpbmF0aW9uIGhlaWdodCBvZiB0aGUgdHJpbW1lZCBmcmFtZSBmb3IgZGlzcGxheS5cclxuICAgICovXHJcbiAgICBzZXRUcmltOiBmdW5jdGlvbiAoYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCwgZGVzdFgsIGRlc3RZLCBkZXN0V2lkdGgsIGRlc3RIZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgdmFyIHNzID0gZGF0YS5zcHJpdGVTb3VyY2VTaXplO1xyXG5cclxuICAgICAgICAvLyAgU3RvcmUgYWN0dWFsIHZhbHVlc1xyXG5cclxuICAgICAgICBkYXRhLnRyaW0gPSB0cnVlO1xyXG5cclxuICAgICAgICBkYXRhLnNvdXJjZVNpemUudyA9IGFjdHVhbFdpZHRoO1xyXG4gICAgICAgIGRhdGEuc291cmNlU2l6ZS5oID0gYWN0dWFsSGVpZ2h0O1xyXG5cclxuICAgICAgICBzcy54ID0gZGVzdFg7XHJcbiAgICAgICAgc3MueSA9IGRlc3RZO1xyXG4gICAgICAgIHNzLncgPSBkZXN0V2lkdGg7XHJcbiAgICAgICAgc3MuaCA9IGRlc3RIZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vICBBZGp1c3QgcHJvcGVydGllc1xyXG4gICAgICAgIHRoaXMueCA9IGRlc3RYO1xyXG4gICAgICAgIHRoaXMueSA9IGRlc3RZO1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gZGVzdFdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGVzdEhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy5jZW50ZXJYID0gTWF0aC5mbG9vcihkZXN0V2lkdGggLyAyKTtcclxuICAgICAgICB0aGlzLmNlbnRlclkgPSBNYXRoLmZsb29yKGRlc3RIZWlnaHQgLyAyKTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVVVnMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCB1cGRhdGVVVnNcclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB1cGRhdGVVVnM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHR3ID0gdGhpcy5zb3VyY2Uud2lkdGg7XHJcbiAgICAgICAgdmFyIHRoID0gdGhpcy5zb3VyY2UuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB1dnMgPSB0aGlzLmRhdGEudXZzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHV2cy54MCA9IHRoaXMuY3V0WCAvIHR3O1xyXG4gICAgICAgIHV2cy55MCA9IHRoaXMuY3V0WSAvIHRoO1xyXG5cclxuICAgICAgICB1dnMueDEgPSB0aGlzLmN1dFggLyB0dztcclxuICAgICAgICB1dnMueTEgPSAodGhpcy5jdXRZICsgdGhpcy5jdXRIZWlnaHQpIC8gdGg7XHJcblxyXG4gICAgICAgIHV2cy54MiA9ICh0aGlzLmN1dFggKyB0aGlzLmN1dFdpZHRoKSAvIHR3O1xyXG4gICAgICAgIHV2cy55MiA9ICh0aGlzLmN1dFkgKyB0aGlzLmN1dEhlaWdodCkgLyB0aDtcclxuXHJcbiAgICAgICAgdXZzLngzID0gKHRoaXMuY3V0WCArIHRoaXMuY3V0V2lkdGgpIC8gdHc7XHJcbiAgICAgICAgdXZzLnkzID0gdGhpcy5jdXRZIC8gdGg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgV2ViR0wgVVYgY2FjaGUuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgdXBkYXRlVVZzSW52ZXJ0ZWRcclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB1cGRhdGVVVnNJbnZlcnRlZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgdHcgPSB0aGlzLnNvdXJjZS53aWR0aDtcclxuICAgICAgICB2YXIgdGggPSB0aGlzLnNvdXJjZS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHV2cyA9IHRoaXMuZGF0YS51dnM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdXZzLngzID0gKHRoaXMuY3V0WCArIHRoaXMuY3V0SGVpZ2h0KSAvIHR3O1xyXG4gICAgICAgIHV2cy55MyA9ICh0aGlzLmN1dFkgKyB0aGlzLmN1dFdpZHRoKSAvIHRoO1xyXG5cclxuICAgICAgICB1dnMueDIgPSB0aGlzLmN1dFggLyB0dztcclxuICAgICAgICB1dnMueTIgPSAodGhpcy5jdXRZICsgdGhpcy5jdXRXaWR0aCkgLyB0aDtcclxuICAgICAgICBcclxuICAgICAgICB1dnMueDEgPSB0aGlzLmN1dFggLyB0dztcclxuICAgICAgICB1dnMueTEgPSB0aGlzLmN1dFkgLyB0aDtcclxuICAgICAgICBcclxuICAgICAgICB1dnMueDAgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRIZWlnaHQpIC8gdHc7XHJcbiAgICAgICAgdXZzLnkwID0gdGhpcy5jdXRZIC8gdGg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgY2xvbmUgPSBuZXcgRnJhbWUodGhpcy50ZXh0dXJlLCB0aGlzLm5hbWUsIHRoaXMuc291cmNlSW5kZXgpO1xyXG5cclxuICAgICAgICBjbG9uZS5jdXRYID0gdGhpcy5jdXRYO1xyXG4gICAgICAgIGNsb25lLmN1dFkgPSB0aGlzLmN1dFk7XHJcbiAgICAgICAgY2xvbmUuY3V0V2lkdGggPSB0aGlzLmN1dFdpZHRoO1xyXG4gICAgICAgIGNsb25lLmN1dEhlaWdodCA9IHRoaXMuY3V0SGVpZ2h0O1xyXG5cclxuICAgICAgICBjbG9uZS54ID0gdGhpcy54O1xyXG4gICAgICAgIGNsb25lLnkgPSB0aGlzLnk7XHJcblxyXG4gICAgICAgIGNsb25lLndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICBjbG9uZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICAgICAgY2xvbmUuY2VudGVyWCA9IHRoaXMuY2VudGVyWDtcclxuICAgICAgICBjbG9uZS5jZW50ZXJZID0gdGhpcy5jZW50ZXJZO1xyXG5cclxuICAgICAgICBjbG9uZS5yb3RhdGVkID0gdGhpcy5yb3RhdGVkO1xyXG5cclxuICAgICAgICBjbG9uZS5kYXRhID0gRXh0ZW5kKHRydWUsIGNsb25lLmRhdGEsIHRoaXMuZGF0YSk7XHJcblxyXG4gICAgICAgIGNsb25lLnVwZGF0ZVVWcygpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgd2lkdGggb2YgdGhlIEZyYW1lIGluIGl0cyB1bi10cmltbWVkLCB1bi1wYWRkZWQgc3RhdGUsIGFzIHByZXBhcmVkIGluIHRoZSBhcnQgcGFja2FnZSxcclxuICAgICogYmVmb3JlIGJlaW5nIHBhY2tlZC5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSNyZWFsV2lkdGhcclxuICAgICogQHByb3BlcnR5IHthbnl9IHJlYWxXaWR0aFxyXG4gICAgKi9cclxuICAgIHJlYWxXaWR0aDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZVNpemUudztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGhlaWdodCBvZiB0aGUgRnJhbWUgaW4gaXRzIHVuLXRyaW1tZWQsIHVuLXBhZGRlZCBzdGF0ZSwgYXMgcHJlcGFyZWQgaW4gdGhlIGFydCBwYWNrYWdlLFxyXG4gICAgKiBiZWZvcmUgYmVpbmcgcGFja2VkLlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI3JlYWxIZWlnaHRcclxuICAgICogQHByb3BlcnR5IHthbnl9IHJlYWxIZWlnaHRcclxuICAgICovXHJcbiAgICByZWFsSGVpZ2h0OiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlU2l6ZS5oO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBVVnNcclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSN1dnNcclxuICAgICogQHByb3BlcnR5IHtPYmplY3R9IHV2c1xyXG4gICAgKi9cclxuICAgIHV2czoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnV2cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIHJhZGl1cyBvZiB0aGUgRnJhbWUgKGRlcml2ZWQgZnJvbSBzcXJ0KHcgKiB3ICsgaCAqIGgpIC8gMilcclxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSNyYWRpdXNcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1c1xyXG4gICAgKi9cclxuICAgIHJhZGl1czoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnJhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogSXMgdGhlIEZyYW1lIHRyaW1tZWQ/XHJcbiAgICAqIEBuYW1lIFBoYXNlci5UZXh0dXJlRnJhbWUjdHJpbW1lZFxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHRyaW1tZWRcclxuICAgICovXHJcbiAgICB0cmltbWVkOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEudHJpbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQ2FudmFzIERyYXcgSW1hZ2UgZGF0YVxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI2NhbnZhc0RhdGFcclxuICAgICogQHByb3BlcnR5IHtPYmplY3R9IGNhbnZhc0RhdGFcclxuICAgICovXHJcbiAgICBjYW52YXNEYXRhOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuZHJhd0ltYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDk3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG52YXIgRnJhbWUgPSByZXF1aXJlKCcuL0ZyYW1lJyk7XHJcbnZhciBUZXh0dXJlU291cmNlID0gcmVxdWlyZSgnLi9UZXh0dXJlU291cmNlJyk7XHJcblxyXG4vKipcclxuKiBBIFRleHR1cmUgY29uc2lzdHMgb2YgYSBzb3VyY2UsIHVzdWFsbHkgYW4gSW1hZ2UgZnJvbSB0aGUgQ2FjaGUsIG9yIGEgQ2FudmFzLCBhbmQgYSBjb2xsZWN0aW9uXHJcbiogb2YgRnJhbWVzLiBUaGUgRnJhbWVzIHJlcHJlc2VudCB0aGUgZGlmZmVyZW50IGFyZWFzIG9mIHRoZSBUZXh0dXJlLiBGb3IgZXhhbXBsZSBhIHRleHR1cmUgYXRsYXNcclxuKiBtYXkgaGF2ZSBtYW55IEZyYW1lcywgb25lIGZvciBlYWNoIGVsZW1lbnQgd2l0aGluIHRoZSBhdGxhcy4gV2hlcmUtYXMgYSBzaW5nbGUgaW1hZ2Ugd291bGQgaGF2ZVxyXG4qIGp1c3Qgb25lIGZyYW1lLCB0aGF0IGVuY29tcGFzc2VzIHRoZSB3aG9sZSBpbWFnZS5cclxuKlxyXG4qIFRleHR1cmVzIGFyZSBtYW5hZ2VkIGJ5IHRoZSBnbG9iYWwgVGV4dHVyZU1hbmFnZXIuIFRoaXMgaXMgYSBzaW5nbGV0b24gY2xhc3MgdGhhdCBpc1xyXG4qIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgZGVsaXZlcmluZyBUZXh0dXJlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBGcmFtZXMgdG8gR2FtZSBPYmplY3RzLlxyXG4qXHJcbiogU3ByaXRlcyBhbmQgb3RoZXIgR2FtZSBPYmplY3RzIGdldCB0aGUgdGV4dHVyZSBkYXRhIHRoZXkgbmVlZCBmcm9tIHRoZSBUZXh0dXJlTWFuYWdlci5cclxuKi9cclxudmFyIFRleHR1cmUgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gVGV4dHVyZSAobWFuYWdlciwga2V5LCBzb3VyY2UsIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBbIHNvdXJjZSBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIHNvdXJjZSB0aGF0IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlLlxyXG4gICAgICAgICogVXN1YWxseSBhbiBJbWFnZSwgYnV0IGNhbiBhbHNvIGJlIGEgQ2FudmFzLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5maXJzdEZyYW1lID0gJ19fQkFTRSc7XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVUb3RhbCA9IDA7XHJcblxyXG4gICAgICAgIC8vICBMb2FkIHRoZSBTb3VyY2VzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5wdXNoKG5ldyBUZXh0dXJlU291cmNlKHRoaXMsIHNvdXJjZVtpXSwgd2lkdGgsIGhlaWdodCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAobmFtZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gbmV3IEZyYW1lKHRoaXMsIG5hbWUsIHNvdXJjZUluZGV4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5mcmFtZXNbbmFtZV0gPSBmcmFtZTtcclxuXHJcbiAgICAgICAgLy8gIFNldCB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIFRleHR1cmUgKG90aGVyIHRoYW4gX19CQVNFKVxyXG4gICAgICAgIC8vICBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHdlIGRvbid0IHNwYW0gdGhlIGRpc3BsYXkgd2l0aCBlbnRpcmVcclxuICAgICAgICAvLyAgYXRsYXNlcyBvZiBzcHJpdGUgc2hlZXRzLCBidXQgaW5zdGVhZCBqdXN0IHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVtXHJcbiAgICAgICAgLy8gIHNob3VsZCB0aGUgZGV2IGluY29ycmVjdGx5IHNwZWNpZnkgdGhlIGZyYW1lIGluZGV4XHJcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVUb3RhbCA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZyYW1lVG90YWwrKztcclxuXHJcbiAgICAgICAgcmV0dXJuIGZyYW1lO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXM6IGZ1bmN0aW9uIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mcmFtZXNbbmFtZV0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQgfHwgbmFtZSA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWUgPSAodGhpcy5mcmFtZVRvdGFsID09PSAxKSA/ICdfX0JBU0UnIDogdGhpcy5maXJzdEZyYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZXNbbmFtZV07XHJcblxyXG4gICAgICAgIGlmICghZnJhbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIFRleHR1cmUuZnJhbWUgZm91bmQgd2l0aCBuYW1lICcgKyBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lc1snX19CQVNFJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZyYW1lTmFtZXM6IGZ1bmN0aW9uIChpbmNsdWRlQmFzZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoaW5jbHVkZUJhc2UgPT09IHVuZGVmaW5lZCkgeyBpbmNsdWRlQmFzZSA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIHZhciBvdXQgPSBPYmplY3Qua2V5cyh0aGlzLmZyYW1lcyk7XHJcblxyXG4gICAgICAgIGlmICghaW5jbHVkZUJhc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ19fQkFTRScpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG91dC5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U291cmNlSW1hZ2U6IGZ1bmN0aW9uIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQgfHwgbmFtZSA9PT0gbnVsbCB8fCB0aGlzLmZyYW1lVG90YWwgPT09IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lID0gJ19fQkFTRSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lc1tuYW1lXTtcclxuXHJcbiAgICAgICAgaWYgKCFmcmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gVGV4dHVyZS5mcmFtZSBmb3VuZCB3aXRoIG5hbWUgJyArIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzWydfX0JBU0UnXS5zb3VyY2UuaW1hZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcmFtZS5zb3VyY2UuaW1hZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uIChmaWx0ZXJNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zb3VyY2UubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZVtpXS5zZXRGaWx0ZXIoZmlsdGVyTW9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvVGV4dHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gOTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDb2xvciA9IHJlcXVpcmUoJy4uL2dyYXBoaWNzL2NvbG9yL0NvbG9yJyk7XHJcbnZhciBHZW5lcmF0ZVRleHR1cmUgPSByZXF1aXJlKCcuLi9jcmVhdGUvR2VuZXJhdGVUZXh0dXJlJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXJzJyk7XHJcbnZhciBUZXh0dXJlID0gcmVxdWlyZSgnLi9UZXh0dXJlJyk7XHJcblxyXG4vKipcclxuKiBUZXh0dXJlcyBhcmUgbWFuYWdlZCBieSB0aGUgZ2xvYmFsIFRleHR1cmVNYW5hZ2VyLiBUaGlzIGlzIGEgc2luZ2xldG9uIGNsYXNzIHRoYXQgaXNcclxuKiByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIGRlbGl2ZXJpbmcgVGV4dHVyZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgRnJhbWVzIHRvIEdhbWUgT2JqZWN0cy5cclxuKlxyXG4qIFNwcml0ZXMgYW5kIG90aGVyIEdhbWUgT2JqZWN0cyBnZXQgdGhlIHRleHR1cmUgZGF0YSB0aGV5IG5lZWQgZnJvbSB0aGUgVGV4dHVyZU1hbmFnZXIuXHJcbipcclxuKiBBY2Nlc3MgaXQgdmlhIGBzY2VuZS50ZXh0dXJlc2AuXHJcbiovXHJcbnZhciBUZXh0dXJlTWFuYWdlciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBUZXh0dXJlTWFuYWdlciAoZ2FtZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3QgPSB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5fdGVtcENhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlMkQodGhpcywgMSwgMSk7XHJcbiAgICAgICAgdGhpcy5fdGVtcENvbnRleHQgPSB0aGlzLl90ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJvb3Q6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hZGRCYXNlNjQoJ19fREVGQVVMVCcsIHRoaXMuZ2FtZS5jb25maWcuZGVmYXVsdEltYWdlKTtcclxuICAgICAgICB0aGlzLmFkZEJhc2U2NCgnX19NSVNTSU5HJywgdGhpcy5nYW1lLmNvbmZpZy5taXNzaW5nSW1hZ2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRCYXNlNjQ6IGZ1bmN0aW9uIChrZXksIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gX3RoaXMuY3JlYXRlKGtleSwgaW1hZ2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBQYXJzZXIuSW1hZ2UodGV4dHVyZSwgMCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaW1hZ2Uuc3JjID0gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkSW1hZ2U6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuICAgICAgICBcclxuICAgICAgICBQYXJzZXIuSW1hZ2UodGV4dHVyZSwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24gKGtleSwgY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZSh0aGlzLCAxLCAxKTtcclxuXHJcbiAgICAgICAgY29uZmlnLmNhbnZhcyA9IGNhbnZhcztcclxuXHJcbiAgICAgICAgR2VuZXJhdGVUZXh0dXJlKGNvbmZpZyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZENhbnZhcyhrZXksIGNhbnZhcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUNhbnZhczogZnVuY3Rpb24gKGtleSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDI1NjsgfVxyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSAyNTY7IH1cclxuXHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRDYW52YXMoa2V5LCBjYW52YXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRDYW52YXM6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuICAgICAgICBcclxuICAgICAgICBQYXJzZXIuQ2FudmFzKHRleHR1cmUsIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXRsYXM6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICAvLyAgSXMgaXQgYSBIYXNoIG9yIGFuIEFycmF5P1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmZyYW1lcykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBdGxhc0pTT05BcnJheShrZXksIHNvdXJjZSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEF0bGFzSlNPTkhhc2goa2V5LCBzb3VyY2UsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXRsYXNKU09OQXJyYXk6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5KU09OQXJyYXkodGV4dHVyZSwgaSwgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUGFyc2VyLkpTT05BcnJheSh0ZXh0dXJlLCAwLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRBdGxhc0pTT05IYXNoOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQYXJzZXIuSlNPTkhhc2godGV4dHVyZSwgaSwgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUGFyc2VyLkpTT05IYXNoKHRleHR1cmUsIDAsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFVuaXR5QXRsYXM6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgUGFyc2VyLlVuaXR5WUFNTCh0ZXh0dXJlLCAwLCBkYXRhKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogW2FkZFNwcml0ZVNoZWV0IGRlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IGtleSAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0gc291cmNlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBjb25maWcgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5mcmFtZVdpZHRoIC0gVGhlIGZpeGVkIHdpZHRoIG9mIGVhY2ggZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5mcmFtZUhlaWdodF0gLSBUaGUgZml4ZWQgaGVpZ2h0IG9mIGVhY2ggZnJhbWUuIElmIG5vdCBzZXQgaXQgd2lsbCB1c2UgdGhlIGZyYW1lV2lkdGggYXMgdGhlIGhlaWdodC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLnN0YXJ0RnJhbWU9MF0gLSBTa2lwIGEgbnVtYmVyIG9mIGZyYW1lcy4gVXNlZnVsIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHNwcml0ZSBzaGVldHMgaW4gb25lIFRleHR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5lbmRGcmFtZT0tMV0gLSBUaGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyB0byBleHRyYWN0IGZyb20gdGhlIFNwcml0ZSBTaGVldC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgLTEgbWVhbnMgXCJleHRyYWN0IGFsbCBmcmFtZXNcIi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1hcmdpbj0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggYSBtYXJnaW4sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuc3BhY2luZz0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggc3BhY2luZyBiZXR3ZWVuIHRoZW0sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxyXG4gICAgICovXHJcbiAgICBhZGRTcHJpdGVTaGVldDogZnVuY3Rpb24gKGtleSwgc291cmNlLCBjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XHJcblxyXG4gICAgICAgIHZhciB3aWR0aCA9IHRleHR1cmUuc291cmNlWzBdLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0dXJlLnNvdXJjZVswXS5oZWlnaHQ7XHJcblxyXG4gICAgICAgIFBhcnNlci5TcHJpdGVTaGVldCh0ZXh0dXJlLCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCBjb25maWcpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkU3ByaXRlU2hlZXRGcm9tQXRsYXM6IGZ1bmN0aW9uIChrZXksIGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB2YXIgYXRsYXNLZXkgPSBHZXRWYWx1ZShjb25maWcsICdhdGxhcycsIG51bGwpO1xyXG4gICAgICAgIHZhciBhdGxhc0ZyYW1lID0gR2V0VmFsdWUoY29uZmlnLCAnZnJhbWUnLCBudWxsKTtcclxuXHJcbiAgICAgICAgaWYgKCFhdGxhc0tleSB8fCAhYXRsYXNGcmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhdGxhcyA9IHRoaXMuZ2V0KGF0bGFzS2V5KTtcclxuICAgICAgICB2YXIgc2hlZXQgPSBhdGxhcy5nZXQoYXRsYXNGcmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChzaGVldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzaGVldC5zb3VyY2UuaW1hZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJmaWxlbmFtZVwiOiBcImV4cGxvc2lvblwiLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJmcmFtZVwiOiB7XCJ4XCI6MixcInlcIjoyLFwid1wiOjMxOSxcImhcIjozMTJ9LCA9IGN1dFgsIFksIFcsIEhcclxuICAgICAgICAgICAgLy8gICAgIFwicm90YXRlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gICAgIFwidHJpbW1lZFwiOiB0cnVlLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJzcHJpdGVTb3VyY2VTaXplXCI6IHtcInhcIjoxLFwieVwiOjYsXCJ3XCI6MzE5LFwiaFwiOjMxMn0sXHJcbiAgICAgICAgICAgIC8vICAgICBcInNvdXJjZVNpemVcIjoge1wid1wiOjMyMCxcImhcIjozMjB9LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJwaXZvdFwiOiB7XCJ4XCI6MC41LFwieVwiOjAuNX1cclxuICAgICAgICAgICAgLy8gfSxcclxuXHJcbiAgICAgICAgICAgIC8vICBJZiB0cmltbWVkIHdlIG5lZWQgdG8gaGVscCB0aGUgcGFyc2VyIGFkanVzdFxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coc2hlZXQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNoZWV0LnRyaW1tZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5TcHJpdGVTaGVldEZyb21BdGxhcyh0ZXh0dXJlLCBzaGVldCwgY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5TcHJpdGVTaGVldCh0ZXh0dXJlLCAwLCBzaGVldC5jdXRYLCBzaGVldC5jdXRZLCBzaGVldC5jdXRXaWR0aCwgc2hlZXQuY3V0SGVpZ2h0LCBjb25maWcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEF0bGFzU3RhcmxpbmdYTUw6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5TdGFybGluZ1hNTCh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQYXJzZXIuU3RhcmxpbmdYTUwodGV4dHVyZSwgMCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXRsYXNQeXhlbDogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUGFyc2VyLlB5eGVsKHRleHR1cmUsIGksIGRhdGFbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBhcnNlci5QeXhlbCh0ZXh0dXJlLCAwLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMsIGtleSwgc291cmNlLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0W2tleV0gPSB0ZXh0dXJlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgZXhpc3RzOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5saXN0Lmhhc093blByb3BlcnR5KGtleSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7IGtleSA9ICdfX0RFRkFVTFQnOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFsnX19NSVNTSU5HJ107XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZUZyYW1lOiBmdW5jdGlvbiAoa2V5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0W2tleV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W2tleV0uZ2V0KGZyYW1lKS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RnJhbWU6IGZ1bmN0aW9uIChrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XS5nZXQoZnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UGl4ZWw6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlRnJhbWUgPSB0aGlzLmdldEZyYW1lKGtleSwgZnJhbWUpO1xyXG5cclxuICAgICAgICBpZiAodGV4dHVyZUZyYW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRleHR1cmVGcmFtZS5zb3VyY2UuaW1hZ2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoeCA+PSAwICYmIHggPD0gc291cmNlLndpZHRoICYmIHkgPj0gMCAmJiB5IDw9IHNvdXJjZS5oZWlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHggKz0gdGV4dHVyZUZyYW1lLmN1dFg7XHJcbiAgICAgICAgICAgICAgICB5ICs9IHRleHR1cmVGcmFtZS5jdXRZO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmICh0ZXh0dXJlRnJhbWUudHJpbW1lZClcclxuICAgICAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB4IC09IHRoaXMuc3ByaXRlLnRleHR1cmUudHJpbS54O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHkgLT0gdGhpcy5zcHJpdGUudGV4dHVyZS50cmltLnk7XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl90ZW1wQ29udGV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCAxLCAxKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHNvdXJjZSwgeCwgeSwgMSwgMSwgMCwgMCwgMSwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJnYiA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IocmdiLmRhdGFbMF0sIHJnYi5kYXRhWzFdLCByZ2IuZGF0YVsyXSwgcmdiLmRhdGFbM10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dHVyZTogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2FtZU9iamVjdC50ZXh0dXJlID0gdGhpcy5saXN0W2tleV07XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QuZnJhbWUgPSBnYW1lT2JqZWN0LnRleHR1cmUuZ2V0KGZyYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUGFzc2VzIGFsbCBUZXh0dXJlcyB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgZWFjaFxyXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgICogQHBhcmFtIHsuLi4qfSBbYXJndW1lbnRzXSAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBhZnRlciB0aGUgY2hpbGQuXHJcbiAgICAqL1xyXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhcmdzID0gWyBudWxsIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciB0ZXh0dXJlIGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB0aGlzLmxpc3RbdGV4dHVyZV07XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZU1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvVGV4dHVyZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDk3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgSXNTaXplUG93ZXJPZlR3byA9IHJlcXVpcmUoJy4uL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvJyk7XHJcbnZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvU2NhbGVNb2RlcycpO1xyXG5cclxudmFyIFRleHR1cmVTb3VyY2UgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gVGV4dHVyZVNvdXJjZSAodGV4dHVyZSwgc291cmNlLCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnYW1lID0gdGV4dHVyZS5tYW5hZ2VyLmdhbWU7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XHJcblxyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBzb3VyY2U7XHJcblxyXG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25BbGdvcml0aG0gPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCBzb3VyY2UubmF0dXJhbFdpZHRoIHx8IHNvdXJjZS53aWR0aCB8fCAwO1xyXG5cclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCBzb3VyY2UubmF0dXJhbEhlaWdodCB8fCBzb3VyY2UuaGVpZ2h0IHx8IDA7XHJcblxyXG4gICAgICAgIHRoaXMuc2NhbGVNb2RlID0gU2NhbGVNb2Rlcy5ERUZBVUxUO1xyXG5cclxuICAgICAgICB0aGlzLmlzQ2FudmFzID0gKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KTtcclxuXHJcbiAgICAgICAgdGhpcy5pc1Bvd2VyT2YyID0gSXNTaXplUG93ZXJPZlR3byh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdChnYW1lKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGdhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nbFRleHR1cmUgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoZ2FtZS5jb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuV0VCR0wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnYW1lLnJlbmRlcmVyLmNyZWF0ZVRleHR1cmUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGdhbWUuY29uZmlnLnBpeGVsQXJ0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRGaWx0ZXIoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uIChmaWx0ZXJNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnYW1lID0gdGhpcy50ZXh0dXJlLm1hbmFnZXIuZ2FtZTtcclxuXHJcbiAgICAgICAgaWYgKGdhbWUuY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULldFQkdMKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2FtZS5yZW5kZXJlci5zZXRUZXh0dXJlRmlsdGVyTW9kZSh0aGlzLmdsVGV4dHVyZSwgZmlsdGVyTW9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVTb3VyY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvVGV4dHVyZVNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gOTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYW52YXMgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgpXHJcbntcclxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XHJcblxyXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvcGFyc2Vycy9DYW52YXMuanNcbi8vIG1vZHVsZSBpZCA9IDk3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW1hZ2UgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgpXHJcbntcclxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XHJcblxyXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9wYXJzZXJzL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEpTT05BcnJheSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2VJbmRleCwganNvbilcclxue1xyXG4gICAgLy8gIE1hbGZvcm1lZD9cclxuICAgIGlmICghanNvblsnZnJhbWVzJ10pXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIFRleHR1cmUgQXRsYXMgSlNPTiBBcnJheSBnaXZlbiwgbWlzc2luZyBcXCdmcmFtZXNcXCcgYXJyYXknKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFkZCBpbiBhIF9fQkFTRSBlbnRyeSAoZm9yIHRoZSBlbnRpcmUgYXRsYXMpXHJcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xyXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG5cclxuICAgIC8vICBCeSB0aGlzIHN0YWdlIGZyYW1lcyBpcyBhIGZ1bGx5IHBhcnNlZCBhcnJheVxyXG4gICAgdmFyIGZyYW1lcyA9IGpzb25bJ2ZyYW1lcyddO1xyXG4gICAgdmFyIG5ld0ZyYW1lO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzcmMgPSBmcmFtZXNbaV07XHJcblxyXG4gICAgICAgIC8vICBUaGUgZnJhbWUgdmFsdWVzIGFyZSB0aGUgZXhhY3QgY29vcmRpbmF0ZXMgdG8gY3V0IHRoZSBmcmFtZSBvdXQgb2YgdGhlIGF0bGFzIGZyb21cclxuICAgICAgICBuZXdGcmFtZSA9IHRleHR1cmUuYWRkKHNyYy5maWxlbmFtZSwgc291cmNlSW5kZXgsIHNyYy5mcmFtZS54LCBzcmMuZnJhbWUueSwgc3JjLmZyYW1lLncsIHNyYy5mcmFtZS5oKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZXNlIGFyZSB0aGUgb3JpZ2luYWwgKG5vbi10cmltbWVkKSBzcHJpdGUgdmFsdWVzXHJcbiAgICAgICAgaWYgKHNyYy50cmltbWVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUuc2V0VHJpbShcclxuICAgICAgICAgICAgICAgIHNyYy5zb3VyY2VTaXplLncsXHJcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS5oLFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueCxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLnksXHJcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS53LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUuaFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNyYy5yb3RhdGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUucm90YXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnVwZGF0ZVVWc0ludmVydGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKU09OQXJyYXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvcGFyc2Vycy9KU09OQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDk3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSlNPTkhhc2ggPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIGpzb24pXHJcbntcclxuICAgIC8vICBNYWxmb3JtZWQ/XHJcbiAgICBpZiAoIWpzb25bJ2ZyYW1lcyddKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBUZXh0dXJlIEF0bGFzIEpTT04gSGFzaCBnaXZlbiwgbWlzc2luZyBcXCdmcmFtZXNcXCcgT2JqZWN0Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBZGQgaW4gYSBfX0JBU0UgZW50cnkgKGZvciB0aGUgZW50aXJlIGF0bGFzKVxyXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuXHJcbiAgICAvLyAgQnkgdGhpcyBzdGFnZSBmcmFtZXMgaXMgYSBmdWxseSBwYXJzZWQgT2JqZWN0XHJcbiAgICB2YXIgZnJhbWVzID0ganNvblsnZnJhbWVzJ107XHJcbiAgICB2YXIgbmV3RnJhbWU7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIGZyYW1lcylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3JjID0gZnJhbWVzW2tleV07XHJcblxyXG4gICAgICAgIC8vICBUaGUgZnJhbWUgdmFsdWVzIGFyZSB0aGUgZXhhY3QgY29vcmRpbmF0ZXMgdG8gY3V0IHRoZSBmcmFtZSBvdXQgb2YgdGhlIGF0bGFzIGZyb21cclxuICAgICAgICBuZXdGcmFtZSA9IHRleHR1cmUuYWRkKGtleSwgc291cmNlSW5kZXgsIHNyYy5mcmFtZS54LCBzcmMuZnJhbWUueSwgc3JjLmZyYW1lLncsIHNyYy5mcmFtZS5oKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZXNlIGFyZSB0aGUgb3JpZ2luYWwgKG5vbi10cmltbWVkKSBzcHJpdGUgdmFsdWVzXHJcbiAgICAgICAgaWYgKHNyYy50cmltbWVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUuc2V0VHJpbShcclxuICAgICAgICAgICAgICAgIHNyYy5zb3VyY2VTaXplLncsXHJcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS5oLFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueCxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLnksXHJcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS53LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUuaFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNyYy5yb3RhdGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUucm90YXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnVwZGF0ZVVWc0ludmVydGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKU09OSGFzaDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9wYXJzZXJzL0pTT05IYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSA5Nzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFB5eGVsID0gZnVuY3Rpb24gKHRleHR1cmUsIGpzb24pXHJcbntcclxuICAgIC8vICBNYWxmb3JtZWQ/IFRoZXJlIGFyZSBhIGZldyBrZXlzIHRvIGNoZWNrIGhlcmUuXHJcbiAgICB2YXIgc2lnbmF0dXJlID0gWyAnbGF5ZXJzJywgJ3RpbGV3aWR0aCcsICd0aWxlaGVpZ2h0JywgJ3RpbGVzd2lkZScsICd0aWxlc2hpZ2gnIF07XHJcblxyXG4gICAgc2lnbmF0dXJlLmZvckVhY2goZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIWpzb25ba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignUGhhc2VyLkFuaW1hdGlvblBhcnNlci5KU09ORGF0YVB5eGVsOiBJbnZhbGlkIFB5eGVsIFRpbGVtYXAgSlNPTiBnaXZlbiwgbWlzc2luZyBcIicgKyBrZXkgKyAnXCIga2V5LicpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhqc29uKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEZvciB0aGlzIHB1cnBvc2UsIEkgb25seSBjYXJlIGFib3V0IHBhcnNpbmcgdGlsZW1hcHMgd2l0aCBhIHNpbmdsZSBsYXllci5cclxuICAgIGlmIChqc29uWydsYXllcnMnXS5sZW5ndGggIT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdQaGFzZXIuQW5pbWF0aW9uUGFyc2VyLkpTT05EYXRhUHl4ZWw6IFRvbyBtYW55IGxheWVycywgdGhpcyBwYXJzZXIgb25seSBzdXBwb3J0cyBmbGF0IFRpbGVtYXBzLicpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGpzb24pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IG5ldyBQaGFzZXIuRnJhbWVEYXRhKCk7XHJcblxyXG4gICAgdmFyIHRpbGVoZWlnaHQgPSBqc29uWyd0aWxlaGVpZ2h0J107XHJcbiAgICB2YXIgdGlsZXdpZHRoID0ganNvblsndGlsZXdpZHRoJ107XHJcblxyXG4gICAgdmFyIGZyYW1lcyA9IGpzb25bJ2xheWVycyddWzBdWyd0aWxlcyddO1xyXG4gICAgdmFyIG5ld0ZyYW1lO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG5ld0ZyYW1lID0gZGF0YS5hZGRGcmFtZShuZXcgUGhhc2VyLkZyYW1lKFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBmcmFtZXNbaV0ueCxcclxuICAgICAgICAgICAgZnJhbWVzW2ldLnksXHJcbiAgICAgICAgICAgIHRpbGV3aWR0aCxcclxuICAgICAgICAgICAgdGlsZWhlaWdodCxcclxuICAgICAgICAgICAgXCJmcmFtZV9cIiArIGkgIC8vIE5vIG5hbWVzIGFyZSBpbmNsdWRlZCBpbiBweXhlbCB0aWxlbWFwIGRhdGEuXHJcbiAgICAgICAgKSk7XHJcblxyXG4gICAgICAgIC8vIE5vIHRyaW0gZGF0YSBpcyBpbmNsdWRlZC5cclxuICAgICAgICBuZXdGcmFtZS5zZXRUcmltKGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHl4ZWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvcGFyc2Vycy9QeXhlbC5qc1xuLy8gbW9kdWxlIGlkID0gOTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG5cclxudmFyIFNwcml0ZVNoZWV0ID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb25maWcpXHJcbntcclxuICAgIHZhciBmcmFtZVdpZHRoID0gR2V0VmFsdWUoY29uZmlnLCAnZnJhbWVXaWR0aCcsIG51bGwpO1xyXG4gICAgdmFyIGZyYW1lSGVpZ2h0ID0gR2V0VmFsdWUoY29uZmlnLCAnZnJhbWVIZWlnaHQnLCBmcmFtZVdpZHRoKTtcclxuXHJcbiAgICAvLyAgSWYgbWlzc2luZyB3ZSBjYW4ndCBwcm9jZWVkXHJcbiAgICBpZiAoZnJhbWVXaWR0aCA9PT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVNYW5hZ2VyLlNwcml0ZVNoZWV0OiBJbnZhbGlkIGZyYW1lV2lkdGggZ2l2ZW4uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFkZCBpbiBhIF9fQkFTRSBlbnRyeSAoZm9yIHRoZSBlbnRpcmUgYXRsYXMpXHJcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xyXG5cclxuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuXHJcbiAgICB2YXIgc3RhcnRGcmFtZSA9IEdldFZhbHVlKGNvbmZpZywgJ3N0YXJ0RnJhbWUnLCAwKTtcclxuICAgIHZhciBlbmRGcmFtZSA9IEdldFZhbHVlKGNvbmZpZywgJ2VuZEZyYW1lJywgLTEpO1xyXG4gICAgdmFyIG1hcmdpbiA9IEdldFZhbHVlKGNvbmZpZywgJ21hcmdpbicsIDApO1xyXG4gICAgdmFyIHNwYWNpbmcgPSBHZXRWYWx1ZShjb25maWcsICdzcGFjaW5nJywgMCk7XHJcblxyXG4gICAgdmFyIHJvdyA9IE1hdGguZmxvb3IoKHdpZHRoIC0gbWFyZ2luKSAvIChmcmFtZVdpZHRoICsgc3BhY2luZykpO1xyXG4gICAgdmFyIGNvbHVtbiA9IE1hdGguZmxvb3IoKGhlaWdodCAtIG1hcmdpbikgLyAoZnJhbWVIZWlnaHQgKyBzcGFjaW5nKSk7XHJcbiAgICB2YXIgdG90YWwgPSByb3cgKiBjb2x1bW47XHJcblxyXG4gICAgaWYgKHN0YXJ0RnJhbWUgPiB0b3RhbCB8fCBzdGFydEZyYW1lIDwgLXRvdGFsKVxyXG4gICAge1xyXG4gICAgICAgIHN0YXJ0RnJhbWUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGFydEZyYW1lIDwgMClcclxuICAgIHtcclxuICAgICAgICAvLyAgQWxsb3cgbmVnYXRpdmUgc2tpcGZyYW1lcy5cclxuICAgICAgICBzdGFydEZyYW1lID0gdG90YWwgKyBzdGFydEZyYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbmRGcmFtZSAhPT0gLTEpXHJcbiAgICB7XHJcbiAgICAgICAgdG90YWwgPSBzdGFydEZyYW1lICsgKGVuZEZyYW1lICsgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZ4ID0gbWFyZ2luO1xyXG4gICAgdmFyIGZ5ID0gbWFyZ2luO1xyXG4gICAgdmFyIGF4ID0gMDtcclxuICAgIHZhciBheSA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGF4ID0gMDtcclxuICAgICAgICBheSA9IDA7XHJcblxyXG4gICAgICAgIHZhciB3ID0gZnggKyBmcmFtZVdpZHRoO1xyXG4gICAgICAgIHZhciBoID0gZnkgKyBmcmFtZUhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKHcgPiB3aWR0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF4ID0gdyAtIHdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGggPiBoZWlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBheSA9IGggLSBoZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0ZXh0dXJlLmFkZChpLCBzb3VyY2VJbmRleCwgeCArIGZ4LCB5ICsgZnksIGZyYW1lV2lkdGggLSBheCwgZnJhbWVIZWlnaHQgLSBheSk7XHJcblxyXG4gICAgICAgIGZ4ICs9IGZyYW1lV2lkdGggKyBzcGFjaW5nO1xyXG5cclxuICAgICAgICBpZiAoZnggKyBmcmFtZVdpZHRoID4gd2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmeCA9IG1hcmdpbjtcclxuICAgICAgICAgICAgZnkgKz0gZnJhbWVIZWlnaHQgKyBzcGFjaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ByaXRlU2hlZXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvcGFyc2Vycy9TcHJpdGVTaGVldC5qc1xuLy8gbW9kdWxlIGlkID0gOTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG5cclxudmFyIFNwcml0ZVNoZWV0RnJvbUF0bGFzID0gZnVuY3Rpb24gKHRleHR1cmUsIGZyYW1lLCBjb25maWcpXHJcbntcclxuICAgIHZhciBmcmFtZVdpZHRoID0gR2V0VmFsdWUoY29uZmlnLCAnZnJhbWVXaWR0aCcsIG51bGwpO1xyXG4gICAgdmFyIGZyYW1lSGVpZ2h0ID0gR2V0VmFsdWUoY29uZmlnLCAnZnJhbWVIZWlnaHQnLCBmcmFtZVdpZHRoKTtcclxuXHJcbiAgICAvLyAgSWYgbWlzc2luZyB3ZSBjYW4ndCBwcm9jZWVkXHJcbiAgICBpZiAoIWZyYW1lV2lkdGgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlTWFuYWdlci5TcHJpdGVTaGVldEZyb21BdGxhczogSW52YWxpZCBmcmFtZVdpZHRoIGdpdmVuLicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBZGQgaW4gYSBfX0JBU0UgZW50cnkgKGZvciB0aGUgZW50aXJlIGF0bGFzKVxyXG4gICAgLy8gdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlWzBdO1xyXG4gICAgLy8gdGV4dHVyZS5hZGQoJ19fQkFTRScsIDAsIDAsIDAsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcblxyXG4gICAgdmFyIHN0YXJ0RnJhbWUgPSBHZXRWYWx1ZShjb25maWcsICdzdGFydEZyYW1lJywgMCk7XHJcbiAgICB2YXIgZW5kRnJhbWUgPSBHZXRWYWx1ZShjb25maWcsICdlbmRGcmFtZScsIC0xKTtcclxuICAgIHZhciBtYXJnaW4gPSBHZXRWYWx1ZShjb25maWcsICdtYXJnaW4nLCAwKTtcclxuICAgIHZhciBzcGFjaW5nID0gR2V0VmFsdWUoY29uZmlnLCAnc3BhY2luZycsIDApO1xyXG5cclxuICAgIHZhciB4ID0gZnJhbWUuY3V0WDtcclxuICAgIHZhciB5ID0gZnJhbWUuY3V0WTtcclxuICAgIHZhciBjdXRXaWR0aCA9IGZyYW1lLmN1dFdpZHRoO1xyXG4gICAgdmFyIGN1dEhlaWdodCA9IGZyYW1lLmN1dEhlaWdodDtcclxuICAgIHZhciBzaGVldFdpZHRoID0gZnJhbWUucmVhbFdpZHRoO1xyXG4gICAgdmFyIHNoZWV0SGVpZ2h0ID0gZnJhbWUucmVhbEhlaWdodDtcclxuXHJcbiAgICB2YXIgcm93ID0gTWF0aC5mbG9vcigoc2hlZXRXaWR0aCAtIG1hcmdpbikgLyAoZnJhbWVXaWR0aCArIHNwYWNpbmcpKTtcclxuICAgIHZhciBjb2x1bW4gPSBNYXRoLmZsb29yKChzaGVldEhlaWdodCAtIG1hcmdpbikgLyAoZnJhbWVIZWlnaHQgKyBzcGFjaW5nKSk7XHJcbiAgICB2YXIgdG90YWwgPSByb3cgKiBjb2x1bW47XHJcblxyXG4gICAgY29uc29sZS5sb2coJ3NwbGl0IHNoZWV0IGludG8gcm93cy9jb2xzOicsIHJvdywgY29sdW1uLCAndG90YWwgZnJhbWVzOicsIHRvdGFsKTtcclxuXHJcbiAgICBpZiAoc3RhcnRGcmFtZSA+IHRvdGFsIHx8IHN0YXJ0RnJhbWUgPCAtdG90YWwpXHJcbiAgICB7XHJcbiAgICAgICAgc3RhcnRGcmFtZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0YXJ0RnJhbWUgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBBbGxvdyBuZWdhdGl2ZSBza2lwZnJhbWVzLlxyXG4gICAgICAgIHN0YXJ0RnJhbWUgPSB0b3RhbCArIHN0YXJ0RnJhbWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVuZEZyYW1lICE9PSAtMSlcclxuICAgIHtcclxuICAgICAgICB0b3RhbCA9IHN0YXJ0RnJhbWUgKyAoZW5kRnJhbWUgKyAxKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZnggPSBtYXJnaW47XHJcbiAgICB2YXIgZnkgPSBtYXJnaW47XHJcbiAgICB2YXIgYXggPSAwO1xyXG4gICAgdmFyIGF5ID0gMDtcclxuICAgIHZhciBzaGVldEZyYW1lO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcclxuICAgIHtcclxuICAgICAgICBheCA9IDA7XHJcbiAgICAgICAgYXkgPSAwO1xyXG5cclxuICAgICAgICB2YXIgdyA9IGZ4ICsgZnJhbWVXaWR0aDtcclxuICAgICAgICB2YXIgaCA9IGZ5ICsgZnJhbWVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh3ID4gd2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBheCA9IHcgLSB3aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoID4gaGVpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXkgPSBoIC0gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2hlZXRGcmFtZSA9IHRleHR1cmUuYWRkKGksIHNvdXJjZUluZGV4LCB4ICsgZngsIHkgKyBmeSwgZnJhbWVXaWR0aCAtIGF4LCBmcmFtZUhlaWdodCAtIGF5KTtcclxuXHJcbiAgICAgICAgLy8gc2hlZXRGcmFtZS5zZXRUcmltKHNoZWV0V2lkdGgsIHNoZWV0SGVpZ2h0LCApXHJcblxyXG4gICAgICAgIC8vIHNldFRyaW06IGZ1bmN0aW9uIChhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0LCBkZXN0WCwgZGVzdFksIGRlc3RXaWR0aCwgZGVzdEhlaWdodClcclxuXHJcblxyXG4gICAgICAgIGZ4ICs9IGZyYW1lV2lkdGggKyBzcGFjaW5nO1xyXG5cclxuICAgICAgICBpZiAoZnggKyBmcmFtZVdpZHRoID4gd2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmeCA9IG1hcmdpbjtcclxuICAgICAgICAgICAgZnkgKz0gZnJhbWVIZWlnaHQgKyBzcGFjaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ByaXRlU2hlZXRGcm9tQXRsYXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvcGFyc2Vycy9TcHJpdGVTaGVldEZyb21BdGxhcy5qc1xuLy8gbW9kdWxlIGlkID0gOTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdGFybGluZ1hNTCA9IGZ1bmN0aW9uICh0ZXh0dXJlLCB4bWwpXHJcbntcclxuICAgIC8vICBNYWxmb3JtZWQ/XHJcbiAgICBpZiAoIXhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnVGV4dHVyZUF0bGFzJykpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKFwiUGhhc2VyLkFuaW1hdGlvblBhcnNlci5YTUxEYXRhOiBJbnZhbGlkIFRleHR1cmUgQXRsYXMgWE1MIGdpdmVuLCBtaXNzaW5nIDxUZXh0dXJlQXRsYXM+IHRhZ1wiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIExldCdzIGNyZWF0ZSBzb21lIGZyYW1lcyB0aGVuXHJcbiAgICB2YXIgZGF0YSA9IG5ldyBQaGFzZXIuRnJhbWVEYXRhKCk7XHJcbiAgICB2YXIgZnJhbWVzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdTdWJUZXh0dXJlJyk7XHJcbiAgICB2YXIgbmV3RnJhbWU7XHJcblxyXG4gICAgdmFyIG5hbWU7XHJcbiAgICB2YXIgZnJhbWU7XHJcbiAgICB2YXIgeDtcclxuICAgIHZhciB5O1xyXG4gICAgdmFyIHdpZHRoO1xyXG4gICAgdmFyIGhlaWdodDtcclxuICAgIHZhciBmcmFtZVg7XHJcbiAgICB2YXIgZnJhbWVZO1xyXG4gICAgdmFyIGZyYW1lV2lkdGg7XHJcbiAgICB2YXIgZnJhbWVIZWlnaHQ7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgZnJhbWUgPSBmcmFtZXNbaV0uYXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgbmFtZSA9IGZyYW1lLm5hbWUudmFsdWU7XHJcbiAgICAgICAgeCA9IHBhcnNlSW50KGZyYW1lLngudmFsdWUsIDEwKTtcclxuICAgICAgICB5ID0gcGFyc2VJbnQoZnJhbWUueS52YWx1ZSwgMTApO1xyXG4gICAgICAgIHdpZHRoID0gcGFyc2VJbnQoZnJhbWUud2lkdGgudmFsdWUsIDEwKTtcclxuICAgICAgICBoZWlnaHQgPSBwYXJzZUludChmcmFtZS5oZWlnaHQudmFsdWUsIDEwKTtcclxuXHJcbiAgICAgICAgZnJhbWVYID0gbnVsbDtcclxuICAgICAgICBmcmFtZVkgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoZnJhbWUuZnJhbWVYKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZnJhbWVYID0gTWF0aC5hYnMocGFyc2VJbnQoZnJhbWUuZnJhbWVYLnZhbHVlLCAxMCkpO1xyXG4gICAgICAgICAgICBmcmFtZVkgPSBNYXRoLmFicyhwYXJzZUludChmcmFtZS5mcmFtZVkudmFsdWUsIDEwKSk7XHJcbiAgICAgICAgICAgIGZyYW1lV2lkdGggPSBwYXJzZUludChmcmFtZS5mcmFtZVdpZHRoLnZhbHVlLCAxMCk7XHJcbiAgICAgICAgICAgIGZyYW1lSGVpZ2h0ID0gcGFyc2VJbnQoZnJhbWUuZnJhbWVIZWlnaHQudmFsdWUsIDEwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5ld0ZyYW1lID0gZGF0YS5hZGRGcmFtZShuZXcgUGhhc2VyLkZyYW1lKGksIHgsIHksIHdpZHRoLCBoZWlnaHQsIG5hbWUpKTtcclxuXHJcbiAgICAgICAgLy8gIFRyaW1tZWQ/XHJcbiAgICAgICAgaWYgKGZyYW1lWCAhPT0gbnVsbCB8fCBmcmFtZVkgIT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuZXdGcmFtZS5zZXRUcmltKHRydWUsIHdpZHRoLCBoZWlnaHQsIGZyYW1lWCwgZnJhbWVZLCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RhcmxpbmdYTUw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvcGFyc2Vycy9TdGFybGluZ1hNTC5qc1xuLy8gbW9kdWxlIGlkID0gOTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcbkV4YW1wbGUgZGF0YTpcclxuXHJcblRleHR1cmVJbXBvcnRlcjpcclxuICBzcHJpdGVQaXZvdDoge3g6IC41LCB5OiAuNX1cclxuICBzcHJpdGVCb3JkZXI6IHt4OiAwLCB5OiAwLCB6OiAwLCB3OiAwfVxyXG4gIHNwcml0ZVBpeGVsc1RvVW5pdHM6IDEwMFxyXG4gIHNwcml0ZVNoZWV0OlxyXG4gICAgc3ByaXRlczpcclxuICAgIC0gbmFtZTogYXN0ZXJvaWRzXzBcclxuICAgICAgcmVjdDpcclxuICAgICAgICBzZXJpYWxpemVkVmVyc2lvbjogMlxyXG4gICAgICAgIHg6IDVcclxuICAgICAgICB5OiAzMjhcclxuICAgICAgICB3aWR0aDogNjVcclxuICAgICAgICBoZWlnaHQ6IDgyXHJcbiAgICAgIGFsaWdubWVudDogMFxyXG4gICAgICBwaXZvdDoge3g6IDAsIHk6IDB9XHJcbiAgICAgIGJvcmRlcjoge3g6IDAsIHk6IDAsIHo6IDAsIHc6IDB9XHJcbiAgICAtIG5hbWU6IGFzdGVyb2lkc18xXHJcbiAgICAgIHJlY3Q6XHJcbiAgICAgICAgc2VyaWFsaXplZFZlcnNpb246IDJcclxuICAgICAgICB4OiA4MFxyXG4gICAgICAgIHk6IDMyMlxyXG4gICAgICAgIHdpZHRoOiA1M1xyXG4gICAgICAgIGhlaWdodDogODhcclxuICAgICAgYWxpZ25tZW50OiAwXHJcbiAgICAgIHBpdm90OiB7eDogMCwgeTogMH1cclxuICAgICAgYm9yZGVyOiB7eDogMCwgeTogMCwgejogMCwgdzogMH1cclxuICBzcHJpdGVQYWNraW5nVGFnOiBBc3Rlcm9pZHNcclxuKi9cclxuXHJcbnZhciBpbWFnZUhlaWdodCA9IDA7XHJcblxyXG52YXIgYWRkRnJhbWUgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIG5hbWUsIGZyYW1lKVxyXG57XHJcbiAgICAvLyAgVGhlIGZyYW1lIHZhbHVlcyBhcmUgdGhlIGV4YWN0IGNvb3JkaW5hdGVzIHRvIGN1dCB0aGUgZnJhbWUgb3V0IG9mIHRoZSBhdGxhcyBmcm9tXHJcblxyXG4gICAgdmFyIHkgPSBpbWFnZUhlaWdodCAtIGZyYW1lLnkgLSBmcmFtZS5oZWlnaHQ7XHJcblxyXG4gICAgdmFyIG5ld0ZyYW1lID0gdGV4dHVyZS5hZGQobmFtZSwgc291cmNlSW5kZXgsIGZyYW1lLngsIHksIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xyXG5cclxuICAgIC8vIGNvbnNvbGUubG9nKCduYW1lJywgbmFtZSwgJ3JlY3QnLCBmcmFtZS54LCB5LCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcclxuXHJcbiAgICAvLyAgVGhlc2UgYXJlIHRoZSBvcmlnaW5hbCAobm9uLXRyaW1tZWQpIHNwcml0ZSB2YWx1ZXNcclxuICAgIC8qXHJcbiAgICBpZiAoc3JjLnRyaW1tZWQpXHJcbiAgICB7XHJcbiAgICAgICAgbmV3RnJhbWUuc2V0VHJpbShcclxuICAgICAgICAgICAgc3JjLnNvdXJjZVNpemUudyxcclxuICAgICAgICAgICAgc3JjLnNvdXJjZVNpemUuaCxcclxuICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueCxcclxuICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueSxcclxuICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUudyxcclxuICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUuaFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICAqL1xyXG59O1xyXG5cclxuLy8gaHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9TcHJpdGVNZXRhRGF0YS5odG1sXHJcblxyXG52YXIgVW5pdHlZQU1MID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4LCB5YW1sKVxyXG57XHJcbiAgICAvLyAgQWRkIGluIGEgX19CQVNFIGVudHJ5IChmb3IgdGhlIGVudGlyZSBhdGxhcylcclxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XHJcblxyXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG5cclxuICAgIGltYWdlSGVpZ2h0ID0gc291cmNlLmhlaWdodDtcclxuXHJcbiAgICB2YXIgZGF0YSA9IHlhbWwuc3BsaXQoJ1xcbicpO1xyXG5cclxuICAgIHZhciBsaW5lUmVnRXhwID0gL15bIF0qKC0gKSooXFx3KykrWzogXSsoLiopLztcclxuXHJcbiAgICB2YXIgcHJldlNwcml0ZSA9ICcnO1xyXG4gICAgdmFyIGN1cnJlbnRTcHJpdGUgPSAnJztcclxuICAgIHZhciByZWN0ID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XHJcbiAgICB2YXIgcGl2b3QgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgIHZhciBib3JkZXIgPSB7IHg6IDAsIHk6IDAsIHo6IDAsIHc6IDAgfTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBkYXRhW2ldLm1hdGNoKGxpbmVSZWdFeHApO1xyXG5cclxuICAgICAgICBpZiAoIXJlc3VsdHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpc0xpc3QgPSAocmVzdWx0c1sxXSA9PT0gJy0gJyk7XHJcbiAgICAgICAgdmFyIGtleSA9IHJlc3VsdHNbMl07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0c1szXTtcclxuXHJcbiAgICAgICAgaWYgKGlzTGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3ByaXRlICE9PSBwcmV2U3ByaXRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhZGRGcmFtZSh0ZXh0dXJlLCBzb3VyY2VJbmRleCwgY3VycmVudFNwcml0ZSwgcmVjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcHJldlNwcml0ZSA9IGN1cnJlbnRTcHJpdGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlY3QgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChrZXkgPT09ICduYW1lJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBTdGFydCBuZXcgbGlzdFxyXG4gICAgICAgICAgICBjdXJyZW50U3ByaXRlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3dpdGNoIChrZXkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYXNlICd4JzpcclxuICAgICAgICAgICAgY2FzZSAneSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcclxuICAgICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcclxuICAgICAgICAgICAgICAgIHJlY3Rba2V5XSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ3Bpdm90JzpcclxuICAgICAgICAgICAgICAgIHBpdm90ID0gZXZhbCgndmFyIG9iaiA9ICcgKyB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2JvcmRlcic6XHJcbiAgICAgICAgICAgICAgICBib3JkZXIgPSBldmFsKCd2YXIgb2JqID0gJyArIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3VycmVudFNwcml0ZSAhPT0gcHJldlNwcml0ZSlcclxuICAgIHtcclxuICAgICAgICBhZGRGcmFtZSh0ZXh0dXJlLCBzb3VyY2VJbmRleCwgY3VycmVudFNwcml0ZSwgcmVjdCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXR5WUFNTDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9wYXJzZXJzL1VuaXR5WUFNTC5qc1xuLy8gbW9kdWxlIGlkID0gOTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIENhbnZhczogcmVxdWlyZSgnLi9DYW52YXMnKSxcclxuICAgIEltYWdlOiByZXF1aXJlKCcuL0ltYWdlJyksXHJcbiAgICBKU09OQXJyYXk6IHJlcXVpcmUoJy4vSlNPTkFycmF5JyksXHJcbiAgICBKU09OSGFzaDogcmVxdWlyZSgnLi9KU09OSGFzaCcpLFxyXG4gICAgUHl4ZWw6IHJlcXVpcmUoJy4vUHl4ZWwnKSxcclxuICAgIFNwcml0ZVNoZWV0OiByZXF1aXJlKCcuL1Nwcml0ZVNoZWV0JyksXHJcbiAgICBTcHJpdGVTaGVldEZyb21BdGxhczogcmVxdWlyZSgnLi9TcHJpdGVTaGVldEZyb21BdGxhcycpLFxyXG4gICAgU3RhcmxpbmdYTUw6IHJlcXVpcmUoJy4vU3RhcmxpbmdYTUwnKSxcclxuICAgIFVuaXR5WUFNTDogcmVxdWlyZSgnLi9Vbml0eVlBTUwnKVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3RleHR1cmVzL3BhcnNlcnMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDk4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG52YXIgVGltZXJFdmVudCA9IHJlcXVpcmUoJy4vVGltZXJFdmVudCcpO1xyXG5cclxudmFyIENsb2NrID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIENsb2NrIChzY2VuZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcblxyXG4gICAgICAgIHRoaXMubm93ID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgLy8gIFNjYWxlIHRoZSBkZWx0YSB0aW1lIGNvbWluZyBpbnRvIHRoZSBDbG9jayBieSB0aGlzIGZhY3RvclxyXG4gICAgICAgIC8vICB3aGljaCB0aGVuIGluZmx1ZW5jZXMgYW55dGhpbmcgdXNpbmcgdGhpcyBDbG9jayBmb3IgY2FsY3VsYXRpb25zLCBsaWtlIFRpbWVyRXZlbnRzXHJcbiAgICAgICAgdGhpcy50aW1lU2NhbGUgPSAxO1xyXG5cclxuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBbXTtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nSW5zZXJ0aW9uID0gW107XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlbW92YWwgPSBbXTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkRXZlbnQ6IGZ1bmN0aW9uIChjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IFRpbWVyRXZlbnQoY29uZmlnKTtcclxuXHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0luc2VydGlvbi5wdXNoKGV2ZW50KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgfSxcclxuXHJcbiAgICBkZWxheWVkQ2FsbDogZnVuY3Rpb24gKGRlbGF5LCBjYWxsYmFjaywgYXJncywgY2FsbGJhY2tTY29wZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRFdmVudCh7IGRlbGF5OiBkZWxheSwgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzLCBjYWxsYmFja1Njb3BlOiBjYWxsYmFja1Njb3BlIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhclBlbmRpbmdFdmVudHM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0luc2VydGlvbiA9IFtdO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVBbGxFdmVudHM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlbW92YWwgPSB0aGlzLl9wZW5kaW5nUmVtb3ZhbC5jb25jYXQodGhpcy5fYWN0aXZlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGJlZ2luOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0b1JlbW92ZSA9IHRoaXMuX3BlbmRpbmdSZW1vdmFsLmxlbmd0aDtcclxuICAgICAgICB2YXIgdG9JbnNlcnQgPSB0aGlzLl9wZW5kaW5nSW5zZXJ0aW9uLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKHRvUmVtb3ZlID09PSAwICYmIHRvSW5zZXJ0ID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFF1aWNrIGJhaWxcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGV2ZW50O1xyXG5cclxuICAgICAgICAvLyAgRGVsZXRlIG9sZCBldmVudHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9SZW1vdmU7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gdGhpcy5fcGVuZGluZ1JlbW92YWxbaV07XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9hY3RpdmUuaW5kZXhPZihldmVudCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vICBQb29sIHRoZW0/XHJcbiAgICAgICAgICAgIGV2ZW50LmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0luc2VydDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZXZlbnQgPSB0aGlzLl9wZW5kaW5nSW5zZXJ0aW9uW2ldO1xyXG5cclxuICAgICAgICAgICAgZXZlbnQuZWxhcHNlZCA9IGV2ZW50LnN0YXJ0QXQgKiBldmVudC50aW1lU2NhbGU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUucHVzaChldmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQ2xlYXIgdGhlIGxpc3RzXHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlbW92YWwubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nSW5zZXJ0aW9uLmxlbmd0aCA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWUsIGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubm93ID0gdGltZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVsdGEgKiB0aGlzLnRpbWVTY2FsZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl9hY3RpdmVbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoZXZlbnQucGF1c2VkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIFVzZSBkZWx0YSB0aW1lIHRvIGluY3JlYXNlIGVsYXBzZWQuXHJcbiAgICAgICAgICAgIC8vICBBdm9pZHMgbmVlZGluZyB0byBhZGp1c3QgZm9yIHBhdXNlIC8gcmVzdW1lLlxyXG4gICAgICAgICAgICAvLyAgQXV0b21hdGljYWxseSBzbW9vdGhlZCBieSBUaW1lU3RlcCBjbGFzcy5cclxuICAgICAgICAgICAgLy8gIEluIHRlc3RpbmcgYWNjdXJhdGUgdG8gKy0gMW1zIVxyXG4gICAgICAgICAgICBldmVudC5lbGFwc2VkICs9IGRlbHRhICogZXZlbnQudGltZVNjYWxlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2ZW50LmVsYXBzZWQgPj0gZXZlbnQuZGVsYXkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSBldmVudC5lbGFwc2VkIC0gZXZlbnQuZGVsYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIExpbWl0IGl0LCBpbiBjYXNlIGl0J3MgY2hlY2tlZCBpbiB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIGV2ZW50LmVsYXBzZWQgPSBldmVudC5kZWxheTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgUHJvY2VzcyB0aGUgZXZlbnRcclxuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuaGFzRGlzcGF0Y2hlZCAmJiBldmVudC5jYWxsYmFjaylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5oYXNEaXNwYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5jYWxsYmFjay5hcHBseShldmVudC5jYWxsYmFja1Njb3BlLCBldmVudC5hcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucmVwZWF0Q291bnQgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnJlcGVhdENvdW50LS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmVsYXBzZWQgPSByZW1haW5kZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuaGFzRGlzcGF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZW1vdmFsLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU2NlbmUgdGhhdCBvd25zIHRoaXMgQ2xvY2sgaXMgc2h1dHRpbmcgZG93blxyXG4gICAgc2h1dGRvd246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9wZW5kaW5nSW5zZXJ0aW9uLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0luc2VydGlvbltpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9wZW5kaW5nUmVtb3ZhbC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZW1vdmFsW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2FjdGl2ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZW1vdmFsLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0luc2VydGlvbi5sZW5ndGggPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgR2FtZSBsZXZlbCBudWtlXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcclxuXHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9jaztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90aW1lL0Nsb2NrLmpzXG4vLyBtb2R1bGUgaWQgPSA5ODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdldEZhc3RWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL29iamVjdC9HZXRGYXN0VmFsdWUnKTtcclxuXHJcbnZhciBUaW1lckV2ZW50ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFRpbWVyRXZlbnQgKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWxheSAtIFRoZSBkZWxheSBpbiBtcyBhdCB3aGljaCB0aGlzIFRpbWVyRXZlbnQgZmlyZXMuXHJcbiAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVsYXkgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXBlYXQgLSBUaGUgdG90YWwgbnVtYmVyIG9mIHRpbWVzIHRoaXMgVGltZXJFdmVudCB3aWxsIHJlcGVhdCBiZWZvcmUgZmluaXNoaW5nLlxyXG4gICAgICAgICogQHJlYWRPbmx5XHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlcGVhdCA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJlcGVhdENvdW50IC0gSWYgcmVwZWF0aW5nIHRoaXMgY29udGFpbnMgdGhlIGN1cnJlbnQgcmVwZWF0IGNvdW50LlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZXBlYXRDb3VudCA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBsb29wIC0gVHJ1ZSBpZiB0aGlzIFRpbWVyRXZlbnQgbG9vcHMsIG90aGVyd2lzZSBmYWxzZS5cclxuICAgICAgICAqIEByZWFkT25seVxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb29wID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBUaW1lckV2ZW50IG9jY3Vycy5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2s7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IGNhbGxiYWNrQ29udGV4dCAtIFRoZSBjb250ZXh0IGluIHdoaWNoIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZC5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tTY29wZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJvcGVydHkge2FueVtdfSBhcmd1bWVudHMgLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hcmdzO1xyXG5cclxuICAgICAgICAvLyAgU2NhbGUgdGhlIHRpbWUgY2F1c2luZyB0aGlzIFRpbWVyRXZlbnQgdG8gdXBkYXRlXHJcbiAgICAgICAgdGhpcy50aW1lU2NhbGUgPSAxO1xyXG5cclxuICAgICAgICAvLyAgU3RhcnQgdGhpcyBtYW55IE1TIGludG8gdGhlIGVsYXBzZWQgKHVzZWZ1bCBpZiB5b3Ugd2FudCBhIGxvbmcgZHVyYXRpb24gd2l0aCByZXBlYXQsIGJ1dCBmb3IgdGhlIGZpcnN0IGxvb3AgdG8gZmlyZSBxdWlja2x5KVxyXG4gICAgICAgIHRoaXMuc3RhcnRBdCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuZWxhcHNlZCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuaGFzRGlzcGF0Y2hlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2V0KGNvbmZpZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZGVsYXkgPSBHZXRGYXN0VmFsdWUoY29uZmlnLCAnZGVsYXknLCAwKTtcclxuXHJcbiAgICAgICAgLy8gIENhbiBhbHNvIGJlIHNldCB0byAtMSBmb3IgYW4gaW5maW5pdGUgbG9vcCAoc2FtZSBhcyBzZXR0aW5nIGxvb3A6IHRydWUpXHJcbiAgICAgICAgdGhpcy5yZXBlYXQgPSBHZXRGYXN0VmFsdWUoY29uZmlnLCAncmVwZWF0JywgMCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9vcCA9IEdldEZhc3RWYWx1ZShjb25maWcsICdsb29wJywgZmFsc2UpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ2NhbGxiYWNrJywgdW5kZWZpbmVkKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFja1Njb3BlID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ2NhbGxiYWNrU2NvcGUnLCB0aGlzLmNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgdGhpcy5hcmdzID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ2FyZ3MnLCBbXSk7XHJcblxyXG4gICAgICAgIHRoaXMudGltZVNjYWxlID0gR2V0RmFzdFZhbHVlKGNvbmZpZywgJ3RpbWVTY2FsZScsIDEpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0QXQgPSBHZXRGYXN0VmFsdWUoY29uZmlnLCAnc3RhcnRBdCcsIDApO1xyXG5cclxuICAgICAgICB0aGlzLnBhdXNlZCA9IEdldEZhc3RWYWx1ZShjb25maWcsICdwYXVzZWQnLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZWxhcHNlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5oYXNEaXNwYXRjaGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZXBlYXRDb3VudCA9ICh0aGlzLnJlcGVhdCA9PT0gLTEgfHwgdGhpcy5sb29wKSA/IDk5OTk5OTk5OTk5OSA6IHRoaXMucmVwZWF0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEdldHMgdGhlIHByb2dyZXNzIG9mIHRoZSBjdXJyZW50IGl0ZXJhdGlvbiwgbm90IGZhY3RvcmluZyBpbiByZXBlYXRzXHJcbiAgICBnZXRQcm9ncmVzczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZWxhcHNlZCAvIHRoaXMuZGVsYXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgR2V0cyB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIHRpbWVyIG92ZXJhbGwsIGZhY3RvcmluZyBpbiByZXBlYXRzLlxyXG4gICAgZ2V0T3ZlcmFsbFByb2dyZXNzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnJlcGVhdCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgdG90YWxEdXJhdGlvbiA9IHRoaXMuZGVsYXkgKyAodGhpcy5kZWxheSAqIHRoaXMucmVwZWF0KTtcclxuICAgICAgICAgICAgdmFyIHRvdGFsRWxhcHNlZCA9IHRoaXMuZWxhcHNlZCArICh0aGlzLmRlbGF5ICogKHRoaXMucmVwZWF0IC0gdGhpcy5yZXBlYXRDb3VudCkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICh0b3RhbEVsYXBzZWQgLyB0b3RhbER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvZ3Jlc3MoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFJlcGVhdENvdW50OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcGVhdENvdW50O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRFbGFwc2VkOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsYXBzZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEVsYXBzZWRTZWNvbmRzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsYXBzZWQgKiAwLjAwMTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoZGlzcGF0Y2hDYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICBpZiAoZGlzcGF0Y2hDYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7IGRpc3BhdGNoQ2FsbGJhY2sgPSBmYWxzZTsgfVxyXG5cclxuICAgICAgICB0aGlzLmVsYXBzZWQgPSB0aGlzLmRlbGF5O1xyXG5cclxuICAgICAgICB0aGlzLmhhc0Rpc3BhdGNoZWQgPSAhIWRpc3BhdGNoQ2FsbGJhY2s7XHJcblxyXG4gICAgICAgIHRoaXMucmVwZWF0Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIGludGVybmFseSwgcHJpdmF0ZVxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tTY29wZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmFyZ3MubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaW1lckV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3RpbWUvVGltZXJFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gOTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSRVNFUlZFRCA9IHJlcXVpcmUoJy4uL3R3ZWVuL1Jlc2VydmVkUHJvcHMnKTtcclxuXHJcbnZhciBHZXRQcm9wcyA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHZhciBrZXk7XHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG5cclxuICAgIC8vICBGaXJzdCBzZWUgaWYgd2UgaGF2ZSBhIHByb3BzIG9iamVjdFxyXG5cclxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ3Byb3BzJykpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yIChrZXkgaW4gY29uZmlnLnByb3BzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFNraXAgYW55IHByb3BlcnR5IHRoYXQgc3RhcnRzIHdpdGggYW4gdW5kZXJzY29yZVxyXG4gICAgICAgICAgICBpZiAoa2V5LnN1YnN0cigwLCAxKSAhPT0gJ18nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goeyBrZXk6IGtleSwgdmFsdWU6IGNvbmZpZy5wcm9wc1trZXldIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGZvciAoa2V5IGluIGNvbmZpZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBTa2lwIGFueSBwcm9wZXJ0eSB0aGF0IGlzIGluIHRoZSBSZXNlcnZlZFByb3BzIGxpc3Qgb3IgdGhhdCBzdGFydHMgd2l0aCBhbiB1bmRlcnNjb3JlXHJcbiAgICAgICAgICAgIGlmIChSRVNFUlZFRC5pbmRleE9mKGtleSkgPT09IC0xICYmIGtleS5zdWJzdHIoMCwgMSkgIT09ICdfJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiBjb25maWdba2V5XSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ga2V5cztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UHJvcHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vYnVpbGRlci9HZXRQcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gOTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG5cclxudmFyIEdldFR3ZWVucyA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHZhciB0d2VlbnMgPSBHZXRWYWx1ZShjb25maWcsICd0d2VlbnMnLCBudWxsKTtcclxuXHJcbiAgICBpZiAodHdlZW5zID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB0d2VlbnMgPT09ICdmdW5jdGlvbicpXHJcbiAgICB7XHJcbiAgICAgICAgdHdlZW5zID0gdHdlZW5zLmNhbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHdlZW5zKSlcclxuICAgIHtcclxuICAgICAgICB0d2VlbnMgPSBbIHR3ZWVucyBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0d2VlbnM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFR3ZWVucztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9idWlsZGVyL0dldFR3ZWVucy5qc1xuLy8gbW9kdWxlIGlkID0gOTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGhhc0dldFN0YXJ0IChkZWYpXHJcbntcclxuICAgIHJldHVybiAoISFkZWYuZ2V0U3RhcnQgJiYgdHlwZW9mIGRlZi5nZXRTdGFydCA9PT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc0dldEVuZCAoZGVmKVxyXG57XHJcbiAgICByZXR1cm4gKCEhZGVmLmdldEVuZCAmJiB0eXBlb2YgZGVmLmdldEVuZCA9PT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc0dldHRlcnMgKGRlZilcclxue1xyXG4gICAgcmV0dXJuIGhhc0dldFN0YXJ0KGRlZikgfHwgaGFzR2V0RW5kKGRlZik7XHJcbn1cclxuXHJcbnZhciBHZXRWYWx1ZU9wID0gZnVuY3Rpb24gKGtleSwgcHJvcGVydHlWYWx1ZSlcclxue1xyXG4gICAgdmFyIGNhbGxiYWNrcztcclxuXHJcbiAgICAvLyAgVGhlIHJldHVybmVkIHZhbHVlIHNldHMgd2hhdCB0aGUgcHJvcGVydHkgd2lsbCBiZSBhdCB0aGUgRU5EIG9mIHRoZSBUd2VlbiAodXN1YWxseSBjYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBUd2VlbilcclxuICAgIHZhciBnZXRFbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcclxuXHJcbiAgICAvLyAgVGhlIHJldHVybmVkIHZhbHVlIHNldHMgd2hhdCB0aGUgcHJvcGVydHkgd2lsbCBiZSBhdCB0aGUgU1RBUlQgb2YgdGhlIFR3ZWVuICh1c3VhbGx5IGNhbGxlZCBhdCB0aGUgZW5kIG9mIHRoZSBUd2VlbilcclxuICAgIHZhciBnZXRTdGFydCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xyXG5cclxuICAgIHZhciB0ID0gdHlwZW9mKHByb3BlcnR5VmFsdWUpO1xyXG5cclxuICAgIGlmICh0ID09PSAnbnVtYmVyJylcclxuICAgIHtcclxuICAgICAgICAvLyBwcm9wczoge1xyXG4gICAgICAgIC8vICAgICB4OiA0MDAsXHJcbiAgICAgICAgLy8gICAgIHk6IDMwMFxyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgZ2V0RW5kID0gZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eVZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0ID09PSAnc3RyaW5nJylcclxuICAgIHtcclxuICAgICAgICAvLyBwcm9wczoge1xyXG4gICAgICAgIC8vICAgICB4OiAnKz00MDAnLFxyXG4gICAgICAgIC8vICAgICB5OiAnLT0zMDAnLFxyXG4gICAgICAgIC8vICAgICB6OiAnKj0yJyxcclxuICAgICAgICAvLyAgICAgdzogJy89MidcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIHZhciBvcCA9IHByb3BlcnR5VmFsdWVbMF07XHJcbiAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQocHJvcGVydHlWYWx1ZS5zdWJzdHIoMikpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKG9wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgICAgICAgICBnZXRFbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArIG51bTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJy0nOlxyXG4gICAgICAgICAgICAgICAgZ2V0RW5kID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgLSBudW07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICcqJzpcclxuICAgICAgICAgICAgICAgIGdldEVuZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICogbnVtO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnLyc6XHJcbiAgICAgICAgICAgICAgICBnZXRFbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAvIG51bTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBnZXRFbmQgPSBmdW5jdGlvbiAoKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHByb3BlcnR5VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0ID09PSAnZnVuY3Rpb24nKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUaGUgc2FtZSBhcyBzZXR0aW5nIGp1c3QgdGhlIGdldEVuZCBmdW5jdGlvbiBhbmQgbm8gZ2V0U3RhcnRcclxuXHJcbiAgICAgICAgLy8gcHJvcHM6IHtcclxuICAgICAgICAvLyAgICAgeDogZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkgeyByZXR1cm4gdmFsdWUgKyA1MCk7IH0sXHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBnZXRFbmQgPSBwcm9wZXJ0eVZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodCA9PT0gJ29iamVjdCcgJiYgaGFzR2V0dGVycyhwcm9wZXJ0eVZhbHVlKSlcclxuICAgIHtcclxuICAgICAgICAvKlxyXG4gICAgICAgIHg6IHtcclxuICAgICAgICAgICAgLy8gIENhbGxlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIFR3ZWVuLiBUaGUgcmV0dXJuZWQgdmFsdWUgc2V0cyB3aGF0IHRoZSBwcm9wZXJ0eSB3aWxsIGJlIGF0IHRoZSBFTkQgb2YgdGhlIFR3ZWVuLlxyXG4gICAgICAgICAgICBnZXRFbmQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vICBDYWxsZWQgYXQgdGhlIGVuZCBvZiB0aGUgVHdlZW4uIFRoZSByZXR1cm5lZCB2YWx1ZSBzZXRzIHdoYXQgdGhlIHByb3BlcnR5IHdpbGwgYmUgYXQgdGhlIFNUQVJUIG9mIHRoZSBUd2Vlbi5cclxuICAgICAgICAgICAgZ2V0U3RhcnQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAqL1xyXG5cclxuICAgICAgICBpZiAoaGFzR2V0RW5kKHByb3BlcnR5VmFsdWUpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0RW5kID0gcHJvcGVydHlWYWx1ZS5nZXRFbmQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGFzR2V0U3RhcnQocHJvcGVydHlWYWx1ZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRTdGFydCA9IHByb3BlcnR5VmFsdWUuZ2V0U3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvcGVydHlWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSlcclxuICAgIHtcclxuICAgICAgICAvLyAgVmFsdWUgbWF5IHN0aWxsIGJlIGEgc3RyaW5nLCBmdW5jdGlvbiBvciBhIG51bWJlclxyXG4gICAgICAgIC8vIHByb3BzOiB7XHJcbiAgICAgICAgLy8gICAgIHg6IHsgdmFsdWU6IDQwMCwgLi4uIH0sXHJcbiAgICAgICAgLy8gICAgIHk6IHsgdmFsdWU6IDMwMCwgLi4uIH1cclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIGNhbGxiYWNrcyA9IEdldFZhbHVlT3Aoa2V5LCBwcm9wZXJ0eVZhbHVlLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgSWYgY2FsbGJhY2sgbm90IHNldCBieSB0aGUgZWxzZSBpZiBibG9jayBhYm92ZSB0aGVuIHNldCBpdCBoZXJlIGFuZCByZXR1cm4gaXRcclxuICAgIGlmICghY2FsbGJhY2tzKVxyXG4gICAge1xyXG4gICAgICAgIGNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgZ2V0RW5kOiBnZXRFbmQsXHJcbiAgICAgICAgICAgIGdldFN0YXJ0OiBnZXRTdGFydFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhbGxiYWNrcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VmFsdWVPcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9idWlsZGVyL0dldFZhbHVlT3AuanNcbi8vIG1vZHVsZSBpZCA9IDk4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xvbmUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvQ2xvbmUnKTtcclxudmFyIERlZmF1bHRzID0gcmVxdWlyZSgnLi4vdHdlZW4vRGVmYXVsdHMnKTtcclxudmFyIEdldEJvb2xlYW4gPSByZXF1aXJlKCcuL0dldEJvb2xlYW4nKTtcclxudmFyIEdldEVhc2VGdW5jdGlvbiA9IHJlcXVpcmUoJy4vR2V0RWFzZUZ1bmN0aW9uJyk7XHJcbnZhciBHZXROZXdWYWx1ZSA9IHJlcXVpcmUoJy4vR2V0TmV3VmFsdWUnKTtcclxudmFyIEdldFRhcmdldHMgPSByZXF1aXJlKCcuL0dldFRhcmdldHMnKTtcclxudmFyIEdldFR3ZWVucyA9IHJlcXVpcmUoJy4vR2V0VHdlZW5zJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgR2V0QWR2YW5jZWRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRBZHZhbmNlZFZhbHVlJyk7XHJcbnZhciBUaW1lbGluZSA9IHJlcXVpcmUoJy4uL3RpbWVsaW5lL1RpbWVsaW5lJyk7XHJcbnZhciBUd2VlbkJ1aWxkZXIgPSByZXF1aXJlKCcuL1R3ZWVuQnVpbGRlcicpO1xyXG5cclxudmFyIFRpbWVsaW5lQnVpbGRlciA9IGZ1bmN0aW9uIChtYW5hZ2VyLCBjb25maWcpXHJcbntcclxuICAgIHZhciB0aW1lbGluZSA9IG5ldyBUaW1lbGluZShtYW5hZ2VyKTtcclxuXHJcbiAgICB2YXIgdHdlZW5zID0gR2V0VHdlZW5zKGNvbmZpZyk7XHJcblxyXG4gICAgaWYgKHR3ZWVucy5sZW5ndGggPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgdGltZWxpbmUucGF1c2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRpbWVsaW5lO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0cyA9IENsb25lKERlZmF1bHRzKTtcclxuXHJcbiAgICBkZWZhdWx0cy50YXJnZXRzID0gR2V0VGFyZ2V0cyhjb25maWcpO1xyXG5cclxuICAgIC8vICB0b3RhbER1cmF0aW9uOiBJZiBzcGVjaWZpZWQgZWFjaCB0d2VlbiBpbiB0aGUgVGltZWxpbmUgaXMgZ2l2ZW4gYW4gZXF1YWwgcG9ydGlvbiBvZiB0aGUgdG90YWxEdXJhdGlvblxyXG5cclxuICAgIHZhciB0b3RhbER1cmF0aW9uID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd0b3RhbER1cmF0aW9uJywgMCk7XHJcblxyXG4gICAgaWYgKHRvdGFsRHVyYXRpb24gPiAwKVxyXG4gICAge1xyXG4gICAgICAgIGRlZmF1bHRzLmR1cmF0aW9uID0gTWF0aC5mbG9vcih0b3RhbER1cmF0aW9uIC8gdHdlZW5zLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZGVmYXVsdHMuZHVyYXRpb24gPSBHZXROZXdWYWx1ZShjb25maWcsICdkdXJhdGlvbicsIGRlZmF1bHRzLmR1cmF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWZhdWx0cy5kZWxheSA9IEdldE5ld1ZhbHVlKGNvbmZpZywgJ2RlbGF5JywgZGVmYXVsdHMuZGVsYXkpO1xyXG4gICAgZGVmYXVsdHMuZWFzZVBhcmFtcyA9IEdldFZhbHVlKGNvbmZpZywgJ2Vhc2VQYXJhbXMnLCBkZWZhdWx0cy5lYXNlUGFyYW1zKTtcclxuICAgIGRlZmF1bHRzLmVhc2UgPSBHZXRFYXNlRnVuY3Rpb24oR2V0VmFsdWUoY29uZmlnLCAnZWFzZScsIGRlZmF1bHRzLmVhc2UpLCBkZWZhdWx0cy5lYXNlUGFyYW1zKTtcclxuICAgIGRlZmF1bHRzLmhvbGQgPSBHZXROZXdWYWx1ZShjb25maWcsICdob2xkJywgZGVmYXVsdHMuaG9sZCk7XHJcbiAgICBkZWZhdWx0cy5yZXBlYXQgPSBHZXROZXdWYWx1ZShjb25maWcsICdyZXBlYXQnLCBkZWZhdWx0cy5yZXBlYXQpO1xyXG4gICAgZGVmYXVsdHMucmVwZWF0RGVsYXkgPSBHZXROZXdWYWx1ZShjb25maWcsICdyZXBlYXREZWxheScsIGRlZmF1bHRzLnJlcGVhdERlbGF5KTtcclxuICAgIGRlZmF1bHRzLnlveW8gPSBHZXRCb29sZWFuKGNvbmZpZywgJ3lveW8nLCBkZWZhdWx0cy55b3lvKTtcclxuICAgIGRlZmF1bHRzLmZsaXBYID0gR2V0Qm9vbGVhbihjb25maWcsICdmbGlwWCcsIGRlZmF1bHRzLmZsaXBYKTtcclxuICAgIGRlZmF1bHRzLmZsaXBZID0gR2V0Qm9vbGVhbihjb25maWcsICdmbGlwWScsIGRlZmF1bHRzLmZsaXBZKTtcclxuXHJcbiAgICAvLyAgQ3JlYXRlIHRoZSBUd2VlbnNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHdlZW5zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHRpbWVsaW5lLnF1ZXVlKFR3ZWVuQnVpbGRlcih0aW1lbGluZSwgdHdlZW5zW2ldLCBkZWZhdWx0cykpO1xyXG4gICAgfVxyXG5cclxuICAgIHRpbWVsaW5lLmNvbXBsZXRlRGVsYXkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2NvbXBsZXRlRGVsYXknLCAwKTtcclxuICAgIHRpbWVsaW5lLmxvb3AgPSBNYXRoLnJvdW5kKEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnbG9vcCcsIDApKTtcclxuICAgIHRpbWVsaW5lLmxvb3BEZWxheSA9IE1hdGgucm91bmQoR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdsb29wRGVsYXknLCAwKSk7XHJcbiAgICB0aW1lbGluZS5wYXVzZWQgPSBHZXRCb29sZWFuKGNvbmZpZywgJ3BhdXNlZCcsIGZhbHNlKTtcclxuICAgIHRpbWVsaW5lLnVzZUZyYW1lcyA9IEdldEJvb2xlYW4oY29uZmlnLCAndXNlRnJhbWVzJywgZmFsc2UpO1xyXG5cclxuICAgIC8vICBDYWxsYmFja3NcclxuXHJcbiAgICB2YXIgc2NvcGUgPSBHZXRWYWx1ZShjb25maWcsICdjYWxsYmFja1Njb3BlJywgdGltZWxpbmUpO1xyXG5cclxuICAgIHZhciB0aW1lbGluZUFycmF5ID0gWyB0aW1lbGluZSBdO1xyXG5cclxuICAgIHZhciBvblN0YXJ0ID0gR2V0VmFsdWUoY29uZmlnLCAnb25TdGFydCcsIGZhbHNlKTtcclxuXHJcbiAgICAvLyAgVGhlIFN0YXJ0IG9mIHRoZSBUaW1lbGluZVxyXG4gICAgaWYgKG9uU3RhcnQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG9uU3RhcnRTY29wZSA9IEdldFZhbHVlKGNvbmZpZywgJ29uU3RhcnRTY29wZScsIHNjb3BlKTtcclxuICAgICAgICB2YXIgb25TdGFydFBhcmFtcyA9IEdldFZhbHVlKGNvbmZpZywgJ29uU3RhcnRQYXJhbXMnLCBbXSk7XHJcblxyXG4gICAgICAgIHRpbWVsaW5lLnNldENhbGxiYWNrKCdvblN0YXJ0Jywgb25TdGFydCwgdGltZWxpbmVBcnJheS5jb25jYXQob25TdGFydFBhcmFtcyksIG9uU3RhcnRTY29wZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9uVXBkYXRlID0gR2V0VmFsdWUoY29uZmlnLCAnb25VcGRhdGUnLCBmYWxzZSk7XHJcblxyXG4gICAgLy8gIEV2ZXJ5IHRpbWUgdGhlIFRpbWVsaW5lIHVwZGF0ZXMgKHJlZ2FyZGxlc3Mgd2hpY2ggVHdlZW5zIGFyZSBydW5uaW5nKVxyXG4gICAgaWYgKG9uVXBkYXRlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvblVwZGF0ZVNjb3BlID0gR2V0VmFsdWUoY29uZmlnLCAnb25VcGRhdGVTY29wZScsIHNjb3BlKTtcclxuICAgICAgICB2YXIgb25VcGRhdGVQYXJhbXMgPSBHZXRWYWx1ZShjb25maWcsICdvblVwZGF0ZVBhcmFtcycsIFtdKTtcclxuXHJcbiAgICAgICAgdGltZWxpbmUuc2V0Q2FsbGJhY2soJ29uVXBkYXRlJywgb25VcGRhdGUsIHRpbWVsaW5lQXJyYXkuY29uY2F0KG9uVXBkYXRlUGFyYW1zKSwgb25VcGRhdGVTY29wZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9uTG9vcCA9IEdldFZhbHVlKGNvbmZpZywgJ29uTG9vcCcsIGZhbHNlKTtcclxuXHJcbiAgICAvLyAgQ2FsbGVkIHdoZW4gdGhlIHdob2xlIFRpbWVsaW5lIGxvb3BzXHJcbiAgICBpZiAob25Mb29wKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvbkxvb3BTY29wZSA9IEdldFZhbHVlKGNvbmZpZywgJ29uTG9vcFNjb3BlJywgc2NvcGUpO1xyXG4gICAgICAgIHZhciBvbkxvb3BQYXJhbXMgPSBHZXRWYWx1ZShjb25maWcsICdvbkxvb3BQYXJhbXMnLCBbXSk7XHJcblxyXG4gICAgICAgIHRpbWVsaW5lLnNldENhbGxiYWNrKCdvbkxvb3AnLCBvbkxvb3AsIHRpbWVsaW5lQXJyYXkuY29uY2F0KG9uTG9vcFBhcmFtcyksIG9uTG9vcFNjb3BlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb25Zb3lvID0gR2V0VmFsdWUoY29uZmlnLCAnb25Zb3lvJywgZmFsc2UpO1xyXG5cclxuICAgIC8vICBDYWxsZWQgd2hlbiBhIFRpbWVsaW5lIHlveW9zXHJcbiAgICBpZiAob25Zb3lvKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvbllveW9TY29wZSA9IEdldFZhbHVlKGNvbmZpZywgJ29uWW95b1Njb3BlJywgc2NvcGUpO1xyXG4gICAgICAgIHZhciBvbllveW9QYXJhbXMgPSBHZXRWYWx1ZShjb25maWcsICdvbllveW9QYXJhbXMnLCBbXSk7XHJcblxyXG4gICAgICAgIHRpbWVsaW5lLnNldENhbGxiYWNrKCdvbllveW8nLCBvbllveW8sIHRpbWVsaW5lQXJyYXkuY29uY2F0KG51bGwsIG9uWW95b1BhcmFtcyksIG9uWW95b1Njb3BlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb25Db21wbGV0ZSA9IEdldFZhbHVlKGNvbmZpZywgJ29uQ29tcGxldGUnLCBmYWxzZSk7XHJcblxyXG4gICAgLy8gIENhbGxlZCB3aGVuIHRoZSBUaW1lbGluZSBjb21wbGV0ZXMsIGFmdGVyIHRoZSBjb21wbGV0ZURlbGF5LCBldGMuXHJcbiAgICBpZiAob25Db21wbGV0ZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgb25Db21wbGV0ZVNjb3BlID0gR2V0VmFsdWUoY29uZmlnLCAnb25Db21wbGV0ZVNjb3BlJywgc2NvcGUpO1xyXG4gICAgICAgIHZhciBvbkNvbXBsZXRlUGFyYW1zID0gR2V0VmFsdWUoY29uZmlnLCAnb25Db21wbGV0ZVBhcmFtcycsIFtdKTtcclxuXHJcbiAgICAgICAgdGltZWxpbmUuc2V0Q2FsbGJhY2soJ29uQ29tcGxldGUnLCBvbkNvbXBsZXRlLCB0aW1lbGluZUFycmF5LmNvbmNhdChvbkNvbXBsZXRlUGFyYW1zKSwgb25Db21wbGV0ZVNjb3BlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGltZWxpbmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVsaW5lQnVpbGRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9idWlsZGVyL1RpbWVsaW5lQnVpbGRlci5qc1xuLy8gbW9kdWxlIGlkID0gOTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgVGltZWxpbmVCdWlsZGVyID0gcmVxdWlyZSgnLi4vYnVpbGRlci9UaW1lbGluZUJ1aWxkZXInKTtcclxudmFyIFR3ZWVuQnVpbGRlciA9IHJlcXVpcmUoJy4uL2J1aWxkZXIvVHdlZW5CdWlsZGVyJyk7XHJcbnZhciBUV0VFTl9DT05TVCA9IHJlcXVpcmUoJy4uL3R3ZWVuL2NvbnN0Jyk7XHJcblxyXG52YXIgVHdlZW5NYW5hZ2VyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFR3ZWVuTWFuYWdlciAoc2NlbmUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRoZSBTY2VuZSB0aGUgVHdlZW4gTWFuYWdlciBiZWxvbmdzIHRvICh0d2VlbnMgYXJlIFNjZW5lIHNwZWNpZmljLCBub3QgR2FtZSBnbG9iYWwpXHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuICAgICAgICB0aGlzLnRpbWVTY2FsZSA9IDE7XHJcblxyXG4gICAgICAgIHRoaXMuX2FkZCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmcgPSBbXTtcclxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBbXTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95ID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuX3RvUHJvY2VzcyA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBTY2VuZSBpcyBzdGFydGluZyB1cFxyXG4gICAgYm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRpbWVTY2FsZSA9IDE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDcmVhdGUgYSBUd2VlbiBUaW1lbGluZSBhbmQgcmV0dXJuIGl0LCBidXQgZG8gTk9UIGFkZCBpdCB0byB0aGUgYWN0aXZlIG9yIHBlbmRpbmcgVHdlZW4gbGlzdHNcclxuICAgIGNyZWF0ZVRpbWVsaW5lOiBmdW5jdGlvbiAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBUaW1lbGluZUJ1aWxkZXIodGhpcywgY29uZmlnKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENyZWF0ZSBhIFR3ZWVuIFRpbWVsaW5lIGFuZCBhZGQgaXQgdG8gdGhlIGFjdGl2ZSBUd2VlbiBsaXN0XHJcbiAgICB0aW1lbGluZTogZnVuY3Rpb24gKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB2YXIgdGltZWxpbmUgPSBUaW1lbGluZUJ1aWxkZXIodGhpcywgY29uZmlnKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aW1lbGluZS5wYXVzZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGQucHVzaCh0aW1lbGluZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90b1Byb2Nlc3MrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aW1lbGluZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENyZWF0ZSBhIFR3ZWVuIGFuZCByZXR1cm4gaXQsIGJ1dCBkbyBOT1QgYWRkIGl0IHRvIHRoZSBhY3RpdmUgb3IgcGVuZGluZyBUd2VlbiBsaXN0c1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBUd2VlbkJ1aWxkZXIodGhpcywgY29uZmlnKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENyZWF0ZSBhIFR3ZWVuIGFuZCBhZGQgaXQgdG8gdGhlIGFjdGl2ZSBUd2VlbiBsaXN0XHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHR3ZWVuID0gVHdlZW5CdWlsZGVyKHRoaXMsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgIHRoaXMuX2FkZC5wdXNoKHR3ZWVuKTtcclxuXHJcbiAgICAgICAgdGhpcy5fdG9Qcm9jZXNzKys7XHJcblxyXG4gICAgICAgIHJldHVybiB0d2VlbjtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEFkZCBhbiBleGlzdGluZyB0d2VlbiBpbnRvIHRoZSBhY3RpdmUgVHdlZW4gbGlzdFxyXG4gICAgZXhpc3Rpbmc6IGZ1bmN0aW9uICh0d2VlbilcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9hZGQucHVzaCh0d2Vlbik7XHJcblxyXG4gICAgICAgIHRoaXMuX3RvUHJvY2VzcysrO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgYmVnaW46IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RvUHJvY2VzcyA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBRdWljayBiYWlsXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fZGVzdHJveTtcclxuICAgICAgICB2YXIgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB0d2VlbjtcclxuXHJcbiAgICAgICAgLy8gIENsZWFyIHRoZSAnZGVzdHJveScgbGlzdFxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHdlZW4gPSBsaXN0W2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gIFJlbW92ZSBmcm9tIHRoZSAnYWN0aXZlJyBhcnJheVxyXG4gICAgICAgICAgICB2YXIgaWR4ID0gYWN0aXZlLmluZGV4T2YodHdlZW4pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR3ZWVuLnN0YXRlID0gVFdFRU5fQ09OU1QuUkVNT1ZFRDtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZS5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGlzdC5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAvLyAgUHJvY2VzcyB0aGUgYWRkaXRpb24gbGlzdFxyXG4gICAgICAgIC8vICBUaGlzIHN0b3BzIGNhbGxiYWNrcyBhbmQgb3V0IG9mIHN5bmMgZXZlbnRzIGZyb20gcG9wdWxhdGluZyB0aGUgYWN0aXZlIGFycmF5IG1pZC13YXkgZHVyaW5nIHRoZSB1cGRhdGVcclxuXHJcbiAgICAgICAgbGlzdCA9IHRoaXMuX2FkZDtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0d2VlbiA9IGxpc3RbaV07XHJcblxyXG4gICAgICAgICAgICAvLyAgUmV0dXJuIHRydWUgaWYgdGhlIFR3ZWVuIHNob3VsZCBiZSBzdGFydGVkIHJpZ2h0IGF3YXksIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICAgICAgICBpZiAodHdlZW4uaW5pdCgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0d2Vlbi5wbGF5KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlLnB1c2godHdlZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZy5wdXNoKHR3ZWVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGlzdC5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICB0aGlzLl90b1Byb2Nlc3MgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICh0aW1lc3RhbXAsIGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBQcm9jZXNzIGFjdGl2ZSB0d2VlbnNcclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2FjdGl2ZTtcclxuICAgICAgICB2YXIgdHdlZW47XHJcblxyXG4gICAgICAgIC8vICBTY2FsZSB0aGUgZGVsdGFcclxuICAgICAgICBkZWx0YSAqPSB0aGlzLnRpbWVTY2FsZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHdlZW4gPSBsaXN0W2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gIElmIFR3ZWVuLnVwZGF0ZSByZXR1cm5zICd0cnVlJyB0aGVuIGl0IG1lYW5zIGl0IGhhcyBjb21wbGV0ZWQsXHJcbiAgICAgICAgICAgIC8vICBzbyBtb3ZlIGl0IHRvIHRoZSBkZXN0cm95IGxpc3RcclxuICAgICAgICAgICAgaWYgKHR3ZWVuLnVwZGF0ZSh0aW1lc3RhbXAsIGRlbHRhKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveS5wdXNoKHR3ZWVuKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvUHJvY2VzcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlQWN0aXZlOiBmdW5jdGlvbiAodHdlZW4pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FkZC5pbmRleE9mKHR3ZWVuKSAhPT0gLTEgfHwgdGhpcy5fYWN0aXZlLmluZGV4T2YodHdlZW4pICE9PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLl9wZW5kaW5nLmluZGV4T2YodHdlZW4pO1xyXG5cclxuICAgICAgICBpZiAoaWR4ICE9PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9hZGQucHVzaCh0d2Vlbik7XHJcblxyXG4gICAgICAgIHR3ZWVuLnN0YXRlID0gVFdFRU5fQ09OU1QuUEVORElOR19BREQ7XHJcblxyXG4gICAgICAgIHRoaXMuX3RvUHJvY2VzcysrO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0R2xvYmFsVGltZVNjYWxlOiByZXF1aXJlKCcuL2luYy9TZXRHbG9iYWxUaW1lU2NhbGUnKSxcclxuICAgIGdldEdsb2JhbFRpbWVTY2FsZTogcmVxdWlyZSgnLi9pbmMvR2V0R2xvYmFsVGltZVNjYWxlJyksXHJcbiAgICBnZXRBbGxUd2VlbnM6IHJlcXVpcmUoJy4vaW5jL0dldEFsbFR3ZWVucycpLFxyXG4gICAgZ2V0VHdlZW5zT2Y6IHJlcXVpcmUoJy4vaW5jL0dldFR3ZWVuc09mJyksXHJcbiAgICBpc1R3ZWVuaW5nOiByZXF1aXJlKCcuL2luYy9Jc1R3ZWVuaW5nJyksXHJcbiAgICBraWxsQWxsOiByZXF1aXJlKCcuL2luYy9LaWxsQWxsJyksXHJcbiAgICBraWxsVHdlZW5zT2Y6IHJlcXVpcmUoJy4vaW5jL0tpbGxUd2VlbnNPZicpLFxyXG4gICAgcGF1c2VBbGw6IHJlcXVpcmUoJy4vaW5jL1BhdXNlQWxsJyksXHJcbiAgICByZXN1bWVBbGw6IHJlcXVpcmUoJy4vaW5jL1Jlc3VtZUFsbCcpLFxyXG4gICAgZWFjaDogcmVxdWlyZSgnLi9pbmMvRWFjaCcpLFxyXG4gICAgc2h1dGRvd246IHJlcXVpcmUoJy4vaW5jL1NodXRkb3duJyksXHJcbiAgICBkZXN0cm95OiByZXF1aXJlKCcuL2luYy9EZXN0cm95JylcclxuXHJcbiAgICAvLyBUT0RPOiBraWxsOiBmdW5jdGlvbiAodmFycywgdGFyZ2V0KVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHdlZW5NYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL21hbmFnZXIvVHdlZW5NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5OTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEdhbWUgbGV2ZWwgbnVrZVxyXG52YXIgRGVzdHJveSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuc2h1dGRvd24oKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGVzdHJveTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9tYW5hZ2VyL2luYy9EZXN0cm95LmpzXG4vLyBtb2R1bGUgaWQgPSA5OTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogUGFzc2VzIGFsbCBUd2VlbnMgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxyXG4qXHJcbiogQG1ldGhvZCBlYWNoXHJcbiogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cclxuKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuKiBAcGFyYW0gey4uLip9IFthcmd1bWVudHNdIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIGFmdGVyIHRoZSBjaGlsZC5cclxuKi9cclxudmFyIEVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpXHJcbntcclxuICAgIHZhciBhcmdzID0gWyBudWxsIF07XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgdGV4dHVyZSBpbiB0aGlzLmxpc3QpXHJcbiAgICB7XHJcbiAgICAgICAgYXJnc1swXSA9IHRoaXMubGlzdFt0ZXh0dXJlXTtcclxuXHJcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVhY2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vbWFuYWdlci9pbmMvRWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gOTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRBbGxUd2VlbnMgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2FjdGl2ZTtcclxuICAgIHZhciBvdXRwdXQgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LnB1c2gobGlzdFtpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0QWxsVHdlZW5zO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL21hbmFnZXIvaW5jL0dldEFsbFR3ZWVucy5qc1xuLy8gbW9kdWxlIGlkID0gOTk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRHbG9iYWxUaW1lU2NhbGUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy50aW1lU2NhbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEdsb2JhbFRpbWVTY2FsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9tYW5hZ2VyL2luYy9HZXRHbG9iYWxUaW1lU2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IDk5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgU2luZ2xlIFRhcmdldCBvciBhbiBBcnJheSBvZiB0YXJnZXRzXHJcbnZhciBHZXRUd2VlbnNPZiA9IGZ1bmN0aW9uICh0YXJnZXQpXHJcbntcclxuICAgIHZhciBsaXN0ID0gdGhpcy5fYWN0aXZlO1xyXG4gICAgdmFyIHR3ZWVuO1xyXG4gICAgdmFyIG91dHB1dCA9IFtdO1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuID0gbGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGFyZ2V0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHdlZW4uaGFzVGFyZ2V0KHRhcmdldFt0XSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godHdlZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHdlZW4gPSBsaXN0W2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR3ZWVuLmhhc1RhcmdldCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh0d2Vlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VHdlZW5zT2Y7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vbWFuYWdlci9pbmMvR2V0VHdlZW5zT2YuanNcbi8vIG1vZHVsZSBpZCA9IDk5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgU2luZ2xlIFRhcmdldCBvbmx5XHJcbnZhciBJc1R3ZWVuaW5nID0gZnVuY3Rpb24gKHRhcmdldClcclxue1xyXG4gICAgdmFyIGxpc3QgPSB0aGlzLl9hY3RpdmU7XHJcbiAgICB2YXIgdHdlZW47XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHR3ZWVuID0gbGlzdFtpXTtcclxuXHJcbiAgICAgICAgaWYgKHR3ZWVuLmhhc1RhcmdldCh0YXJnZXQpICYmIHR3ZWVuLmlzUGxheWluZygpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXNUd2VlbmluZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9tYW5hZ2VyL2luYy9Jc1R3ZWVuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA5OTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEtpbGxBbGwgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgdHdlZW5zID0gdGhpcy5nZXRBbGxUd2VlbnMoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR3ZWVucy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB0d2VlbnNbaV0uc3RvcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBLaWxsQWxsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL21hbmFnZXIvaW5jL0tpbGxBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDk5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgU2luZ2xlIFRhcmdldCBvciBhbiBBcnJheSBvZiB0YXJnZXRzXHJcbnZhciBLaWxsVHdlZW5zT2YgPSBmdW5jdGlvbiAodGFyZ2V0KVxyXG57XHJcbiAgICB2YXIgdHdlZW5zID0gdGhpcy5nZXRUd2VlbnNPZih0YXJnZXQpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHdlZW5zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHR3ZWVuc1tpXS5zdG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtpbGxUd2VlbnNPZjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9tYW5hZ2VyL2luYy9LaWxsVHdlZW5zT2YuanNcbi8vIG1vZHVsZSBpZCA9IDk5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF1c2VBbGwgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2FjdGl2ZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgbGlzdFtpXS5wYXVzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXVzZUFsbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9tYW5hZ2VyL2luYy9QYXVzZUFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTAwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVzdW1lQWxsID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIGxpc3QgPSB0aGlzLl9hY3RpdmU7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGxpc3RbaV0ucmVzdW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VtZUFsbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9tYW5hZ2VyL2luYy9SZXN1bWVBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDEwMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldEdsb2JhbFRpbWVTY2FsZSA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgdGhpcy50aW1lU2NhbGUgPSB2YWx1ZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0R2xvYmFsVGltZVNjYWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL21hbmFnZXIvaW5jL1NldEdsb2JhbFRpbWVTY2FsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgU2NlbmUgdGhhdCBvd25zIHRoaXMgbWFuYWdlciBpcyBzaHV0dGluZyBkb3duXHJcbnZhciBTaHV0ZG93biA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMua2lsbEFsbCgpO1xyXG5cclxuICAgIHRoaXMuX2FkZCA9IFtdO1xyXG4gICAgdGhpcy5fcGVuZGluZyA9IFtdO1xyXG4gICAgdGhpcy5fYWN0aXZlID0gW107XHJcbiAgICB0aGlzLl9kZXN0cm95ID0gW107XHJcblxyXG4gICAgdGhpcy5fdG9Qcm9jZXNzID0gMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2h1dGRvd247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vbWFuYWdlci9pbmMvU2h1dGRvd24uanNcbi8vIG1vZHVsZSBpZCA9IDEwMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIFR3ZWVuQnVpbGRlciA9IHJlcXVpcmUoJy4uL2J1aWxkZXIvVHdlZW5CdWlsZGVyJyk7XHJcbnZhciBUV0VFTl9DT05TVCA9IHJlcXVpcmUoJy4uL3R3ZWVuL2NvbnN0Jyk7XHJcblxyXG52YXIgVGltZWxpbmUgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gVGltZWxpbmUgKG1hbmFnZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuXHJcbiAgICAgICAgdGhpcy5pc1RpbWVsaW5lID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gIEFuIGFycmF5IG9mIFR3ZWVuIG9iamVjdHMsIGVhY2ggY29udGFpbmluZyBhIHVuaXF1ZSBwcm9wZXJ0eSBhbmQgdGFyZ2V0IGJlaW5nIHR3ZWVuZWQuXHJcbiAgICAgICAgdGhpcy5kYXRhID0gW107XHJcblxyXG4gICAgICAgIC8vICBkYXRhIGFycmF5IGRvZXNuJ3QgdXN1YWxseSBjaGFuZ2UsIHNvIHdlIGNhbiBjYWNoZSB0aGUgbGVuZ3RoXHJcbiAgICAgICAgdGhpcy50b3RhbERhdGEgPSAwO1xyXG5cclxuICAgICAgICAvLyAgSWYgdHJ1ZSB0aGVuIGR1cmF0aW9uLCBkZWxheSwgZXRjIHZhbHVlcyBhcmUgYWxsIGZyYW1lIHRvdGFsc1xyXG4gICAgICAgIHRoaXMudXNlRnJhbWVzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vICBTY2FsZXMgdGhlIHRpbWUgYXBwbGllZCB0byB0aGlzIFR3ZWVuLiBBIHZhbHVlIG9mIDEgcnVucyBpbiByZWFsLXRpbWUuIEEgdmFsdWUgb2YgMC41IHJ1bnMgNTAlIHNsb3dlciwgYW5kIHNvIG9uLlxyXG4gICAgICAgIC8vICBWYWx1ZSBpc24ndCB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdG90YWwgZHVyYXRpb24gb2YgdGhlIHR3ZWVuLCBpdCdzIGEgcnVuLXRpbWUgZGVsdGEgYWRqdXN0bWVudCBvbmx5LlxyXG4gICAgICAgIHRoaXMudGltZVNjYWxlID0gMTtcclxuXHJcbiAgICAgICAgLy8gIExvb3AgdGhpcyB0d2Vlbj8gQ2FuIGJlIC0xIGZvciBhbiBpbmZpbml0ZSBsb29wLCBvciBhbiBpbnRlZ2VyLlxyXG4gICAgICAgIC8vICBXaGVuIGVuYWJsZWQgaXQgd2lsbCBwbGF5IHRocm91Z2ggQUxMIFR3ZWVuRGF0YXMgYWdhaW4gKHVzZSBUd2VlbkRhdGEucmVwZWF0IHRvIGxvb3AgYSBzaW5nbGUgVEQpXHJcbiAgICAgICAgdGhpcy5sb29wID0gMDtcclxuXHJcbiAgICAgICAgLy8gIFRpbWUgaW4gbXMvZnJhbWVzIGJlZm9yZSB0aGUgdHdlZW4gbG9vcHMuXHJcbiAgICAgICAgdGhpcy5sb29wRGVsYXkgPSAwO1xyXG5cclxuICAgICAgICAvLyAgSG93IG1hbnkgbG9vcHMgYXJlIGxlZnQgdG8gcnVuP1xyXG4gICAgICAgIHRoaXMubG9vcENvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICAvLyAgVGltZSBpbiBtcy9mcmFtZXMgYmVmb3JlIHRoZSAnb25Db21wbGV0ZScgZXZlbnQgZmlyZXMuIFRoaXMgbmV2ZXIgZmlyZXMgaWYgbG9vcCA9IHRydWUgKGFzIGl0IG5ldmVyIGNvbXBsZXRlcylcclxuICAgICAgICB0aGlzLmNvbXBsZXRlRGVsYXkgPSAwO1xyXG5cclxuICAgICAgICAvLyAgQ291bnRkb3duIHRpbWVyICh1c2VkIGJ5IGxvb3BEZWxheSBhbmQgY29tcGxldGVEZWxheSlcclxuICAgICAgICB0aGlzLmNvdW50ZG93biA9IDA7XHJcblxyXG4gICAgICAgIC8vICBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdHdlZW5cclxuICAgICAgICB0aGlzLnN0YXRlID0gVFdFRU5fQ09OU1QuUEVORElOR19BREQ7XHJcblxyXG4gICAgICAgIC8vICBUaGUgc3RhdGUgb2YgdGhlIHR3ZWVuIHdoZW4gaXQgd2FzIHBhdXNlZCAodXNlZCBieSBSZXN1bWUpXHJcbiAgICAgICAgdGhpcy5fcGF1c2VkU3RhdGUgPSBUV0VFTl9DT05TVC5QRU5ESU5HX0FERDtcclxuXHJcbiAgICAgICAgLy8gIERvZXMgdGhlIFR3ZWVuIHN0YXJ0IG9mZiBwYXVzZWQ/IChpZiBzbyBpdCBuZWVkcyB0byBiZSBzdGFydGVkIHdpdGggVHdlZW4ucGxheSlcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyAgRWxhcHNlZCB0aW1lIGluIG1zL2ZyYW1lcyBvZiB0aGlzIHJ1biB0aHJvdWdoIHRoZSBUd2Vlbi5cclxuICAgICAgICB0aGlzLmVsYXBzZWQgPSAwO1xyXG5cclxuICAgICAgICAvLyAgVG90YWwgZWxhcHNlZCB0aW1lIGluIG1zL2ZyYW1lcyBvZiB0aGUgZW50aXJlIFR3ZWVuLCBpbmNsdWRpbmcgbG9vcGluZy5cclxuICAgICAgICB0aGlzLnRvdGFsRWxhcHNlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vICBUaW1lIGluIG1zL2ZyYW1lcyBmb3IgdGhlIHdob2xlIFR3ZWVuIHRvIHBsYXkgdGhyb3VnaCBvbmNlLCBleGNsdWRpbmcgbG9vcCBhbW91bnRzIGFuZCBsb29wIGRlbGF5c1xyXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xyXG5cclxuICAgICAgICAvLyAgVmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBUaGUgYW1vdW50IHRocm91Z2ggdGhlIFR3ZWVuLCBleGNsdWRpbmcgbG9vcHMuXHJcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XHJcblxyXG4gICAgICAgIC8vICBUaW1lIGluIG1zL2ZyYW1lcyBmb3IgYWxsIFR3ZWVucyB0byBjb21wbGV0ZSAoaW5jbHVkaW5nIGxvb3BpbmcpXHJcbiAgICAgICAgdGhpcy50b3RhbER1cmF0aW9uID0gMDtcclxuXHJcbiAgICAgICAgLy8gIFZhbHVlIGJldHdlZW4gMCBhbmQgMS4gVGhlIGFtb3VudCB0aHJvdWdoIHRoZSBlbnRpcmUgVHdlZW4sIGluY2x1ZGluZyBsb29waW5nLlxyXG4gICAgICAgIHRoaXMudG90YWxQcm9ncmVzcyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0ge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBudWxsLFxyXG4gICAgICAgICAgICBvbkxvb3A6IG51bGwsXHJcbiAgICAgICAgICAgIG9uU3RhcnQ6IG51bGwsXHJcbiAgICAgICAgICAgIG9uVXBkYXRlOiBudWxsLFxyXG4gICAgICAgICAgICBvbllveW86IG51bGxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrU2NvcGU7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRpbWVTY2FsZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGltZVNjYWxlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUaW1lU2NhbGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZVNjYWxlO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc1BsYXlpbmc6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlID09PSBUV0VFTl9DT05TVC5BQ1RJVkUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUoVHdlZW5CdWlsZGVyKHRoaXMsIGNvbmZpZykpO1xyXG4gICAgfSxcclxuXHJcbiAgICBxdWV1ZTogZnVuY3Rpb24gKHR3ZWVuKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1BsYXlpbmcoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHR3ZWVuLnBhcmVudElzVGltZWxpbmUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2godHdlZW4pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50b3RhbERhdGEgPSB0aGlzLmRhdGEubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhc09mZnNldDogZnVuY3Rpb24gKHR3ZWVuKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodHdlZW4ub2Zmc2V0ICE9PSBudWxsKTtcclxuICAgIH0sXHJcblxyXG4gICAgaXNPZmZzZXRBYnNvbHV0ZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodHlwZW9mKHZhbHVlKSA9PT0gJ251bWJlcicpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc09mZnNldFJlbGF0aXZlOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHQgPSB0eXBlb2YodmFsdWUpO1xyXG5cclxuICAgICAgICBpZiAodCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgb3AgPSB2YWx1ZVswXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcCA9PT0gJy0nIHx8IG9wID09PSAnKycpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFJlbGF0aXZlT2Zmc2V0OiBmdW5jdGlvbiAodmFsdWUsIGJhc2UpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG9wID0gdmFsdWVbMF07XHJcbiAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gYmFzZTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChvcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgJysnOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG51bTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnLSc6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgLT0gbnVtO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQ2Fubm90IGV2ZXIgYmUgPCAwXHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIHJlc3VsdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNhbGNEdXJhdGlvbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgcHJldkVuZCA9IDA7XHJcbiAgICAgICAgdmFyIHRvdGFsRHVyYXRpb24gPSAwO1xyXG4gICAgICAgIHZhciBvZmZzZXREdXJhdGlvbiA9IDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50b3RhbERhdGE7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0d2VlbiA9IHRoaXMuZGF0YVtpXTtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuLmluaXQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc09mZnNldCh0d2VlbikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT2Zmc2V0QWJzb2x1dGUodHdlZW4ub2Zmc2V0KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgQW4gYWN0dWFsIG51bWJlciwgc28gaXQgZGVmaW5lcyB0aGUgc3RhcnQgcG9pbnQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuLmNhbGN1bGF0ZWRPZmZzZXQgPSB0d2Vlbi5vZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0d2Vlbi5vZmZzZXQgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXREdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVGltZWxpbmUuY2FsY0R1cmF0aW9uJywgaSwgJ2Fic29sdXRlJywgdHdlZW4uY2FsY3VsYXRlZE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzT2Zmc2V0UmVsYXRpdmUodHdlZW4ub2Zmc2V0KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgQSByZWxhdGl2ZSBvZmZzZXQgKGkuZS4gJy09MTAwMCcsIHNvIHN0YXJ0cyBhdCAnb2Zmc2V0JyBtcyByZWxhdGl2ZSB0byB0aGUgUFJFVklPVVMgVHdlZW5zIGVuZGluZyB0aW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuLmNhbGN1bGF0ZWRPZmZzZXQgPSB0aGlzLmdldFJlbGF0aXZlT2Zmc2V0KHR3ZWVuLm9mZnNldCwgcHJldkVuZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdUaW1lbGluZS5jYWxjRHVyYXRpb24nLCBpLCAncmVsYXRpdmUnLCB0d2Vlbi5jYWxjdWxhdGVkT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBTZXF1ZW50aWFsXHJcbiAgICAgICAgICAgICAgICB0d2Vlbi5jYWxjdWxhdGVkT2Zmc2V0ID0gb2Zmc2V0RHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdUaW1lbGluZS5jYWxjRHVyYXRpb24nLCBpLCAnc2VxdWVudGlhbCcsIHR3ZWVuLmNhbGN1bGF0ZWRPZmZzZXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmV2RW5kID0gdHdlZW4udG90YWxEdXJhdGlvbiArIHR3ZWVuLmNhbGN1bGF0ZWRPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU3BhbicsIGksIHR3ZWVuLmNhbGN1bGF0ZWRPZmZzZXQsICd0bycsIHByZXZFbmQpO1xyXG5cclxuICAgICAgICAgICAgdG90YWxEdXJhdGlvbiArPSB0d2Vlbi50b3RhbER1cmF0aW9uO1xyXG4gICAgICAgICAgICBvZmZzZXREdXJhdGlvbiArPSB0d2Vlbi50b3RhbER1cmF0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEV4Y2x1ZGVzIGxvb3AgdmFsdWVzXHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHRvdGFsRHVyYXRpb247XHJcblxyXG4gICAgICAgIHRoaXMubG9vcENvdW50ZXIgPSAodGhpcy5sb29wID09PSAtMSkgPyA5OTk5OTk5OTk5OTkgOiB0aGlzLmxvb3A7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxvb3BDb3VudGVyID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudG90YWxEdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24gKyB0aGlzLmNvbXBsZXRlRGVsYXkgKyAoKHRoaXMuZHVyYXRpb24gKyB0aGlzLmxvb3BEZWxheSkgKiB0aGlzLmxvb3BDb3VudGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50b3RhbER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbiArIHRoaXMuY29tcGxldGVEZWxheTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jYWxjRHVyYXRpb24oKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy50b3RhbFByb2dyZXNzID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULlBBVVNFRDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZXNldFR3ZWVuczogZnVuY3Rpb24gKHJlc2V0RnJvbUxvb3ApXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRvdGFsRGF0YTsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy5kYXRhW2ldO1xyXG5cclxuICAgICAgICAgICAgdHdlZW4ucGxheShyZXNldEZyb21Mb29wKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENhbGxiYWNrOiBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKFRpbWVsaW5lLlRZUEVTLmluZGV4T2YodHlwZSkgIT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbdHlwZV0gPSB7IGZ1bmM6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUsIHBhcmFtczogcGFyYW1zIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcGxheTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVFdFRU5fQ09OU1QuQUNUSVZFKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLm1ha2VBY3RpdmUodGhpcyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRUd2VlbnMoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULkFDVElWRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvblN0YXJ0ID0gdGhpcy5jYWxsYmFja3Mub25TdGFydDtcclxuXHJcbiAgICAgICAgaWYgKG9uU3RhcnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvblN0YXJ0LmZ1bmMuYXBwbHkob25TdGFydC5zY29wZSwgb25TdGFydC5wYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbmV4dFN0YXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmxvb3BDb3VudGVyID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBSZXNldCB0aGUgZWxhcHNlZCB0aW1lXHJcbiAgICAgICAgICAgIC8vICBUT0RPOiBQcm9iYWJseSBvdWdodCB0byBiZSBzZXQgdG8gdGhlIHJlbWFpbmRlciBmcm9tIGVsYXBzZWQgLSBkdXJhdGlvblxyXG4gICAgICAgICAgICAvLyAgYXMgdGhlIHR3ZWVucyBuZWFybHkgYWx3YXlzIG92ZXItcnVuIGJ5IGEgZmV3IG1zIGR1ZSB0byByQWZcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5sb29wQ291bnRlci0tO1xyXG5cclxuICAgICAgICAgICAgdmFyIG9uTG9vcCA9IHRoaXMuY2FsbGJhY2tzLm9uTG9vcDtcclxuXHJcbiAgICAgICAgICAgIGlmIChvbkxvb3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9uTG9vcC5mdW5jLmFwcGx5KG9uTG9vcC5zY29wZSwgb25Mb29wLnBhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRUd2VlbnModHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5sb29wRGVsYXkgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZG93biA9IHRoaXMubG9vcERlbGF5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULkxPT1BfREVMQVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gVFdFRU5fQ09OU1QuQUNUSVZFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29tcGxldGVEZWxheSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ZG93biA9IHRoaXMuY29tcGxldGVEZWxheTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULkNPTVBMRVRFX0RFTEFZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgb25Db21wbGV0ZSA9IHRoaXMuY2FsbGJhY2tzLm9uQ29tcGxldGU7XHJcblxyXG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZS5mdW5jLmFwcGx5KG9uQ29tcGxldGUuc2NvcGUsIG9uQ29tcGxldGUucGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULlBFTkRJTkdfUkVNT1ZFO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFJldHVybnMgJ3RydWUnIGlmIHRoaXMgVGltZWxpbmUgaGFzIGZpbmlzaGVkIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZSBUd2VlbiBNYW5hZ2VyXHJcbiAgICAvLyAgT3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICh0aW1lc3RhbXAsIGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBUV0VFTl9DT05TVC5QQVVTRUQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmF3RGVsdGEgPSBkZWx0YTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudXNlRnJhbWVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsdGEgPSAxICogdGhpcy5tYW5hZ2VyLnRpbWVTY2FsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlbHRhICo9IHRoaXMudGltZVNjYWxlO1xyXG5cclxuICAgICAgICB0aGlzLmVsYXBzZWQgKz0gZGVsdGE7XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IE1hdGgubWluKHRoaXMuZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24sIDEpO1xyXG5cclxuICAgICAgICB0aGlzLnRvdGFsRWxhcHNlZCArPSBkZWx0YTtcclxuICAgICAgICB0aGlzLnRvdGFsUHJvZ3Jlc3MgPSBNYXRoLm1pbih0aGlzLnRvdGFsRWxhcHNlZCAvIHRoaXMudG90YWxEdXJhdGlvbiwgMSk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgVFdFRU5fQ09OU1QuQUNUSVZFOlxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzdGlsbFJ1bm5pbmcgPSB0aGlzLnRvdGFsRGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG90YWxEYXRhOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy5kYXRhW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHdlZW4udXBkYXRlKHRpbWVzdGFtcCwgcmF3RGVsdGEpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RpbGxSdW5uaW5nLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvblVwZGF0ZSA9IHRoaXMuY2FsbGJhY2tzLm9uVXBkYXRlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvblVwZGF0ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBvblVwZGF0ZS5mdW5jLmFwcGx5KG9uVXBkYXRlLnNjb3BlLCBvblVwZGF0ZS5wYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vICBBbnl0aGluZyBzdGlsbCBydW5uaW5nPyBJZiBub3QsIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgICAgIGlmIChzdGlsbFJ1bm5pbmcgPT09IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgVFdFRU5fQ09OU1QuTE9PUF9ERUxBWTpcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZG93biAtPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudGRvd24gPD0gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gVFdFRU5fQ09OU1QuQUNUSVZFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBUV0VFTl9DT05TVC5DT01QTEVURV9ERUxBWTpcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZG93biAtPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudGRvd24gPD0gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb25Db21wbGV0ZSA9IHRoaXMuY2FsbGJhY2tzLm9uQ29tcGxldGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZS5mdW5jLmFwcGx5KG9uQ29tcGxldGUuc2NvcGUsIG9uQ29tcGxldGUucGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBUV0VFTl9DT05TVC5QRU5ESU5HX1JFTU9WRTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZSA9PT0gVFdFRU5fQ09OU1QuUEVORElOR19SRU1PVkUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU3RvcHMgdGhlIFR3ZWVuIGltbWVkaWF0ZWx5LCB3aGF0ZXZlciBzdGFnZSBvZiBwcm9ncmVzcyBpdCBpcyBhdCBhbmQgZmxhZ3MgaXQgZm9yIHJlbW92YWwgYnkgdGhlIFR3ZWVuTWFuYWdlclxyXG4gICAgc3RvcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gVFdFRU5fQ09OU1QuUEVORElOR19SRU1PVkU7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBUV0VFTl9DT05TVC5QQVVTRUQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuX3BhdXNlZFN0YXRlID0gdGhpcy5zdGF0ZTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULlBBVVNFRDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc3VtZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVFdFRU5fQ09OU1QuUEFVU0VEKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLl9wYXVzZWRTdGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXNUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXQpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldLmhhc1RhcmdldCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxuVGltZWxpbmUuVFlQRVMgPSBbICdvblN0YXJ0JywgJ29uVXBkYXRlJywgJ29uTG9vcCcsICdvbkNvbXBsZXRlJywgJ29uWW95bycgXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGltZWxpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vdGltZWxpbmUvVGltZWxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFJFU0VSVkVEIHByb3BlcnRpZXMgdGhhdCBhIFR3ZWVuIGNvbmZpZyBvYmplY3QgdXNlc1xyXG5cclxuLy8gIGNvbXBsZXRlRGVsYXk6IFRoZSB0aW1lIHRoZSB0d2VlbiB3aWxsIHdhaXQgYmVmb3JlIHRoZSBvbkNvbXBsZXRlIGV2ZW50IGlzIGRpc3BhdGNoZWQgb25jZSBpdCBoYXMgY29tcGxldGVkXHJcbi8vICBkZWxheTogVGhlIHRpbWUgdGhlIHR3ZWVuIHdpbGwgd2FpdCBiZWZvcmUgaXQgZmlyc3Qgc3RhcnRzXHJcbi8vICBkdXJhdGlvbjogVGhlIGR1cmF0aW9uIG9mIHRoZSB0d2VlblxyXG4vLyAgZWFzZTogVGhlIGVhc2UgZnVuY3Rpb24gdXNlZCBieSB0aGUgdHdlZW5cclxuLy8gIGVhc2VQYXJhbXM6IFRoZSBwYXJhbWV0ZXJzIHRvIGdvIHdpdGggdGhlIGVhc2UgZnVuY3Rpb24gKGlmIGFueSlcclxuLy8gIGhvbGQ6IFRoZSB0aW1lIHRoZSB0d2VlbiB3aWxsIHBhdXNlIGJlZm9yZSBydW5uaW5nIGEgeW95b1xyXG4vLyAgbG9vcDogVGhlIHRpbWUgdGhlIHR3ZWVuIHdpbGwgcGF1c2UgYmVmb3JlIHN0YXJ0aW5nIGVpdGhlciBhIHlveW8gb3IgcmV0dXJuaW5nIHRvIHRoZSBzdGFydCBmb3IgYSByZXBlYXRcclxuLy8gIGxvb3BEZWxheTogXHJcbi8vICBvZmZzZXQ6IFVzZWQgd2hlbiB0aGUgVHdlZW4gaXMgcGFydCBvZiBhIFRpbWVsaW5lXHJcbi8vICBwYXVzZWQ6IERvZXMgdGhlIHR3ZWVuIHN0YXJ0IGluIGEgcGF1c2VkIHN0YXRlLCBvciBwbGF5aW5nP1xyXG4vLyAgcHJvcHM6IFRoZSBwcm9wZXJ0aWVzIGJlaW5nIHR3ZWVuZWQgYnkgdGhlIHR3ZWVuXHJcbi8vICByZXBlYXQ6IFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHR3ZWVuIHdpbGwgcmVwZWF0IGl0c2VsZiAoYSB2YWx1ZSBvZiAxIG1lYW5zIHRoZSB0d2VlbiB3aWxsIHBsYXkgdHdpY2UsIGFzIGl0IHJlcGVhdGVkIG9uY2UpXHJcbi8vICByZXBlYXREZWxheTogVGhlIHRpbWUgdGhlIHR3ZWVuIHdpbGwgcGF1c2UgZm9yIGJlZm9yZSBzdGFydGluZyBhIHJlcGVhdC4gVGhlIHR3ZWVuIGhvbGRzIGluIHRoZSBzdGFydCBzdGF0ZS5cclxuLy8gIHRhcmdldHM6IFRoZSB0YXJnZXRzIHRoZSB0d2VlbiBpcyB1cGRhdGluZy5cclxuLy8gIHVzZUZyYW1lczogVXNlIGZyYW1lcyBvciBtaWxsaXNlY29uZHM/XHJcbi8vICB5b3lvOiBib29sZWFuIC0gRG9lcyB0aGUgdHdlZW4gcmV2ZXJzZSBpdHNlbGYgKHlveW8pIHdoZW4gaXQgcmVhY2hlcyB0aGUgZW5kP1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgICAnY2FsbGJhY2tTY29wZScsXHJcbiAgICAnY29tcGxldGVEZWxheScsXHJcbiAgICAnZGVsYXknLFxyXG4gICAgJ2R1cmF0aW9uJyxcclxuICAgICdlYXNlJyxcclxuICAgICdlYXNlUGFyYW1zJyxcclxuICAgICdmbGlwWCcsXHJcbiAgICAnZmxpcFknLFxyXG4gICAgJ2hvbGQnLFxyXG4gICAgJ2xvb3AnLFxyXG4gICAgJ2xvb3BEZWxheScsXHJcbiAgICAnb2Zmc2V0JyxcclxuICAgICdvbkNvbXBsZXRlJyxcclxuICAgICdvbkNvbXBsZXRlUGFyYW1zJyxcclxuICAgICdvbkNvbXBsZXRlU2NvcGUnLFxyXG4gICAgJ29uTG9vcCcsXHJcbiAgICAnb25Mb29wUGFyYW1zJyxcclxuICAgICdvbkxvb3BTY29wZScsXHJcbiAgICAnb25SZXBlYXQnLFxyXG4gICAgJ29uUmVwZWF0UGFyYW1zJyxcclxuICAgICdvblJlcGVhdFNjb3BlJyxcclxuICAgICdvblN0YXJ0JyxcclxuICAgICdvblN0YXJ0UGFyYW1zJyxcclxuICAgICdvblN0YXJ0U2NvcGUnLFxyXG4gICAgJ29uVXBkYXRlJyxcclxuICAgICdvblVwZGF0ZVBhcmFtcycsXHJcbiAgICAnb25VcGRhdGVTY29wZScsXHJcbiAgICAnb25Zb3lvJyxcclxuICAgICdvbllveW9QYXJhbXMnLFxyXG4gICAgJ29uWW95b1Njb3BlJyxcclxuICAgICdwYXVzZWQnLFxyXG4gICAgJ3Byb3BzJyxcclxuICAgICdyZXBlYXQnLFxyXG4gICAgJ3JlcGVhdERlbGF5JyxcclxuICAgICd0YXJnZXRzJyxcclxuICAgICd1c2VGcmFtZXMnLFxyXG4gICAgJ3lveW8nXHJcbl07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vdHdlZW4vUmVzZXJ2ZWRQcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gMTAwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZU9iamVjdENyZWF0b3IgPSByZXF1aXJlKCcuLi8uLi9zY2VuZS9wbHVnaW5zL0dhbWVPYmplY3RDcmVhdG9yJyk7XHJcbnZhciBHYW1lT2JqZWN0RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL3NjZW5lL3BsdWdpbnMvR2FtZU9iamVjdEZhY3RvcnknKTtcclxudmFyIFRXRUVOX0NPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIFR3ZWVuID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFR3ZWVuIChwYXJlbnQsIGRhdGEsIHRhcmdldHMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgIC8vICBJcyB0aGUgcGFyZW50IG9mIHRoaXMgVHdlZW4gYSBUaW1lbGluZT9cclxuICAgICAgICB0aGlzLnBhcmVudElzVGltZWxpbmUgPSBwYXJlbnQuaGFzT3duUHJvcGVydHkoJ2lzVGltZWxpbmUnKTtcclxuXHJcbiAgICAgICAgLy8gIEFuIGFycmF5IG9mIFR3ZWVuRGF0YSBvYmplY3RzLCBlYWNoIGNvbnRhaW5pbmcgYSB1bmlxdWUgcHJvcGVydHkgYW5kIHRhcmdldCBiZWluZyB0d2VlbmVkLlxyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgIC8vICBkYXRhIGFycmF5IGRvZXNuJ3QgY2hhbmdlLCBzbyB3ZSBjYW4gY2FjaGUgdGhlIGxlbmd0aFxyXG4gICAgICAgIHRoaXMudG90YWxEYXRhID0gZGF0YS5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vICBBbiBhcnJheSBvZiByZWZlcmVuY2VzIHRvIHRoZSB0YXJnZXQvcyB0aGlzIFR3ZWVuIGlzIG9wZXJhdGluZyBvblxyXG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IHRhcmdldHM7XHJcblxyXG4gICAgICAgIC8vICBDYWNoZWQgdGFyZ2V0IHRvdGFsIChub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgYXMgdGhlIGRhdGEgdG90YWwpXHJcbiAgICAgICAgdGhpcy50b3RhbFRhcmdldHMgPSB0YXJnZXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gIElmIHRydWUgdGhlbiBkdXJhdGlvbiwgZGVsYXksIGV0YyB2YWx1ZXMgYXJlIGFsbCBmcmFtZSB0b3RhbHNcclxuICAgICAgICB0aGlzLnVzZUZyYW1lcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyAgU2NhbGVzIHRoZSB0aW1lIGFwcGxpZWQgdG8gdGhpcyBUd2Vlbi4gQSB2YWx1ZSBvZiAxIHJ1bnMgaW4gcmVhbC10aW1lLiBBIHZhbHVlIG9mIDAuNSBydW5zIDUwJSBzbG93ZXIsIGFuZCBzbyBvbi5cclxuICAgICAgICAvLyAgVmFsdWUgaXNuJ3QgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSB0d2VlbiwgaXQncyBhIHJ1bi10aW1lIGRlbHRhIGFkanVzdG1lbnQgb25seS5cclxuICAgICAgICB0aGlzLnRpbWVTY2FsZSA9IDE7XHJcblxyXG4gICAgICAgIC8vICBMb29wIHRoaXMgdHdlZW4/IENhbiBiZSAtMSBmb3IgYW4gaW5maW5pdGUgbG9vcCwgb3IgYW4gaW50ZWdlci5cclxuICAgICAgICAvLyAgV2hlbiBlbmFibGVkIGl0IHdpbGwgcGxheSB0aHJvdWdoIEFMTCBUd2VlbkRhdGFzIGFnYWluICh1c2UgVHdlZW5EYXRhLnJlcGVhdCB0byBsb29wIGEgc2luZ2xlIFREKVxyXG4gICAgICAgIHRoaXMubG9vcCA9IDA7XHJcblxyXG4gICAgICAgIC8vICBUaW1lIGluIG1zL2ZyYW1lcyBiZWZvcmUgdGhlIHR3ZWVuIGxvb3BzLlxyXG4gICAgICAgIHRoaXMubG9vcERlbGF5ID0gMDtcclxuXHJcbiAgICAgICAgLy8gIEhvdyBtYW55IGxvb3BzIGFyZSBsZWZ0IHRvIHJ1bj9cclxuICAgICAgICB0aGlzLmxvb3BDb3VudGVyID0gMDtcclxuXHJcbiAgICAgICAgLy8gIFRpbWUgaW4gbXMvZnJhbWVzIGJlZm9yZSB0aGUgJ29uQ29tcGxldGUnIGV2ZW50IGZpcmVzLiBUaGlzIG5ldmVyIGZpcmVzIGlmIGxvb3AgPSAtMSAoYXMgaXQgbmV2ZXIgY29tcGxldGVzKVxyXG4gICAgICAgIHRoaXMuY29tcGxldGVEZWxheSA9IDA7XHJcblxyXG4gICAgICAgIC8vICBDb3VudGRvd24gdGltZXIgKHVzZWQgYnkgdGltZWxpbmUgb2Zmc2V0LCBsb29wRGVsYXkgYW5kIGNvbXBsZXRlRGVsYXkpXHJcbiAgICAgICAgdGhpcy5jb3VudGRvd24gPSAwO1xyXG5cclxuICAgICAgICAvLyAgU2V0IG9ubHkgaWYgdGhpcyBUd2VlbiBpcyBwYXJ0IG9mIGEgVGltZWxpbmUuXHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICAvLyAgU2V0IG9ubHkgaWYgdGhpcyBUd2VlbiBpcyBwYXJ0IG9mIGEgVGltZWxpbmUuIFRoZSBjYWxjdWxhdGVkIG9mZnNldCBhbW91bnQuXHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVkT2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0d2VlblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUV0VFTl9DT05TVC5QRU5ESU5HX0FERDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBzdGF0ZSBvZiB0aGUgdHdlZW4gd2hlbiBpdCB3YXMgcGF1c2VkICh1c2VkIGJ5IFJlc3VtZSlcclxuICAgICAgICB0aGlzLl9wYXVzZWRTdGF0ZSA9IFRXRUVOX0NPTlNULlBFTkRJTkdfQUREO1xyXG5cclxuICAgICAgICAvLyAgRG9lcyB0aGUgVHdlZW4gc3RhcnQgb2ZmIHBhdXNlZD8gKGlmIHNvIGl0IG5lZWRzIHRvIGJlIHN0YXJ0ZWQgd2l0aCBUd2Vlbi5wbGF5KVxyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vICBFbGFwc2VkIHRpbWUgaW4gbXMvZnJhbWVzIG9mIHRoaXMgcnVuIHRocm91Z2ggdGhlIFR3ZWVuLlxyXG4gICAgICAgIHRoaXMuZWxhcHNlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vICBUb3RhbCBlbGFwc2VkIHRpbWUgaW4gbXMvZnJhbWVzIG9mIHRoZSBlbnRpcmUgVHdlZW4sIGluY2x1ZGluZyBsb29waW5nLlxyXG4gICAgICAgIHRoaXMudG90YWxFbGFwc2VkID0gMDtcclxuXHJcbiAgICAgICAgLy8gIFRpbWUgaW4gbXMvZnJhbWVzIGZvciB0aGUgd2hvbGUgVHdlZW4gdG8gcGxheSB0aHJvdWdoIG9uY2UsIGV4Y2x1ZGluZyBsb29wIGFtb3VudHMgYW5kIGxvb3AgZGVsYXlzXHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XHJcblxyXG4gICAgICAgIC8vICBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDEuIFRoZSBhbW91bnQgdGhyb3VnaCB0aGUgVHdlZW4sIGV4Y2x1ZGluZyBsb29wcy5cclxuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcclxuXHJcbiAgICAgICAgLy8gIFRpbWUgaW4gbXMvZnJhbWVzIGZvciB0aGUgVHdlZW4gdG8gY29tcGxldGUgKGluY2x1ZGluZyBsb29waW5nKVxyXG4gICAgICAgIHRoaXMudG90YWxEdXJhdGlvbiA9IDA7XHJcblxyXG4gICAgICAgIC8vICBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDEuIFRoZSBhbW91bnQgdGhyb3VnaCB0aGUgZW50aXJlIFR3ZWVuLCBpbmNsdWRpbmcgbG9vcGluZy5cclxuICAgICAgICB0aGlzLnRvdGFsUHJvZ3Jlc3MgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgb25Db21wbGV0ZTogbnVsbCxcclxuICAgICAgICAgICAgb25Mb29wOiBudWxsLFxyXG4gICAgICAgICAgICBvblJlcGVhdDogbnVsbCxcclxuICAgICAgICAgICAgb25TdGFydDogbnVsbCxcclxuICAgICAgICAgICAgb25VcGRhdGU6IG51bGwsXHJcbiAgICAgICAgICAgIG9uWW95bzogbnVsbFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tTY29wZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGltZVNjYWxlOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50aW1lU2NhbGUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRpbWVTY2FsZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lU2NhbGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzUGxheWluZzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09IFRXRUVOX0NPTlNULkFDVElWRSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhc1RhcmdldDogZnVuY3Rpb24gKHRhcmdldClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudGFyZ2V0cy5pbmRleE9mKHRhcmdldCkgIT09IC0xKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlVG86IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBzdGFydFRvQ3VycmVudClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG90YWxEYXRhOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgdHdlZW5EYXRhID0gdGhpcy5kYXRhW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR3ZWVuRGF0YS5rZXkgPT09IGtleSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHdlZW5EYXRhLmVuZCA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydFRvQ3VycmVudClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0d2VlbkRhdGEuc3RhcnQgPSB0d2VlbkRhdGEuY3VycmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc3RhcnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgdGhpcy5wbGF5KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNhbGNEdXJhdGlvbjogcmVxdWlyZSgnLi9pbmMvQ2FsY0R1cmF0aW9uJyksXHJcbiAgICBpbml0OiByZXF1aXJlKCcuL2luYy9Jbml0JyksXHJcbiAgICBuZXh0U3RhdGU6IHJlcXVpcmUoJy4vaW5jL05leHRTdGF0ZScpLFxyXG4gICAgcGF1c2U6IHJlcXVpcmUoJy4vaW5jL1BhdXNlJyksXHJcbiAgICBwbGF5OiByZXF1aXJlKCcuL2luYy9QbGF5JyksXHJcbiAgICByZXNldFR3ZWVuRGF0YTogcmVxdWlyZSgnLi9pbmMvUmVzZXRUd2VlbkRhdGEnKSxcclxuICAgIHJlc3VtZTogcmVxdWlyZSgnLi9pbmMvUmVzdW1lJyksXHJcbiAgICBzZWVrOiByZXF1aXJlKCcuL2luYy9TZWVrJyksXHJcbiAgICBzZXRDYWxsYmFjazogcmVxdWlyZSgnLi9pbmMvU2V0Q2FsbGJhY2snKSxcclxuICAgIHN0b3A6IHJlcXVpcmUoJy4vaW5jL1N0b3AnKSxcclxuICAgIHVwZGF0ZTogcmVxdWlyZSgnLi9pbmMvVXBkYXRlJylcclxuXHJcbn0pO1xyXG5cclxuVHdlZW4uVFlQRVMgPSBbXHJcbiAgICAnb25Db21wbGV0ZScsXHJcbiAgICAnb25Mb29wJyxcclxuICAgICdvblJlcGVhdCcsXHJcbiAgICAnb25TdGFydCcsXHJcbiAgICAnb25VcGRhdGUnLFxyXG4gICAgJ29uWW95bydcclxuXTtcclxuXHJcbi8vICBXaGVuIHJlZ2lzdGVyaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiAndGhpcycgcmVmZXJzIHRvIHRoZSBHYW1lT2JqZWN0RmFjdG9yeSBjb250ZXh0LlxyXG4vLyAgXHJcbi8vICBUaGVyZSBhcmUgc2V2ZXJhbCBwcm9wZXJ0aWVzIGF2YWlsYWJsZSB0byB1c2U6XHJcbi8vICBcclxuLy8gIHRoaXMuc2NlbmUgLSBhIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhhdCBvd25zIHRoZSBHYW1lT2JqZWN0RmFjdG9yeVxyXG4vLyAgdGhpcy5kaXNwbGF5TGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBEaXNwbGF5IExpc3QgdGhlIFNjZW5lIG93bnNcclxuLy8gIHRoaXMudXBkYXRlTGlzdCAtIGEgcmVmZXJlbmNlIHRvIHRoZSBVcGRhdGUgTGlzdCB0aGUgU2NlbmUgb3duc1xyXG5cclxuR2FtZU9iamVjdEZhY3RvcnkucmVnaXN0ZXIoJ3R3ZWVuJywgZnVuY3Rpb24gKGNvbmZpZylcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuc2NlbmUuc3lzLnR3ZWVucy5hZGQoY29uZmlnKTtcclxufSk7XHJcblxyXG4vLyAgV2hlbiByZWdpc3RlcmluZyBhIGZhY3RvcnkgZnVuY3Rpb24gJ3RoaXMnIHJlZmVycyB0byB0aGUgR2FtZU9iamVjdENyZWF0b3IgY29udGV4dC5cclxuXHJcbkdhbWVPYmplY3RDcmVhdG9yLnJlZ2lzdGVyKCd0d2VlbicsIGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHJldHVybiB0aGlzLnNjZW5lLnN5cy50d2VlbnMuY3JlYXRlKGNvbmZpZyk7XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUd2VlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi90d2Vlbi9Ud2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gMTAwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVHdlZW5EYXRhID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCBnZXRFbmQsIGdldFN0YXJ0LCBlYXNlLCBkZWxheSwgZHVyYXRpb24sIHlveW8sIGhvbGQsIHJlcGVhdCwgcmVwZWF0RGVsYXksIGZsaXBYLCBmbGlwWSlcclxue1xyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgLy8gIFRoZSB0YXJnZXQgdG8gdHdlZW5cclxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuXHJcbiAgICAgICAgLy8gIFRoZSBwcm9wZXJ0eSBvZiB0aGUgdGFyZ2V0IHRvIHR3ZWVuXHJcbiAgICAgICAga2V5OiBrZXksXHJcblxyXG4gICAgICAgIC8vICBUaGUgcmV0dXJuZWQgdmFsdWUgc2V0cyB3aGF0IHRoZSBwcm9wZXJ0eSB3aWxsIGJlIGF0IHRoZSBFTkQgb2YgdGhlIFR3ZWVuLlxyXG4gICAgICAgIGdldEVuZFZhbHVlOiBnZXRFbmQsXHJcblxyXG4gICAgICAgIC8vICBUaGUgcmV0dXJuZWQgdmFsdWUgc2V0cyB3aGF0IHRoZSBwcm9wZXJ0eSB3aWxsIGJlIGF0IHRoZSBTVEFSVCBvZiB0aGUgVHdlZW4uXHJcbiAgICAgICAgZ2V0U3RhcnRWYWx1ZTogZ2V0U3RhcnQsXHJcblxyXG4gICAgICAgIC8vICBUaGUgZWFzZSBmdW5jdGlvbiB0aGlzIHR3ZWVuIHVzZXMuXHJcbiAgICAgICAgZWFzZTogZWFzZSxcclxuXHJcbiAgICAgICAgLy8gIER1cmF0aW9uIG9mIHRoZSB0d2VlbiBpbiBtcy9mcmFtZXMsIGV4Y2x1ZGVzIHRpbWUgZm9yIHlveW8gb3IgcmVwZWF0cy5cclxuICAgICAgICBkdXJhdGlvbjogMCxcclxuXHJcbiAgICAgICAgLy8gIFRoZSB0b3RhbCBjYWxjdWxhdGVkIGR1cmF0aW9uIG9mIHRoaXMgVHdlZW5EYXRhIChiYXNlZCBvbiBkdXJhdGlvbiwgcmVwZWF0LCBkZWxheSBhbmQgeW95bylcclxuICAgICAgICB0b3RhbER1cmF0aW9uOiAwLFxyXG5cclxuICAgICAgICAvLyAgVGltZSBpbiBtcy9mcmFtZXMgYmVmb3JlIHR3ZWVuIHdpbGwgc3RhcnQuXHJcbiAgICAgICAgZGVsYXk6IDAsXHJcblxyXG4gICAgICAgIC8vICBDYXVzZSB0aGUgdHdlZW4gdG8gcmV0dXJuIGJhY2sgdG8gaXRzIHN0YXJ0IHZhbHVlIGFmdGVyIGhvbGQgaGFzIGV4cGlyZWQuXHJcbiAgICAgICAgeW95bzogeW95byxcclxuXHJcbiAgICAgICAgLy8gIFRpbWUgaW4gbXMvZnJhbWVzIHRoZSB0d2VlbiB3aWxsIHBhdXNlIGJlZm9yZSBydW5uaW5nIHRoZSB5b3lvIG9yIHN0YXJ0aW5nIGEgcmVwZWF0LlxyXG4gICAgICAgIGhvbGQ6IDAsXHJcblxyXG4gICAgICAgIC8vICBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSB0d2Vlbi4gVGhlIHR3ZWVuIHdpbGwgYWx3YXlzIHJ1biBvbmNlIHJlZ2FyZGxlc3MsIHNvIGEgcmVwZWF0IHZhbHVlIG9mICcxJyB3aWxsIHBsYXkgdGhlIHR3ZWVuIHR3aWNlLlxyXG4gICAgICAgIHJlcGVhdDogMCxcclxuXHJcbiAgICAgICAgLy8gIFRpbWUgaW4gbXMvZnJhbWVzIGJlZm9yZSB0aGUgcmVwZWF0IHdpbGwgc3RhcnQuXHJcbiAgICAgICAgcmVwZWF0RGVsYXk6IDAsXHJcblxyXG4gICAgICAgIC8vICBBdXRvbWF0aWNhbGx5IGNhbGwgdG9nZ2xlRmxpcFggd2hlbiB0aGUgVHdlZW5EYXRhIHlveW9zIG9yIHJlcGVhdHNcclxuICAgICAgICBmbGlwWDogZmxpcFgsXHJcblxyXG4gICAgICAgIC8vICBBdXRvbWF0aWNhbGx5IGNhbGwgdG9nZ2xlRmxpcFkgd2hlbiB0aGUgVHdlZW5EYXRhIHlveW9zIG9yIHJlcGVhdHNcclxuICAgICAgICBmbGlwWTogZmxpcFksXHJcblxyXG4gICAgICAgIC8vICBCZXR3ZWVuIDAgYW5kIDEgc2hvd2luZyBjb21wbGV0aW9uIG9mIHRoaXMgVHdlZW5EYXRhLlxyXG4gICAgICAgIHByb2dyZXNzOiAwLFxyXG5cclxuICAgICAgICAvLyAgRGVsdGEgY291bnRlci5cclxuICAgICAgICBlbGFwc2VkOiAwLFxyXG5cclxuICAgICAgICAvLyAgSG93IG1hbnkgcmVwZWF0cyBhcmUgbGVmdCB0byBydW4/XHJcbiAgICAgICAgcmVwZWF0Q291bnRlcjogMCxcclxuXHJcbiAgICAgICAgLy8gIEVhc2UgVmFsdWUgRGF0YTpcclxuXHJcbiAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgY3VycmVudDogMCxcclxuICAgICAgICBlbmQ6IDAsXHJcblxyXG4gICAgICAgIC8vICBUaW1lIER1cmF0aW9uc1xyXG4gICAgICAgIHQxOiAwLFxyXG4gICAgICAgIHQyOiAwLFxyXG5cclxuICAgICAgICAvLyAgTG9hZFZhbHVlIGdlbmVyYXRpb24gZnVuY3Rpb25zXHJcbiAgICAgICAgZ2VuOiB7XHJcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheSxcclxuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBob2xkOiBob2xkLFxyXG4gICAgICAgICAgICByZXBlYXQ6IHJlcGVhdCxcclxuICAgICAgICAgICAgcmVwZWF0RGVsYXk6IHJlcGVhdERlbGF5XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gIFRXRUVOX0NPTlNULkNSRUFURURcclxuICAgICAgICBzdGF0ZTogMFxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHdlZW5EYXRhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL3R3ZWVuL1R3ZWVuRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTAwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FsY0R1cmF0aW9uID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIG1heCA9IDA7XHJcblxyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRvdGFsRGF0YTsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0d2VlbkRhdGEgPSBkYXRhW2ldO1xyXG5cclxuICAgICAgICAvLyAgU2V0IHQxIChkdXJhdGlvbiArIGhvbGQgKyB5b3lvKVxyXG4gICAgICAgIHR3ZWVuRGF0YS50MSA9IHR3ZWVuRGF0YS5kdXJhdGlvbiArIHR3ZWVuRGF0YS5ob2xkO1xyXG5cclxuICAgICAgICBpZiAodHdlZW5EYXRhLnlveW8pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0d2VlbkRhdGEudDEgKz0gdHdlZW5EYXRhLmR1cmF0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFNldCB0MiAocmVwZWF0RGVsYXkgKyBkdXJhdGlvbiArIGhvbGQgKyB5b3lvKVxyXG4gICAgICAgIHR3ZWVuRGF0YS50MiA9IHR3ZWVuRGF0YS50MSArIHR3ZWVuRGF0YS5yZXBlYXREZWxheTtcclxuXHJcbiAgICAgICAgLy8gIFRvdGFsIER1cmF0aW9uXHJcbiAgICAgICAgdHdlZW5EYXRhLnRvdGFsRHVyYXRpb24gPSB0d2VlbkRhdGEuZGVsYXkgKyB0d2VlbkRhdGEudDE7XHJcblxyXG4gICAgICAgIGlmICh0d2VlbkRhdGEucmVwZWF0ID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50b3RhbER1cmF0aW9uICs9ICh0d2VlbkRhdGEudDIgKiA5OTk5OTk5OTk5OTkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0d2VlbkRhdGEucmVwZWF0ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50b3RhbER1cmF0aW9uICs9ICh0d2VlbkRhdGEudDIgKiB0d2VlbkRhdGEucmVwZWF0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0d2VlbkRhdGEudG90YWxEdXJhdGlvbiA+IG1heClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBHZXQgdGhlIGxvbmdlc3QgVHdlZW5EYXRhIGZyb20gdGhlIFR3ZWVuLCB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgVHdlZW4gVERcclxuICAgICAgICAgICAgbWF4ID0gdHdlZW5EYXRhLnRvdGFsRHVyYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBFeGNsdWRlcyBsb29wIHZhbHVlc1xyXG4gICAgdGhpcy5kdXJhdGlvbiA9IG1heDtcclxuXHJcbiAgICB0aGlzLmxvb3BDb3VudGVyID0gKHRoaXMubG9vcCA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5sb29wO1xyXG5cclxuICAgIGlmICh0aGlzLmxvb3BDb3VudGVyID4gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRvdGFsRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uICsgdGhpcy5jb21wbGV0ZURlbGF5ICsgKCh0aGlzLmR1cmF0aW9uICsgdGhpcy5sb29wRGVsYXkpICogdGhpcy5sb29wQ291bnRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50b3RhbER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbiArIHRoaXMuY29tcGxldGVEZWxheTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FsY0R1cmF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL3R3ZWVuL2luYy9DYWxjRHVyYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRXRUVOX0NPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbi8vICBSZXR1cm4gdHJ1ZSBpZiB0aGlzIFR3ZWVuIHNob3VsZCBiZSBtb3ZlZCBmcm9tIHRoZSBwZW5kaW5nIGxpc3QgdG8gdGhlIGFjdGl2ZSBsaXN0XHJcbnZhciBJbml0ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICB2YXIgdG90YWxUYXJnZXRzID0gdGhpcy50b3RhbFRhcmdldHM7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRvdGFsRGF0YTsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0d2VlbkRhdGEgPSBkYXRhW2ldO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSB0d2VlbkRhdGEudGFyZ2V0O1xyXG4gICAgICAgIHZhciBnZW4gPSB0d2VlbkRhdGEuZ2VuO1xyXG5cclxuICAgICAgICB0d2VlbkRhdGEuZGVsYXkgPSBnZW4uZGVsYXkoaSwgdG90YWxUYXJnZXRzLCB0YXJnZXQpO1xyXG4gICAgICAgIHR3ZWVuRGF0YS5kdXJhdGlvbiA9IGdlbi5kdXJhdGlvbihpLCB0b3RhbFRhcmdldHMsIHRhcmdldCk7XHJcbiAgICAgICAgdHdlZW5EYXRhLmhvbGQgPSBnZW4uaG9sZChpLCB0b3RhbFRhcmdldHMsIHRhcmdldCk7XHJcbiAgICAgICAgdHdlZW5EYXRhLnJlcGVhdCA9IGdlbi5yZXBlYXQoaSwgdG90YWxUYXJnZXRzLCB0YXJnZXQpO1xyXG4gICAgICAgIHR3ZWVuRGF0YS5yZXBlYXREZWxheSA9IGdlbi5yZXBlYXREZWxheShpLCB0b3RhbFRhcmdldHMsIHRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jYWxjRHVyYXRpb24oKTtcclxuXHJcbiAgICB0aGlzLnByb2dyZXNzID0gMDtcclxuICAgIHRoaXMudG90YWxQcm9ncmVzcyA9IDA7XHJcbiAgICB0aGlzLmVsYXBzZWQgPSAwO1xyXG4gICAgdGhpcy50b3RhbEVsYXBzZWQgPSAwO1xyXG5cclxuICAgIC8vICBZb3UgY2FuJ3QgaGF2ZSBhIHBhdXNlZCBUd2VlbiBpZiBpdCdzIHBhcnQgb2YgYSBUaW1lbGluZVxyXG4gICAgaWYgKHRoaXMucGF1c2VkICYmICF0aGlzLnBhcmVudElzVGltZWxpbmUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULlBBVVNFRDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbml0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL3R3ZWVuL2luYy9Jbml0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUV0VFTl9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcblxyXG52YXIgTmV4dFN0YXRlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKHRoaXMubG9vcENvdW50ZXIgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZWxhcHNlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5sb29wQ291bnRlci0tO1xyXG5cclxuICAgICAgICB2YXIgb25Mb29wID0gdGhpcy5jYWxsYmFja3Mub25Mb29wO1xyXG5cclxuICAgICAgICBpZiAob25Mb29wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb25Mb29wLnBhcmFtc1sxXSA9IHRoaXMudGFyZ2V0cztcclxuXHJcbiAgICAgICAgICAgIG9uTG9vcC5mdW5jLmFwcGx5KG9uTG9vcC5zY29wZSwgb25Mb29wLnBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlc2V0VHdlZW5EYXRhKHRydWUpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5sb29wRGVsYXkgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jb3VudGRvd24gPSB0aGlzLmxvb3BEZWxheTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULkxPT1BfREVMQVk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBUV0VFTl9DT05TVC5BQ1RJVkU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy5jb21wbGV0ZURlbGF5ID4gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvdW50ZG93biA9IHRoaXMuY29tcGxldGVEZWxheTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gVFdFRU5fQ09OU1QuQ09NUExFVEVfREVMQVk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG9uQ29tcGxldGUgPSB0aGlzLmNhbGxiYWNrcy5vbkNvbXBsZXRlO1xyXG5cclxuICAgICAgICBpZiAob25Db21wbGV0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG9uQ29tcGxldGUucGFyYW1zWzFdID0gdGhpcy50YXJnZXRzO1xyXG5cclxuICAgICAgICAgICAgb25Db21wbGV0ZS5mdW5jLmFwcGx5KG9uQ29tcGxldGUuc2NvcGUsIG9uQ29tcGxldGUucGFyYW1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUV0VFTl9DT05TVC5QRU5ESU5HX1JFTU9WRTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTmV4dFN0YXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL3R3ZWVuL2luYy9OZXh0U3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRXRUVOX0NPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbnZhciBQYXVzZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBUV0VFTl9DT05TVC5QQVVTRUQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl9wYXVzZWRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULlBBVVNFRDtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGF1c2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vdHdlZW4vaW5jL1BhdXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUV0VFTl9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcblxyXG52YXIgUGxheSA9IGZ1bmN0aW9uIChyZXNldEZyb21UaW1lbGluZSlcclxue1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFRXRUVOX0NPTlNULkFDVElWRSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBUV0VFTl9DT05TVC5QRU5ESU5HX1JFTU9WRSB8fCB0aGlzLnN0YXRlID09PSBUV0VFTl9DT05TVC5SRU1PVkVEKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgICAgIHRoaXMucGFyZW50Lm1ha2VBY3RpdmUodGhpcyk7XHJcbiAgICAgICAgcmVzZXRGcm9tVGltZWxpbmUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvblN0YXJ0ID0gdGhpcy5jYWxsYmFja3Mub25TdGFydDtcclxuXHJcbiAgICBpZiAodGhpcy5wYXJlbnRJc1RpbWVsaW5lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVzZXRUd2VlbkRhdGEocmVzZXRGcm9tVGltZWxpbmUpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jYWxjdWxhdGVkT2Zmc2V0ID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKG9uU3RhcnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9uU3RhcnQucGFyYW1zWzFdID0gdGhpcy50YXJnZXRzO1xyXG5cclxuICAgICAgICAgICAgICAgIG9uU3RhcnQuZnVuYy5hcHBseShvblN0YXJ0LnNjb3BlLCBvblN0YXJ0LnBhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBUV0VFTl9DT05TVC5BQ1RJVkU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnRkb3duID0gdGhpcy5jYWxjdWxhdGVkT2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULk9GRlNFVF9ERUxBWTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLnBhdXNlZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICAgICAgdGhpcy5wYXJlbnQubWFrZUFjdGl2ZSh0aGlzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVzZXRUd2VlbkRhdGEocmVzZXRGcm9tVGltZWxpbmUpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gVFdFRU5fQ09OU1QuQUNUSVZFO1xyXG5cclxuICAgICAgICBpZiAob25TdGFydClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG9uU3RhcnQucGFyYW1zWzFdID0gdGhpcy50YXJnZXRzO1xyXG5cclxuICAgICAgICAgICAgb25TdGFydC5mdW5jLmFwcGx5KG9uU3RhcnQuc2NvcGUsIG9uU3RhcnQucGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsYXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vdHdlZW4vaW5jL1BsYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEwMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRXRUVOX0NPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbnZhciBSZXNldFR3ZWVuRGF0YSA9IGZ1bmN0aW9uIChyZXNldEZyb21Mb29wKVxyXG57XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG90YWxEYXRhOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHR3ZWVuRGF0YSA9IGRhdGFbaV07XHJcblxyXG4gICAgICAgIHR3ZWVuRGF0YS5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdHdlZW5EYXRhLmVsYXBzZWQgPSAwO1xyXG5cclxuICAgICAgICB0d2VlbkRhdGEucmVwZWF0Q291bnRlciA9ICh0d2VlbkRhdGEucmVwZWF0ID09PSAtMSkgPyA5OTk5OTk5OTk5OTkgOiB0d2VlbkRhdGEucmVwZWF0O1xyXG5cclxuICAgICAgICBpZiAocmVzZXRGcm9tTG9vcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5zdGFydCA9IHR3ZWVuRGF0YS5nZXRTdGFydFZhbHVlKHR3ZWVuRGF0YS50YXJnZXQsIHR3ZWVuRGF0YS5rZXksIHR3ZWVuRGF0YS5zdGFydCk7XHJcblxyXG4gICAgICAgICAgICB0d2VlbkRhdGEuZW5kID0gdHdlZW5EYXRhLmdldEVuZFZhbHVlKHR3ZWVuRGF0YS50YXJnZXQsIHR3ZWVuRGF0YS5rZXksIHR3ZWVuRGF0YS5lbmQpO1xyXG5cclxuICAgICAgICAgICAgdHdlZW5EYXRhLmN1cnJlbnQgPSB0d2VlbkRhdGEuc3RhcnQ7XHJcblxyXG4gICAgICAgICAgICB0d2VlbkRhdGEuc3RhdGUgPSBUV0VFTl9DT05TVC5QTEFZSU5HX0ZPUldBUkQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR3ZWVuRGF0YS5kZWxheSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCA9IHR3ZWVuRGF0YS5kZWxheTtcclxuICAgICAgICAgICAgdHdlZW5EYXRhLnN0YXRlID0gVFdFRU5fQ09OU1QuREVMQVk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5zdGF0ZSA9IFRXRUVOX0NPTlNULlBFTkRJTkdfUkVOREVSO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzZXRUd2VlbkRhdGE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vdHdlZW4vaW5jL1Jlc2V0VHdlZW5EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUV0VFTl9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcblxyXG52YXIgUGF1c2UgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVFdFRU5fQ09OU1QuUEFVU0VEKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLl9wYXVzZWRTdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGF1c2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vdHdlZW4vaW5jL1Jlc3VtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyB2YXIgVFdFRU5fQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG5cclxuLy8gIEZvciBub3cgcHJvZ3Jlc3MgPSAwIHRvIDFcclxudmFyIFNlZWsgPSBmdW5jdGlvbiAodG9Qb3NpdGlvbilcclxue1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRvdGFsRGF0YTsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUaGlzIHdvbid0IHdvcmsgd2l0aCBsb29wID4gMCB5ZXRcclxuICAgICAgICB2YXIgbXMgPSB0aGlzLnRvdGFsRHVyYXRpb24gKiB0b1Bvc2l0aW9uO1xyXG5cclxuICAgICAgICB2YXIgdHdlZW5EYXRhID0gZGF0YVtpXTtcclxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgIHZhciBlbGFwc2VkID0gMDtcclxuXHJcbiAgICAgICAgaWYgKG1zIDw9IHR3ZWVuRGF0YS5kZWxheSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByb2dyZXNzID0gMDtcclxuICAgICAgICAgICAgZWxhcHNlZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1zID49IHR3ZWVuRGF0YS50b3RhbER1cmF0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHJvZ3Jlc3MgPSAxO1xyXG4gICAgICAgICAgICBlbGFwc2VkID0gdHdlZW5EYXRhLmR1cmF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtcyA+IHR3ZWVuRGF0YS5kZWxheSAmJiBtcyA8PSB0d2VlbkRhdGEudDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgS2VlcCBpdCB6ZXJvIGJvdW5kXHJcbiAgICAgICAgICAgIG1zID0gTWF0aC5tYXgoMCwgbXMgLSB0d2VlbkRhdGEuZGVsYXkpO1xyXG5cclxuICAgICAgICAgICAgLy8gIFNvbWV3aGVyZSBpbiB0aGUgZmlyc3QgcGxheXRocnUgcmFuZ2VcclxuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBtcyAvIHR3ZWVuRGF0YS50MTtcclxuICAgICAgICAgICAgZWxhcHNlZCA9IHR3ZWVuRGF0YS5kdXJhdGlvbiAqIHByb2dyZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtcyA+IHR3ZWVuRGF0YS50MSAmJiBtcyA8IHR3ZWVuRGF0YS50b3RhbER1cmF0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFNvbWV3aGVyZSBpbiByZXBlYXQgbGFuZFxyXG4gICAgICAgICAgICBtcyAtPSB0d2VlbkRhdGEuZGVsYXk7XHJcbiAgICAgICAgICAgIG1zIC09IHR3ZWVuRGF0YS50MTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXBlYXRzID0gTWF0aC5mbG9vcihtcyAvIHR3ZWVuRGF0YS50Mik7XHJcblxyXG4gICAgICAgICAgICAvLyAgcmVtYWluZGVyXHJcbiAgICAgICAgICAgIG1zID0gKChtcyAvIHR3ZWVuRGF0YS50MikgJSAxKSAqIHR3ZWVuRGF0YS50MjtcclxuXHJcbiAgICAgICAgICAgIGlmIChtcyA+IHR3ZWVuRGF0YS5yZXBlYXREZWxheSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSBtcyAvIHR3ZWVuRGF0YS50MTtcclxuICAgICAgICAgICAgICAgIGVsYXBzZWQgPSB0d2VlbkRhdGEuZHVyYXRpb24gKiBwcm9ncmVzcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHdlZW5EYXRhLnByb2dyZXNzID0gcHJvZ3Jlc3M7XHJcbiAgICAgICAgdHdlZW5EYXRhLmVsYXBzZWQgPSBlbGFwc2VkO1xyXG5cclxuICAgICAgICB2YXIgdiA9IHR3ZWVuRGF0YS5lYXNlKHR3ZWVuRGF0YS5wcm9ncmVzcyk7XHJcblxyXG4gICAgICAgIHR3ZWVuRGF0YS5jdXJyZW50ID0gdHdlZW5EYXRhLnN0YXJ0ICsgKCh0d2VlbkRhdGEuZW5kIC0gdHdlZW5EYXRhLnN0YXJ0KSAqIHYpO1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0d2VlbkRhdGEua2V5LCAnU2VlaycsIHR3ZWVuRGF0YS50YXJnZXRbdHdlZW5EYXRhLmtleV0sICd0bycsIHR3ZWVuRGF0YS5jdXJyZW50LCAncHJvJywgdHdlZW5EYXRhLnByb2dyZXNzLCAnbWFya2VyJywgbWFya2VyLCBwcm9ncmVzcyk7XHJcblxyXG4gICAgICAgIHR3ZWVuRGF0YS50YXJnZXRbdHdlZW5EYXRhLmtleV0gPSB0d2VlbkRhdGEuY3VycmVudDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VlaztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi90d2Vlbi9pbmMvU2Vlay5qc1xuLy8gbW9kdWxlIGlkID0gMTAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFNldENhbGxiYWNrID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKVxyXG57XHJcbiAgICB0aGlzLmNhbGxiYWNrc1t0eXBlXSA9IHsgZnVuYzogY2FsbGJhY2ssIHNjb3BlOiBzY29wZSwgcGFyYW1zOiBwYXJhbXMgfTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FsbGJhY2s7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vdHdlZW4vaW5jL1NldENhbGxiYWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUV0VFTl9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcblxyXG4vLyAgU3RvcHMgdGhlIFR3ZWVuIGltbWVkaWF0ZWx5LCB3aGF0ZXZlciBzdGFnZSBvZiBwcm9ncmVzcyBpdCBpcyBhdCBhbmQgZmxhZ3MgaXQgZm9yIHJlbW92YWwgYnkgdGhlIFR3ZWVuTWFuYWdlclxyXG5cclxudmFyIFN0b3AgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gVFdFRU5fQ09OU1QuUEVORElOR19SRU1PVkU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3A7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vdHdlZW4vaW5jL1N0b3AuanNcbi8vIG1vZHVsZSBpZCA9IDEwMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRXRUVOX0NPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIFVwZGF0ZVR3ZWVuRGF0YSA9IHJlcXVpcmUoJy4vVXBkYXRlVHdlZW5EYXRhJyk7XHJcblxyXG4vLyAgUmV0dXJucyAndHJ1ZScgaWYgdGhpcyBUd2VlbiBoYXMgZmluaXNoZWQgYW5kIHNob3VsZCBiZSByZW1vdmVkIGZyb20gdGhlIFR3ZWVuIE1hbmFnZXJcclxuLy8gIE90aGVyd2lzZSwgcmV0dXJucyBmYWxzZVxyXG52YXIgVXBkYXRlID0gZnVuY3Rpb24gKHRpbWVzdGFtcCwgZGVsdGEpXHJcbntcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBUV0VFTl9DT05TVC5QQVVTRUQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnVzZUZyYW1lcylcclxuICAgIHtcclxuICAgICAgICBkZWx0YSA9IDEgKiB0aGlzLnBhcmVudC50aW1lU2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsdGEgKj0gdGhpcy50aW1lU2NhbGU7XHJcblxyXG4gICAgdGhpcy5lbGFwc2VkICs9IGRlbHRhO1xyXG4gICAgdGhpcy5wcm9ncmVzcyA9IE1hdGgubWluKHRoaXMuZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24sIDEpO1xyXG5cclxuICAgIHRoaXMudG90YWxFbGFwc2VkICs9IGRlbHRhO1xyXG4gICAgdGhpcy50b3RhbFByb2dyZXNzID0gTWF0aC5taW4odGhpcy50b3RhbEVsYXBzZWQgLyB0aGlzLnRvdGFsRHVyYXRpb24sIDEpO1xyXG5cclxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSlcclxuICAgIHtcclxuICAgICAgICBjYXNlIFRXRUVOX0NPTlNULkFDVElWRTpcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGlsbFJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50b3RhbERhdGE7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFVwZGF0ZVR3ZWVuRGF0YSh0aGlzLCB0aGlzLmRhdGFbaV0sIGRlbHRhKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGlsbFJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAgQW55dGhpbmcgc3RpbGwgcnVubmluZz8gSWYgbm90LCB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgIGlmICghc3RpbGxSdW5uaW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBUV0VFTl9DT05TVC5MT09QX0RFTEFZOlxyXG5cclxuICAgICAgICAgICAgdGhpcy5jb3VudGRvd24gLT0gZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudGRvd24gPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULkFDVElWRTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgVFdFRU5fQ09OU1QuT0ZGU0VUX0RFTEFZOlxyXG5cclxuICAgICAgICAgICAgdGhpcy5jb3VudGRvd24gLT0gZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudGRvd24gPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9uU3RhcnQgPSB0aGlzLmNhbGxiYWNrcy5vblN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvblN0YXJ0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uU3RhcnQucGFyYW1zWzFdID0gdGhpcy50YXJnZXRzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBvblN0YXJ0LmZ1bmMuYXBwbHkob25TdGFydC5zY29wZSwgb25TdGFydC5wYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBUV0VFTl9DT05TVC5BQ1RJVkU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIFRXRUVOX0NPTlNULkNPTVBMRVRFX0RFTEFZOlxyXG5cclxuICAgICAgICAgICAgdGhpcy5jb3VudGRvd24gLT0gZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudGRvd24gPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9uQ29tcGxldGUgPSB0aGlzLmNhbGxiYWNrcy5vbkNvbXBsZXRlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGUuZnVuYy5hcHBseShvbkNvbXBsZXRlLnNjb3BlLCBvbkNvbXBsZXRlLnBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULlBFTkRJTkdfUkVNT1ZFO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09IFRXRUVOX0NPTlNULlBFTkRJTkdfUkVNT1ZFKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXBkYXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL3R3ZWVuL2luYy9VcGRhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRXRUVOX0NPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbnZhciBTZXRTdGF0ZUZyb21FbmQgPSBmdW5jdGlvbiAodHdlZW4sIHR3ZWVuRGF0YSwgZGlmZilcclxue1xyXG4gICAgaWYgKHR3ZWVuRGF0YS55b3lvKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBXZSd2ZSBoaXQgdGhlIGVuZCBvZiBhIFBsYXlpbmcgRm9yd2FyZCBUd2VlbkRhdGEgYW5kIHdlIGhhdmUgYSB5b3lvXHJcblxyXG4gICAgICAgIC8vICBBY2NvdW50IGZvciBhbnkgZXh0cmEgdGltZSB3ZSBnb3QgZnJvbSB0aGUgcHJldmlvdXMgZnJhbWVcclxuICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCA9IGRpZmY7XHJcbiAgICAgICAgdHdlZW5EYXRhLnByb2dyZXNzID0gZGlmZiAvIHR3ZWVuRGF0YS5kdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKHR3ZWVuRGF0YS5mbGlwWClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50YXJnZXQudG9nZ2xlRmxpcFgoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBQcm9ibGVtOiBUaGUgZmxpcCBhbmQgY2FsbGJhY2sgYW5kIHNvIG9uIGdldHMgY2FsbGVkIGZvciBldmVyeSBUd2VlbkRhdGEgdGhhdCB0cmlnZ2VycyBpdCBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICAgIC8vICBJZiB5b3UncmUgdHdlZW5pbmcgc2V2ZXJhbCBwcm9wZXJ0aWVzIGl0IGNhbiBmaXJlIGZvciBhbGwgb2YgdGhlbSwgYXQgb25jZS5cclxuXHJcbiAgICAgICAgaWYgKHR3ZWVuRGF0YS5mbGlwWSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50YXJnZXQudG9nZ2xlRmxpcFkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvbllveW8gPSB0d2Vlbi5jYWxsYmFja3Mub25Zb3lvO1xyXG5cclxuICAgICAgICBpZiAob25Zb3lvKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEVsZW1lbnQgMSBpcyByZXNlcnZlZCBmb3IgdGhlIHRhcmdldCBvZiB0aGUgeW95byAoYW5kIG5lZWRzIHNldHRpbmcgaGVyZSlcclxuICAgICAgICAgICAgb25Zb3lvLnBhcmFtc1sxXSA9IHR3ZWVuRGF0YS50YXJnZXQ7XHJcblxyXG4gICAgICAgICAgICBvbllveW8uZnVuYy5hcHBseShvbllveW8uc2NvcGUsIG9uWW95by5wYXJhbXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHdlZW5EYXRhLnN0YXJ0ID0gdHdlZW5EYXRhLmdldFN0YXJ0VmFsdWUodHdlZW5EYXRhLnRhcmdldCwgdHdlZW5EYXRhLmtleSwgdHdlZW5EYXRhLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFRXRUVOX0NPTlNULlBMQVlJTkdfQkFDS1dBUkQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0d2VlbkRhdGEucmVwZWF0Q291bnRlciA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFdlJ3ZlIGhpdCB0aGUgZW5kIG9mIGEgUGxheWluZyBGb3J3YXJkIFR3ZWVuRGF0YSBhbmQgd2UgaGF2ZSBhIFJlcGVhdC5cclxuICAgICAgICAvLyAgU28gd2UncmUgZ29pbmcgdG8gZ28gcmlnaHQgYmFjayB0byB0aGUgc3RhcnQgdG8gcmVwZWF0IGl0IGFnYWluLlxyXG5cclxuICAgICAgICB0d2VlbkRhdGEucmVwZWF0Q291bnRlci0tO1xyXG5cclxuICAgICAgICAvLyAgQWNjb3VudCBmb3IgYW55IGV4dHJhIHRpbWUgd2UgZ290IGZyb20gdGhlIHByZXZpb3VzIGZyYW1lXHJcbiAgICAgICAgdHdlZW5EYXRhLmVsYXBzZWQgPSBkaWZmO1xyXG4gICAgICAgIHR3ZWVuRGF0YS5wcm9ncmVzcyA9IGRpZmYgLyB0d2VlbkRhdGEuZHVyYXRpb247XHJcblxyXG4gICAgICAgIC8vIHR3ZWVuRGF0YS5lbGFwc2VkID0gMDtcclxuICAgICAgICAvLyB0d2VlbkRhdGEucHJvZ3Jlc3MgPSAwO1xyXG5cclxuICAgICAgICBpZiAodHdlZW5EYXRhLmZsaXBYKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHdlZW5EYXRhLnRhcmdldC50b2dnbGVGbGlwWCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR3ZWVuRGF0YS5mbGlwWSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50YXJnZXQudG9nZ2xlRmxpcFkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvblJlcGVhdCA9IHR3ZWVuLmNhbGxiYWNrcy5vblJlcGVhdDtcclxuXHJcbiAgICAgICAgaWYgKG9uUmVwZWF0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEVsZW1lbnQgMSBpcyByZXNlcnZlZCBmb3IgdGhlIHRhcmdldCBvZiB0aGUgcmVwZWF0IChhbmQgbmVlZHMgc2V0dGluZyBoZXJlKVxyXG4gICAgICAgICAgICBvblJlcGVhdC5wYXJhbXNbMV0gPSB0d2VlbkRhdGEudGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgb25SZXBlYXQuZnVuYy5hcHBseShvblJlcGVhdC5zY29wZSwgb25SZXBlYXQucGFyYW1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHR3ZWVuRGF0YS5zdGFydCA9IHR3ZWVuRGF0YS5nZXRTdGFydFZhbHVlKHR3ZWVuRGF0YS50YXJnZXQsIHR3ZWVuRGF0YS5rZXksIHR3ZWVuRGF0YS5zdGFydCk7XHJcblxyXG4gICAgICAgIHR3ZWVuRGF0YS5lbmQgPSB0d2VlbkRhdGEuZ2V0RW5kVmFsdWUodHdlZW5EYXRhLnRhcmdldCwgdHdlZW5EYXRhLmtleSwgdHdlZW5EYXRhLmVuZCk7XHJcblxyXG4gICAgICAgIC8vICBEZWxheT9cclxuICAgICAgICBpZiAodHdlZW5EYXRhLnJlcGVhdERlbGF5ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5lbGFwc2VkID0gdHdlZW5EYXRhLnJlcGVhdERlbGF5IC0gZGlmZjtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5jdXJyZW50ID0gdHdlZW5EYXRhLnN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgdHdlZW5EYXRhLnRhcmdldFt0d2VlbkRhdGEua2V5XSA9IHR3ZWVuRGF0YS5jdXJyZW50O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFRXRUVOX0NPTlNULlJFUEVBVF9ERUxBWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRXRUVOX0NPTlNULlBMQVlJTkdfRk9SV0FSRDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFRXRUVOX0NPTlNULkNPTVBMRVRFO1xyXG59O1xyXG5cclxuLy8gIFdhcyBQTEFZSU5HX0JBQ0tXQVJEIGFuZCBoYXMgaGl0IHRoZSBzdGFydFxyXG52YXIgU2V0U3RhdGVGcm9tU3RhcnQgPSBmdW5jdGlvbiAodHdlZW4sIHR3ZWVuRGF0YSwgZGlmZilcclxue1xyXG4gICAgaWYgKHR3ZWVuRGF0YS5yZXBlYXRDb3VudGVyID4gMClcclxuICAgIHtcclxuICAgICAgICB0d2VlbkRhdGEucmVwZWF0Q291bnRlci0tO1xyXG5cclxuICAgICAgICAvLyAgQWNjb3VudCBmb3IgYW55IGV4dHJhIHRpbWUgd2UgZ290IGZyb20gdGhlIHByZXZpb3VzIGZyYW1lXHJcbiAgICAgICAgdHdlZW5EYXRhLmVsYXBzZWQgPSBkaWZmO1xyXG4gICAgICAgIHR3ZWVuRGF0YS5wcm9ncmVzcyA9IGRpZmYgLyB0d2VlbkRhdGEuZHVyYXRpb247XHJcblxyXG4gICAgICAgIC8vIHR3ZWVuRGF0YS5lbGFwc2VkID0gMDtcclxuICAgICAgICAvLyB0d2VlbkRhdGEucHJvZ3Jlc3MgPSAwO1xyXG5cclxuICAgICAgICBpZiAodHdlZW5EYXRhLmZsaXBYKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHdlZW5EYXRhLnRhcmdldC50b2dnbGVGbGlwWCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR3ZWVuRGF0YS5mbGlwWSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50YXJnZXQudG9nZ2xlRmxpcFkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvblJlcGVhdCA9IHR3ZWVuLmNhbGxiYWNrcy5vblJlcGVhdDtcclxuXHJcbiAgICAgICAgaWYgKG9uUmVwZWF0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEVsZW1lbnQgMSBpcyByZXNlcnZlZCBmb3IgdGhlIHRhcmdldCBvZiB0aGUgcmVwZWF0IChhbmQgbmVlZHMgc2V0dGluZyBoZXJlKVxyXG4gICAgICAgICAgICBvblJlcGVhdC5wYXJhbXNbMV0gPSB0d2VlbkRhdGEudGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgb25SZXBlYXQuZnVuYy5hcHBseShvblJlcGVhdC5zY29wZSwgb25SZXBlYXQucGFyYW1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHR3ZWVuRGF0YS5lbmQgPSB0d2VlbkRhdGEuZ2V0RW5kVmFsdWUodHdlZW5EYXRhLnRhcmdldCwgdHdlZW5EYXRhLmtleSwgdHdlZW5EYXRhLmVuZCk7XHJcblxyXG4gICAgICAgIC8vICBEZWxheT9cclxuICAgICAgICBpZiAodHdlZW5EYXRhLnJlcGVhdERlbGF5ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5lbGFwc2VkID0gdHdlZW5EYXRhLnJlcGVhdERlbGF5IC0gZGlmZjtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5jdXJyZW50ID0gdHdlZW5EYXRhLnN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgdHdlZW5EYXRhLnRhcmdldFt0d2VlbkRhdGEua2V5XSA9IHR3ZWVuRGF0YS5jdXJyZW50O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFRXRUVOX0NPTlNULlJFUEVBVF9ERUxBWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRXRUVOX0NPTlNULlBMQVlJTkdfRk9SV0FSRDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFRXRUVOX0NPTlNULkNPTVBMRVRFO1xyXG59O1xyXG5cclxuLy8gIERlbHRhIGlzIGVpdGhlciBhIHZhbHVlIGluIG1zLCBvciAxIGlmIFR3ZWVuLnVzZUZyYW1lcyBpcyB0cnVlXHJcbnZhciBVcGRhdGVUd2VlbkRhdGEgPSBmdW5jdGlvbiAodHdlZW4sIHR3ZWVuRGF0YSwgZGVsdGEpXHJcbntcclxuICAgIHN3aXRjaCAodHdlZW5EYXRhLnN0YXRlKVxyXG4gICAge1xyXG4gICAgICAgIGNhc2UgVFdFRU5fQ09OU1QuUExBWUlOR19GT1JXQVJEOlxyXG4gICAgICAgIGNhc2UgVFdFRU5fQ09OU1QuUExBWUlOR19CQUNLV0FSRDpcclxuXHJcbiAgICAgICAgICAgIHZhciBlbGFwc2VkID0gdHdlZW5EYXRhLmVsYXBzZWQ7XHJcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHR3ZWVuRGF0YS5kdXJhdGlvbjtcclxuICAgICAgICAgICAgdmFyIGRpZmYgPSAwO1xyXG5cclxuICAgICAgICAgICAgZWxhcHNlZCArPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlbGFwc2VkID4gZHVyYXRpb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSBlbGFwc2VkIC0gZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBlbGFwc2VkID0gZHVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmb3J3YXJkID0gKHR3ZWVuRGF0YS5zdGF0ZSA9PT0gVFdFRU5fQ09OU1QuUExBWUlOR19GT1JXQVJEKTtcclxuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gZWxhcHNlZCAvIGR1cmF0aW9uO1xyXG5cclxuICAgICAgICAgICAgdmFyIHY7XHJcblxyXG4gICAgICAgICAgICBpZiAoZm9yd2FyZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdiA9IHR3ZWVuRGF0YS5lYXNlKHByb2dyZXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHYgPSB0d2VlbkRhdGEuZWFzZSgxIC0gcHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0d2VlbkRhdGEuY3VycmVudCA9IHR3ZWVuRGF0YS5zdGFydCArICgodHdlZW5EYXRhLmVuZCAtIHR3ZWVuRGF0YS5zdGFydCkgKiB2KTtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50YXJnZXRbdHdlZW5EYXRhLmtleV0gPSB0d2VlbkRhdGEuY3VycmVudDtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5lbGFwc2VkID0gZWxhcHNlZDtcclxuICAgICAgICAgICAgdHdlZW5EYXRhLnByb2dyZXNzID0gcHJvZ3Jlc3M7XHJcblxyXG4gICAgICAgICAgICB2YXIgb25VcGRhdGUgPSB0d2Vlbi5jYWxsYmFja3Mub25VcGRhdGU7XHJcblxyXG4gICAgICAgICAgICBpZiAob25VcGRhdGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9uVXBkYXRlLnBhcmFtc1sxXSA9IHR3ZWVuRGF0YS50YXJnZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgb25VcGRhdGUuZnVuYy5hcHBseShvblVwZGF0ZS5zY29wZSwgb25VcGRhdGUucGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHByb2dyZXNzID09PSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHdlZW5EYXRhLmhvbGQgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW5EYXRhLmVsYXBzZWQgPSB0d2VlbkRhdGEuaG9sZCAtIGRpZmY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0d2VlbkRhdGEuc3RhdGUgPSBUV0VFTl9DT05TVC5IT0xEX0RFTEFZO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0d2VlbkRhdGEuc3RhdGUgPSBTZXRTdGF0ZUZyb21FbmQodHdlZW4sIHR3ZWVuRGF0YSwgZGlmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuRGF0YS5zdGF0ZSA9IFNldFN0YXRlRnJvbVN0YXJ0KHR3ZWVuLCB0d2VlbkRhdGEsIGRpZmYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBUV0VFTl9DT05TVC5ERUxBWTpcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5lbGFwc2VkIC09IGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR3ZWVuRGF0YS5lbGFwc2VkIDw9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR3ZWVuRGF0YS5lbGFwc2VkID0gTWF0aC5hYnModHdlZW5EYXRhLmVsYXBzZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHR3ZWVuRGF0YS5zdGF0ZSA9IFRXRUVOX0NPTlNULlBFTkRJTkdfUkVOREVSO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBUV0VFTl9DT05TVC5SRVBFQVRfREVMQVk6XHJcblxyXG4gICAgICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCAtPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0d2VlbkRhdGEuZWxhcHNlZCA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCA9IE1hdGguYWJzKHR3ZWVuRGF0YS5lbGFwc2VkKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0d2VlbkRhdGEuc3RhdGUgPSBUV0VFTl9DT05TVC5QTEFZSU5HX0ZPUldBUkQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIFRXRUVOX0NPTlNULkhPTERfREVMQVk6XHJcblxyXG4gICAgICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCAtPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0d2VlbkRhdGEuZWxhcHNlZCA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0d2VlbkRhdGEuc3RhdGUgPSBTZXRTdGF0ZUZyb21FbmQodHdlZW4sIHR3ZWVuRGF0YSwgTWF0aC5hYnModHdlZW5EYXRhLmVsYXBzZWQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgVFdFRU5fQ09OU1QuUEVORElOR19SRU5ERVI6XHJcblxyXG4gICAgICAgICAgICB0d2VlbkRhdGEuc3RhcnQgPSB0d2VlbkRhdGEuZ2V0U3RhcnRWYWx1ZSh0d2VlbkRhdGEudGFyZ2V0LCB0d2VlbkRhdGEua2V5LCB0d2VlbkRhdGEudGFyZ2V0W3R3ZWVuRGF0YS5rZXldKTtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5lbmQgPSB0d2VlbkRhdGEuZ2V0RW5kVmFsdWUodHdlZW5EYXRhLnRhcmdldCwgdHdlZW5EYXRhLmtleSwgdHdlZW5EYXRhLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5jdXJyZW50ID0gdHdlZW5EYXRhLnN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgdHdlZW5EYXRhLnRhcmdldFt0d2VlbkRhdGEua2V5XSA9IHR3ZWVuRGF0YS5zdGFydDtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5zdGF0ZSA9IFRXRUVOX0NPTlNULlBMQVlJTkdfRk9SV0FSRDtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBSZXR1cm4gVFJVRSBpZiB0aGlzIFR3ZWVuRGF0YSBzdGlsbCBwbGF5aW5nLCBvdGhlcndpc2UgcmV0dXJuIEZBTFNFXHJcbiAgICByZXR1cm4gKHR3ZWVuRGF0YS5zdGF0ZSAhPT0gVFdFRU5fQ09OU1QuQ09NUExFVEUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVcGRhdGVUd2VlbkRhdGE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vdHdlZW4vaW5jL1VwZGF0ZVR3ZWVuRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgQWxpZ25Jbk1hcCA9IFtdO1xyXG5cclxuQWxpZ25Jbk1hcFtDT05TVC5CT1RUT01fQ0VOVEVSXSA9IHJlcXVpcmUoJy4vSW5Cb3R0b21DZW50ZXInKTtcclxuQWxpZ25Jbk1hcFtDT05TVC5CT1RUT01fTEVGVF0gPSByZXF1aXJlKCcuL0luQm90dG9tTGVmdCcpO1xyXG5BbGlnbkluTWFwW0NPTlNULkJPVFRPTV9SSUdIVF0gPSByZXF1aXJlKCcuL0luQm90dG9tUmlnaHQnKTtcclxuQWxpZ25Jbk1hcFtDT05TVC5DRU5URVJdID0gcmVxdWlyZSgnLi9JbkNlbnRlcicpO1xyXG5BbGlnbkluTWFwW0NPTlNULkxFRlRfQ0VOVEVSXSA9IHJlcXVpcmUoJy4vSW5MZWZ0Q2VudGVyJyk7XHJcbkFsaWduSW5NYXBbQ09OU1QuUklHSFRfQ0VOVEVSXSA9IHJlcXVpcmUoJy4vSW5SaWdodENlbnRlcicpO1xyXG5BbGlnbkluTWFwW0NPTlNULlRPUF9DRU5URVJdID0gcmVxdWlyZSgnLi9JblRvcENlbnRlcicpO1xyXG5BbGlnbkluTWFwW0NPTlNULlRPUF9MRUZUXSA9IHJlcXVpcmUoJy4vSW5Ub3BMZWZ0Jyk7XHJcbkFsaWduSW5NYXBbQ09OU1QuVE9QX1JJR0hUXSA9IHJlcXVpcmUoJy4vSW5Ub3BSaWdodCcpO1xyXG5cclxudmFyIEFsaWduSW4gPSBmdW5jdGlvbiAoY2hpbGQsIGNvbnRhaW5lciwgcG9zaXRpb24sIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIHJldHVybiBBbGlnbkluTWFwW3Bvc2l0aW9uXShjaGlsZCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWxpZ25JbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9BbGlnbkluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRDZW50ZXJYID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldENlbnRlclgnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWCcpO1xyXG52YXIgU2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFRvcCcpO1xyXG5cclxudmFyIFRvQm90dG9tQ2VudGVyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldENlbnRlclgoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0Qm90dG9tKHBhcmVudCkgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Cb3R0b21DZW50ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYWxpZ24vVG9Cb3R0b21DZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xyXG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xyXG52YXIgU2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRMZWZ0Jyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgVG9Cb3R0b21MZWZ0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldExlZnQoZ2FtZU9iamVjdCwgR2V0TGVmdChwYXJlbnQpIC0gb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0Qm90dG9tKHBhcmVudCkgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Cb3R0b21MZWZ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FsaWduL1RvQm90dG9tTGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMTAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgVG9Cb3R0b21SaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0Qm90dG9tKHBhcmVudCkgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Cb3R0b21SaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub0JvdHRvbVJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgVG9MZWZ0Qm90dG9tID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldFJpZ2h0KGdhbWVPYmplY3QsIEdldExlZnQocGFyZW50KSAtIG9mZnNldFgpO1xyXG4gICAgU2V0Qm90dG9tKGdhbWVPYmplY3QsIEdldEJvdHRvbShwYXJlbnQpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvTGVmdEJvdHRvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub0xlZnRCb3R0b20uanNcbi8vIG1vZHVsZSBpZCA9IDEwMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xyXG52YXIgR2V0Q2VudGVyWSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJZJyk7XHJcbnZhciBTZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRSaWdodCcpO1xyXG52YXIgU2V0Q2VudGVyWSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRDZW50ZXJZJyk7XHJcblxyXG52YXIgVG9MZWZ0Q2VudGVyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldFJpZ2h0KGdhbWVPYmplY3QsIEdldExlZnQocGFyZW50KSAtIG9mZnNldFgpO1xyXG4gICAgU2V0Q2VudGVyWShnYW1lT2JqZWN0LCBHZXRDZW50ZXJZKHBhcmVudCkgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9MZWZ0Q2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FsaWduL1RvTGVmdENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRMZWZ0Jyk7XHJcbnZhciBHZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0VG9wJyk7XHJcbnZhciBTZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRSaWdodCcpO1xyXG52YXIgU2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFRvcCcpO1xyXG5cclxudmFyIFRvTGVmdFRvcCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRMZWZ0KHBhcmVudCkgLSBvZmZzZXRYKTtcclxuICAgIFNldFRvcChnYW1lT2JqZWN0LCBHZXRUb3AocGFyZW50KSAtIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb0xlZnRUb3A7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYWxpZ24vVG9MZWZ0VG9wLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRSaWdodCcpO1xyXG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xyXG52YXIgU2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRMZWZ0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgVG9SaWdodEJvdHRvbSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldFJpZ2h0KHBhcmVudCkgKyBvZmZzZXRYKTtcclxuICAgIFNldEJvdHRvbShnYW1lT2JqZWN0LCBHZXRCb3R0b20ocGFyZW50KSArIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb1JpZ2h0Qm90dG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FsaWduL1RvUmlnaHRCb3R0b20uanNcbi8vIG1vZHVsZSBpZCA9IDEwMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFJpZ2h0Jyk7XHJcbnZhciBHZXRDZW50ZXJZID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldENlbnRlclknKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0Q2VudGVyWSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRDZW50ZXJZJyk7XHJcblxyXG52YXIgVG9SaWdodFRvcCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldFJpZ2h0KHBhcmVudCkgKyBvZmZzZXRYKTtcclxuICAgIFNldENlbnRlclkoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWShwYXJlbnQpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvUmlnaHRUb3A7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYWxpZ24vVG9SaWdodENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFRvcCcpO1xyXG5cclxudmFyIFRvUmlnaHRUb3AgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0TGVmdChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0VG9wKHBhcmVudCkgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9SaWdodFRvcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub1JpZ2h0VG9wLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRDZW50ZXJYID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldENlbnRlclgnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWCcpO1xyXG52YXIgU2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldEJvdHRvbScpO1xyXG5cclxudmFyIFRvVG9wQ2VudGVyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldENlbnRlclgoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0VG9wKHBhcmVudCkgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Ub3BDZW50ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYWxpZ24vVG9Ub3BDZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xyXG52YXIgR2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFRvcCcpO1xyXG52YXIgU2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRMZWZ0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgVG9Ub3BMZWZ0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldExlZnQoZ2FtZU9iamVjdCwgR2V0TGVmdChwYXJlbnQpIC0gb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0VG9wKHBhcmVudCkgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Ub3BMZWZ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FsaWduL1RvVG9wTGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMTAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgVG9Ub3BSaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0VG9wKHBhcmVudCkgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Ub3BSaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub1RvcFJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuVXRpbHMuQWxpZ25cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluQm90dG9tQ2VudGVyOiByZXF1aXJlKCcuL0luQm90dG9tQ2VudGVyJyksXHJcbiAgICBJbkJvdHRvbUxlZnQ6IHJlcXVpcmUoJy4vSW5Cb3R0b21MZWZ0JyksXHJcbiAgICBJbkJvdHRvbVJpZ2h0OiByZXF1aXJlKCcuL0luQm90dG9tUmlnaHQnKSxcclxuICAgIEluQ2VudGVyOiByZXF1aXJlKCcuL0luQ2VudGVyJyksXHJcbiAgICBJbkxlZnRDZW50ZXI6IHJlcXVpcmUoJy4vSW5MZWZ0Q2VudGVyJyksXHJcbiAgICBJblJpZ2h0Q2VudGVyOiByZXF1aXJlKCcuL0luUmlnaHRDZW50ZXInKSxcclxuICAgIEluVG9wQ2VudGVyOiByZXF1aXJlKCcuL0luVG9wQ2VudGVyJyksXHJcbiAgICBJblRvcExlZnQ6IHJlcXVpcmUoJy4vSW5Ub3BMZWZ0JyksXHJcbiAgICBJblRvcFJpZ2h0OiByZXF1aXJlKCcuL0luVG9wUmlnaHQnKSxcclxuICAgIFRvQm90dG9tQ2VudGVyOiByZXF1aXJlKCcuL1RvQm90dG9tQ2VudGVyJyksXHJcbiAgICBUb0JvdHRvbUxlZnQ6IHJlcXVpcmUoJy4vVG9Cb3R0b21MZWZ0JyksXHJcbiAgICBUb0JvdHRvbVJpZ2h0OiByZXF1aXJlKCcuL1RvQm90dG9tUmlnaHQnKSxcclxuICAgIFRvTGVmdEJvdHRvbTogcmVxdWlyZSgnLi9Ub0xlZnRCb3R0b20nKSxcclxuICAgIFRvTGVmdENlbnRlcjogcmVxdWlyZSgnLi9Ub0xlZnRDZW50ZXInKSxcclxuICAgIFRvTGVmdFRvcDogcmVxdWlyZSgnLi9Ub0xlZnRUb3AnKSxcclxuICAgIFRvUmlnaHRCb3R0b206IHJlcXVpcmUoJy4vVG9SaWdodEJvdHRvbScpLFxyXG4gICAgVG9SaWdodENlbnRlcjogcmVxdWlyZSgnLi9Ub1JpZ2h0Q2VudGVyJyksXHJcbiAgICBUb1JpZ2h0VG9wOiByZXF1aXJlKCcuL1RvUmlnaHRUb3AnKSxcclxuICAgIFRvVG9wQ2VudGVyOiByZXF1aXJlKCcuL1RvVG9wQ2VudGVyJyksXHJcbiAgICBUb1RvcExlZnQ6IHJlcXVpcmUoJy4vVG9Ub3BMZWZ0JyksXHJcbiAgICBUb1RvcFJpZ2h0OiByZXF1aXJlKCcuL1RvVG9wUmlnaHQnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBTbmFwcyBhIHZhbHVlIHRvIHRoZSBuZWFyZXN0IHZhbHVlIGluIGFuIGFycmF5LlxyXG4qIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgaW4gdGhlIHJhbmdlIGBbZmlyc3RfdmFsdWUsIGxhc3RfdmFsdWVdYC5cclxuKlxyXG4qIEBtZXRob2RcclxuKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgc2VhcmNoIHZhbHVlXHJcbiogQHBhcmFtIHtudW1iZXJbXX0gYXJyIC0gVGhlIGlucHV0IGFycmF5IHdoaWNoIF9tdXN0XyBiZSBzb3J0ZWQuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgbmVhcmVzdCB2YWx1ZSBmb3VuZC5cclxuKi9cclxudmFyIEZpbmRDbG9zZXN0SW5Tb3J0ZWQgPSBmdW5jdGlvbiAodmFsdWUsIGFycmF5KVxyXG57XHJcbiAgICBpZiAoIWFycmF5Lmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXJyYXkubGVuZ3RoID09PSAxIHx8IHZhbHVlIDwgYXJyYXlbMF0pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpID0gMTtcclxuXHJcbiAgICB3aGlsZSAoYXJyYXlbaV0gPCB2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxvdyA9IGFycmF5W2kgLSAxXTtcclxuICAgIHZhciBoaWdoID0gKGkgPCBhcnJheS5sZW5ndGgpID8gYXJyYXlbaV0gOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblxyXG4gICAgcmV0dXJuICgoaGlnaCAtIHZhbHVlKSA8PSAodmFsdWUgLSBsb3cpKSA/IGhpZ2ggOiBsb3c7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpbmRDbG9zZXN0SW5Tb3J0ZWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYXJyYXkvRmluZENsb3Nlc3RJblNvcnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBGZXRjaCBhIHJhbmRvbSBlbnRyeSBmcm9tIHRoZSBnaXZlbiBhcnJheS5cclxuKlxyXG4qIFdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgYXJlIG5vIGFycmF5IGl0ZW1zIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHNwZWNpZmllZCByYW5nZVxyXG4qIG9yIGlmIHRoZXJlIGlzIG5vIGl0ZW0gZm9yIHRoZSByYW5kb21seSBjaG9zZW4gaW5kZXguXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHthbnlbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydEluZGV4IC0gT3B0aW9uYWwgb2Zmc2V0IG9mZiB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LiBEZWZhdWx0IHZhbHVlIGlzIDAsIG9yIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIC0gT3B0aW9uYWwgcmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiB2YWx1ZXMgeW91IHdhbnQgdG8gcmFuZG9tbHkgc2VsZWN0IGZyb20uXHJcbiogQHJldHVybiB7b2JqZWN0fSBUaGUgcmFuZG9tIG9iamVjdCB0aGF0IHdhcyBzZWxlY3RlZC5cclxuKi9cclxuXHJcbnZhciBHZXRSYW5kb21FbGVtZW50ID0gZnVuY3Rpb24gKGFycmF5LCBzdGFydCwgbGVuZ3RoKVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSBhcnJheS5sZW5ndGg7IH1cclxuXHJcbiAgICB2YXIgcmFuZG9tSW5kZXggPSBzdGFydCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCk7XHJcblxyXG4gICAgcmV0dXJuIChhcnJheVtyYW5kb21JbmRleF0gPT09IHVuZGVmaW5lZCkgPyBudWxsIDogYXJyYXlbcmFuZG9tSW5kZXhdO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRSYW5kb21FbGVtZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FycmF5L0dldFJhbmRvbUVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEwMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJvdW5kQXdheUZyb21aZXJvID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9Sb3VuZEF3YXlGcm9tWmVybycpO1xyXG5cclxuLyoqXHJcbiogQ3JlYXRlIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbSBgc3RhcnRgXHJcbiogdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgYGVuZGAgYnkgYWR2YW5jaW5nIGJ5IGBzdGVwYC5cclxuKlxyXG4qIElmIGBzdGFydGAgaXMgbGVzcyB0aGFuIGBlbmRgIGEgemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxyXG4qXHJcbiogQ2VydGFpbiB2YWx1ZXMgZm9yIGBzdGFydGAgYW5kIGBlbmRgIChlZy4gTmFOL3VuZGVmaW5lZC9udWxsKSBhcmUgY3VycmVudGx5IGNvZXJjZWQgdG8gMDtcclxuKiBmb3IgZm9yd2FyZCBjb21wYXRpYmlsaXR5IG1ha2Ugc3VyZSB0byBwYXNzIGluIGFjdHVhbCBudW1iZXJzLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQXJyYXlVdGlscyNudW1iZXJBcnJheVN0ZXBcclxuKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbZW5kXSAtIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSAtIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxyXG4qIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIG51bWJlcnMuXHJcbiogQGV4YW1wbGVcclxuKiBOdW1iZXJBcnJheVN0ZXAoNCk7XHJcbiogLy8gPT4gWzAsIDEsIDIsIDNdXHJcbipcclxuKiBOdW1iZXJBcnJheVN0ZXAoMSwgNSk7XHJcbiogLy8gPT4gWzEsIDIsIDMsIDRdXHJcbipcclxuKiBOdW1iZXJBcnJheVN0ZXAoMCwgMjAsIDUpO1xyXG4qIC8vID0+IFswLCA1LCAxMCwgMTVdXHJcbipcclxuKiBOdW1iZXJBcnJheVN0ZXAoMCwgLTQsIC0xKTtcclxuKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cclxuKlxyXG4qIE51bWJlckFycmF5U3RlcCgxLCA0LCAwKTtcclxuKiAvLyA9PiBbMSwgMSwgMV1cclxuKlxyXG4qIE51bWJlckFycmF5U3RlcCgwKTtcclxuKiAvLyA9PiBbXVxyXG4qL1xyXG52YXIgTnVtYmVyQXJyYXlTdGVwID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0ZXApXHJcbntcclxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxyXG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7IGVuZCA9IG51bGw7IH1cclxuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDE7IH1cclxuXHJcbiAgICBpZiAoZW5kID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIGVuZCA9IHN0YXJ0O1xyXG4gICAgICAgIHN0YXJ0ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgdmFyIHRvdGFsID0gTWF0aC5tYXgoUm91bmRBd2F5RnJvbVplcm8oKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHN0YXJ0KTtcclxuICAgICAgICBzdGFydCArPSBzdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlckFycmF5U3RlcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9OdW1iZXJBcnJheVN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDEwMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNwbGljZU9uZSA9IHJlcXVpcmUoJy4vU3BsaWNlT25lJyk7XHJcblxyXG4vKipcclxuKiBSZW1vdmVzIGEgcmFuZG9tIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheSBhbmQgcmV0dXJucyBpdC5cclxuKlxyXG4qIFdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgYXJlIG5vIGFycmF5IGl0ZW1zIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHNwZWNpZmllZCByYW5nZVxyXG4qIG9yIGlmIHRoZXJlIGlzIG5vIGl0ZW0gZm9yIHRoZSByYW5kb21seSBjaG9zZW4gaW5kZXguXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHthbnlbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydEluZGV4IC0gT3B0aW9uYWwgb2Zmc2V0IG9mZiB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LiBEZWZhdWx0IHZhbHVlIGlzIDAsIG9yIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIC0gT3B0aW9uYWwgcmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiB2YWx1ZXMgeW91IHdhbnQgdG8gcmFuZG9tbHkgc2VsZWN0IGZyb20uXHJcbiogQHJldHVybiB7b2JqZWN0fSBUaGUgcmFuZG9tIG9iamVjdCB0aGF0IHdhcyByZW1vdmVkLlxyXG4qL1xyXG5cclxudmFyIFJlbW92ZVJhbmRvbUVsZW1lbnQgPSBmdW5jdGlvbiAoYXJyYXksIHN0YXJ0LCBsZW5ndGgpXHJcbntcclxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxyXG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgfVxyXG5cclxuICAgIHZhciByYW5kb21JbmRleCA9IHN0YXJ0ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuZ3RoKTtcclxuXHJcbiAgICByZXR1cm4gU3BsaWNlT25lKGFycmF5LCByYW5kb21JbmRleCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW92ZVJhbmRvbUVsZW1lbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYXJyYXkvUmVtb3ZlUmFuZG9tRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlV0aWxzLkFycmF5XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBGaW5kQ2xvc2VzdEluU29ydGVkOiByZXF1aXJlKCcuL0ZpbmRDbG9zZXN0SW5Tb3J0ZWQnKSxcclxuICAgIEdldFJhbmRvbUVsZW1lbnQ6IHJlcXVpcmUoJy4vR2V0UmFuZG9tRWxlbWVudCcpLFxyXG4gICAgTnVtYmVyQXJyYXk6IHJlcXVpcmUoJy4vTnVtYmVyQXJyYXknKSxcclxuICAgIE51bWJlckFycmF5U3RlcDogcmVxdWlyZSgnLi9OdW1iZXJBcnJheVN0ZXAnKSxcclxuICAgIFF1aWNrU2VsZWN0OiByZXF1aXJlKCcuL1F1aWNrU2VsZWN0JyksXHJcbiAgICBSYW5nZTogcmVxdWlyZSgnLi9SYW5nZScpLFxyXG4gICAgUmVtb3ZlUmFuZG9tRWxlbWVudDogcmVxdWlyZSgnLi9SZW1vdmVSYW5kb21FbGVtZW50JyksXHJcbiAgICBSb3RhdGVMZWZ0OiByZXF1aXJlKCcuL1JvdGF0ZUxlZnQnKSxcclxuICAgIFJvdGF0ZVJpZ2h0OiByZXF1aXJlKCcuL1JvdGF0ZVJpZ2h0JyksXHJcbiAgICBTaHVmZmxlOiByZXF1aXJlKCcuL1NodWZmbGUnKSxcclxuICAgIFNwbGljZU9uZTogcmVxdWlyZSgnLi9TcGxpY2VPbmUnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYW1vdW50IHRoZSBHYW1lIE9iamVjdCBpcyB2aXN1YWxseSBvZmZzZXQgZnJvbSBpdHMgeCBjb29yZGluYXRlLlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHdpZHRoICogb3JpZ2luLnhgLlxyXG4qIEl0IHdpbGwgb25seSBiZSA+IDAgaWYgb3JpZ2luLnggaXMgbm90IGVxdWFsIHRvIHplcm8uXHJcbipcclxuKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0WFxyXG4qIEByZWFkT25seVxyXG4qL1xyXG5cclxudmFyIEdldE9mZnNldFggPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxue1xyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Qud2lkdGggKiBnYW1lT2JqZWN0Lm9yaWdpblg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE9mZnNldFg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL0dldE9mZnNldFguanNcbi8vIG1vZHVsZSBpZCA9IDEwMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGFtb3VudCB0aGUgR2FtZSBPYmplY3QgaXMgdmlzdWFsbHkgb2Zmc2V0IGZyb20gaXRzIHggY29vcmRpbmF0ZS5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB3aWR0aCAqIG9yaWdpbi54YC5cclxuKiBJdCB3aWxsIG9ubHkgYmUgPiAwIGlmIG9yaWdpbi54IGlzIG5vdCBlcXVhbCB0byB6ZXJvLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFhcclxuKiBAcmVhZE9ubHlcclxuKi9cclxuXHJcbnZhciBHZXRPZmZzZXRZID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHJldHVybiBnYW1lT2JqZWN0LmhlaWdodCAqIGdhbWVPYmplY3Qub3JpZ2luWTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0T2Zmc2V0WTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9ib3VuZHMvR2V0T2Zmc2V0WS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlV0aWxzLkJvdW5kc1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2VudGVyT246IHJlcXVpcmUoJy4vQ2VudGVyT24nKSxcclxuICAgIEdldEJvdHRvbTogcmVxdWlyZSgnLi9HZXRCb3R0b20nKSxcclxuICAgIEdldENlbnRlclg6IHJlcXVpcmUoJy4vR2V0Q2VudGVyWCcpLFxyXG4gICAgR2V0Q2VudGVyWTogcmVxdWlyZSgnLi9HZXRDZW50ZXJZJyksXHJcbiAgICBHZXRMZWZ0OiByZXF1aXJlKCcuL0dldExlZnQnKSxcclxuICAgIEdldE9mZnNldFg6IHJlcXVpcmUoJy4vR2V0T2Zmc2V0WCcpLFxyXG4gICAgR2V0T2Zmc2V0WTogcmVxdWlyZSgnLi9HZXRPZmZzZXRZJyksXHJcbiAgICBHZXRSaWdodDogcmVxdWlyZSgnLi9HZXRSaWdodCcpLFxyXG4gICAgR2V0VG9wOiByZXF1aXJlKCcuL0dldFRvcCcpLFxyXG4gICAgU2V0Qm90dG9tOiByZXF1aXJlKCcuL1NldEJvdHRvbScpLFxyXG4gICAgU2V0Q2VudGVyWDogcmVxdWlyZSgnLi9TZXRDZW50ZXJYJyksXHJcbiAgICBTZXRDZW50ZXJZOiByZXF1aXJlKCcuL1NldENlbnRlclknKSxcclxuICAgIFNldExlZnQ6IHJlcXVpcmUoJy4vU2V0TGVmdCcpLFxyXG4gICAgU2V0UmlnaHQ6IHJlcXVpcmUoJy4vU2V0UmlnaHQnKSxcclxuICAgIFNldFRvcDogcmVxdWlyZSgnLi9TZXRUb3AnKVxyXG4gICAgXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4vR2V0VmFsdWUnKTtcclxudmFyIENsYW1wID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9DbGFtcCcpO1xyXG5cclxudmFyIEdldE1pbk1heFZhbHVlID0gZnVuY3Rpb24gKHNvdXJjZSwga2V5LCBtaW4sIG1heCwgZGVmYXVsdFZhbHVlKVxyXG57XHJcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHsgZGVmYXVsdFZhbHVlID0gbWluOyB9XHJcblxyXG4gICAgdmFyIHZhbHVlID0gR2V0VmFsdWUoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSk7XHJcblxyXG4gICAgcmV0dXJuIENsYW1wKHZhbHVlLCBtaW4sIG1heCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE1pbk1heFZhbHVlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL29iamVjdC9HZXRNaW5NYXhWYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQ3JlYXRlcyBhIG5ldyBPYmplY3QgdXNpbmcgYWxsIHZhbHVlcyBmcm9tIG9iajEuXHJcbi8vICBcclxuLy8gIFRoZW4gc2NhbnMgb2JqMi4gSWYgYSBwcm9wZXJ0eSBpcyBmb3VuZCBpbiBvYmoyIHRoYXQgKmFsc28qIGV4aXN0cyBpbiBvYmoxLFxyXG4vLyAgdGhlIHZhbHVlIGZyb20gb2JqMiBpcyB1c2VkLCBvdGhlcndpc2UgdGhlIHByb3BlcnR5IGlzIHNraXBwZWQuXHJcblxyXG52YXIgQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcblxyXG52YXIgTWVyZ2VSaWdodCA9IGZ1bmN0aW9uIChvYmoxLCBvYmoyKVxyXG57XHJcbiAgICB2YXIgY2xvbmUgPSBDbG9uZShvYmoxKTtcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqMilcclxuICAgIHtcclxuICAgICAgICBpZiAoY2xvbmUuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNsb25lW2tleV0gPSBvYmoyW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbG9uZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVyZ2VSaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9vYmplY3QvTWVyZ2VSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMTA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlV0aWxzLk9iamVjdFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2xvbmU6IHJlcXVpcmUoJy4vQ2xvbmUnKSxcclxuICAgIEV4dGVuZDogcmVxdWlyZSgnLi9FeHRlbmQnKSxcclxuICAgIEdldEFkdmFuY2VkVmFsdWU6IHJlcXVpcmUoJy4vR2V0QWR2YW5jZWRWYWx1ZScpLFxyXG4gICAgR2V0RmFzdFZhbHVlOiByZXF1aXJlKCcuL0dldEZhc3RWYWx1ZScpLFxyXG4gICAgR2V0TWluTWF4VmFsdWU6IHJlcXVpcmUoJy4vR2V0TWluTWF4VmFsdWUnKSxcclxuICAgIEdldFZhbHVlOiByZXF1aXJlKCcuL0dldFZhbHVlJyksXHJcbiAgICBJc1BsYWluT2JqZWN0OiByZXF1aXJlKCcuL0lzUGxhaW5PYmplY3QnKSxcclxuICAgIE1lcmdlOiByZXF1aXJlKCcuL01lcmdlJyksXHJcbiAgICBNZXJnZVJpZ2h0OiByZXF1aXJlKCcuL01lcmdlUmlnaHQnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9vYmplY3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIFJlcGxhY2VzICUxLCAlMiwgJTMgZXRjIGluIHRoZSBTdHJpbmcgd2l0aCB0aGUgdmFsdWVzXHJcbiAqIGdpdmVuIGluIHRoZSBhcnJheS4gVmFsdWVzIGFyZSBjYXN0IHRvIHN0cmluZ3MuXHJcbiAqIElmIG5vIHZhbHVlIGV4aXN0cyBhbiBlbXB0eSBzdHJpbmcgaXMgaW5zZXJ0ZWQuXHJcbiAqIFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBtYXJrZXJzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHZhbHVlcyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyB0byByZXBsYWNlIHRoZSBtYXJrZXJzIHdpdGhcclxuKi9cclxudmFyIEZvcm1hdCA9IGZ1bmN0aW9uIChzdHJpbmcsIHZhbHVlcylcclxue1xyXG4gICAgc3RyaW5nLnJlcGxhY2UoLyUoWzAtOV0rKS9nLCBmdW5jdGlvbiAocywgbilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdmFsdWVzW051bWJlcihuKSAtIDFdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHN0cmluZztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRm9ybWF0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL3N0cmluZy9Gb3JtYXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGFrZXMgdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV2ZXJzZXMgaXQsIHJldHVybmluZyB0aGUgcmV2ZXJzZWQgc3RyaW5nLlxyXG4qIEZvciBleGFtcGxlIGlmIGdpdmVuIHRoZSBzdHJpbmcgYEF0YXJpIDUyMFNUYCBpdCB3b3VsZCByZXR1cm4gYFRTMDI1IGlyYXRBYC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlV0aWxzLnJldmVyc2VTdHJpbmdcclxuKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIHN0cmluZyB0byBiZSByZXZlcnNlZC5cclxuKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSByZXZlcnNlZCBzdHJpbmcuXHJcbiovXHJcbnZhciBSZXZlcnNlU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZylcclxue1xyXG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXZlcnNlU3RyaW5nO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL3N0cmluZy9SZXZlcnNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIFBhZDogcmVxdWlyZSgnLi9QYWQnKSxcclxuICAgIEZvcm1hdDogcmVxdWlyZSgnLi9Gb3JtYXQnKSxcclxuICAgIFJldmVyc2U6IHJlcXVpcmUoJy4vUmV2ZXJzZScpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL3N0cmluZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9