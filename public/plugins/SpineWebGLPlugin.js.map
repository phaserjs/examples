{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///D:/wamp/www/phaser/node_modules/eventemitter3/index.js","webpack:///D:/wamp/www/phaser/src/data/DataManager.js","webpack:///D:/wamp/www/phaser/src/gameobjects/GameObject.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Alpha.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/BlendMode.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Depth.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Flip.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/ScrollFactor.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/ToJSON.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Transform.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/TransformMatrix.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Visible.js","webpack:///D:/wamp/www/phaser/src/loader/File.js","webpack:///D:/wamp/www/phaser/src/loader/FileTypesManager.js","webpack:///D:/wamp/www/phaser/src/loader/GetURL.js","webpack:///D:/wamp/www/phaser/src/loader/MergeXHRSettings.js","webpack:///D:/wamp/www/phaser/src/loader/MultiFile.js","webpack:///D:/wamp/www/phaser/src/loader/XHRLoader.js","webpack:///D:/wamp/www/phaser/src/loader/XHRSettings.js","webpack:///D:/wamp/www/phaser/src/loader/const.js","webpack:///D:/wamp/www/phaser/src/loader/filetypes/ImageFile.js","webpack:///D:/wamp/www/phaser/src/loader/filetypes/JSONFile.js","webpack:///D:/wamp/www/phaser/src/loader/filetypes/TextFile.js","webpack:///D:/wamp/www/phaser/src/math/Clamp.js","webpack:///D:/wamp/www/phaser/src/math/Matrix4.js","webpack:///D:/wamp/www/phaser/src/math/Vector2.js","webpack:///D:/wamp/www/phaser/src/math/Wrap.js","webpack:///D:/wamp/www/phaser/src/math/angle/CounterClockwise.js","webpack:///D:/wamp/www/phaser/src/math/angle/Wrap.js","webpack:///D:/wamp/www/phaser/src/math/angle/WrapDegrees.js","webpack:///D:/wamp/www/phaser/src/math/const.js","webpack:///D:/wamp/www/phaser/src/plugins/BasePlugin.js","webpack:///D:/wamp/www/phaser/src/plugins/ScenePlugin.js","webpack:///D:/wamp/www/phaser/src/renderer/BlendModes.js","webpack:///D:/wamp/www/phaser/src/utils/Class.js","webpack:///D:/wamp/www/phaser/src/utils/NOOP.js","webpack:///D:/wamp/www/phaser/src/utils/object/Extend.js","webpack:///D:/wamp/www/phaser/src/utils/object/GetFastValue.js","webpack:///D:/wamp/www/phaser/src/utils/object/GetValue.js","webpack:///D:/wamp/www/phaser/src/utils/object/IsPlainObject.js","webpack:///./BaseSpinePlugin.js","webpack:///./SpineFile.js","webpack:///./SpineWebGLPlugin.js","webpack:///./gameobject/SpineGameObject.js","webpack:///./gameobject/SpineGameObjectRender.js","webpack:///./gameobject/SpineGameObjectWebGLRenderer.js","webpack:///./runtimes/spine-webgl.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yDAAyD,OAAO;AAChE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,eAAe,YAAY;AAC3B;;AAEA;AACA,2DAA2D;AAC3D,+DAA+D;AAC/D,mEAAmE;AACnE,uEAAuE;AACvE;AACA,0DAA0D,SAAS;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/UA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,2BAA2B;AACtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAA2D;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,EAAE;AACjB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,EAAE;AACjB,eAAe,KAAK;AACpB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,QAAQ;AACvB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA,sCAAsC,kBAAkB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC7mBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAA2D;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,EAAE;AACjB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAsC;AACrD,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,sCAAsC,mBAAmB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChlBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,oCAAoC,aAAa;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;AChSA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACjHA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACtFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC7IA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACpGA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,kCAAkC,0CAA0C;AAC5E,mCAAmC,4CAA4C;;AAE/E;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,oCAAoC,aAAa;;AAEjD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,oCAAoC,aAAa;;AAEjD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA,uCAAuC,oCAAoC;;AAE3E;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA,uCAAuC,oCAAoC;AAC3E,yCAAyC,sCAAsC;;AAE/E;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC7cA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,+BAA+B,QAAQ;AACvC,+BAA+B,QAAQ;;AAEvC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,+CAA+C;AAC9D;AACA,gBAAgB,+CAA+C;AAC/D;AACA;AACA;AACA,kCAAkC,UAAU,cAAc;;AAE1D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,mCAAmC,wBAAwB;;AAE3D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACx5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AClFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,2BAA2B;AACzC,cAAc,0BAA0B;AACxC,cAAc,IAAI;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,WAAW;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,4GAA4G;AAC5G;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,IAAI;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,eAAe,IAAI;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;;AAEnD;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE;AACjE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9kBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC1DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC3LA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,kBAAkB;AAC7B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC7DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,2BAA2B;AACzC,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD,8BAA8B,cAAc;AAC5C,6BAA6B,WAAW;AACxC,iCAAiC,eAAe;AAChD,gCAAgC,aAAa;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACvEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACjJA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;;AAEA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,yCAAyC;AACvD,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,iDAAiD;AAC5D,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B,WAAW,yCAAyC;AACpD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2FAA2F;AACtG,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;ACjSA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,cAAc,WAAW;AACzB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,gDAAgD;AAC3D,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,QAAQ;AACR,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yFAAyF;AACpG,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;ACzOA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,gDAAgD;AAC3D,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yFAAyF;AACpG,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;ACjLA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;;AAEA;;;;;;;;;;;;AC/6CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;;AAEzC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,6BAA6B,YAAY;;AAEzC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;;;;;;;;;;;ACjkBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AChEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC9KA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACjFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChJA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvOA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY,OAAO;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5FA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,8CAA8C,aAAa,qBAAqB;AAChF;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE,oBAAoB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;;AAEA;;;;;;;;;;;;ACjDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC7LA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,sDAAsD;AACjE,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,oBAAoB;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,qBAAqB;AACpD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2FAA2F;AACtG,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;ACpUA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACzFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACzSA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAEA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,mCAAmC;AAC9C,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC,WAAW,8CAA8C;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxHA;AACA;;AAEA;AACA;AACA,IAAI,gBAAgB,sCAAsC,iBAAiB,EAAE;AAC7E,mBAAmB,uDAAuD;AAC1E;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gDAAgD;AAClD;AACA;AACA;AACA;AACA,EAAE,+DAA+D;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,+DAA+D;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6CAA6C;AACtD;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yBAAyB,EAAE;AAChF;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,sDAAsD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,sDAAsD;AACxD,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kEAAkE;AACpE,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE,+DAA+D;AACjE;AACA;AACA;AACA;AACA;AACA,EAAE,4DAA4D;AAC9D;AACA;AACA;AACA;AACA;AACA,EAAE,yDAAyD;AAC3D,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA;AACA,kBAAkB,iCAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA,kBAAkB,eAAe;AACjC;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kEAAkE;AACpE;AACA;AACA;AACA;AACA;AACA,EAAE,4DAA4D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE,4DAA4D;AAC5D,+CAA+C;AAC/C;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,qEAAqE;AACvE,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,mDAAmD;AACnD;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wBAAwB;AACvE,6CAA6C,sDAAsD;AACnG,6CAA6C,qDAAqD;AAClG;AACA;AACA;AACA;AACA,6CAA6C,sBAAsB;AACnE,4CAA4C,4BAA4B;AACxE,4CAA4C,2BAA2B;AACvE;AACA;AACA;AACA;AACA,4CAA4C,qBAAqB;AACjE;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG,oFAAoF;AACvF,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,uBAAuB;AAC/E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,4BAA4B;AACpE,oCAAoC,qBAAqB;AACzD,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA,wCAAwC,4BAA4B;AACpE,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,wCAAwC,4BAA4B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,wCAAwC,4BAA4B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,4BAA4B,eAAe;AAC3C,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,4BAA4B,eAAe;AAC3C,4BAA4B,eAAe;AAC3C,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,yDAAyD;AAC5D,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE,mDAAmD,0BAA0B;AAC7E,qDAAqD,4BAA4B;AACjF,yDAAyD,sBAAsB;AAC/E,qDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,8CAA8C,kDAAkD,iDAAiD,+BAA+B,mCAAmC,0BAA0B,2CAA2C,mDAAmD,8EAA8E,WAAW;AACne,qGAAqG,2FAA2F,mCAAmC,sCAAsC,0BAA0B,uEAAuE,WAAW;AACrX;AACA;AACA;AACA,+DAA+D,8CAA8C,+CAA+C,kDAAkD,iDAAiD,+BAA+B,8BAA8B,mCAAmC,0BAA0B,2CAA2C,2CAA2C,mDAAmD,8EAA8E,WAAW;AAC3lB,qGAAqG,2FAA2F,mCAAmC,mCAAmC,sCAAsC,0BAA0B,8DAA8D,oDAAoD,8HAA8H,WAAW;AACjkB;AACA;AACA;AACA,+DAA+D,8CAA8C,iDAAiD,+BAA+B,0BAA0B,2CAA2C,8EAA8E,WAAW;AAC3V,qGAAqG,2FAA2F,0BAA0B,mCAAmC,WAAW;AACxQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,4BAA4B,eAAe;AAC3C,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,4BAA4B,eAAe;AAC3C,4BAA4B,eAAe;AAC3C,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,sDAAsD;AACzD,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,4BAA4B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAA0C;AAC5C,CAAC,sBAAsB;AACvB;;AAEA;AACA;AACA,CAAC,e","file":"SpineWebGLPlugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SpineWebGLPlugin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SpineWebGLPlugin\"] = factory();\n\telse\n\t\troot[\"SpineWebGLPlugin\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./SpineWebGLPlugin.js\");\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @callback DataEachCallback\r\n *\r\n * @param {*} parent - The parent object of the DataManager.\r\n * @param {string} key - The key of the value.\r\n * @param {*} value - The value.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * The Data Component features a means to store pieces of data specific to a Game Object, System or Plugin.\r\n * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,\r\n * or have a property called `events` that is an instance of it.\r\n *\r\n * @class DataManager\r\n * @memberof Phaser.Data\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} parent - The object that this DataManager belongs to.\r\n * @param {Phaser.Events.EventEmitter} eventEmitter - The DataManager's event emitter.\r\n */\r\nvar DataManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function DataManager (parent, eventEmitter)\r\n    {\r\n        /**\r\n         * The object that this DataManager belongs to.\r\n         *\r\n         * @name Phaser.Data.DataManager#parent\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.parent = parent;\r\n\r\n        /**\r\n         * The DataManager's event emitter.\r\n         *\r\n         * @name Phaser.Data.DataManager#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = eventEmitter;\r\n\r\n        if (!eventEmitter)\r\n        {\r\n            this.events = (parent.events) ? parent.events : parent;\r\n        }\r\n\r\n        /**\r\n         * The data list.\r\n         *\r\n         * @name Phaser.Data.DataManager#list\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.list = {};\r\n\r\n        /**\r\n         * The public values list. You can use this to access anything you have stored\r\n         * in this Data Manager. For example, if you set a value called `gold` you can\r\n         * access it via:\r\n         *\r\n         * ```javascript\r\n         * this.data.values.gold;\r\n         * ```\r\n         *\r\n         * You can also modify it directly:\r\n         * \r\n         * ```javascript\r\n         * this.data.values.gold += 1000;\r\n         * ```\r\n         *\r\n         * Doing so will emit a `setdata` event from the parent of this Data Manager.\r\n         * \r\n         * Do not modify this object directly. Adding properties directly to this object will not\r\n         * emit any events. Always use `DataManager.set` to create new items the first time around.\r\n         *\r\n         * @name Phaser.Data.DataManager#values\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.10.0\r\n         */\r\n        this.values = {};\r\n\r\n        /**\r\n         * Whether setting data is frozen for this DataManager.\r\n         *\r\n         * @name Phaser.Data.DataManager#_frozen\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._frozen = false;\r\n\r\n        if (!parent.hasOwnProperty('sys') && this.events)\r\n        {\r\n            this.events.once('destroy', this.destroy, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieves the value for the given key, or undefined if it doesn't exist.\r\n     *\r\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n     * \r\n     * ```javascript\r\n     * this.data.get('gold');\r\n     * ```\r\n     *\r\n     * Or access the value directly:\r\n     * \r\n     * ```javascript\r\n     * this.data.values.gold;\r\n     * ```\r\n     *\r\n     * You can also pass in an array of keys, in which case an array of values will be returned:\r\n     * \r\n     * ```javascript\r\n     * this.data.get([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * This approach is useful for destructuring arrays in ES6.\r\n     *\r\n     * @method Phaser.Data.DataManager#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n     *\r\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n     */\r\n    get: function (key)\r\n    {\r\n        var list = this.list;\r\n\r\n        if (Array.isArray(key))\r\n        {\r\n            var output = [];\r\n\r\n            for (var i = 0; i < key.length; i++)\r\n            {\r\n                output.push(list[key[i]]);\r\n            }\r\n\r\n            return output;\r\n        }\r\n        else\r\n        {\r\n            return list[key];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieves all data values in a new object.\r\n     *\r\n     * @method Phaser.Data.DataManager#getAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Object.<string, *>} All data values.\r\n     */\r\n    getAll: function ()\r\n    {\r\n        var results = {};\r\n\r\n        for (var key in this.list)\r\n        {\r\n            if (this.list.hasOwnProperty(key))\r\n            {\r\n                results[key] = this.list[key];\r\n            }\r\n        }\r\n\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Queries the DataManager for the values of keys matching the given regular expression.\r\n     *\r\n     * @method Phaser.Data.DataManager#query\r\n     * @since 3.0.0\r\n     *\r\n     * @param {RegExp} search - A regular expression object. If a non-RegExp object obj is passed, it is implicitly converted to a RegExp by using new RegExp(obj).\r\n     *\r\n     * @return {Object.<string, *>} The values of the keys matching the search string.\r\n     */\r\n    query: function (search)\r\n    {\r\n        var results = {};\r\n\r\n        for (var key in this.list)\r\n        {\r\n            if (this.list.hasOwnProperty(key) && key.match(search))\r\n            {\r\n                results[key] = this.list[key];\r\n            }\r\n        }\r\n\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Sets a value for the given key. If the key doesn't already exist in the Data Manager then it is created.\r\n     * \r\n     * ```javascript\r\n     * data.set('name', 'Red Gem Stone');\r\n     * ```\r\n     *\r\n     * You can also pass in an object of key value pairs as the first argument:\r\n     *\r\n     * ```javascript\r\n     * data.set({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n     * ```\r\n     *\r\n     * To get a value back again you can call `get`:\r\n     * \r\n     * ```javascript\r\n     * data.get('gold');\r\n     * ```\r\n     * \r\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n     * \r\n     * ```javascript\r\n     * data.values.gold += 50;\r\n     * ```\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted.\r\n     *\r\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata_PlayerLives`.\r\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n     *\r\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.Data.DataManager#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|object)} key - The key to set the value for. Or an object or key value pairs. If an object the `data` argument is ignored.\r\n     * @param {*} data - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    set: function (key, data)\r\n    {\r\n        if (this._frozen)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            return this.setValue(key, data);\r\n        }\r\n        else\r\n        {\r\n            for (var entry in key)\r\n            {\r\n                this.setValue(entry, key[entry]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal value setter, called automatically by the `set` method.\r\n     *\r\n     * @method Phaser.Data.DataManager#setValue\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The key to set the value for.\r\n     * @param {*} data - The value to set.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    setValue: function (key, data)\r\n    {\r\n        if (this._frozen)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.has(key))\r\n        {\r\n            //  Hit the key getter, which will in turn emit the events.\r\n            this.values[key] = data;\r\n        }\r\n        else\r\n        {\r\n            var _this = this;\r\n            var list = this.list;\r\n            var events = this.events;\r\n            var parent = this.parent;\r\n\r\n            Object.defineProperty(this.values, key, {\r\n\r\n                enumerable: true,\r\n                \r\n                configurable: true,\r\n\r\n                get: function ()\r\n                {\r\n                    return list[key];\r\n                },\r\n\r\n                set: function (value)\r\n                {\r\n                    if (!_this._frozen)\r\n                    {\r\n                        var previousValue = list[key];\r\n                        list[key] = value;\r\n\r\n                        events.emit('changedata', parent, key, value, previousValue);\r\n                        events.emit('changedata_' + key, parent, value, previousValue);\r\n                    }\r\n                }\r\n\r\n            });\r\n\r\n            list[key] = data;\r\n\r\n            events.emit('setdata', parent, key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes all data entries to the given callback.\r\n     *\r\n     * @method Phaser.Data.DataManager#each\r\n     * @since 3.0.0\r\n     *\r\n     * @param {DataEachCallback} callback - The function to call.\r\n     * @param {*} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    each: function (callback, context)\r\n    {\r\n        var args = [ this.parent, null, undefined ];\r\n\r\n        for (var i = 1; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (var key in this.list)\r\n        {\r\n            args[1] = key;\r\n            args[2] = this.list[key];\r\n\r\n            callback.apply(context, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Merge the given object of key value pairs into this DataManager.\r\n     *\r\n     * Any newly created values will emit a `setdata` event. Any updated values (see the `overwrite` argument)\r\n     * will emit a `changedata` event.\r\n     *\r\n     * @method Phaser.Data.DataManager#merge\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Object.<string, *>} data - The data to merge.\r\n     * @param {boolean} [overwrite=true] - Whether to overwrite existing data. Defaults to true.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    merge: function (data, overwrite)\r\n    {\r\n        if (overwrite === undefined) { overwrite = true; }\r\n\r\n        //  Merge data from another component into this one\r\n        for (var key in data)\r\n        {\r\n            if (data.hasOwnProperty(key) && (overwrite || (!overwrite && !this.has(key))))\r\n            {\r\n                this.setValue(key, data[key]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Remove the value for the given key.\r\n     *\r\n     * If the key is found in this Data Manager it is removed from the internal lists and a\r\n     * `removedata` event is emitted.\r\n     * \r\n     * You can also pass in an array of keys, in which case all keys in the array will be removed:\r\n     * \r\n     * ```javascript\r\n     * this.data.remove([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * @method Phaser.Data.DataManager#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key to remove, or an array of keys to remove.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (this._frozen)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (Array.isArray(key))\r\n        {\r\n            for (var i = 0; i < key.length; i++)\r\n            {\r\n                this.removeValue(key[i]);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return this.removeValue(key);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal value remover, called automatically by the `remove` method.\r\n     *\r\n     * @method Phaser.Data.DataManager#removeValue\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The key to set the value for.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    removeValue: function (key)\r\n    {\r\n        if (this.has(key))\r\n        {\r\n            var data = this.list[key];\r\n\r\n            delete this.list[key];\r\n            delete this.values[key];\r\n\r\n            this.events.emit('removedata', this.parent, key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the data associated with the given 'key', deletes it from this Data Manager, then returns it.\r\n     *\r\n     * @method Phaser.Data.DataManager#pop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the value to retrieve and delete.\r\n     *\r\n     * @return {*} The value of the given key.\r\n     */\r\n    pop: function (key)\r\n    {\r\n        var data = undefined;\r\n\r\n        if (!this._frozen && this.has(key))\r\n        {\r\n            data = this.list[key];\r\n\r\n            delete this.list[key];\r\n            delete this.values[key];\r\n\r\n            this.events.emit('removedata', this, key, data);\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    /**\r\n     * Determines whether the given key is set in this Data Manager.\r\n     * \r\n     * Please note that the keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.Data.DataManager#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to check.\r\n     *\r\n     * @return {boolean} Returns `true` if the key exists, otherwise `false`.\r\n     */\r\n    has: function (key)\r\n    {\r\n        return this.list.hasOwnProperty(key);\r\n    },\r\n\r\n    /**\r\n     * Freeze or unfreeze this Data Manager. A frozen Data Manager will block all attempts\r\n     * to create new values or update existing ones.\r\n     *\r\n     * @method Phaser.Data.DataManager#setFreeze\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - Whether to freeze or unfreeze the Data Manager.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    setFreeze: function (value)\r\n    {\r\n        this._frozen = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Delete all data in this Data Manager and unfreeze it.\r\n     *\r\n     * @method Phaser.Data.DataManager#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    reset: function ()\r\n    {\r\n        for (var key in this.list)\r\n        {\r\n            delete this.list[key];\r\n            delete this.values[key];\r\n        }\r\n\r\n        this._frozen = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy this data manager.\r\n     *\r\n     * @method Phaser.Data.DataManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.events.off('changedata');\r\n        this.events.off('setdata');\r\n        this.events.off('removedata');\r\n\r\n        this.parent = null;\r\n    },\r\n\r\n    /**\r\n     * Gets or sets the frozen state of this Data Manager.\r\n     * A frozen Data Manager will block all attempts to create new values or update existing ones.\r\n     *\r\n     * @name Phaser.Data.DataManager#freeze\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    freeze: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._frozen;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._frozen = (value) ? true : false;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Return the total number of entries in this Data Manager.\r\n     *\r\n     * @name Phaser.Data.DataManager#count\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    count: {\r\n\r\n        get: function ()\r\n        {\r\n            var i = 0;\r\n\r\n            for (var key in this.list)\r\n            {\r\n                if (this.list[key] !== undefined)\r\n                {\r\n                    i++;\r\n                }\r\n            }\r\n\r\n            return i;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = DataManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar ComponentsToJSON = require('./components/ToJSON');\r\nvar DataManager = require('../data/DataManager');\r\nvar EventEmitter = require('eventemitter3');\r\n\r\n/**\r\n * @classdesc\r\n * The base class that all Game Objects extend.\r\n * You don't create GameObjects directly and they cannot be added to the display list.\r\n * Instead, use them as the base for your own custom classes.\r\n *\r\n * @class GameObject\r\n * @memberof Phaser.GameObjects\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {string} type - A textual representation of the type of Game Object, i.e. `sprite`.\r\n */\r\nvar GameObject = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function GameObject (scene, type)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Scene to which this Game Object belongs.\r\n         * Game Objects can only belong to one Scene.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#scene\r\n         * @type {Phaser.Scene}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A textual representation of this Game Object, i.e. `sprite`.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * The parent Container of this Game Object, if it has one.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#parentContainer\r\n         * @type {Phaser.GameObjects.Container}\r\n         * @since 3.4.0\r\n         */\r\n        this.parentContainer = null;\r\n\r\n        /**\r\n         * The name of this Game Object.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The active state of this Game Object.\r\n         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.\r\n         * An active object is one which is having its logic and internal systems updated.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * The Tab Index of the Game Object.\r\n         * Reserved for future use by plugins and the Input Manager.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#tabIndex\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.tabIndex = -1;\r\n\r\n        /**\r\n         * A Data Manager.\r\n         * It allows you to store, query and get key/value paired information specific to this Game Object.\r\n         * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#data\r\n         * @type {Phaser.Data.DataManager}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.data = null;\r\n\r\n        /**\r\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\r\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\r\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#renderFlags\r\n         * @type {integer}\r\n         * @default 15\r\n         * @since 3.0.0\r\n         */\r\n        this.renderFlags = 15;\r\n\r\n        /**\r\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\r\n         * Not usually set directly, instead call `Camera.ignore`, however you can\r\n         * set this property directly using the Camera.id property:\r\n         *\r\n         * @example\r\n         * this.cameraFilter |= camera.id\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#cameraFilter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.cameraFilter = 0;\r\n\r\n        /**\r\n         * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.\r\n         * Not usually set directly. Instead call `GameObject.setInteractive()`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#input\r\n         * @type {?Phaser.Input.InteractiveObject}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.input = null;\r\n\r\n        /**\r\n         * If this Game Object is enabled for physics then this property will contain a reference to a Physics Body.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#body\r\n         * @type {?(object|Phaser.Physics.Arcade.Body|Phaser.Physics.Impact.Body)}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.body = null;\r\n\r\n        /**\r\n         * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.\r\n         * This includes calls that may come from a Group, Container or the Scene itself.\r\n         * While it allows you to persist a Game Object across Scenes, please understand you are entirely\r\n         * responsible for managing references to and from this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#ignoreDestroy\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.5.0\r\n         */\r\n        this.ignoreDestroy = false;\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        scene.sys.queueDepthSort();\r\n    },\r\n\r\n    /**\r\n     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.\r\n     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - True if this Game Object should be set as active, false if not.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setActive: function (value)\r\n    {\r\n        this.active = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.\r\n     * The `name` property is not populated by Phaser and is presented for your own use.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} value - The name to be given to this Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setName: function (value)\r\n    {\r\n        this.name = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a Data Manager component to this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setDataEnabled\r\n     * @since 3.0.0\r\n     * @see Phaser.Data.DataManager\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setDataEnabled: function ()\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Allows you to store a key value pair within this Game Objects Data Manager.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * ```javascript\r\n     * sprite.setData('name', 'Red Gem Stone');\r\n     * ```\r\n     *\r\n     * You can also pass in an object of key value pairs as the first argument:\r\n     *\r\n     * ```javascript\r\n     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n     * ```\r\n     *\r\n     * To get a value back again you can call `getData`:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold += 50;\r\n     * ```\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata_PlayerLives`.\r\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n     *\r\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|object)} key - The key to set the value for. Or an object or key value pairs. If an object the `data` argument is ignored.\r\n     * @param {*} data - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setData: function (key, value)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.set(key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.\r\n     *\r\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or access the value directly:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold;\r\n     * ```\r\n     *\r\n     * You can also pass in an array of keys, in which case an array of values will be returned:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * This approach is useful for destructuring arrays in ES6.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n     *\r\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n     */\r\n    getData: function (key)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this.data.get(key);\r\n    },\r\n\r\n    /**\r\n     * Pass this Game Object to the Input Manager to enable it for Input.\r\n     *\r\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n     * input detection.\r\n     *\r\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n     * shape for it to use.\r\n     *\r\n     * You can also provide an Input Configuration Object as the only argument to this method.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setInteractive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {HitAreaCallback} [callback] - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\r\n     * @param {boolean} [dropZone=false] - Should this Game Object be treated as a drop zone target?\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setInteractive: function (shape, callback, dropZone)\r\n    {\r\n        this.scene.sys.input.enable(this, shape, callback, dropZone);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Game Object has previously been enabled for input, this will disable it.\r\n     *\r\n     * An object that is disabled for input stops processing or being considered for\r\n     * input events, but can be turned back on again at any time by simply calling\r\n     * `setInteractive()` with no arguments provided.\r\n     *\r\n     * If want to completely remove interaction from this Game Object then use `removeInteractive` instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#disableInteractive\r\n     * @since 3.7.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    disableInteractive: function ()\r\n    {\r\n        if (this.input)\r\n        {\r\n            this.input.enabled = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Game Object has previously been enabled for input, this will queue it\r\n     * for removal, causing it to no longer be interactive. The removal happens on\r\n     * the next game step, it is not immediate.\r\n     *\r\n     * The Interactive Object that was assigned to this Game Object will be destroyed,\r\n     * removed from the Input Manager and cleared from this Game Object.\r\n     *\r\n     * If you wish to re-enable this Game Object at a later date you will need to\r\n     * re-create its InteractiveObject by calling `setInteractive` again.\r\n     *\r\n     * If you wish to only temporarily stop an object from receiving input then use\r\n     * `disableInteractive` instead, as that toggles the interactive state, where-as\r\n     * this erases it completely.\r\n     * \r\n     * If you wish to resize a hit area, don't remove and then set it as being\r\n     * interactive. Instead, access the hitarea object directly and resize the shape\r\n     * being used. I.e.: `sprite.input.hitArea.setSize(width, height)` (assuming the\r\n     * shape is a Rectangle, which it is by default.)\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#removeInteractive\r\n     * @since 3.7.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    removeInteractive: function ()\r\n    {\r\n        this.scene.sys.input.clear(this);\r\n\r\n        this.input = undefined;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {...*} [args] - args\r\n     */\r\n    update: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Returns a JSON representation of the Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONGameObject} A JSON representation of the Game Object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return ComponentsToJSON(this);\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     * Also checks the Game Object against the given Cameras exclusion list.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#willRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */\r\n    willRender: function (camera)\r\n    {\r\n        return !(GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter > 0 && (this.cameraFilter & camera.id)));\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the display list index of either this Game Object, or if it has one,\r\n     * its parent Container. It then iterates up through all of the parent containers until it hits the\r\n     * root of the display list (which is index 0 in the returned array).\r\n     *\r\n     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of\r\n     * this Game Object and all of its ancestors.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getIndexList\r\n     * @since 3.4.0\r\n     *\r\n     * @return {integer[]} An array of display list position indexes.\r\n     */\r\n    getIndexList: function ()\r\n    {\r\n        // eslint-disable-next-line consistent-this\r\n        var child = this;\r\n        var parent = this.parentContainer;\r\n\r\n        var indexes = [];\r\n\r\n        while (parent)\r\n        {\r\n            // indexes.unshift([parent.getIndex(child), parent.name]);\r\n            indexes.unshift(parent.getIndex(child));\r\n\r\n            child = parent;\r\n\r\n            if (!parent.parentContainer)\r\n            {\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                parent = parent.parentContainer;\r\n            }\r\n        }\r\n\r\n        // indexes.unshift([this.scene.sys.displayList.getIndex(child), 'root']);\r\n        indexes.unshift(this.scene.sys.displayList.getIndex(child));\r\n\r\n        return indexes;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Game Object removing it from the Display List and Update List and\r\n     * severing all ties to parent resources.\r\n     *\r\n     * Also removes itself from the Input Manager and Physics Manager if previously enabled.\r\n     *\r\n     * Use this to remove a Game Object from your game if you don't ever plan to use it again.\r\n     * As long as no reference to it exists within your own code it should become free for\r\n     * garbage collection by the browser.\r\n     *\r\n     * If you just want to temporarily disable an object then look at using the\r\n     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#destroy\r\n     * @since 3.0.0\r\n     * \r\n     * @param {boolean} [fromScene=false] - Is this Game Object being destroyed as the result of a Scene shutdown?\r\n     */\r\n    destroy: function (fromScene)\r\n    {\r\n        if (fromScene === undefined) { fromScene = false; }\r\n\r\n        //  This Game Object has already been destroyed\r\n        if (!this.scene || this.ignoreDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.preDestroy)\r\n        {\r\n            this.preDestroy.call(this);\r\n        }\r\n\r\n        this.emit('destroy', this);\r\n\r\n        var sys = this.scene.sys;\r\n\r\n        if (!fromScene)\r\n        {\r\n            sys.displayList.remove(this);\r\n            sys.updateList.remove(this);\r\n        }\r\n\r\n        if (this.input)\r\n        {\r\n            sys.input.clear(this);\r\n            this.input = undefined;\r\n        }\r\n\r\n        if (this.data)\r\n        {\r\n            this.data.destroy();\r\n\r\n            this.data = undefined;\r\n        }\r\n\r\n        if (this.body)\r\n        {\r\n            this.body.destroy();\r\n            this.body = undefined;\r\n        }\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        if (!fromScene)\r\n        {\r\n            sys.queueDepthSort();\r\n        }\r\n\r\n        this.active = false;\r\n        this.visible = false;\r\n\r\n        this.scene = undefined;\r\n\r\n        this.parentContainer = undefined;\r\n\r\n        this.removeAllListeners();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.\r\n *\r\n * @constant {integer} RENDER_MASK\r\n * @memberof Phaser.GameObjects.GameObject\r\n * @default\r\n */\r\nGameObject.RENDER_MASK = 15;\r\n\r\nmodule.exports = GameObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Clamp = require('../../math/Clamp');\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 2; // 0010\r\n\r\n/**\r\n * Provides methods used for setting the alpha properties of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @name Phaser.GameObjects.Components.Alpha\r\n * @since 3.0.0\r\n */\r\n\r\nvar Alpha = {\r\n\r\n    /**\r\n     * Private internal value. Holds the global alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#_alpha\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alpha: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the top-left alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaTL\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alphaTL: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the top-right alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaTR\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alphaTR: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the bottom-left alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaBL\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alphaBL: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the bottom-right alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaBR\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alphaBR: 1,\r\n\r\n    /**\r\n     * Clears all alpha values associated with this Game Object.\r\n     *\r\n     * Immediately sets the alpha levels back to 1 (fully opaque).\r\n     *\r\n     * @method Phaser.GameObjects.Components.Alpha#clearAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    clearAlpha: function ()\r\n    {\r\n        return this.setAlpha(1);\r\n    },\r\n\r\n    /**\r\n     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.\r\n     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n     *\r\n     * If your game is running under WebGL you can optionally specify four different alpha values, each of which\r\n     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Alpha#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [topLeft=1] - The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object.\r\n     * @param {number} [topRight] - The alpha value used for the top-right of the Game Object. WebGL only.\r\n     * @param {number} [bottomLeft] - The alpha value used for the bottom-left of the Game Object. WebGL only.\r\n     * @param {number} [bottomRight] - The alpha value used for the bottom-right of the Game Object. WebGL only.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAlpha: function (topLeft, topRight, bottomLeft, bottomRight)\r\n    {\r\n        if (topLeft === undefined) { topLeft = 1; }\r\n\r\n        //  Treat as if there is only one alpha value for the whole Game Object\r\n        if (topRight === undefined)\r\n        {\r\n            this.alpha = topLeft;\r\n        }\r\n        else\r\n        {\r\n            this._alphaTL = Clamp(topLeft, 0, 1);\r\n            this._alphaTR = Clamp(topRight, 0, 1);\r\n            this._alphaBL = Clamp(bottomLeft, 0, 1);\r\n            this._alphaBR = Clamp(bottomRight, 0, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The alpha value of the Game Object.\r\n     *\r\n     * This is a global value, impacting the entire Game Object, not just a region of it.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#alpha\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    alpha: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alpha;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alpha = v;\r\n            this._alphaTL = v;\r\n            this._alphaTR = v;\r\n            this._alphaBL = v;\r\n            this._alphaBR = v;\r\n\r\n            if (v === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The alpha value starting from the top-left of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#alphaTopLeft\r\n     * @type {number}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */\r\n    alphaTopLeft: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alphaTL;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alphaTL = v;\r\n\r\n            if (v !== 0)\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The alpha value starting from the top-right of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#alphaTopRight\r\n     * @type {number}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */\r\n    alphaTopRight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alphaTR;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alphaTR = v;\r\n\r\n            if (v !== 0)\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The alpha value starting from the bottom-left of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#alphaBottomLeft\r\n     * @type {number}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */\r\n    alphaBottomLeft: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alphaBL;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alphaBL = v;\r\n\r\n            if (v !== 0)\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The alpha value starting from the bottom-right of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#alphaBottomRight\r\n     * @type {number}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */\r\n    alphaBottomRight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alphaBR;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alphaBR = v;\r\n\r\n            if (v !== 0)\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Alpha;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\n\r\n/**\r\n * Provides methods used for setting the blend mode of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @name Phaser.GameObjects.Components.BlendMode\r\n * @since 3.0.0\r\n */\r\n\r\nvar BlendMode = {\r\n\r\n    /**\r\n     * Private internal value. Holds the current blend mode.\r\n     * \r\n     * @name Phaser.GameObjects.Components.BlendMode#_blendMode\r\n     * @type {integer}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _blendMode: BlendModes.NORMAL,\r\n\r\n    /**\r\n     * Sets the Blend Mode being used by this Game Object.\r\n     *\r\n     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)\r\n     *\r\n     * Under WebGL only the following Blend Modes are available:\r\n     *\r\n     * * ADD\r\n     * * MULTIPLY\r\n     * * SCREEN\r\n     *\r\n     * Canvas has more available depending on browser support.\r\n     *\r\n     * You can also create your own custom Blend Modes in WebGL.\r\n     *\r\n     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending\r\n     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these\r\n     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes\r\n     * are used.\r\n     *\r\n     * @name Phaser.GameObjects.Components.BlendMode#blendMode\r\n     * @type {(Phaser.BlendModes|string)}\r\n     * @since 3.0.0\r\n     */\r\n    blendMode: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._blendMode;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (typeof value === 'string')\r\n            {\r\n                value = BlendModes[value];\r\n            }\r\n\r\n            value |= 0;\r\n\r\n            if (value >= -1)\r\n            {\r\n                this._blendMode = value;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the Blend Mode being used by this Game Object.\r\n     *\r\n     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)\r\n     *\r\n     * Under WebGL only the following Blend Modes are available:\r\n     *\r\n     * * ADD\r\n     * * MULTIPLY\r\n     * * SCREEN\r\n     *\r\n     * Canvas has more available depending on browser support.\r\n     *\r\n     * You can also create your own custom Blend Modes in WebGL.\r\n     *\r\n     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending\r\n     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these\r\n     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes\r\n     * are used.\r\n     *\r\n     * @method Phaser.GameObjects.Components.BlendMode#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.BlendModes)} value - The BlendMode value. Either a string or a CONST.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setBlendMode: function (value)\r\n    {\r\n        this.blendMode = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = BlendMode;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the depth of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @name Phaser.GameObjects.Components.Depth\r\n * @since 3.0.0\r\n */\r\n\r\nvar Depth = {\r\n\r\n    /**\r\n     * Private internal value. Holds the depth of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Depth#_depth\r\n     * @type {integer}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _depth: 0,\r\n\r\n    /**\r\n     * The depth of this Game Object within the Scene.\r\n     * \r\n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\r\n     * of Game Objects, without actually moving their position in the display list.\r\n     *\r\n     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth\r\n     * value will always render in front of one with a lower value.\r\n     *\r\n     * Setting the depth will queue a depth sort event within the Scene.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Depth#depth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    depth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._depth;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scene.sys.queueDepthSort();\r\n            this._depth = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The depth of this Game Object within the Scene.\r\n     * \r\n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\r\n     * of Game Objects, without actually moving their position in the display list.\r\n     *\r\n     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth\r\n     * value will always render in front of one with a lower value.\r\n     *\r\n     * Setting the depth will queue a depth sort event within the Scene.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Depth#setDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} value - The depth of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDepth: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.depth = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Depth;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for visually flipping a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @name Phaser.GameObjects.Components.Flip\r\n * @since 3.0.0\r\n */\r\n\r\nvar Flip = {\r\n\r\n    /**\r\n     * The horizontally flipped state of the Game Object.\r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Flip#flipX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\r\n    flipX: false,\r\n\r\n    /**\r\n     * The vertically flipped state of the Game Object.\r\n     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Flip#flipY\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\r\n    flipY: false,\r\n\r\n    /**\r\n     * Toggles the horizontal flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#toggleFlipX\r\n     * @since 3.0.0\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    toggleFlipX: function ()\r\n    {\r\n        this.flipX = !this.flipX;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Toggles the vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#toggleFlipY\r\n     * @since 3.0.0\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    toggleFlipY: function ()\r\n    {\r\n        this.flipY = !this.flipY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlipX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlipX: function (value)\r\n    {\r\n        this.flipX = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlipY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlipY: function (value)\r\n    {\r\n        this.flipY = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal and vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} x - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * @param {boolean} y - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlip: function (x, y)\r\n    {\r\n        this.flipX = x;\r\n        this.flipY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#resetFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    resetFlip: function ()\r\n    {\r\n        this.flipX = false;\r\n        this.flipY = false;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Flip;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for getting and setting the Scroll Factor of a Game Object.\r\n *\r\n * @name Phaser.GameObjects.Components.ScrollFactor\r\n * @since 3.0.0\r\n */\r\n\r\nvar ScrollFactor = {\r\n\r\n    /**\r\n     * The horizontal scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scrollFactorX: 1,\r\n\r\n    /**\r\n     * The vertical scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scrollFactorY: 1,\r\n\r\n    /**\r\n     * Sets the scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @method Phaser.GameObjects.Components.ScrollFactor#setScrollFactor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scroll factor of this Game Object.\r\n     * @param {number} [y=x] - The vertical scroll factor of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScrollFactor: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.scrollFactorX = x;\r\n        this.scrollFactorY = y;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = ScrollFactor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} JSONGameObject\r\n *\r\n * @property {string} name - The name of this Game Object.\r\n * @property {string} type - A textual representation of this Game Object, i.e. `sprite`.\r\n * @property {number} x - The x position of this Game Object.\r\n * @property {number} y - The y position of this Game Object.\r\n * @property {object} scale - The scale of this Game Object\r\n * @property {number} scale.x - The horizontal scale of this Game Object.\r\n * @property {number} scale.y - The vertical scale of this Game Object.\r\n * @property {object} origin - The origin of this Game Object.\r\n * @property {number} origin.x - The horizontal origin of this Game Object.\r\n * @property {number} origin.y - The vertical origin of this Game Object.\r\n * @property {boolean} flipX - The horizontally flipped state of the Game Object.\r\n * @property {boolean} flipY - The vertically flipped state of the Game Object.\r\n * @property {number} rotation - The angle of this Game Object in radians.\r\n * @property {number} alpha - The alpha value of the Game Object.\r\n * @property {boolean} visible - The visible state of the Game Object.\r\n * @property {integer} scaleMode - The Scale Mode being used by this Game Object.\r\n * @property {(integer|string)} blendMode - Sets the Blend Mode being used by this Game Object.\r\n * @property {string} textureKey - The texture key of this Game Object.\r\n * @property {string} frameKey - The frame key of this Game Object.\r\n * @property {object} data - The data of this Game Object.\r\n */\r\n\r\n/**\r\n * Build a JSON representation of the given Game Object.\r\n *\r\n * This is typically extended further by Game Object specific implementations.\r\n *\r\n * @method Phaser.GameObjects.Components.ToJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to export as JSON.\r\n *\r\n * @return {JSONGameObject} A JSON representation of the Game Object.\r\n */\r\nvar ToJSON = function (gameObject)\r\n{\r\n    var out = {\r\n        name: gameObject.name,\r\n        type: gameObject.type,\r\n        x: gameObject.x,\r\n        y: gameObject.y,\r\n        depth: gameObject.depth,\r\n        scale: {\r\n            x: gameObject.scaleX,\r\n            y: gameObject.scaleY\r\n        },\r\n        origin: {\r\n            x: gameObject.originX,\r\n            y: gameObject.originY\r\n        },\r\n        flipX: gameObject.flipX,\r\n        flipY: gameObject.flipY,\r\n        rotation: gameObject.rotation,\r\n        alpha: gameObject.alpha,\r\n        visible: gameObject.visible,\r\n        scaleMode: gameObject.scaleMode,\r\n        blendMode: gameObject.blendMode,\r\n        textureKey: '',\r\n        frameKey: '',\r\n        data: {}\r\n    };\r\n\r\n    if (gameObject.texture)\r\n    {\r\n        out.textureKey = gameObject.texture.key;\r\n        out.frameKey = gameObject.frame.name;\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = ToJSON;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../../math/const');\r\nvar TransformMatrix = require('./TransformMatrix');\r\nvar WrapAngle = require('../../math/angle/Wrap');\r\nvar WrapAngleDegrees = require('../../math/angle/WrapDegrees');\r\n\r\n//  global bitmask flag for GameObject.renderMask (used by Scale)\r\nvar _FLAG = 4; // 0100\r\n\r\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @name Phaser.GameObjects.Components.Transform\r\n * @since 3.0.0\r\n */\r\n\r\nvar Transform = {\r\n\r\n    /**\r\n     * Private internal value. Holds the horizontal scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_scaleX\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _scaleX: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the vertical scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_scaleY\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _scaleY: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the rotation value in radians.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_rotation\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _rotation: 0,\r\n\r\n    /**\r\n     * The x position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#x\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    x: 0,\r\n\r\n    /**\r\n     * The y position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#y\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    y: 0,\r\n\r\n    /**\r\n     * The z position of this Game Object.\r\n     * Note: Do not use this value to set the z-index, instead see the `depth` property.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#z\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    z: 0,\r\n\r\n    /**\r\n     * The w position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#w\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    w: 0,\r\n\r\n    /**\r\n     * The horizontal scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n\r\n            if (this._scaleX === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleY = value;\r\n\r\n            if (this._scaleY === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The angle of this Game Object as expressed in degrees.\r\n     *\r\n     * Where 0 is to the right, 90 is down, 180 is left.\r\n     *\r\n     * If you prefer to work in radians, see the `rotation` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#angle\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    angle: {\r\n\r\n        get: function ()\r\n        {\r\n            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in degrees\r\n            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The angle of this Game Object in radians.\r\n     *\r\n     * If you prefer to work in degrees, see the `angle` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#rotation\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._rotation;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in radians\r\n            this._rotation = WrapAngle(value);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x position of this Game Object.\r\n     * @param {number} [y=x] - The y position of this Game Object. If not set it will use the `x` value.\r\n     * @param {number} [z=0] - The z position of this Game Object.\r\n     * @param {number} [w=0] - The w position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPosition: function (x, y, z, w)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n        if (z === undefined) { z = 0; }\r\n        if (w === undefined) { w = 0; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Game Object to be a random position within the confines of\r\n     * the given area.\r\n     * \r\n     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.\r\n     *\r\n     * The position does not factor in the size of this Game Object, meaning that only the origin is\r\n     * guaranteed to be within the area.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRandomPosition\r\n     * @since 3.8.0\r\n     *\r\n     * @param {number} [x=0] - The x position of the top-left of the random area.\r\n     * @param {number} [y=0] - The y position of the top-left of the random area.\r\n     * @param {number} [width] - The width of the random area.\r\n     * @param {number} [height] - The height of the random area.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRandomPosition: function (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.scene.sys.game.config.width; }\r\n        if (height === undefined) { height = this.scene.sys.game.config.height; }\r\n\r\n        this.x = x + (Math.random() * width);\r\n        this.y = y + (Math.random() * height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the rotation of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radians=0] - The rotation of this Game Object, in radians.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRotation: function (radians)\r\n    {\r\n        if (radians === undefined) { radians = 0; }\r\n\r\n        this.rotation = radians;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [degrees=0] - The rotation of this Game Object, in degrees.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAngle: function (degrees)\r\n    {\r\n        if (degrees === undefined) { degrees = 0; }\r\n\r\n        this.angle = degrees;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scale of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale of this Game Object.\r\n     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScale: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 1; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.scaleX = x;\r\n        this.scaleY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The x position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setX: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the y position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The y position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setY: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the z position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The z position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setZ: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.z = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the w position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setW\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The w position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setW: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.w = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the local transform matrix for this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getLocalTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */\r\n    getLocalTransformMatrix: function (tempMatrix)\r\n    {\r\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\r\n\r\n        return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\r\n    },\r\n\r\n    /**\r\n     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getWorldTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A temporary matrix to hold parent values during the calculations.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */\r\n    getWorldTransformMatrix: function (tempMatrix, parentMatrix)\r\n    {\r\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\r\n        if (parentMatrix === undefined) { parentMatrix = new TransformMatrix(); }\r\n\r\n        var parent = this.parentContainer;\r\n\r\n        if (!parent)\r\n        {\r\n            return this.getLocalTransformMatrix(tempMatrix);\r\n        }\r\n\r\n        tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\r\n\r\n        while (parent)\r\n        {\r\n            parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);\r\n\r\n            parentMatrix.multiply(tempMatrix, tempMatrix);\r\n\r\n            parent = parent.parentContainer;\r\n        }\r\n\r\n        return tempMatrix;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Transform;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Matrix used for display transformations for rendering.\r\n *\r\n * It is represented like so:\r\n *\r\n * ```\r\n * | a | c | tx |\r\n * | b | d | ty |\r\n * | 0 | 0 | 1  |\r\n * ```\r\n *\r\n * @class TransformMatrix\r\n * @memberof Phaser.GameObjects.Components\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [a=1] - The Scale X value.\r\n * @param {number} [b=0] - The Shear Y value.\r\n * @param {number} [c=0] - The Shear X value.\r\n * @param {number} [d=1] - The Scale Y value.\r\n * @param {number} [tx=0] - The Translate X value.\r\n * @param {number} [ty=0] - The Translate Y value.\r\n */\r\nvar TransformMatrix = new Class({\r\n\r\n    initialize:\r\n\r\n    function TransformMatrix (a, b, c, d, tx, ty)\r\n    {\r\n        if (a === undefined) { a = 1; }\r\n        if (b === undefined) { b = 0; }\r\n        if (c === undefined) { c = 0; }\r\n        if (d === undefined) { d = 1; }\r\n        if (tx === undefined) { tx = 0; }\r\n        if (ty === undefined) { ty = 0; }\r\n\r\n        /**\r\n         * The matrix values.\r\n         *\r\n         * @name Phaser.GameObjects.Components.TransformMatrix#matrix\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.matrix = new Float32Array([ a, b, c, d, tx, ty, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The decomposed matrix.\r\n         *\r\n         * @name Phaser.GameObjects.Components.TransformMatrix#decomposedMatrix\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.decomposedMatrix = {\r\n            translateX: 0,\r\n            translateY: 0,\r\n            scaleX: 1,\r\n            scaleY: 1,\r\n            rotation: 0\r\n        };\r\n    },\r\n\r\n    /**\r\n     * The Scale X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#a\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    a: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[0];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[0] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Shear Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#b\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    b: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[1];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[1] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Shear X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#c\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    c: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[2];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[2] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Scale Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#d\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    d: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[3];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[3] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#e\r\n     * @type {number}\r\n     * @since 3.11.0\r\n     */\r\n    e: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[4];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[4] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#f\r\n     * @type {number}\r\n     * @since 3.11.0\r\n     */\r\n    f: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[5];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[5] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#tx\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    tx: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[4];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[4] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#ty\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    ty: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[5];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[5] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The rotation of the Matrix.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#rotation\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of the Matrix.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#scaleX\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.sqrt((this.a * this.a) + (this.c * this.c));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of the Matrix.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#scaleY\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.sqrt((this.b * this.b) + (this.d * this.d));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Reset the Matrix to an identity matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#loadIdentity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    loadIdentity: function ()\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = 1;\r\n        matrix[1] = 0;\r\n        matrix[2] = 0;\r\n        matrix[3] = 1;\r\n        matrix[4] = 0;\r\n        matrix[5] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translate the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal translation value.\r\n     * @param {number} y - The vertical translation value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    translate: function (x, y)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];\r\n        matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale value.\r\n     * @param {number} y - The vertical scale value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    scale: function (x, y)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] *= x;\r\n        matrix[1] *= x;\r\n        matrix[2] *= y;\r\n        matrix[3] *= y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} angle - The angle of rotation in radians.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    rotate: function (angle)\r\n    {\r\n        var sin = Math.sin(angle);\r\n        var cos = Math.cos(angle);\r\n\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n\r\n        matrix[0] = a * cos + c * sin;\r\n        matrix[1] = b * cos + d * sin;\r\n        matrix[2] = a * -sin + c * cos;\r\n        matrix[3] = b * -sin + d * cos;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the given Matrix.\r\n     * \r\n     * If an `out` Matrix is given then the results will be stored in it.\r\n     * If it is not given, this matrix will be updated in place instead.\r\n     * Use an `out` Matrix if you do not wish to mutate this matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} rhs - The Matrix to multiply by.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [out] - An optional Matrix to store the results in.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} Either this TransformMatrix, or the `out` Matrix, if given in the arguments.\r\n     */\r\n    multiply: function (rhs, out)\r\n    {\r\n        var matrix = this.matrix;\r\n        var source = rhs.matrix;\r\n\r\n        var localA = matrix[0];\r\n        var localB = matrix[1];\r\n        var localC = matrix[2];\r\n        var localD = matrix[3];\r\n        var localE = matrix[4];\r\n        var localF = matrix[5];\r\n\r\n        var sourceA = source[0];\r\n        var sourceB = source[1];\r\n        var sourceC = source[2];\r\n        var sourceD = source[3];\r\n        var sourceE = source[4];\r\n        var sourceF = source[5];\r\n\r\n        var destinationMatrix = (out === undefined) ? this : out;\r\n\r\n        destinationMatrix.a = (sourceA * localA) + (sourceB * localC);\r\n        destinationMatrix.b = (sourceA * localB) + (sourceB * localD);\r\n        destinationMatrix.c = (sourceC * localA) + (sourceD * localC);\r\n        destinationMatrix.d = (sourceC * localB) + (sourceD * localD);\r\n        destinationMatrix.e = (sourceE * localA) + (sourceF * localC) + localE;\r\n        destinationMatrix.f = (sourceE * localB) + (sourceF * localD) + localF;\r\n\r\n        return destinationMatrix;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the matrix given, including the offset.\r\n     * \r\n     * The offsetX is added to the tx value: `offsetX * a + offsetY * c + tx`.\r\n     * The offsetY is added to the ty value: `offsetY * b + offsetY * d + ty`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#multiplyWithOffset\r\n     * @since 3.11.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} src - The source Matrix to copy from.\r\n     * @param {number} offsetX - Horizontal offset to factor in to the multiplication.\r\n     * @param {number} offsetY - Vertical offset to factor in to the multiplication.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    multiplyWithOffset: function (src, offsetX, offsetY)\r\n    {\r\n        var matrix = this.matrix;\r\n        var otherMatrix = src.matrix;\r\n\r\n        var a0 = matrix[0];\r\n        var b0 = matrix[1];\r\n        var c0 = matrix[2];\r\n        var d0 = matrix[3];\r\n        var tx0 = matrix[4];\r\n        var ty0 = matrix[5];\r\n\r\n        var pse = offsetX * a0 + offsetY * c0 + tx0;\r\n        var psf = offsetX * b0 + offsetY * d0 + ty0;\r\n\r\n        var a1 = otherMatrix[0];\r\n        var b1 = otherMatrix[1];\r\n        var c1 = otherMatrix[2];\r\n        var d1 = otherMatrix[3];\r\n        var tx1 = otherMatrix[4];\r\n        var ty1 = otherMatrix[5];\r\n\r\n        matrix[0] = a1 * a0 + b1 * c0;\r\n        matrix[1] = a1 * b0 + b1 * d0;\r\n        matrix[2] = c1 * a0 + d1 * c0;\r\n        matrix[3] = c1 * b0 + d1 * d0;\r\n        matrix[4] = tx1 * a0 + ty1 * c0 + pse;\r\n        matrix[5] = tx1 * b0 + ty1 * d0 + psf;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#transform\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} a - The Scale X value.\r\n     * @param {number} b - The Shear Y value.\r\n     * @param {number} c - The Shear X value.\r\n     * @param {number} d - The Scale Y value.\r\n     * @param {number} tx - The Translate X value.\r\n     * @param {number} ty - The Translate Y value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    transform: function (a, b, c, d, tx, ty)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        var a0 = matrix[0];\r\n        var b0 = matrix[1];\r\n        var c0 = matrix[2];\r\n        var d0 = matrix[3];\r\n        var tx0 = matrix[4];\r\n        var ty0 = matrix[5];\r\n\r\n        matrix[0] = a * a0 + b * c0;\r\n        matrix[1] = a * b0 + b * d0;\r\n        matrix[2] = c * a0 + d * c0;\r\n        matrix[3] = c * b0 + d * d0;\r\n        matrix[4] = tx * a0 + ty * c0 + tx0;\r\n        matrix[5] = tx * b0 + ty * d0 + ty0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform a point using this Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#transformPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the point to transform.\r\n     * @param {number} y - The y coordinate of the point to transform.\r\n     * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} point - The Point object to store the transformed coordinates.\r\n     *\r\n     * @return {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} The Point containing the transformed coordinates.\r\n     */\r\n    transformPoint: function (x, y, point)\r\n    {\r\n        if (point === undefined) { point = { x: 0, y: 0 }; }\r\n\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n        var tx = matrix[4];\r\n        var ty = matrix[5];\r\n\r\n        point.x = x * a + y * c + tx;\r\n        point.y = x * b + y * d + ty;\r\n\r\n        return point;\r\n    },\r\n\r\n    /**\r\n     * Invert the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    invert: function ()\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n        var tx = matrix[4];\r\n        var ty = matrix[5];\r\n\r\n        var n = a * d - b * c;\r\n\r\n        matrix[0] = d / n;\r\n        matrix[1] = -b / n;\r\n        matrix[2] = -c / n;\r\n        matrix[3] = a / n;\r\n        matrix[4] = (c * ty - d * tx) / n;\r\n        matrix[5] = -(a * ty - b * tx) / n;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix to copy those of the matrix given.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyFrom\r\n     * @since 3.11.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} src - The source Matrix to copy from.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    copyFrom: function (src)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = src.a;\r\n        matrix[1] = src.b;\r\n        matrix[2] = src.c;\r\n        matrix[3] = src.d;\r\n        matrix[4] = src.e;\r\n        matrix[5] = src.f;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix to copy those of the array given.\r\n     * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyFromArray\r\n     * @since 3.11.0\r\n     *\r\n     * @param {array} src - The array of values to set into this matrix.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    copyFromArray: function (src)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = src[0];\r\n        matrix[1] = src[1];\r\n        matrix[2] = src[2];\r\n        matrix[3] = src[3];\r\n        matrix[4] = src[4];\r\n        matrix[5] = src[5];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copy the values from this Matrix to the given Canvas Rendering Context.\r\n     * This will use the Context.transform method.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyToContext\r\n     * @since 3.12.0\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx - The Canvas Rendering Context to copy the matrix values to.\r\n     *\r\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context.\r\n     */\r\n    copyToContext: function (ctx)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n\r\n        return ctx;\r\n    },\r\n\r\n    /**\r\n     * Copy the values from this Matrix to the given Canvas Rendering Context.\r\n     * This will use the Context.setTransform method.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#setToContext\r\n     * @since 3.12.0\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx - The Canvas Rendering Context to copy the matrix values to.\r\n     *\r\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context.\r\n     */\r\n    setToContext: function (ctx)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n\r\n        return ctx;\r\n    },\r\n\r\n    /**\r\n     * Copy the values in this Matrix to the array given.\r\n     * \r\n     * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyToArray\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} [out] - The array to copy the matrix values in to.\r\n     *\r\n     * @return {array} An array where elements 0 to 5 contain the values from this matrix.\r\n     */\r\n    copyToArray: function (out)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        if (out === undefined)\r\n        {\r\n            out = [ matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5] ];\r\n        }\r\n        else\r\n        {\r\n            out[0] = matrix[0];\r\n            out[1] = matrix[1];\r\n            out[2] = matrix[2];\r\n            out[3] = matrix[3];\r\n            out[4] = matrix[4];\r\n            out[5] = matrix[5];\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#setTransform\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} a - The Scale X value.\r\n     * @param {number} b - The Shear Y value.\r\n     * @param {number} c - The Shear X value.\r\n     * @param {number} d - The Scale Y value.\r\n     * @param {number} tx - The Translate X value.\r\n     * @param {number} ty - The Translate Y value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    setTransform: function (a, b, c, d, tx, ty)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = a;\r\n        matrix[1] = b;\r\n        matrix[2] = c;\r\n        matrix[3] = d;\r\n        matrix[4] = tx;\r\n        matrix[5] = ty;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Decompose this Matrix into its translation, scale and rotation values using QR decomposition.\r\n     * \r\n     * The result must be applied in the following order to reproduce the current matrix:\r\n     * \r\n     * translate -> rotate -> scale\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#decomposeMatrix\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} The decomposed Matrix.\r\n     */\r\n    decomposeMatrix: function ()\r\n    {\r\n        var decomposedMatrix = this.decomposedMatrix;\r\n\r\n        var matrix = this.matrix;\r\n\r\n        //  a = scale X (1)\r\n        //  b = shear Y (0)\r\n        //  c = shear X (0)\r\n        //  d = scale Y (1)\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n\r\n        var determ = a * d - b * c;\r\n\r\n        decomposedMatrix.translateX = matrix[4];\r\n        decomposedMatrix.translateY = matrix[5];\r\n\r\n        if (a || b)\r\n        {\r\n            var r = Math.sqrt(a * a + b * b);\r\n\r\n            decomposedMatrix.rotation = (b > 0) ? Math.acos(a / r) : -Math.acos(a / r);\r\n            decomposedMatrix.scaleX = r;\r\n            decomposedMatrix.scaleY = determ / r;\r\n        }\r\n        else if (c || d)\r\n        {\r\n            var s = Math.sqrt(c * c + d * d);\r\n\r\n            decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));\r\n            decomposedMatrix.scaleX = determ / s;\r\n            decomposedMatrix.scaleY = s;\r\n        }\r\n        else\r\n        {\r\n            decomposedMatrix.rotation = 0;\r\n            decomposedMatrix.scaleX = 0;\r\n            decomposedMatrix.scaleY = 0;\r\n        }\r\n\r\n        return decomposedMatrix;\r\n    },\r\n\r\n    /**\r\n     * Apply the identity, translate, rotate and scale operations on the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#applyITRS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal translation.\r\n     * @param {number} y - The vertical translation.\r\n     * @param {number} rotation - The angle of rotation in radians.\r\n     * @param {number} scaleX - The horizontal scale.\r\n     * @param {number} scaleY - The vertical scale.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    applyITRS: function (x, y, rotation, scaleX, scaleY)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        var radianSin = Math.sin(rotation);\r\n        var radianCos = Math.cos(rotation);\r\n\r\n        // Translate\r\n        matrix[4] = x;\r\n        matrix[5] = y;\r\n\r\n        // Rotate and Scale\r\n        matrix[0] = radianCos * scaleX;\r\n        matrix[1] = radianSin * scaleX;\r\n        matrix[2] = -radianSin * scaleY;\r\n        matrix[3] = radianCos * scaleY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes the `x` and `y` values and returns a new position in the `output` vector that is the inverse of\r\n     * the current matrix with its transformation applied.\r\n     * \r\n     * Can be used to translate points from world to local space.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#applyInverse\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} x - The x position to translate.\r\n     * @param {number} y - The y position to translate.\r\n     * @param {Phaser.Math.Vector2} [output] - A Vector2, or point-like object, to store the results in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates, inverse-transformed through this matrix.\r\n     */\r\n    applyInverse: function (x, y, output)\r\n    {\r\n        if (output === undefined) { output = new Vector2(); }\r\n\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n        var tx = matrix[4];\r\n        var ty = matrix[5];\r\n\r\n        var id = 1 / ((a * d) + (c * -b));\r\n\r\n        output.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\r\n        output.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns the X component of this matrix multiplied by the given values.\r\n     * This is the same as `x * a + y * c + e`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#getX\r\n     * @since 3.12.0\r\n     * \r\n     * @param {number} x - The x value.\r\n     * @param {number} y - The y value.\r\n     *\r\n     * @return {number} The calculated x value.\r\n     */\r\n    getX: function (x, y)\r\n    {\r\n        return x * this.a + y * this.c + this.e;\r\n    },\r\n\r\n    /**\r\n     * Returns the Y component of this matrix multiplied by the given values.\r\n     * This is the same as `x * b + y * d + f`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#getY\r\n     * @since 3.12.0\r\n     * \r\n     * @param {number} x - The x value.\r\n     * @param {number} y - The y value.\r\n     *\r\n     * @return {number} The calculated y value.\r\n     */\r\n    getY: function (x, y)\r\n    {\r\n        return x * this.b + y * this.d + this.f;\r\n    },\r\n\r\n    /**\r\n     * Returns a string that can be used in a CSS Transform call as a `matrix` property.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#getCSSMatrix\r\n     * @since 3.12.0\r\n     *\r\n     * @return {string} A string containing the CSS Transform matrix values.\r\n     */\r\n    getCSSMatrix: function ()\r\n    {\r\n        var m = this.matrix;\r\n\r\n        return 'matrix(' + m[0] + ',' + m[1] + ',' + m[2] + ',' + m[3] + ',' + m[4] + ',' + m[5] + ')';\r\n    },\r\n\r\n    /**\r\n     * Destroys this Transform Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#destroy\r\n     * @since 3.4.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.matrix = null;\r\n        this.decomposedMatrix = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TransformMatrix;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 1; // 0001\r\n\r\n/**\r\n * Provides methods used for setting the visibility of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @name Phaser.GameObjects.Components.Visible\r\n * @since 3.0.0\r\n */\r\n\r\nvar Visible = {\r\n\r\n    /**\r\n     * Private internal value. Holds the visible value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Visible#_visible\r\n     * @type {boolean}\r\n     * @private\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\r\n    _visible: true,\r\n\r\n    /**\r\n     * The visible state of the Game Object.\r\n     * \r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Visible#visible\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    visible: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._visible;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (value)\r\n            {\r\n                this._visible = true;\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n            else\r\n            {\r\n                this._visible = false;\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility of this Game Object.\r\n     * \r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Visible#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The visible state of the Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setVisible: function (value)\r\n    {\r\n        this.visible = value;\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\nmodule.exports = Visible;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GetURL = require('./GetURL');\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\nvar XHRLoader = require('./XHRLoader');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * @typedef {object} FileConfig\r\n *\r\n * @property {string} type - The file type string (image, json, etc) for sorting within the Loader.\r\n * @property {string} key - Unique cache key (unique within its file type)\r\n * @property {string} [url] - The URL of the file, not including baseURL.\r\n * @property {string} [path] - The path of the file, not including the baseURL.\r\n * @property {string} [extension] - The default extension this file uses.\r\n * @property {XMLHttpRequestResponseType} [responseType] - The responseType to be used by the XHR request.\r\n * @property {(XHRSettingsObject|false)} [xhrSettings=false] - Custom XHR Settings specific to this file and merged with the Loader defaults.\r\n * @property {any} [config] - A config object that can be used by file types to store transitional data.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * The base File class used by all File Types that the Loader can support.\r\n * You shouldn't create an instance of a File directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class File\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {FileConfig} fileConfig - The file configuration object, as created by the file type.\r\n */\r\nvar File = new Class({\r\n\r\n    initialize:\r\n\r\n    function File (loader, fileConfig)\r\n    {\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.File#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * A reference to the Cache, or Texture Manager, that is going to store this file if it loads.\r\n         *\r\n         * @name Phaser.Loader.File#cache\r\n         * @type {(Phaser.Cache.BaseCache|Phaser.Textures.TextureManager)}\r\n         * @since 3.7.0\r\n         */\r\n        this.cache = GetFastValue(fileConfig, 'cache', false);\r\n\r\n        /**\r\n         * The file type string (image, json, etc) for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.File#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = GetFastValue(fileConfig, 'type', false);\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.File#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = GetFastValue(fileConfig, 'key', false);\r\n\r\n        var loadKey = this.key;\r\n\r\n        if (loader.prefix && loader.prefix !== '')\r\n        {\r\n            this.key = loader.prefix + loadKey;\r\n        }\r\n\r\n        if (!this.type || !this.key)\r\n        {\r\n            throw new Error('Error calling \\'Loader.' + this.type + '\\' invalid key provided.');\r\n        }\r\n\r\n        /**\r\n         * The URL of the file, not including baseURL.\r\n         * Automatically has Loader.path prepended to it.\r\n         *\r\n         * @name Phaser.Loader.File#url\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.url = GetFastValue(fileConfig, 'url');\r\n\r\n        if (this.url === undefined)\r\n        {\r\n            this.url = loader.path + loadKey + '.' + GetFastValue(fileConfig, 'extension', '');\r\n        }\r\n        else if (typeof(this.url) !== 'function')\r\n        {\r\n            this.url = loader.path + this.url;\r\n        }\r\n\r\n        /**\r\n         * The final URL this file will load from, including baseURL and path.\r\n         * Set automatically when the Loader calls 'load' on this file.\r\n         *\r\n         * @name Phaser.Loader.File#src\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.src = '';\r\n\r\n        /**\r\n         * The merged XHRSettings for this file.\r\n         *\r\n         * @name Phaser.Loader.File#xhrSettings\r\n         * @type {XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrSettings = XHRSettings(GetFastValue(fileConfig, 'responseType', undefined));\r\n\r\n        if (GetFastValue(fileConfig, 'xhrSettings', false))\r\n        {\r\n            this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, 'xhrSettings', {}));\r\n        }\r\n\r\n        /**\r\n         * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.\r\n         *\r\n         * @name Phaser.Loader.File#xhrLoader\r\n         * @type {?XMLHttpRequest}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrLoader = null;\r\n\r\n        /**\r\n         * The current state of the file. One of the FILE_CONST values.\r\n         *\r\n         * @name Phaser.Loader.File#state\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.state = (typeof(this.url) === 'function') ? CONST.FILE_POPULATED : CONST.FILE_PENDING;\r\n\r\n        /**\r\n         * The total size of this file.\r\n         * Set by onProgress and only if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesTotal\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesTotal = 0;\r\n\r\n        /**\r\n         * Updated as the file loads.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesLoaded\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesLoaded = -1;\r\n\r\n        /**\r\n         * A percentage value between 0 and 1 indicating how much of this file has loaded.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#percentComplete\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.percentComplete = -1;\r\n\r\n        /**\r\n         * For CORs based loading.\r\n         * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)\r\n         *\r\n         * @name Phaser.Loader.File#crossOrigin\r\n         * @type {(string|undefined)}\r\n         * @since 3.0.0\r\n         */\r\n        this.crossOrigin = undefined;\r\n\r\n        /**\r\n         * The processed file data, stored here after the file has loaded.\r\n         *\r\n         * @name Phaser.Loader.File#data\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = undefined;\r\n\r\n        /**\r\n         * A config object that can be used by file types to store transitional data.\r\n         *\r\n         * @name Phaser.Loader.File#config\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = GetFastValue(fileConfig, 'config', {});\r\n\r\n        /**\r\n         * If this is a multipart file, i.e. an atlas and its json together, then this is a reference\r\n         * to the parent MultiFile. Set and used internally by the Loader or specific file types.\r\n         *\r\n         * @name Phaser.Loader.File#multiFile\r\n         * @type {?Phaser.Loader.MultiFile}\r\n         * @since 3.7.0\r\n         */\r\n        this.multiFile;\r\n\r\n        /**\r\n         * Does this file have an associated linked file? Such as an image and a normal map.\r\n         * Atlases and Bitmap Fonts use the multiFile, because those files need loading together but aren't\r\n         * actually bound by data, where-as a linkFile is.\r\n         *\r\n         * @name Phaser.Loader.File#linkFile\r\n         * @type {?Phaser.Loader.File}\r\n         * @since 3.7.0\r\n         */\r\n        this.linkFile;\r\n    },\r\n\r\n    /**\r\n     * Links this File with another, so they depend upon each other for loading and processing.\r\n     *\r\n     * @method Phaser.Loader.File#setLink\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} fileB - The file to link to this one.\r\n     */\r\n    setLink: function (fileB)\r\n    {\r\n        this.linkFile = fileB;\r\n\r\n        fileB.linkFile = this;\r\n    },\r\n\r\n    /**\r\n     * Resets the XHRLoader instance this file is using.\r\n     *\r\n     * @method Phaser.Loader.File#resetXHR\r\n     * @since 3.0.0\r\n     */\r\n    resetXHR: function ()\r\n    {\r\n        if (this.xhrLoader)\r\n        {\r\n            this.xhrLoader.onload = undefined;\r\n            this.xhrLoader.onerror = undefined;\r\n            this.xhrLoader.onprogress = undefined;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.File#load\r\n     * @since 3.0.0\r\n     */\r\n    load: function ()\r\n    {\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            //  Can happen for example in a JSONFile if they've provided a JSON object instead of a URL\r\n            this.loader.nextFile(this, true);\r\n        }\r\n        else\r\n        {\r\n            this.src = GetURL(this, this.loader.baseURL);\r\n\r\n            if (this.src.indexOf('data:') === 0)\r\n            {\r\n                console.warn('Local data URIs are not supported: ' + this.key);\r\n            }\r\n            else\r\n            {\r\n                //  The creation of this XHRLoader starts the load process going.\r\n                //  It will automatically call the following, based on the load outcome:\r\n                //  \r\n                // xhr.onload = this.onLoad\r\n                // xhr.onerror = this.onError\r\n                // xhr.onprogress = this.onProgress\r\n\r\n                this.xhrLoader = XHRLoader(this, this.loader.xhr);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called when the file finishes loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onLoad\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onLoad: function (xhr, event)\r\n    {\r\n        var success = !(event.target && event.target.status !== 200);\r\n\r\n        //  Handle HTTP status codes of 4xx and 5xx as errors, even if xhr.onerror was not called.\r\n        if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599)\r\n        {\r\n            success = false;\r\n        }\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, success);\r\n    },\r\n\r\n    /**\r\n     * Called if the file errors while loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onError\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this error.\r\n     */\r\n    onError: function ()\r\n    {\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onProgress\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent.\r\n     */\r\n    onProgress: function (event)\r\n    {\r\n        if (event.lengthComputable)\r\n        {\r\n            this.bytesLoaded = event.loaded;\r\n            this.bytesTotal = event.total;\r\n\r\n            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);\r\n\r\n            this.loader.emit('fileprogress', this, this.percentComplete);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Usually overridden by the FileTypes and is called by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data, for example a JSON file will parse itself during this stage.\r\n     *\r\n     * @method Phaser.Loader.File#onProcess\r\n     * @since 3.0.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessComplete\r\n     * @since 3.7.0\r\n     */\r\n    onProcessComplete: function ()\r\n    {\r\n        this.state = CONST.FILE_COMPLETE;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileComplete(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing but it generated an error.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessError\r\n     * @since 3.7.0\r\n     */\r\n    onProcessError: function ()\r\n    {\r\n        this.state = CONST.FILE_ERRORED;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileFailed(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Checks if a key matching the one used by this file exists in the target Cache or not.\r\n     * This is called automatically by the LoaderPlugin to decide if the file can be safely\r\n     * loaded or will conflict.\r\n     *\r\n     * @method Phaser.Loader.File#hasCacheConflict\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if adding this file will cause a conflict, otherwise `false`.\r\n     */\r\n    hasCacheConflict: function ()\r\n    {\r\n        return (this.cache && this.cache.exists(this.key));\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     * This method is often overridden by specific file types.\r\n     *\r\n     * @method Phaser.Loader.File#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.cache)\r\n        {\r\n            this.cache.add(this.key, this.data);\r\n        }\r\n\r\n        this.pendingDestroy();\r\n    },\r\n\r\n    /**\r\n     * You can listen for this event from the LoaderPlugin. It is dispatched _every time_\r\n     * a file loads and is sent 3 arguments, which allow you to identify the file:\r\n     *\r\n     * ```javascript\r\n     * this.load.on('filecomplete', function (key, type, data) {\r\n     *     // Your handler code\r\n     * });\r\n     * ```\r\n     * \r\n     * @event Phaser.Loader.File#fileCompleteEvent\r\n     * @param {string} key - The key of the file that just loaded and finished processing.\r\n     * @param {string} type - The type of the file that just loaded and finished processing.\r\n     * @param {any} data - The data of the file.\r\n     */\r\n\r\n    /**\r\n     * You can listen for this event from the LoaderPlugin. It is dispatched only once per\r\n     * file and you have to use a special listener handle to pick it up.\r\n     * \r\n     * The string of the event is based on the file type and the key you gave it, split up\r\n     * using hyphens.\r\n     * \r\n     * For example, if you have loaded an image with a key of `monster`, you can listen for it\r\n     * using the following:\r\n     *\r\n     * ```javascript\r\n     * this.load.on('filecomplete-image-monster', function (key, type, data) {\r\n     *     // Your handler code\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, if you have loaded a texture atlas with a key of `Level1`:\r\n     * \r\n     * ```javascript\r\n     * this.load.on('filecomplete-atlas-Level1', function (key, type, data) {\r\n     *     // Your handler code\r\n     * });\r\n     * ```\r\n     * \r\n     * Or, if you have loaded a sprite sheet with a key of `Explosion` and a prefix of `GAMEOVER`:\r\n     * \r\n     * ```javascript\r\n     * this.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) {\r\n     *     // Your handler code\r\n     * });\r\n     * ```\r\n     * \r\n     * @event Phaser.Loader.File#singleFileCompleteEvent\r\n     * @param {any} data - The data of the file.\r\n     */\r\n\r\n    /**\r\n     * Called once the file has been added to its cache and is now ready for deletion from the Loader.\r\n     * It will emit a `filecomplete` event from the LoaderPlugin.\r\n     *\r\n     * @method Phaser.Loader.File#pendingDestroy\r\n     * @fires Phaser.Loader.File#fileCompleteEvent\r\n     * @fires Phaser.Loader.File#singleFileCompleteEvent\r\n     * @since 3.7.0\r\n     */\r\n    pendingDestroy: function (data)\r\n    {\r\n        if (data === undefined) { data = this.data; }\r\n\r\n        var key = this.key;\r\n        var type = this.type;\r\n\r\n        this.loader.emit('filecomplete', key, type, data);\r\n        this.loader.emit('filecomplete-' + type + '-' + key, key, type, data);\r\n\r\n        this.loader.flagForRemoval(this);\r\n    },\r\n\r\n    /**\r\n     * Destroy this File and any references it holds.\r\n     *\r\n     * @method Phaser.Loader.File#destroy\r\n     * @since 3.7.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.loader = null;\r\n        this.cache = null;\r\n        this.xhrSettings = null;\r\n        this.multiFile = null;\r\n        this.linkFile = null;\r\n        this.data = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Static method for creating object URL using URL API and setting it as image 'src' attribute.\r\n * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.\r\n *\r\n * @method Phaser.Loader.File.createObjectURL\r\n * @static\r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be set to object URL.\r\n * @param {Blob} blob - A Blob object to create an object URL for.\r\n * @param {string} defaultType - Default mime type used if blob type is not available.\r\n */\r\nFile.createObjectURL = function (image, blob, defaultType)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        image.src = URL.createObjectURL(blob);\r\n    }\r\n    else\r\n    {\r\n        var reader = new FileReader();\r\n\r\n        reader.onload = function ()\r\n        {\r\n            image.removeAttribute('crossOrigin');\r\n            image.src = 'data:' + (blob.type || defaultType) + ';base64,' + reader.result.split(',')[1];\r\n        };\r\n\r\n        reader.onerror = image.onerror;\r\n\r\n        reader.readAsDataURL(blob);\r\n    }\r\n};\r\n\r\n/**\r\n * Static method for releasing an existing object URL which was previously created\r\n * by calling {@link File#createObjectURL} method.\r\n *\r\n * @method Phaser.Loader.File.revokeObjectURL\r\n * @static\r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be revoked.\r\n */\r\nFile.revokeObjectURL = function (image)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        URL.revokeObjectURL(image.src);\r\n    }\r\n};\r\n\r\nmodule.exports = File;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar types = {};\r\n\r\nvar FileTypesManager = {\r\n\r\n    /**\r\n     * Static method called when a LoaderPlugin is created.\r\n     * \r\n     * Loops through the local types object and injects all of them as\r\n     * properties into the LoaderPlugin instance.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.register\r\n     * @since 3.0.0\r\n     * \r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The LoaderPlugin to install the types into.\r\n     */\r\n    install: function (loader)\r\n    {\r\n        for (var key in types)\r\n        {\r\n            loader[key] = types[key];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Static method called directly by the File Types.\r\n     * \r\n     * The key is a reference to the function used to load the files via the Loader, i.e. `image`.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.register\r\n     * @since 3.0.0\r\n     * \r\n     * @param {string} key - The key that will be used as the method name in the LoaderPlugin.\r\n     * @param {function} factoryFunction - The function that will be called when LoaderPlugin.key is invoked.\r\n     */\r\n    register: function (key, factoryFunction)\r\n    {\r\n        types[key] = factoryFunction;\r\n    },\r\n\r\n    /**\r\n     * Removed all associated file types.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        types = {};\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = FileTypesManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * Given a File and a baseURL value this returns the URL the File will use to download from.\r\n *\r\n * @function Phaser.Loader.GetURL\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File object.\r\n * @param {string} baseURL - A default base URL.\r\n *\r\n * @return {string} The URL the File will use.\r\n */\r\nvar GetURL = function (file, baseURL)\r\n{\r\n    if (!file.url)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (file.url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/))\r\n    {\r\n        return file.url;\r\n    }\r\n    else\r\n    {\r\n        return baseURL + file.url;\r\n    }\r\n};\r\n\r\nmodule.exports = GetURL;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Extend = require('../utils/object/Extend');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * Takes two XHRSettings Objects and creates a new XHRSettings object from them.\r\n *\r\n * The new object is seeded by the values given in the global settings, but any setting in\r\n * the local object overrides the global ones.\r\n *\r\n * @function Phaser.Loader.MergeXHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {XHRSettingsObject} global - The global XHRSettings object.\r\n * @param {XHRSettingsObject} local - The local XHRSettings object.\r\n *\r\n * @return {XHRSettingsObject} A newly formed XHRSettings object.\r\n */\r\nvar MergeXHRSettings = function (global, local)\r\n{\r\n    var output = (global === undefined) ? XHRSettings() : Extend({}, global);\r\n\r\n    if (local)\r\n    {\r\n        for (var setting in local)\r\n        {\r\n            if (local[setting] !== undefined)\r\n            {\r\n                output[setting] = local[setting];\r\n            }\r\n        }\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = MergeXHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A MultiFile is a special kind of parent that contains two, or more, Files as children and looks after\r\n * the loading and processing of them all. It is commonly extended and used as a base class for file types such as AtlasJSON or BitmapFont.\r\n * \r\n * You shouldn't create an instance of a MultiFile directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class MultiFile\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {string} type - The file type string for sorting within the Loader.\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {Phaser.Loader.File[]} files - An array of Files that make-up this MultiFile.\r\n */\r\nvar MultiFile = new Class({\r\n\r\n    initialize:\r\n\r\n    function MultiFile (loader, type, key, files)\r\n    {\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.7.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * The file type string for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#type\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.MultiFile#key\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.key = key;\r\n\r\n        /**\r\n         * Array of files that make up this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#files\r\n         * @type {Phaser.Loader.File[]}\r\n         * @since 3.7.0\r\n         */\r\n        this.files = files;\r\n\r\n        /**\r\n         * The completion status of this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#complete\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.7.0\r\n         */\r\n        this.complete = false;\r\n\r\n        /**\r\n         * The number of files to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#pending\r\n         * @type {integer}\r\n         * @since 3.7.0\r\n         */\r\n\r\n        this.pending = files.length;\r\n\r\n        /**\r\n         * The number of files that failed to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#failed\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.failed = 0;\r\n\r\n        /**\r\n         * A storage container for transient data that the loading files need.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#config\r\n         * @type {any}\r\n         * @since 3.7.0\r\n         */\r\n        this.config = {};\r\n\r\n        //  Link the files\r\n        for (var i = 0; i < files.length; i++)\r\n        {\r\n            files[i].multiFile = this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if this MultiFile is ready to process its children or not.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#isReadyToProcess\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if all children of this MultiFile have loaded, otherwise `false`.\r\n     */\r\n    isReadyToProcess: function ()\r\n    {\r\n        return (this.pending === 0 && this.failed === 0 && !this.complete);\r\n    },\r\n\r\n    /**\r\n     * Adds another child to this MultiFile, increases the pending count and resets the completion status.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#addToMultiFile\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} files - The File to add to this MultiFile.\r\n     *\r\n     * @return {Phaser.Loader.MultiFile} This MultiFile instance.\r\n     */\r\n    addToMultiFile: function (file)\r\n    {\r\n        this.files.push(file);\r\n\r\n        file.multiFile = this;\r\n\r\n        this.pending++;\r\n\r\n        this.complete = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by each File that fails to load.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileFailed\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has failed to load.\r\n     */\r\n    onFileFailed: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.failed++;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MultiFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\n\r\n/**\r\n * Creates a new XMLHttpRequest (xhr) object based on the given File and XHRSettings\r\n * and starts the download of it. It uses the Files own XHRSettings and merges them\r\n * with the global XHRSettings object to set the xhr values before download.\r\n *\r\n * @function Phaser.Loader.XHRLoader\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File to download.\r\n * @param {XHRSettingsObject} globalXHRSettings - The global XHRSettings object.\r\n *\r\n * @return {XMLHttpRequest} The XHR object.\r\n */\r\nvar XHRLoader = function (file, globalXHRSettings)\r\n{\r\n    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);\r\n\r\n    var xhr = new XMLHttpRequest();\r\n\r\n    xhr.open('GET', file.src, config.async, config.user, config.password);\r\n\r\n    xhr.responseType = file.xhrSettings.responseType;\r\n    xhr.timeout = config.timeout;\r\n\r\n    if (config.header && config.headerValue)\r\n    {\r\n        xhr.setRequestHeader(config.header, config.headerValue);\r\n    }\r\n\r\n    if (config.requestedWith)\r\n    {\r\n        xhr.setRequestHeader('X-Requested-With', config.requestedWith);\r\n    }\r\n\r\n    if (config.overrideMimeType)\r\n    {\r\n        xhr.overrideMimeType(config.overrideMimeType);\r\n    }\r\n\r\n    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)\r\n\r\n    xhr.onload = file.onLoad.bind(file, xhr);\r\n    xhr.onerror = file.onError.bind(file);\r\n    xhr.onprogress = file.onProgress.bind(file);\r\n\r\n    //  This is the only standard method, the ones above are browser additions (maybe not universal?)\r\n    // xhr.onreadystatechange\r\n\r\n    xhr.send();\r\n\r\n    return xhr;\r\n};\r\n\r\nmodule.exports = XHRLoader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} XHRSettingsObject\r\n *\r\n * @property {XMLHttpRequestResponseType} responseType - The response type of the XHR request, i.e. `blob`, `text`, etc.\r\n * @property {boolean} [async=true] - Should the XHR request use async or not?\r\n * @property {string} [user=''] - Optional username for the XHR request.\r\n * @property {string} [password=''] - Optional password for the XHR request.\r\n * @property {integer} [timeout=0] - Optional XHR timeout value.\r\n * @property {(string|undefined)} [header] - This value is used to populate the XHR `setRequestHeader` and is undefined by default.\r\n * @property {(string|undefined)} [headerValue] - This value is used to populate the XHR `setRequestHeader` and is undefined by default.\r\n * @property {(string|undefined)} [requestedWith] - This value is used to populate the XHR `setRequestHeader` and is undefined by default.\r\n * @property {(string|undefined)} [overrideMimeType] - Provide a custom mime-type to use instead of the default.\r\n */\r\n\r\n/**\r\n * Creates an XHRSettings Object with default values.\r\n *\r\n * @function Phaser.Loader.XHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {XMLHttpRequestResponseType} [responseType=''] - The responseType, such as 'text'.\r\n * @param {boolean} [async=true] - Should the XHR request use async or not?\r\n * @param {string} [user=''] - Optional username for the XHR request.\r\n * @param {string} [password=''] - Optional password for the XHR request.\r\n * @param {integer} [timeout=0] - Optional XHR timeout value.\r\n *\r\n * @return {XHRSettingsObject} The XHRSettings object as used by the Loader.\r\n */\r\nvar XHRSettings = function (responseType, async, user, password, timeout)\r\n{\r\n    if (responseType === undefined) { responseType = ''; }\r\n    if (async === undefined) { async = true; }\r\n    if (user === undefined) { user = ''; }\r\n    if (password === undefined) { password = ''; }\r\n    if (timeout === undefined) { timeout = 0; }\r\n\r\n    // Before sending a request, set the xhr.responseType to \"text\",\r\n    // \"arraybuffer\", \"blob\", or \"document\", depending on your data needs.\r\n    // Note, setting xhr.responseType = '' (or omitting) will default the response to \"text\".\r\n\r\n    return {\r\n\r\n        //  Ignored by the Loader, only used by File.\r\n        responseType: responseType,\r\n\r\n        async: async,\r\n\r\n        //  credentials\r\n        user: user,\r\n        password: password,\r\n\r\n        //  timeout in ms (0 = no timeout)\r\n        timeout: timeout,\r\n\r\n        //  setRequestHeader\r\n        header: undefined,\r\n        headerValue: undefined,\r\n        requestedWith: false,\r\n\r\n        //  overrideMimeType\r\n        overrideMimeType: undefined\r\n\r\n    };\r\n};\r\n\r\nmodule.exports = XHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar FILE_CONST = {\r\n\r\n    /**\r\n     * The Loader is idle.\r\n     * \r\n     * @name Phaser.Loader.LOADER_IDLE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_IDLE: 0,\r\n\r\n    /**\r\n     * The Loader is actively loading.\r\n     * \r\n     * @name Phaser.Loader.LOADER_LOADING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_LOADING: 1,\r\n\r\n    /**\r\n     * The Loader is processing files is has loaded.\r\n     * \r\n     * @name Phaser.Loader.LOADER_PROCESSING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_PROCESSING: 2,\r\n\r\n    /**\r\n     * The Loader has completed loading and processing.\r\n     * \r\n     * @name Phaser.Loader.LOADER_COMPLETE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_COMPLETE: 3,\r\n\r\n    /**\r\n     * The Loader is shutting down.\r\n     * \r\n     * @name Phaser.Loader.LOADER_SHUTDOWN\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_SHUTDOWN: 4,\r\n\r\n    /**\r\n     * The Loader has been destroyed.\r\n     * \r\n     * @name Phaser.Loader.LOADER_DESTROYED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_DESTROYED: 5,\r\n\r\n    /**\r\n     * File is in the load queue but not yet started\r\n     * \r\n     * @name Phaser.Loader.FILE_PENDING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PENDING: 10,\r\n\r\n    /**\r\n     * File has been started to load by the loader (onLoad called)\r\n     * \r\n     * @name Phaser.Loader.FILE_LOADING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADING: 11,\r\n\r\n    /**\r\n     * File has loaded successfully, awaiting processing    \r\n     * \r\n     * @name Phaser.Loader.FILE_LOADED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADED: 12,\r\n\r\n    /**\r\n     * File failed to load\r\n     * \r\n     * @name Phaser.Loader.FILE_FAILED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_FAILED: 13,\r\n\r\n    /**\r\n     * File is being processed (onProcess callback)\r\n     * \r\n     * @name Phaser.Loader.FILE_PROCESSING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PROCESSING: 14,\r\n\r\n    /**\r\n     * The File has errored somehow during processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_ERRORED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_ERRORED: 16,\r\n\r\n    /**\r\n     * File has finished processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_COMPLETE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_COMPLETE: 17,\r\n\r\n    /**\r\n     * File has been destroyed\r\n     * \r\n     * @name Phaser.Loader.FILE_DESTROYED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_DESTROYED: 18,\r\n\r\n    /**\r\n     * File was populated from local data and doesn't need an HTTP request\r\n     * \r\n     * @name Phaser.Loader.FILE_POPULATED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_POPULATED: 19\r\n\r\n};\r\n\r\nmodule.exports = FILE_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @typedef {object} Phaser.Loader.FileTypes.ImageFrameConfig\r\n *\r\n * @property {integer} frameWidth - The width of the frame in pixels.\r\n * @property {integer} [frameHeight] - The height of the frame in pixels. Uses the `frameWidth` value if not provided.\r\n * @property {integer} [startFrame=0] - The first frame to start parsing from.\r\n * @property {integer} [endFrame] - The frame to stop parsing at. If not provided it will calculate the value based on the image and frame dimensions.\r\n * @property {integer} [margin=0] - The margin in the image. This is the space around the edge of the frames.\r\n * @property {integer} [spacing=0] - The spacing between each frame in the image.\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Loader.FileTypes.ImageFileConfig\r\n *\r\n * @property {string} key - The key of the file. Must be unique within both the Loader and the Texture Manager.\r\n * @property {string} [url] - The absolute or relative URL to load the file from.\r\n * @property {string} [extension='png'] - The default file extension to use if no url is provided.\r\n * @property {string} [normalMap] - The filename of an associated normal map. It uses the same path and url to load as the image.\r\n * @property {Phaser.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. Only provided for, and used by, Sprite Sheets.\r\n * @property {XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A single Image File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#image method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#image.\r\n *\r\n * @class ImageFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Loader.FileTypes.ImageFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {Phaser.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. Only provided for, and used by, Sprite Sheets.\r\n */\r\nvar ImageFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ImageFile (loader, key, url, xhrSettings, frameConfig)\r\n    {\r\n        var extension = 'png';\r\n        var normalMapURL;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            normalMapURL = GetFastValue(config, 'normalMap');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            frameConfig = GetFastValue(config, 'frameConfig');\r\n        }\r\n\r\n        if (Array.isArray(url))\r\n        {\r\n            normalMapURL = url[1];\r\n            url = url[0];\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'image',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'blob',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: frameConfig\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        //  Do we have a normal map to load as well?\r\n        if (normalMapURL)\r\n        {\r\n            var normalMap = new ImageFile(loader, this.key, normalMapURL, xhrSettings, frameConfig);\r\n\r\n            normalMap.type = 'normalMap';\r\n\r\n            this.setLink(normalMap);\r\n\r\n            loader.addFile(normalMap);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        var _this = this;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(this.data, this.xhrLoader.response, 'image/png');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture;\r\n        var linkFile = this.linkFile;\r\n\r\n        if (linkFile && linkFile.state === CONST.FILE_COMPLETE)\r\n        {\r\n            if (this.type === 'image')\r\n            {\r\n                texture = this.cache.addImage(this.key, this.data, linkFile.data);\r\n            }\r\n            else\r\n            {\r\n                texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);\r\n            }\r\n\r\n            this.pendingDestroy(texture);\r\n\r\n            linkFile.pendingDestroy(texture);\r\n        }\r\n        else if (!linkFile)\r\n        {\r\n            texture = this.cache.addImage(this.key, this.data);\r\n\r\n            this.pendingDestroy(texture);\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Image, or array of Images, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.image('logo', 'images/phaserLogo.png');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback\r\n * of animated gifs to Canvas elements.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Loader.FileTypes.ImageFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n * \r\n * ```javascript\r\n * this.load.image('logo', 'images/AtariLogo.png');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'logo');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n * \r\n * ```javascript\r\n * this.load.image('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ]);\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n * \r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png',\r\n *     normalMap: 'images/AtariLogo-n.png'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Image File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#image\r\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Loader.FileTypes.ImageFileConfig|Phaser.Loader.FileTypes.ImageFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n */\r\nFileTypesManager.register('image', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ImageFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ImageFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ImageFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @typedef {object} Phaser.Loader.FileTypes.JSONFileConfig\r\n *\r\n * @property {string} key - The key of the file. Must be unique within both the Loader and the JSON Cache.\r\n * @property {string|any} [url] - The absolute or relative URL to load the file from. Or can be a ready formed JSON object, in which case it will be directly added to the Cache.\r\n * @property {string} [extension='json'] - The default file extension to use if no url is provided.\r\n * @property {string} [dataKey] - If specified instead of the whole JSON file being parsed and added to the Cache, only the section corresponding to this property key will be added. If the property you want to extract is nested, use periods to divide it.\r\n * @property {XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#json method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#json.\r\n *\r\n * @class JSONFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Loader.FileTypes.JSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar JSONFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function JSONFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        var extension = 'json';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            dataKey = GetFastValue(config, 'dataKey', dataKey);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'json',\r\n            cache: loader.cacheManager.json,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: dataKey\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        if (IsPlainObject(url))\r\n        {\r\n            //  Object provided instead of a URL, so no need to actually load it (populate data with value)\r\n            if (dataKey)\r\n            {\r\n                this.data = GetValue(url, dataKey);\r\n            }\r\n            else\r\n            {\r\n                this.data = url;\r\n            }\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.JSONFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        if (this.state !== CONST.FILE_POPULATED)\r\n        {\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            var json = JSON.parse(this.xhrLoader.responseText);\r\n\r\n            var key = this.config;\r\n\r\n            if (typeof key === 'string')\r\n            {\r\n                this.data = GetValue(json, key, json);\r\n            }\r\n            else\r\n            {\r\n                this.data = json;\r\n            }\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON file, or array of JSON files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.json({\r\n *     key: 'wavedata',\r\n *     url: 'files/AlienWaveData.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Loader.FileTypes.JSONFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n * \r\n * ```javascript\r\n * this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * // and later in your game ...\r\n * var data = this.cache.json.get('wavedata');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n * \r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#json\r\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Loader.FileTypes.JSONFileConfig|Phaser.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n * @param {XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n */\r\nFileTypesManager.register('json', function (key, url, dataKey, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new JSONFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = JSONFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @typedef {object} Phaser.Loader.FileTypes.TextFileConfig\r\n *\r\n * @property {string} key - The key of the file. Must be unique within both the Loader and the Text Cache.\r\n * @property {string} [url] - The absolute or relative URL to load the file from.\r\n * @property {string} [extension='txt'] - The default file extension to use if no url is provided.\r\n * @property {XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A single Text File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#text method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#text.\r\n *\r\n * @class TextFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Loader.FileTypes.TextFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TextFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function TextFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'txt';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'text',\r\n            cache: loader.cacheManager.text,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TextFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Text file, or array of Text files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.text('story', 'files/IntroStory.txt');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Text Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Text Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.text({\r\n *     key: 'story',\r\n *     url: 'files/IntroStory.txt'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Loader.FileTypes.TextFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.text('story', 'files/IntroStory.txt');\r\n * // and later in your game ...\r\n * var data = this.cache.text.get('story');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Text Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.txt\". It will always add `.txt` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Text File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#text\r\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Loader.FileTypes.TextFileConfig|Phaser.Loader.FileTypes.TextFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n */\r\nFileTypesManager.register('text', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TextFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TextFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TextFile;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\n/**\r\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\r\n *\r\n * @function Phaser.Math.Clamp\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to be clamped.\r\n * @param {number} min - The minimum bounds.\r\n * @param {number} max - The maximum bounds.\r\n *\r\n * @return {number} The clamped value.\r\n */\r\nvar Clamp = function (value, min, max)\r\n{\r\n    return Math.max(min, Math.min(max, value));\r\n};\r\n\r\nmodule.exports = Clamp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\nvar EPSILON = 0.000001;\r\n\r\n/**\r\n * @classdesc\r\n * A four-dimensional matrix.\r\n *\r\n * @class Matrix4\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Matrix4} [m] - Optional Matrix4 to copy values from.\r\n */\r\nvar Matrix4 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Matrix4 (m)\r\n    {\r\n        /**\r\n         * The matrix values.\r\n         *\r\n         * @name Phaser.Math.Matrix4#val\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.val = new Float32Array(16);\r\n\r\n        if (m)\r\n        {\r\n            //  Assume Matrix4 with val:\r\n            this.copy(m);\r\n        }\r\n        else\r\n        {\r\n            //  Default to identity\r\n            this.identity();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Matrix4.\r\n     *\r\n     * @method Phaser.Math.Matrix4#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} A clone of this Matrix4.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Matrix4(this);\r\n    },\r\n\r\n    //  TODO - Should work with basic values\r\n\r\n    /**\r\n     * This method is an alias for `Matrix4.copy`.\r\n     *\r\n     * @method Phaser.Math.Matrix4#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - The Matrix to set the values of this Matrix's from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    set: function (src)\r\n    {\r\n        return this.copy(src);\r\n    },\r\n\r\n    /**\r\n     * Copy the values of a given Matrix into this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - The Matrix to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        var out = this.val;\r\n        var a = src.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        out[4] = a[4];\r\n        out[5] = a[5];\r\n        out[6] = a[6];\r\n        out[7] = a[7];\r\n        out[8] = a[8];\r\n        out[9] = a[9];\r\n        out[10] = a[10];\r\n        out[11] = a[11];\r\n        out[12] = a[12];\r\n        out[13] = a[13];\r\n        out[14] = a[14];\r\n        out[15] = a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given array.\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromArray\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} a - The array to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    fromArray: function (a)\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        out[4] = a[4];\r\n        out[5] = a[5];\r\n        out[6] = a[6];\r\n        out[7] = a[7];\r\n        out[8] = a[8];\r\n        out[9] = a[9];\r\n        out[10] = a[10];\r\n        out[11] = a[11];\r\n        out[12] = a[12];\r\n        out[13] = a[13];\r\n        out[14] = a[14];\r\n        out[15] = a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset this Matrix.\r\n     *\r\n     * Sets all values to `0`.\r\n     *\r\n     * @method Phaser.Math.Matrix4#zero\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    zero: function ()\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = 0;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n        out[4] = 0;\r\n        out[5] = 0;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = 0;\r\n        out[11] = 0;\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = 0;\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the `x`, `y` and `z` values of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#xyz\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x value.\r\n     * @param {number} y - The y value.\r\n     * @param {number} z - The z value.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    xyz: function (x, y, z)\r\n    {\r\n        this.identity();\r\n\r\n        var out = this.val;\r\n\r\n        out[12] = x;\r\n        out[13] = y;\r\n        out[14] = z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the scaling values of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#scaling\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x scaling value.\r\n     * @param {number} y - The y scaling value.\r\n     * @param {number} z - The z scaling value.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    scaling: function (x, y, z)\r\n    {\r\n        this.zero();\r\n\r\n        var out = this.val;\r\n\r\n        out[0] = x;\r\n        out[5] = y;\r\n        out[10] = z;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset this Matrix to an identity (default) matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#identity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    identity: function ()\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = 1;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n        out[4] = 0;\r\n        out[5] = 1;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = 1;\r\n        out[11] = 0;\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = 0;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transpose this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#transpose\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    transpose: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n        var a23 = a[11];\r\n\r\n        a[1] = a[4];\r\n        a[2] = a[8];\r\n        a[3] = a[12];\r\n        a[4] = a01;\r\n        a[6] = a[9];\r\n        a[7] = a[13];\r\n        a[8] = a02;\r\n        a[9] = a12;\r\n        a[11] = a[14];\r\n        a[12] = a03;\r\n        a[13] = a13;\r\n        a[14] = a23;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Invert this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    invert: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b00 = a00 * a11 - a01 * a10;\r\n        var b01 = a00 * a12 - a02 * a10;\r\n        var b02 = a00 * a13 - a03 * a10;\r\n        var b03 = a01 * a12 - a02 * a11;\r\n\r\n        var b04 = a01 * a13 - a03 * a11;\r\n        var b05 = a02 * a13 - a03 * a12;\r\n        var b06 = a20 * a31 - a21 * a30;\r\n        var b07 = a20 * a32 - a22 * a30;\r\n\r\n        var b08 = a20 * a33 - a23 * a30;\r\n        var b09 = a21 * a32 - a22 * a31;\r\n        var b10 = a21 * a33 - a23 * a31;\r\n        var b11 = a22 * a33 - a23 * a32;\r\n\r\n        // Calculate the determinant\r\n        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n        if (!det)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        det = 1 / det;\r\n\r\n        a[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n        a[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n        a[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n        a[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\r\n        a[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n        a[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n        a[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n        a[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\r\n        a[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n        a[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n        a[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n        a[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\r\n        a[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\r\n        a[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\r\n        a[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\r\n        a[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the adjoint, or adjugate, of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#adjoint\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    adjoint: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        a[0] = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));\r\n        a[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\r\n        a[2] = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));\r\n        a[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\r\n        a[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\r\n        a[5] = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));\r\n        a[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\r\n        a[7] = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));\r\n        a[8] = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));\r\n        a[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\r\n        a[10] = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));\r\n        a[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\r\n        a[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\r\n        a[13] = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));\r\n        a[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\r\n        a[15] = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the determinant of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#determinant\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The determinant of this Matrix.\r\n     */\r\n    determinant: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b00 = a00 * a11 - a01 * a10;\r\n        var b01 = a00 * a12 - a02 * a10;\r\n        var b02 = a00 * a13 - a03 * a10;\r\n        var b03 = a01 * a12 - a02 * a11;\r\n        var b04 = a01 * a13 - a03 * a11;\r\n        var b05 = a02 * a13 - a03 * a12;\r\n        var b06 = a20 * a31 - a21 * a30;\r\n        var b07 = a20 * a32 - a22 * a30;\r\n        var b08 = a20 * a33 - a23 * a30;\r\n        var b09 = a21 * a32 - a22 * a31;\r\n        var b10 = a21 * a33 - a23 * a31;\r\n        var b11 = a22 * a33 - a23 * a32;\r\n\r\n        // Calculate the determinant\r\n        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - The Matrix to multiply this Matrix by.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    multiply: function (src)\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b = src.val;\r\n\r\n        // Cache only the current line of the second matrix\r\n        var b0 = b[0];\r\n        var b1 = b[1];\r\n        var b2 = b[2];\r\n        var b3 = b[3];\r\n\r\n        a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[4];\r\n        b1 = b[5];\r\n        b2 = b[6];\r\n        b3 = b[7];\r\n\r\n        a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[8];\r\n        b1 = b[9];\r\n        b2 = b[10];\r\n        b3 = b[11];\r\n\r\n        a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[12];\r\n        b1 = b[13];\r\n        b2 = b[14];\r\n        b3 = b[15];\r\n\r\n        a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#multiplyLocal\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    multiplyLocal: function (src)\r\n    {\r\n        var a = [];\r\n        var m1 = this.val;\r\n        var m2 = src.val;\r\n\r\n        a[0] = m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8] + m1[3] * m2[12];\r\n        a[1] = m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9] + m1[3] * m2[13];\r\n        a[2] = m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10] + m1[3] * m2[14];\r\n        a[3] = m1[0] * m2[3] + m1[1] * m2[7] + m1[2] * m2[11] + m1[3] * m2[15];\r\n\r\n        a[4] = m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8] + m1[7] * m2[12];\r\n        a[5] = m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9] + m1[7] * m2[13];\r\n        a[6] = m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10] + m1[7] * m2[14];\r\n        a[7] = m1[4] * m2[3] + m1[5] * m2[7] + m1[6] * m2[11] + m1[7] * m2[15];\r\n\r\n        a[8] = m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8] + m1[11] * m2[12];\r\n        a[9] = m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9] + m1[11] * m2[13];\r\n        a[10] = m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10] + m1[11] * m2[14];\r\n        a[11] = m1[8] * m2[3] + m1[9] * m2[7] + m1[10] * m2[11] + m1[11] * m2[15];\r\n\r\n        a[12] = m1[12] * m2[0] + m1[13] * m2[4] + m1[14] * m2[8] + m1[15] * m2[12];\r\n        a[13] = m1[12] * m2[1] + m1[13] * m2[5] + m1[14] * m2[9] + m1[15] * m2[13];\r\n        a[14] = m1[12] * m2[2] + m1[13] * m2[6] + m1[14] * m2[10] + m1[15] * m2[14];\r\n        a[15] = m1[12] * m2[3] + m1[13] * m2[7] + m1[14] * m2[11] + m1[15] * m2[15];\r\n\r\n        return this.fromArray(a);\r\n    },\r\n\r\n    /**\r\n     * Translate this Matrix using the given Vector.\r\n     *\r\n     * @method Phaser.Math.Matrix4#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    translate: function (v)\r\n    {\r\n        var x = v.x;\r\n        var y = v.y;\r\n        var z = v.z;\r\n        var a = this.val;\r\n\r\n        a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\r\n        a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\r\n        a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\r\n        a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translate this Matrix using the given values.\r\n     *\r\n     * @method Phaser.Math.Matrix4#translateXYZ\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x component.\r\n     * @param {number} y - The y component.\r\n     * @param {number} z - The z component.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    translateXYZ: function (x, y, z)\r\n    {\r\n        var a = this.val;\r\n\r\n        a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\r\n        a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\r\n        a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\r\n        a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a scale transformation to this Matrix.\r\n     *\r\n     * Uses the `x`, `y` and `z` components of the given Vector to scale the Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    scale: function (v)\r\n    {\r\n        var x = v.x;\r\n        var y = v.y;\r\n        var z = v.z;\r\n        var a = this.val;\r\n\r\n        a[0] = a[0] * x;\r\n        a[1] = a[1] * x;\r\n        a[2] = a[2] * x;\r\n        a[3] = a[3] * x;\r\n\r\n        a[4] = a[4] * y;\r\n        a[5] = a[5] * y;\r\n        a[6] = a[6] * y;\r\n        a[7] = a[7] * y;\r\n\r\n        a[8] = a[8] * z;\r\n        a[9] = a[9] * z;\r\n        a[10] = a[10] * z;\r\n        a[11] = a[11] * z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a scale transformation to this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#scaleXYZ\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x component.\r\n     * @param {number} y - The y component.\r\n     * @param {number} z - The z component.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    scaleXYZ: function (x, y, z)\r\n    {\r\n        var a = this.val;\r\n\r\n        a[0] = a[0] * x;\r\n        a[1] = a[1] * x;\r\n        a[2] = a[2] * x;\r\n        a[3] = a[3] * x;\r\n\r\n        a[4] = a[4] * y;\r\n        a[5] = a[5] * y;\r\n        a[6] = a[6] * y;\r\n        a[7] = a[7] * y;\r\n\r\n        a[8] = a[8] * z;\r\n        a[9] = a[9] * z;\r\n        a[10] = a[10] * z;\r\n        a[11] = a[11] * z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Derive a rotation matrix around the given axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#makeRotationAxis\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} axis - The rotation axis.\r\n     * @param {number} angle - The rotation angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    makeRotationAxis: function (axis, angle)\r\n    {\r\n        // Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n        var c = Math.cos(angle);\r\n        var s = Math.sin(angle);\r\n        var t = 1 - c;\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var tx = t * x;\r\n        var ty = t * y;\r\n\r\n        this.fromArray([\r\n            tx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n            tx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n            0, 0, 0, 1\r\n        ]);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a rotation transformation to this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle in radians to rotate by.\r\n     * @param {Phaser.Math.Vector3} axis - The axis to rotate upon.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotate: function (rad, axis)\r\n    {\r\n        var a = this.val;\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var len = Math.sqrt(x * x + y * y + z * z);\r\n\r\n        if (Math.abs(len) < EPSILON)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        len = 1 / len;\r\n        x *= len;\r\n        y *= len;\r\n        z *= len;\r\n\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n        var t = 1 - c;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        // Construct the elements of the rotation matrix\r\n        var b00 = x * x * t + c;\r\n        var b01 = y * x * t + z * s;\r\n        var b02 = z * x * t - y * s;\r\n\r\n        var b10 = x * y * t - z * s;\r\n        var b11 = y * y * t + c;\r\n        var b12 = z * y * t + x * s;\r\n\r\n        var b20 = x * z * t + y * s;\r\n        var b21 = y * z * t - x * s;\r\n        var b22 = z * z * t + c;\r\n\r\n        // Perform rotation-specific matrix multiplication\r\n        a[0] = a00 * b00 + a10 * b01 + a20 * b02;\r\n        a[1] = a01 * b00 + a11 * b01 + a21 * b02;\r\n        a[2] = a02 * b00 + a12 * b01 + a22 * b02;\r\n        a[3] = a03 * b00 + a13 * b01 + a23 * b02;\r\n        a[4] = a00 * b10 + a10 * b11 + a20 * b12;\r\n        a[5] = a01 * b10 + a11 * b11 + a21 * b12;\r\n        a[6] = a02 * b10 + a12 * b11 + a22 * b12;\r\n        a[7] = a03 * b10 + a13 * b11 + a23 * b12;\r\n        a[8] = a00 * b20 + a10 * b21 + a20 * b22;\r\n        a[9] = a01 * b20 + a11 * b21 + a21 * b22;\r\n        a[10] = a02 * b20 + a12 * b21 + a22 * b22;\r\n        a[11] = a03 * b20 + a13 * b21 + a23 * b22;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this matrix on its X axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle in radians to rotate by.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotateX: function (rad)\r\n    {\r\n        var a = this.val;\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        // Perform axis-specific matrix multiplication\r\n        a[4] = a10 * c + a20 * s;\r\n        a[5] = a11 * c + a21 * s;\r\n        a[6] = a12 * c + a22 * s;\r\n        a[7] = a13 * c + a23 * s;\r\n        a[8] = a20 * c - a10 * s;\r\n        a[9] = a21 * c - a11 * s;\r\n        a[10] = a22 * c - a12 * s;\r\n        a[11] = a23 * c - a13 * s;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this matrix on its Y axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle to rotate by, in radians.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotateY: function (rad)\r\n    {\r\n        var a = this.val;\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        // Perform axis-specific matrix multiplication\r\n        a[0] = a00 * c - a20 * s;\r\n        a[1] = a01 * c - a21 * s;\r\n        a[2] = a02 * c - a22 * s;\r\n        a[3] = a03 * c - a23 * s;\r\n        a[8] = a00 * s + a20 * c;\r\n        a[9] = a01 * s + a21 * c;\r\n        a[10] = a02 * s + a22 * c;\r\n        a[11] = a03 * s + a23 * c;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this matrix on its Z axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle to rotate by, in radians.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotateZ: function (rad)\r\n    {\r\n        var a = this.val;\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        // Perform axis-specific matrix multiplication\r\n        a[0] = a00 * c + a10 * s;\r\n        a[1] = a01 * c + a11 * s;\r\n        a[2] = a02 * c + a12 * s;\r\n        a[3] = a03 * c + a13 * s;\r\n        a[4] = a10 * c - a00 * s;\r\n        a[5] = a11 * c - a01 * s;\r\n        a[6] = a12 * c - a02 * s;\r\n        a[7] = a13 * c - a03 * s;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given rotation Quaternion and translation Vector.\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromRotationTranslation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set rotation from.\r\n     * @param {Phaser.Math.Vector3} v - The Vector to set translation from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    fromRotationTranslation: function (q, v)\r\n    {\r\n        // Quaternion math\r\n        var out = this.val;\r\n\r\n        var x = q.x;\r\n        var y = q.y;\r\n        var z = q.z;\r\n        var w = q.w;\r\n\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n\r\n        out[0] = 1 - (yy + zz);\r\n        out[1] = xy + wz;\r\n        out[2] = xz - wy;\r\n        out[3] = 0;\r\n\r\n        out[4] = xy - wz;\r\n        out[5] = 1 - (xx + zz);\r\n        out[6] = yz + wx;\r\n        out[7] = 0;\r\n\r\n        out[8] = xz + wy;\r\n        out[9] = yz - wx;\r\n        out[10] = 1 - (xx + yy);\r\n        out[11] = 0;\r\n\r\n        out[12] = v.x;\r\n        out[13] = v.y;\r\n        out[14] = v.z;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    fromQuat: function (q)\r\n    {\r\n        var out = this.val;\r\n\r\n        var x = q.x;\r\n        var y = q.y;\r\n        var z = q.z;\r\n        var w = q.w;\r\n\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n\r\n        out[0] = 1 - (yy + zz);\r\n        out[1] = xy + wz;\r\n        out[2] = xz - wy;\r\n        out[3] = 0;\r\n\r\n        out[4] = xy - wz;\r\n        out[5] = 1 - (xx + zz);\r\n        out[6] = yz + wx;\r\n        out[7] = 0;\r\n\r\n        out[8] = xz + wy;\r\n        out[9] = yz - wx;\r\n        out[10] = 1 - (xx + yy);\r\n        out[11] = 0;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = 0;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a frustum matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#frustum\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} left - The left bound of the frustum.\r\n     * @param {number} right - The right bound of the frustum.\r\n     * @param {number} bottom - The bottom bound of the frustum.\r\n     * @param {number} top - The top bound of the frustum.\r\n     * @param {number} near - The near bound of the frustum.\r\n     * @param {number} far - The far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    frustum: function (left, right, bottom, top, near, far)\r\n    {\r\n        var out = this.val;\r\n\r\n        var rl = 1 / (right - left);\r\n        var tb = 1 / (top - bottom);\r\n        var nf = 1 / (near - far);\r\n\r\n        out[0] = (near * 2) * rl;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = (near * 2) * tb;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = (right + left) * rl;\r\n        out[9] = (top + bottom) * tb;\r\n        out[10] = (far + near) * nf;\r\n        out[11] = -1;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = (far * near * 2) * nf;\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a perspective projection matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#perspective\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} fovy - Vertical field of view in radians\r\n     * @param {number} aspect - Aspect ratio. Typically viewport width  /height.\r\n     * @param {number} near - Near bound of the frustum.\r\n     * @param {number} far - Far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    perspective: function (fovy, aspect, near, far)\r\n    {\r\n        var out = this.val;\r\n        var f = 1.0 / Math.tan(fovy / 2);\r\n        var nf = 1 / (near - far);\r\n\r\n        out[0] = f / aspect;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = f;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = (far + near) * nf;\r\n        out[11] = -1;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = (2 * far * near) * nf;\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a perspective projection matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#perspectiveLH\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of the frustum.\r\n     * @param {number} height - The height of the frustum.\r\n     * @param {number} near - Near bound of the frustum.\r\n     * @param {number} far - Far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    perspectiveLH: function (width, height, near, far)\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = (2 * near) / width;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = (2 * near) / height;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = -far / (near - far);\r\n        out[11] = 1;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = (near * far) / (near - far);\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate an orthogonal projection matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#ortho\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} left - The left bound of the frustum.\r\n     * @param {number} right - The right bound of the frustum.\r\n     * @param {number} bottom - The bottom bound of the frustum.\r\n     * @param {number} top - The top bound of the frustum.\r\n     * @param {number} near - The near bound of the frustum.\r\n     * @param {number} far - The far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    ortho: function (left, right, bottom, top, near, far)\r\n    {\r\n        var out = this.val;\r\n        var lr = left - right;\r\n        var bt = bottom - top;\r\n        var nf = near - far;\r\n\r\n        //  Avoid division by zero\r\n        lr = (lr === 0) ? lr : 1 / lr;\r\n        bt = (bt === 0) ? bt : 1 / bt;\r\n        nf = (nf === 0) ? nf : 1 / nf;\r\n\r\n        out[0] = -2 * lr;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = -2 * bt;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = 2 * nf;\r\n        out[11] = 0;\r\n\r\n        out[12] = (left + right) * lr;\r\n        out[13] = (top + bottom) * bt;\r\n        out[14] = (far + near) * nf;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a look-at matrix with the given eye position, focal point, and up axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#lookAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} eye - Position of the viewer\r\n     * @param {Phaser.Math.Vector3} center - Point the viewer is looking at\r\n     * @param {Phaser.Math.Vector3} up - vec3 pointing up.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    lookAt: function (eye, center, up)\r\n    {\r\n        var out = this.val;\r\n\r\n        var eyex = eye.x;\r\n        var eyey = eye.y;\r\n        var eyez = eye.z;\r\n\r\n        var upx = up.x;\r\n        var upy = up.y;\r\n        var upz = up.z;\r\n\r\n        var centerx = center.x;\r\n        var centery = center.y;\r\n        var centerz = center.z;\r\n\r\n        if (Math.abs(eyex - centerx) < EPSILON &&\r\n            Math.abs(eyey - centery) < EPSILON &&\r\n            Math.abs(eyez - centerz) < EPSILON)\r\n        {\r\n            return this.identity();\r\n        }\r\n\r\n        var z0 = eyex - centerx;\r\n        var z1 = eyey - centery;\r\n        var z2 = eyez - centerz;\r\n\r\n        var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\r\n\r\n        z0 *= len;\r\n        z1 *= len;\r\n        z2 *= len;\r\n\r\n        var x0 = upy * z2 - upz * z1;\r\n        var x1 = upz * z0 - upx * z2;\r\n        var x2 = upx * z1 - upy * z0;\r\n\r\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\r\n\r\n        if (!len)\r\n        {\r\n            x0 = 0;\r\n            x1 = 0;\r\n            x2 = 0;\r\n        }\r\n        else\r\n        {\r\n            len = 1 / len;\r\n            x0 *= len;\r\n            x1 *= len;\r\n            x2 *= len;\r\n        }\r\n\r\n        var y0 = z1 * x2 - z2 * x1;\r\n        var y1 = z2 * x0 - z0 * x2;\r\n        var y2 = z0 * x1 - z1 * x0;\r\n\r\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\r\n\r\n        if (!len)\r\n        {\r\n            y0 = 0;\r\n            y1 = 0;\r\n            y2 = 0;\r\n        }\r\n        else\r\n        {\r\n            len = 1 / len;\r\n            y0 *= len;\r\n            y1 *= len;\r\n            y2 *= len;\r\n        }\r\n\r\n        out[0] = x0;\r\n        out[1] = y0;\r\n        out[2] = z0;\r\n        out[3] = 0;\r\n\r\n        out[4] = x1;\r\n        out[5] = y1;\r\n        out[6] = z1;\r\n        out[7] = 0;\r\n\r\n        out[8] = x2;\r\n        out[9] = y2;\r\n        out[10] = z2;\r\n        out[11] = 0;\r\n\r\n        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\r\n        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\r\n        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this matrix from the given `yaw`, `pitch` and `roll` values.\r\n     *\r\n     * @method Phaser.Math.Matrix4#yawPitchRoll\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} yaw - [description]\r\n     * @param {number} pitch - [description]\r\n     * @param {number} roll - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    yawPitchRoll: function (yaw, pitch, roll)\r\n    {\r\n        this.zero();\r\n        _tempMat1.zero();\r\n        _tempMat2.zero();\r\n\r\n        var m0 = this.val;\r\n        var m1 = _tempMat1.val;\r\n        var m2 = _tempMat2.val;\r\n\r\n        //  Rotate Z\r\n        var s = Math.sin(roll);\r\n        var c = Math.cos(roll);\r\n\r\n        m0[10] = 1;\r\n        m0[15] = 1;\r\n        m0[0] = c;\r\n        m0[1] = s;\r\n        m0[4] = -s;\r\n        m0[5] = c;\r\n\r\n        //  Rotate X\r\n        s = Math.sin(pitch);\r\n        c = Math.cos(pitch);\r\n\r\n        m1[0] = 1;\r\n        m1[15] = 1;\r\n        m1[5] = c;\r\n        m1[10] = c;\r\n        m1[9] = -s;\r\n        m1[6] = s;\r\n\r\n        //  Rotate Y\r\n        s = Math.sin(yaw);\r\n        c = Math.cos(yaw);\r\n\r\n        m2[5] = 1;\r\n        m2[15] = 1;\r\n        m2[0] = c;\r\n        m2[2] = -s;\r\n        m2[8] = s;\r\n        m2[10] = c;\r\n\r\n        this.multiplyLocal(_tempMat1);\r\n        this.multiplyLocal(_tempMat2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a world matrix from the given rotation, position, scale, view matrix and projection matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#setWorldMatrix\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} rotation - The rotation of the world matrix.\r\n     * @param {Phaser.Math.Vector3} position - The position of the world matrix.\r\n     * @param {Phaser.Math.Vector3} scale - The scale of the world matrix.\r\n     * @param {Phaser.Math.Matrix4} [viewMatrix] - The view matrix.\r\n     * @param {Phaser.Math.Matrix4} [projectionMatrix] - The projection matrix.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    setWorldMatrix: function (rotation, position, scale, viewMatrix, projectionMatrix)\r\n    {\r\n        this.yawPitchRoll(rotation.y, rotation.x, rotation.z);\r\n\r\n        _tempMat1.scaling(scale.x, scale.y, scale.z);\r\n        _tempMat2.xyz(position.x, position.y, position.z);\r\n\r\n        this.multiplyLocal(_tempMat1);\r\n        this.multiplyLocal(_tempMat2);\r\n\r\n        if (viewMatrix !== undefined)\r\n        {\r\n            this.multiplyLocal(viewMatrix);\r\n        }\r\n\r\n        if (projectionMatrix !== undefined)\r\n        {\r\n            this.multiplyLocal(projectionMatrix);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nvar _tempMat1 = new Matrix4();\r\nvar _tempMat2 = new Matrix4();\r\n\r\nmodule.exports = Matrix4;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @typedef {object} Vector2Like\r\n *\r\n * @property {number} x - The x component.\r\n * @property {number} y - The y component.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 2D space.\r\n *\r\n * A two-component vector.\r\n *\r\n * @class Vector2\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number|Vector2Like} [x] - The x component, or an object with `x` and `y` properties.\r\n * @param {number} [y] - The y component.\r\n */\r\nvar Vector2 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector2 (x, y)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n        }\r\n        else\r\n        {\r\n            if (y === undefined) { y = x; }\r\n\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector2.\r\n     *\r\n     * @method Phaser.Math.Vector2#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} A clone of this Vector2.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector2(this.x, this.y);\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x || 0;\r\n        this.y = src.y || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the component values of this Vector from a given Vector2Like object.\r\n     *\r\n     * @method Phaser.Math.Vector2#setFromObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Vector2Like} obj - The object containing the component values to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setFromObject: function (obj)\r\n    {\r\n        this.x = obj.x || 0;\r\n        this.y = obj.y || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.\r\n     *\r\n     * @method Phaser.Math.Vector2#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x value to set for this Vector.\r\n     * @param {number} [y=x] - The y value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    set: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method is an alias for `Vector2.set`.\r\n     *\r\n     * @method Phaser.Math.Vector2#setTo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The x value to set for this Vector.\r\n     * @param {number} [y=x] - The y value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setTo: function (x, y)\r\n    {\r\n        return this.set(x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the `x` and `y` values of this object from a given polar coordinate.\r\n     *\r\n     * @method Phaser.Math.Vector2#setToPolar\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} azimuth - The angular coordinate, in radians.\r\n     * @param {number} [radius=1] - The radial coordinate (length).\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setToPolar: function (azimuth, radius)\r\n    {\r\n        if (radius == null) { radius = 1; }\r\n\r\n        this.x = Math.cos(azimuth) * radius;\r\n        this.y = Math.sin(azimuth) * radius;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict equality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector2#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} v - The vector to compare with this Vector.\r\n     *\r\n     * @return {boolean} Whether the given Vector is equal to this Vector.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y));\r\n    },\r\n\r\n    /**\r\n     * Calculate the angle between this Vector and the positive x-axis, in radians.\r\n     *\r\n     * @method Phaser.Math.Vector2#angle\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The angle between this Vector, and the positive x-axis, given in radians.\r\n     */\r\n    angle: function ()\r\n    {\r\n        // computes the angle in radians with respect to the positive x-axis\r\n\r\n        var angle = Math.atan2(this.y, this.x);\r\n\r\n        if (angle < 0)\r\n        {\r\n            angle += 2 * Math.PI;\r\n        }\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector2#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    add: function (src)\r\n    {\r\n        this.x += src.x;\r\n        this.y += src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector2#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    subtract: function (src)\r\n    {\r\n        this.x -= src.x;\r\n        this.y -= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    multiply: function (src)\r\n    {\r\n        this.x *= src.x;\r\n        this.y *= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector2#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    scale: function (value)\r\n    {\r\n        if (isFinite(value))\r\n        {\r\n            this.x *= value;\r\n            this.y *= value;\r\n        }\r\n        else\r\n        {\r\n            this.x = 0;\r\n            this.y = 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    divide: function (src)\r\n    {\r\n        this.x /= src.x;\r\n        this.y /= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x` and `y` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (src)\r\n    {\r\n        var dx = src.x - this.x;\r\n        var dy = src.y - this.y;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector2#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (src)\r\n    {\r\n        var dx = src.x - this.x;\r\n        var dy = src.y - this.y;\r\n\r\n        return dx * dx + dy * dy;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        return Math.sqrt(x * x + y * y);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector2#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        return x * x + y * y;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var len = x * x + y * y;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Right-hand normalize (make unit length) this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalizeRightHand\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalizeRightHand: function ()\r\n    {\r\n        var x = this.x;\r\n\r\n        this.x = this.y * -1;\r\n        this.y = x;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to dot product with this Vector2.\r\n     *\r\n     * @return {number} The dot product of this Vector and the given Vector.\r\n     */\r\n    dot: function (src)\r\n    {\r\n        return this.x * src.x + this.y * src.y;\r\n    },\r\n\r\n    /**\r\n     * Calculate the cross product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#cross\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to cross with this Vector2.\r\n     *\r\n     * @return {number} The cross product of this Vector and the given Vector.\r\n     */\r\n    cross: function (src)\r\n    {\r\n        return this.x * src.y - this.y * src.x;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    lerp: function (src, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n\r\n        this.x = ax + t * (src.x - ax);\r\n        this.y = ay + t * (src.y - ay);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    transformMat3: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[3] * y + m[6];\r\n        this.y = m[1] * x + m[4] * y + m[7];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[12];\r\n        this.y = m[1] * x + m[5] * y + m[13];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector2#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * A static zero Vector2 for use by reference.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ZERO\r\n * @type {Vector2}\r\n * @since 3.1.0\r\n */\r\nVector2.ZERO = new Vector2();\r\n\r\nmodule.exports = Vector2;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * Wrap the given `value` between `min` and `max.\r\n *\r\n * @function Phaser.Math.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to wrap.\r\n * @param {number} min - The minimum value.\r\n * @param {number} max - The maximum value.\r\n *\r\n * @return {number} The wrapped value.\r\n */\r\nvar Wrap = function (value, min, max)\r\n{\r\n    var range = max - min;\r\n\r\n    return (min + ((((value - min) % range) + range) % range));\r\n};\r\n\r\nmodule.exports = Wrap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar CONST = require('../const');\r\n\r\n/**\r\n * Takes an angle in Phasers default clockwise format and converts it so that\r\n * 0 is North, 90 is West, 180 is South and 270 is East,\r\n * therefore running counter-clockwise instead of clockwise.\r\n * \r\n * You can pass in the angle from a Game Object using:\r\n * \r\n * ```javascript\r\n * var converted = CounterClockwise(gameobject.rotation);\r\n * ```\r\n * \r\n * All values for this function are in radians.\r\n *\r\n * @function Phaser.Math.Angle.CounterClockwise\r\n * @since 3.16.0\r\n *\r\n * @param {number} angle - The angle to convert, in radians.\r\n *\r\n * @return {number} The converted angle, in radians.\r\n */\r\nvar CounterClockwise = function (angle)\r\n{\r\n    return Math.abs((((angle + CONST.TAU) % CONST.PI2) - CONST.PI2) % CONST.PI2);\r\n};\r\n\r\nmodule.exports = CounterClockwise;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar MathWrap = require('../Wrap');\r\n\r\n/**\r\n * Wrap an angle.\r\n *\r\n * Wraps the angle to a value in the range of -PI to PI.\r\n *\r\n * @function Phaser.Math.Angle.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to wrap, in radians.\r\n *\r\n * @return {number} The wrapped angle, in radians.\r\n */\r\nvar Wrap = function (angle)\r\n{\r\n    return MathWrap(angle, -Math.PI, Math.PI);\r\n};\r\n\r\nmodule.exports = Wrap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Wrap = require('../Wrap');\r\n\r\n/**\r\n * Wrap an angle in degrees.\r\n *\r\n * Wraps the angle to a value in the range of -180 to 180.\r\n *\r\n * @function Phaser.Math.Angle.WrapDegrees\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to wrap, in degrees.\r\n *\r\n * @return {number} The wrapped angle, in degrees.\r\n */\r\nvar WrapDegrees = function (angle)\r\n{\r\n    return Wrap(angle, -180, 180);\r\n};\r\n\r\nmodule.exports = WrapDegrees;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar MATH_CONST = {\r\n\r\n    /**\r\n     * The value of PI * 2.\r\n     * \r\n     * @name Phaser.Math.PI2\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    PI2: Math.PI * 2,\r\n\r\n    /**\r\n     * The value of PI * 0.5.\r\n     * \r\n     * @name Phaser.Math.TAU\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TAU: Math.PI * 0.5,\r\n\r\n    /**\r\n     * An epsilon value (1.0e-6)\r\n     * \r\n     * @name Phaser.Math.EPSILON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    EPSILON: 1.0e-6,\r\n\r\n    /**\r\n     * For converting degrees to radians (PI / 180)\r\n     * \r\n     * @name Phaser.Math.DEG_TO_RAD\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    DEG_TO_RAD: Math.PI / 180,\r\n\r\n    /**\r\n     * For converting radians to degrees (180 / PI)\r\n     * \r\n     * @name Phaser.Math.RAD_TO_DEG\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    RAD_TO_DEG: 180 / Math.PI,\r\n\r\n    /**\r\n     * An instance of the Random Number Generator.\r\n     * \r\n     * @name Phaser.Math.RND\r\n     * @type {Phaser.Math.RandomDataGenerator}\r\n     * @since 3.0.0\r\n     */\r\n    RND: null\r\n\r\n};\r\n\r\nmodule.exports = MATH_CONST;\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2018 Photon Storm Ltd.\r\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Global Plugin is installed just once into the Game owned Plugin Manager.\r\n * It can listen for Game events and respond to them.\r\n *\r\n * @class BasePlugin\r\n * @memberof Phaser.Plugins\r\n * @constructor\r\n * @since 3.8.0\r\n *\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.\r\n */\r\nvar BasePlugin = new Class({\r\n\r\n    initialize:\r\n\r\n    function BasePlugin (pluginManager)\r\n    {\r\n        /**\r\n         * A handy reference to the Plugin Manager that is responsible for this plugin.\r\n         * Can be used as a route to gain access to game systems and  events.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#pluginManager\r\n         * @type {Phaser.Plugins.PluginManager}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.pluginManager = pluginManager;\r\n\r\n        /**\r\n         * A reference to the Game instance this plugin is running under.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#game\r\n         * @type {Phaser.Game}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.game = pluginManager.game;\r\n\r\n        /**\r\n         * A reference to the Scene that has installed this plugin.\r\n         * Only set if it's a Scene Plugin, otherwise `null`.\r\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\r\n         * You cannot use it during the `init` method, but you can during the `boot` method.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#scene\r\n         * @type {?Phaser.Scene}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems of the Scene that has installed this plugin.\r\n         * Only set if it's a Scene Plugin, otherwise `null`.\r\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\r\n         * You cannot use it during the `init` method, but you can during the `boot` method.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#systems\r\n         * @type {?Phaser.Scenes.Systems}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.systems;\r\n    },\r\n\r\n    /**\r\n     * Called by the PluginManager when this plugin is first instantiated.\r\n     * It will never be called again on this instance.\r\n     * In here you can set-up whatever you need for this plugin to run.\r\n     * If a plugin is set to automatically start then `BasePlugin.start` will be called immediately after this.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#init\r\n     * @since 3.8.0\r\n     *\r\n     * @param {?any} [data] - A value specified by the user, if any, from the `data` property of the plugin's configuration object (if started at game boot) or passed in the PluginManager's `install` method (if started manually).\r\n     */\r\n    init: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Called by the PluginManager when this plugin is started.\r\n     * If a plugin is stopped, and then started again, this will get called again.\r\n     * Typically called immediately after `BasePlugin.init`.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#start\r\n     * @since 3.8.0\r\n     */\r\n    start: function ()\r\n    {\r\n        //  Here are the game-level events you can listen to.\r\n        //  At the very least you should offer a destroy handler for when the game closes down.\r\n\r\n        // var eventEmitter = this.game.events;\r\n\r\n        // eventEmitter.once('destroy', this.gameDestroy, this);\r\n        // eventEmitter.on('pause', this.gamePause, this);\r\n        // eventEmitter.on('resume', this.gameResume, this);\r\n        // eventEmitter.on('resize', this.gameResize, this);\r\n        // eventEmitter.on('prestep', this.gamePreStep, this);\r\n        // eventEmitter.on('step', this.gameStep, this);\r\n        // eventEmitter.on('poststep', this.gamePostStep, this);\r\n        // eventEmitter.on('prerender', this.gamePreRender, this);\r\n        // eventEmitter.on('postrender', this.gamePostRender, this);\r\n    },\r\n\r\n    /**\r\n     * Called by the PluginManager when this plugin is stopped.\r\n     * The game code has requested that your plugin stop doing whatever it does.\r\n     * It is now considered as 'inactive' by the PluginManager.\r\n     * Handle that process here (i.e. stop listening for events, etc)\r\n     * If the plugin is started again then `BasePlugin.start` will be called again.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#stop\r\n     * @since 3.8.0\r\n     */\r\n    stop: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.\r\n     * By this point the plugin properties `scene` and `systems` will have already been set.\r\n     * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#boot\r\n     * @since 3.8.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        //  Here are the Scene events you can listen to.\r\n        //  At the very least you should offer a destroy handler for when the Scene closes down.\r\n\r\n        // var eventEmitter = this.systems.events;\r\n\r\n        // eventEmitter.once('destroy', this.sceneDestroy, this);\r\n        // eventEmitter.on('start', this.sceneStart, this);\r\n        // eventEmitter.on('preupdate', this.scenePreUpdate, this);\r\n        // eventEmitter.on('update', this.sceneUpdate, this);\r\n        // eventEmitter.on('postupdate', this.scenePostUpdate, this);\r\n        // eventEmitter.on('pause', this.scenePause, this);\r\n        // eventEmitter.on('resume', this.sceneResume, this);\r\n        // eventEmitter.on('sleep', this.sceneSleep, this);\r\n        // eventEmitter.on('wake', this.sceneWake, this);\r\n        // eventEmitter.on('shutdown', this.sceneShutdown, this);\r\n        // eventEmitter.on('destroy', this.sceneDestroy, this);\r\n    },\r\n\r\n    /**\r\n     * Game instance has been destroyed.\r\n     * You must release everything in here, all references, all objects, free it all up.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#destroy\r\n     * @since 3.8.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pluginManager = null;\r\n        this.game = null;\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BasePlugin;\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2018 Photon Storm Ltd.\r\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nvar BasePlugin = require('./BasePlugin');\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Scene Level Plugin is installed into every Scene and belongs to that Scene.\r\n * It can listen for Scene events and respond to them.\r\n * It can map itself to a Scene property, or into the Scene Systems, or both.\r\n *\r\n * @class ScenePlugin\r\n * @memberof Phaser.Plugins\r\n * @extends Phaser.Plugins.BasePlugin\r\n * @constructor\r\n * @since 3.8.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.\r\n */\r\nvar ScenePlugin = new Class({\r\n\r\n    Extends: BasePlugin,\r\n\r\n    initialize:\r\n\r\n    function ScenePlugin (scene, pluginManager)\r\n    {\r\n        BasePlugin.call(this, pluginManager);\r\n\r\n        this.scene = scene;\r\n        this.systems = scene.sys;\r\n\r\n        scene.sys.events.once('boot', this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called when the Scene boots. It is only ever called once.\r\n     * \r\n     * By this point the plugin properties `scene` and `systems` will have already been set.\r\n     * \r\n     * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\r\n     * Here are the Scene events you can listen to:\r\n     * \r\n     * start\r\n     * ready\r\n     * preupdate\r\n     * update\r\n     * postupdate\r\n     * resize\r\n     * pause\r\n     * resume\r\n     * sleep\r\n     * wake\r\n     * transitioninit\r\n     * transitionstart\r\n     * transitioncomplete\r\n     * transitionout\r\n     * shutdown\r\n     * destroy\r\n     * \r\n     * At the very least you should offer a destroy handler for when the Scene closes down, i.e:\r\n     *\r\n     * ```javascript\r\n     * var eventEmitter = this.systems.events;\r\n     * eventEmitter.once('destroy', this.sceneDestroy, this);\r\n     * ```\r\n     *\r\n     * @method Phaser.Plugins.ScenePlugin#boot\r\n     * @since 3.8.0\r\n     */\r\n    boot: function ()\r\n    {\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ScenePlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Blend Modes.\r\n * \r\n * @name Phaser.BlendModes\r\n * @enum {integer}\r\n * @memberof Phaser\r\n * @readonly\r\n * @since 3.0.0\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * Skips the Blend Mode check in the renderer.\r\n     * \r\n     * @name Phaser.BlendModes.SKIP_CHECK\r\n     */\r\n    SKIP_CHECK: -1,\r\n\r\n    /**\r\n     * Normal blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.NORMAL\r\n     */\r\n    NORMAL: 0,\r\n\r\n    /**\r\n     * Add blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.ADD\r\n     */\r\n    ADD: 1,\r\n\r\n    /**\r\n     * Multiply blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.MULTIPLY\r\n     */\r\n    MULTIPLY: 2,\r\n\r\n    /**\r\n     * Screen blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.SCREEN\r\n     */\r\n    SCREEN: 3,\r\n\r\n    /**\r\n     * Overlay blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.OVERLAY\r\n     */\r\n    OVERLAY: 4,\r\n\r\n    /**\r\n     * Darken blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.DARKEN\r\n     */\r\n    DARKEN: 5,\r\n\r\n    /**\r\n     * Lighten blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.LIGHTEN\r\n     */\r\n    LIGHTEN: 6,\r\n\r\n    /**\r\n     * Color Dodge blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR_DODGE\r\n     */\r\n    COLOR_DODGE: 7,\r\n\r\n    /**\r\n     * Color Burn blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR_BURN\r\n     */\r\n    COLOR_BURN: 8,\r\n\r\n    /**\r\n     * Hard Light blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.HARD_LIGHT\r\n     */\r\n    HARD_LIGHT: 9,\r\n\r\n    /**\r\n     * Soft Light blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.SOFT_LIGHT\r\n     */\r\n    SOFT_LIGHT: 10,\r\n\r\n    /**\r\n     * Difference blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.DIFFERENCE\r\n     */\r\n    DIFFERENCE: 11,\r\n\r\n    /**\r\n     * Exclusion blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.EXCLUSION\r\n     */\r\n    EXCLUSION: 12,\r\n\r\n    /**\r\n     * Hue blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.HUE\r\n     */\r\n    HUE: 13,\r\n\r\n    /**\r\n     * Saturation blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.SATURATION\r\n     */\r\n    SATURATION: 14,\r\n\r\n    /**\r\n     * Color blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR\r\n     */\r\n    COLOR: 15,\r\n\r\n    /**\r\n     * Luminosity blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.LUMINOSITY\r\n     */\r\n    LUMINOSITY: 16\r\n\r\n};\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class  Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\n/**\r\n * A NOOP (No Operation) callback function.\r\n *\r\n * Used internally by Phaser when it's more expensive to determine if a callback exists\r\n * than it is to just invoke an empty function.\r\n *\r\n * @function Phaser.Utils.NOOP\r\n * @since 3.0.0\r\n */\r\nvar NOOP = function ()\r\n{\r\n    //  NOOP\r\n};\r\n\r\nmodule.exports = NOOP;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar IsPlainObject = require('./IsPlainObject');\r\n\r\n// @param {boolean} deep - Perform a deep copy?\r\n// @param {object} target - The target object to copy to.\r\n// @return {object} The extended object.\r\n\r\n/**\r\n * This is a slightly modified version of http://api.jquery.com/jQuery.extend/\r\n *\r\n * @function Phaser.Utils.Objects.Extend\r\n * @since 3.0.0\r\n *\r\n * @return {object} The extended object.\r\n */\r\nvar Extend = function ()\r\n{\r\n    var options, name, src, copy, copyIsArray, clone,\r\n        target = arguments[0] || {},\r\n        i = 1,\r\n        length = arguments.length,\r\n        deep = false;\r\n\r\n    // Handle a deep copy situation\r\n    if (typeof target === 'boolean')\r\n    {\r\n        deep = target;\r\n        target = arguments[1] || {};\r\n\r\n        // skip the boolean and the target\r\n        i = 2;\r\n    }\r\n\r\n    // extend Phaser if only one argument is passed\r\n    if (length === i)\r\n    {\r\n        target = this;\r\n        --i;\r\n    }\r\n\r\n    for (; i < length; i++)\r\n    {\r\n        // Only deal with non-null/undefined values\r\n        if ((options = arguments[i]) != null)\r\n        {\r\n            // Extend the base object\r\n            for (name in options)\r\n            {\r\n                src = target[name];\r\n                copy = options[name];\r\n\r\n                // Prevent never-ending loop\r\n                if (target === copy)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                // Recurse if we're merging plain objects or arrays\r\n                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))\r\n                {\r\n                    if (copyIsArray)\r\n                    {\r\n                        copyIsArray = false;\r\n                        clone = src && Array.isArray(src) ? src : [];\r\n                    }\r\n                    else\r\n                    {\r\n                        clone = src && IsPlainObject(src) ? src : {};\r\n                    }\r\n\r\n                    // Never move original objects, clone them\r\n                    target[name] = Extend(deep, clone, copy);\r\n\r\n                // Don't bring in undefined values\r\n                }\r\n                else if (copy !== undefined)\r\n                {\r\n                    target[name] = copy;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Return the modified object\r\n    return target;\r\n};\r\n\r\nmodule.exports = Extend;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * Finds the key within the top level of the {@link source} object, or returns {@link defaultValue}\r\n *\r\n * @function Phaser.Utils.Objects.GetFastValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to search\r\n * @param {string} key - The key for the property on source. Must exist at the top level of the source object (no periods)\r\n * @param {*} [defaultValue] - The default value to use if the key does not exist.\r\n *\r\n * @return {*} The value if found; otherwise, defaultValue (null if none provided)\r\n */\r\nvar GetFastValue = function (source, key, defaultValue)\r\n{\r\n    var t = typeof(source);\r\n\r\n    if (!source || t === 'number' || t === 'string')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key) && source[key] !== undefined)\r\n    {\r\n        return source[key];\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetFastValue;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n//  Source object\r\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\r\n//  The default value to use if the key doesn't exist\r\n\r\n/**\r\n * Retrieves a value from an object.\r\n *\r\n * @function Phaser.Utils.Objects.GetValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\r\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\r\n *\r\n * @return {*} The value of the requested key.\r\n */\r\nvar GetValue = function (source, key, defaultValue)\r\n{\r\n    if (!source || typeof source === 'number')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key))\r\n    {\r\n        return source[key];\r\n    }\r\n    else if (key.indexOf('.'))\r\n    {\r\n        var keys = key.split('.');\r\n        var parent = source;\r\n        var value = defaultValue;\r\n\r\n        //  Use for loop here so we can break early\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            if (parent.hasOwnProperty(keys[i]))\r\n            {\r\n                //  Yes it has a key property, let's carry on down\r\n                value = parent[keys[i]];\r\n\r\n                parent = parent[keys[i]];\r\n            }\r\n            else\r\n            {\r\n                //  Can't go any further, so reset to default\r\n                value = defaultValue;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetValue;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * This is a slightly modified version of jQuery.isPlainObject.\r\n * A plain object is an object whose internal class property is [object Object].\r\n *\r\n * @function Phaser.Utils.Objects.IsPlainObject\r\n * @since 3.0.0\r\n *\r\n * @param {object} obj - The object to inspect.\r\n *\r\n * @return {boolean} `true` if the object is plain, otherwise `false`.\r\n */\r\nvar IsPlainObject = function (obj)\r\n{\r\n    // Not plain objects:\r\n    // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\r\n    // - DOM nodes\r\n    // - window\r\n    if (typeof(obj) !== 'object' || obj.nodeType || obj === obj.window)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    // Support: Firefox <20\r\n    // The try/catch suppresses exceptions thrown when attempting to access\r\n    // the \"constructor\" property of certain host objects, ie. |window.location|\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\r\n    try\r\n    {\r\n        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf'))\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n    catch (e)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    // If the function hasn't returned already, we're confident that\r\n    // |obj| is a plain object, created by {} or constructed with new Object\r\n    return true;\r\n};\r\n\r\nmodule.exports = IsPlainObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../src/utils/Class');\r\nvar ScenePlugin = require('../../../src/plugins/ScenePlugin');\r\nvar SpineFile = require('./SpineFile');\r\nvar SpineGameObject = require('./gameobject/SpineGameObject');\r\n\r\nvar runtime;\r\n\r\n/**\r\n * @classdesc\r\n * TODO\r\n *\r\n * @class SpinePlugin\r\n * @extends Phaser.Plugins.ScenePlugin\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Phaser Plugin Manager.\r\n */\r\nvar SpinePlugin = new Class({\r\n\r\n    Extends: ScenePlugin,\r\n\r\n    initialize:\r\n\r\n    function SpinePlugin (scene, pluginManager, SpineRuntime)\r\n    {\r\n        console.log('BaseSpinePlugin created');\r\n\r\n        ScenePlugin.call(this, scene, pluginManager);\r\n\r\n        var game = pluginManager.game;\r\n\r\n        //  Create a custom cache to store the spine data (.atlas files)\r\n        this.cache = game.cache.addCustom('spine');\r\n\r\n        this.json = game.cache.json;\r\n\r\n        this.textures = game.textures;\r\n\r\n        this.skeletonRenderer;\r\n\r\n        this.drawDebug = false;\r\n\r\n        //  Register our file type\r\n        pluginManager.registerFileType('spine', this.spineFileCallback, scene);\r\n\r\n        //  Register our game object\r\n        pluginManager.registerGameObject('spine', this.createSpineFactory(this));\r\n\r\n        runtime = SpineRuntime;\r\n    },\r\n\r\n    spineFileCallback: function (key, jsonURL, atlasURL, jsonXhrSettings, atlasXhrSettings)\r\n    {\r\n        var multifile;\r\n   \r\n        if (Array.isArray(key))\r\n        {\r\n            for (var i = 0; i < key.length; i++)\r\n            {\r\n                multifile = new SpineFile(this, key[i]);\r\n    \r\n                this.addFile(multifile.files);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            multifile = new SpineFile(this, key, jsonURL, atlasURL, jsonXhrSettings, atlasXhrSettings);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n        \r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Spine Game Object and adds it to the Scene.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#spineFactory\r\n     * @since 3.16.0\r\n     * \r\n     * @param {number} x - The horizontal position of this Game Object.\r\n     * @param {number} y - The vertical position of this Game Object.\r\n     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.GameObjects.Spine} The Game Object that was created.\r\n     */\r\n    createSpineFactory: function (plugin)\r\n    {\r\n        var callback = function (x, y, key, animationName, loop)\r\n        {\r\n            var spineGO = new SpineGameObject(this.scene, plugin, x, y, key, animationName, loop);\r\n\r\n            this.displayList.add(spineGO);\r\n            this.updateList.add(spineGO);\r\n        \r\n            return spineGO;\r\n        };\r\n\r\n        return callback;\r\n    },\r\n\r\n    getRuntime: function ()\r\n    {\r\n        return runtime;\r\n    },\r\n\r\n    createSkeleton: function (key, skeletonJSON)\r\n    {\r\n        var atlas = this.getAtlas(key);\r\n\r\n        var atlasLoader = new runtime.AtlasAttachmentLoader(atlas);\r\n        \r\n        var skeletonJson = new runtime.SkeletonJson(atlasLoader);\r\n\r\n        var data = (skeletonJSON) ? skeletonJSON : this.json.get(key);\r\n\r\n        var skeletonData = skeletonJson.readSkeletonData(data);\r\n\r\n        var skeleton = new runtime.Skeleton(skeletonData);\r\n    \r\n        return { skeletonData: skeletonData, skeleton: skeleton };\r\n    },\r\n\r\n    getBounds: function (skeleton)\r\n    {\r\n        var offset = new runtime.Vector2();\r\n        var size = new runtime.Vector2();\r\n\r\n        skeleton.getBounds(offset, size, []);\r\n\r\n        return { offset: offset, size: size };\r\n    },\r\n\r\n    createAnimationState: function (skeleton)\r\n    {\r\n        var stateData = new runtime.AnimationStateData(skeleton.data);\r\n\r\n        var state = new runtime.AnimationState(stateData);\r\n\r\n        return { stateData: stateData, state: state };\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Camera3DPlugin#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off('update', this.update, this);\r\n        eventEmitter.off('shutdown', this.shutdown, this);\r\n\r\n        this.removeAll();\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Camera3DPlugin#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.pluginManager = null;\r\n        this.game = null;\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SpinePlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../src/utils/Class');\r\nvar GetFastValue = require('../../../src/utils/object/GetFastValue');\r\nvar ImageFile = require('../../../src/loader/filetypes/ImageFile.js');\r\nvar IsPlainObject = require('../../../src/utils/object/IsPlainObject');\r\nvar JSONFile = require('../../../src/loader/filetypes/JSONFile.js');\r\nvar MultiFile = require('../../../src/loader/MultiFile.js');\r\nvar TextFile = require('../../../src/loader/filetypes/TextFile.js');\r\n\r\n/**\r\n * @typedef {object} Phaser.Loader.FileTypes.SpineFileConfig\r\n *\r\n * @property {string} key - The key of the file. Must be unique within both the Loader and the Texture Manager.\r\n * @property {string} [textureURL] - The absolute or relative URL to load the texture image file from.\r\n * @property {string} [textureExtension='png'] - The default file extension to use for the image texture if no url is provided.\r\n * @property {XHRSettingsObject} [textureXhrSettings] - Extra XHR Settings specifically for the texture image file.\r\n * @property {string} [normalMap] - The filename of an associated normal map. It uses the same path and url to load as the texture image.\r\n * @property {string} [atlasURL] - The absolute or relative URL to load the atlas data file from.\r\n * @property {string} [atlasExtension='txt'] - The default file extension to use for the atlas data if no url is provided.\r\n * @property {XHRSettingsObject} [atlasXhrSettings] - Extra XHR Settings specifically for the atlas data file.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Spine File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#spine method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#spine.\r\n *\r\n * @class SpineFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Loader.FileTypes.UnityAtlasFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar SpineFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function SpineFile (loader, key, jsonURL, atlasURL, jsonXhrSettings, atlasXhrSettings)\r\n    {\r\n        var json;\r\n        var atlas;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            json = new JSONFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'jsonURL'),\r\n                extension: GetFastValue(config, 'jsonExtension', 'json'),\r\n                xhrSettings: GetFastValue(config, 'jsonXhrSettings')\r\n            });\r\n\r\n            atlas = new TextFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'atlasURL'),\r\n                extension: GetFastValue(config, 'atlasExtension', 'atlas'),\r\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            json = new JSONFile(loader, key, jsonURL, jsonXhrSettings);\r\n            atlas = new TextFile(loader, key, atlasURL, atlasXhrSettings);\r\n        }\r\n        \r\n        atlas.cache = loader.cacheManager.custom.spine;\r\n\r\n        MultiFile.call(this, loader, 'spine', key, [ json, atlas ]);\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n\r\n            if (file.type === 'text')\r\n            {\r\n                //  Inspect the data for the files to now load\r\n                var content = file.data.split('\\n');\r\n\r\n                //  Extract the textures\r\n                var textures = [];\r\n\r\n                for (var t = 0; t < content.length; t++)\r\n                {\r\n                    var line = content[t];\r\n\r\n                    if (line.trim() === '' && t < content.length - 1)\r\n                    {\r\n                        line = content[t + 1];\r\n\r\n                        textures.push(line);\r\n                    }\r\n                }\r\n\r\n                var config = this.config;\r\n                var loader = this.loader;\r\n\r\n                var currentBaseURL = loader.baseURL;\r\n                var currentPath = loader.path;\r\n                var currentPrefix = loader.prefix;\r\n\r\n                var baseURL = GetFastValue(config, 'baseURL', currentBaseURL);\r\n                var path = GetFastValue(config, 'path', currentPath);\r\n                var prefix = GetFastValue(config, 'prefix', currentPrefix);\r\n                var textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\r\n\r\n                loader.setBaseURL(baseURL);\r\n                loader.setPath(path);\r\n                loader.setPrefix(prefix);\r\n\r\n                for (var i = 0; i < textures.length; i++)\r\n                {\r\n                    var textureURL = textures[i];\r\n\r\n                    var key = '_SP_' + textureURL;\r\n\r\n                    var image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n\r\n                    this.addToMultiFile(image);\r\n\r\n                    loader.addFile(image);\r\n                }\r\n\r\n                //  Reset the loader settings\r\n                loader.setBaseURL(currentBaseURL);\r\n                loader.setPath(currentPath);\r\n                loader.setPrefix(currentPrefix);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SpineFile#addToCache\r\n     * @since 3.16.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var fileJSON = this.files[0];\r\n\r\n            fileJSON.addToCache();\r\n\r\n            var fileText = this.files[1];\r\n\r\n            fileText.addToCache();\r\n\r\n            for (var i = 2; i < this.files.length; i++)\r\n            {\r\n                var file = this.files[i];\r\n\r\n                var key = file.key.substr(4).trim();\r\n\r\n                this.loader.textureManager.addImage(key, file.data);\r\n\r\n                file.pendingDestroy();\r\n            }\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Unity YAML based Texture Atlas, or array of atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.txt');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in a YAML formatted text file as exported from Unity.\r\n * \r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.unityAtlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     atlasURL: 'images/MainMenu.txt'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Loader.FileTypes.SpineFileConfig` for more details.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n * \r\n * ```javascript\r\n * this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'mainmenu', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n * \r\n * ```javascript\r\n * this.load.unityAtlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.txt');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n * \r\n * ```javascript\r\n * this.load.unityAtlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     normalMap: 'images/MainMenu-n.png',\r\n *     atlasURL: 'images/MainMenu.txt'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Unity Atlas File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#spine\r\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n * @since 3.16.0\r\n *\r\n * @param {(string|Phaser.Loader.FileTypes.SpineFileConfig|Phaser.Loader.FileTypes.SpineFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\nFileTypesManager.register('spine', function (key, jsonURL, atlasURL, jsonXhrSettings, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new SpineFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new SpineFile(this, key, jsonURL, atlasURL, jsonXhrSettings, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n */\r\n\r\nmodule.exports = SpineFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../src/utils/Class');\r\nvar BaseSpinePlugin = require('./BaseSpinePlugin');\r\nvar SpineWebGL = require('SpineWebGL');\r\nvar Matrix4 = require('../../../src/math/Matrix4');\r\n\r\n/**\r\n * @classdesc\r\n * Just the WebGL Runtime.\r\n *\r\n * @class SpinePlugin\r\n * @extends Phaser.Plugins.ScenePlugin\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Phaser Plugin Manager.\r\n */\r\nvar SpineWebGLPlugin = new Class({\r\n\r\n    Extends: BaseSpinePlugin,\r\n\r\n    initialize:\r\n\r\n    function SpineWebGLPlugin (scene, pluginManager)\r\n    {\r\n        console.log('SpineWebGLPlugin created');\r\n\r\n        BaseSpinePlugin.call(this, scene, pluginManager, SpineWebGL);\r\n\r\n        this.gl;\r\n        this.mvp;\r\n        this.shader;\r\n        this.batcher;\r\n        this.debugRenderer;\r\n        this.debugShader;\r\n    },\r\n\r\n    boot: function ()\r\n    {\r\n        var gl = this.game.renderer.gl;\r\n\r\n        this.gl = gl;\r\n\r\n        this.mvp = new Matrix4();\r\n\r\n        //  Create a simple shader, mesh, model-view-projection matrix and SkeletonRenderer.\r\n        this.shader = SpineWebGL.webgl.Shader.newTwoColoredTextured(gl);\r\n        this.batcher = new SpineWebGL.webgl.PolygonBatcher(gl);\r\n\r\n        this.skeletonRenderer = new SpineWebGL.webgl.SkeletonRenderer(gl);\r\n        this.skeletonRenderer.premultipliedAlpha = true;\r\n\r\n        this.shapes = new SpineWebGL.webgl.ShapeRenderer(gl);\r\n\r\n        this.debugRenderer = new SpineWebGL.webgl.SkeletonDebugRenderer(gl);\r\n\r\n        this.debugShader = SpineWebGL.webgl.Shader.newColored(gl);\r\n    },\r\n\r\n    getAtlas: function (key)\r\n    {\r\n        var atlasData = this.cache.get(key);\r\n\r\n        if (!atlasData)\r\n        {\r\n            console.warn('No atlas data for: ' + key);\r\n            return;\r\n        }\r\n\r\n        var textures = this.textures;\r\n\r\n        var gl = this.game.renderer.gl;\r\n\r\n        var atlas = new SpineWebGL.TextureAtlas(atlasData, function (path)\r\n        {\r\n            return new SpineWebGL.webgl.GLTexture(gl, textures.get(path).getSourceImage());\r\n        });\r\n\r\n        return atlas;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SpineWebGLPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../../src/utils/Class');\r\nvar ComponentsAlpha = require('../../../../src/gameobjects/components/Alpha');\r\nvar ComponentsBlendMode = require('../../../../src/gameobjects/components/BlendMode');\r\nvar ComponentsDepth = require('../../../../src/gameobjects/components/Depth');\r\nvar ComponentsFlip = require('../../../../src/gameobjects/components/Flip');\r\nvar ComponentsScrollFactor = require('../../../../src/gameobjects/components/ScrollFactor');\r\nvar ComponentsTransform = require('../../../../src/gameobjects/components/Transform');\r\nvar ComponentsVisible = require('../../../../src/gameobjects/components/Visible');\r\nvar GameObject = require('../../../../src/gameobjects/GameObject');\r\nvar SpineGameObjectRender = require('./SpineGameObjectRender');\r\n\r\n/**\r\n * @classdesc\r\n * TODO\r\n *\r\n * @class SpineGameObject\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Phaser Plugin Manager.\r\n */\r\nvar SpineGameObject = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        ComponentsAlpha,\r\n        ComponentsBlendMode,\r\n        ComponentsDepth,\r\n        ComponentsFlip,\r\n        ComponentsScrollFactor,\r\n        ComponentsTransform,\r\n        ComponentsVisible,\r\n        SpineGameObjectRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function SpineGameObject (scene, plugin, x, y, key, animationName, loop)\r\n    {\r\n        GameObject.call(this, scene, 'Spine');\r\n\r\n        this.plugin = plugin;\r\n\r\n        this.runtime = plugin.getRuntime();\r\n\r\n        this.skeleton = null;\r\n        this.skeletonData = null;\r\n\r\n        this.state = null;\r\n        this.stateData = null;\r\n\r\n        this.drawDebug = false;\r\n\r\n        this.timeScale = 1;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (key)\r\n        {\r\n            this.setSkeleton(key, animationName, loop);\r\n        }\r\n    },\r\n\r\n    setSkeletonFromJSON: function (atlasDataKey, skeletonJSON, animationName, loop)\r\n    {\r\n        return this.setSkeleton(atlasDataKey, skeletonJSON, animationName, loop);\r\n    },\r\n\r\n    setSkeleton: function (atlasDataKey, animationName, loop, skeletonJSON)\r\n    {\r\n        var data = this.plugin.createSkeleton(atlasDataKey, skeletonJSON);\r\n\r\n        this.skeletonData = data.skeletonData;\r\n\r\n        var skeleton = data.skeleton;\r\n\r\n        skeleton.flipY = (this.scene.sys.game.config.renderType === 1);\r\n\r\n        skeleton.setToSetupPose();\r\n\r\n        skeleton.updateWorldTransform();\r\n\r\n        skeleton.setSkinByName('default');\r\n\r\n        this.skeleton = skeleton;\r\n\r\n        //  AnimationState\r\n        data = this.plugin.createAnimationState(skeleton);\r\n\r\n        if (this.state)\r\n        {\r\n            this.state.clearListeners();\r\n            this.state.clearListenerNotifications();\r\n        }\r\n\r\n        this.state = data.state;\r\n\r\n        this.stateData = data.stateData;\r\n\r\n        var _this = this;\r\n\r\n        this.state.addListener({\r\n            event: function (trackIndex, event)\r\n            {\r\n                //  Event on a Track\r\n                _this.emit('spine.event', _this, trackIndex, event);\r\n            },\r\n            complete: function (trackIndex, loopCount)\r\n            {\r\n                //  Animation on Track x completed, loop count\r\n                _this.emit('spine.complete', _this, trackIndex, loopCount);\r\n            },\r\n            start: function (trackIndex)\r\n            {\r\n                //  Animation on Track x started\r\n                _this.emit('spine.start', _this, trackIndex);\r\n            },\r\n            end: function (trackIndex)\r\n            {\r\n                //  Animation on Track x ended\r\n                _this.emit('spine.end', _this, trackIndex);\r\n            }\r\n        });\r\n\r\n        if (animationName)\r\n        {\r\n            this.setAnimation(0, animationName, loop);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    // http://esotericsoftware.com/spine-runtimes-guide\r\n\r\n    getAnimationList: function ()\r\n    {\r\n        var output = [];\r\n\r\n        var skeletonData = this.skeletonData;\r\n\r\n        if (skeletonData)\r\n        {\r\n            for (var i = 0; i < skeletonData.animations.length; i++)\r\n            {\r\n                output.push(skeletonData.animations[i].name);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    play: function (animationName, loop)\r\n    {\r\n        if (loop === undefined)\r\n        {\r\n            loop = false;\r\n        }\r\n\r\n        return this.setAnimation(0, animationName, loop);\r\n    },\r\n\r\n    setAnimation: function (trackIndex, animationName, loop)\r\n    {\r\n        this.state.setAnimation(trackIndex, animationName, loop);\r\n\r\n        return this;\r\n    },\r\n\r\n    addAnimation: function (trackIndex, animationName, loop, delay)\r\n    {\r\n        return this.state.addAnimation(trackIndex, animationName, loop, delay);\r\n    },\r\n\r\n    setEmptyAnimation: function (trackIndex, mixDuration)\r\n    {\r\n        this.state.setEmptyAnimation(trackIndex, mixDuration);\r\n\r\n        return this;\r\n    },\r\n\r\n    clearTrack: function (trackIndex)\r\n    {\r\n        this.state.clearTrack(trackIndex);\r\n\r\n        return this;\r\n    },\r\n     \r\n    clearTracks: function ()\r\n    {\r\n        this.state.clearTracks();\r\n\r\n        return this;\r\n    },\r\n\r\n    setSkinByName: function (skinName)\r\n    {\r\n        this.skeleton.setSkinByName(skinName);\r\n\r\n        return this;\r\n    },\r\n\r\n    setSkin: function (newSkin)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        skeleton.setSkin(newSkin);\r\n\r\n        skeleton.setSlotsToSetupPose();\r\n\r\n        this.state.apply(skeleton);\r\n\r\n        return this;\r\n    },\r\n\r\n    setMix: function (fromName, toName, duration)\r\n    {\r\n        this.stateData.setMix(fromName, toName, duration);\r\n\r\n        return this;\r\n    },\r\n\r\n    findBone: function (boneName)\r\n    {\r\n        return this.skeleton.findBone(boneName);\r\n    },\r\n\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        return this.skeleton.findBoneIndex(boneName);\r\n    },\r\n\r\n    findSlot: function (slotName)\r\n    {\r\n        return this.skeleton.findSlot(slotName);\r\n    },\r\n\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        return this.skeleton.findSlotIndex(slotName);\r\n    },\r\n\r\n    getBounds: function ()\r\n    {\r\n        return this.plugin.getBounds(this.skeleton);\r\n    },\r\n\r\n    preUpdate: function (time, delta)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        skeleton.flipX = this.flipX;\r\n        skeleton.flipY = this.flipY;\r\n\r\n        this.state.update((delta / 1000) * this.timeScale);\r\n\r\n        this.state.apply(skeleton);\r\n\r\n        this.emit('spine.update', skeleton);\r\n\r\n        skeleton.updateWorldTransform();\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#preDestroy\r\n     * @protected\r\n     * @since 3.16.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (this.state)\r\n        {\r\n            this.state.clearListeners();\r\n            this.state.clearListenerNotifications();\r\n        }\r\n\r\n        this.plugin = null;\r\n        this.runtime = null;\r\n\r\n        this.skeleton = null;\r\n        this.skeletonData = null;\r\n\r\n        this.state = null;\r\n        this.stateData = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SpineGameObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../../src/utils/NOOP');\r\nvar renderCanvas = require('../../../../src/utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./SpineGameObjectWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./SpineGameObjectCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar CounterClockwise = require('../../../../src/math/angle/CounterClockwise');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.SpineGameObject#renderCanvas\r\n * @since 3.16.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.SpineGameObject} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpineGameObjectWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var pipeline = renderer.currentPipeline;\r\n    var plugin = src.plugin;\r\n    var mvp = plugin.mvp;\r\n\r\n    var shader = plugin.shader;\r\n    var batcher = plugin.batcher;\r\n    var runtime = src.runtime;\r\n    var skeleton = src.skeleton;\r\n    var skeletonRenderer = plugin.skeletonRenderer;\r\n\r\n    if (!skeleton)\r\n    {\r\n        return;\r\n    }\r\n\r\n    renderer.clearPipeline();\r\n\r\n    var camMatrix = renderer._tempMatrix1;\r\n    var spriteMatrix = renderer._tempMatrix2;\r\n    var calcMatrix = renderer._tempMatrix3;\r\n\r\n    //  - 90 degrees to account for the difference in Spine vs. Phaser rotation\r\n    spriteMatrix.applyITRS(src.x, src.y, src.rotation - 1.5707963267948966, src.scaleX, src.scaleY);\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        spriteMatrix.e = src.x;\r\n        spriteMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n    else\r\n    {\r\n        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n\r\n    var width = renderer.width;\r\n    var height = renderer.height;\r\n\r\n    var data = calcMatrix.decomposeMatrix();\r\n\r\n    mvp.ortho(0, width, 0, height, 0, 1);\r\n    mvp.translateXYZ(data.translateX, height - data.translateY, 0);\r\n    mvp.rotateZ(CounterClockwise(data.rotation));\r\n    mvp.scaleXYZ(data.scaleX, data.scaleY, 1);\r\n\r\n    //  For a Stage 1 release we'll handle it like this:\r\n    shader.bind();\r\n    shader.setUniformi(runtime.webgl.Shader.SAMPLER, 0);\r\n    shader.setUniform4x4f(runtime.webgl.Shader.MVP_MATRIX, mvp.val);\r\n\r\n    //  For Stage 2, we'll move to using a custom pipeline, so Spine objects are batched\r\n\r\n    batcher.begin(shader);\r\n\r\n    skeletonRenderer.premultipliedAlpha = true;\r\n\r\n    skeletonRenderer.draw(batcher, skeleton);\r\n\r\n    batcher.end();\r\n\r\n    shader.unbind();\r\n\r\n    if (plugin.drawDebug || src.drawDebug)\r\n    {\r\n        var debugShader = plugin.debugShader;\r\n        var debugRenderer = plugin.debugRenderer;\r\n        var shapes = plugin.shapes;\r\n\r\n        debugShader.bind();\r\n        debugShader.setUniform4x4f(runtime.webgl.Shader.MVP_MATRIX, mvp.val);\r\n\r\n        shapes.begin(debugShader);\r\n\r\n        debugRenderer.draw(shapes, skeleton);\r\n\r\n        shapes.end();\r\n\r\n        debugShader.unbind();\r\n    }\r\n\r\n    renderer.rebindPipeline(pipeline);\r\n};\r\n\r\nmodule.exports = SpineGameObjectWebGLRenderer;\r\n","/*** IMPORTS FROM imports-loader ***/\n(function() {\n\nvar __extends = (this && this.__extends) || (function () {\r\n\tvar extendStatics = Object.setPrototypeOf ||\r\n\t\t({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t\tfunction (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\treturn function (d, b) {\r\n\t\textendStatics(d, b);\r\n\t\tfunction __() { this.constructor = d; }\r\n\t\td.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n})();\r\nvar spine;\r\n(function (spine) {\r\n\tvar Animation = (function () {\r\n\t\tfunction Animation(name, timelines, duration) {\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tif (timelines == null)\r\n\t\t\t\tthrow new Error(\"timelines cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.timelines = timelines;\r\n\t\t\tthis.duration = duration;\r\n\t\t}\r\n\t\tAnimation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, pose, direction) {\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tif (loop && this.duration != 0) {\r\n\t\t\t\ttime %= this.duration;\r\n\t\t\t\tif (lastTime > 0)\r\n\t\t\t\t\tlastTime %= this.duration;\r\n\t\t\t}\r\n\t\t\tvar timelines = this.timelines;\r\n\t\t\tfor (var i = 0, n = timelines.length; i < n; i++)\r\n\t\t\t\ttimelines[i].apply(skeleton, lastTime, time, events, alpha, pose, direction);\r\n\t\t};\r\n\t\tAnimation.binarySearch = function (values, target, step) {\r\n\t\t\tif (step === void 0) { step = 1; }\r\n\t\t\tvar low = 0;\r\n\t\t\tvar high = values.length / step - 2;\r\n\t\t\tif (high == 0)\r\n\t\t\t\treturn step;\r\n\t\t\tvar current = high >>> 1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tif (values[(current + 1) * step] <= target)\r\n\t\t\t\t\tlow = current + 1;\r\n\t\t\t\telse\r\n\t\t\t\t\thigh = current;\r\n\t\t\t\tif (low == high)\r\n\t\t\t\t\treturn (low + 1) * step;\r\n\t\t\t\tcurrent = (low + high) >>> 1;\r\n\t\t\t}\r\n\t\t};\r\n\t\tAnimation.linearSearch = function (values, target, step) {\r\n\t\t\tfor (var i = 0, last = values.length - step; i <= last; i += step)\r\n\t\t\t\tif (values[i] > target)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\treturn Animation;\r\n\t}());\r\n\tspine.Animation = Animation;\r\n\tvar MixPose;\r\n\t(function (MixPose) {\r\n\t\tMixPose[MixPose[\"setup\"] = 0] = \"setup\";\r\n\t\tMixPose[MixPose[\"current\"] = 1] = \"current\";\r\n\t\tMixPose[MixPose[\"currentLayered\"] = 2] = \"currentLayered\";\r\n\t})(MixPose = spine.MixPose || (spine.MixPose = {}));\r\n\tvar MixDirection;\r\n\t(function (MixDirection) {\r\n\t\tMixDirection[MixDirection[\"in\"] = 0] = \"in\";\r\n\t\tMixDirection[MixDirection[\"out\"] = 1] = \"out\";\r\n\t})(MixDirection = spine.MixDirection || (spine.MixDirection = {}));\r\n\tvar TimelineType;\r\n\t(function (TimelineType) {\r\n\t\tTimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\r\n\t\tTimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\r\n\t\tTimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\r\n\t\tTimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\r\n\t\tTimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\r\n\t\tTimelineType[TimelineType[\"color\"] = 5] = \"color\";\r\n\t\tTimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\r\n\t\tTimelineType[TimelineType[\"event\"] = 7] = \"event\";\r\n\t\tTimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\r\n\t\tTimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\r\n\t\tTimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\r\n\t\tTimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\r\n\t\tTimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\r\n\t\tTimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\r\n\t\tTimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\r\n\t})(TimelineType = spine.TimelineType || (spine.TimelineType = {}));\r\n\tvar CurveTimeline = (function () {\r\n\t\tfunction CurveTimeline(frameCount) {\r\n\t\t\tif (frameCount <= 0)\r\n\t\t\t\tthrow new Error(\"frameCount must be > 0: \" + frameCount);\r\n\t\t\tthis.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n\t\t}\r\n\t\tCurveTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.setLinear = function (frameIndex) {\r\n\t\t\tthis.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.setStepped = function (frameIndex) {\r\n\t\t\tthis.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.getCurveType = function (frameIndex) {\r\n\t\t\tvar index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\t\tif (index == this.curves.length)\r\n\t\t\t\treturn CurveTimeline.LINEAR;\r\n\t\t\tvar type = this.curves[index];\r\n\t\t\tif (type == CurveTimeline.LINEAR)\r\n\t\t\t\treturn CurveTimeline.LINEAR;\r\n\t\t\tif (type == CurveTimeline.STEPPED)\r\n\t\t\t\treturn CurveTimeline.STEPPED;\r\n\t\t\treturn CurveTimeline.BEZIER;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\r\n\t\t\tvar tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n\t\t\tvar dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n\t\t\tvar ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\r\n\t\t\tvar dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n\t\t\tvar i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\t\tvar curves = this.curves;\r\n\t\t\tcurves[i++] = CurveTimeline.BEZIER;\r\n\t\t\tvar x = dfx, y = dfy;\r\n\t\t\tfor (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n\t\t\t\tcurves[i] = x;\r\n\t\t\t\tcurves[i + 1] = y;\r\n\t\t\t\tdfx += ddfx;\r\n\t\t\t\tdfy += ddfy;\r\n\t\t\t\tddfx += dddfx;\r\n\t\t\t\tddfy += dddfy;\r\n\t\t\t\tx += dfx;\r\n\t\t\t\ty += dfy;\r\n\t\t\t}\r\n\t\t};\r\n\t\tCurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\r\n\t\t\tpercent = spine.MathUtils.clamp(percent, 0, 1);\r\n\t\t\tvar curves = this.curves;\r\n\t\t\tvar i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\t\tvar type = curves[i];\r\n\t\t\tif (type == CurveTimeline.LINEAR)\r\n\t\t\t\treturn percent;\r\n\t\t\tif (type == CurveTimeline.STEPPED)\r\n\t\t\t\treturn 0;\r\n\t\t\ti++;\r\n\t\t\tvar x = 0;\r\n\t\t\tfor (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n\t\t\t\tx = curves[i];\r\n\t\t\t\tif (x >= percent) {\r\n\t\t\t\t\tvar prevX = void 0, prevY = void 0;\r\n\t\t\t\t\tif (i == start) {\r\n\t\t\t\t\t\tprevX = 0;\r\n\t\t\t\t\t\tprevY = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tprevX = curves[i - 2];\r\n\t\t\t\t\t\tprevY = curves[i - 1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar y = curves[i - 1];\r\n\t\t\treturn y + (1 - y) * (percent - x) / (1 - x);\r\n\t\t};\r\n\t\tCurveTimeline.LINEAR = 0;\r\n\t\tCurveTimeline.STEPPED = 1;\r\n\t\tCurveTimeline.BEZIER = 2;\r\n\t\tCurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\r\n\t\treturn CurveTimeline;\r\n\t}());\r\n\tspine.CurveTimeline = CurveTimeline;\r\n\tvar RotateTimeline = (function (_super) {\r\n\t\t__extends(RotateTimeline, _super);\r\n\t\tfunction RotateTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount << 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tRotateTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.rotate << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tRotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\r\n\t\t\tframeIndex <<= 1;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n\t\t};\r\n\t\tRotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tbone.rotation = bone.data.rotation;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tvar r_1 = bone.data.rotation - bone.rotation;\r\n\t\t\t\t\t\tr_1 -= (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360;\r\n\t\t\t\t\t\tbone.rotation += r_1 * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\r\n\t\t\t\tif (pose == MixPose.setup)\r\n\t\t\t\t\tbone.rotation = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha;\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar r_2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;\r\n\t\t\t\t\tr_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;\r\n\t\t\t\t\tbone.rotation += r_2 * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n\t\t\tvar prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n\t\t\tvar frameTime = frames[frame];\r\n\t\t\tvar percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\t\t\tvar r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\tr = prevRotation + r * percent;\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\tbone.rotation = bone.data.rotation + r * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tr = bone.data.rotation + r - bone.rotation;\r\n\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\tbone.rotation += r * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tRotateTimeline.ENTRIES = 2;\r\n\t\tRotateTimeline.PREV_TIME = -2;\r\n\t\tRotateTimeline.PREV_ROTATION = -1;\r\n\t\tRotateTimeline.ROTATION = 1;\r\n\t\treturn RotateTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.RotateTimeline = RotateTimeline;\r\n\tvar TranslateTimeline = (function (_super) {\r\n\t\t__extends(TranslateTimeline, _super);\r\n\t\tfunction TranslateTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tTranslateTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.translate << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tTranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\r\n\t\t\tframeIndex *= TranslateTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + TranslateTimeline.X] = x;\r\n\t\t\tthis.frames[frameIndex + TranslateTimeline.Y] = y;\r\n\t\t};\r\n\t\tTranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tbone.x = bone.data.x;\r\n\t\t\t\t\t\tbone.y = bone.data.y;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tbone.x += (bone.data.x - bone.x) * alpha;\r\n\t\t\t\t\t\tbone.y += (bone.data.y - bone.y) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar x = 0, y = 0;\r\n\t\t\tif (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\r\n\t\t\t\tx = frames[frames.length + TranslateTimeline.PREV_X];\r\n\t\t\t\ty = frames[frames.length + TranslateTimeline.PREV_Y];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n\t\t\t\tx = frames[frame + TranslateTimeline.PREV_X];\r\n\t\t\t\ty = frames[frame + TranslateTimeline.PREV_Y];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tx += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n\t\t\t\ty += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tbone.x = bone.data.x + x * alpha;\r\n\t\t\t\tbone.y = bone.data.y + y * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbone.x += (bone.data.x + x - bone.x) * alpha;\r\n\t\t\t\tbone.y += (bone.data.y + y - bone.y) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTranslateTimeline.ENTRIES = 3;\r\n\t\tTranslateTimeline.PREV_TIME = -3;\r\n\t\tTranslateTimeline.PREV_X = -2;\r\n\t\tTranslateTimeline.PREV_Y = -1;\r\n\t\tTranslateTimeline.X = 1;\r\n\t\tTranslateTimeline.Y = 2;\r\n\t\treturn TranslateTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.TranslateTimeline = TranslateTimeline;\r\n\tvar ScaleTimeline = (function (_super) {\r\n\t\t__extends(ScaleTimeline, _super);\r\n\t\tfunction ScaleTimeline(frameCount) {\r\n\t\t\treturn _super.call(this, frameCount) || this;\r\n\t\t}\r\n\t\tScaleTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.scale << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tbone.scaleX = bone.data.scaleX;\r\n\t\t\t\t\t\tbone.scaleY = bone.data.scaleY;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tbone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n\t\t\t\t\t\tbone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar x = 0, y = 0;\r\n\t\t\tif (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\r\n\t\t\t\tx = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n\t\t\t\ty = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n\t\t\t\tx = frames[frame + ScaleTimeline.PREV_X];\r\n\t\t\t\ty = frames[frame + ScaleTimeline.PREV_Y];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tx = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n\t\t\t\ty = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n\t\t\t}\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\tbone.scaleX = x;\r\n\t\t\t\tbone.scaleY = y;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar bx = 0, by = 0;\r\n\t\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\t\tbx = bone.data.scaleX;\r\n\t\t\t\t\tby = bone.data.scaleY;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbx = bone.scaleX;\r\n\t\t\t\t\tby = bone.scaleY;\r\n\t\t\t\t}\r\n\t\t\t\tif (direction == MixDirection.out) {\r\n\t\t\t\t\tx = Math.abs(x) * spine.MathUtils.signum(bx);\r\n\t\t\t\t\ty = Math.abs(y) * spine.MathUtils.signum(by);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbx = Math.abs(bx) * spine.MathUtils.signum(x);\r\n\t\t\t\t\tby = Math.abs(by) * spine.MathUtils.signum(y);\r\n\t\t\t\t}\r\n\t\t\t\tbone.scaleX = bx + (x - bx) * alpha;\r\n\t\t\t\tbone.scaleY = by + (y - by) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn ScaleTimeline;\r\n\t}(TranslateTimeline));\r\n\tspine.ScaleTimeline = ScaleTimeline;\r\n\tvar ShearTimeline = (function (_super) {\r\n\t\t__extends(ShearTimeline, _super);\r\n\t\tfunction ShearTimeline(frameCount) {\r\n\t\t\treturn _super.call(this, frameCount) || this;\r\n\t\t}\r\n\t\tShearTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.shear << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tbone.shearX = bone.data.shearX;\r\n\t\t\t\t\t\tbone.shearY = bone.data.shearY;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tbone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n\t\t\t\t\t\tbone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar x = 0, y = 0;\r\n\t\t\tif (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\r\n\t\t\t\tx = frames[frames.length + ShearTimeline.PREV_X];\r\n\t\t\t\ty = frames[frames.length + ShearTimeline.PREV_Y];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n\t\t\t\tx = frames[frame + ShearTimeline.PREV_X];\r\n\t\t\t\ty = frames[frame + ShearTimeline.PREV_Y];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tx = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n\t\t\t\ty = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tbone.shearX = bone.data.shearX + x * alpha;\r\n\t\t\t\tbone.shearY = bone.data.shearY + y * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n\t\t\t\tbone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn ShearTimeline;\r\n\t}(TranslateTimeline));\r\n\tspine.ShearTimeline = ShearTimeline;\r\n\tvar ColorTimeline = (function (_super) {\r\n\t\t__extends(ColorTimeline, _super);\r\n\t\tfunction ColorTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tColorTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.color << 24) + this.slotIndex;\r\n\t\t};\r\n\t\tColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\r\n\t\t\tframeIndex *= ColorTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.R] = r;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.G] = g;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.B] = b;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.A] = a;\r\n\t\t};\r\n\t\tColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tslot.color.setFromColor(slot.data.color);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tvar color = slot.color, setup = slot.data.color;\r\n\t\t\t\t\t\tcolor.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar r = 0, g = 0, b = 0, a = 0;\r\n\t\t\tif (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\r\n\t\t\t\tvar i = frames.length;\r\n\t\t\t\tr = frames[i + ColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[i + ColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[i + ColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[i + ColorTimeline.PREV_A];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n\t\t\t\tr = frames[frame + ColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[frame + ColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[frame + ColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[frame + ColorTimeline.PREV_A];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tr += (frames[frame + ColorTimeline.R] - r) * percent;\r\n\t\t\t\tg += (frames[frame + ColorTimeline.G] - g) * percent;\r\n\t\t\t\tb += (frames[frame + ColorTimeline.B] - b) * percent;\r\n\t\t\t\ta += (frames[frame + ColorTimeline.A] - a) * percent;\r\n\t\t\t}\r\n\t\t\tif (alpha == 1)\r\n\t\t\t\tslot.color.set(r, g, b, a);\r\n\t\t\telse {\r\n\t\t\t\tvar color = slot.color;\r\n\t\t\t\tif (pose == MixPose.setup)\r\n\t\t\t\t\tcolor.setFromColor(slot.data.color);\r\n\t\t\t\tcolor.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n\t\t\t}\r\n\t\t};\r\n\t\tColorTimeline.ENTRIES = 5;\r\n\t\tColorTimeline.PREV_TIME = -5;\r\n\t\tColorTimeline.PREV_R = -4;\r\n\t\tColorTimeline.PREV_G = -3;\r\n\t\tColorTimeline.PREV_B = -2;\r\n\t\tColorTimeline.PREV_A = -1;\r\n\t\tColorTimeline.R = 1;\r\n\t\tColorTimeline.G = 2;\r\n\t\tColorTimeline.B = 3;\r\n\t\tColorTimeline.A = 4;\r\n\t\treturn ColorTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.ColorTimeline = ColorTimeline;\r\n\tvar TwoColorTimeline = (function (_super) {\r\n\t\t__extends(TwoColorTimeline, _super);\r\n\t\tfunction TwoColorTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tTwoColorTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.twoColor << 24) + this.slotIndex;\r\n\t\t};\r\n\t\tTwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\r\n\t\t\tframeIndex *= TwoColorTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.R] = r;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.G] = g;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.B] = b;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.A] = a;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n\t\t};\r\n\t\tTwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tslot.color.setFromColor(slot.data.color);\r\n\t\t\t\t\t\tslot.darkColor.setFromColor(slot.data.darkColor);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tvar light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n\t\t\t\t\t\tlight.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\r\n\t\t\t\t\t\tdark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n\t\t\tif (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\r\n\t\t\t\tvar i = frames.length;\r\n\t\t\t\tr = frames[i + TwoColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[i + TwoColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[i + TwoColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[i + TwoColorTimeline.PREV_A];\r\n\t\t\t\tr2 = frames[i + TwoColorTimeline.PREV_R2];\r\n\t\t\t\tg2 = frames[i + TwoColorTimeline.PREV_G2];\r\n\t\t\t\tb2 = frames[i + TwoColorTimeline.PREV_B2];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n\t\t\t\tr = frames[frame + TwoColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[frame + TwoColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[frame + TwoColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[frame + TwoColorTimeline.PREV_A];\r\n\t\t\t\tr2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n\t\t\t\tg2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n\t\t\t\tb2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tr += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n\t\t\t\tg += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n\t\t\t\tb += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n\t\t\t\ta += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n\t\t\t\tr2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n\t\t\t\tg2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n\t\t\t\tb2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n\t\t\t}\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\tslot.color.set(r, g, b, a);\r\n\t\t\t\tslot.darkColor.set(r2, g2, b2, 1);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar light = slot.color, dark = slot.darkColor;\r\n\t\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\t\tlight.setFromColor(slot.data.color);\r\n\t\t\t\t\tdark.setFromColor(slot.data.darkColor);\r\n\t\t\t\t}\r\n\t\t\t\tlight.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n\t\t\t\tdark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTwoColorTimeline.ENTRIES = 8;\r\n\t\tTwoColorTimeline.PREV_TIME = -8;\r\n\t\tTwoColorTimeline.PREV_R = -7;\r\n\t\tTwoColorTimeline.PREV_G = -6;\r\n\t\tTwoColorTimeline.PREV_B = -5;\r\n\t\tTwoColorTimeline.PREV_A = -4;\r\n\t\tTwoColorTimeline.PREV_R2 = -3;\r\n\t\tTwoColorTimeline.PREV_G2 = -2;\r\n\t\tTwoColorTimeline.PREV_B2 = -1;\r\n\t\tTwoColorTimeline.R = 1;\r\n\t\tTwoColorTimeline.G = 2;\r\n\t\tTwoColorTimeline.B = 3;\r\n\t\tTwoColorTimeline.A = 4;\r\n\t\tTwoColorTimeline.R2 = 5;\r\n\t\tTwoColorTimeline.G2 = 6;\r\n\t\tTwoColorTimeline.B2 = 7;\r\n\t\treturn TwoColorTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.TwoColorTimeline = TwoColorTimeline;\r\n\tvar AttachmentTimeline = (function () {\r\n\t\tfunction AttachmentTimeline(frameCount) {\r\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\tthis.attachmentNames = new Array(frameCount);\r\n\t\t}\r\n\t\tAttachmentTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.attachment << 24) + this.slotIndex;\r\n\t\t};\r\n\t\tAttachmentTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.frames.length;\r\n\t\t};\r\n\t\tAttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.attachmentNames[frameIndex] = attachmentName;\r\n\t\t};\r\n\t\tAttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tif (direction == MixDirection.out && pose == MixPose.setup) {\r\n\t\t\t\tvar attachmentName_1 = slot.data.attachmentName;\r\n\t\t\t\tslot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\t\tvar attachmentName_2 = slot.data.attachmentName;\r\n\t\t\t\t\tslot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frameIndex = 0;\r\n\t\t\tif (time >= frames[frames.length - 1])\r\n\t\t\t\tframeIndex = frames.length - 1;\r\n\t\t\telse\r\n\t\t\t\tframeIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n\t\t\tvar attachmentName = this.attachmentNames[frameIndex];\r\n\t\t\tskeleton.slots[this.slotIndex]\r\n\t\t\t\t.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n\t\t};\r\n\t\treturn AttachmentTimeline;\r\n\t}());\r\n\tspine.AttachmentTimeline = AttachmentTimeline;\r\n\tvar zeros = null;\r\n\tvar DeformTimeline = (function (_super) {\r\n\t\t__extends(DeformTimeline, _super);\r\n\t\tfunction DeformTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\t_this.frameVertices = new Array(frameCount);\r\n\t\t\tif (zeros == null)\r\n\t\t\t\tzeros = spine.Utils.newFloatArray(64);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tDeformTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\r\n\t\t};\r\n\t\tDeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frameVertices[frameIndex] = vertices;\r\n\t\t};\r\n\t\tDeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tvar slotAttachment = slot.getAttachment();\r\n\t\t\tif (!(slotAttachment instanceof spine.VertexAttachment) || !slotAttachment.applyDeform(this.attachment))\r\n\t\t\t\treturn;\r\n\t\t\tvar verticesArray = slot.attachmentVertices;\r\n\t\t\tif (verticesArray.length == 0)\r\n\t\t\t\talpha = 1;\r\n\t\t\tvar frameVertices = this.frameVertices;\r\n\t\t\tvar vertexCount = frameVertices[0].length;\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tverticesArray.length = 0;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tif (alpha == 1) {\r\n\t\t\t\t\t\t\tverticesArray.length = 0;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar vertices_1 = spine.Utils.setArraySize(verticesArray, vertexCount);\r\n\t\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\t\t\tvertices_1[i] += (setupVertices[i] - vertices_1[i]) * alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\talpha = 1 - alpha;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\t\t\tvertices_1[i] *= alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar vertices = spine.Utils.setArraySize(verticesArray, vertexCount);\r\n\t\t\tif (time >= frames[frames.length - 1]) {\r\n\t\t\t\tvar lastVertices = frameVertices[frames.length - 1];\r\n\t\t\t\tif (alpha == 1) {\r\n\t\t\t\t\tspine.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\r\n\t\t\t\t}\r\n\t\t\t\telse if (pose == MixPose.setup) {\r\n\t\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\tvar setupVertices_1 = vertexAttachment.vertices;\r\n\t\t\t\t\t\tfor (var i_1 = 0; i_1 < vertexCount; i_1++) {\r\n\t\t\t\t\t\t\tvar setup = setupVertices_1[i_1];\r\n\t\t\t\t\t\t\tvertices[i_1] = setup + (lastVertices[i_1] - setup) * alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tfor (var i_2 = 0; i_2 < vertexCount; i_2++)\r\n\t\t\t\t\t\t\tvertices[i_2] = lastVertices[i_2] * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (var i_3 = 0; i_3 < vertexCount; i_3++)\r\n\t\t\t\t\t\tvertices[i_3] += (lastVertices[i_3] - vertices[i_3]) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = Animation.binarySearch(frames, time);\r\n\t\t\tvar prevVertices = frameVertices[frame - 1];\r\n\t\t\tvar nextVertices = frameVertices[frame];\r\n\t\t\tvar frameTime = frames[frame];\r\n\t\t\tvar percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\tfor (var i_4 = 0; i_4 < vertexCount; i_4++) {\r\n\t\t\t\t\tvar prev = prevVertices[i_4];\r\n\t\t\t\t\tvertices[i_4] = prev + (nextVertices[i_4] - prev) * percent;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (pose == MixPose.setup) {\r\n\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\tvar setupVertices_2 = vertexAttachment.vertices;\r\n\t\t\t\t\tfor (var i_5 = 0; i_5 < vertexCount; i_5++) {\r\n\t\t\t\t\t\tvar prev = prevVertices[i_5], setup = setupVertices_2[i_5];\r\n\t\t\t\t\t\tvertices[i_5] = setup + (prev + (nextVertices[i_5] - prev) * percent - setup) * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (var i_6 = 0; i_6 < vertexCount; i_6++) {\r\n\t\t\t\t\t\tvar prev = prevVertices[i_6];\r\n\t\t\t\t\t\tvertices[i_6] = (prev + (nextVertices[i_6] - prev) * percent) * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (var i_7 = 0; i_7 < vertexCount; i_7++) {\r\n\t\t\t\t\tvar prev = prevVertices[i_7];\r\n\t\t\t\t\tvertices[i_7] += (prev + (nextVertices[i_7] - prev) * percent - vertices[i_7]) * alpha;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn DeformTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.DeformTimeline = DeformTimeline;\r\n\tvar EventTimeline = (function () {\r\n\t\tfunction EventTimeline(frameCount) {\r\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\tthis.events = new Array(frameCount);\r\n\t\t}\r\n\t\tEventTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn TimelineType.event << 24;\r\n\t\t};\r\n\t\tEventTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.frames.length;\r\n\t\t};\r\n\t\tEventTimeline.prototype.setFrame = function (frameIndex, event) {\r\n\t\t\tthis.frames[frameIndex] = event.time;\r\n\t\t\tthis.events[frameIndex] = event;\r\n\t\t};\r\n\t\tEventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tif (firedEvents == null)\r\n\t\t\t\treturn;\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar frameCount = this.frames.length;\r\n\t\t\tif (lastTime > time) {\r\n\t\t\t\tthis.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, pose, direction);\r\n\t\t\t\tlastTime = -1;\r\n\t\t\t}\r\n\t\t\telse if (lastTime >= frames[frameCount - 1])\r\n\t\t\t\treturn;\r\n\t\t\tif (time < frames[0])\r\n\t\t\t\treturn;\r\n\t\t\tvar frame = 0;\r\n\t\t\tif (lastTime < frames[0])\r\n\t\t\t\tframe = 0;\r\n\t\t\telse {\r\n\t\t\t\tframe = Animation.binarySearch(frames, lastTime);\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\twhile (frame > 0) {\r\n\t\t\t\t\tif (frames[frame - 1] != frameTime)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tframe--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (; frame < frameCount && time >= frames[frame]; frame++)\r\n\t\t\t\tfiredEvents.push(this.events[frame]);\r\n\t\t};\r\n\t\treturn EventTimeline;\r\n\t}());\r\n\tspine.EventTimeline = EventTimeline;\r\n\tvar DrawOrderTimeline = (function () {\r\n\t\tfunction DrawOrderTimeline(frameCount) {\r\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\tthis.drawOrders = new Array(frameCount);\r\n\t\t}\r\n\t\tDrawOrderTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn TimelineType.drawOrder << 24;\r\n\t\t};\r\n\t\tDrawOrderTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.frames.length;\r\n\t\t};\r\n\t\tDrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.drawOrders[frameIndex] = drawOrder;\r\n\t\t};\r\n\t\tDrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar drawOrder = skeleton.drawOrder;\r\n\t\t\tvar slots = skeleton.slots;\r\n\t\t\tif (direction == MixDirection.out && pose == MixPose.setup) {\r\n\t\t\t\tspine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tif (pose == MixPose.setup)\r\n\t\t\t\t\tspine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = 0;\r\n\t\t\tif (time >= frames[frames.length - 1])\r\n\t\t\t\tframe = frames.length - 1;\r\n\t\t\telse\r\n\t\t\t\tframe = Animation.binarySearch(frames, time) - 1;\r\n\t\t\tvar drawOrderToSetupIndex = this.drawOrders[frame];\r\n\t\t\tif (drawOrderToSetupIndex == null)\r\n\t\t\t\tspine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n\t\t\t\t\tdrawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn DrawOrderTimeline;\r\n\t}());\r\n\tspine.DrawOrderTimeline = DrawOrderTimeline;\r\n\tvar IkConstraintTimeline = (function (_super) {\r\n\t\t__extends(IkConstraintTimeline, _super);\r\n\t\tfunction IkConstraintTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tIkConstraintTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n\t\t};\r\n\t\tIkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, bendDirection) {\r\n\t\t\tframeIndex *= IkConstraintTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n\t\t};\r\n\t\tIkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tconstraint.mix = constraint.data.mix;\r\n\t\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tconstraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n\t\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\r\n\t\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\t\tconstraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n\t\t\t\t\tconstraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection\r\n\t\t\t\t\t\t: frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconstraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n\t\t\t\t\tif (direction == MixDirection[\"in\"])\r\n\t\t\t\t\t\tconstraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n\t\t\tvar mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n\t\t\tvar frameTime = frames[frame];\r\n\t\t\tvar percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tconstraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\r\n\t\t\t\tconstraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconstraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n\t\t\t\tif (direction == MixDirection[\"in\"])\r\n\t\t\t\t\tconstraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t}\r\n\t\t};\r\n\t\tIkConstraintTimeline.ENTRIES = 3;\r\n\t\tIkConstraintTimeline.PREV_TIME = -3;\r\n\t\tIkConstraintTimeline.PREV_MIX = -2;\r\n\t\tIkConstraintTimeline.PREV_BEND_DIRECTION = -1;\r\n\t\tIkConstraintTimeline.MIX = 1;\r\n\t\tIkConstraintTimeline.BEND_DIRECTION = 2;\r\n\t\treturn IkConstraintTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.IkConstraintTimeline = IkConstraintTimeline;\r\n\tvar TransformConstraintTimeline = (function (_super) {\r\n\t\t__extends(TransformConstraintTimeline, _super);\r\n\t\tfunction TransformConstraintTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tTransformConstraintTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n\t\t};\r\n\t\tTransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\r\n\t\t\tframeIndex *= TransformConstraintTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n\t\t};\r\n\t\tTransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\t\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\t\t\t\tconstraint.scaleMix = data.scaleMix;\r\n\t\t\t\t\t\tconstraint.shearMix = data.shearMix;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tconstraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n\t\t\t\t\t\tconstraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n\t\t\t\t\t\tconstraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n\t\t\t\t\t\tconstraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar rotate = 0, translate = 0, scale = 0, shear = 0;\r\n\t\t\tif (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\r\n\t\t\t\tvar i = frames.length;\r\n\t\t\t\trotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n\t\t\t\tscale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n\t\t\t\tshear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n\t\t\t\trotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n\t\t\t\tscale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n\t\t\t\tshear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\trotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n\t\t\t\ttranslate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n\t\t\t\tscale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n\t\t\t\tshear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tconstraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n\t\t\t\tconstraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n\t\t\t\tconstraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconstraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n\t\t\t\tconstraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n\t\t\t\tconstraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraintTimeline.ENTRIES = 5;\r\n\t\tTransformConstraintTimeline.PREV_TIME = -5;\r\n\t\tTransformConstraintTimeline.PREV_ROTATE = -4;\r\n\t\tTransformConstraintTimeline.PREV_TRANSLATE = -3;\r\n\t\tTransformConstraintTimeline.PREV_SCALE = -2;\r\n\t\tTransformConstraintTimeline.PREV_SHEAR = -1;\r\n\t\tTransformConstraintTimeline.ROTATE = 1;\r\n\t\tTransformConstraintTimeline.TRANSLATE = 2;\r\n\t\tTransformConstraintTimeline.SCALE = 3;\r\n\t\tTransformConstraintTimeline.SHEAR = 4;\r\n\t\treturn TransformConstraintTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.TransformConstraintTimeline = TransformConstraintTimeline;\r\n\tvar PathConstraintPositionTimeline = (function (_super) {\r\n\t\t__extends(PathConstraintPositionTimeline, _super);\r\n\t\tfunction PathConstraintPositionTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPathConstraintPositionTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n\t\t};\r\n\t\tPathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\r\n\t\t\tframeIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n\t\t};\r\n\t\tPathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tconstraint.position = constraint.data.position;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tconstraint.position += (constraint.data.position - constraint.position) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar position = 0;\r\n\t\t\tif (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\r\n\t\t\t\tposition = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n\t\t\t\tposition = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tposition += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup)\r\n\t\t\t\tconstraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n\t\t\telse\r\n\t\t\t\tconstraint.position += (position - constraint.position) * alpha;\r\n\t\t};\r\n\t\tPathConstraintPositionTimeline.ENTRIES = 2;\r\n\t\tPathConstraintPositionTimeline.PREV_TIME = -2;\r\n\t\tPathConstraintPositionTimeline.PREV_VALUE = -1;\r\n\t\tPathConstraintPositionTimeline.VALUE = 1;\r\n\t\treturn PathConstraintPositionTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\r\n\tvar PathConstraintSpacingTimeline = (function (_super) {\r\n\t\t__extends(PathConstraintSpacingTimeline, _super);\r\n\t\tfunction PathConstraintSpacingTimeline(frameCount) {\r\n\t\t\treturn _super.call(this, frameCount) || this;\r\n\t\t}\r\n\t\tPathConstraintSpacingTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n\t\t};\r\n\t\tPathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tconstraint.spacing = constraint.data.spacing;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tconstraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar spacing = 0;\r\n\t\t\tif (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\r\n\t\t\t\tspacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n\t\t\t\tspacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tspacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup)\r\n\t\t\t\tconstraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n\t\t\telse\r\n\t\t\t\tconstraint.spacing += (spacing - constraint.spacing) * alpha;\r\n\t\t};\r\n\t\treturn PathConstraintSpacingTimeline;\r\n\t}(PathConstraintPositionTimeline));\r\n\tspine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\r\n\tvar PathConstraintMixTimeline = (function (_super) {\r\n\t\t__extends(PathConstraintMixTimeline, _super);\r\n\t\tfunction PathConstraintMixTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPathConstraintMixTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n\t\t};\r\n\t\tPathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\r\n\t\t\tframeIndex *= PathConstraintMixTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n\t\t\tthis.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n\t\t};\r\n\t\tPathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tconstraint.rotateMix = constraint.data.rotateMix;\r\n\t\t\t\t\t\tconstraint.translateMix = constraint.data.translateMix;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tconstraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n\t\t\t\t\t\tconstraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar rotate = 0, translate = 0;\r\n\t\t\tif (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\r\n\t\t\t\trotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n\t\t\t\trotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\trotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n\t\t\t\ttranslate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tconstraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconstraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tPathConstraintMixTimeline.ENTRIES = 3;\r\n\t\tPathConstraintMixTimeline.PREV_TIME = -3;\r\n\t\tPathConstraintMixTimeline.PREV_ROTATE = -2;\r\n\t\tPathConstraintMixTimeline.PREV_TRANSLATE = -1;\r\n\t\tPathConstraintMixTimeline.ROTATE = 1;\r\n\t\tPathConstraintMixTimeline.TRANSLATE = 2;\r\n\t\treturn PathConstraintMixTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.PathConstraintMixTimeline = PathConstraintMixTimeline;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AnimationState = (function () {\r\n\t\tfunction AnimationState(data) {\r\n\t\t\tthis.tracks = new Array();\r\n\t\t\tthis.events = new Array();\r\n\t\t\tthis.listeners = new Array();\r\n\t\t\tthis.queue = new EventQueue(this);\r\n\t\t\tthis.propertyIDs = new spine.IntSet();\r\n\t\t\tthis.mixingTo = new Array();\r\n\t\t\tthis.animationsChanged = false;\r\n\t\t\tthis.timeScale = 1;\r\n\t\t\tthis.trackEntryPool = new spine.Pool(function () { return new TrackEntry(); });\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\tAnimationState.prototype.update = function (delta) {\r\n\t\t\tdelta *= this.timeScale;\r\n\t\t\tvar tracks = this.tracks;\r\n\t\t\tfor (var i = 0, n = tracks.length; i < n; i++) {\r\n\t\t\t\tvar current = tracks[i];\r\n\t\t\t\tif (current == null)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tcurrent.animationLast = current.nextAnimationLast;\r\n\t\t\t\tcurrent.trackLast = current.nextTrackLast;\r\n\t\t\t\tvar currentDelta = delta * current.timeScale;\r\n\t\t\t\tif (current.delay > 0) {\r\n\t\t\t\t\tcurrent.delay -= currentDelta;\r\n\t\t\t\t\tif (current.delay > 0)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tcurrentDelta = -current.delay;\r\n\t\t\t\t\tcurrent.delay = 0;\r\n\t\t\t\t}\r\n\t\t\t\tvar next = current.next;\r\n\t\t\t\tif (next != null) {\r\n\t\t\t\t\tvar nextTime = current.trackLast - next.delay;\r\n\t\t\t\t\tif (nextTime >= 0) {\r\n\t\t\t\t\t\tnext.delay = 0;\r\n\t\t\t\t\t\tnext.trackTime = nextTime + delta * next.timeScale;\r\n\t\t\t\t\t\tcurrent.trackTime += currentDelta;\r\n\t\t\t\t\t\tthis.setCurrent(i, next, true);\r\n\t\t\t\t\t\twhile (next.mixingFrom != null) {\r\n\t\t\t\t\t\t\tnext.mixTime += currentDelta;\r\n\t\t\t\t\t\t\tnext = next.mixingFrom;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\r\n\t\t\t\t\ttracks[i] = null;\r\n\t\t\t\t\tthis.queue.end(current);\r\n\t\t\t\t\tthis.disposeNext(current);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\r\n\t\t\t\t\tvar from = current.mixingFrom;\r\n\t\t\t\t\tcurrent.mixingFrom = null;\r\n\t\t\t\t\twhile (from != null) {\r\n\t\t\t\t\t\tthis.queue.end(from);\r\n\t\t\t\t\t\tfrom = from.mixingFrom;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcurrent.trackTime += currentDelta;\r\n\t\t\t}\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.updateMixingFrom = function (to, delta) {\r\n\t\t\tvar from = to.mixingFrom;\r\n\t\t\tif (from == null)\r\n\t\t\t\treturn true;\r\n\t\t\tvar finished = this.updateMixingFrom(from, delta);\r\n\t\t\tfrom.animationLast = from.nextAnimationLast;\r\n\t\t\tfrom.trackLast = from.nextTrackLast;\r\n\t\t\tif (to.mixTime > 0 && (to.mixTime >= to.mixDuration || to.timeScale == 0)) {\r\n\t\t\t\tif (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n\t\t\t\t\tto.mixingFrom = from.mixingFrom;\r\n\t\t\t\t\tto.interruptAlpha = from.interruptAlpha;\r\n\t\t\t\t\tthis.queue.end(from);\r\n\t\t\t\t}\r\n\t\t\t\treturn finished;\r\n\t\t\t}\r\n\t\t\tfrom.trackTime += delta * from.timeScale;\r\n\t\t\tto.mixTime += delta * to.timeScale;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tAnimationState.prototype.apply = function (skeleton) {\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tif (this.animationsChanged)\r\n\t\t\t\tthis._animationsChanged();\r\n\t\t\tvar events = this.events;\r\n\t\t\tvar tracks = this.tracks;\r\n\t\t\tvar applied = false;\r\n\t\t\tfor (var i = 0, n = tracks.length; i < n; i++) {\r\n\t\t\t\tvar current = tracks[i];\r\n\t\t\t\tif (current == null || current.delay > 0)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tapplied = true;\r\n\t\t\t\tvar currentPose = i == 0 ? spine.MixPose.current : spine.MixPose.currentLayered;\r\n\t\t\t\tvar mix = current.alpha;\r\n\t\t\t\tif (current.mixingFrom != null)\r\n\t\t\t\t\tmix *= this.applyMixingFrom(current, skeleton, currentPose);\r\n\t\t\t\telse if (current.trackTime >= current.trackEnd && current.next == null)\r\n\t\t\t\t\tmix = 0;\r\n\t\t\t\tvar animationLast = current.animationLast, animationTime = current.getAnimationTime();\r\n\t\t\t\tvar timelineCount = current.animation.timelines.length;\r\n\t\t\t\tvar timelines = current.animation.timelines;\r\n\t\t\t\tif (mix == 1) {\r\n\t\t\t\t\tfor (var ii = 0; ii < timelineCount; ii++)\r\n\t\t\t\t\t\ttimelines[ii].apply(skeleton, animationLast, animationTime, events, 1, spine.MixPose.setup, spine.MixDirection[\"in\"]);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar timelineData = current.timelineData;\r\n\t\t\t\t\tvar firstFrame = current.timelinesRotation.length == 0;\r\n\t\t\t\t\tif (firstFrame)\r\n\t\t\t\t\t\tspine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\r\n\t\t\t\t\tvar timelinesRotation = current.timelinesRotation;\r\n\t\t\t\t\tfor (var ii = 0; ii < timelineCount; ii++) {\r\n\t\t\t\t\t\tvar timeline = timelines[ii];\r\n\t\t\t\t\t\tvar pose = timelineData[ii] >= AnimationState.FIRST ? spine.MixPose.setup : currentPose;\r\n\t\t\t\t\t\tif (timeline instanceof spine.RotateTimeline) {\r\n\t\t\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, animationTime, mix, pose, timelinesRotation, ii << 1, firstFrame);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tspine.Utils.webkit602BugfixHelper(mix, pose);\r\n\t\t\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, mix, pose, spine.MixDirection[\"in\"]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.queueEvents(current, animationTime);\r\n\t\t\t\tevents.length = 0;\r\n\t\t\t\tcurrent.nextAnimationLast = animationTime;\r\n\t\t\t\tcurrent.nextTrackLast = current.trackTime;\r\n\t\t\t}\r\n\t\t\tthis.queue.drain();\r\n\t\t\treturn applied;\r\n\t\t};\r\n\t\tAnimationState.prototype.applyMixingFrom = function (to, skeleton, currentPose) {\r\n\t\t\tvar from = to.mixingFrom;\r\n\t\t\tif (from.mixingFrom != null)\r\n\t\t\t\tthis.applyMixingFrom(from, skeleton, currentPose);\r\n\t\t\tvar mix = 0;\r\n\t\t\tif (to.mixDuration == 0) {\r\n\t\t\t\tmix = 1;\r\n\t\t\t\tcurrentPose = spine.MixPose.setup;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tmix = to.mixTime / to.mixDuration;\r\n\t\t\t\tif (mix > 1)\r\n\t\t\t\t\tmix = 1;\r\n\t\t\t}\r\n\t\t\tvar events = mix < from.eventThreshold ? this.events : null;\r\n\t\t\tvar attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n\t\t\tvar animationLast = from.animationLast, animationTime = from.getAnimationTime();\r\n\t\t\tvar timelineCount = from.animation.timelines.length;\r\n\t\t\tvar timelines = from.animation.timelines;\r\n\t\t\tvar timelineData = from.timelineData;\r\n\t\t\tvar timelineDipMix = from.timelineDipMix;\r\n\t\t\tvar firstFrame = from.timelinesRotation.length == 0;\r\n\t\t\tif (firstFrame)\r\n\t\t\t\tspine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\r\n\t\t\tvar timelinesRotation = from.timelinesRotation;\r\n\t\t\tvar pose;\r\n\t\t\tvar alphaDip = from.alpha * to.interruptAlpha, alphaMix = alphaDip * (1 - mix), alpha = 0;\r\n\t\t\tfrom.totalAlpha = 0;\r\n\t\t\tfor (var i = 0; i < timelineCount; i++) {\r\n\t\t\t\tvar timeline = timelines[i];\r\n\t\t\t\tswitch (timelineData[i]) {\r\n\t\t\t\t\tcase AnimationState.SUBSEQUENT:\r\n\t\t\t\t\t\tif (!attachments && timeline instanceof spine.AttachmentTimeline)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tif (!drawOrder && timeline instanceof spine.DrawOrderTimeline)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tpose = currentPose;\r\n\t\t\t\t\t\talpha = alphaMix;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase AnimationState.FIRST:\r\n\t\t\t\t\t\tpose = spine.MixPose.setup;\r\n\t\t\t\t\t\talpha = alphaMix;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase AnimationState.DIP:\r\n\t\t\t\t\t\tpose = spine.MixPose.setup;\r\n\t\t\t\t\t\talpha = alphaDip;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tpose = spine.MixPose.setup;\r\n\t\t\t\t\t\talpha = alphaDip;\r\n\t\t\t\t\t\tvar dipMix = timelineDipMix[i];\r\n\t\t\t\t\t\talpha *= Math.max(0, 1 - dipMix.mixTime / dipMix.mixDuration);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tfrom.totalAlpha += alpha;\r\n\t\t\t\tif (timeline instanceof spine.RotateTimeline)\r\n\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, animationTime, alpha, pose, timelinesRotation, i << 1, firstFrame);\r\n\t\t\t\telse {\r\n\t\t\t\t\tspine.Utils.webkit602BugfixHelper(alpha, pose);\r\n\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, alpha, pose, spine.MixDirection.out);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (to.mixDuration > 0)\r\n\t\t\t\tthis.queueEvents(from, animationTime);\r\n\t\t\tthis.events.length = 0;\r\n\t\t\tfrom.nextAnimationLast = animationTime;\r\n\t\t\tfrom.nextTrackLast = from.trackTime;\r\n\t\t\treturn mix;\r\n\t\t};\r\n\t\tAnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, pose, timelinesRotation, i, firstFrame) {\r\n\t\t\tif (firstFrame)\r\n\t\t\t\ttimelinesRotation[i] = 0;\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\ttimeline.apply(skeleton, 0, time, null, 1, pose, spine.MixDirection[\"in\"]);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar rotateTimeline = timeline;\r\n\t\t\tvar frames = rotateTimeline.frames;\r\n\t\t\tvar bone = skeleton.bones[rotateTimeline.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tif (pose == spine.MixPose.setup)\r\n\t\t\t\t\tbone.rotation = bone.data.rotation;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar r2 = 0;\r\n\t\t\tif (time >= frames[frames.length - spine.RotateTimeline.ENTRIES])\r\n\t\t\t\tr2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION];\r\n\t\t\telse {\r\n\t\t\t\tvar frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);\r\n\t\t\t\tvar prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tr2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;\r\n\t\t\t\tr2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n\t\t\t\tr2 = prevRotation + r2 * percent + bone.data.rotation;\r\n\t\t\t\tr2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n\t\t\t}\r\n\t\t\tvar r1 = pose == spine.MixPose.setup ? bone.data.rotation : bone.rotation;\r\n\t\t\tvar total = 0, diff = r2 - r1;\r\n\t\t\tif (diff == 0) {\r\n\t\t\t\ttotal = timelinesRotation[i];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdiff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n\t\t\t\tvar lastTotal = 0, lastDiff = 0;\r\n\t\t\t\tif (firstFrame) {\r\n\t\t\t\t\tlastTotal = 0;\r\n\t\t\t\t\tlastDiff = diff;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlastTotal = timelinesRotation[i];\r\n\t\t\t\t\tlastDiff = timelinesRotation[i + 1];\r\n\t\t\t\t}\r\n\t\t\t\tvar current = diff > 0, dir = lastTotal >= 0;\r\n\t\t\t\tif (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n\t\t\t\t\tif (Math.abs(lastTotal) > 180)\r\n\t\t\t\t\t\tlastTotal += 360 * spine.MathUtils.signum(lastTotal);\r\n\t\t\t\t\tdir = current;\r\n\t\t\t\t}\r\n\t\t\t\ttotal = diff + lastTotal - lastTotal % 360;\r\n\t\t\t\tif (dir != current)\r\n\t\t\t\t\ttotal += 360 * spine.MathUtils.signum(lastTotal);\r\n\t\t\t\ttimelinesRotation[i] = total;\r\n\t\t\t}\r\n\t\t\ttimelinesRotation[i + 1] = diff;\r\n\t\t\tr1 += total * alpha;\r\n\t\t\tbone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\r\n\t\t};\r\n\t\tAnimationState.prototype.queueEvents = function (entry, animationTime) {\r\n\t\t\tvar animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n\t\t\tvar duration = animationEnd - animationStart;\r\n\t\t\tvar trackLastWrapped = entry.trackLast % duration;\r\n\t\t\tvar events = this.events;\r\n\t\t\tvar i = 0, n = events.length;\r\n\t\t\tfor (; i < n; i++) {\r\n\t\t\t\tvar event_1 = events[i];\r\n\t\t\t\tif (event_1.time < trackLastWrapped)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tif (event_1.time > animationEnd)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tthis.queue.event(entry, event_1);\r\n\t\t\t}\r\n\t\t\tvar complete = false;\r\n\t\t\tif (entry.loop)\r\n\t\t\t\tcomplete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n\t\t\telse\r\n\t\t\t\tcomplete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n\t\t\tif (complete)\r\n\t\t\t\tthis.queue.complete(entry);\r\n\t\t\tfor (; i < n; i++) {\r\n\t\t\t\tvar event_2 = events[i];\r\n\t\t\t\tif (event_2.time < animationStart)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tthis.queue.event(entry, events[i]);\r\n\t\t\t}\r\n\t\t};\r\n\t\tAnimationState.prototype.clearTracks = function () {\r\n\t\t\tvar oldDrainDisabled = this.queue.drainDisabled;\r\n\t\t\tthis.queue.drainDisabled = true;\r\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++)\r\n\t\t\t\tthis.clearTrack(i);\r\n\t\t\tthis.tracks.length = 0;\r\n\t\t\tthis.queue.drainDisabled = oldDrainDisabled;\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.clearTrack = function (trackIndex) {\r\n\t\t\tif (trackIndex >= this.tracks.length)\r\n\t\t\t\treturn;\r\n\t\t\tvar current = this.tracks[trackIndex];\r\n\t\t\tif (current == null)\r\n\t\t\t\treturn;\r\n\t\t\tthis.queue.end(current);\r\n\t\t\tthis.disposeNext(current);\r\n\t\t\tvar entry = current;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar from = entry.mixingFrom;\r\n\t\t\t\tif (from == null)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tthis.queue.end(from);\r\n\t\t\t\tentry.mixingFrom = null;\r\n\t\t\t\tentry = from;\r\n\t\t\t}\r\n\t\t\tthis.tracks[current.trackIndex] = null;\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.setCurrent = function (index, current, interrupt) {\r\n\t\t\tvar from = this.expandToIndex(index);\r\n\t\t\tthis.tracks[index] = current;\r\n\t\t\tif (from != null) {\r\n\t\t\t\tif (interrupt)\r\n\t\t\t\t\tthis.queue.interrupt(from);\r\n\t\t\t\tcurrent.mixingFrom = from;\r\n\t\t\t\tcurrent.mixTime = 0;\r\n\t\t\t\tif (from.mixingFrom != null && from.mixDuration > 0)\r\n\t\t\t\t\tcurrent.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\t\t\t\tfrom.timelinesRotation.length = 0;\r\n\t\t\t}\r\n\t\t\tthis.queue.start(current);\r\n\t\t};\r\n\t\tAnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\r\n\t\t\tvar animation = this.data.skeletonData.findAnimation(animationName);\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + animationName);\r\n\t\t\treturn this.setAnimationWith(trackIndex, animation, loop);\r\n\t\t};\r\n\t\tAnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"animation cannot be null.\");\r\n\t\t\tvar interrupt = true;\r\n\t\t\tvar current = this.expandToIndex(trackIndex);\r\n\t\t\tif (current != null) {\r\n\t\t\t\tif (current.nextTrackLast == -1) {\r\n\t\t\t\t\tthis.tracks[trackIndex] = current.mixingFrom;\r\n\t\t\t\t\tthis.queue.interrupt(current);\r\n\t\t\t\t\tthis.queue.end(current);\r\n\t\t\t\t\tthis.disposeNext(current);\r\n\t\t\t\t\tcurrent = current.mixingFrom;\r\n\t\t\t\t\tinterrupt = false;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.disposeNext(current);\r\n\t\t\t}\r\n\t\t\tvar entry = this.trackEntry(trackIndex, animation, loop, current);\r\n\t\t\tthis.setCurrent(trackIndex, entry, interrupt);\r\n\t\t\tthis.queue.drain();\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\r\n\t\t\tvar animation = this.data.skeletonData.findAnimation(animationName);\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + animationName);\r\n\t\t\treturn this.addAnimationWith(trackIndex, animation, loop, delay);\r\n\t\t};\r\n\t\tAnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"animation cannot be null.\");\r\n\t\t\tvar last = this.expandToIndex(trackIndex);\r\n\t\t\tif (last != null) {\r\n\t\t\t\twhile (last.next != null)\r\n\t\t\t\t\tlast = last.next;\r\n\t\t\t}\r\n\t\t\tvar entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\t\t\tif (last == null) {\r\n\t\t\t\tthis.setCurrent(trackIndex, entry, true);\r\n\t\t\t\tthis.queue.drain();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlast.next = entry;\r\n\t\t\t\tif (delay <= 0) {\r\n\t\t\t\t\tvar duration = last.animationEnd - last.animationStart;\r\n\t\t\t\t\tif (duration != 0) {\r\n\t\t\t\t\t\tif (last.loop)\r\n\t\t\t\t\t\t\tdelay += duration * (1 + ((last.trackTime / duration) | 0));\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tdelay += duration;\r\n\t\t\t\t\t\tdelay -= this.data.getMix(last.animation, animation);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdelay = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tentry.delay = delay;\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\r\n\t\t\tvar entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\r\n\t\t\tentry.mixDuration = mixDuration;\r\n\t\t\tentry.trackEnd = mixDuration;\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\r\n\t\t\tif (delay <= 0)\r\n\t\t\t\tdelay -= mixDuration;\r\n\t\t\tvar entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\r\n\t\t\tentry.mixDuration = mixDuration;\r\n\t\t\tentry.trackEnd = mixDuration;\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.setEmptyAnimations = function (mixDuration) {\r\n\t\t\tvar oldDrainDisabled = this.queue.drainDisabled;\r\n\t\t\tthis.queue.drainDisabled = true;\r\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++) {\r\n\t\t\t\tvar current = this.tracks[i];\r\n\t\t\t\tif (current != null)\r\n\t\t\t\t\tthis.setEmptyAnimation(current.trackIndex, mixDuration);\r\n\t\t\t}\r\n\t\t\tthis.queue.drainDisabled = oldDrainDisabled;\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.expandToIndex = function (index) {\r\n\t\t\tif (index < this.tracks.length)\r\n\t\t\t\treturn this.tracks[index];\r\n\t\t\tspine.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\r\n\t\t\tthis.tracks.length = index + 1;\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tAnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\r\n\t\t\tvar entry = this.trackEntryPool.obtain();\r\n\t\t\tentry.trackIndex = trackIndex;\r\n\t\t\tentry.animation = animation;\r\n\t\t\tentry.loop = loop;\r\n\t\t\tentry.eventThreshold = 0;\r\n\t\t\tentry.attachmentThreshold = 0;\r\n\t\t\tentry.drawOrderThreshold = 0;\r\n\t\t\tentry.animationStart = 0;\r\n\t\t\tentry.animationEnd = animation.duration;\r\n\t\t\tentry.animationLast = -1;\r\n\t\t\tentry.nextAnimationLast = -1;\r\n\t\t\tentry.delay = 0;\r\n\t\t\tentry.trackTime = 0;\r\n\t\t\tentry.trackLast = -1;\r\n\t\t\tentry.nextTrackLast = -1;\r\n\t\t\tentry.trackEnd = Number.MAX_VALUE;\r\n\t\t\tentry.timeScale = 1;\r\n\t\t\tentry.alpha = 1;\r\n\t\t\tentry.interruptAlpha = 1;\r\n\t\t\tentry.mixTime = 0;\r\n\t\t\tentry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.disposeNext = function (entry) {\r\n\t\t\tvar next = entry.next;\r\n\t\t\twhile (next != null) {\r\n\t\t\t\tthis.queue.dispose(next);\r\n\t\t\t\tnext = next.next;\r\n\t\t\t}\r\n\t\t\tentry.next = null;\r\n\t\t};\r\n\t\tAnimationState.prototype._animationsChanged = function () {\r\n\t\t\tthis.animationsChanged = false;\r\n\t\t\tvar propertyIDs = this.propertyIDs;\r\n\t\t\tpropertyIDs.clear();\r\n\t\t\tvar mixingTo = this.mixingTo;\r\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++) {\r\n\t\t\t\tvar entry = this.tracks[i];\r\n\t\t\t\tif (entry != null)\r\n\t\t\t\t\tentry.setTimelineData(null, mixingTo, propertyIDs);\r\n\t\t\t}\r\n\t\t};\r\n\t\tAnimationState.prototype.getCurrent = function (trackIndex) {\r\n\t\t\tif (trackIndex >= this.tracks.length)\r\n\t\t\t\treturn null;\r\n\t\t\treturn this.tracks[trackIndex];\r\n\t\t};\r\n\t\tAnimationState.prototype.addListener = function (listener) {\r\n\t\t\tif (listener == null)\r\n\t\t\t\tthrow new Error(\"listener cannot be null.\");\r\n\t\t\tthis.listeners.push(listener);\r\n\t\t};\r\n\t\tAnimationState.prototype.removeListener = function (listener) {\r\n\t\t\tvar index = this.listeners.indexOf(listener);\r\n\t\t\tif (index >= 0)\r\n\t\t\t\tthis.listeners.splice(index, 1);\r\n\t\t};\r\n\t\tAnimationState.prototype.clearListeners = function () {\r\n\t\t\tthis.listeners.length = 0;\r\n\t\t};\r\n\t\tAnimationState.prototype.clearListenerNotifications = function () {\r\n\t\t\tthis.queue.clear();\r\n\t\t};\r\n\t\tAnimationState.emptyAnimation = new spine.Animation(\"<empty>\", [], 0);\r\n\t\tAnimationState.SUBSEQUENT = 0;\r\n\t\tAnimationState.FIRST = 1;\r\n\t\tAnimationState.DIP = 2;\r\n\t\tAnimationState.DIP_MIX = 3;\r\n\t\treturn AnimationState;\r\n\t}());\r\n\tspine.AnimationState = AnimationState;\r\n\tvar TrackEntry = (function () {\r\n\t\tfunction TrackEntry() {\r\n\t\t\tthis.timelineData = new Array();\r\n\t\t\tthis.timelineDipMix = new Array();\r\n\t\t\tthis.timelinesRotation = new Array();\r\n\t\t}\r\n\t\tTrackEntry.prototype.reset = function () {\r\n\t\t\tthis.next = null;\r\n\t\t\tthis.mixingFrom = null;\r\n\t\t\tthis.animation = null;\r\n\t\t\tthis.listener = null;\r\n\t\t\tthis.timelineData.length = 0;\r\n\t\t\tthis.timelineDipMix.length = 0;\r\n\t\t\tthis.timelinesRotation.length = 0;\r\n\t\t};\r\n\t\tTrackEntry.prototype.setTimelineData = function (to, mixingToArray, propertyIDs) {\r\n\t\t\tif (to != null)\r\n\t\t\t\tmixingToArray.push(to);\r\n\t\t\tvar lastEntry = this.mixingFrom != null ? this.mixingFrom.setTimelineData(this, mixingToArray, propertyIDs) : this;\r\n\t\t\tif (to != null)\r\n\t\t\t\tmixingToArray.pop();\r\n\t\t\tvar mixingTo = mixingToArray;\r\n\t\t\tvar mixingToLast = mixingToArray.length - 1;\r\n\t\t\tvar timelines = this.animation.timelines;\r\n\t\t\tvar timelinesCount = this.animation.timelines.length;\r\n\t\t\tvar timelineData = spine.Utils.setArraySize(this.timelineData, timelinesCount);\r\n\t\t\tthis.timelineDipMix.length = 0;\r\n\t\t\tvar timelineDipMix = spine.Utils.setArraySize(this.timelineDipMix, timelinesCount);\r\n\t\t\touter: for (var i = 0; i < timelinesCount; i++) {\r\n\t\t\t\tvar id = timelines[i].getPropertyId();\r\n\t\t\t\tif (!propertyIDs.add(id))\r\n\t\t\t\t\ttimelineData[i] = AnimationState.SUBSEQUENT;\r\n\t\t\t\telse if (to == null || !to.hasTimeline(id))\r\n\t\t\t\t\ttimelineData[i] = AnimationState.FIRST;\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (var ii = mixingToLast; ii >= 0; ii--) {\r\n\t\t\t\t\t\tvar entry = mixingTo[ii];\r\n\t\t\t\t\t\tif (!entry.hasTimeline(id)) {\r\n\t\t\t\t\t\t\tif (entry.mixDuration > 0) {\r\n\t\t\t\t\t\t\t\ttimelineData[i] = AnimationState.DIP_MIX;\r\n\t\t\t\t\t\t\t\ttimelineDipMix[i] = entry;\r\n\t\t\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimelineData[i] = AnimationState.DIP;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn lastEntry;\r\n\t\t};\r\n\t\tTrackEntry.prototype.hasTimeline = function (id) {\r\n\t\t\tvar timelines = this.animation.timelines;\r\n\t\t\tfor (var i = 0, n = timelines.length; i < n; i++)\r\n\t\t\t\tif (timelines[i].getPropertyId() == id)\r\n\t\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tTrackEntry.prototype.getAnimationTime = function () {\r\n\t\t\tif (this.loop) {\r\n\t\t\t\tvar duration = this.animationEnd - this.animationStart;\r\n\t\t\t\tif (duration == 0)\r\n\t\t\t\t\treturn this.animationStart;\r\n\t\t\t\treturn (this.trackTime % duration) + this.animationStart;\r\n\t\t\t}\r\n\t\t\treturn Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n\t\t};\r\n\t\tTrackEntry.prototype.setAnimationLast = function (animationLast) {\r\n\t\t\tthis.animationLast = animationLast;\r\n\t\t\tthis.nextAnimationLast = animationLast;\r\n\t\t};\r\n\t\tTrackEntry.prototype.isComplete = function () {\r\n\t\t\treturn this.trackTime >= this.animationEnd - this.animationStart;\r\n\t\t};\r\n\t\tTrackEntry.prototype.resetRotationDirections = function () {\r\n\t\t\tthis.timelinesRotation.length = 0;\r\n\t\t};\r\n\t\treturn TrackEntry;\r\n\t}());\r\n\tspine.TrackEntry = TrackEntry;\r\n\tvar EventQueue = (function () {\r\n\t\tfunction EventQueue(animState) {\r\n\t\t\tthis.objects = [];\r\n\t\t\tthis.drainDisabled = false;\r\n\t\t\tthis.animState = animState;\r\n\t\t}\r\n\t\tEventQueue.prototype.start = function (entry) {\r\n\t\t\tthis.objects.push(EventType.start);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t\tthis.animState.animationsChanged = true;\r\n\t\t};\r\n\t\tEventQueue.prototype.interrupt = function (entry) {\r\n\t\t\tthis.objects.push(EventType.interrupt);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t};\r\n\t\tEventQueue.prototype.end = function (entry) {\r\n\t\t\tthis.objects.push(EventType.end);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t\tthis.animState.animationsChanged = true;\r\n\t\t};\r\n\t\tEventQueue.prototype.dispose = function (entry) {\r\n\t\t\tthis.objects.push(EventType.dispose);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t};\r\n\t\tEventQueue.prototype.complete = function (entry) {\r\n\t\t\tthis.objects.push(EventType.complete);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t};\r\n\t\tEventQueue.prototype.event = function (entry, event) {\r\n\t\t\tthis.objects.push(EventType.event);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t\tthis.objects.push(event);\r\n\t\t};\r\n\t\tEventQueue.prototype.drain = function () {\r\n\t\t\tif (this.drainDisabled)\r\n\t\t\t\treturn;\r\n\t\t\tthis.drainDisabled = true;\r\n\t\t\tvar objects = this.objects;\r\n\t\t\tvar listeners = this.animState.listeners;\r\n\t\t\tfor (var i = 0; i < objects.length; i += 2) {\r\n\t\t\t\tvar type = objects[i];\r\n\t\t\t\tvar entry = objects[i + 1];\r\n\t\t\t\tswitch (type) {\r\n\t\t\t\t\tcase EventType.start:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.start)\r\n\t\t\t\t\t\t\tentry.listener.start(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].start)\r\n\t\t\t\t\t\t\t\tlisteners[ii].start(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.interrupt:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.interrupt)\r\n\t\t\t\t\t\t\tentry.listener.interrupt(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].interrupt)\r\n\t\t\t\t\t\t\t\tlisteners[ii].interrupt(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.end:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.end)\r\n\t\t\t\t\t\t\tentry.listener.end(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].end)\r\n\t\t\t\t\t\t\t\tlisteners[ii].end(entry);\r\n\t\t\t\t\tcase EventType.dispose:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.dispose)\r\n\t\t\t\t\t\t\tentry.listener.dispose(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].dispose)\r\n\t\t\t\t\t\t\t\tlisteners[ii].dispose(entry);\r\n\t\t\t\t\t\tthis.animState.trackEntryPool.free(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.complete:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.complete)\r\n\t\t\t\t\t\t\tentry.listener.complete(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].complete)\r\n\t\t\t\t\t\t\t\tlisteners[ii].complete(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.event:\r\n\t\t\t\t\t\tvar event_3 = objects[i++ + 2];\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.event)\r\n\t\t\t\t\t\t\tentry.listener.event(entry, event_3);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].event)\r\n\t\t\t\t\t\t\t\tlisteners[ii].event(entry, event_3);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.clear();\r\n\t\t\tthis.drainDisabled = false;\r\n\t\t};\r\n\t\tEventQueue.prototype.clear = function () {\r\n\t\t\tthis.objects.length = 0;\r\n\t\t};\r\n\t\treturn EventQueue;\r\n\t}());\r\n\tspine.EventQueue = EventQueue;\r\n\tvar EventType;\r\n\t(function (EventType) {\r\n\t\tEventType[EventType[\"start\"] = 0] = \"start\";\r\n\t\tEventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\r\n\t\tEventType[EventType[\"end\"] = 2] = \"end\";\r\n\t\tEventType[EventType[\"dispose\"] = 3] = \"dispose\";\r\n\t\tEventType[EventType[\"complete\"] = 4] = \"complete\";\r\n\t\tEventType[EventType[\"event\"] = 5] = \"event\";\r\n\t})(EventType = spine.EventType || (spine.EventType = {}));\r\n\tvar AnimationStateAdapter2 = (function () {\r\n\t\tfunction AnimationStateAdapter2() {\r\n\t\t}\r\n\t\tAnimationStateAdapter2.prototype.start = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.interrupt = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.end = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.dispose = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.complete = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.event = function (entry, event) {\r\n\t\t};\r\n\t\treturn AnimationStateAdapter2;\r\n\t}());\r\n\tspine.AnimationStateAdapter2 = AnimationStateAdapter2;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AnimationStateData = (function () {\r\n\t\tfunction AnimationStateData(skeletonData) {\r\n\t\t\tthis.animationToMixTime = {};\r\n\t\t\tthis.defaultMix = 0;\r\n\t\t\tif (skeletonData == null)\r\n\t\t\t\tthrow new Error(\"skeletonData cannot be null.\");\r\n\t\t\tthis.skeletonData = skeletonData;\r\n\t\t}\r\n\t\tAnimationStateData.prototype.setMix = function (fromName, toName, duration) {\r\n\t\t\tvar from = this.skeletonData.findAnimation(fromName);\r\n\t\t\tif (from == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + fromName);\r\n\t\t\tvar to = this.skeletonData.findAnimation(toName);\r\n\t\t\tif (to == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + toName);\r\n\t\t\tthis.setMixWith(from, to, duration);\r\n\t\t};\r\n\t\tAnimationStateData.prototype.setMixWith = function (from, to, duration) {\r\n\t\t\tif (from == null)\r\n\t\t\t\tthrow new Error(\"from cannot be null.\");\r\n\t\t\tif (to == null)\r\n\t\t\t\tthrow new Error(\"to cannot be null.\");\r\n\t\t\tvar key = from.name + \".\" + to.name;\r\n\t\t\tthis.animationToMixTime[key] = duration;\r\n\t\t};\r\n\t\tAnimationStateData.prototype.getMix = function (from, to) {\r\n\t\t\tvar key = from.name + \".\" + to.name;\r\n\t\t\tvar value = this.animationToMixTime[key];\r\n\t\t\treturn value === undefined ? this.defaultMix : value;\r\n\t\t};\r\n\t\treturn AnimationStateData;\r\n\t}());\r\n\tspine.AnimationStateData = AnimationStateData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AssetManager = (function () {\r\n\t\tfunction AssetManager(textureLoader, pathPrefix) {\r\n\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n\t\t\tthis.assets = {};\r\n\t\t\tthis.errors = {};\r\n\t\t\tthis.toLoad = 0;\r\n\t\t\tthis.loaded = 0;\r\n\t\t\tthis.textureLoader = textureLoader;\r\n\t\t\tthis.pathPrefix = pathPrefix;\r\n\t\t}\r\n\t\tAssetManager.downloadText = function (url, success, error) {\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.open(\"GET\", url, true);\r\n\t\t\trequest.onload = function () {\r\n\t\t\t\tif (request.status == 200) {\r\n\t\t\t\t\tsuccess(request.responseText);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.onerror = function () {\r\n\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t};\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tAssetManager.downloadBinary = function (url, success, error) {\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.open(\"GET\", url, true);\r\n\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\trequest.onload = function () {\r\n\t\t\t\tif (request.status == 200) {\r\n\t\t\t\t\tsuccess(new Uint8Array(request.response));\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.onerror = function () {\r\n\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t};\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tAssetManager.prototype.loadText = function (path, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tAssetManager.downloadText(path, function (data) {\r\n\t\t\t\t_this.assets[path] = data;\r\n\t\t\t\tif (success)\r\n\t\t\t\t\tsuccess(path, data);\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t}, function (state, responseText) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText);\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t});\r\n\t\t};\r\n\t\tAssetManager.prototype.loadTexture = function (path, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tvar img = new Image();\r\n\t\t\timg.crossOrigin = \"anonymous\";\r\n\t\t\timg.onload = function (ev) {\r\n\t\t\t\tvar texture = _this.textureLoader(img);\r\n\t\t\t\t_this.assets[path] = texture;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (success)\r\n\t\t\t\t\tsuccess(path, img);\r\n\t\t\t};\r\n\t\t\timg.onerror = function (ev) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load image \" + path);\r\n\t\t\t};\r\n\t\t\timg.src = path;\r\n\t\t};\r\n\t\tAssetManager.prototype.loadTextureData = function (path, data, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tvar img = new Image();\r\n\t\t\timg.onload = function (ev) {\r\n\t\t\t\tvar texture = _this.textureLoader(img);\r\n\t\t\t\t_this.assets[path] = texture;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (success)\r\n\t\t\t\t\tsuccess(path, img);\r\n\t\t\t};\r\n\t\t\timg.onerror = function (ev) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load image \" + path);\r\n\t\t\t};\r\n\t\t\timg.src = data;\r\n\t\t};\r\n\t\tAssetManager.prototype.loadTextureAtlas = function (path, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tvar parent = path.lastIndexOf(\"/\") >= 0 ? path.substring(0, path.lastIndexOf(\"/\")) : \"\";\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tAssetManager.downloadText(path, function (atlasData) {\r\n\t\t\t\tvar pagesLoaded = { count: 0 };\r\n\t\t\t\tvar atlasPages = new Array();\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvar atlas = new spine.TextureAtlas(atlasData, function (path) {\r\n\t\t\t\t\t\tatlasPages.push(parent + \"/\" + path);\r\n\t\t\t\t\t\tvar image = document.createElement(\"img\");\r\n\t\t\t\t\t\timage.width = 16;\r\n\t\t\t\t\t\timage.height = 16;\r\n\t\t\t\t\t\treturn new spine.FakeTexture(image);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tvar ex = e;\r\n\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\r\n\t\t\t\t\tif (error)\r\n\t\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\r\n\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar _loop_1 = function (atlasPage) {\r\n\t\t\t\t\tvar pageLoadError = false;\r\n\t\t\t\t\t_this.loadTexture(atlasPage, function (imagePath, image) {\r\n\t\t\t\t\t\tpagesLoaded.count++;\r\n\t\t\t\t\t\tif (pagesLoaded.count == atlasPages.length) {\r\n\t\t\t\t\t\t\tif (!pageLoadError) {\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tvar atlas = new spine.TextureAtlas(atlasData, function (path) {\r\n\t\t\t\t\t\t\t\t\t\treturn _this.get(parent + \"/\" + path);\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t_this.assets[path] = atlas;\r\n\t\t\t\t\t\t\t\t\tif (success)\r\n\t\t\t\t\t\t\t\t\t\tsuccess(path, atlas);\r\n\t\t\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcatch (e) {\r\n\t\t\t\t\t\t\t\t\tvar ex = e;\r\n\t\t\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\r\n\t\t\t\t\t\t\t\t\tif (error)\r\n\t\t\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\r\n\t\t\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\r\n\t\t\t\t\t\t\t\tif (error)\r\n\t\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\r\n\t\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, function (imagePath, errorMessage) {\r\n\t\t\t\t\t\tpageLoadError = true;\r\n\t\t\t\t\t\tpagesLoaded.count++;\r\n\t\t\t\t\t\tif (pagesLoaded.count == atlasPages.length) {\r\n\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\r\n\t\t\t\t\t\t\tif (error)\r\n\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\r\n\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\t\t\t\tfor (var _i = 0, atlasPages_1 = atlasPages; _i < atlasPages_1.length; _i++) {\r\n\t\t\t\t\tvar atlasPage = atlasPages_1[_i];\r\n\t\t\t\t\t_loop_1(atlasPage);\r\n\t\t\t\t}\r\n\t\t\t}, function (state, responseText) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText);\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t});\r\n\t\t};\r\n\t\tAssetManager.prototype.get = function (path) {\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\treturn this.assets[path];\r\n\t\t};\r\n\t\tAssetManager.prototype.remove = function (path) {\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tvar asset = this.assets[path];\r\n\t\t\tif (asset.dispose)\r\n\t\t\t\tasset.dispose();\r\n\t\t\tthis.assets[path] = null;\r\n\t\t};\r\n\t\tAssetManager.prototype.removeAll = function () {\r\n\t\t\tfor (var key in this.assets) {\r\n\t\t\t\tvar asset = this.assets[key];\r\n\t\t\t\tif (asset.dispose)\r\n\t\t\t\t\tasset.dispose();\r\n\t\t\t}\r\n\t\t\tthis.assets = {};\r\n\t\t};\r\n\t\tAssetManager.prototype.isLoadingComplete = function () {\r\n\t\t\treturn this.toLoad == 0;\r\n\t\t};\r\n\t\tAssetManager.prototype.getToLoad = function () {\r\n\t\t\treturn this.toLoad;\r\n\t\t};\r\n\t\tAssetManager.prototype.getLoaded = function () {\r\n\t\t\treturn this.loaded;\r\n\t\t};\r\n\t\tAssetManager.prototype.dispose = function () {\r\n\t\t\tthis.removeAll();\r\n\t\t};\r\n\t\tAssetManager.prototype.hasErrors = function () {\r\n\t\t\treturn Object.keys(this.errors).length > 0;\r\n\t\t};\r\n\t\tAssetManager.prototype.getErrors = function () {\r\n\t\t\treturn this.errors;\r\n\t\t};\r\n\t\treturn AssetManager;\r\n\t}());\r\n\tspine.AssetManager = AssetManager;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AtlasAttachmentLoader = (function () {\r\n\t\tfunction AtlasAttachmentLoader(atlas) {\r\n\t\t\tthis.atlas = atlas;\r\n\t\t}\r\n\t\tAtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\r\n\t\t\tvar region = this.atlas.findRegion(path);\r\n\t\t\tif (region == null)\r\n\t\t\t\tthrow new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n\t\t\tregion.renderObject = region;\r\n\t\t\tvar attachment = new spine.RegionAttachment(name);\r\n\t\t\tattachment.setRegion(region);\r\n\t\t\treturn attachment;\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\r\n\t\t\tvar region = this.atlas.findRegion(path);\r\n\t\t\tif (region == null)\r\n\t\t\t\tthrow new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n\t\t\tregion.renderObject = region;\r\n\t\t\tvar attachment = new spine.MeshAttachment(name);\r\n\t\t\tattachment.region = region;\r\n\t\t\treturn attachment;\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\r\n\t\t\treturn new spine.BoundingBoxAttachment(name);\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\r\n\t\t\treturn new spine.PathAttachment(name);\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\r\n\t\t\treturn new spine.PointAttachment(name);\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\r\n\t\t\treturn new spine.ClippingAttachment(name);\r\n\t\t};\r\n\t\treturn AtlasAttachmentLoader;\r\n\t}());\r\n\tspine.AtlasAttachmentLoader = AtlasAttachmentLoader;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar BlendMode;\r\n\t(function (BlendMode) {\r\n\t\tBlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\r\n\t\tBlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\r\n\t\tBlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\r\n\t\tBlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\r\n\t})(BlendMode = spine.BlendMode || (spine.BlendMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Bone = (function () {\r\n\t\tfunction Bone(data, skeleton, parent) {\r\n\t\t\tthis.children = new Array();\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.rotation = 0;\r\n\t\t\tthis.scaleX = 0;\r\n\t\t\tthis.scaleY = 0;\r\n\t\t\tthis.shearX = 0;\r\n\t\t\tthis.shearY = 0;\r\n\t\t\tthis.ax = 0;\r\n\t\t\tthis.ay = 0;\r\n\t\t\tthis.arotation = 0;\r\n\t\t\tthis.ascaleX = 0;\r\n\t\t\tthis.ascaleY = 0;\r\n\t\t\tthis.ashearX = 0;\r\n\t\t\tthis.ashearY = 0;\r\n\t\t\tthis.appliedValid = false;\r\n\t\t\tthis.a = 0;\r\n\t\t\tthis.b = 0;\r\n\t\t\tthis.worldX = 0;\r\n\t\t\tthis.c = 0;\r\n\t\t\tthis.d = 0;\r\n\t\t\tthis.worldY = 0;\r\n\t\t\tthis.sorted = false;\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.skeleton = skeleton;\r\n\t\t\tthis.parent = parent;\r\n\t\t\tthis.setToSetupPose();\r\n\t\t}\r\n\t\tBone.prototype.update = function () {\r\n\t\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n\t\t};\r\n\t\tBone.prototype.updateWorldTransform = function () {\r\n\t\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n\t\t};\r\n\t\tBone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\r\n\t\t\tthis.ax = x;\r\n\t\t\tthis.ay = y;\r\n\t\t\tthis.arotation = rotation;\r\n\t\t\tthis.ascaleX = scaleX;\r\n\t\t\tthis.ascaleY = scaleY;\r\n\t\t\tthis.ashearX = shearX;\r\n\t\t\tthis.ashearY = shearY;\r\n\t\t\tthis.appliedValid = true;\r\n\t\t\tvar parent = this.parent;\r\n\t\t\tif (parent == null) {\r\n\t\t\t\tvar rotationY = rotation + 90 + shearY;\r\n\t\t\t\tvar la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n\t\t\t\tvar lb = spine.MathUtils.cosDeg(rotationY) * scaleY;\r\n\t\t\t\tvar lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n\t\t\t\tvar ld = spine.MathUtils.sinDeg(rotationY) * scaleY;\r\n\t\t\t\tvar skeleton = this.skeleton;\r\n\t\t\t\tif (skeleton.flipX) {\r\n\t\t\t\t\tx = -x;\r\n\t\t\t\t\tla = -la;\r\n\t\t\t\t\tlb = -lb;\r\n\t\t\t\t}\r\n\t\t\t\tif (skeleton.flipY) {\r\n\t\t\t\t\ty = -y;\r\n\t\t\t\t\tlc = -lc;\r\n\t\t\t\t\tld = -ld;\r\n\t\t\t\t}\r\n\t\t\t\tthis.a = la;\r\n\t\t\t\tthis.b = lb;\r\n\t\t\t\tthis.c = lc;\r\n\t\t\t\tthis.d = ld;\r\n\t\t\t\tthis.worldX = x + skeleton.x;\r\n\t\t\t\tthis.worldY = y + skeleton.y;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\r\n\t\t\tthis.worldX = pa * x + pb * y + parent.worldX;\r\n\t\t\tthis.worldY = pc * x + pd * y + parent.worldY;\r\n\t\t\tswitch (this.data.transformMode) {\r\n\t\t\t\tcase spine.TransformMode.Normal: {\r\n\t\t\t\t\tvar rotationY = rotation + 90 + shearY;\r\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(rotationY) * scaleY;\r\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(rotationY) * scaleY;\r\n\t\t\t\t\tthis.a = pa * la + pb * lc;\r\n\t\t\t\t\tthis.b = pa * lb + pb * ld;\r\n\t\t\t\t\tthis.c = pc * la + pd * lc;\r\n\t\t\t\t\tthis.d = pc * lb + pd * ld;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tcase spine.TransformMode.OnlyTranslation: {\r\n\t\t\t\t\tvar rotationY = rotation + 90 + shearY;\r\n\t\t\t\t\tthis.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tthis.b = spine.MathUtils.cosDeg(rotationY) * scaleY;\r\n\t\t\t\t\tthis.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tthis.d = spine.MathUtils.sinDeg(rotationY) * scaleY;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase spine.TransformMode.NoRotationOrReflection: {\r\n\t\t\t\t\tvar s = pa * pa + pc * pc;\r\n\t\t\t\t\tvar prx = 0;\r\n\t\t\t\t\tif (s > 0.0001) {\r\n\t\t\t\t\t\ts = Math.abs(pa * pd - pb * pc) / s;\r\n\t\t\t\t\t\tpb = pc * s;\r\n\t\t\t\t\t\tpd = pa * s;\r\n\t\t\t\t\t\tprx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpa = 0;\r\n\t\t\t\t\t\tpc = 0;\r\n\t\t\t\t\t\tprx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar rx = rotation + shearX - prx;\r\n\t\t\t\t\tvar ry = rotation + shearY - prx + 90;\r\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(rx) * scaleX;\r\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(ry) * scaleY;\r\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(rx) * scaleX;\r\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(ry) * scaleY;\r\n\t\t\t\t\tthis.a = pa * la - pb * lc;\r\n\t\t\t\t\tthis.b = pa * lb - pb * ld;\r\n\t\t\t\t\tthis.c = pc * la + pd * lc;\r\n\t\t\t\t\tthis.d = pc * lb + pd * ld;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase spine.TransformMode.NoScale:\r\n\t\t\t\tcase spine.TransformMode.NoScaleOrReflection: {\r\n\t\t\t\t\tvar cos = spine.MathUtils.cosDeg(rotation);\r\n\t\t\t\t\tvar sin = spine.MathUtils.sinDeg(rotation);\r\n\t\t\t\t\tvar za = pa * cos + pb * sin;\r\n\t\t\t\t\tvar zc = pc * cos + pd * sin;\r\n\t\t\t\t\tvar s = Math.sqrt(za * za + zc * zc);\r\n\t\t\t\t\tif (s > 0.00001)\r\n\t\t\t\t\t\ts = 1 / s;\r\n\t\t\t\t\tza *= s;\r\n\t\t\t\t\tzc *= s;\r\n\t\t\t\t\ts = Math.sqrt(za * za + zc * zc);\r\n\t\t\t\t\tvar r = Math.PI / 2 + Math.atan2(zc, za);\r\n\t\t\t\t\tvar zb = Math.cos(r) * s;\r\n\t\t\t\t\tvar zd = Math.sin(r) * s;\r\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(shearX) * scaleX;\r\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;\r\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(shearX) * scaleX;\r\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;\r\n\t\t\t\t\tif (this.data.transformMode != spine.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : this.skeleton.flipX != this.skeleton.flipY) {\r\n\t\t\t\t\t\tzb = -zb;\r\n\t\t\t\t\t\tzd = -zd;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.a = za * la + zb * lc;\r\n\t\t\t\t\tthis.b = za * lb + zb * ld;\r\n\t\t\t\t\tthis.c = zc * la + zd * lc;\r\n\t\t\t\t\tthis.d = zc * lb + zd * ld;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.skeleton.flipX) {\r\n\t\t\t\tthis.a = -this.a;\r\n\t\t\t\tthis.b = -this.b;\r\n\t\t\t}\r\n\t\t\tif (this.skeleton.flipY) {\r\n\t\t\t\tthis.c = -this.c;\r\n\t\t\t\tthis.d = -this.d;\r\n\t\t\t}\r\n\t\t};\r\n\t\tBone.prototype.setToSetupPose = function () {\r\n\t\t\tvar data = this.data;\r\n\t\t\tthis.x = data.x;\r\n\t\t\tthis.y = data.y;\r\n\t\t\tthis.rotation = data.rotation;\r\n\t\t\tthis.scaleX = data.scaleX;\r\n\t\t\tthis.scaleY = data.scaleY;\r\n\t\t\tthis.shearX = data.shearX;\r\n\t\t\tthis.shearY = data.shearY;\r\n\t\t};\r\n\t\tBone.prototype.getWorldRotationX = function () {\r\n\t\t\treturn Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.getWorldRotationY = function () {\r\n\t\t\treturn Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.getWorldScaleX = function () {\r\n\t\t\treturn Math.sqrt(this.a * this.a + this.c * this.c);\r\n\t\t};\r\n\t\tBone.prototype.getWorldScaleY = function () {\r\n\t\t\treturn Math.sqrt(this.b * this.b + this.d * this.d);\r\n\t\t};\r\n\t\tBone.prototype.updateAppliedTransform = function () {\r\n\t\t\tthis.appliedValid = true;\r\n\t\t\tvar parent = this.parent;\r\n\t\t\tif (parent == null) {\r\n\t\t\t\tthis.ax = this.worldX;\r\n\t\t\t\tthis.ay = this.worldY;\r\n\t\t\t\tthis.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\r\n\t\t\t\tthis.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);\r\n\t\t\t\tthis.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);\r\n\t\t\t\tthis.ashearX = 0;\r\n\t\t\t\tthis.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\r\n\t\t\tvar pid = 1 / (pa * pd - pb * pc);\r\n\t\t\tvar dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;\r\n\t\t\tthis.ax = (dx * pd * pid - dy * pb * pid);\r\n\t\t\tthis.ay = (dy * pa * pid - dx * pc * pid);\r\n\t\t\tvar ia = pid * pd;\r\n\t\t\tvar id = pid * pa;\r\n\t\t\tvar ib = pid * pb;\r\n\t\t\tvar ic = pid * pc;\r\n\t\t\tvar ra = ia * this.a - ib * this.c;\r\n\t\t\tvar rb = ia * this.b - ib * this.d;\r\n\t\t\tvar rc = id * this.c - ic * this.a;\r\n\t\t\tvar rd = id * this.d - ic * this.b;\r\n\t\t\tthis.ashearX = 0;\r\n\t\t\tthis.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n\t\t\tif (this.ascaleX > 0.0001) {\r\n\t\t\t\tvar det = ra * rd - rb * rc;\r\n\t\t\t\tthis.ascaleY = det / this.ascaleX;\r\n\t\t\t\tthis.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;\r\n\t\t\t\tthis.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.ascaleX = 0;\r\n\t\t\t\tthis.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n\t\t\t\tthis.ashearY = 0;\r\n\t\t\t\tthis.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;\r\n\t\t\t}\r\n\t\t};\r\n\t\tBone.prototype.worldToLocal = function (world) {\r\n\t\t\tvar a = this.a, b = this.b, c = this.c, d = this.d;\r\n\t\t\tvar invDet = 1 / (a * d - b * c);\r\n\t\t\tvar x = world.x - this.worldX, y = world.y - this.worldY;\r\n\t\t\tworld.x = (x * d * invDet - y * b * invDet);\r\n\t\t\tworld.y = (y * a * invDet - x * c * invDet);\r\n\t\t\treturn world;\r\n\t\t};\r\n\t\tBone.prototype.localToWorld = function (local) {\r\n\t\t\tvar x = local.x, y = local.y;\r\n\t\t\tlocal.x = x * this.a + y * this.b + this.worldX;\r\n\t\t\tlocal.y = x * this.c + y * this.d + this.worldY;\r\n\t\t\treturn local;\r\n\t\t};\r\n\t\tBone.prototype.worldToLocalRotation = function (worldRotation) {\r\n\t\t\tvar sin = spine.MathUtils.sinDeg(worldRotation), cos = spine.MathUtils.cosDeg(worldRotation);\r\n\t\t\treturn Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.localToWorldRotation = function (localRotation) {\r\n\t\t\tvar sin = spine.MathUtils.sinDeg(localRotation), cos = spine.MathUtils.cosDeg(localRotation);\r\n\t\t\treturn Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.rotateWorld = function (degrees) {\r\n\t\t\tvar a = this.a, b = this.b, c = this.c, d = this.d;\r\n\t\t\tvar cos = spine.MathUtils.cosDeg(degrees), sin = spine.MathUtils.sinDeg(degrees);\r\n\t\t\tthis.a = cos * a - sin * c;\r\n\t\t\tthis.b = cos * b - sin * d;\r\n\t\t\tthis.c = sin * a + cos * c;\r\n\t\t\tthis.d = sin * b + cos * d;\r\n\t\t\tthis.appliedValid = false;\r\n\t\t};\r\n\t\treturn Bone;\r\n\t}());\r\n\tspine.Bone = Bone;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar BoneData = (function () {\r\n\t\tfunction BoneData(index, name, parent) {\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.rotation = 0;\r\n\t\t\tthis.scaleX = 1;\r\n\t\t\tthis.scaleY = 1;\r\n\t\t\tthis.shearX = 0;\r\n\t\t\tthis.shearY = 0;\r\n\t\t\tthis.transformMode = TransformMode.Normal;\r\n\t\t\tif (index < 0)\r\n\t\t\t\tthrow new Error(\"index must be >= 0.\");\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.index = index;\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.parent = parent;\r\n\t\t}\r\n\t\treturn BoneData;\r\n\t}());\r\n\tspine.BoneData = BoneData;\r\n\tvar TransformMode;\r\n\t(function (TransformMode) {\r\n\t\tTransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\r\n\t\tTransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\r\n\t\tTransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\r\n\t\tTransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\r\n\t\tTransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\r\n\t})(TransformMode = spine.TransformMode || (spine.TransformMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Event = (function () {\r\n\t\tfunction Event(time, data) {\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tthis.time = time;\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\treturn Event;\r\n\t}());\r\n\tspine.Event = Event;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar EventData = (function () {\r\n\t\tfunction EventData(name) {\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn EventData;\r\n\t}());\r\n\tspine.EventData = EventData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar IkConstraint = (function () {\r\n\t\tfunction IkConstraint(data, skeleton) {\r\n\t\t\tthis.mix = 1;\r\n\t\t\tthis.bendDirection = 0;\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.mix = data.mix;\r\n\t\t\tthis.bendDirection = data.bendDirection;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0; i < data.bones.length; i++)\r\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\t\tthis.target = skeleton.findBone(data.target.name);\r\n\t\t}\r\n\t\tIkConstraint.prototype.getOrder = function () {\r\n\t\t\treturn this.data.order;\r\n\t\t};\r\n\t\tIkConstraint.prototype.apply = function () {\r\n\t\t\tthis.update();\r\n\t\t};\r\n\t\tIkConstraint.prototype.update = function () {\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tswitch (bones.length) {\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tthis.apply1(bones[0], target.worldX, target.worldY, this.mix);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tthis.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t};\r\n\t\tIkConstraint.prototype.apply1 = function (bone, targetX, targetY, alpha) {\r\n\t\t\tif (!bone.appliedValid)\r\n\t\t\t\tbone.updateAppliedTransform();\r\n\t\t\tvar p = bone.parent;\r\n\t\t\tvar id = 1 / (p.a * p.d - p.b * p.c);\r\n\t\t\tvar x = targetX - p.worldX, y = targetY - p.worldY;\r\n\t\t\tvar tx = (x * p.d - y * p.b) * id - bone.ax, ty = (y * p.a - x * p.c) * id - bone.ay;\r\n\t\t\tvar rotationIK = Math.atan2(ty, tx) * spine.MathUtils.radDeg - bone.ashearX - bone.arotation;\r\n\t\t\tif (bone.ascaleX < 0)\r\n\t\t\t\trotationIK += 180;\r\n\t\t\tif (rotationIK > 180)\r\n\t\t\t\trotationIK -= 360;\r\n\t\t\telse if (rotationIK < -180)\r\n\t\t\t\trotationIK += 360;\r\n\t\t\tbone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX, bone.ashearY);\r\n\t\t};\r\n\t\tIkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, alpha) {\r\n\t\t\tif (alpha == 0) {\r\n\t\t\t\tchild.updateWorldTransform();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (!parent.appliedValid)\r\n\t\t\t\tparent.updateAppliedTransform();\r\n\t\t\tif (!child.appliedValid)\r\n\t\t\t\tchild.updateAppliedTransform();\r\n\t\t\tvar px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, csx = child.ascaleX;\r\n\t\t\tvar os1 = 0, os2 = 0, s2 = 0;\r\n\t\t\tif (psx < 0) {\r\n\t\t\t\tpsx = -psx;\r\n\t\t\t\tos1 = 180;\r\n\t\t\t\ts2 = -1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tos1 = 0;\r\n\t\t\t\ts2 = 1;\r\n\t\t\t}\r\n\t\t\tif (psy < 0) {\r\n\t\t\t\tpsy = -psy;\r\n\t\t\t\ts2 = -s2;\r\n\t\t\t}\r\n\t\t\tif (csx < 0) {\r\n\t\t\t\tcsx = -csx;\r\n\t\t\t\tos2 = 180;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tos2 = 0;\r\n\t\t\tvar cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;\r\n\t\t\tvar u = Math.abs(psx - psy) <= 0.0001;\r\n\t\t\tif (!u) {\r\n\t\t\t\tcy = 0;\r\n\t\t\t\tcwx = a * cx + parent.worldX;\r\n\t\t\t\tcwy = c * cx + parent.worldY;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcy = child.ay;\r\n\t\t\t\tcwx = a * cx + b * cy + parent.worldX;\r\n\t\t\t\tcwy = c * cx + d * cy + parent.worldY;\r\n\t\t\t}\r\n\t\t\tvar pp = parent.parent;\r\n\t\t\ta = pp.a;\r\n\t\t\tb = pp.b;\r\n\t\t\tc = pp.c;\r\n\t\t\td = pp.d;\r\n\t\t\tvar id = 1 / (a * d - b * c), x = targetX - pp.worldX, y = targetY - pp.worldY;\r\n\t\t\tvar tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\r\n\t\t\tx = cwx - pp.worldX;\r\n\t\t\ty = cwy - pp.worldY;\r\n\t\t\tvar dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n\t\t\tvar l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\r\n\t\t\touter: if (u) {\r\n\t\t\t\tl2 *= psx;\r\n\t\t\t\tvar cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n\t\t\t\tif (cos < -1)\r\n\t\t\t\t\tcos = -1;\r\n\t\t\t\telse if (cos > 1)\r\n\t\t\t\t\tcos = 1;\r\n\t\t\t\ta2 = Math.acos(cos) * bendDir;\r\n\t\t\t\ta = l1 + l2 * cos;\r\n\t\t\t\tb = l2 * Math.sin(a2);\r\n\t\t\t\ta1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ta = psx * l2;\r\n\t\t\t\tb = psy * l2;\r\n\t\t\t\tvar aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);\r\n\t\t\t\tc = bb * l1 * l1 + aa * dd - aa * bb;\r\n\t\t\t\tvar c1 = -2 * bb * l1, c2 = bb - aa;\r\n\t\t\t\td = c1 * c1 - 4 * c2 * c;\r\n\t\t\t\tif (d >= 0) {\r\n\t\t\t\t\tvar q = Math.sqrt(d);\r\n\t\t\t\t\tif (c1 < 0)\r\n\t\t\t\t\t\tq = -q;\r\n\t\t\t\t\tq = -(c1 + q) / 2;\r\n\t\t\t\t\tvar r0 = q / c2, r1 = c / q;\r\n\t\t\t\t\tvar r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n\t\t\t\t\tif (r * r <= dd) {\r\n\t\t\t\t\t\ty = Math.sqrt(dd - r * r) * bendDir;\r\n\t\t\t\t\t\ta1 = ta - Math.atan2(y, r);\r\n\t\t\t\t\t\ta2 = Math.atan2(y / psy, (r - l1) / psx);\r\n\t\t\t\t\t\tbreak outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar minAngle = spine.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n\t\t\t\tvar maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n\t\t\t\tc = -a * l1 / (aa - bb);\r\n\t\t\t\tif (c >= -1 && c <= 1) {\r\n\t\t\t\t\tc = Math.acos(c);\r\n\t\t\t\t\tx = a * Math.cos(c) + l1;\r\n\t\t\t\t\ty = b * Math.sin(c);\r\n\t\t\t\t\td = x * x + y * y;\r\n\t\t\t\t\tif (d < minDist) {\r\n\t\t\t\t\t\tminAngle = c;\r\n\t\t\t\t\t\tminDist = d;\r\n\t\t\t\t\t\tminX = x;\r\n\t\t\t\t\t\tminY = y;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (d > maxDist) {\r\n\t\t\t\t\t\tmaxAngle = c;\r\n\t\t\t\t\t\tmaxDist = d;\r\n\t\t\t\t\t\tmaxX = x;\r\n\t\t\t\t\t\tmaxY = y;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (dd <= (minDist + maxDist) / 2) {\r\n\t\t\t\t\ta1 = ta - Math.atan2(minY * bendDir, minX);\r\n\t\t\t\t\ta2 = minAngle * bendDir;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ta1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n\t\t\t\t\ta2 = maxAngle * bendDir;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar os = Math.atan2(cy, cx) * s2;\r\n\t\t\tvar rotation = parent.arotation;\r\n\t\t\ta1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;\r\n\t\t\tif (a1 > 180)\r\n\t\t\t\ta1 -= 360;\r\n\t\t\telse if (a1 < -180)\r\n\t\t\t\ta1 += 360;\r\n\t\t\tparent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);\r\n\t\t\trotation = child.arotation;\r\n\t\t\ta2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n\t\t\tif (a2 > 180)\r\n\t\t\t\ta2 -= 360;\r\n\t\t\telse if (a2 < -180)\r\n\t\t\t\ta2 += 360;\r\n\t\t\tchild.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n\t\t};\r\n\t\treturn IkConstraint;\r\n\t}());\r\n\tspine.IkConstraint = IkConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar IkConstraintData = (function () {\r\n\t\tfunction IkConstraintData(name) {\r\n\t\t\tthis.order = 0;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.bendDirection = 1;\r\n\t\t\tthis.mix = 1;\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn IkConstraintData;\r\n\t}());\r\n\tspine.IkConstraintData = IkConstraintData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PathConstraint = (function () {\r\n\t\tfunction PathConstraint(data, skeleton) {\r\n\t\t\tthis.position = 0;\r\n\t\t\tthis.spacing = 0;\r\n\t\t\tthis.rotateMix = 0;\r\n\t\t\tthis.translateMix = 0;\r\n\t\t\tthis.spaces = new Array();\r\n\t\t\tthis.positions = new Array();\r\n\t\t\tthis.world = new Array();\r\n\t\t\tthis.curves = new Array();\r\n\t\t\tthis.lengths = new Array();\r\n\t\t\tthis.segments = new Array();\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0, n = data.bones.length; i < n; i++)\r\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\t\tthis.target = skeleton.findSlot(data.target.name);\r\n\t\t\tthis.position = data.position;\r\n\t\t\tthis.spacing = data.spacing;\r\n\t\t\tthis.rotateMix = data.rotateMix;\r\n\t\t\tthis.translateMix = data.translateMix;\r\n\t\t}\r\n\t\tPathConstraint.prototype.apply = function () {\r\n\t\t\tthis.update();\r\n\t\t};\r\n\t\tPathConstraint.prototype.update = function () {\r\n\t\t\tvar attachment = this.target.getAttachment();\r\n\t\t\tif (!(attachment instanceof spine.PathAttachment))\r\n\t\t\t\treturn;\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n\t\t\tvar translate = translateMix > 0, rotate = rotateMix > 0;\r\n\t\t\tif (!translate && !rotate)\r\n\t\t\t\treturn;\r\n\t\t\tvar data = this.data;\r\n\t\t\tvar spacingMode = data.spacingMode;\r\n\t\t\tvar lengthSpacing = spacingMode == spine.SpacingMode.Length;\r\n\t\t\tvar rotateMode = data.rotateMode;\r\n\t\t\tvar tangents = rotateMode == spine.RotateMode.Tangent, scale = rotateMode == spine.RotateMode.ChainScale;\r\n\t\t\tvar boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tvar spaces = spine.Utils.setArraySize(this.spaces, spacesCount), lengths = null;\r\n\t\t\tvar spacing = this.spacing;\r\n\t\t\tif (scale || lengthSpacing) {\r\n\t\t\t\tif (scale)\r\n\t\t\t\t\tlengths = spine.Utils.setArraySize(this.lengths, boneCount);\r\n\t\t\t\tfor (var i = 0, n = spacesCount - 1; i < n;) {\r\n\t\t\t\t\tvar bone = bones[i];\r\n\t\t\t\t\tvar setupLength = bone.data.length;\r\n\t\t\t\t\tif (setupLength < PathConstraint.epsilon) {\r\n\t\t\t\t\t\tif (scale)\r\n\t\t\t\t\t\t\tlengths[i] = 0;\r\n\t\t\t\t\t\tspaces[++i] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar x = setupLength * bone.a, y = setupLength * bone.c;\r\n\t\t\t\t\t\tvar length_1 = Math.sqrt(x * x + y * y);\r\n\t\t\t\t\t\tif (scale)\r\n\t\t\t\t\t\t\tlengths[i] = length_1;\r\n\t\t\t\t\t\tspaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 1; i < spacesCount; i++)\r\n\t\t\t\t\tspaces[i] = spacing;\r\n\t\t\t}\r\n\t\t\tvar positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, spacingMode == spine.SpacingMode.Percent);\r\n\t\t\tvar boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n\t\t\tvar tip = false;\r\n\t\t\tif (offsetRotation == 0)\r\n\t\t\t\ttip = rotateMode == spine.RotateMode.Chain;\r\n\t\t\telse {\r\n\t\t\t\ttip = false;\r\n\t\t\t\tvar p = this.target.bone;\r\n\t\t\t\toffsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tbone.worldX += (boneX - bone.worldX) * translateMix;\r\n\t\t\t\tbone.worldY += (boneY - bone.worldY) * translateMix;\r\n\t\t\t\tvar x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n\t\t\t\tif (scale) {\r\n\t\t\t\t\tvar length_2 = lengths[i];\r\n\t\t\t\t\tif (length_2 != 0) {\r\n\t\t\t\t\t\tvar s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;\r\n\t\t\t\t\t\tbone.a *= s;\r\n\t\t\t\t\t\tbone.c *= s;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tboneX = x;\r\n\t\t\t\tboneY = y;\r\n\t\t\t\tif (rotate) {\r\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;\r\n\t\t\t\t\tif (tangents)\r\n\t\t\t\t\t\tr = positions[p - 1];\r\n\t\t\t\t\telse if (spaces[i + 1] == 0)\r\n\t\t\t\t\t\tr = positions[p + 2];\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tr = Math.atan2(dy, dx);\r\n\t\t\t\t\tr -= Math.atan2(c, a);\r\n\t\t\t\t\tif (tip) {\r\n\t\t\t\t\t\tcos = Math.cos(r);\r\n\t\t\t\t\t\tsin = Math.sin(r);\r\n\t\t\t\t\t\tvar length_3 = bone.data.length;\r\n\t\t\t\t\t\tboneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;\r\n\t\t\t\t\t\tboneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tr += offsetRotation;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr *= rotateMix;\r\n\t\t\t\t\tcos = Math.cos(r);\r\n\t\t\t\t\tsin = Math.sin(r);\r\n\t\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\t}\r\n\t\t\t\tbone.appliedValid = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tPathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar position = this.position;\r\n\t\t\tvar spaces = this.spaces, out = spine.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;\r\n\t\t\tvar closed = path.closed;\r\n\t\t\tvar verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n\t\t\tif (!path.constantSpeed) {\r\n\t\t\t\tvar lengths = path.lengths;\r\n\t\t\t\tcurveCount -= closed ? 1 : 2;\r\n\t\t\t\tvar pathLength_1 = lengths[curveCount];\r\n\t\t\t\tif (percentPosition)\r\n\t\t\t\t\tposition *= pathLength_1;\r\n\t\t\t\tif (percentSpacing) {\r\n\t\t\t\t\tfor (var i = 0; i < spacesCount; i++)\r\n\t\t\t\t\t\tspaces[i] *= pathLength_1;\r\n\t\t\t\t}\r\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, 8);\r\n\t\t\t\tfor (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n\t\t\t\t\tvar space = spaces[i];\r\n\t\t\t\t\tposition += space;\r\n\t\t\t\t\tvar p = position;\r\n\t\t\t\t\tif (closed) {\r\n\t\t\t\t\t\tp %= pathLength_1;\r\n\t\t\t\t\t\tif (p < 0)\r\n\t\t\t\t\t\t\tp += pathLength_1;\r\n\t\t\t\t\t\tcurve = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (p < 0) {\r\n\t\t\t\t\t\tif (prevCurve != PathConstraint.BEFORE) {\r\n\t\t\t\t\t\t\tprevCurve = PathConstraint.BEFORE;\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (p > pathLength_1) {\r\n\t\t\t\t\t\tif (prevCurve != PathConstraint.AFTER) {\r\n\t\t\t\t\t\t\tprevCurve = PathConstraint.AFTER;\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.addAfterPosition(p - pathLength_1, world, 0, out, o);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (;; curve++) {\r\n\t\t\t\t\t\tvar length_4 = lengths[curve];\r\n\t\t\t\t\t\tif (p > length_4)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tif (curve == 0)\r\n\t\t\t\t\t\t\tp /= length_4;\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tvar prev = lengths[curve - 1];\r\n\t\t\t\t\t\t\tp = (p - prev) / (length_4 - prev);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (curve != prevCurve) {\r\n\t\t\t\t\t\tprevCurve = curve;\r\n\t\t\t\t\t\tif (closed && curve == curveCount) {\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\r\n\t\t\t\t}\r\n\t\t\t\treturn out;\r\n\t\t\t}\r\n\t\t\tif (closed) {\r\n\t\t\t\tverticesLength += 2;\r\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, verticesLength);\r\n\t\t\t\tpath.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n\t\t\t\tpath.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n\t\t\t\tworld[verticesLength - 2] = world[0];\r\n\t\t\t\tworld[verticesLength - 1] = world[1];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcurveCount--;\r\n\t\t\t\tverticesLength -= 4;\r\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, verticesLength);\r\n\t\t\t\tpath.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n\t\t\t}\r\n\t\t\tvar curves = spine.Utils.setArraySize(this.curves, curveCount);\r\n\t\t\tvar pathLength = 0;\r\n\t\t\tvar x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n\t\t\tvar tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n\t\t\tfor (var i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n\t\t\t\tcx1 = world[w];\r\n\t\t\t\tcy1 = world[w + 1];\r\n\t\t\t\tcx2 = world[w + 2];\r\n\t\t\t\tcy2 = world[w + 3];\r\n\t\t\t\tx2 = world[w + 4];\r\n\t\t\t\ty2 = world[w + 5];\r\n\t\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n\t\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n\t\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n\t\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n\t\t\t\tddfx = tmpx * 2 + dddfx;\r\n\t\t\t\tddfy = tmpy * 2 + dddfy;\r\n\t\t\t\tdfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n\t\t\t\tdfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tdfx += ddfx;\r\n\t\t\t\tdfy += ddfy;\r\n\t\t\t\tddfx += dddfx;\r\n\t\t\t\tddfy += dddfy;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tdfx += ddfx;\r\n\t\t\t\tdfy += ddfy;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tdfx += ddfx + dddfx;\r\n\t\t\t\tdfy += ddfy + dddfy;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tcurves[i] = pathLength;\r\n\t\t\t\tx1 = x2;\r\n\t\t\t\ty1 = y2;\r\n\t\t\t}\r\n\t\t\tif (percentPosition)\r\n\t\t\t\tposition *= pathLength;\r\n\t\t\tif (percentSpacing) {\r\n\t\t\t\tfor (var i = 0; i < spacesCount; i++)\r\n\t\t\t\t\tspaces[i] *= pathLength;\r\n\t\t\t}\r\n\t\t\tvar segments = this.segments;\r\n\t\t\tvar curveLength = 0;\r\n\t\t\tfor (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n\t\t\t\tvar space = spaces[i];\r\n\t\t\t\tposition += space;\r\n\t\t\t\tvar p = position;\r\n\t\t\t\tif (closed) {\r\n\t\t\t\t\tp %= pathLength;\r\n\t\t\t\t\tif (p < 0)\r\n\t\t\t\t\t\tp += pathLength;\r\n\t\t\t\t\tcurve = 0;\r\n\t\t\t\t}\r\n\t\t\t\telse if (p < 0) {\r\n\t\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse if (p > pathLength) {\r\n\t\t\t\t\tthis.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tfor (;; curve++) {\r\n\t\t\t\t\tvar length_5 = curves[curve];\r\n\t\t\t\t\tif (p > length_5)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (curve == 0)\r\n\t\t\t\t\t\tp /= length_5;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar prev = curves[curve - 1];\r\n\t\t\t\t\t\tp = (p - prev) / (length_5 - prev);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (curve != prevCurve) {\r\n\t\t\t\t\tprevCurve = curve;\r\n\t\t\t\t\tvar ii = curve * 6;\r\n\t\t\t\t\tx1 = world[ii];\r\n\t\t\t\t\ty1 = world[ii + 1];\r\n\t\t\t\t\tcx1 = world[ii + 2];\r\n\t\t\t\t\tcy1 = world[ii + 3];\r\n\t\t\t\t\tcx2 = world[ii + 4];\r\n\t\t\t\t\tcy2 = world[ii + 5];\r\n\t\t\t\t\tx2 = world[ii + 6];\r\n\t\t\t\t\ty2 = world[ii + 7];\r\n\t\t\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n\t\t\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n\t\t\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n\t\t\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n\t\t\t\t\tddfx = tmpx * 2 + dddfx;\r\n\t\t\t\t\tddfy = tmpy * 2 + dddfy;\r\n\t\t\t\t\tdfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n\t\t\t\t\tdfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n\t\t\t\t\tcurveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\tsegments[0] = curveLength;\r\n\t\t\t\t\tfor (ii = 1; ii < 8; ii++) {\r\n\t\t\t\t\t\tdfx += ddfx;\r\n\t\t\t\t\t\tdfy += ddfy;\r\n\t\t\t\t\t\tddfx += dddfx;\r\n\t\t\t\t\t\tddfy += dddfy;\r\n\t\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\t\tsegments[ii] = curveLength;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdfx += ddfx;\r\n\t\t\t\t\tdfy += ddfy;\r\n\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\tsegments[8] = curveLength;\r\n\t\t\t\t\tdfx += ddfx + dddfx;\r\n\t\t\t\t\tdfy += ddfy + dddfy;\r\n\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\tsegments[9] = curveLength;\r\n\t\t\t\t\tsegment = 0;\r\n\t\t\t\t}\r\n\t\t\t\tp *= curveLength;\r\n\t\t\t\tfor (;; segment++) {\r\n\t\t\t\t\tvar length_6 = segments[segment];\r\n\t\t\t\t\tif (p > length_6)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (segment == 0)\r\n\t\t\t\t\t\tp /= length_6;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar prev = segments[segment - 1];\r\n\t\t\t\t\t\tp = segment + (p - prev) / (length_6 - prev);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tthis.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n\t\t\t}\r\n\t\t\treturn out;\r\n\t\t};\r\n\t\tPathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\r\n\t\t\tvar x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n\t\t\tout[o] = x1 + p * Math.cos(r);\r\n\t\t\tout[o + 1] = y1 + p * Math.sin(r);\r\n\t\t\tout[o + 2] = r;\r\n\t\t};\r\n\t\tPathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\r\n\t\t\tvar x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n\t\t\tout[o] = x1 + p * Math.cos(r);\r\n\t\t\tout[o + 1] = y1 + p * Math.sin(r);\r\n\t\t\tout[o + 2] = r;\r\n\t\t};\r\n\t\tPathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\r\n\t\t\tif (p == 0 || isNaN(p))\r\n\t\t\t\tp = 0.0001;\r\n\t\t\tvar tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n\t\t\tvar ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n\t\t\tvar x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n\t\t\tout[o] = x;\r\n\t\t\tout[o + 1] = y;\r\n\t\t\tif (tangents)\r\n\t\t\t\tout[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n\t\t};\r\n\t\tPathConstraint.prototype.getOrder = function () {\r\n\t\t\treturn this.data.order;\r\n\t\t};\r\n\t\tPathConstraint.NONE = -1;\r\n\t\tPathConstraint.BEFORE = -2;\r\n\t\tPathConstraint.AFTER = -3;\r\n\t\tPathConstraint.epsilon = 0.00001;\r\n\t\treturn PathConstraint;\r\n\t}());\r\n\tspine.PathConstraint = PathConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PathConstraintData = (function () {\r\n\t\tfunction PathConstraintData(name) {\r\n\t\t\tthis.order = 0;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn PathConstraintData;\r\n\t}());\r\n\tspine.PathConstraintData = PathConstraintData;\r\n\tvar PositionMode;\r\n\t(function (PositionMode) {\r\n\t\tPositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\r\n\t\tPositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\r\n\t})(PositionMode = spine.PositionMode || (spine.PositionMode = {}));\r\n\tvar SpacingMode;\r\n\t(function (SpacingMode) {\r\n\t\tSpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\r\n\t\tSpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\r\n\t\tSpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\r\n\t})(SpacingMode = spine.SpacingMode || (spine.SpacingMode = {}));\r\n\tvar RotateMode;\r\n\t(function (RotateMode) {\r\n\t\tRotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\r\n\t\tRotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\r\n\t\tRotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\r\n\t})(RotateMode = spine.RotateMode || (spine.RotateMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Assets = (function () {\r\n\t\tfunction Assets(clientId) {\r\n\t\t\tthis.toLoad = new Array();\r\n\t\t\tthis.assets = {};\r\n\t\t\tthis.clientId = clientId;\r\n\t\t}\r\n\t\tAssets.prototype.loaded = function () {\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (var v in this.assets)\r\n\t\t\t\ti++;\r\n\t\t\treturn i;\r\n\t\t};\r\n\t\treturn Assets;\r\n\t}());\r\n\tvar SharedAssetManager = (function () {\r\n\t\tfunction SharedAssetManager(pathPrefix) {\r\n\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n\t\t\tthis.clientAssets = {};\r\n\t\t\tthis.queuedAssets = {};\r\n\t\t\tthis.rawAssets = {};\r\n\t\t\tthis.errors = {};\r\n\t\t\tthis.pathPrefix = pathPrefix;\r\n\t\t}\r\n\t\tSharedAssetManager.prototype.queueAsset = function (clientId, textureLoader, path) {\r\n\t\t\tvar clientAssets = this.clientAssets[clientId];\r\n\t\t\tif (clientAssets === null || clientAssets === undefined) {\r\n\t\t\t\tclientAssets = new Assets(clientId);\r\n\t\t\t\tthis.clientAssets[clientId] = clientAssets;\r\n\t\t\t}\r\n\t\t\tif (textureLoader !== null)\r\n\t\t\t\tclientAssets.textureLoader = textureLoader;\r\n\t\t\tclientAssets.toLoad.push(path);\r\n\t\t\tif (this.queuedAssets[path] === path) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.queuedAssets[path] = path;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.loadText = function (clientId, path) {\r\n\t\t\tvar _this = this;\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tif (!this.queueAsset(clientId, null, path))\r\n\t\t\t\treturn;\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.onreadystatechange = function () {\r\n\t\t\t\tif (request.readyState == XMLHttpRequest.DONE) {\r\n\t\t\t\t\tif (request.status >= 200 && request.status < 300) {\r\n\t\t\t\t\t\t_this.rawAssets[path] = request.responseText;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.open(\"GET\", path, true);\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.loadJson = function (clientId, path) {\r\n\t\t\tvar _this = this;\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tif (!this.queueAsset(clientId, null, path))\r\n\t\t\t\treturn;\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.onreadystatechange = function () {\r\n\t\t\t\tif (request.readyState == XMLHttpRequest.DONE) {\r\n\t\t\t\t\tif (request.status >= 200 && request.status < 300) {\r\n\t\t\t\t\t\t_this.rawAssets[path] = JSON.parse(request.responseText);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.open(\"GET\", path, true);\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.loadTexture = function (clientId, textureLoader, path) {\r\n\t\t\tvar _this = this;\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tif (!this.queueAsset(clientId, textureLoader, path))\r\n\t\t\t\treturn;\r\n\t\t\tvar img = new Image();\r\n\t\t\timg.src = path;\r\n\t\t\timg.crossOrigin = \"anonymous\";\r\n\t\t\timg.onload = function (ev) {\r\n\t\t\t\t_this.rawAssets[path] = img;\r\n\t\t\t};\r\n\t\t\timg.onerror = function (ev) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\r\n\t\t\t};\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.get = function (clientId, path) {\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tvar clientAssets = this.clientAssets[clientId];\r\n\t\t\tif (clientAssets === null || clientAssets === undefined)\r\n\t\t\t\treturn true;\r\n\t\t\treturn clientAssets.assets[path];\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.updateClientAssets = function (clientAssets) {\r\n\t\t\tfor (var i = 0; i < clientAssets.toLoad.length; i++) {\r\n\t\t\t\tvar path = clientAssets.toLoad[i];\r\n\t\t\t\tvar asset = clientAssets.assets[path];\r\n\t\t\t\tif (asset === null || asset === undefined) {\r\n\t\t\t\t\tvar rawAsset = this.rawAssets[path];\r\n\t\t\t\t\tif (rawAsset === null || rawAsset === undefined)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (rawAsset instanceof HTMLImageElement) {\r\n\t\t\t\t\t\tclientAssets.assets[path] = clientAssets.textureLoader(rawAsset);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tclientAssets.assets[path] = rawAsset;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.isLoadingComplete = function (clientId) {\r\n\t\t\tvar clientAssets = this.clientAssets[clientId];\r\n\t\t\tif (clientAssets === null || clientAssets === undefined)\r\n\t\t\t\treturn true;\r\n\t\t\tthis.updateClientAssets(clientAssets);\r\n\t\t\treturn clientAssets.toLoad.length == clientAssets.loaded();\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.dispose = function () {\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.hasErrors = function () {\r\n\t\t\treturn Object.keys(this.errors).length > 0;\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.getErrors = function () {\r\n\t\t\treturn this.errors;\r\n\t\t};\r\n\t\treturn SharedAssetManager;\r\n\t}());\r\n\tspine.SharedAssetManager = SharedAssetManager;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Skeleton = (function () {\r\n\t\tfunction Skeleton(data) {\r\n\t\t\tthis._updateCache = new Array();\r\n\t\t\tthis.updateCacheReset = new Array();\r\n\t\t\tthis.time = 0;\r\n\t\t\tthis.flipX = false;\r\n\t\t\tthis.flipY = false;\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0; i < data.bones.length; i++) {\r\n\t\t\t\tvar boneData = data.bones[i];\r\n\t\t\t\tvar bone = void 0;\r\n\t\t\t\tif (boneData.parent == null)\r\n\t\t\t\t\tbone = new spine.Bone(boneData, this, null);\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar parent_1 = this.bones[boneData.parent.index];\r\n\t\t\t\t\tbone = new spine.Bone(boneData, this, parent_1);\r\n\t\t\t\t\tparent_1.children.push(bone);\r\n\t\t\t\t}\r\n\t\t\t\tthis.bones.push(bone);\r\n\t\t\t}\r\n\t\t\tthis.slots = new Array();\r\n\t\t\tthis.drawOrder = new Array();\r\n\t\t\tfor (var i = 0; i < data.slots.length; i++) {\r\n\t\t\t\tvar slotData = data.slots[i];\r\n\t\t\t\tvar bone = this.bones[slotData.boneData.index];\r\n\t\t\t\tvar slot = new spine.Slot(slotData, bone);\r\n\t\t\t\tthis.slots.push(slot);\r\n\t\t\t\tthis.drawOrder.push(slot);\r\n\t\t\t}\r\n\t\t\tthis.ikConstraints = new Array();\r\n\t\t\tfor (var i = 0; i < data.ikConstraints.length; i++) {\r\n\t\t\t\tvar ikConstraintData = data.ikConstraints[i];\r\n\t\t\t\tthis.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));\r\n\t\t\t}\r\n\t\t\tthis.transformConstraints = new Array();\r\n\t\t\tfor (var i = 0; i < data.transformConstraints.length; i++) {\r\n\t\t\t\tvar transformConstraintData = data.transformConstraints[i];\r\n\t\t\t\tthis.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));\r\n\t\t\t}\r\n\t\t\tthis.pathConstraints = new Array();\r\n\t\t\tfor (var i = 0; i < data.pathConstraints.length; i++) {\r\n\t\t\t\tvar pathConstraintData = data.pathConstraints[i];\r\n\t\t\t\tthis.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));\r\n\t\t\t}\r\n\t\t\tthis.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\tthis.updateCache();\r\n\t\t}\r\n\t\tSkeleton.prototype.updateCache = function () {\r\n\t\t\tvar updateCache = this._updateCache;\r\n\t\t\tupdateCache.length = 0;\r\n\t\t\tthis.updateCacheReset.length = 0;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tbones[i].sorted = false;\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tvar ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n\t\t\tvar constraintCount = ikCount + transformCount + pathCount;\r\n\t\t\touter: for (var i = 0; i < constraintCount; i++) {\r\n\t\t\t\tfor (var ii = 0; ii < ikCount; ii++) {\r\n\t\t\t\t\tvar constraint = ikConstraints[ii];\r\n\t\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\t\tthis.sortIkConstraint(constraint);\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var ii = 0; ii < transformCount; ii++) {\r\n\t\t\t\t\tvar constraint = transformConstraints[ii];\r\n\t\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\t\tthis.sortTransformConstraint(constraint);\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var ii = 0; ii < pathCount; ii++) {\r\n\t\t\t\t\tvar constraint = pathConstraints[ii];\r\n\t\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\t\tthis.sortPathConstraint(constraint);\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tthis.sortBone(bones[i]);\r\n\t\t};\r\n\t\tSkeleton.prototype.sortIkConstraint = function (constraint) {\r\n\t\t\tvar target = constraint.target;\r\n\t\t\tthis.sortBone(target);\r\n\t\t\tvar constrained = constraint.bones;\r\n\t\t\tvar parent = constrained[0];\r\n\t\t\tthis.sortBone(parent);\r\n\t\t\tif (constrained.length > 1) {\r\n\t\t\t\tvar child = constrained[constrained.length - 1];\r\n\t\t\t\tif (!(this._updateCache.indexOf(child) > -1))\r\n\t\t\t\t\tthis.updateCacheReset.push(child);\r\n\t\t\t}\r\n\t\t\tthis._updateCache.push(constraint);\r\n\t\t\tthis.sortReset(parent.children);\r\n\t\t\tconstrained[constrained.length - 1].sorted = true;\r\n\t\t};\r\n\t\tSkeleton.prototype.sortPathConstraint = function (constraint) {\r\n\t\t\tvar slot = constraint.target;\r\n\t\t\tvar slotIndex = slot.data.index;\r\n\t\t\tvar slotBone = slot.bone;\r\n\t\t\tif (this.skin != null)\r\n\t\t\t\tthis.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n\t\t\tif (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n\t\t\t\tthis.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n\t\t\tfor (var i = 0, n = this.data.skins.length; i < n; i++)\r\n\t\t\t\tthis.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\tif (attachment instanceof spine.PathAttachment)\r\n\t\t\t\tthis.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\t\t\tvar constrained = constraint.bones;\r\n\t\t\tvar boneCount = constrained.length;\r\n\t\t\tfor (var i = 0; i < boneCount; i++)\r\n\t\t\t\tthis.sortBone(constrained[i]);\r\n\t\t\tthis._updateCache.push(constraint);\r\n\t\t\tfor (var i = 0; i < boneCount; i++)\r\n\t\t\t\tthis.sortReset(constrained[i].children);\r\n\t\t\tfor (var i = 0; i < boneCount; i++)\r\n\t\t\t\tconstrained[i].sorted = true;\r\n\t\t};\r\n\t\tSkeleton.prototype.sortTransformConstraint = function (constraint) {\r\n\t\t\tthis.sortBone(constraint.target);\r\n\t\t\tvar constrained = constraint.bones;\r\n\t\t\tvar boneCount = constrained.length;\r\n\t\t\tif (constraint.data.local) {\r\n\t\t\t\tfor (var i = 0; i < boneCount; i++) {\r\n\t\t\t\t\tvar child = constrained[i];\r\n\t\t\t\t\tthis.sortBone(child.parent);\r\n\t\t\t\t\tif (!(this._updateCache.indexOf(child) > -1))\r\n\t\t\t\t\t\tthis.updateCacheReset.push(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 0; i < boneCount; i++) {\r\n\t\t\t\t\tthis.sortBone(constrained[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._updateCache.push(constraint);\r\n\t\t\tfor (var ii = 0; ii < boneCount; ii++)\r\n\t\t\t\tthis.sortReset(constrained[ii].children);\r\n\t\t\tfor (var ii = 0; ii < boneCount; ii++)\r\n\t\t\t\tconstrained[ii].sorted = true;\r\n\t\t};\r\n\t\tSkeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\r\n\t\t\tvar attachments = skin.attachments[slotIndex];\r\n\t\t\tif (!attachments)\r\n\t\t\t\treturn;\r\n\t\t\tfor (var key in attachments) {\r\n\t\t\t\tthis.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\r\n\t\t\tif (!(attachment instanceof spine.PathAttachment))\r\n\t\t\t\treturn;\r\n\t\t\tvar pathBones = attachment.bones;\r\n\t\t\tif (pathBones == null)\r\n\t\t\t\tthis.sortBone(slotBone);\r\n\t\t\telse {\r\n\t\t\t\tvar bones = this.bones;\r\n\t\t\t\tvar i = 0;\r\n\t\t\t\twhile (i < pathBones.length) {\r\n\t\t\t\t\tvar boneCount = pathBones[i++];\r\n\t\t\t\t\tfor (var n = i + boneCount; i < n; i++) {\r\n\t\t\t\t\t\tvar boneIndex = pathBones[i];\r\n\t\t\t\t\t\tthis.sortBone(bones[boneIndex]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.sortBone = function (bone) {\r\n\t\t\tif (bone.sorted)\r\n\t\t\t\treturn;\r\n\t\t\tvar parent = bone.parent;\r\n\t\t\tif (parent != null)\r\n\t\t\t\tthis.sortBone(parent);\r\n\t\t\tbone.sorted = true;\r\n\t\t\tthis._updateCache.push(bone);\r\n\t\t};\r\n\t\tSkeleton.prototype.sortReset = function (bones) {\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (bone.sorted)\r\n\t\t\t\t\tthis.sortReset(bone.children);\r\n\t\t\t\tbone.sorted = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.updateWorldTransform = function () {\r\n\t\t\tvar updateCacheReset = this.updateCacheReset;\r\n\t\t\tfor (var i = 0, n = updateCacheReset.length; i < n; i++) {\r\n\t\t\t\tvar bone = updateCacheReset[i];\r\n\t\t\t\tbone.ax = bone.x;\r\n\t\t\t\tbone.ay = bone.y;\r\n\t\t\t\tbone.arotation = bone.rotation;\r\n\t\t\t\tbone.ascaleX = bone.scaleX;\r\n\t\t\t\tbone.ascaleY = bone.scaleY;\r\n\t\t\t\tbone.ashearX = bone.shearX;\r\n\t\t\t\tbone.ashearY = bone.shearY;\r\n\t\t\t\tbone.appliedValid = true;\r\n\t\t\t}\r\n\t\t\tvar updateCache = this._updateCache;\r\n\t\t\tfor (var i = 0, n = updateCache.length; i < n; i++)\r\n\t\t\t\tupdateCache[i].update();\r\n\t\t};\r\n\t\tSkeleton.prototype.setToSetupPose = function () {\r\n\t\t\tthis.setBonesToSetupPose();\r\n\t\t\tthis.setSlotsToSetupPose();\r\n\t\t};\r\n\t\tSkeleton.prototype.setBonesToSetupPose = function () {\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tbones[i].setToSetupPose();\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = ikConstraints[i];\r\n\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\tconstraint.mix = constraint.data.mix;\r\n\t\t\t}\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = transformConstraints[i];\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\t\tconstraint.scaleMix = data.scaleMix;\r\n\t\t\t\tconstraint.shearMix = data.shearMix;\r\n\t\t\t}\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = pathConstraints[i];\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tconstraint.position = data.position;\r\n\t\t\t\tconstraint.spacing = data.spacing;\r\n\t\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.setSlotsToSetupPose = function () {\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tspine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\r\n\t\t\t\tslots[i].setToSetupPose();\r\n\t\t};\r\n\t\tSkeleton.prototype.getRootBone = function () {\r\n\t\t\tif (this.bones.length == 0)\r\n\t\t\t\treturn null;\r\n\t\t\treturn this.bones[0];\r\n\t\t};\r\n\t\tSkeleton.prototype.findBone = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (bone.data.name == boneName)\r\n\t\t\t\t\treturn bone;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findBoneIndex = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tif (bones[i].data.name == boneName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeleton.prototype.findSlot = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tif (slot.data.name == slotName)\r\n\t\t\t\t\treturn slot;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findSlotIndex = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\r\n\t\t\t\tif (slots[i].data.name == slotName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeleton.prototype.setSkinByName = function (skinName) {\r\n\t\t\tvar skin = this.data.findSkin(skinName);\r\n\t\t\tif (skin == null)\r\n\t\t\t\tthrow new Error(\"Skin not found: \" + skinName);\r\n\t\t\tthis.setSkin(skin);\r\n\t\t};\r\n\t\tSkeleton.prototype.setSkin = function (newSkin) {\r\n\t\t\tif (newSkin != null) {\r\n\t\t\t\tif (this.skin != null)\r\n\t\t\t\t\tnewSkin.attachAll(this, this.skin);\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar slots = this.slots;\r\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\t\t\tvar slot = slots[i];\r\n\t\t\t\t\t\tvar name_1 = slot.data.attachmentName;\r\n\t\t\t\t\t\tif (name_1 != null) {\r\n\t\t\t\t\t\t\tvar attachment = newSkin.getAttachment(i, name_1);\r\n\t\t\t\t\t\t\tif (attachment != null)\r\n\t\t\t\t\t\t\t\tslot.setAttachment(attachment);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.skin = newSkin;\r\n\t\t};\r\n\t\tSkeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\r\n\t\t\treturn this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n\t\t};\r\n\t\tSkeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\r\n\t\t\tif (attachmentName == null)\r\n\t\t\t\tthrow new Error(\"attachmentName cannot be null.\");\r\n\t\t\tif (this.skin != null) {\r\n\t\t\t\tvar attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n\t\t\t\tif (attachment != null)\r\n\t\t\t\t\treturn attachment;\r\n\t\t\t}\r\n\t\t\tif (this.data.defaultSkin != null)\r\n\t\t\t\treturn this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.setAttachment = function (slotName, attachmentName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tif (slot.data.name == slotName) {\r\n\t\t\t\t\tvar attachment = null;\r\n\t\t\t\t\tif (attachmentName != null) {\r\n\t\t\t\t\t\tattachment = this.getAttachment(i, attachmentName);\r\n\t\t\t\t\t\tif (attachment == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tslot.setAttachment(attachment);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Slot not found: \" + slotName);\r\n\t\t};\r\n\t\tSkeleton.prototype.findIkConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\t\tvar ikConstraint = ikConstraints[i];\r\n\t\t\t\tif (ikConstraint.data.name == constraintName)\r\n\t\t\t\t\treturn ikConstraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findTransformConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = transformConstraints[i];\r\n\t\t\t\tif (constraint.data.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findPathConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = pathConstraints[i];\r\n\t\t\t\tif (constraint.data.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.getBounds = function (offset, size, temp) {\r\n\t\t\tif (offset == null)\r\n\t\t\t\tthrow new Error(\"offset cannot be null.\");\r\n\t\t\tif (size == null)\r\n\t\t\t\tthrow new Error(\"size cannot be null.\");\r\n\t\t\tvar drawOrder = this.drawOrder;\r\n\t\t\tvar minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n\t\t\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\r\n\t\t\t\tvar slot = drawOrder[i];\r\n\t\t\t\tvar verticesLength = 0;\r\n\t\t\t\tvar vertices = null;\r\n\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\r\n\t\t\t\t\tverticesLength = 8;\r\n\t\t\t\t\tvertices = spine.Utils.setArraySize(temp, verticesLength, 0);\r\n\t\t\t\t\tattachment.computeWorldVertices(slot.bone, vertices, 0, 2);\r\n\t\t\t\t}\r\n\t\t\t\telse if (attachment instanceof spine.MeshAttachment) {\r\n\t\t\t\t\tvar mesh = attachment;\r\n\t\t\t\t\tverticesLength = mesh.worldVerticesLength;\r\n\t\t\t\t\tvertices = spine.Utils.setArraySize(temp, verticesLength, 0);\r\n\t\t\t\t\tmesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n\t\t\t\t}\r\n\t\t\t\tif (vertices != null) {\r\n\t\t\t\t\tfor (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n\t\t\t\t\t\tvar x = vertices[ii], y = vertices[ii + 1];\r\n\t\t\t\t\t\tminX = Math.min(minX, x);\r\n\t\t\t\t\t\tminY = Math.min(minY, y);\r\n\t\t\t\t\t\tmaxX = Math.max(maxX, x);\r\n\t\t\t\t\t\tmaxY = Math.max(maxY, y);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toffset.set(minX, minY);\r\n\t\t\tsize.set(maxX - minX, maxY - minY);\r\n\t\t};\r\n\t\tSkeleton.prototype.update = function (delta) {\r\n\t\t\tthis.time += delta;\r\n\t\t};\r\n\t\treturn Skeleton;\r\n\t}());\r\n\tspine.Skeleton = Skeleton;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonBounds = (function () {\r\n\t\tfunction SkeletonBounds() {\r\n\t\t\tthis.minX = 0;\r\n\t\t\tthis.minY = 0;\r\n\t\t\tthis.maxX = 0;\r\n\t\t\tthis.maxY = 0;\r\n\t\t\tthis.boundingBoxes = new Array();\r\n\t\t\tthis.polygons = new Array();\r\n\t\t\tthis.polygonPool = new spine.Pool(function () {\r\n\t\t\t\treturn spine.Utils.newFloatArray(16);\r\n\t\t\t});\r\n\t\t}\r\n\t\tSkeletonBounds.prototype.update = function (skeleton, updateAabb) {\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tvar boundingBoxes = this.boundingBoxes;\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tvar polygonPool = this.polygonPool;\r\n\t\t\tvar slots = skeleton.slots;\r\n\t\t\tvar slotCount = slots.length;\r\n\t\t\tboundingBoxes.length = 0;\r\n\t\t\tpolygonPool.freeAll(polygons);\r\n\t\t\tpolygons.length = 0;\r\n\t\t\tfor (var i = 0; i < slotCount; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\tif (attachment instanceof spine.BoundingBoxAttachment) {\r\n\t\t\t\t\tvar boundingBox = attachment;\r\n\t\t\t\t\tboundingBoxes.push(boundingBox);\r\n\t\t\t\t\tvar polygon = polygonPool.obtain();\r\n\t\t\t\t\tif (polygon.length != boundingBox.worldVerticesLength) {\r\n\t\t\t\t\t\tpolygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpolygons.push(polygon);\r\n\t\t\t\t\tboundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (updateAabb) {\r\n\t\t\t\tthis.aabbCompute();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.minX = Number.POSITIVE_INFINITY;\r\n\t\t\t\tthis.minY = Number.POSITIVE_INFINITY;\r\n\t\t\t\tthis.maxX = Number.NEGATIVE_INFINITY;\r\n\t\t\t\tthis.maxY = Number.NEGATIVE_INFINITY;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbCompute = function () {\r\n\t\t\tvar minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++) {\r\n\t\t\t\tvar polygon = polygons[i];\r\n\t\t\t\tvar vertices = polygon;\r\n\t\t\t\tfor (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n\t\t\t\t\tvar x = vertices[ii];\r\n\t\t\t\t\tvar y = vertices[ii + 1];\r\n\t\t\t\t\tminX = Math.min(minX, x);\r\n\t\t\t\t\tminY = Math.min(minY, y);\r\n\t\t\t\t\tmaxX = Math.max(maxX, x);\r\n\t\t\t\t\tmaxY = Math.max(maxY, y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.minX = minX;\r\n\t\t\tthis.minY = minY;\r\n\t\t\tthis.maxX = maxX;\r\n\t\t\tthis.maxY = maxY;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\r\n\t\t\treturn x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\r\n\t\t\tvar minX = this.minX;\r\n\t\t\tvar minY = this.minY;\r\n\t\t\tvar maxX = this.maxX;\r\n\t\t\tvar maxY = this.maxY;\r\n\t\t\tif ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n\t\t\t\treturn false;\r\n\t\t\tvar m = (y2 - y1) / (x2 - x1);\r\n\t\t\tvar y = m * (minX - x1) + y1;\r\n\t\t\tif (y > minY && y < maxY)\r\n\t\t\t\treturn true;\r\n\t\t\ty = m * (maxX - x1) + y1;\r\n\t\t\tif (y > minY && y < maxY)\r\n\t\t\t\treturn true;\r\n\t\t\tvar x = (minY - y1) / m + x1;\r\n\t\t\tif (x > minX && x < maxX)\r\n\t\t\t\treturn true;\r\n\t\t\tx = (maxY - y1) / m + x1;\r\n\t\t\tif (x > minX && x < maxX)\r\n\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\r\n\t\t\treturn this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.containsPoint = function (x, y) {\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++)\r\n\t\t\t\tif (this.containsPointPolygon(polygons[i], x, y))\r\n\t\t\t\t\treturn this.boundingBoxes[i];\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\r\n\t\t\tvar vertices = polygon;\r\n\t\t\tvar nn = polygon.length;\r\n\t\t\tvar prevIndex = nn - 2;\r\n\t\t\tvar inside = false;\r\n\t\t\tfor (var ii = 0; ii < nn; ii += 2) {\r\n\t\t\t\tvar vertexY = vertices[ii + 1];\r\n\t\t\t\tvar prevY = vertices[prevIndex + 1];\r\n\t\t\t\tif ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n\t\t\t\t\tvar vertexX = vertices[ii];\r\n\t\t\t\t\tif (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)\r\n\t\t\t\t\t\tinside = !inside;\r\n\t\t\t\t}\r\n\t\t\t\tprevIndex = ii;\r\n\t\t\t}\r\n\t\t\treturn inside;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++)\r\n\t\t\t\tif (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))\r\n\t\t\t\t\treturn this.boundingBoxes[i];\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\r\n\t\t\tvar vertices = polygon;\r\n\t\t\tvar nn = polygon.length;\r\n\t\t\tvar width12 = x1 - x2, height12 = y1 - y2;\r\n\t\t\tvar det1 = x1 * y2 - y1 * x2;\r\n\t\t\tvar x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n\t\t\tfor (var ii = 0; ii < nn; ii += 2) {\r\n\t\t\t\tvar x4 = vertices[ii], y4 = vertices[ii + 1];\r\n\t\t\t\tvar det2 = x3 * y4 - y3 * x4;\r\n\t\t\t\tvar width34 = x3 - x4, height34 = y3 - y4;\r\n\t\t\t\tvar det3 = width12 * height34 - height12 * width34;\r\n\t\t\t\tvar x = (det1 * width34 - width12 * det2) / det3;\r\n\t\t\t\tif (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n\t\t\t\t\tvar y = (det1 * height34 - height12 * det2) / det3;\r\n\t\t\t\t\tif (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tx3 = x4;\r\n\t\t\t\ty3 = y4;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.getPolygon = function (boundingBox) {\r\n\t\t\tif (boundingBox == null)\r\n\t\t\t\tthrow new Error(\"boundingBox cannot be null.\");\r\n\t\t\tvar index = this.boundingBoxes.indexOf(boundingBox);\r\n\t\t\treturn index == -1 ? null : this.polygons[index];\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.getWidth = function () {\r\n\t\t\treturn this.maxX - this.minX;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.getHeight = function () {\r\n\t\t\treturn this.maxY - this.minY;\r\n\t\t};\r\n\t\treturn SkeletonBounds;\r\n\t}());\r\n\tspine.SkeletonBounds = SkeletonBounds;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonClipping = (function () {\r\n\t\tfunction SkeletonClipping() {\r\n\t\t\tthis.triangulator = new spine.Triangulator();\r\n\t\t\tthis.clippingPolygon = new Array();\r\n\t\t\tthis.clipOutput = new Array();\r\n\t\t\tthis.clippedVertices = new Array();\r\n\t\t\tthis.clippedTriangles = new Array();\r\n\t\t\tthis.scratch = new Array();\r\n\t\t}\r\n\t\tSkeletonClipping.prototype.clipStart = function (slot, clip) {\r\n\t\t\tif (this.clipAttachment != null)\r\n\t\t\t\treturn 0;\r\n\t\t\tthis.clipAttachment = clip;\r\n\t\t\tvar n = clip.worldVerticesLength;\r\n\t\t\tvar vertices = spine.Utils.setArraySize(this.clippingPolygon, n);\r\n\t\t\tclip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n\t\t\tvar clippingPolygon = this.clippingPolygon;\r\n\t\t\tSkeletonClipping.makeClockwise(clippingPolygon);\r\n\t\t\tvar clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\r\n\t\t\tfor (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {\r\n\t\t\t\tvar polygon = clippingPolygons[i];\r\n\t\t\t\tSkeletonClipping.makeClockwise(polygon);\r\n\t\t\t\tpolygon.push(polygon[0]);\r\n\t\t\t\tpolygon.push(polygon[1]);\r\n\t\t\t}\r\n\t\t\treturn clippingPolygons.length;\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clipEndWithSlot = function (slot) {\r\n\t\t\tif (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)\r\n\t\t\t\tthis.clipEnd();\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clipEnd = function () {\r\n\t\t\tif (this.clipAttachment == null)\r\n\t\t\t\treturn;\r\n\t\t\tthis.clipAttachment = null;\r\n\t\t\tthis.clippingPolygons = null;\r\n\t\t\tthis.clippedVertices.length = 0;\r\n\t\t\tthis.clippedTriangles.length = 0;\r\n\t\t\tthis.clippingPolygon.length = 0;\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.isClipping = function () {\r\n\t\t\treturn this.clipAttachment != null;\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\r\n\t\t\tvar clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\r\n\t\t\tvar clippedTriangles = this.clippedTriangles;\r\n\t\t\tvar polygons = this.clippingPolygons;\r\n\t\t\tvar polygonsCount = this.clippingPolygons.length;\r\n\t\t\tvar vertexSize = twoColor ? 12 : 8;\r\n\t\t\tvar index = 0;\r\n\t\t\tclippedVertices.length = 0;\r\n\t\t\tclippedTriangles.length = 0;\r\n\t\t\touter: for (var i = 0; i < trianglesLength; i += 3) {\r\n\t\t\t\tvar vertexOffset = triangles[i] << 1;\r\n\t\t\t\tvar x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\r\n\t\t\t\tvar u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\r\n\t\t\t\tvertexOffset = triangles[i + 1] << 1;\r\n\t\t\t\tvar x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\r\n\t\t\t\tvar u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\r\n\t\t\t\tvertexOffset = triangles[i + 2] << 1;\r\n\t\t\t\tvar x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\r\n\t\t\t\tvar u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\r\n\t\t\t\tfor (var p = 0; p < polygonsCount; p++) {\r\n\t\t\t\t\tvar s = clippedVertices.length;\r\n\t\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\r\n\t\t\t\t\t\tvar clipOutputLength = clipOutput.length;\r\n\t\t\t\t\t\tif (clipOutputLength == 0)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tvar d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\r\n\t\t\t\t\t\tvar d = 1 / (d0 * d2 + d1 * (y1 - y3));\r\n\t\t\t\t\t\tvar clipOutputCount = clipOutputLength >> 1;\r\n\t\t\t\t\t\tvar clipOutputItems = this.clipOutput;\r\n\t\t\t\t\t\tvar clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < clipOutputLength; ii += 2) {\r\n\t\t\t\t\t\t\tvar x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\r\n\t\t\t\t\t\t\tclippedVerticesItems[s] = x;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\r\n\t\t\t\t\t\t\tvar c0 = x - x3, c1 = y - y3;\r\n\t\t\t\t\t\t\tvar a = (d0 * c0 + d1 * c1) * d;\r\n\t\t\t\t\t\t\tvar b = (d4 * c0 + d2 * c1) * d;\r\n\t\t\t\t\t\t\tvar c = 1 - a - b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\r\n\t\t\t\t\t\t\tif (twoColor) {\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ts += vertexSize;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ts = clippedTriangles.length;\r\n\t\t\t\t\t\tvar clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\r\n\t\t\t\t\t\tclipOutputCount--;\r\n\t\t\t\t\t\tfor (var ii = 1; ii < clipOutputCount; ii++) {\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s] = index;\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\r\n\t\t\t\t\t\t\ts += 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tindex += clipOutputCount + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\r\n\t\t\t\t\t\tclippedVerticesItems[s] = x1;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\r\n\t\t\t\t\t\tif (!twoColor) {\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = x2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = y2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = u2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = v2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = x3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = y3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = u3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = v3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = x2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = y2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = u2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = v2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = dark.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 24] = x3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 25] = y3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 26] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 27] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 28] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 29] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 30] = u3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 31] = v3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 32] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 33] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 34] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 35] = dark.a;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ts = clippedTriangles.length;\r\n\t\t\t\t\t\tvar clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3);\r\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\r\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\r\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\r\n\t\t\t\t\t\tindex += 3;\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\r\n\t\t\tvar originalOutput = output;\r\n\t\t\tvar clipped = false;\r\n\t\t\tvar input = null;\r\n\t\t\tif (clippingArea.length % 4 >= 2) {\r\n\t\t\t\tinput = output;\r\n\t\t\t\toutput = this.scratch;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tinput = this.scratch;\r\n\t\t\tinput.length = 0;\r\n\t\t\tinput.push(x1);\r\n\t\t\tinput.push(y1);\r\n\t\t\tinput.push(x2);\r\n\t\t\tinput.push(y2);\r\n\t\t\tinput.push(x3);\r\n\t\t\tinput.push(y3);\r\n\t\t\tinput.push(x1);\r\n\t\t\tinput.push(y1);\r\n\t\t\toutput.length = 0;\r\n\t\t\tvar clippingVertices = clippingArea;\r\n\t\t\tvar clippingVerticesLast = clippingArea.length - 4;\r\n\t\t\tfor (var i = 0;; i += 2) {\r\n\t\t\t\tvar edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\r\n\t\t\t\tvar edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\r\n\t\t\t\tvar deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\r\n\t\t\t\tvar inputVertices = input;\r\n\t\t\t\tvar inputVerticesLength = input.length - 2, outputStart = output.length;\r\n\t\t\t\tfor (var ii = 0; ii < inputVerticesLength; ii += 2) {\r\n\t\t\t\t\tvar inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\r\n\t\t\t\t\tvar inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\r\n\t\t\t\t\tvar side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\r\n\t\t\t\t\tif (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\r\n\t\t\t\t\t\tif (side2) {\r\n\t\t\t\t\t\t\toutput.push(inputX2);\r\n\t\t\t\t\t\t\toutput.push(inputY2);\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n\t\t\t\t\t\tvar ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\r\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\r\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (side2) {\r\n\t\t\t\t\t\tvar c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n\t\t\t\t\t\tvar ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\r\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\r\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\r\n\t\t\t\t\t\toutput.push(inputX2);\r\n\t\t\t\t\t\toutput.push(inputY2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclipped = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (outputStart == output.length) {\r\n\t\t\t\t\toriginalOutput.length = 0;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\toutput.push(output[0]);\r\n\t\t\t\toutput.push(output[1]);\r\n\t\t\t\tif (i == clippingVerticesLast)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tvar temp = output;\r\n\t\t\t\toutput = input;\r\n\t\t\t\toutput.length = 0;\r\n\t\t\t\tinput = temp;\r\n\t\t\t}\r\n\t\t\tif (originalOutput != output) {\r\n\t\t\t\toriginalOutput.length = 0;\r\n\t\t\t\tfor (var i = 0, n = output.length - 2; i < n; i++)\r\n\t\t\t\t\toriginalOutput[i] = output[i];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\toriginalOutput.length = originalOutput.length - 2;\r\n\t\t\treturn clipped;\r\n\t\t};\r\n\t\tSkeletonClipping.makeClockwise = function (polygon) {\r\n\t\t\tvar vertices = polygon;\r\n\t\t\tvar verticeslength = polygon.length;\r\n\t\t\tvar area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\r\n\t\t\tfor (var i = 0, n = verticeslength - 3; i < n; i += 2) {\r\n\t\t\t\tp1x = vertices[i];\r\n\t\t\t\tp1y = vertices[i + 1];\r\n\t\t\t\tp2x = vertices[i + 2];\r\n\t\t\t\tp2y = vertices[i + 3];\r\n\t\t\t\tarea += p1x * p2y - p2x * p1y;\r\n\t\t\t}\r\n\t\t\tif (area < 0)\r\n\t\t\t\treturn;\r\n\t\t\tfor (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\r\n\t\t\t\tvar x = vertices[i], y = vertices[i + 1];\r\n\t\t\t\tvar other = lastX - i;\r\n\t\t\t\tvertices[i] = vertices[other];\r\n\t\t\t\tvertices[i + 1] = vertices[other + 1];\r\n\t\t\t\tvertices[other] = x;\r\n\t\t\t\tvertices[other + 1] = y;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn SkeletonClipping;\r\n\t}());\r\n\tspine.SkeletonClipping = SkeletonClipping;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonData = (function () {\r\n\t\tfunction SkeletonData() {\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.slots = new Array();\r\n\t\t\tthis.skins = new Array();\r\n\t\t\tthis.events = new Array();\r\n\t\t\tthis.animations = new Array();\r\n\t\t\tthis.ikConstraints = new Array();\r\n\t\t\tthis.transformConstraints = new Array();\r\n\t\t\tthis.pathConstraints = new Array();\r\n\t\t\tthis.fps = 0;\r\n\t\t}\r\n\t\tSkeletonData.prototype.findBone = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (bone.name == boneName)\r\n\t\t\t\t\treturn bone;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findBoneIndex = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tif (bones[i].name == boneName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findSlot = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tif (slot.name == slotName)\r\n\t\t\t\t\treturn slot;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findSlotIndex = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\r\n\t\t\t\tif (slots[i].name == slotName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findSkin = function (skinName) {\r\n\t\t\tif (skinName == null)\r\n\t\t\t\tthrow new Error(\"skinName cannot be null.\");\r\n\t\t\tvar skins = this.skins;\r\n\t\t\tfor (var i = 0, n = skins.length; i < n; i++) {\r\n\t\t\t\tvar skin = skins[i];\r\n\t\t\t\tif (skin.name == skinName)\r\n\t\t\t\t\treturn skin;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findEvent = function (eventDataName) {\r\n\t\t\tif (eventDataName == null)\r\n\t\t\t\tthrow new Error(\"eventDataName cannot be null.\");\r\n\t\t\tvar events = this.events;\r\n\t\t\tfor (var i = 0, n = events.length; i < n; i++) {\r\n\t\t\t\tvar event_4 = events[i];\r\n\t\t\t\tif (event_4.name == eventDataName)\r\n\t\t\t\t\treturn event_4;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findAnimation = function (animationName) {\r\n\t\t\tif (animationName == null)\r\n\t\t\t\tthrow new Error(\"animationName cannot be null.\");\r\n\t\t\tvar animations = this.animations;\r\n\t\t\tfor (var i = 0, n = animations.length; i < n; i++) {\r\n\t\t\t\tvar animation = animations[i];\r\n\t\t\t\tif (animation.name == animationName)\r\n\t\t\t\t\treturn animation;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findIkConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = ikConstraints[i];\r\n\t\t\t\tif (constraint.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findTransformConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = transformConstraints[i];\r\n\t\t\t\tif (constraint.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findPathConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = pathConstraints[i];\r\n\t\t\t\tif (constraint.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\r\n\t\t\tif (pathConstraintName == null)\r\n\t\t\t\tthrow new Error(\"pathConstraintName cannot be null.\");\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++)\r\n\t\t\t\tif (pathConstraints[i].name == pathConstraintName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\treturn SkeletonData;\r\n\t}());\r\n\tspine.SkeletonData = SkeletonData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonJson = (function () {\r\n\t\tfunction SkeletonJson(attachmentLoader) {\r\n\t\t\tthis.scale = 1;\r\n\t\t\tthis.linkedMeshes = new Array();\r\n\t\t\tthis.attachmentLoader = attachmentLoader;\r\n\t\t}\r\n\t\tSkeletonJson.prototype.readSkeletonData = function (json) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tvar skeletonData = new spine.SkeletonData();\r\n\t\t\tvar root = typeof (json) === \"string\" ? JSON.parse(json) : json;\r\n\t\t\tvar skeletonMap = root.skeleton;\r\n\t\t\tif (skeletonMap != null) {\r\n\t\t\t\tskeletonData.hash = skeletonMap.hash;\r\n\t\t\t\tskeletonData.version = skeletonMap.spine;\r\n\t\t\t\tskeletonData.width = skeletonMap.width;\r\n\t\t\t\tskeletonData.height = skeletonMap.height;\r\n\t\t\t\tskeletonData.fps = skeletonMap.fps;\r\n\t\t\t\tskeletonData.imagesPath = skeletonMap.images;\r\n\t\t\t}\r\n\t\t\tif (root.bones) {\r\n\t\t\t\tfor (var i = 0; i < root.bones.length; i++) {\r\n\t\t\t\t\tvar boneMap = root.bones[i];\r\n\t\t\t\t\tvar parent_2 = null;\r\n\t\t\t\t\tvar parentName = this.getValue(boneMap, \"parent\", null);\r\n\t\t\t\t\tif (parentName != null) {\r\n\t\t\t\t\t\tparent_2 = skeletonData.findBone(parentName);\r\n\t\t\t\t\t\tif (parent_2 == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Parent bone not found: \" + parentName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_2);\r\n\t\t\t\t\tdata.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n\t\t\t\t\tdata.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n\t\t\t\t\tdata.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n\t\t\t\t\tdata.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n\t\t\t\t\tdata.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n\t\t\t\t\tdata.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n\t\t\t\t\tdata.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n\t\t\t\t\tdata.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n\t\t\t\t\tdata.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\r\n\t\t\t\t\tskeletonData.bones.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.slots) {\r\n\t\t\t\tfor (var i = 0; i < root.slots.length; i++) {\r\n\t\t\t\t\tvar slotMap = root.slots[i];\r\n\t\t\t\t\tvar slotName = slotMap.name;\r\n\t\t\t\t\tvar boneName = slotMap.bone;\r\n\t\t\t\t\tvar boneData = skeletonData.findBone(boneName);\r\n\t\t\t\t\tif (boneData == null)\r\n\t\t\t\t\t\tthrow new Error(\"Slot bone not found: \" + boneName);\r\n\t\t\t\t\tvar data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);\r\n\t\t\t\t\tvar color = this.getValue(slotMap, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tdata.color.setFromString(color);\r\n\t\t\t\t\tvar dark = this.getValue(slotMap, \"dark\", null);\r\n\t\t\t\t\tif (dark != null) {\r\n\t\t\t\t\t\tdata.darkColor = new spine.Color(1, 1, 1, 1);\r\n\t\t\t\t\t\tdata.darkColor.setFromString(dark);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdata.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n\t\t\t\t\tdata.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n\t\t\t\t\tskeletonData.slots.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.ik) {\r\n\t\t\t\tfor (var i = 0; i < root.ik.length; i++) {\r\n\t\t\t\t\tvar constraintMap = root.ik[i];\r\n\t\t\t\t\tvar data = new spine.IkConstraintData(constraintMap.name);\r\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\r\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\t\tif (bone == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"IK bone not found: \" + boneName);\r\n\t\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar targetName = constraintMap.target;\r\n\t\t\t\t\tdata.target = skeletonData.findBone(targetName);\r\n\t\t\t\t\tif (data.target == null)\r\n\t\t\t\t\t\tthrow new Error(\"IK target bone not found: \" + targetName);\r\n\t\t\t\t\tdata.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n\t\t\t\t\tdata.mix = this.getValue(constraintMap, \"mix\", 1);\r\n\t\t\t\t\tskeletonData.ikConstraints.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.transform) {\r\n\t\t\t\tfor (var i = 0; i < root.transform.length; i++) {\r\n\t\t\t\t\tvar constraintMap = root.transform[i];\r\n\t\t\t\t\tvar data = new spine.TransformConstraintData(constraintMap.name);\r\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\r\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\t\tif (bone == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Transform constraint bone not found: \" + boneName);\r\n\t\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar targetName = constraintMap.target;\r\n\t\t\t\t\tdata.target = skeletonData.findBone(targetName);\r\n\t\t\t\t\tif (data.target == null)\r\n\t\t\t\t\t\tthrow new Error(\"Transform constraint target bone not found: \" + targetName);\r\n\t\t\t\t\tdata.local = this.getValue(constraintMap, \"local\", false);\r\n\t\t\t\t\tdata.relative = this.getValue(constraintMap, \"relative\", false);\r\n\t\t\t\t\tdata.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n\t\t\t\t\tdata.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n\t\t\t\t\tdata.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n\t\t\t\t\tdata.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n\t\t\t\t\tdata.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n\t\t\t\t\tdata.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n\t\t\t\t\tdata.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n\t\t\t\t\tdata.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\t\t\t\t\tdata.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n\t\t\t\t\tdata.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n\t\t\t\t\tskeletonData.transformConstraints.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.path) {\r\n\t\t\t\tfor (var i = 0; i < root.path.length; i++) {\r\n\t\t\t\t\tvar constraintMap = root.path[i];\r\n\t\t\t\t\tvar data = new spine.PathConstraintData(constraintMap.name);\r\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\r\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\t\tif (bone == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Transform constraint bone not found: \" + boneName);\r\n\t\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar targetName = constraintMap.target;\r\n\t\t\t\t\tdata.target = skeletonData.findSlot(targetName);\r\n\t\t\t\t\tif (data.target == null)\r\n\t\t\t\t\t\tthrow new Error(\"Path target slot not found: \" + targetName);\r\n\t\t\t\t\tdata.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n\t\t\t\t\tdata.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n\t\t\t\t\tdata.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n\t\t\t\t\tdata.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n\t\t\t\t\tdata.position = this.getValue(constraintMap, \"position\", 0);\r\n\t\t\t\t\tif (data.positionMode == spine.PositionMode.Fixed)\r\n\t\t\t\t\t\tdata.position *= scale;\r\n\t\t\t\t\tdata.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n\t\t\t\t\tif (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\r\n\t\t\t\t\t\tdata.spacing *= scale;\r\n\t\t\t\t\tdata.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n\t\t\t\t\tdata.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\t\t\t\t\tskeletonData.pathConstraints.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.skins) {\r\n\t\t\t\tfor (var skinName in root.skins) {\r\n\t\t\t\t\tvar skinMap = root.skins[skinName];\r\n\t\t\t\t\tvar skin = new spine.Skin(skinName);\r\n\t\t\t\t\tfor (var slotName in skinMap) {\r\n\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotName);\r\n\t\t\t\t\t\tvar slotMap = skinMap[slotName];\r\n\t\t\t\t\t\tfor (var entryName in slotMap) {\r\n\t\t\t\t\t\t\tvar attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\r\n\t\t\t\t\t\t\tif (attachment != null)\r\n\t\t\t\t\t\t\t\tskin.addAttachment(slotIndex, entryName, attachment);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tskeletonData.skins.push(skin);\r\n\t\t\t\t\tif (skin.name == \"default\")\r\n\t\t\t\t\t\tskeletonData.defaultSkin = skin;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n\t\t\t\tvar linkedMesh = this.linkedMeshes[i];\r\n\t\t\t\tvar skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\t\t\t\tif (skin == null)\r\n\t\t\t\t\tthrow new Error(\"Skin not found: \" + linkedMesh.skin);\r\n\t\t\t\tvar parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\t\t\t\tif (parent_3 == null)\r\n\t\t\t\t\tthrow new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n\t\t\t\tlinkedMesh.mesh.setParentMesh(parent_3);\r\n\t\t\t\tlinkedMesh.mesh.updateUVs();\r\n\t\t\t}\r\n\t\t\tthis.linkedMeshes.length = 0;\r\n\t\t\tif (root.events) {\r\n\t\t\t\tfor (var eventName in root.events) {\r\n\t\t\t\t\tvar eventMap = root.events[eventName];\r\n\t\t\t\t\tvar data = new spine.EventData(eventName);\r\n\t\t\t\t\tdata.intValue = this.getValue(eventMap, \"int\", 0);\r\n\t\t\t\t\tdata.floatValue = this.getValue(eventMap, \"float\", 0);\r\n\t\t\t\t\tdata.stringValue = this.getValue(eventMap, \"string\", \"\");\r\n\t\t\t\t\tskeletonData.events.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.animations) {\r\n\t\t\t\tfor (var animationName in root.animations) {\r\n\t\t\t\t\tvar animationMap = root.animations[animationName];\r\n\t\t\t\t\tthis.readAnimation(animationMap, animationName, skeletonData);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn skeletonData;\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tname = this.getValue(map, \"name\", name);\r\n\t\t\tvar type = this.getValue(map, \"type\", \"region\");\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase \"region\": {\r\n\t\t\t\t\tvar path = this.getValue(map, \"path\", name);\r\n\t\t\t\t\tvar region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n\t\t\t\t\tif (region == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tregion.path = path;\r\n\t\t\t\t\tregion.x = this.getValue(map, \"x\", 0) * scale;\r\n\t\t\t\t\tregion.y = this.getValue(map, \"y\", 0) * scale;\r\n\t\t\t\t\tregion.scaleX = this.getValue(map, \"scaleX\", 1);\r\n\t\t\t\t\tregion.scaleY = this.getValue(map, \"scaleY\", 1);\r\n\t\t\t\t\tregion.rotation = this.getValue(map, \"rotation\", 0);\r\n\t\t\t\t\tregion.width = map.width * scale;\r\n\t\t\t\t\tregion.height = map.height * scale;\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tregion.color.setFromString(color);\r\n\t\t\t\t\tregion.updateOffset();\r\n\t\t\t\t\treturn region;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"boundingbox\": {\r\n\t\t\t\t\tvar box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\t\t\t\t\tif (box == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tthis.readVertices(map, box, map.vertexCount << 1);\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tbox.color.setFromString(color);\r\n\t\t\t\t\treturn box;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"mesh\":\r\n\t\t\t\tcase \"linkedmesh\": {\r\n\t\t\t\t\tvar path = this.getValue(map, \"path\", name);\r\n\t\t\t\t\tvar mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\t\t\t\t\tif (mesh == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tmesh.path = path;\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tmesh.color.setFromString(color);\r\n\t\t\t\t\tvar parent_4 = this.getValue(map, \"parent\", null);\r\n\t\t\t\t\tif (parent_4 != null) {\r\n\t\t\t\t\t\tmesh.inheritDeform = this.getValue(map, \"deform\", true);\r\n\t\t\t\t\t\tthis.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_4));\r\n\t\t\t\t\t\treturn mesh;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar uvs = map.uvs;\r\n\t\t\t\t\tthis.readVertices(map, mesh, uvs.length);\r\n\t\t\t\t\tmesh.triangles = map.triangles;\r\n\t\t\t\t\tmesh.regionUVs = uvs;\r\n\t\t\t\t\tmesh.updateUVs();\r\n\t\t\t\t\tmesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n\t\t\t\t\treturn mesh;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"path\": {\r\n\t\t\t\t\tvar path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\t\t\t\t\tif (path == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tpath.closed = this.getValue(map, \"closed\", false);\r\n\t\t\t\t\tpath.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n\t\t\t\t\tvar vertexCount = map.vertexCount;\r\n\t\t\t\t\tthis.readVertices(map, path, vertexCount << 1);\r\n\t\t\t\t\tvar lengths = spine.Utils.newArray(vertexCount / 3, 0);\r\n\t\t\t\t\tfor (var i = 0; i < map.lengths.length; i++)\r\n\t\t\t\t\t\tlengths[i] = map.lengths[i] * scale;\r\n\t\t\t\t\tpath.lengths = lengths;\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tpath.color.setFromString(color);\r\n\t\t\t\t\treturn path;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"point\": {\r\n\t\t\t\t\tvar point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\t\t\t\t\tif (point == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tpoint.x = this.getValue(map, \"x\", 0) * scale;\r\n\t\t\t\t\tpoint.y = this.getValue(map, \"y\", 0) * scale;\r\n\t\t\t\t\tpoint.rotation = this.getValue(map, \"rotation\", 0);\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tpoint.color.setFromString(color);\r\n\t\t\t\t\treturn point;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"clipping\": {\r\n\t\t\t\t\tvar clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\t\t\t\t\tif (clip == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tvar end = this.getValue(map, \"end\", null);\r\n\t\t\t\t\tif (end != null) {\r\n\t\t\t\t\t\tvar slot = skeletonData.findSlot(end);\r\n\t\t\t\t\t\tif (slot == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Clipping end slot not found: \" + end);\r\n\t\t\t\t\t\tclip.endSlot = slot;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar vertexCount = map.vertexCount;\r\n\t\t\t\t\tthis.readVertices(map, clip, vertexCount << 1);\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tclip.color.setFromString(color);\r\n\t\t\t\t\treturn clip;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tattachment.worldVerticesLength = verticesLength;\r\n\t\t\tvar vertices = map.vertices;\r\n\t\t\tif (verticesLength == vertices.length) {\r\n\t\t\t\tvar scaledVertices = spine.Utils.toFloatArray(vertices);\r\n\t\t\t\tif (scale != 1) {\r\n\t\t\t\t\tfor (var i = 0, n = vertices.length; i < n; i++)\r\n\t\t\t\t\t\tscaledVertices[i] *= scale;\r\n\t\t\t\t}\r\n\t\t\t\tattachment.vertices = scaledVertices;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar weights = new Array();\r\n\t\t\tvar bones = new Array();\r\n\t\t\tfor (var i = 0, n = vertices.length; i < n;) {\r\n\t\t\t\tvar boneCount = vertices[i++];\r\n\t\t\t\tbones.push(boneCount);\r\n\t\t\t\tfor (var nn = i + boneCount * 4; i < nn; i += 4) {\r\n\t\t\t\t\tbones.push(vertices[i]);\r\n\t\t\t\t\tweights.push(vertices[i + 1] * scale);\r\n\t\t\t\t\tweights.push(vertices[i + 2] * scale);\r\n\t\t\t\t\tweights.push(vertices[i + 3]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tattachment.bones = bones;\r\n\t\t\tattachment.vertices = spine.Utils.toFloatArray(weights);\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tvar timelines = new Array();\r\n\t\t\tvar duration = 0;\r\n\t\t\tif (map.slots) {\r\n\t\t\t\tfor (var slotName in map.slots) {\r\n\t\t\t\t\tvar slotMap = map.slots[slotName];\r\n\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotName);\r\n\t\t\t\t\tfor (var timelineName in slotMap) {\r\n\t\t\t\t\t\tvar timelineMap = slotMap[timelineName];\r\n\t\t\t\t\t\tif (timelineName == \"attachment\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.AttachmentTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName == \"color\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.ColorTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\tvar color = new spine.Color();\r\n\t\t\t\t\t\t\t\tcolor.setFromString(valueMap.color);\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName == \"twoColor\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.TwoColorTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\tvar light = new spine.Color();\r\n\t\t\t\t\t\t\t\tvar dark = new spine.Color();\r\n\t\t\t\t\t\t\t\tlight.setFromString(valueMap.light);\r\n\t\t\t\t\t\t\t\tdark.setFromString(valueMap.dark);\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TwoColorTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tthrow new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.bones) {\r\n\t\t\t\tfor (var boneName in map.bones) {\r\n\t\t\t\t\tvar boneMap = map.bones[boneName];\r\n\t\t\t\t\tvar boneIndex = skeletonData.findBoneIndex(boneName);\r\n\t\t\t\t\tif (boneIndex == -1)\r\n\t\t\t\t\t\tthrow new Error(\"Bone not found: \" + boneName);\r\n\t\t\t\t\tfor (var timelineName in boneMap) {\r\n\t\t\t\t\t\tvar timelineMap = boneMap[timelineName];\r\n\t\t\t\t\t\tif (timelineName === \"rotate\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.RotateTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n\t\t\t\t\t\t\tvar timeline = null;\r\n\t\t\t\t\t\t\tvar timelineScale = 1;\r\n\t\t\t\t\t\t\tif (timelineName === \"scale\")\r\n\t\t\t\t\t\t\t\ttimeline = new spine.ScaleTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\telse if (timelineName === \"shear\")\r\n\t\t\t\t\t\t\t\ttimeline = new spine.ShearTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\ttimeline = new spine.TranslateTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\tvar x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tthrow new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.ik) {\r\n\t\t\t\tfor (var constraintName in map.ik) {\r\n\t\t\t\t\tvar constraintMap = map.ik[constraintName];\r\n\t\t\t\t\tvar constraint = skeletonData.findIkConstraint(constraintName);\r\n\t\t\t\t\tvar timeline = new spine.IkConstraintTimeline(constraintMap.length);\r\n\t\t\t\t\ttimeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\tfor (var i = 0; i < constraintMap.length; i++) {\r\n\t\t\t\t\t\tvar valueMap = constraintMap[i];\r\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1);\r\n\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.transform) {\r\n\t\t\t\tfor (var constraintName in map.transform) {\r\n\t\t\t\t\tvar constraintMap = map.transform[constraintName];\r\n\t\t\t\t\tvar constraint = skeletonData.findTransformConstraint(constraintName);\r\n\t\t\t\t\tvar timeline = new spine.TransformConstraintTimeline(constraintMap.length);\r\n\t\t\t\t\ttimeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\tfor (var i = 0; i < constraintMap.length; i++) {\r\n\t\t\t\t\t\tvar valueMap = constraintMap[i];\r\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.paths) {\r\n\t\t\t\tfor (var constraintName in map.paths) {\r\n\t\t\t\t\tvar constraintMap = map.paths[constraintName];\r\n\t\t\t\t\tvar index = skeletonData.findPathConstraintIndex(constraintName);\r\n\t\t\t\t\tif (index == -1)\r\n\t\t\t\t\t\tthrow new Error(\"Path constraint not found: \" + constraintName);\r\n\t\t\t\t\tvar data = skeletonData.pathConstraints[index];\r\n\t\t\t\t\tfor (var timelineName in constraintMap) {\r\n\t\t\t\t\t\tvar timelineMap = constraintMap[timelineName];\r\n\t\t\t\t\t\tif (timelineName === \"position\" || timelineName === \"spacing\") {\r\n\t\t\t\t\t\t\tvar timeline = null;\r\n\t\t\t\t\t\t\tvar timelineScale = 1;\r\n\t\t\t\t\t\t\tif (timelineName === \"spacing\") {\r\n\t\t\t\t\t\t\t\ttimeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\t\tif (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\r\n\t\t\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\ttimeline = new spine.PathConstraintPositionTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\t\tif (data.positionMode == spine.PositionMode.Fixed)\r\n\t\t\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName === \"mix\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.PathConstraintMixTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.deform) {\r\n\t\t\t\tfor (var deformName in map.deform) {\r\n\t\t\t\t\tvar deformMap = map.deform[deformName];\r\n\t\t\t\t\tvar skin = skeletonData.findSkin(deformName);\r\n\t\t\t\t\tif (skin == null)\r\n\t\t\t\t\t\tthrow new Error(\"Skin not found: \" + deformName);\r\n\t\t\t\t\tfor (var slotName in deformMap) {\r\n\t\t\t\t\t\tvar slotMap = deformMap[slotName];\r\n\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotMap.name);\r\n\t\t\t\t\t\tfor (var timelineName in slotMap) {\r\n\t\t\t\t\t\t\tvar timelineMap = slotMap[timelineName];\r\n\t\t\t\t\t\t\tvar attachment = skin.getAttachment(slotIndex, timelineName);\r\n\t\t\t\t\t\t\tif (attachment == null)\r\n\t\t\t\t\t\t\t\tthrow new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n\t\t\t\t\t\t\tvar weighted = attachment.bones != null;\r\n\t\t\t\t\t\t\tvar vertices = attachment.vertices;\r\n\t\t\t\t\t\t\tvar deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\t\t\t\t\t\t\tvar timeline = new spine.DeformTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\ttimeline.attachment = attachment;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var j = 0; j < timelineMap.length; j++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[j];\r\n\t\t\t\t\t\t\t\tvar deform = void 0;\r\n\t\t\t\t\t\t\t\tvar verticesValue = this.getValue(valueMap, \"vertices\", null);\r\n\t\t\t\t\t\t\t\tif (verticesValue == null)\r\n\t\t\t\t\t\t\t\t\tdeform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tdeform = spine.Utils.newFloatArray(deformLength);\r\n\t\t\t\t\t\t\t\t\tvar start = this.getValue(valueMap, \"offset\", 0);\r\n\t\t\t\t\t\t\t\t\tspine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n\t\t\t\t\t\t\t\t\tif (scale != 1) {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = start, n = i + verticesValue.length; i < n; i++)\r\n\t\t\t\t\t\t\t\t\t\t\tdeform[i] *= scale;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!weighted) {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < deformLength; i++)\r\n\t\t\t\t\t\t\t\t\t\t\tdeform[i] += vertices[i];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, deform);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar drawOrderNode = map.drawOrder;\r\n\t\t\tif (drawOrderNode == null)\r\n\t\t\t\tdrawOrderNode = map.draworder;\r\n\t\t\tif (drawOrderNode != null) {\r\n\t\t\t\tvar timeline = new spine.DrawOrderTimeline(drawOrderNode.length);\r\n\t\t\t\tvar slotCount = skeletonData.slots.length;\r\n\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\tfor (var j = 0; j < drawOrderNode.length; j++) {\r\n\t\t\t\t\tvar drawOrderMap = drawOrderNode[j];\r\n\t\t\t\t\tvar drawOrder = null;\r\n\t\t\t\t\tvar offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n\t\t\t\t\tif (offsets != null) {\r\n\t\t\t\t\t\tdrawOrder = spine.Utils.newArray(slotCount, -1);\r\n\t\t\t\t\t\tvar unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);\r\n\t\t\t\t\t\tvar originalIndex = 0, unchangedIndex = 0;\r\n\t\t\t\t\t\tfor (var i = 0; i < offsets.length; i++) {\r\n\t\t\t\t\t\t\tvar offsetMap = offsets[i];\r\n\t\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n\t\t\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + offsetMap.slot);\r\n\t\t\t\t\t\t\twhile (originalIndex != slotIndex)\r\n\t\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\r\n\t\t\t\t\t\t\tdrawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile (originalIndex < slotCount)\r\n\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\r\n\t\t\t\t\t\tfor (var i = slotCount - 1; i >= 0; i--)\r\n\t\t\t\t\t\t\tif (drawOrder[i] == -1)\r\n\t\t\t\t\t\t\t\tdrawOrder[i] = unchanged[--unchangedIndex];\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t}\r\n\t\t\tif (map.events) {\r\n\t\t\t\tvar timeline = new spine.EventTimeline(map.events.length);\r\n\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\tfor (var i = 0; i < map.events.length; i++) {\r\n\t\t\t\t\tvar eventMap = map.events[i];\r\n\t\t\t\t\tvar eventData = skeletonData.findEvent(eventMap.name);\r\n\t\t\t\t\tif (eventData == null)\r\n\t\t\t\t\t\tthrow new Error(\"Event not found: \" + eventMap.name);\r\n\t\t\t\t\tvar event_5 = new spine.Event(spine.Utils.toSinglePrecision(eventMap.time), eventData);\r\n\t\t\t\t\tevent_5.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n\t\t\t\t\tevent_5.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n\t\t\t\t\tevent_5.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n\t\t\t\t\ttimeline.setFrame(frameIndex++, event_5);\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t}\r\n\t\t\tif (isNaN(duration)) {\r\n\t\t\t\tthrow new Error(\"Error while parsing animation, duration is NaN\");\r\n\t\t\t}\r\n\t\t\tskeletonData.animations.push(new spine.Animation(name, timelines, duration));\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\r\n\t\t\tif (!map.curve)\r\n\t\t\t\treturn;\r\n\t\t\tif (map.curve === \"stepped\")\r\n\t\t\t\ttimeline.setStepped(frameIndex);\r\n\t\t\telse if (Object.prototype.toString.call(map.curve) === '[object Array]') {\r\n\t\t\t\tvar curve = map.curve;\r\n\t\t\t\ttimeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\r\n\t\t\treturn map[prop] !== undefined ? map[prop] : defaultValue;\r\n\t\t};\r\n\t\tSkeletonJson.blendModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"normal\")\r\n\t\t\t\treturn spine.BlendMode.Normal;\r\n\t\t\tif (str == \"additive\")\r\n\t\t\t\treturn spine.BlendMode.Additive;\r\n\t\t\tif (str == \"multiply\")\r\n\t\t\t\treturn spine.BlendMode.Multiply;\r\n\t\t\tif (str == \"screen\")\r\n\t\t\t\treturn spine.BlendMode.Screen;\r\n\t\t\tthrow new Error(\"Unknown blend mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.positionModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"fixed\")\r\n\t\t\t\treturn spine.PositionMode.Fixed;\r\n\t\t\tif (str == \"percent\")\r\n\t\t\t\treturn spine.PositionMode.Percent;\r\n\t\t\tthrow new Error(\"Unknown position mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.spacingModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"length\")\r\n\t\t\t\treturn spine.SpacingMode.Length;\r\n\t\t\tif (str == \"fixed\")\r\n\t\t\t\treturn spine.SpacingMode.Fixed;\r\n\t\t\tif (str == \"percent\")\r\n\t\t\t\treturn spine.SpacingMode.Percent;\r\n\t\t\tthrow new Error(\"Unknown position mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.rotateModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"tangent\")\r\n\t\t\t\treturn spine.RotateMode.Tangent;\r\n\t\t\tif (str == \"chain\")\r\n\t\t\t\treturn spine.RotateMode.Chain;\r\n\t\t\tif (str == \"chainscale\")\r\n\t\t\t\treturn spine.RotateMode.ChainScale;\r\n\t\t\tthrow new Error(\"Unknown rotate mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.transformModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"normal\")\r\n\t\t\t\treturn spine.TransformMode.Normal;\r\n\t\t\tif (str == \"onlytranslation\")\r\n\t\t\t\treturn spine.TransformMode.OnlyTranslation;\r\n\t\t\tif (str == \"norotationorreflection\")\r\n\t\t\t\treturn spine.TransformMode.NoRotationOrReflection;\r\n\t\t\tif (str == \"noscale\")\r\n\t\t\t\treturn spine.TransformMode.NoScale;\r\n\t\t\tif (str == \"noscaleorreflection\")\r\n\t\t\t\treturn spine.TransformMode.NoScaleOrReflection;\r\n\t\t\tthrow new Error(\"Unknown transform mode: \" + str);\r\n\t\t};\r\n\t\treturn SkeletonJson;\r\n\t}());\r\n\tspine.SkeletonJson = SkeletonJson;\r\n\tvar LinkedMesh = (function () {\r\n\t\tfunction LinkedMesh(mesh, skin, slotIndex, parent) {\r\n\t\t\tthis.mesh = mesh;\r\n\t\t\tthis.skin = skin;\r\n\t\t\tthis.slotIndex = slotIndex;\r\n\t\t\tthis.parent = parent;\r\n\t\t}\r\n\t\treturn LinkedMesh;\r\n\t}());\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Skin = (function () {\r\n\t\tfunction Skin(name) {\r\n\t\t\tthis.attachments = new Array();\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\tSkin.prototype.addAttachment = function (slotIndex, name, attachment) {\r\n\t\t\tif (attachment == null)\r\n\t\t\t\tthrow new Error(\"attachment cannot be null.\");\r\n\t\t\tvar attachments = this.attachments;\r\n\t\t\tif (slotIndex >= attachments.length)\r\n\t\t\t\tattachments.length = slotIndex + 1;\r\n\t\t\tif (!attachments[slotIndex])\r\n\t\t\t\tattachments[slotIndex] = {};\r\n\t\t\tattachments[slotIndex][name] = attachment;\r\n\t\t};\r\n\t\tSkin.prototype.getAttachment = function (slotIndex, name) {\r\n\t\t\tvar dictionary = this.attachments[slotIndex];\r\n\t\t\treturn dictionary ? dictionary[name] : null;\r\n\t\t};\r\n\t\tSkin.prototype.attachAll = function (skeleton, oldSkin) {\r\n\t\t\tvar slotIndex = 0;\r\n\t\t\tfor (var i = 0; i < skeleton.slots.length; i++) {\r\n\t\t\t\tvar slot = skeleton.slots[i];\r\n\t\t\t\tvar slotAttachment = slot.getAttachment();\r\n\t\t\t\tif (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n\t\t\t\t\tvar dictionary = oldSkin.attachments[slotIndex];\r\n\t\t\t\t\tfor (var key in dictionary) {\r\n\t\t\t\t\t\tvar skinAttachment = dictionary[key];\r\n\t\t\t\t\t\tif (slotAttachment == skinAttachment) {\r\n\t\t\t\t\t\t\tvar attachment = this.getAttachment(slotIndex, key);\r\n\t\t\t\t\t\t\tif (attachment != null)\r\n\t\t\t\t\t\t\t\tslot.setAttachment(attachment);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tslotIndex++;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn Skin;\r\n\t}());\r\n\tspine.Skin = Skin;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Slot = (function () {\r\n\t\tfunction Slot(data, bone) {\r\n\t\t\tthis.attachmentVertices = new Array();\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (bone == null)\r\n\t\t\t\tthrow new Error(\"bone cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.bone = bone;\r\n\t\t\tthis.color = new spine.Color();\r\n\t\t\tthis.darkColor = data.darkColor == null ? null : new spine.Color();\r\n\t\t\tthis.setToSetupPose();\r\n\t\t}\r\n\t\tSlot.prototype.getAttachment = function () {\r\n\t\t\treturn this.attachment;\r\n\t\t};\r\n\t\tSlot.prototype.setAttachment = function (attachment) {\r\n\t\t\tif (this.attachment == attachment)\r\n\t\t\t\treturn;\r\n\t\t\tthis.attachment = attachment;\r\n\t\t\tthis.attachmentTime = this.bone.skeleton.time;\r\n\t\t\tthis.attachmentVertices.length = 0;\r\n\t\t};\r\n\t\tSlot.prototype.setAttachmentTime = function (time) {\r\n\t\t\tthis.attachmentTime = this.bone.skeleton.time - time;\r\n\t\t};\r\n\t\tSlot.prototype.getAttachmentTime = function () {\r\n\t\t\treturn this.bone.skeleton.time - this.attachmentTime;\r\n\t\t};\r\n\t\tSlot.prototype.setToSetupPose = function () {\r\n\t\t\tthis.color.setFromColor(this.data.color);\r\n\t\t\tif (this.darkColor != null)\r\n\t\t\t\tthis.darkColor.setFromColor(this.data.darkColor);\r\n\t\t\tif (this.data.attachmentName == null)\r\n\t\t\t\tthis.attachment = null;\r\n\t\t\telse {\r\n\t\t\t\tthis.attachment = null;\r\n\t\t\t\tthis.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn Slot;\r\n\t}());\r\n\tspine.Slot = Slot;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SlotData = (function () {\r\n\t\tfunction SlotData(index, name, boneData) {\r\n\t\t\tthis.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\tif (index < 0)\r\n\t\t\t\tthrow new Error(\"index must be >= 0.\");\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tif (boneData == null)\r\n\t\t\t\tthrow new Error(\"boneData cannot be null.\");\r\n\t\t\tthis.index = index;\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.boneData = boneData;\r\n\t\t}\r\n\t\treturn SlotData;\r\n\t}());\r\n\tspine.SlotData = SlotData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Texture = (function () {\r\n\t\tfunction Texture(image) {\r\n\t\t\tthis._image = image;\r\n\t\t}\r\n\t\tTexture.prototype.getImage = function () {\r\n\t\t\treturn this._image;\r\n\t\t};\r\n\t\tTexture.filterFromString = function (text) {\r\n\t\t\tswitch (text.toLowerCase()) {\r\n\t\t\t\tcase \"nearest\": return TextureFilter.Nearest;\r\n\t\t\t\tcase \"linear\": return TextureFilter.Linear;\r\n\t\t\t\tcase \"mipmap\": return TextureFilter.MipMap;\r\n\t\t\t\tcase \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n\t\t\t\tcase \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n\t\t\t\tcase \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n\t\t\t\tcase \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n\t\t\t\tdefault: throw new Error(\"Unknown texture filter \" + text);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTexture.wrapFromString = function (text) {\r\n\t\t\tswitch (text.toLowerCase()) {\r\n\t\t\t\tcase \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n\t\t\t\tcase \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n\t\t\t\tcase \"repeat\": return TextureWrap.Repeat;\r\n\t\t\t\tdefault: throw new Error(\"Unknown texture wrap \" + text);\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn Texture;\r\n\t}());\r\n\tspine.Texture = Texture;\r\n\tvar TextureFilter;\r\n\t(function (TextureFilter) {\r\n\t\tTextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\r\n\t\tTextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\r\n\t\tTextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\r\n\t})(TextureFilter = spine.TextureFilter || (spine.TextureFilter = {}));\r\n\tvar TextureWrap;\r\n\t(function (TextureWrap) {\r\n\t\tTextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\r\n\t\tTextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\r\n\t\tTextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\r\n\t})(TextureWrap = spine.TextureWrap || (spine.TextureWrap = {}));\r\n\tvar TextureRegion = (function () {\r\n\t\tfunction TextureRegion() {\r\n\t\t\tthis.u = 0;\r\n\t\t\tthis.v = 0;\r\n\t\t\tthis.u2 = 0;\r\n\t\t\tthis.v2 = 0;\r\n\t\t\tthis.width = 0;\r\n\t\t\tthis.height = 0;\r\n\t\t\tthis.rotate = false;\r\n\t\t\tthis.offsetX = 0;\r\n\t\t\tthis.offsetY = 0;\r\n\t\t\tthis.originalWidth = 0;\r\n\t\t\tthis.originalHeight = 0;\r\n\t\t}\r\n\t\treturn TextureRegion;\r\n\t}());\r\n\tspine.TextureRegion = TextureRegion;\r\n\tvar FakeTexture = (function (_super) {\r\n\t\t__extends(FakeTexture, _super);\r\n\t\tfunction FakeTexture() {\r\n\t\t\treturn _super !== null && _super.apply(this, arguments) || this;\r\n\t\t}\r\n\t\tFakeTexture.prototype.setFilters = function (minFilter, magFilter) { };\r\n\t\tFakeTexture.prototype.setWraps = function (uWrap, vWrap) { };\r\n\t\tFakeTexture.prototype.dispose = function () { };\r\n\t\treturn FakeTexture;\r\n\t}(spine.Texture));\r\n\tspine.FakeTexture = FakeTexture;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar TextureAtlas = (function () {\r\n\t\tfunction TextureAtlas(atlasText, textureLoader) {\r\n\t\t\tthis.pages = new Array();\r\n\t\t\tthis.regions = new Array();\r\n\t\t\tthis.load(atlasText, textureLoader);\r\n\t\t}\r\n\t\tTextureAtlas.prototype.load = function (atlasText, textureLoader) {\r\n\t\t\tif (textureLoader == null)\r\n\t\t\t\tthrow new Error(\"textureLoader cannot be null.\");\r\n\t\t\tvar reader = new TextureAtlasReader(atlasText);\r\n\t\t\tvar tuple = new Array(4);\r\n\t\t\tvar page = null;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar line = reader.readLine();\r\n\t\t\t\tif (line == null)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tline = line.trim();\r\n\t\t\t\tif (line.length == 0)\r\n\t\t\t\t\tpage = null;\r\n\t\t\t\telse if (!page) {\r\n\t\t\t\t\tpage = new TextureAtlasPage();\r\n\t\t\t\t\tpage.name = line;\r\n\t\t\t\t\tif (reader.readTuple(tuple) == 2) {\r\n\t\t\t\t\t\tpage.width = parseInt(tuple[0]);\r\n\t\t\t\t\t\tpage.height = parseInt(tuple[1]);\r\n\t\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tpage.minFilter = spine.Texture.filterFromString(tuple[0]);\r\n\t\t\t\t\tpage.magFilter = spine.Texture.filterFromString(tuple[1]);\r\n\t\t\t\t\tvar direction = reader.readValue();\r\n\t\t\t\t\tpage.uWrap = spine.TextureWrap.ClampToEdge;\r\n\t\t\t\t\tpage.vWrap = spine.TextureWrap.ClampToEdge;\r\n\t\t\t\t\tif (direction == \"x\")\r\n\t\t\t\t\t\tpage.uWrap = spine.TextureWrap.Repeat;\r\n\t\t\t\t\telse if (direction == \"y\")\r\n\t\t\t\t\t\tpage.vWrap = spine.TextureWrap.Repeat;\r\n\t\t\t\t\telse if (direction == \"xy\")\r\n\t\t\t\t\t\tpage.uWrap = page.vWrap = spine.TextureWrap.Repeat;\r\n\t\t\t\t\tpage.texture = textureLoader(line);\r\n\t\t\t\t\tpage.texture.setFilters(page.minFilter, page.magFilter);\r\n\t\t\t\t\tpage.texture.setWraps(page.uWrap, page.vWrap);\r\n\t\t\t\t\tpage.width = page.texture.getImage().width;\r\n\t\t\t\t\tpage.height = page.texture.getImage().height;\r\n\t\t\t\t\tthis.pages.push(page);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar region = new TextureAtlasRegion();\r\n\t\t\t\t\tregion.name = line;\r\n\t\t\t\t\tregion.page = page;\r\n\t\t\t\t\tregion.rotate = reader.readValue() == \"true\";\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tvar x = parseInt(tuple[0]);\r\n\t\t\t\t\tvar y = parseInt(tuple[1]);\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tvar width = parseInt(tuple[0]);\r\n\t\t\t\t\tvar height = parseInt(tuple[1]);\r\n\t\t\t\t\tregion.u = x / page.width;\r\n\t\t\t\t\tregion.v = y / page.height;\r\n\t\t\t\t\tif (region.rotate) {\r\n\t\t\t\t\t\tregion.u2 = (x + height) / page.width;\r\n\t\t\t\t\t\tregion.v2 = (y + width) / page.height;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tregion.u2 = (x + width) / page.width;\r\n\t\t\t\t\t\tregion.v2 = (y + height) / page.height;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregion.x = x;\r\n\t\t\t\t\tregion.y = y;\r\n\t\t\t\t\tregion.width = Math.abs(width);\r\n\t\t\t\t\tregion.height = Math.abs(height);\r\n\t\t\t\t\tif (reader.readTuple(tuple) == 4) {\r\n\t\t\t\t\t\tif (reader.readTuple(tuple) == 4) {\r\n\t\t\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregion.originalWidth = parseInt(tuple[0]);\r\n\t\t\t\t\tregion.originalHeight = parseInt(tuple[1]);\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tregion.offsetX = parseInt(tuple[0]);\r\n\t\t\t\t\tregion.offsetY = parseInt(tuple[1]);\r\n\t\t\t\t\tregion.index = parseInt(reader.readValue());\r\n\t\t\t\t\tregion.texture = page.texture;\r\n\t\t\t\t\tthis.regions.push(region);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tTextureAtlas.prototype.findRegion = function (name) {\r\n\t\t\tfor (var i = 0; i < this.regions.length; i++) {\r\n\t\t\t\tif (this.regions[i].name == name) {\r\n\t\t\t\t\treturn this.regions[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tTextureAtlas.prototype.dispose = function () {\r\n\t\t\tfor (var i = 0; i < this.pages.length; i++) {\r\n\t\t\t\tthis.pages[i].texture.dispose();\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn TextureAtlas;\r\n\t}());\r\n\tspine.TextureAtlas = TextureAtlas;\r\n\tvar TextureAtlasReader = (function () {\r\n\t\tfunction TextureAtlasReader(text) {\r\n\t\t\tthis.index = 0;\r\n\t\t\tthis.lines = text.split(/\\r\\n|\\r|\\n/);\r\n\t\t}\r\n\t\tTextureAtlasReader.prototype.readLine = function () {\r\n\t\t\tif (this.index >= this.lines.length)\r\n\t\t\t\treturn null;\r\n\t\t\treturn this.lines[this.index++];\r\n\t\t};\r\n\t\tTextureAtlasReader.prototype.readValue = function () {\r\n\t\t\tvar line = this.readLine();\r\n\t\t\tvar colon = line.indexOf(\":\");\r\n\t\t\tif (colon == -1)\r\n\t\t\t\tthrow new Error(\"Invalid line: \" + line);\r\n\t\t\treturn line.substring(colon + 1).trim();\r\n\t\t};\r\n\t\tTextureAtlasReader.prototype.readTuple = function (tuple) {\r\n\t\t\tvar line = this.readLine();\r\n\t\t\tvar colon = line.indexOf(\":\");\r\n\t\t\tif (colon == -1)\r\n\t\t\t\tthrow new Error(\"Invalid line: \" + line);\r\n\t\t\tvar i = 0, lastMatch = colon + 1;\r\n\t\t\tfor (; i < 3; i++) {\r\n\t\t\t\tvar comma = line.indexOf(\",\", lastMatch);\r\n\t\t\t\tif (comma == -1)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\ttuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n\t\t\t\tlastMatch = comma + 1;\r\n\t\t\t}\r\n\t\t\ttuple[i] = line.substring(lastMatch).trim();\r\n\t\t\treturn i + 1;\r\n\t\t};\r\n\t\treturn TextureAtlasReader;\r\n\t}());\r\n\tvar TextureAtlasPage = (function () {\r\n\t\tfunction TextureAtlasPage() {\r\n\t\t}\r\n\t\treturn TextureAtlasPage;\r\n\t}());\r\n\tspine.TextureAtlasPage = TextureAtlasPage;\r\n\tvar TextureAtlasRegion = (function (_super) {\r\n\t\t__extends(TextureAtlasRegion, _super);\r\n\t\tfunction TextureAtlasRegion() {\r\n\t\t\treturn _super !== null && _super.apply(this, arguments) || this;\r\n\t\t}\r\n\t\treturn TextureAtlasRegion;\r\n\t}(spine.TextureRegion));\r\n\tspine.TextureAtlasRegion = TextureAtlasRegion;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar TransformConstraint = (function () {\r\n\t\tfunction TransformConstraint(data, skeleton) {\r\n\t\t\tthis.rotateMix = 0;\r\n\t\t\tthis.translateMix = 0;\r\n\t\t\tthis.scaleMix = 0;\r\n\t\t\tthis.shearMix = 0;\r\n\t\t\tthis.temp = new spine.Vector2();\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.rotateMix = data.rotateMix;\r\n\t\t\tthis.translateMix = data.translateMix;\r\n\t\t\tthis.scaleMix = data.scaleMix;\r\n\t\t\tthis.shearMix = data.shearMix;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0; i < data.bones.length; i++)\r\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\t\tthis.target = skeleton.findBone(data.target.name);\r\n\t\t}\r\n\t\tTransformConstraint.prototype.apply = function () {\r\n\t\t\tthis.update();\r\n\t\t};\r\n\t\tTransformConstraint.prototype.update = function () {\r\n\t\t\tif (this.data.local) {\r\n\t\t\t\tif (this.data.relative)\r\n\t\t\t\t\tthis.applyRelativeLocal();\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.applyAbsoluteLocal();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (this.data.relative)\r\n\t\t\t\t\tthis.applyRelativeWorld();\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.applyAbsoluteWorld();\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyAbsoluteWorld = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar ta = target.a, tb = target.b, tc = target.c, td = target.d;\r\n\t\t\tvar degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n\t\t\tvar offsetRotation = this.data.offsetRotation * degRadReflect;\r\n\t\t\tvar offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tvar modified = false;\r\n\t\t\t\tif (rotateMix != 0) {\r\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\t\tvar r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr *= rotateMix;\r\n\t\t\t\t\tvar cos = Math.cos(r), sin = Math.sin(r);\r\n\t\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tvar temp = this.temp;\r\n\t\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n\t\t\t\t\tbone.worldX += (temp.x - bone.worldX) * translateMix;\r\n\t\t\t\t\tbone.worldY += (temp.y - bone.worldY) * translateMix;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (scaleMix > 0) {\r\n\t\t\t\t\tvar s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);\r\n\t\t\t\t\tvar ts = Math.sqrt(ta * ta + tc * tc);\r\n\t\t\t\t\tif (s > 0.00001)\r\n\t\t\t\t\t\ts = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n\t\t\t\t\tbone.a *= s;\r\n\t\t\t\t\tbone.c *= s;\r\n\t\t\t\t\ts = Math.sqrt(bone.b * bone.b + bone.d * bone.d);\r\n\t\t\t\t\tts = Math.sqrt(tb * tb + td * td);\r\n\t\t\t\t\tif (s > 0.00001)\r\n\t\t\t\t\t\ts = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n\t\t\t\t\tbone.b *= s;\r\n\t\t\t\t\tbone.d *= s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (shearMix > 0) {\r\n\t\t\t\t\tvar b = bone.b, d = bone.d;\r\n\t\t\t\t\tvar by = Math.atan2(d, b);\r\n\t\t\t\t\tvar r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr = by + (r + offsetShearY) * shearMix;\r\n\t\t\t\t\tvar s = Math.sqrt(b * b + d * d);\r\n\t\t\t\t\tbone.b = Math.cos(r) * s;\r\n\t\t\t\t\tbone.d = Math.sin(r) * s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (modified)\r\n\t\t\t\t\tbone.appliedValid = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyRelativeWorld = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar ta = target.a, tb = target.b, tc = target.c, td = target.d;\r\n\t\t\tvar degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n\t\t\tvar offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tvar modified = false;\r\n\t\t\t\tif (rotateMix != 0) {\r\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\t\tvar r = Math.atan2(tc, ta) + offsetRotation;\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr *= rotateMix;\r\n\t\t\t\t\tvar cos = Math.cos(r), sin = Math.sin(r);\r\n\t\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tvar temp = this.temp;\r\n\t\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n\t\t\t\t\tbone.worldX += temp.x * translateMix;\r\n\t\t\t\t\tbone.worldY += temp.y * translateMix;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (scaleMix > 0) {\r\n\t\t\t\t\tvar s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n\t\t\t\t\tbone.a *= s;\r\n\t\t\t\t\tbone.c *= s;\r\n\t\t\t\t\ts = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n\t\t\t\t\tbone.b *= s;\r\n\t\t\t\t\tbone.d *= s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (shearMix > 0) {\r\n\t\t\t\t\tvar r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tvar b = bone.b, d = bone.d;\r\n\t\t\t\t\tr = Math.atan2(d, b) + (r - spine.MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n\t\t\t\t\tvar s = Math.sqrt(b * b + d * d);\r\n\t\t\t\t\tbone.b = Math.cos(r) * s;\r\n\t\t\t\t\tbone.d = Math.sin(r) * s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (modified)\r\n\t\t\t\t\tbone.appliedValid = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyAbsoluteLocal = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tif (!target.appliedValid)\r\n\t\t\t\ttarget.updateAppliedTransform();\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (!bone.appliedValid)\r\n\t\t\t\t\tbone.updateAppliedTransform();\r\n\t\t\t\tvar rotation = bone.arotation;\r\n\t\t\t\tif (rotateMix != 0) {\r\n\t\t\t\t\tvar r = target.arotation - rotation + this.data.offsetRotation;\r\n\t\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\t\trotation += r * rotateMix;\r\n\t\t\t\t}\r\n\t\t\t\tvar x = bone.ax, y = bone.ay;\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tx += (target.ax - x + this.data.offsetX) * translateMix;\r\n\t\t\t\t\ty += (target.ay - y + this.data.offsetY) * translateMix;\r\n\t\t\t\t}\r\n\t\t\t\tvar scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n\t\t\t\tif (scaleMix > 0) {\r\n\t\t\t\t\tif (scaleX > 0.00001)\r\n\t\t\t\t\t\tscaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n\t\t\t\t\tif (scaleY > 0.00001)\r\n\t\t\t\t\t\tscaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n\t\t\t\t}\r\n\t\t\t\tvar shearY = bone.ashearY;\r\n\t\t\t\tif (shearMix > 0) {\r\n\t\t\t\t\tvar r = target.ashearY - shearY + this.data.offsetShearY;\r\n\t\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\t\tbone.shearY += r * shearMix;\r\n\t\t\t\t}\r\n\t\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyRelativeLocal = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tif (!target.appliedValid)\r\n\t\t\t\ttarget.updateAppliedTransform();\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (!bone.appliedValid)\r\n\t\t\t\t\tbone.updateAppliedTransform();\r\n\t\t\t\tvar rotation = bone.arotation;\r\n\t\t\t\tif (rotateMix != 0)\r\n\t\t\t\t\trotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n\t\t\t\tvar x = bone.ax, y = bone.ay;\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tx += (target.ax + this.data.offsetX) * translateMix;\r\n\t\t\t\t\ty += (target.ay + this.data.offsetY) * translateMix;\r\n\t\t\t\t}\r\n\t\t\t\tvar scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n\t\t\t\tif (scaleMix > 0) {\r\n\t\t\t\t\tif (scaleX > 0.00001)\r\n\t\t\t\t\t\tscaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\r\n\t\t\t\t\tif (scaleY > 0.00001)\r\n\t\t\t\t\t\tscaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\r\n\t\t\t\t}\r\n\t\t\t\tvar shearY = bone.ashearY;\r\n\t\t\t\tif (shearMix > 0)\r\n\t\t\t\t\tshearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n\t\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.getOrder = function () {\r\n\t\t\treturn this.data.order;\r\n\t\t};\r\n\t\treturn TransformConstraint;\r\n\t}());\r\n\tspine.TransformConstraint = TransformConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar TransformConstraintData = (function () {\r\n\t\tfunction TransformConstraintData(name) {\r\n\t\t\tthis.order = 0;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.rotateMix = 0;\r\n\t\t\tthis.translateMix = 0;\r\n\t\t\tthis.scaleMix = 0;\r\n\t\t\tthis.shearMix = 0;\r\n\t\t\tthis.offsetRotation = 0;\r\n\t\t\tthis.offsetX = 0;\r\n\t\t\tthis.offsetY = 0;\r\n\t\t\tthis.offsetScaleX = 0;\r\n\t\t\tthis.offsetScaleY = 0;\r\n\t\t\tthis.offsetShearY = 0;\r\n\t\t\tthis.relative = false;\r\n\t\t\tthis.local = false;\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn TransformConstraintData;\r\n\t}());\r\n\tspine.TransformConstraintData = TransformConstraintData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Triangulator = (function () {\r\n\t\tfunction Triangulator() {\r\n\t\t\tthis.convexPolygons = new Array();\r\n\t\t\tthis.convexPolygonsIndices = new Array();\r\n\t\t\tthis.indicesArray = new Array();\r\n\t\t\tthis.isConcaveArray = new Array();\r\n\t\t\tthis.triangles = new Array();\r\n\t\t\tthis.polygonPool = new spine.Pool(function () {\r\n\t\t\t\treturn new Array();\r\n\t\t\t});\r\n\t\t\tthis.polygonIndicesPool = new spine.Pool(function () {\r\n\t\t\t\treturn new Array();\r\n\t\t\t});\r\n\t\t}\r\n\t\tTriangulator.prototype.triangulate = function (verticesArray) {\r\n\t\t\tvar vertices = verticesArray;\r\n\t\t\tvar vertexCount = verticesArray.length >> 1;\r\n\t\t\tvar indices = this.indicesArray;\r\n\t\t\tindices.length = 0;\r\n\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\tindices[i] = i;\r\n\t\t\tvar isConcave = this.isConcaveArray;\r\n\t\t\tisConcave.length = 0;\r\n\t\t\tfor (var i = 0, n = vertexCount; i < n; ++i)\r\n\t\t\t\tisConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\r\n\t\t\tvar triangles = this.triangles;\r\n\t\t\ttriangles.length = 0;\r\n\t\t\twhile (vertexCount > 3) {\r\n\t\t\t\tvar previous = vertexCount - 1, i = 0, next = 1;\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\touter: if (!isConcave[i]) {\r\n\t\t\t\t\t\tvar p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\r\n\t\t\t\t\t\tvar p1x = vertices[p1], p1y = vertices[p1 + 1];\r\n\t\t\t\t\t\tvar p2x = vertices[p2], p2y = vertices[p2 + 1];\r\n\t\t\t\t\t\tvar p3x = vertices[p3], p3y = vertices[p3 + 1];\r\n\t\t\t\t\t\tfor (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\r\n\t\t\t\t\t\t\tif (!isConcave[ii])\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\tvar v = indices[ii] << 1;\r\n\t\t\t\t\t\t\tvar vx = vertices[v], vy = vertices[v + 1];\r\n\t\t\t\t\t\t\tif (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\r\n\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\r\n\t\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))\r\n\t\t\t\t\t\t\t\t\t\tbreak outer;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (next == 0) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tif (!isConcave[i])\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\ti--;\r\n\t\t\t\t\t\t} while (i > 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprevious = i;\r\n\t\t\t\t\ti = next;\r\n\t\t\t\t\tnext = (next + 1) % vertexCount;\r\n\t\t\t\t}\r\n\t\t\t\ttriangles.push(indices[(vertexCount + i - 1) % vertexCount]);\r\n\t\t\t\ttriangles.push(indices[i]);\r\n\t\t\t\ttriangles.push(indices[(i + 1) % vertexCount]);\r\n\t\t\t\tindices.splice(i, 1);\r\n\t\t\t\tisConcave.splice(i, 1);\r\n\t\t\t\tvertexCount--;\r\n\t\t\t\tvar previousIndex = (vertexCount + i - 1) % vertexCount;\r\n\t\t\t\tvar nextIndex = i == vertexCount ? 0 : i;\r\n\t\t\t\tisConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\r\n\t\t\t\tisConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\r\n\t\t\t}\r\n\t\t\tif (vertexCount == 3) {\r\n\t\t\t\ttriangles.push(indices[2]);\r\n\t\t\t\ttriangles.push(indices[0]);\r\n\t\t\t\ttriangles.push(indices[1]);\r\n\t\t\t}\r\n\t\t\treturn triangles;\r\n\t\t};\r\n\t\tTriangulator.prototype.decompose = function (verticesArray, triangles) {\r\n\t\t\tvar vertices = verticesArray;\r\n\t\t\tvar convexPolygons = this.convexPolygons;\r\n\t\t\tthis.polygonPool.freeAll(convexPolygons);\r\n\t\t\tconvexPolygons.length = 0;\r\n\t\t\tvar convexPolygonsIndices = this.convexPolygonsIndices;\r\n\t\t\tthis.polygonIndicesPool.freeAll(convexPolygonsIndices);\r\n\t\t\tconvexPolygonsIndices.length = 0;\r\n\t\t\tvar polygonIndices = this.polygonIndicesPool.obtain();\r\n\t\t\tpolygonIndices.length = 0;\r\n\t\t\tvar polygon = this.polygonPool.obtain();\r\n\t\t\tpolygon.length = 0;\r\n\t\t\tvar fanBaseIndex = -1, lastWinding = 0;\r\n\t\t\tfor (var i = 0, n = triangles.length; i < n; i += 3) {\r\n\t\t\t\tvar t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\r\n\t\t\t\tvar x1 = vertices[t1], y1 = vertices[t1 + 1];\r\n\t\t\t\tvar x2 = vertices[t2], y2 = vertices[t2 + 1];\r\n\t\t\t\tvar x3 = vertices[t3], y3 = vertices[t3 + 1];\r\n\t\t\t\tvar merged = false;\r\n\t\t\t\tif (fanBaseIndex == t1) {\r\n\t\t\t\t\tvar o = polygon.length - 4;\r\n\t\t\t\t\tvar winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\r\n\t\t\t\t\tvar winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\r\n\t\t\t\t\tif (winding1 == lastWinding && winding2 == lastWinding) {\r\n\t\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\t\tpolygonIndices.push(t3);\r\n\t\t\t\t\t\tmerged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!merged) {\r\n\t\t\t\t\tif (polygon.length > 0) {\r\n\t\t\t\t\t\tconvexPolygons.push(polygon);\r\n\t\t\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.polygonPool.free(polygon);\r\n\t\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpolygon = this.polygonPool.obtain();\r\n\t\t\t\t\tpolygon.length = 0;\r\n\t\t\t\t\tpolygon.push(x1);\r\n\t\t\t\t\tpolygon.push(y1);\r\n\t\t\t\t\tpolygon.push(x2);\r\n\t\t\t\t\tpolygon.push(y2);\r\n\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\tpolygonIndices = this.polygonIndicesPool.obtain();\r\n\t\t\t\t\tpolygonIndices.length = 0;\r\n\t\t\t\t\tpolygonIndices.push(t1);\r\n\t\t\t\t\tpolygonIndices.push(t2);\r\n\t\t\t\t\tpolygonIndices.push(t3);\r\n\t\t\t\t\tlastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\r\n\t\t\t\t\tfanBaseIndex = t1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (polygon.length > 0) {\r\n\t\t\t\tconvexPolygons.push(polygon);\r\n\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, n = convexPolygons.length; i < n; i++) {\r\n\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\r\n\t\t\t\tif (polygonIndices.length == 0)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar firstIndex = polygonIndices[0];\r\n\t\t\t\tvar lastIndex = polygonIndices[polygonIndices.length - 1];\r\n\t\t\t\tpolygon = convexPolygons[i];\r\n\t\t\t\tvar o = polygon.length - 4;\r\n\t\t\t\tvar prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\r\n\t\t\t\tvar prevX = polygon[o + 2], prevY = polygon[o + 3];\r\n\t\t\t\tvar firstX = polygon[0], firstY = polygon[1];\r\n\t\t\t\tvar secondX = polygon[2], secondY = polygon[3];\r\n\t\t\t\tvar winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\r\n\t\t\t\tfor (var ii = 0; ii < n; ii++) {\r\n\t\t\t\t\tif (ii == i)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar otherIndices = convexPolygonsIndices[ii];\r\n\t\t\t\t\tif (otherIndices.length != 3)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar otherFirstIndex = otherIndices[0];\r\n\t\t\t\t\tvar otherSecondIndex = otherIndices[1];\r\n\t\t\t\t\tvar otherLastIndex = otherIndices[2];\r\n\t\t\t\t\tvar otherPoly = convexPolygons[ii];\r\n\t\t\t\t\tvar x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\r\n\t\t\t\t\tif (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\r\n\t\t\t\t\tvar winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\r\n\t\t\t\t\tif (winding1 == winding && winding2 == winding) {\r\n\t\t\t\t\t\totherPoly.length = 0;\r\n\t\t\t\t\t\totherIndices.length = 0;\r\n\t\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\t\tpolygonIndices.push(otherLastIndex);\r\n\t\t\t\t\t\tprevPrevX = prevX;\r\n\t\t\t\t\t\tprevPrevY = prevY;\r\n\t\t\t\t\t\tprevX = x3;\r\n\t\t\t\t\t\tprevY = y3;\r\n\t\t\t\t\t\tii = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = convexPolygons.length - 1; i >= 0; i--) {\r\n\t\t\t\tpolygon = convexPolygons[i];\r\n\t\t\t\tif (polygon.length == 0) {\r\n\t\t\t\t\tconvexPolygons.splice(i, 1);\r\n\t\t\t\t\tthis.polygonPool.free(polygon);\r\n\t\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\r\n\t\t\t\t\tconvexPolygonsIndices.splice(i, 1);\r\n\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn convexPolygons;\r\n\t\t};\r\n\t\tTriangulator.isConcave = function (index, vertexCount, vertices, indices) {\r\n\t\t\tvar previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\r\n\t\t\tvar current = indices[index] << 1;\r\n\t\t\tvar next = indices[(index + 1) % vertexCount] << 1;\r\n\t\t\treturn !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\r\n\t\t};\r\n\t\tTriangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n\t\t\treturn p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\r\n\t\t};\r\n\t\tTriangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n\t\t\tvar px = p2x - p1x, py = p2y - p1y;\r\n\t\t\treturn p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\r\n\t\t};\r\n\t\treturn Triangulator;\r\n\t}());\r\n\tspine.Triangulator = Triangulator;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar IntSet = (function () {\r\n\t\tfunction IntSet() {\r\n\t\t\tthis.array = new Array();\r\n\t\t}\r\n\t\tIntSet.prototype.add = function (value) {\r\n\t\t\tvar contains = this.contains(value);\r\n\t\t\tthis.array[value | 0] = value | 0;\r\n\t\t\treturn !contains;\r\n\t\t};\r\n\t\tIntSet.prototype.contains = function (value) {\r\n\t\t\treturn this.array[value | 0] != undefined;\r\n\t\t};\r\n\t\tIntSet.prototype.remove = function (value) {\r\n\t\t\tthis.array[value | 0] = undefined;\r\n\t\t};\r\n\t\tIntSet.prototype.clear = function () {\r\n\t\t\tthis.array.length = 0;\r\n\t\t};\r\n\t\treturn IntSet;\r\n\t}());\r\n\tspine.IntSet = IntSet;\r\n\tvar Color = (function () {\r\n\t\tfunction Color(r, g, b, a) {\r\n\t\t\tif (r === void 0) { r = 0; }\r\n\t\t\tif (g === void 0) { g = 0; }\r\n\t\t\tif (b === void 0) { b = 0; }\r\n\t\t\tif (a === void 0) { a = 0; }\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\t\tthis.a = a;\r\n\t\t}\r\n\t\tColor.prototype.set = function (r, g, b, a) {\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\t\tthis.a = a;\r\n\t\t\tthis.clamp();\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.setFromColor = function (c) {\r\n\t\t\tthis.r = c.r;\r\n\t\t\tthis.g = c.g;\r\n\t\t\tthis.b = c.b;\r\n\t\t\tthis.a = c.a;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.setFromString = function (hex) {\r\n\t\t\thex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n\t\t\tthis.r = parseInt(hex.substr(0, 2), 16) / 255.0;\r\n\t\t\tthis.g = parseInt(hex.substr(2, 2), 16) / 255.0;\r\n\t\t\tthis.b = parseInt(hex.substr(4, 2), 16) / 255.0;\r\n\t\t\tthis.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.add = function (r, g, b, a) {\r\n\t\t\tthis.r += r;\r\n\t\t\tthis.g += g;\r\n\t\t\tthis.b += b;\r\n\t\t\tthis.a += a;\r\n\t\t\tthis.clamp();\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.clamp = function () {\r\n\t\t\tif (this.r < 0)\r\n\t\t\t\tthis.r = 0;\r\n\t\t\telse if (this.r > 1)\r\n\t\t\t\tthis.r = 1;\r\n\t\t\tif (this.g < 0)\r\n\t\t\t\tthis.g = 0;\r\n\t\t\telse if (this.g > 1)\r\n\t\t\t\tthis.g = 1;\r\n\t\t\tif (this.b < 0)\r\n\t\t\t\tthis.b = 0;\r\n\t\t\telse if (this.b > 1)\r\n\t\t\t\tthis.b = 1;\r\n\t\t\tif (this.a < 0)\r\n\t\t\t\tthis.a = 0;\r\n\t\t\telse if (this.a > 1)\r\n\t\t\t\tthis.a = 1;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.WHITE = new Color(1, 1, 1, 1);\r\n\t\tColor.RED = new Color(1, 0, 0, 1);\r\n\t\tColor.GREEN = new Color(0, 1, 0, 1);\r\n\t\tColor.BLUE = new Color(0, 0, 1, 1);\r\n\t\tColor.MAGENTA = new Color(1, 0, 1, 1);\r\n\t\treturn Color;\r\n\t}());\r\n\tspine.Color = Color;\r\n\tvar MathUtils = (function () {\r\n\t\tfunction MathUtils() {\r\n\t\t}\r\n\t\tMathUtils.clamp = function (value, min, max) {\r\n\t\t\tif (value < min)\r\n\t\t\t\treturn min;\r\n\t\t\tif (value > max)\r\n\t\t\t\treturn max;\r\n\t\t\treturn value;\r\n\t\t};\r\n\t\tMathUtils.cosDeg = function (degrees) {\r\n\t\t\treturn Math.cos(degrees * MathUtils.degRad);\r\n\t\t};\r\n\t\tMathUtils.sinDeg = function (degrees) {\r\n\t\t\treturn Math.sin(degrees * MathUtils.degRad);\r\n\t\t};\r\n\t\tMathUtils.signum = function (value) {\r\n\t\t\treturn value > 0 ? 1 : value < 0 ? -1 : 0;\r\n\t\t};\r\n\t\tMathUtils.toInt = function (x) {\r\n\t\t\treturn x > 0 ? Math.floor(x) : Math.ceil(x);\r\n\t\t};\r\n\t\tMathUtils.cbrt = function (x) {\r\n\t\t\tvar y = Math.pow(Math.abs(x), 1 / 3);\r\n\t\t\treturn x < 0 ? -y : y;\r\n\t\t};\r\n\t\tMathUtils.randomTriangular = function (min, max) {\r\n\t\t\treturn MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n\t\t};\r\n\t\tMathUtils.randomTriangularWith = function (min, max, mode) {\r\n\t\t\tvar u = Math.random();\r\n\t\t\tvar d = max - min;\r\n\t\t\tif (u <= (mode - min) / d)\r\n\t\t\t\treturn min + Math.sqrt(u * d * (mode - min));\r\n\t\t\treturn max - Math.sqrt((1 - u) * d * (max - mode));\r\n\t\t};\r\n\t\tMathUtils.PI = 3.1415927;\r\n\t\tMathUtils.PI2 = MathUtils.PI * 2;\r\n\t\tMathUtils.radiansToDegrees = 180 / MathUtils.PI;\r\n\t\tMathUtils.radDeg = MathUtils.radiansToDegrees;\r\n\t\tMathUtils.degreesToRadians = MathUtils.PI / 180;\r\n\t\tMathUtils.degRad = MathUtils.degreesToRadians;\r\n\t\treturn MathUtils;\r\n\t}());\r\n\tspine.MathUtils = MathUtils;\r\n\tvar Interpolation = (function () {\r\n\t\tfunction Interpolation() {\r\n\t\t}\r\n\t\tInterpolation.prototype.apply = function (start, end, a) {\r\n\t\t\treturn start + (end - start) * this.applyInternal(a);\r\n\t\t};\r\n\t\treturn Interpolation;\r\n\t}());\r\n\tspine.Interpolation = Interpolation;\r\n\tvar Pow = (function (_super) {\r\n\t\t__extends(Pow, _super);\r\n\t\tfunction Pow(power) {\r\n\t\t\tvar _this = _super.call(this) || this;\r\n\t\t\t_this.power = 2;\r\n\t\t\t_this.power = power;\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPow.prototype.applyInternal = function (a) {\r\n\t\t\tif (a <= 0.5)\r\n\t\t\t\treturn Math.pow(a * 2, this.power) / 2;\r\n\t\t\treturn Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n\t\t};\r\n\t\treturn Pow;\r\n\t}(Interpolation));\r\n\tspine.Pow = Pow;\r\n\tvar PowOut = (function (_super) {\r\n\t\t__extends(PowOut, _super);\r\n\t\tfunction PowOut(power) {\r\n\t\t\treturn _super.call(this, power) || this;\r\n\t\t}\r\n\t\tPowOut.prototype.applyInternal = function (a) {\r\n\t\t\treturn Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n\t\t};\r\n\t\treturn PowOut;\r\n\t}(Pow));\r\n\tspine.PowOut = PowOut;\r\n\tvar Utils = (function () {\r\n\t\tfunction Utils() {\r\n\t\t}\r\n\t\tUtils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\r\n\t\t\tfor (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n\t\t\t\tdest[j] = source[i];\r\n\t\t\t}\r\n\t\t};\r\n\t\tUtils.setArraySize = function (array, size, value) {\r\n\t\t\tif (value === void 0) { value = 0; }\r\n\t\t\tvar oldSize = array.length;\r\n\t\t\tif (oldSize == size)\r\n\t\t\t\treturn array;\r\n\t\t\tarray.length = size;\r\n\t\t\tif (oldSize < size) {\r\n\t\t\t\tfor (var i = oldSize; i < size; i++)\r\n\t\t\t\t\tarray[i] = value;\r\n\t\t\t}\r\n\t\t\treturn array;\r\n\t\t};\r\n\t\tUtils.ensureArrayCapacity = function (array, size, value) {\r\n\t\t\tif (value === void 0) { value = 0; }\r\n\t\t\tif (array.length >= size)\r\n\t\t\t\treturn array;\r\n\t\t\treturn Utils.setArraySize(array, size, value);\r\n\t\t};\r\n\t\tUtils.newArray = function (size, defaultValue) {\r\n\t\t\tvar array = new Array(size);\r\n\t\t\tfor (var i = 0; i < size; i++)\r\n\t\t\t\tarray[i] = defaultValue;\r\n\t\t\treturn array;\r\n\t\t};\r\n\t\tUtils.newFloatArray = function (size) {\r\n\t\t\tif (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n\t\t\t\treturn new Float32Array(size);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar array = new Array(size);\r\n\t\t\t\tfor (var i = 0; i < array.length; i++)\r\n\t\t\t\t\tarray[i] = 0;\r\n\t\t\t\treturn array;\r\n\t\t\t}\r\n\t\t};\r\n\t\tUtils.newShortArray = function (size) {\r\n\t\t\tif (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n\t\t\t\treturn new Int16Array(size);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar array = new Array(size);\r\n\t\t\t\tfor (var i = 0; i < array.length; i++)\r\n\t\t\t\t\tarray[i] = 0;\r\n\t\t\t\treturn array;\r\n\t\t\t}\r\n\t\t};\r\n\t\tUtils.toFloatArray = function (array) {\r\n\t\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n\t\t};\r\n\t\tUtils.toSinglePrecision = function (value) {\r\n\t\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\r\n\t\t};\r\n\t\tUtils.webkit602BugfixHelper = function (alpha, pose) {\r\n\t\t};\r\n\t\tUtils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== \"undefined\";\r\n\t\treturn Utils;\r\n\t}());\r\n\tspine.Utils = Utils;\r\n\tvar DebugUtils = (function () {\r\n\t\tfunction DebugUtils() {\r\n\t\t}\r\n\t\tDebugUtils.logBones = function (skeleton) {\r\n\t\t\tfor (var i = 0; i < skeleton.bones.length; i++) {\r\n\t\t\t\tvar bone = skeleton.bones[i];\r\n\t\t\t\tconsole.log(bone.data.name + \", \" + bone.a + \", \" + bone.b + \", \" + bone.c + \", \" + bone.d + \", \" + bone.worldX + \", \" + bone.worldY);\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn DebugUtils;\r\n\t}());\r\n\tspine.DebugUtils = DebugUtils;\r\n\tvar Pool = (function () {\r\n\t\tfunction Pool(instantiator) {\r\n\t\t\tthis.items = new Array();\r\n\t\t\tthis.instantiator = instantiator;\r\n\t\t}\r\n\t\tPool.prototype.obtain = function () {\r\n\t\t\treturn this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n\t\t};\r\n\t\tPool.prototype.free = function (item) {\r\n\t\t\tif (item.reset)\r\n\t\t\t\titem.reset();\r\n\t\t\tthis.items.push(item);\r\n\t\t};\r\n\t\tPool.prototype.freeAll = function (items) {\r\n\t\t\tfor (var i = 0; i < items.length; i++) {\r\n\t\t\t\tif (items[i].reset)\r\n\t\t\t\t\titems[i].reset();\r\n\t\t\t\tthis.items[i] = items[i];\r\n\t\t\t}\r\n\t\t};\r\n\t\tPool.prototype.clear = function () {\r\n\t\t\tthis.items.length = 0;\r\n\t\t};\r\n\t\treturn Pool;\r\n\t}());\r\n\tspine.Pool = Pool;\r\n\tvar Vector2 = (function () {\r\n\t\tfunction Vector2(x, y) {\r\n\t\t\tif (x === void 0) { x = 0; }\r\n\t\t\tif (y === void 0) { y = 0; }\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t\tVector2.prototype.set = function (x, y) {\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tVector2.prototype.length = function () {\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\treturn Math.sqrt(x * x + y * y);\r\n\t\t};\r\n\t\tVector2.prototype.normalize = function () {\r\n\t\t\tvar len = this.length();\r\n\t\t\tif (len != 0) {\r\n\t\t\t\tthis.x /= len;\r\n\t\t\t\tthis.y /= len;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\treturn Vector2;\r\n\t}());\r\n\tspine.Vector2 = Vector2;\r\n\tvar TimeKeeper = (function () {\r\n\t\tfunction TimeKeeper() {\r\n\t\t\tthis.maxDelta = 0.064;\r\n\t\t\tthis.framesPerSecond = 0;\r\n\t\t\tthis.delta = 0;\r\n\t\t\tthis.totalTime = 0;\r\n\t\t\tthis.lastTime = Date.now() / 1000;\r\n\t\t\tthis.frameCount = 0;\r\n\t\t\tthis.frameTime = 0;\r\n\t\t}\r\n\t\tTimeKeeper.prototype.update = function () {\r\n\t\t\tvar now = Date.now() / 1000;\r\n\t\t\tthis.delta = now - this.lastTime;\r\n\t\t\tthis.frameTime += this.delta;\r\n\t\t\tthis.totalTime += this.delta;\r\n\t\t\tif (this.delta > this.maxDelta)\r\n\t\t\t\tthis.delta = this.maxDelta;\r\n\t\t\tthis.lastTime = now;\r\n\t\t\tthis.frameCount++;\r\n\t\t\tif (this.frameTime > 1) {\r\n\t\t\t\tthis.framesPerSecond = this.frameCount / this.frameTime;\r\n\t\t\t\tthis.frameTime = 0;\r\n\t\t\t\tthis.frameCount = 0;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn TimeKeeper;\r\n\t}());\r\n\tspine.TimeKeeper = TimeKeeper;\r\n\tvar WindowedMean = (function () {\r\n\t\tfunction WindowedMean(windowSize) {\r\n\t\t\tif (windowSize === void 0) { windowSize = 32; }\r\n\t\t\tthis.addedValues = 0;\r\n\t\t\tthis.lastValue = 0;\r\n\t\t\tthis.mean = 0;\r\n\t\t\tthis.dirty = true;\r\n\t\t\tthis.values = new Array(windowSize);\r\n\t\t}\r\n\t\tWindowedMean.prototype.hasEnoughData = function () {\r\n\t\t\treturn this.addedValues >= this.values.length;\r\n\t\t};\r\n\t\tWindowedMean.prototype.addValue = function (value) {\r\n\t\t\tif (this.addedValues < this.values.length)\r\n\t\t\t\tthis.addedValues++;\r\n\t\t\tthis.values[this.lastValue++] = value;\r\n\t\t\tif (this.lastValue > this.values.length - 1)\r\n\t\t\t\tthis.lastValue = 0;\r\n\t\t\tthis.dirty = true;\r\n\t\t};\r\n\t\tWindowedMean.prototype.getMean = function () {\r\n\t\t\tif (this.hasEnoughData()) {\r\n\t\t\t\tif (this.dirty) {\r\n\t\t\t\t\tvar mean = 0;\r\n\t\t\t\t\tfor (var i = 0; i < this.values.length; i++) {\r\n\t\t\t\t\t\tmean += this.values[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.mean = mean / this.values.length;\r\n\t\t\t\t\tthis.dirty = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn this.mean;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn WindowedMean;\r\n\t}());\r\n\tspine.WindowedMean = WindowedMean;\r\n})(spine || (spine = {}));\r\n(function () {\r\n\tif (!Math.fround) {\r\n\t\tMath.fround = (function (array) {\r\n\t\t\treturn function (x) {\r\n\t\t\t\treturn array[0] = x, array[0];\r\n\t\t\t};\r\n\t\t})(new Float32Array(1));\r\n\t}\r\n})();\r\nvar spine;\r\n(function (spine) {\r\n\tvar Attachment = (function () {\r\n\t\tfunction Attachment(name) {\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn Attachment;\r\n\t}());\r\n\tspine.Attachment = Attachment;\r\n\tvar VertexAttachment = (function (_super) {\r\n\t\t__extends(VertexAttachment, _super);\r\n\t\tfunction VertexAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.id = (VertexAttachment.nextID++ & 65535) << 11;\r\n\t\t\t_this.worldVerticesLength = 0;\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tVertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\r\n\t\t\tcount = offset + (count >> 1) * stride;\r\n\t\t\tvar skeleton = slot.bone.skeleton;\r\n\t\t\tvar deformArray = slot.attachmentVertices;\r\n\t\t\tvar vertices = this.vertices;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tif (bones == null) {\r\n\t\t\t\tif (deformArray.length > 0)\r\n\t\t\t\t\tvertices = deformArray;\r\n\t\t\t\tvar bone = slot.bone;\r\n\t\t\t\tvar x = bone.worldX;\r\n\t\t\t\tvar y = bone.worldY;\r\n\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\tfor (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\r\n\t\t\t\t\tvar vx = vertices[v_1], vy = vertices[v_1 + 1];\r\n\t\t\t\t\tworldVertices[w] = vx * a + vy * b + x;\r\n\t\t\t\t\tworldVertices[w + 1] = vx * c + vy * d + y;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar v = 0, skip = 0;\r\n\t\t\tfor (var i = 0; i < start; i += 2) {\r\n\t\t\t\tvar n = bones[v];\r\n\t\t\t\tv += n + 1;\r\n\t\t\t\tskip += n;\r\n\t\t\t}\r\n\t\t\tvar skeletonBones = skeleton.bones;\r\n\t\t\tif (deformArray.length == 0) {\r\n\t\t\t\tfor (var w = offset, b = skip * 3; w < count; w += stride) {\r\n\t\t\t\t\tvar wx = 0, wy = 0;\r\n\t\t\t\t\tvar n = bones[v++];\r\n\t\t\t\t\tn += v;\r\n\t\t\t\t\tfor (; v < n; v++, b += 3) {\r\n\t\t\t\t\t\tvar bone = skeletonBones[bones[v]];\r\n\t\t\t\t\t\tvar vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n\t\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\r\n\t\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tworldVertices[w] = wx;\r\n\t\t\t\t\tworldVertices[w + 1] = wy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar deform = deformArray;\r\n\t\t\t\tfor (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n\t\t\t\t\tvar wx = 0, wy = 0;\r\n\t\t\t\t\tvar n = bones[v++];\r\n\t\t\t\t\tn += v;\r\n\t\t\t\t\tfor (; v < n; v++, b += 3, f += 2) {\r\n\t\t\t\t\t\tvar bone = skeletonBones[bones[v]];\r\n\t\t\t\t\t\tvar vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n\t\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\r\n\t\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tworldVertices[w] = wx;\r\n\t\t\t\t\tworldVertices[w + 1] = wy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tVertexAttachment.prototype.applyDeform = function (sourceAttachment) {\r\n\t\t\treturn this == sourceAttachment;\r\n\t\t};\r\n\t\tVertexAttachment.nextID = 0;\r\n\t\treturn VertexAttachment;\r\n\t}(Attachment));\r\n\tspine.VertexAttachment = VertexAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AttachmentType;\r\n\t(function (AttachmentType) {\r\n\t\tAttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\r\n\t\tAttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\r\n\t\tAttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\r\n\t\tAttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\r\n\t\tAttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\r\n\t\tAttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\r\n\t})(AttachmentType = spine.AttachmentType || (spine.AttachmentType = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar BoundingBoxAttachment = (function (_super) {\r\n\t\t__extends(BoundingBoxAttachment, _super);\r\n\t\tfunction BoundingBoxAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\treturn BoundingBoxAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.BoundingBoxAttachment = BoundingBoxAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar ClippingAttachment = (function (_super) {\r\n\t\t__extends(ClippingAttachment, _super);\r\n\t\tfunction ClippingAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(0.2275, 0.2275, 0.8078, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\treturn ClippingAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.ClippingAttachment = ClippingAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar MeshAttachment = (function (_super) {\r\n\t\t__extends(MeshAttachment, _super);\r\n\t\tfunction MeshAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\t_this.inheritDeform = false;\r\n\t\t\t_this.tempColor = new spine.Color(0, 0, 0, 0);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tMeshAttachment.prototype.updateUVs = function () {\r\n\t\t\tvar u = 0, v = 0, width = 0, height = 0;\r\n\t\t\tif (this.region == null) {\r\n\t\t\t\tu = v = 0;\r\n\t\t\t\twidth = height = 1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tu = this.region.u;\r\n\t\t\t\tv = this.region.v;\r\n\t\t\t\twidth = this.region.u2 - u;\r\n\t\t\t\theight = this.region.v2 - v;\r\n\t\t\t}\r\n\t\t\tvar regionUVs = this.regionUVs;\r\n\t\t\tif (this.uvs == null || this.uvs.length != regionUVs.length)\r\n\t\t\t\tthis.uvs = spine.Utils.newFloatArray(regionUVs.length);\r\n\t\t\tvar uvs = this.uvs;\r\n\t\t\tif (this.region.rotate) {\r\n\t\t\t\tfor (var i = 0, n = uvs.length; i < n; i += 2) {\r\n\t\t\t\t\tuvs[i] = u + regionUVs[i + 1] * width;\r\n\t\t\t\t\tuvs[i + 1] = v + height - regionUVs[i] * height;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 0, n = uvs.length; i < n; i += 2) {\r\n\t\t\t\t\tuvs[i] = u + regionUVs[i] * width;\r\n\t\t\t\t\tuvs[i + 1] = v + regionUVs[i + 1] * height;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tMeshAttachment.prototype.applyDeform = function (sourceAttachment) {\r\n\t\t\treturn this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\r\n\t\t};\r\n\t\tMeshAttachment.prototype.getParentMesh = function () {\r\n\t\t\treturn this.parentMesh;\r\n\t\t};\r\n\t\tMeshAttachment.prototype.setParentMesh = function (parentMesh) {\r\n\t\t\tthis.parentMesh = parentMesh;\r\n\t\t\tif (parentMesh != null) {\r\n\t\t\t\tthis.bones = parentMesh.bones;\r\n\t\t\t\tthis.vertices = parentMesh.vertices;\r\n\t\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength;\r\n\t\t\t\tthis.regionUVs = parentMesh.regionUVs;\r\n\t\t\t\tthis.triangles = parentMesh.triangles;\r\n\t\t\t\tthis.hullLength = parentMesh.hullLength;\r\n\t\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn MeshAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.MeshAttachment = MeshAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PathAttachment = (function (_super) {\r\n\t\t__extends(PathAttachment, _super);\r\n\t\tfunction PathAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.closed = false;\r\n\t\t\t_this.constantSpeed = false;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\treturn PathAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.PathAttachment = PathAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PointAttachment = (function (_super) {\r\n\t\t__extends(PointAttachment, _super);\r\n\t\tfunction PointAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(0.38, 0.94, 0, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPointAttachment.prototype.computeWorldPosition = function (bone, point) {\r\n\t\t\tpoint.x = this.x * bone.a + this.y * bone.b + bone.worldX;\r\n\t\t\tpoint.y = this.x * bone.c + this.y * bone.d + bone.worldY;\r\n\t\t\treturn point;\r\n\t\t};\r\n\t\tPointAttachment.prototype.computeWorldRotation = function (bone) {\r\n\t\t\tvar cos = spine.MathUtils.cosDeg(this.rotation), sin = spine.MathUtils.sinDeg(this.rotation);\r\n\t\t\tvar x = cos * bone.a + sin * bone.b;\r\n\t\t\tvar y = cos * bone.c + sin * bone.d;\r\n\t\t\treturn Math.atan2(y, x) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\treturn PointAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.PointAttachment = PointAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar RegionAttachment = (function (_super) {\r\n\t\t__extends(RegionAttachment, _super);\r\n\t\tfunction RegionAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.x = 0;\r\n\t\t\t_this.y = 0;\r\n\t\t\t_this.scaleX = 1;\r\n\t\t\t_this.scaleY = 1;\r\n\t\t\t_this.rotation = 0;\r\n\t\t\t_this.width = 0;\r\n\t\t\t_this.height = 0;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\t_this.offset = spine.Utils.newFloatArray(8);\r\n\t\t\t_this.uvs = spine.Utils.newFloatArray(8);\r\n\t\t\t_this.tempColor = new spine.Color(1, 1, 1, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tRegionAttachment.prototype.updateOffset = function () {\r\n\t\t\tvar regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n\t\t\tvar regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n\t\t\tvar localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n\t\t\tvar localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n\t\t\tvar localX2 = localX + this.region.width * regionScaleX;\r\n\t\t\tvar localY2 = localY + this.region.height * regionScaleY;\r\n\t\t\tvar radians = this.rotation * Math.PI / 180;\r\n\t\t\tvar cos = Math.cos(radians);\r\n\t\t\tvar sin = Math.sin(radians);\r\n\t\t\tvar localXCos = localX * cos + this.x;\r\n\t\t\tvar localXSin = localX * sin;\r\n\t\t\tvar localYCos = localY * cos + this.y;\r\n\t\t\tvar localYSin = localY * sin;\r\n\t\t\tvar localX2Cos = localX2 * cos + this.x;\r\n\t\t\tvar localX2Sin = localX2 * sin;\r\n\t\t\tvar localY2Cos = localY2 * cos + this.y;\r\n\t\t\tvar localY2Sin = localY2 * sin;\r\n\t\t\tvar offset = this.offset;\r\n\t\t\toffset[RegionAttachment.OX1] = localXCos - localYSin;\r\n\t\t\toffset[RegionAttachment.OY1] = localYCos + localXSin;\r\n\t\t\toffset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n\t\t\toffset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n\t\t\toffset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n\t\t\toffset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n\t\t\toffset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n\t\t\toffset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n\t\t};\r\n\t\tRegionAttachment.prototype.setRegion = function (region) {\r\n\t\t\tthis.region = region;\r\n\t\t\tvar uvs = this.uvs;\r\n\t\t\tif (region.rotate) {\r\n\t\t\t\tuvs[2] = region.u;\r\n\t\t\t\tuvs[3] = region.v2;\r\n\t\t\t\tuvs[4] = region.u;\r\n\t\t\t\tuvs[5] = region.v;\r\n\t\t\t\tuvs[6] = region.u2;\r\n\t\t\t\tuvs[7] = region.v;\r\n\t\t\t\tuvs[0] = region.u2;\r\n\t\t\t\tuvs[1] = region.v2;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tuvs[0] = region.u;\r\n\t\t\t\tuvs[1] = region.v2;\r\n\t\t\t\tuvs[2] = region.u;\r\n\t\t\t\tuvs[3] = region.v;\r\n\t\t\t\tuvs[4] = region.u2;\r\n\t\t\t\tuvs[5] = region.v;\r\n\t\t\t\tuvs[6] = region.u2;\r\n\t\t\t\tuvs[7] = region.v2;\r\n\t\t\t}\r\n\t\t};\r\n\t\tRegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\r\n\t\t\tvar vertexOffset = this.offset;\r\n\t\t\tvar x = bone.worldX, y = bone.worldY;\r\n\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\tvar offsetX = 0, offsetY = 0;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX1];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY1];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t\toffset += stride;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX2];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY2];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t\toffset += stride;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX3];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY3];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t\toffset += stride;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX4];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY4];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t};\r\n\t\tRegionAttachment.OX1 = 0;\r\n\t\tRegionAttachment.OY1 = 1;\r\n\t\tRegionAttachment.OX2 = 2;\r\n\t\tRegionAttachment.OY2 = 3;\r\n\t\tRegionAttachment.OX3 = 4;\r\n\t\tRegionAttachment.OY3 = 5;\r\n\t\tRegionAttachment.OX4 = 6;\r\n\t\tRegionAttachment.OY4 = 7;\r\n\t\tRegionAttachment.X1 = 0;\r\n\t\tRegionAttachment.Y1 = 1;\r\n\t\tRegionAttachment.C1R = 2;\r\n\t\tRegionAttachment.C1G = 3;\r\n\t\tRegionAttachment.C1B = 4;\r\n\t\tRegionAttachment.C1A = 5;\r\n\t\tRegionAttachment.U1 = 6;\r\n\t\tRegionAttachment.V1 = 7;\r\n\t\tRegionAttachment.X2 = 8;\r\n\t\tRegionAttachment.Y2 = 9;\r\n\t\tRegionAttachment.C2R = 10;\r\n\t\tRegionAttachment.C2G = 11;\r\n\t\tRegionAttachment.C2B = 12;\r\n\t\tRegionAttachment.C2A = 13;\r\n\t\tRegionAttachment.U2 = 14;\r\n\t\tRegionAttachment.V2 = 15;\r\n\t\tRegionAttachment.X3 = 16;\r\n\t\tRegionAttachment.Y3 = 17;\r\n\t\tRegionAttachment.C3R = 18;\r\n\t\tRegionAttachment.C3G = 19;\r\n\t\tRegionAttachment.C3B = 20;\r\n\t\tRegionAttachment.C3A = 21;\r\n\t\tRegionAttachment.U3 = 22;\r\n\t\tRegionAttachment.V3 = 23;\r\n\t\tRegionAttachment.X4 = 24;\r\n\t\tRegionAttachment.Y4 = 25;\r\n\t\tRegionAttachment.C4R = 26;\r\n\t\tRegionAttachment.C4G = 27;\r\n\t\tRegionAttachment.C4B = 28;\r\n\t\tRegionAttachment.C4A = 29;\r\n\t\tRegionAttachment.U4 = 30;\r\n\t\tRegionAttachment.V4 = 31;\r\n\t\treturn RegionAttachment;\r\n\t}(spine.Attachment));\r\n\tspine.RegionAttachment = RegionAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar JitterEffect = (function () {\r\n\t\tfunction JitterEffect(jitterX, jitterY) {\r\n\t\t\tthis.jitterX = 0;\r\n\t\t\tthis.jitterY = 0;\r\n\t\t\tthis.jitterX = jitterX;\r\n\t\t\tthis.jitterY = jitterY;\r\n\t\t}\r\n\t\tJitterEffect.prototype.begin = function (skeleton) {\r\n\t\t};\r\n\t\tJitterEffect.prototype.transform = function (position, uv, light, dark) {\r\n\t\t\tposition.x += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n\t\t\tposition.y += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n\t\t};\r\n\t\tJitterEffect.prototype.end = function () {\r\n\t\t};\r\n\t\treturn JitterEffect;\r\n\t}());\r\n\tspine.JitterEffect = JitterEffect;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SwirlEffect = (function () {\r\n\t\tfunction SwirlEffect(radius) {\r\n\t\t\tthis.centerX = 0;\r\n\t\t\tthis.centerY = 0;\r\n\t\t\tthis.radius = 0;\r\n\t\t\tthis.angle = 0;\r\n\t\t\tthis.worldX = 0;\r\n\t\t\tthis.worldY = 0;\r\n\t\t\tthis.radius = radius;\r\n\t\t}\r\n\t\tSwirlEffect.prototype.begin = function (skeleton) {\r\n\t\t\tthis.worldX = skeleton.x + this.centerX;\r\n\t\t\tthis.worldY = skeleton.y + this.centerY;\r\n\t\t};\r\n\t\tSwirlEffect.prototype.transform = function (position, uv, light, dark) {\r\n\t\t\tvar radAngle = this.angle * spine.MathUtils.degreesToRadians;\r\n\t\t\tvar x = position.x - this.worldX;\r\n\t\t\tvar y = position.y - this.worldY;\r\n\t\t\tvar dist = Math.sqrt(x * x + y * y);\r\n\t\t\tif (dist < this.radius) {\r\n\t\t\t\tvar theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n\t\t\t\tvar cos = Math.cos(theta);\r\n\t\t\t\tvar sin = Math.sin(theta);\r\n\t\t\t\tposition.x = cos * x - sin * y + this.worldX;\r\n\t\t\t\tposition.y = sin * x + cos * y + this.worldY;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSwirlEffect.prototype.end = function () {\r\n\t\t};\r\n\t\tSwirlEffect.interpolation = new spine.PowOut(2);\r\n\t\treturn SwirlEffect;\r\n\t}());\r\n\tspine.SwirlEffect = SwirlEffect;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar AssetManager = (function (_super) {\r\n\t\t\t__extends(AssetManager, _super);\r\n\t\t\tfunction AssetManager(context, pathPrefix) {\r\n\t\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n\t\t\t\treturn _super.call(this, function (image) {\r\n\t\t\t\t\treturn new spine.webgl.GLTexture(context, image);\r\n\t\t\t\t}, pathPrefix) || this;\r\n\t\t\t}\r\n\t\t\treturn AssetManager;\r\n\t\t}(spine.AssetManager));\r\n\t\twebgl.AssetManager = AssetManager;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar OrthoCamera = (function () {\r\n\t\t\tfunction OrthoCamera(viewportWidth, viewportHeight) {\r\n\t\t\t\tthis.position = new webgl.Vector3(0, 0, 0);\r\n\t\t\t\tthis.direction = new webgl.Vector3(0, 0, -1);\r\n\t\t\t\tthis.up = new webgl.Vector3(0, 1, 0);\r\n\t\t\t\tthis.near = 0;\r\n\t\t\t\tthis.far = 100;\r\n\t\t\t\tthis.zoom = 1;\r\n\t\t\t\tthis.viewportWidth = 0;\r\n\t\t\t\tthis.viewportHeight = 0;\r\n\t\t\t\tthis.projectionView = new webgl.Matrix4();\r\n\t\t\t\tthis.inverseProjectionView = new webgl.Matrix4();\r\n\t\t\t\tthis.projection = new webgl.Matrix4();\r\n\t\t\t\tthis.view = new webgl.Matrix4();\r\n\t\t\t\tthis.tmp = new webgl.Vector3();\r\n\t\t\t\tthis.viewportWidth = viewportWidth;\r\n\t\t\t\tthis.viewportHeight = viewportHeight;\r\n\t\t\t\tthis.update();\r\n\t\t\t}\r\n\t\t\tOrthoCamera.prototype.update = function () {\r\n\t\t\t\tvar projection = this.projection;\r\n\t\t\t\tvar view = this.view;\r\n\t\t\t\tvar projectionView = this.projectionView;\r\n\t\t\t\tvar inverseProjectionView = this.inverseProjectionView;\r\n\t\t\t\tvar zoom = this.zoom, viewportWidth = this.viewportWidth, viewportHeight = this.viewportHeight;\r\n\t\t\t\tprojection.ortho(zoom * (-viewportWidth / 2), zoom * (viewportWidth / 2), zoom * (-viewportHeight / 2), zoom * (viewportHeight / 2), this.near, this.far);\r\n\t\t\t\tview.lookAt(this.position, this.direction, this.up);\r\n\t\t\t\tprojectionView.set(projection.values);\r\n\t\t\t\tprojectionView.multiply(view);\r\n\t\t\t\tinverseProjectionView.set(projectionView.values).invert();\r\n\t\t\t};\r\n\t\t\tOrthoCamera.prototype.screenToWorld = function (screenCoords, screenWidth, screenHeight) {\r\n\t\t\t\tvar x = screenCoords.x, y = screenHeight - screenCoords.y - 1;\r\n\t\t\t\tvar tmp = this.tmp;\r\n\t\t\t\ttmp.x = (2 * x) / screenWidth - 1;\r\n\t\t\t\ttmp.y = (2 * y) / screenHeight - 1;\r\n\t\t\t\ttmp.z = (2 * screenCoords.z) - 1;\r\n\t\t\t\ttmp.project(this.inverseProjectionView);\r\n\t\t\t\tscreenCoords.set(tmp.x, tmp.y, tmp.z);\r\n\t\t\t\treturn screenCoords;\r\n\t\t\t};\r\n\t\t\tOrthoCamera.prototype.setViewport = function (viewportWidth, viewportHeight) {\r\n\t\t\t\tthis.viewportWidth = viewportWidth;\r\n\t\t\t\tthis.viewportHeight = viewportHeight;\r\n\t\t\t};\r\n\t\t\treturn OrthoCamera;\r\n\t\t}());\r\n\t\twebgl.OrthoCamera = OrthoCamera;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar GLTexture = (function (_super) {\r\n\t\t\t__extends(GLTexture, _super);\r\n\t\t\tfunction GLTexture(context, image, useMipMaps) {\r\n\t\t\t\tif (useMipMaps === void 0) { useMipMaps = false; }\r\n\t\t\t\tvar _this = _super.call(this, image) || this;\r\n\t\t\t\t_this.texture = null;\r\n\t\t\t\t_this.boundUnit = 0;\r\n\t\t\t\t_this.useMipMaps = false;\r\n\t\t\t\t_this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n\t\t\t\t_this.useMipMaps = useMipMaps;\r\n\t\t\t\t_this.restore();\r\n\t\t\t\t_this.context.addRestorable(_this);\r\n\t\t\t\treturn _this;\r\n\t\t\t}\r\n\t\t\tGLTexture.prototype.setFilters = function (minFilter, magFilter) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tthis.bind();\r\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n\t\t\t};\r\n\t\t\tGLTexture.prototype.setWraps = function (uWrap, vWrap) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tthis.bind();\r\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, uWrap);\r\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, vWrap);\r\n\t\t\t};\r\n\t\t\tGLTexture.prototype.update = function (useMipMaps) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tif (!this.texture) {\r\n\t\t\t\t\tthis.texture = this.context.gl.createTexture();\r\n\t\t\t\t}\r\n\t\t\t\tthis.bind();\r\n\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._image);\r\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\r\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\t\t\t\tif (useMipMaps)\r\n\t\t\t\t\tgl.generateMipmap(gl.TEXTURE_2D);\r\n\t\t\t};\r\n\t\t\tGLTexture.prototype.restore = function () {\r\n\t\t\t\tthis.texture = null;\r\n\t\t\t\tthis.update(this.useMipMaps);\r\n\t\t\t};\r\n\t\t\tGLTexture.prototype.bind = function (unit) {\r\n\t\t\t\tif (unit === void 0) { unit = 0; }\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tthis.boundUnit = unit;\r\n\t\t\t\tgl.activeTexture(gl.TEXTURE0 + unit);\r\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n\t\t\t};\r\n\t\t\tGLTexture.prototype.unbind = function () {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tgl.activeTexture(gl.TEXTURE0 + this.boundUnit);\r\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, null);\r\n\t\t\t};\r\n\t\t\tGLTexture.prototype.dispose = function () {\r\n\t\t\t\tthis.context.removeRestorable(this);\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tgl.deleteTexture(this.texture);\r\n\t\t\t};\r\n\t\t\treturn GLTexture;\r\n\t\t}(spine.Texture));\r\n\t\twebgl.GLTexture = GLTexture;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar Input = (function () {\r\n\t\t\tfunction Input(element) {\r\n\t\t\t\tthis.lastX = 0;\r\n\t\t\t\tthis.lastY = 0;\r\n\t\t\t\tthis.buttonDown = false;\r\n\t\t\t\tthis.currTouch = null;\r\n\t\t\t\tthis.touchesPool = new spine.Pool(function () {\r\n\t\t\t\t\treturn new spine.webgl.Touch(0, 0, 0);\r\n\t\t\t\t});\r\n\t\t\t\tthis.listeners = new Array();\r\n\t\t\t\tthis.element = element;\r\n\t\t\t\tthis.setupCallbacks(element);\r\n\t\t\t}\r\n\t\t\tInput.prototype.setupCallbacks = function (element) {\r\n\t\t\t\tvar _this = this;\r\n\t\t\t\telement.addEventListener(\"mousedown\", function (ev) {\r\n\t\t\t\t\tif (ev instanceof MouseEvent) {\r\n\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\r\n\t\t\t\t\t\tvar x = ev.clientX - rect.left;\r\n\t\t\t\t\t\tvar y = ev.clientY - rect.top;\r\n\t\t\t\t\t\tvar listeners = _this.listeners;\r\n\t\t\t\t\t\tfor (var i = 0; i < listeners.length; i++) {\r\n\t\t\t\t\t\t\tlisteners[i].down(x, y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t_this.lastX = x;\r\n\t\t\t\t\t\t_this.lastY = y;\r\n\t\t\t\t\t\t_this.buttonDown = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, true);\r\n\t\t\t\telement.addEventListener(\"mousemove\", function (ev) {\r\n\t\t\t\t\tif (ev instanceof MouseEvent) {\r\n\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\r\n\t\t\t\t\t\tvar x = ev.clientX - rect.left;\r\n\t\t\t\t\t\tvar y = ev.clientY - rect.top;\r\n\t\t\t\t\t\tvar listeners = _this.listeners;\r\n\t\t\t\t\t\tfor (var i = 0; i < listeners.length; i++) {\r\n\t\t\t\t\t\t\tif (_this.buttonDown) {\r\n\t\t\t\t\t\t\t\tlisteners[i].dragged(x, y);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tlisteners[i].moved(x, y);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t_this.lastX = x;\r\n\t\t\t\t\t\t_this.lastY = y;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, true);\r\n\t\t\t\telement.addEventListener(\"mouseup\", function (ev) {\r\n\t\t\t\t\tif (ev instanceof MouseEvent) {\r\n\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\r\n\t\t\t\t\t\tvar x = ev.clientX - rect.left;\r\n\t\t\t\t\t\tvar y = ev.clientY - rect.top;\r\n\t\t\t\t\t\tvar listeners = _this.listeners;\r\n\t\t\t\t\t\tfor (var i = 0; i < listeners.length; i++) {\r\n\t\t\t\t\t\t\tlisteners[i].up(x, y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t_this.lastX = x;\r\n\t\t\t\t\t\t_this.lastY = y;\r\n\t\t\t\t\t\t_this.buttonDown = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, true);\r\n\t\t\t\telement.addEventListener(\"touchstart\", function (ev) {\r\n\t\t\t\t\tif (_this.currTouch != null)\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tvar touches = ev.changedTouches;\r\n\t\t\t\t\tfor (var i = 0; i < touches.length; i++) {\r\n\t\t\t\t\t\tvar touch = touches[i];\r\n\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\r\n\t\t\t\t\t\tvar x = touch.clientX - rect.left;\r\n\t\t\t\t\t\tvar y = touch.clientY - rect.top;\r\n\t\t\t\t\t\t_this.currTouch = _this.touchesPool.obtain();\r\n\t\t\t\t\t\t_this.currTouch.identifier = touch.identifier;\r\n\t\t\t\t\t\t_this.currTouch.x = x;\r\n\t\t\t\t\t\t_this.currTouch.y = y;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar listeners = _this.listeners;\r\n\t\t\t\t\tfor (var i_8 = 0; i_8 < listeners.length; i_8++) {\r\n\t\t\t\t\t\tlisteners[i_8].down(_this.currTouch.x, _this.currTouch.y);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconsole.log(\"Start \" + _this.currTouch.x + \", \" + _this.currTouch.y);\r\n\t\t\t\t\t_this.lastX = _this.currTouch.x;\r\n\t\t\t\t\t_this.lastY = _this.currTouch.y;\r\n\t\t\t\t\t_this.buttonDown = true;\r\n\t\t\t\t\tev.preventDefault();\r\n\t\t\t\t}, false);\r\n\t\t\t\telement.addEventListener(\"touchend\", function (ev) {\r\n\t\t\t\t\tvar touches = ev.changedTouches;\r\n\t\t\t\t\tfor (var i = 0; i < touches.length; i++) {\r\n\t\t\t\t\t\tvar touch = touches[i];\r\n\t\t\t\t\t\tif (_this.currTouch.identifier === touch.identifier) {\r\n\t\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\r\n\t\t\t\t\t\t\tvar x = _this.currTouch.x = touch.clientX - rect.left;\r\n\t\t\t\t\t\t\tvar y = _this.currTouch.y = touch.clientY - rect.top;\r\n\t\t\t\t\t\t\t_this.touchesPool.free(_this.currTouch);\r\n\t\t\t\t\t\t\tvar listeners = _this.listeners;\r\n\t\t\t\t\t\t\tfor (var i_9 = 0; i_9 < listeners.length; i_9++) {\r\n\t\t\t\t\t\t\t\tlisteners[i_9].up(x, y);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconsole.log(\"End \" + x + \", \" + y);\r\n\t\t\t\t\t\t\t_this.lastX = x;\r\n\t\t\t\t\t\t\t_this.lastY = y;\r\n\t\t\t\t\t\t\t_this.buttonDown = false;\r\n\t\t\t\t\t\t\t_this.currTouch = null;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tev.preventDefault();\r\n\t\t\t\t}, false);\r\n\t\t\t\telement.addEventListener(\"touchcancel\", function (ev) {\r\n\t\t\t\t\tvar touches = ev.changedTouches;\r\n\t\t\t\t\tfor (var i = 0; i < touches.length; i++) {\r\n\t\t\t\t\t\tvar touch = touches[i];\r\n\t\t\t\t\t\tif (_this.currTouch.identifier === touch.identifier) {\r\n\t\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\r\n\t\t\t\t\t\t\tvar x = _this.currTouch.x = touch.clientX - rect.left;\r\n\t\t\t\t\t\t\tvar y = _this.currTouch.y = touch.clientY - rect.top;\r\n\t\t\t\t\t\t\t_this.touchesPool.free(_this.currTouch);\r\n\t\t\t\t\t\t\tvar listeners = _this.listeners;\r\n\t\t\t\t\t\t\tfor (var i_10 = 0; i_10 < listeners.length; i_10++) {\r\n\t\t\t\t\t\t\t\tlisteners[i_10].up(x, y);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconsole.log(\"End \" + x + \", \" + y);\r\n\t\t\t\t\t\t\t_this.lastX = x;\r\n\t\t\t\t\t\t\t_this.lastY = y;\r\n\t\t\t\t\t\t\t_this.buttonDown = false;\r\n\t\t\t\t\t\t\t_this.currTouch = null;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tev.preventDefault();\r\n\t\t\t\t}, false);\r\n\t\t\t\telement.addEventListener(\"touchmove\", function (ev) {\r\n\t\t\t\t\tif (_this.currTouch == null)\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tvar touches = ev.changedTouches;\r\n\t\t\t\t\tfor (var i = 0; i < touches.length; i++) {\r\n\t\t\t\t\t\tvar touch = touches[i];\r\n\t\t\t\t\t\tif (_this.currTouch.identifier === touch.identifier) {\r\n\t\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\r\n\t\t\t\t\t\t\tvar x = touch.clientX - rect.left;\r\n\t\t\t\t\t\t\tvar y = touch.clientY - rect.top;\r\n\t\t\t\t\t\t\tvar listeners = _this.listeners;\r\n\t\t\t\t\t\t\tfor (var i_11 = 0; i_11 < listeners.length; i_11++) {\r\n\t\t\t\t\t\t\t\tlisteners[i_11].dragged(x, y);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconsole.log(\"Drag \" + x + \", \" + y);\r\n\t\t\t\t\t\t\t_this.lastX = _this.currTouch.x = x;\r\n\t\t\t\t\t\t\t_this.lastY = _this.currTouch.y = y;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tev.preventDefault();\r\n\t\t\t\t}, false);\r\n\t\t\t};\r\n\t\t\tInput.prototype.addListener = function (listener) {\r\n\t\t\t\tthis.listeners.push(listener);\r\n\t\t\t};\r\n\t\t\tInput.prototype.removeListener = function (listener) {\r\n\t\t\t\tvar idx = this.listeners.indexOf(listener);\r\n\t\t\t\tif (idx > -1) {\r\n\t\t\t\t\tthis.listeners.splice(idx, 1);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treturn Input;\r\n\t\t}());\r\n\t\twebgl.Input = Input;\r\n\t\tvar Touch = (function () {\r\n\t\t\tfunction Touch(identifier, x, y) {\r\n\t\t\t\tthis.identifier = identifier;\r\n\t\t\t\tthis.x = x;\r\n\t\t\t\tthis.y = y;\r\n\t\t\t}\r\n\t\t\treturn Touch;\r\n\t\t}());\r\n\t\twebgl.Touch = Touch;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar LoadingScreen = (function () {\r\n\t\t\tfunction LoadingScreen(renderer) {\r\n\t\t\t\tthis.logo = null;\r\n\t\t\t\tthis.spinner = null;\r\n\t\t\t\tthis.angle = 0;\r\n\t\t\t\tthis.fadeOut = 0;\r\n\t\t\t\tthis.timeKeeper = new spine.TimeKeeper();\r\n\t\t\t\tthis.backgroundColor = new spine.Color(0.135, 0.135, 0.135, 1);\r\n\t\t\t\tthis.tempColor = new spine.Color();\r\n\t\t\t\tthis.firstDraw = 0;\r\n\t\t\t\tthis.renderer = renderer;\r\n\t\t\t\tthis.timeKeeper.maxDelta = 9;\r\n\t\t\t\tif (LoadingScreen.logoImg === null) {\r\n\t\t\t\t\tvar isSafari = navigator.userAgent.indexOf(\"Safari\") > -1;\r\n\t\t\t\t\tLoadingScreen.logoImg = new Image();\r\n\t\t\t\t\tLoadingScreen.logoImg.src = LoadingScreen.SPINE_LOGO_DATA;\r\n\t\t\t\t\tif (!isSafari)\r\n\t\t\t\t\t\tLoadingScreen.logoImg.crossOrigin = \"anonymous\";\r\n\t\t\t\t\tLoadingScreen.logoImg.onload = function (ev) {\r\n\t\t\t\t\t\tLoadingScreen.loaded++;\r\n\t\t\t\t\t};\r\n\t\t\t\t\tLoadingScreen.spinnerImg = new Image();\r\n\t\t\t\t\tLoadingScreen.spinnerImg.src = LoadingScreen.SPINNER_DATA;\r\n\t\t\t\t\tif (!isSafari)\r\n\t\t\t\t\t\tLoadingScreen.spinnerImg.crossOrigin = \"anonymous\";\r\n\t\t\t\t\tLoadingScreen.spinnerImg.onload = function (ev) {\r\n\t\t\t\t\t\tLoadingScreen.loaded++;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tLoadingScreen.prototype.draw = function (complete) {\r\n\t\t\t\tif (complete === void 0) { complete = false; }\r\n\t\t\t\tif (complete && this.fadeOut > LoadingScreen.FADE_SECONDS)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tthis.timeKeeper.update();\r\n\t\t\t\tvar a = Math.abs(Math.sin(this.timeKeeper.totalTime + 0.75));\r\n\t\t\t\tthis.angle -= this.timeKeeper.delta * 360 * (1 + 1.5 * Math.pow(a, 5));\r\n\t\t\t\tvar renderer = this.renderer;\r\n\t\t\t\tvar canvas = renderer.canvas;\r\n\t\t\t\tvar gl = renderer.context.gl;\r\n\t\t\t\tvar oldX = renderer.camera.position.x, oldY = renderer.camera.position.y;\r\n\t\t\t\trenderer.camera.position.set(canvas.width / 2, canvas.height / 2, 0);\r\n\t\t\t\trenderer.camera.viewportWidth = canvas.width;\r\n\t\t\t\trenderer.camera.viewportHeight = canvas.height;\r\n\t\t\t\trenderer.resize(webgl.ResizeMode.Stretch);\r\n\t\t\t\tif (!complete) {\r\n\t\t\t\t\tgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);\r\n\t\t\t\t\tgl.clear(gl.COLOR_BUFFER_BIT);\r\n\t\t\t\t\tthis.tempColor.a = 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.fadeOut += this.timeKeeper.delta * (this.timeKeeper.totalTime < 1 ? 2 : 1);\r\n\t\t\t\t\tif (this.fadeOut > LoadingScreen.FADE_SECONDS) {\r\n\t\t\t\t\t\trenderer.camera.position.set(oldX, oldY, 0);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ta = 1 - this.fadeOut / LoadingScreen.FADE_SECONDS;\r\n\t\t\t\t\tthis.tempColor.setFromColor(this.backgroundColor);\r\n\t\t\t\t\tthis.tempColor.a = 1 - (a - 1) * (a - 1);\r\n\t\t\t\t\trenderer.begin();\r\n\t\t\t\t\trenderer.quad(true, 0, 0, canvas.width, 0, canvas.width, canvas.height, 0, canvas.height, this.tempColor, this.tempColor, this.tempColor, this.tempColor);\r\n\t\t\t\t\trenderer.end();\r\n\t\t\t\t}\r\n\t\t\t\tthis.tempColor.set(1, 1, 1, this.tempColor.a);\r\n\t\t\t\tif (LoadingScreen.loaded != 2)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tif (this.logo === null) {\r\n\t\t\t\t\tthis.logo = new webgl.GLTexture(renderer.context, LoadingScreen.logoImg);\r\n\t\t\t\t\tthis.spinner = new webgl.GLTexture(renderer.context, LoadingScreen.spinnerImg);\r\n\t\t\t\t}\r\n\t\t\t\tthis.logo.update(false);\r\n\t\t\t\tthis.spinner.update(false);\r\n\t\t\t\tvar logoWidth = this.logo.getImage().width;\r\n\t\t\t\tvar logoHeight = this.logo.getImage().height;\r\n\t\t\t\tvar spinnerWidth = this.spinner.getImage().width;\r\n\t\t\t\tvar spinnerHeight = this.spinner.getImage().height;\r\n\t\t\t\trenderer.batcher.setBlendMode(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n\t\t\t\trenderer.begin();\r\n\t\t\t\trenderer.drawTexture(this.logo, (canvas.width - logoWidth) / 2, (canvas.height - logoHeight) / 2, logoWidth, logoHeight, this.tempColor);\r\n\t\t\t\trenderer.drawTextureRotated(this.spinner, (canvas.width - spinnerWidth) / 2, (canvas.height - spinnerHeight) / 2, spinnerWidth, spinnerHeight, spinnerWidth / 2, spinnerHeight / 2, this.angle, this.tempColor);\r\n\t\t\t\trenderer.end();\r\n\t\t\t\trenderer.camera.position.set(oldX, oldY, 0);\r\n\t\t\t};\r\n\t\t\tLoadingScreen.FADE_SECONDS = 1;\r\n\t\t\tLoadingScreen.loaded = 0;\r\n\t\t\tLoadingScreen.spinnerImg = null;\r\n\t\t\tLoadingScreen.logoImg = null;\r\n\t\t\tLoadingScreen.SPINNER_DATA = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAChCAMAAAB3TUS6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAYNQTFRFAAAA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AAkTDRyAAAAIB0Uk5TAAABAgMEBQYHCAkKCwwODxAREhMUFRYXGBkaHB0eICEiIyQlJicoKSorLC0uLzAxMjM0Nzg5Ojs8PT4/QEFDRUlKS0xNTk9QUlRWWFlbXF1eYWJjZmhscHF0d3h5e3x+f4CIiYuMj5GSlJWXm56io6arr7rAxcjO0dXe6Onr8fmb5sOOAAADuElEQVQYGe3B+3vTVBwH4M/3nCRt13br2Lozhug2q25gYQubcxqVKYoMCYoKjEsUdSpeiBc0Kl7yp9t2za39pely7PF5zvuiQKc+/e2f8K+f9g2oyQ77Ag4VGX+HketQ0XYYe0JQ0CdhogwF+WFiBgr6JkxUoKCDMMGgoP0w9gdUtB3GfoCKVsPYAVQ0H8YuQUWVMHYGKuJhrAklPQkjJpT0bdj3O9S0FfZ9ADXxP8MjVSiqFfa8B2VVV8+df14QtB4iwn+BpuZEgyM38WMQHDYhnbkgukrIh5ygZ48glyn6KshlL+jbhVRcxCzk0ApiC5CI5kVsgTAy9jiI/WxBGmqIFBMjqwYphwRZaiLNwsjqQdoVSFISGRwjM4OMFUjBRcYCYWT0XZD2SwUS0LzIKCGH2SDja0LxKiJjCrm0gowVFI6aIs1CTouPg5QvUTgSKXMMuVUeBSmEopFITBPGwO8HCYbCTYtImTAWejuI3CMUjmZFT5NjbM/9GvQcMkhADdFRIxxD7aug4wGDFGSVTcLx0MzutQ2CpmmapmmapmmapmmapmmaphWBmGFV6rNNcaLC0GUuv3LROftUo8wJk0a10207sVED6IIf+9673LIwQeW2PaCEJX/A+xYmhTbtQUu46g96SJgQZg9Zwxf+EAMTwuwhm3jkD7EwIdweBn+YhQlh9pA2HvpDTEwIs4es4GN/CMekNOxBJ9D2B10nTAyfW7fT1hjYgZ/xYIUwUcycaiwuv2h3tOcZADr7ud/12c0ru2cWSwQ1UAcixIgImqZpmqZpmqZpmqZpmqZp2v8HMSIcF186t8oghbnlOJt1wnHwl7yOGxwSlHacrjWG8dVuej03OApn7jhHtiyMiZa9yD6haLYTebWOsbDXvQRHwchJWSTkV/rQS+EoWttJaTHkJe56KXcJRZt20jY48nnBy9hE4WjLSbvAkIfwMm5zFG/KyWgRRke3vYwGZDjpZHCMruJltCAFrTtpVYxu1ktzCHKwbSdlGqOreynXGGQpOylljI5uebFbBuSZc2IbhBxmvcj9GiSiZ52+HQO5nPb6TkIqajs9L5eQk7jnddxZgGT0jNOxYSI36+Kdj9oG5OPV6QpB6yJuGAYnqIrecLveYlDUKffIOtREl90+BiWV3cgMlNR0I09DSS030oaSttzILpT0phu5BBWRmyAoiLkJgoIMN8GgoJKb4FBQzU0YUFDdTRhQUNVNcCjIdBMEBdE7buQ8lFRz+97lUFN5fe+qu//aMkeB/gU2ae9y2HgbngAAAABJRU5ErkJggg==\";\r\n\t\t\tLoadingScreen.SPINE_LOGO_DATA = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFIAAAAZCAYAAACis3k0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAtNJREFUaN7tmT2I1EAUxwN+oWgRT0HFKo0WCkJ6ObmAWFwZbCxsXGysLNJaiCyIoDaSwk4ETzvhmnBaCRbBWoQ01ho4PwotjP8cE337mMy8TLK757mBH3fLTWbe/PbN53neNniqZW8FvAVvQAqugwvgDDgO9niLRyTyJagM/ACPF6bsIl9ZRDac/Cc6tLn5xQdRQ496QlKPLxD5QCDxO9jtGM8QfYoIgUlgCipGCRJL5VvlyOdCU09iEXkCfLSIfCrs7Fab6nOsiafu06iDwES9w/uU1QnDC+ekkVS9vEaDsgVeB0d+z1VDtOGxRaYPboP3Gokb4GgXkZp4chZPJKgvZ3U0XkriK/TIt9YUDllFgTAjGwoaoHqfBhMI58yD4BQ4V6/aHYdfxToftvw9F2SiVroawU2/Cv5C4Thv0KB9S5nxlOd4STxjwUjzSdYlgrYijw2BsEfgsaFcM09lhiys94xXQQwugcvgJrgFLjrEE7WUiTuWCQzt/ZXN7FfqGwuGClyVy2xZAFmfDQvNtwFFSspMDGsD+UTWqu1KoVmVooFEJgKRXw0if85RpISEzwsjzeqWzkjkC4PIJ3MUmQgITAHlQwTFhnZhELkEntfZRwR+AvfAgXmJHOqU02XligWT8ppg67NXbdCXeq7afUQ6L8C2DalEZNt2YyQ94Qy8/ekjMpBMbfyl5iTjG7YAI8cNecROAb4kJmTjaXAF3AGvwQewOiuRxEtlSaT4j2h2lMsUueQEoMlIKpTvAmKhxPMtC876jEX6rE8l8TNx/KVbn6xlWU9NWcSDUsO4NGWpQOTZFpHPOooMXcswmW2XFk3ixb2v0Nq+XVKP00QNaffBLyWwBI/AkTlfMYZDXMf12kc6yjwEjoFdO/5me5oi/6tnyhlZX6OtgmX1c2Uh0k3khmbB2b9TRfpd/jfTUeRDJvHdYg5wE7kPXAN3wQ1weDvH+xufEgpi5qIl3QAAAABJRU5ErkJggg==\";\r\n\t\t\treturn LoadingScreen;\r\n\t\t}());\r\n\t\twebgl.LoadingScreen = LoadingScreen;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\twebgl.M00 = 0;\r\n\t\twebgl.M01 = 4;\r\n\t\twebgl.M02 = 8;\r\n\t\twebgl.M03 = 12;\r\n\t\twebgl.M10 = 1;\r\n\t\twebgl.M11 = 5;\r\n\t\twebgl.M12 = 9;\r\n\t\twebgl.M13 = 13;\r\n\t\twebgl.M20 = 2;\r\n\t\twebgl.M21 = 6;\r\n\t\twebgl.M22 = 10;\r\n\t\twebgl.M23 = 14;\r\n\t\twebgl.M30 = 3;\r\n\t\twebgl.M31 = 7;\r\n\t\twebgl.M32 = 11;\r\n\t\twebgl.M33 = 15;\r\n\t\tvar Matrix4 = (function () {\r\n\t\t\tfunction Matrix4() {\r\n\t\t\t\tthis.temp = new Float32Array(16);\r\n\t\t\t\tthis.values = new Float32Array(16);\r\n\t\t\t\tvar v = this.values;\r\n\t\t\t\tv[webgl.M00] = 1;\r\n\t\t\t\tv[webgl.M11] = 1;\r\n\t\t\t\tv[webgl.M22] = 1;\r\n\t\t\t\tv[webgl.M33] = 1;\r\n\t\t\t}\r\n\t\t\tMatrix4.prototype.set = function (values) {\r\n\t\t\t\tthis.values.set(values);\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.transpose = function () {\r\n\t\t\t\tvar t = this.temp;\r\n\t\t\t\tvar v = this.values;\r\n\t\t\t\tt[webgl.M00] = v[webgl.M00];\r\n\t\t\t\tt[webgl.M01] = v[webgl.M10];\r\n\t\t\t\tt[webgl.M02] = v[webgl.M20];\r\n\t\t\t\tt[webgl.M03] = v[webgl.M30];\r\n\t\t\t\tt[webgl.M10] = v[webgl.M01];\r\n\t\t\t\tt[webgl.M11] = v[webgl.M11];\r\n\t\t\t\tt[webgl.M12] = v[webgl.M21];\r\n\t\t\t\tt[webgl.M13] = v[webgl.M31];\r\n\t\t\t\tt[webgl.M20] = v[webgl.M02];\r\n\t\t\t\tt[webgl.M21] = v[webgl.M12];\r\n\t\t\t\tt[webgl.M22] = v[webgl.M22];\r\n\t\t\t\tt[webgl.M23] = v[webgl.M32];\r\n\t\t\t\tt[webgl.M30] = v[webgl.M03];\r\n\t\t\t\tt[webgl.M31] = v[webgl.M13];\r\n\t\t\t\tt[webgl.M32] = v[webgl.M23];\r\n\t\t\t\tt[webgl.M33] = v[webgl.M33];\r\n\t\t\t\treturn this.set(t);\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.identity = function () {\r\n\t\t\t\tvar v = this.values;\r\n\t\t\t\tv[webgl.M00] = 1;\r\n\t\t\t\tv[webgl.M01] = 0;\r\n\t\t\t\tv[webgl.M02] = 0;\r\n\t\t\t\tv[webgl.M03] = 0;\r\n\t\t\t\tv[webgl.M10] = 0;\r\n\t\t\t\tv[webgl.M11] = 1;\r\n\t\t\t\tv[webgl.M12] = 0;\r\n\t\t\t\tv[webgl.M13] = 0;\r\n\t\t\t\tv[webgl.M20] = 0;\r\n\t\t\t\tv[webgl.M21] = 0;\r\n\t\t\t\tv[webgl.M22] = 1;\r\n\t\t\t\tv[webgl.M23] = 0;\r\n\t\t\t\tv[webgl.M30] = 0;\r\n\t\t\t\tv[webgl.M31] = 0;\r\n\t\t\t\tv[webgl.M32] = 0;\r\n\t\t\t\tv[webgl.M33] = 1;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.invert = function () {\r\n\t\t\t\tvar v = this.values;\r\n\t\t\t\tvar t = this.temp;\r\n\t\t\t\tvar l_det = v[webgl.M30] * v[webgl.M21] * v[webgl.M12] * v[webgl.M03] - v[webgl.M20] * v[webgl.M31] * v[webgl.M12] * v[webgl.M03] - v[webgl.M30] * v[webgl.M11] * v[webgl.M22] * v[webgl.M03]\r\n\t\t\t\t\t+ v[webgl.M10] * v[webgl.M31] * v[webgl.M22] * v[webgl.M03] + v[webgl.M20] * v[webgl.M11] * v[webgl.M32] * v[webgl.M03] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32] * v[webgl.M03]\r\n\t\t\t\t\t- v[webgl.M30] * v[webgl.M21] * v[webgl.M02] * v[webgl.M13] + v[webgl.M20] * v[webgl.M31] * v[webgl.M02] * v[webgl.M13] + v[webgl.M30] * v[webgl.M01] * v[webgl.M22] * v[webgl.M13]\r\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M31] * v[webgl.M22] * v[webgl.M13] - v[webgl.M20] * v[webgl.M01] * v[webgl.M32] * v[webgl.M13] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32] * v[webgl.M13]\r\n\t\t\t\t\t+ v[webgl.M30] * v[webgl.M11] * v[webgl.M02] * v[webgl.M23] - v[webgl.M10] * v[webgl.M31] * v[webgl.M02] * v[webgl.M23] - v[webgl.M30] * v[webgl.M01] * v[webgl.M12] * v[webgl.M23]\r\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M31] * v[webgl.M12] * v[webgl.M23] + v[webgl.M10] * v[webgl.M01] * v[webgl.M32] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32] * v[webgl.M23]\r\n\t\t\t\t\t- v[webgl.M20] * v[webgl.M11] * v[webgl.M02] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M02] * v[webgl.M33] + v[webgl.M20] * v[webgl.M01] * v[webgl.M12] * v[webgl.M33]\r\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M21] * v[webgl.M12] * v[webgl.M33] - v[webgl.M10] * v[webgl.M01] * v[webgl.M22] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\r\n\t\t\t\tif (l_det == 0)\r\n\t\t\t\t\tthrow new Error(\"non-invertible matrix\");\r\n\t\t\t\tvar inv_det = 1.0 / l_det;\r\n\t\t\t\tt[webgl.M00] = v[webgl.M12] * v[webgl.M23] * v[webgl.M31] - v[webgl.M13] * v[webgl.M22] * v[webgl.M31] + v[webgl.M13] * v[webgl.M21] * v[webgl.M32]\r\n\t\t\t\t\t- v[webgl.M11] * v[webgl.M23] * v[webgl.M32] - v[webgl.M12] * v[webgl.M21] * v[webgl.M33] + v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M01] = v[webgl.M03] * v[webgl.M22] * v[webgl.M31] - v[webgl.M02] * v[webgl.M23] * v[webgl.M31] - v[webgl.M03] * v[webgl.M21] * v[webgl.M32]\r\n\t\t\t\t\t+ v[webgl.M01] * v[webgl.M23] * v[webgl.M32] + v[webgl.M02] * v[webgl.M21] * v[webgl.M33] - v[webgl.M01] * v[webgl.M22] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M02] = v[webgl.M02] * v[webgl.M13] * v[webgl.M31] - v[webgl.M03] * v[webgl.M12] * v[webgl.M31] + v[webgl.M03] * v[webgl.M11] * v[webgl.M32]\r\n\t\t\t\t\t- v[webgl.M01] * v[webgl.M13] * v[webgl.M32] - v[webgl.M02] * v[webgl.M11] * v[webgl.M33] + v[webgl.M01] * v[webgl.M12] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M03] = v[webgl.M03] * v[webgl.M12] * v[webgl.M21] - v[webgl.M02] * v[webgl.M13] * v[webgl.M21] - v[webgl.M03] * v[webgl.M11] * v[webgl.M22]\r\n\t\t\t\t\t+ v[webgl.M01] * v[webgl.M13] * v[webgl.M22] + v[webgl.M02] * v[webgl.M11] * v[webgl.M23] - v[webgl.M01] * v[webgl.M12] * v[webgl.M23];\r\n\t\t\t\tt[webgl.M10] = v[webgl.M13] * v[webgl.M22] * v[webgl.M30] - v[webgl.M12] * v[webgl.M23] * v[webgl.M30] - v[webgl.M13] * v[webgl.M20] * v[webgl.M32]\r\n\t\t\t\t\t+ v[webgl.M10] * v[webgl.M23] * v[webgl.M32] + v[webgl.M12] * v[webgl.M20] * v[webgl.M33] - v[webgl.M10] * v[webgl.M22] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M11] = v[webgl.M02] * v[webgl.M23] * v[webgl.M30] - v[webgl.M03] * v[webgl.M22] * v[webgl.M30] + v[webgl.M03] * v[webgl.M20] * v[webgl.M32]\r\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M23] * v[webgl.M32] - v[webgl.M02] * v[webgl.M20] * v[webgl.M33] + v[webgl.M00] * v[webgl.M22] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M12] = v[webgl.M03] * v[webgl.M12] * v[webgl.M30] - v[webgl.M02] * v[webgl.M13] * v[webgl.M30] - v[webgl.M03] * v[webgl.M10] * v[webgl.M32]\r\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M13] * v[webgl.M32] + v[webgl.M02] * v[webgl.M10] * v[webgl.M33] - v[webgl.M00] * v[webgl.M12] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M13] = v[webgl.M02] * v[webgl.M13] * v[webgl.M20] - v[webgl.M03] * v[webgl.M12] * v[webgl.M20] + v[webgl.M03] * v[webgl.M10] * v[webgl.M22]\r\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M13] * v[webgl.M22] - v[webgl.M02] * v[webgl.M10] * v[webgl.M23] + v[webgl.M00] * v[webgl.M12] * v[webgl.M23];\r\n\t\t\t\tt[webgl.M20] = v[webgl.M11] * v[webgl.M23] * v[webgl.M30] - v[webgl.M13] * v[webgl.M21] * v[webgl.M30] + v[webgl.M13] * v[webgl.M20] * v[webgl.M31]\r\n\t\t\t\t\t- v[webgl.M10] * v[webgl.M23] * v[webgl.M31] - v[webgl.M11] * v[webgl.M20] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M21] = v[webgl.M03] * v[webgl.M21] * v[webgl.M30] - v[webgl.M01] * v[webgl.M23] * v[webgl.M30] - v[webgl.M03] * v[webgl.M20] * v[webgl.M31]\r\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M23] * v[webgl.M31] + v[webgl.M01] * v[webgl.M20] * v[webgl.M33] - v[webgl.M00] * v[webgl.M21] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M22] = v[webgl.M01] * v[webgl.M13] * v[webgl.M30] - v[webgl.M03] * v[webgl.M11] * v[webgl.M30] + v[webgl.M03] * v[webgl.M10] * v[webgl.M31]\r\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M13] * v[webgl.M31] - v[webgl.M01] * v[webgl.M10] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M23] = v[webgl.M03] * v[webgl.M11] * v[webgl.M20] - v[webgl.M01] * v[webgl.M13] * v[webgl.M20] - v[webgl.M03] * v[webgl.M10] * v[webgl.M21]\r\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M13] * v[webgl.M21] + v[webgl.M01] * v[webgl.M10] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M23];\r\n\t\t\t\tt[webgl.M30] = v[webgl.M12] * v[webgl.M21] * v[webgl.M30] - v[webgl.M11] * v[webgl.M22] * v[webgl.M30] - v[webgl.M12] * v[webgl.M20] * v[webgl.M31]\r\n\t\t\t\t\t+ v[webgl.M10] * v[webgl.M22] * v[webgl.M31] + v[webgl.M11] * v[webgl.M20] * v[webgl.M32] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32];\r\n\t\t\t\tt[webgl.M31] = v[webgl.M01] * v[webgl.M22] * v[webgl.M30] - v[webgl.M02] * v[webgl.M21] * v[webgl.M30] + v[webgl.M02] * v[webgl.M20] * v[webgl.M31]\r\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M22] * v[webgl.M31] - v[webgl.M01] * v[webgl.M20] * v[webgl.M32] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32];\r\n\t\t\t\tt[webgl.M32] = v[webgl.M02] * v[webgl.M11] * v[webgl.M30] - v[webgl.M01] * v[webgl.M12] * v[webgl.M30] - v[webgl.M02] * v[webgl.M10] * v[webgl.M31]\r\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M12] * v[webgl.M31] + v[webgl.M01] * v[webgl.M10] * v[webgl.M32] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32];\r\n\t\t\t\tt[webgl.M33] = v[webgl.M01] * v[webgl.M12] * v[webgl.M20] - v[webgl.M02] * v[webgl.M11] * v[webgl.M20] + v[webgl.M02] * v[webgl.M10] * v[webgl.M21]\r\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M12] * v[webgl.M21] - v[webgl.M01] * v[webgl.M10] * v[webgl.M22] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22];\r\n\t\t\t\tv[webgl.M00] = t[webgl.M00] * inv_det;\r\n\t\t\t\tv[webgl.M01] = t[webgl.M01] * inv_det;\r\n\t\t\t\tv[webgl.M02] = t[webgl.M02] * inv_det;\r\n\t\t\t\tv[webgl.M03] = t[webgl.M03] * inv_det;\r\n\t\t\t\tv[webgl.M10] = t[webgl.M10] * inv_det;\r\n\t\t\t\tv[webgl.M11] = t[webgl.M11] * inv_det;\r\n\t\t\t\tv[webgl.M12] = t[webgl.M12] * inv_det;\r\n\t\t\t\tv[webgl.M13] = t[webgl.M13] * inv_det;\r\n\t\t\t\tv[webgl.M20] = t[webgl.M20] * inv_det;\r\n\t\t\t\tv[webgl.M21] = t[webgl.M21] * inv_det;\r\n\t\t\t\tv[webgl.M22] = t[webgl.M22] * inv_det;\r\n\t\t\t\tv[webgl.M23] = t[webgl.M23] * inv_det;\r\n\t\t\t\tv[webgl.M30] = t[webgl.M30] * inv_det;\r\n\t\t\t\tv[webgl.M31] = t[webgl.M31] * inv_det;\r\n\t\t\t\tv[webgl.M32] = t[webgl.M32] * inv_det;\r\n\t\t\t\tv[webgl.M33] = t[webgl.M33] * inv_det;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.determinant = function () {\r\n\t\t\t\tvar v = this.values;\r\n\t\t\t\treturn v[webgl.M30] * v[webgl.M21] * v[webgl.M12] * v[webgl.M03] - v[webgl.M20] * v[webgl.M31] * v[webgl.M12] * v[webgl.M03] - v[webgl.M30] * v[webgl.M11] * v[webgl.M22] * v[webgl.M03]\r\n\t\t\t\t\t+ v[webgl.M10] * v[webgl.M31] * v[webgl.M22] * v[webgl.M03] + v[webgl.M20] * v[webgl.M11] * v[webgl.M32] * v[webgl.M03] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32] * v[webgl.M03]\r\n\t\t\t\t\t- v[webgl.M30] * v[webgl.M21] * v[webgl.M02] * v[webgl.M13] + v[webgl.M20] * v[webgl.M31] * v[webgl.M02] * v[webgl.M13] + v[webgl.M30] * v[webgl.M01] * v[webgl.M22] * v[webgl.M13]\r\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M31] * v[webgl.M22] * v[webgl.M13] - v[webgl.M20] * v[webgl.M01] * v[webgl.M32] * v[webgl.M13] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32] * v[webgl.M13]\r\n\t\t\t\t\t+ v[webgl.M30] * v[webgl.M11] * v[webgl.M02] * v[webgl.M23] - v[webgl.M10] * v[webgl.M31] * v[webgl.M02] * v[webgl.M23] - v[webgl.M30] * v[webgl.M01] * v[webgl.M12] * v[webgl.M23]\r\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M31] * v[webgl.M12] * v[webgl.M23] + v[webgl.M10] * v[webgl.M01] * v[webgl.M32] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32] * v[webgl.M23]\r\n\t\t\t\t\t- v[webgl.M20] * v[webgl.M11] * v[webgl.M02] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M02] * v[webgl.M33] + v[webgl.M20] * v[webgl.M01] * v[webgl.M12] * v[webgl.M33]\r\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M21] * v[webgl.M12] * v[webgl.M33] - v[webgl.M10] * v[webgl.M01] * v[webgl.M22] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.translate = function (x, y, z) {\r\n\t\t\t\tvar v = this.values;\r\n\t\t\t\tv[webgl.M03] += x;\r\n\t\t\t\tv[webgl.M13] += y;\r\n\t\t\t\tv[webgl.M23] += z;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.copy = function () {\r\n\t\t\t\treturn new Matrix4().set(this.values);\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.projection = function (near, far, fovy, aspectRatio) {\r\n\t\t\t\tthis.identity();\r\n\t\t\t\tvar l_fd = (1.0 / Math.tan((fovy * (Math.PI / 180)) / 2.0));\r\n\t\t\t\tvar l_a1 = (far + near) / (near - far);\r\n\t\t\t\tvar l_a2 = (2 * far * near) / (near - far);\r\n\t\t\t\tvar v = this.values;\r\n\t\t\t\tv[webgl.M00] = l_fd / aspectRatio;\r\n\t\t\t\tv[webgl.M10] = 0;\r\n\t\t\t\tv[webgl.M20] = 0;\r\n\t\t\t\tv[webgl.M30] = 0;\r\n\t\t\t\tv[webgl.M01] = 0;\r\n\t\t\t\tv[webgl.M11] = l_fd;\r\n\t\t\t\tv[webgl.M21] = 0;\r\n\t\t\t\tv[webgl.M31] = 0;\r\n\t\t\t\tv[webgl.M02] = 0;\r\n\t\t\t\tv[webgl.M12] = 0;\r\n\t\t\t\tv[webgl.M22] = l_a1;\r\n\t\t\t\tv[webgl.M32] = -1;\r\n\t\t\t\tv[webgl.M03] = 0;\r\n\t\t\t\tv[webgl.M13] = 0;\r\n\t\t\t\tv[webgl.M23] = l_a2;\r\n\t\t\t\tv[webgl.M33] = 0;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.ortho2d = function (x, y, width, height) {\r\n\t\t\t\treturn this.ortho(x, x + width, y, y + height, 0, 1);\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.ortho = function (left, right, bottom, top, near, far) {\r\n\t\t\t\tthis.identity();\r\n\t\t\t\tvar x_orth = 2 / (right - left);\r\n\t\t\t\tvar y_orth = 2 / (top - bottom);\r\n\t\t\t\tvar z_orth = -2 / (far - near);\r\n\t\t\t\tvar tx = -(right + left) / (right - left);\r\n\t\t\t\tvar ty = -(top + bottom) / (top - bottom);\r\n\t\t\t\tvar tz = -(far + near) / (far - near);\r\n\t\t\t\tvar v = this.values;\r\n\t\t\t\tv[webgl.M00] = x_orth;\r\n\t\t\t\tv[webgl.M10] = 0;\r\n\t\t\t\tv[webgl.M20] = 0;\r\n\t\t\t\tv[webgl.M30] = 0;\r\n\t\t\t\tv[webgl.M01] = 0;\r\n\t\t\t\tv[webgl.M11] = y_orth;\r\n\t\t\t\tv[webgl.M21] = 0;\r\n\t\t\t\tv[webgl.M31] = 0;\r\n\t\t\t\tv[webgl.M02] = 0;\r\n\t\t\t\tv[webgl.M12] = 0;\r\n\t\t\t\tv[webgl.M22] = z_orth;\r\n\t\t\t\tv[webgl.M32] = 0;\r\n\t\t\t\tv[webgl.M03] = tx;\r\n\t\t\t\tv[webgl.M13] = ty;\r\n\t\t\t\tv[webgl.M23] = tz;\r\n\t\t\t\tv[webgl.M33] = 1;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.multiply = function (matrix) {\r\n\t\t\t\tvar t = this.temp;\r\n\t\t\t\tvar v = this.values;\r\n\t\t\t\tvar m = matrix.values;\r\n\t\t\t\tt[webgl.M00] = v[webgl.M00] * m[webgl.M00] + v[webgl.M01] * m[webgl.M10] + v[webgl.M02] * m[webgl.M20] + v[webgl.M03] * m[webgl.M30];\r\n\t\t\t\tt[webgl.M01] = v[webgl.M00] * m[webgl.M01] + v[webgl.M01] * m[webgl.M11] + v[webgl.M02] * m[webgl.M21] + v[webgl.M03] * m[webgl.M31];\r\n\t\t\t\tt[webgl.M02] = v[webgl.M00] * m[webgl.M02] + v[webgl.M01] * m[webgl.M12] + v[webgl.M02] * m[webgl.M22] + v[webgl.M03] * m[webgl.M32];\r\n\t\t\t\tt[webgl.M03] = v[webgl.M00] * m[webgl.M03] + v[webgl.M01] * m[webgl.M13] + v[webgl.M02] * m[webgl.M23] + v[webgl.M03] * m[webgl.M33];\r\n\t\t\t\tt[webgl.M10] = v[webgl.M10] * m[webgl.M00] + v[webgl.M11] * m[webgl.M10] + v[webgl.M12] * m[webgl.M20] + v[webgl.M13] * m[webgl.M30];\r\n\t\t\t\tt[webgl.M11] = v[webgl.M10] * m[webgl.M01] + v[webgl.M11] * m[webgl.M11] + v[webgl.M12] * m[webgl.M21] + v[webgl.M13] * m[webgl.M31];\r\n\t\t\t\tt[webgl.M12] = v[webgl.M10] * m[webgl.M02] + v[webgl.M11] * m[webgl.M12] + v[webgl.M12] * m[webgl.M22] + v[webgl.M13] * m[webgl.M32];\r\n\t\t\t\tt[webgl.M13] = v[webgl.M10] * m[webgl.M03] + v[webgl.M11] * m[webgl.M13] + v[webgl.M12] * m[webgl.M23] + v[webgl.M13] * m[webgl.M33];\r\n\t\t\t\tt[webgl.M20] = v[webgl.M20] * m[webgl.M00] + v[webgl.M21] * m[webgl.M10] + v[webgl.M22] * m[webgl.M20] + v[webgl.M23] * m[webgl.M30];\r\n\t\t\t\tt[webgl.M21] = v[webgl.M20] * m[webgl.M01] + v[webgl.M21] * m[webgl.M11] + v[webgl.M22] * m[webgl.M21] + v[webgl.M23] * m[webgl.M31];\r\n\t\t\t\tt[webgl.M22] = v[webgl.M20] * m[webgl.M02] + v[webgl.M21] * m[webgl.M12] + v[webgl.M22] * m[webgl.M22] + v[webgl.M23] * m[webgl.M32];\r\n\t\t\t\tt[webgl.M23] = v[webgl.M20] * m[webgl.M03] + v[webgl.M21] * m[webgl.M13] + v[webgl.M22] * m[webgl.M23] + v[webgl.M23] * m[webgl.M33];\r\n\t\t\t\tt[webgl.M30] = v[webgl.M30] * m[webgl.M00] + v[webgl.M31] * m[webgl.M10] + v[webgl.M32] * m[webgl.M20] + v[webgl.M33] * m[webgl.M30];\r\n\t\t\t\tt[webgl.M31] = v[webgl.M30] * m[webgl.M01] + v[webgl.M31] * m[webgl.M11] + v[webgl.M32] * m[webgl.M21] + v[webgl.M33] * m[webgl.M31];\r\n\t\t\t\tt[webgl.M32] = v[webgl.M30] * m[webgl.M02] + v[webgl.M31] * m[webgl.M12] + v[webgl.M32] * m[webgl.M22] + v[webgl.M33] * m[webgl.M32];\r\n\t\t\t\tt[webgl.M33] = v[webgl.M30] * m[webgl.M03] + v[webgl.M31] * m[webgl.M13] + v[webgl.M32] * m[webgl.M23] + v[webgl.M33] * m[webgl.M33];\r\n\t\t\t\treturn this.set(this.temp);\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.multiplyLeft = function (matrix) {\r\n\t\t\t\tvar t = this.temp;\r\n\t\t\t\tvar v = this.values;\r\n\t\t\t\tvar m = matrix.values;\r\n\t\t\t\tt[webgl.M00] = m[webgl.M00] * v[webgl.M00] + m[webgl.M01] * v[webgl.M10] + m[webgl.M02] * v[webgl.M20] + m[webgl.M03] * v[webgl.M30];\r\n\t\t\t\tt[webgl.M01] = m[webgl.M00] * v[webgl.M01] + m[webgl.M01] * v[webgl.M11] + m[webgl.M02] * v[webgl.M21] + m[webgl.M03] * v[webgl.M31];\r\n\t\t\t\tt[webgl.M02] = m[webgl.M00] * v[webgl.M02] + m[webgl.M01] * v[webgl.M12] + m[webgl.M02] * v[webgl.M22] + m[webgl.M03] * v[webgl.M32];\r\n\t\t\t\tt[webgl.M03] = m[webgl.M00] * v[webgl.M03] + m[webgl.M01] * v[webgl.M13] + m[webgl.M02] * v[webgl.M23] + m[webgl.M03] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M10] = m[webgl.M10] * v[webgl.M00] + m[webgl.M11] * v[webgl.M10] + m[webgl.M12] * v[webgl.M20] + m[webgl.M13] * v[webgl.M30];\r\n\t\t\t\tt[webgl.M11] = m[webgl.M10] * v[webgl.M01] + m[webgl.M11] * v[webgl.M11] + m[webgl.M12] * v[webgl.M21] + m[webgl.M13] * v[webgl.M31];\r\n\t\t\t\tt[webgl.M12] = m[webgl.M10] * v[webgl.M02] + m[webgl.M11] * v[webgl.M12] + m[webgl.M12] * v[webgl.M22] + m[webgl.M13] * v[webgl.M32];\r\n\t\t\t\tt[webgl.M13] = m[webgl.M10] * v[webgl.M03] + m[webgl.M11] * v[webgl.M13] + m[webgl.M12] * v[webgl.M23] + m[webgl.M13] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M20] = m[webgl.M20] * v[webgl.M00] + m[webgl.M21] * v[webgl.M10] + m[webgl.M22] * v[webgl.M20] + m[webgl.M23] * v[webgl.M30];\r\n\t\t\t\tt[webgl.M21] = m[webgl.M20] * v[webgl.M01] + m[webgl.M21] * v[webgl.M11] + m[webgl.M22] * v[webgl.M21] + m[webgl.M23] * v[webgl.M31];\r\n\t\t\t\tt[webgl.M22] = m[webgl.M20] * v[webgl.M02] + m[webgl.M21] * v[webgl.M12] + m[webgl.M22] * v[webgl.M22] + m[webgl.M23] * v[webgl.M32];\r\n\t\t\t\tt[webgl.M23] = m[webgl.M20] * v[webgl.M03] + m[webgl.M21] * v[webgl.M13] + m[webgl.M22] * v[webgl.M23] + m[webgl.M23] * v[webgl.M33];\r\n\t\t\t\tt[webgl.M30] = m[webgl.M30] * v[webgl.M00] + m[webgl.M31] * v[webgl.M10] + m[webgl.M32] * v[webgl.M20] + m[webgl.M33] * v[webgl.M30];\r\n\t\t\t\tt[webgl.M31] = m[webgl.M30] * v[webgl.M01] + m[webgl.M31] * v[webgl.M11] + m[webgl.M32] * v[webgl.M21] + m[webgl.M33] * v[webgl.M31];\r\n\t\t\t\tt[webgl.M32] = m[webgl.M30] * v[webgl.M02] + m[webgl.M31] * v[webgl.M12] + m[webgl.M32] * v[webgl.M22] + m[webgl.M33] * v[webgl.M32];\r\n\t\t\t\tt[webgl.M33] = m[webgl.M30] * v[webgl.M03] + m[webgl.M31] * v[webgl.M13] + m[webgl.M32] * v[webgl.M23] + m[webgl.M33] * v[webgl.M33];\r\n\t\t\t\treturn this.set(this.temp);\r\n\t\t\t};\r\n\t\t\tMatrix4.prototype.lookAt = function (position, direction, up) {\r\n\t\t\t\tMatrix4.initTemps();\r\n\t\t\t\tvar xAxis = Matrix4.xAxis, yAxis = Matrix4.yAxis, zAxis = Matrix4.zAxis;\r\n\t\t\t\tzAxis.setFrom(direction).normalize();\r\n\t\t\t\txAxis.setFrom(direction).normalize();\r\n\t\t\t\txAxis.cross(up).normalize();\r\n\t\t\t\tyAxis.setFrom(xAxis).cross(zAxis).normalize();\r\n\t\t\t\tthis.identity();\r\n\t\t\t\tvar val = this.values;\r\n\t\t\t\tval[webgl.M00] = xAxis.x;\r\n\t\t\t\tval[webgl.M01] = xAxis.y;\r\n\t\t\t\tval[webgl.M02] = xAxis.z;\r\n\t\t\t\tval[webgl.M10] = yAxis.x;\r\n\t\t\t\tval[webgl.M11] = yAxis.y;\r\n\t\t\t\tval[webgl.M12] = yAxis.z;\r\n\t\t\t\tval[webgl.M20] = -zAxis.x;\r\n\t\t\t\tval[webgl.M21] = -zAxis.y;\r\n\t\t\t\tval[webgl.M22] = -zAxis.z;\r\n\t\t\t\tMatrix4.tmpMatrix.identity();\r\n\t\t\t\tMatrix4.tmpMatrix.values[webgl.M03] = -position.x;\r\n\t\t\t\tMatrix4.tmpMatrix.values[webgl.M13] = -position.y;\r\n\t\t\t\tMatrix4.tmpMatrix.values[webgl.M23] = -position.z;\r\n\t\t\t\tthis.multiply(Matrix4.tmpMatrix);\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tMatrix4.initTemps = function () {\r\n\t\t\t\tif (Matrix4.xAxis === null)\r\n\t\t\t\t\tMatrix4.xAxis = new webgl.Vector3();\r\n\t\t\t\tif (Matrix4.yAxis === null)\r\n\t\t\t\t\tMatrix4.yAxis = new webgl.Vector3();\r\n\t\t\t\tif (Matrix4.zAxis === null)\r\n\t\t\t\t\tMatrix4.zAxis = new webgl.Vector3();\r\n\t\t\t};\r\n\t\t\tMatrix4.xAxis = null;\r\n\t\t\tMatrix4.yAxis = null;\r\n\t\t\tMatrix4.zAxis = null;\r\n\t\t\tMatrix4.tmpMatrix = new Matrix4();\r\n\t\t\treturn Matrix4;\r\n\t\t}());\r\n\t\twebgl.Matrix4 = Matrix4;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar Mesh = (function () {\r\n\t\t\tfunction Mesh(context, attributes, maxVertices, maxIndices) {\r\n\t\t\t\tthis.attributes = attributes;\r\n\t\t\t\tthis.verticesLength = 0;\r\n\t\t\t\tthis.dirtyVertices = false;\r\n\t\t\t\tthis.indicesLength = 0;\r\n\t\t\t\tthis.dirtyIndices = false;\r\n\t\t\t\tthis.elementsPerVertex = 0;\r\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n\t\t\t\tthis.elementsPerVertex = 0;\r\n\t\t\t\tfor (var i = 0; i < attributes.length; i++) {\r\n\t\t\t\t\tthis.elementsPerVertex += attributes[i].numElements;\r\n\t\t\t\t}\r\n\t\t\t\tthis.vertices = new Float32Array(maxVertices * this.elementsPerVertex);\r\n\t\t\t\tthis.indices = new Uint16Array(maxIndices);\r\n\t\t\t\tthis.context.addRestorable(this);\r\n\t\t\t}\r\n\t\t\tMesh.prototype.getAttributes = function () { return this.attributes; };\r\n\t\t\tMesh.prototype.maxVertices = function () { return this.vertices.length / this.elementsPerVertex; };\r\n\t\t\tMesh.prototype.numVertices = function () { return this.verticesLength / this.elementsPerVertex; };\r\n\t\t\tMesh.prototype.setVerticesLength = function (length) {\r\n\t\t\t\tthis.dirtyVertices = true;\r\n\t\t\t\tthis.verticesLength = length;\r\n\t\t\t};\r\n\t\t\tMesh.prototype.getVertices = function () { return this.vertices; };\r\n\t\t\tMesh.prototype.maxIndices = function () { return this.indices.length; };\r\n\t\t\tMesh.prototype.numIndices = function () { return this.indicesLength; };\r\n\t\t\tMesh.prototype.setIndicesLength = function (length) {\r\n\t\t\t\tthis.dirtyIndices = true;\r\n\t\t\t\tthis.indicesLength = length;\r\n\t\t\t};\r\n\t\t\tMesh.prototype.getIndices = function () { return this.indices; };\r\n\t\t\t;\r\n\t\t\tMesh.prototype.getVertexSizeInFloats = function () {\r\n\t\t\t\tvar size = 0;\r\n\t\t\t\tfor (var i = 0; i < this.attributes.length; i++) {\r\n\t\t\t\t\tvar attribute = this.attributes[i];\r\n\t\t\t\t\tsize += attribute.numElements;\r\n\t\t\t\t}\r\n\t\t\t\treturn size;\r\n\t\t\t};\r\n\t\t\tMesh.prototype.setVertices = function (vertices) {\r\n\t\t\t\tthis.dirtyVertices = true;\r\n\t\t\t\tif (vertices.length > this.vertices.length)\r\n\t\t\t\t\tthrow Error(\"Mesh can't store more than \" + this.maxVertices() + \" vertices\");\r\n\t\t\t\tthis.vertices.set(vertices, 0);\r\n\t\t\t\tthis.verticesLength = vertices.length;\r\n\t\t\t};\r\n\t\t\tMesh.prototype.setIndices = function (indices) {\r\n\t\t\t\tthis.dirtyIndices = true;\r\n\t\t\t\tif (indices.length > this.indices.length)\r\n\t\t\t\t\tthrow Error(\"Mesh can't store more than \" + this.maxIndices() + \" indices\");\r\n\t\t\t\tthis.indices.set(indices, 0);\r\n\t\t\t\tthis.indicesLength = indices.length;\r\n\t\t\t};\r\n\t\t\tMesh.prototype.draw = function (shader, primitiveType) {\r\n\t\t\t\tthis.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);\r\n\t\t\t};\r\n\t\t\tMesh.prototype.drawWithOffset = function (shader, primitiveType, offset, count) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tif (this.dirtyVertices || this.dirtyIndices)\r\n\t\t\t\t\tthis.update();\r\n\t\t\t\tthis.bind(shader);\r\n\t\t\t\tif (this.indicesLength > 0) {\r\n\t\t\t\t\tgl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tgl.drawArrays(primitiveType, offset, count);\r\n\t\t\t\t}\r\n\t\t\t\tthis.unbind(shader);\r\n\t\t\t};\r\n\t\t\tMesh.prototype.bind = function (shader) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\r\n\t\t\t\tvar offset = 0;\r\n\t\t\t\tfor (var i = 0; i < this.attributes.length; i++) {\r\n\t\t\t\t\tvar attrib = this.attributes[i];\r\n\t\t\t\t\tvar location_1 = shader.getAttributeLocation(attrib.name);\r\n\t\t\t\t\tgl.enableVertexAttribArray(location_1);\r\n\t\t\t\t\tgl.vertexAttribPointer(location_1, attrib.numElements, gl.FLOAT, false, this.elementsPerVertex * 4, offset * 4);\r\n\t\t\t\t\toffset += attrib.numElements;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.indicesLength > 0)\r\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n\t\t\t};\r\n\t\t\tMesh.prototype.unbind = function (shader) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tfor (var i = 0; i < this.attributes.length; i++) {\r\n\t\t\t\t\tvar attrib = this.attributes[i];\r\n\t\t\t\t\tvar location_2 = shader.getAttributeLocation(attrib.name);\r\n\t\t\t\t\tgl.disableVertexAttribArray(location_2);\r\n\t\t\t\t}\r\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\t\t\t\tif (this.indicesLength > 0)\r\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n\t\t\t};\r\n\t\t\tMesh.prototype.update = function () {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tif (this.dirtyVertices) {\r\n\t\t\t\t\tif (!this.verticesBuffer) {\r\n\t\t\t\t\t\tthis.verticesBuffer = gl.createBuffer();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\r\n\t\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW);\r\n\t\t\t\t\tthis.dirtyVertices = false;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.dirtyIndices) {\r\n\t\t\t\t\tif (!this.indicesBuffer) {\r\n\t\t\t\t\t\tthis.indicesBuffer = gl.createBuffer();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n\t\t\t\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW);\r\n\t\t\t\t\tthis.dirtyIndices = false;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tMesh.prototype.restore = function () {\r\n\t\t\t\tthis.verticesBuffer = null;\r\n\t\t\t\tthis.indicesBuffer = null;\r\n\t\t\t\tthis.update();\r\n\t\t\t};\r\n\t\t\tMesh.prototype.dispose = function () {\r\n\t\t\t\tthis.context.removeRestorable(this);\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tgl.deleteBuffer(this.verticesBuffer);\r\n\t\t\t\tgl.deleteBuffer(this.indicesBuffer);\r\n\t\t\t};\r\n\t\t\treturn Mesh;\r\n\t\t}());\r\n\t\twebgl.Mesh = Mesh;\r\n\t\tvar VertexAttribute = (function () {\r\n\t\t\tfunction VertexAttribute(name, type, numElements) {\r\n\t\t\t\tthis.name = name;\r\n\t\t\t\tthis.type = type;\r\n\t\t\t\tthis.numElements = numElements;\r\n\t\t\t}\r\n\t\t\treturn VertexAttribute;\r\n\t\t}());\r\n\t\twebgl.VertexAttribute = VertexAttribute;\r\n\t\tvar Position2Attribute = (function (_super) {\r\n\t\t\t__extends(Position2Attribute, _super);\r\n\t\t\tfunction Position2Attribute() {\r\n\t\t\t\treturn _super.call(this, webgl.Shader.POSITION, VertexAttributeType.Float, 2) || this;\r\n\t\t\t}\r\n\t\t\treturn Position2Attribute;\r\n\t\t}(VertexAttribute));\r\n\t\twebgl.Position2Attribute = Position2Attribute;\r\n\t\tvar Position3Attribute = (function (_super) {\r\n\t\t\t__extends(Position3Attribute, _super);\r\n\t\t\tfunction Position3Attribute() {\r\n\t\t\t\treturn _super.call(this, webgl.Shader.POSITION, VertexAttributeType.Float, 3) || this;\r\n\t\t\t}\r\n\t\t\treturn Position3Attribute;\r\n\t\t}(VertexAttribute));\r\n\t\twebgl.Position3Attribute = Position3Attribute;\r\n\t\tvar TexCoordAttribute = (function (_super) {\r\n\t\t\t__extends(TexCoordAttribute, _super);\r\n\t\t\tfunction TexCoordAttribute(unit) {\r\n\t\t\t\tif (unit === void 0) { unit = 0; }\r\n\t\t\t\treturn _super.call(this, webgl.Shader.TEXCOORDS + (unit == 0 ? \"\" : unit), VertexAttributeType.Float, 2) || this;\r\n\t\t\t}\r\n\t\t\treturn TexCoordAttribute;\r\n\t\t}(VertexAttribute));\r\n\t\twebgl.TexCoordAttribute = TexCoordAttribute;\r\n\t\tvar ColorAttribute = (function (_super) {\r\n\t\t\t__extends(ColorAttribute, _super);\r\n\t\t\tfunction ColorAttribute() {\r\n\t\t\t\treturn _super.call(this, webgl.Shader.COLOR, VertexAttributeType.Float, 4) || this;\r\n\t\t\t}\r\n\t\t\treturn ColorAttribute;\r\n\t\t}(VertexAttribute));\r\n\t\twebgl.ColorAttribute = ColorAttribute;\r\n\t\tvar Color2Attribute = (function (_super) {\r\n\t\t\t__extends(Color2Attribute, _super);\r\n\t\t\tfunction Color2Attribute() {\r\n\t\t\t\treturn _super.call(this, webgl.Shader.COLOR2, VertexAttributeType.Float, 4) || this;\r\n\t\t\t}\r\n\t\t\treturn Color2Attribute;\r\n\t\t}(VertexAttribute));\r\n\t\twebgl.Color2Attribute = Color2Attribute;\r\n\t\tvar VertexAttributeType;\r\n\t\t(function (VertexAttributeType) {\r\n\t\t\tVertexAttributeType[VertexAttributeType[\"Float\"] = 0] = \"Float\";\r\n\t\t})(VertexAttributeType = webgl.VertexAttributeType || (webgl.VertexAttributeType = {}));\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar PolygonBatcher = (function () {\r\n\t\t\tfunction PolygonBatcher(context, twoColorTint, maxVertices) {\r\n\t\t\t\tif (twoColorTint === void 0) { twoColorTint = true; }\r\n\t\t\t\tif (maxVertices === void 0) { maxVertices = 10920; }\r\n\t\t\t\tthis.isDrawing = false;\r\n\t\t\t\tthis.shader = null;\r\n\t\t\t\tthis.lastTexture = null;\r\n\t\t\t\tthis.verticesLength = 0;\r\n\t\t\t\tthis.indicesLength = 0;\r\n\t\t\t\tif (maxVertices > 10920)\r\n\t\t\t\t\tthrow new Error(\"Can't have more than 10920 triangles per batch: \" + maxVertices);\r\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n\t\t\t\tvar attributes = twoColorTint ?\r\n\t\t\t\t\t[new webgl.Position2Attribute(), new webgl.ColorAttribute(), new webgl.TexCoordAttribute(), new webgl.Color2Attribute()] :\r\n\t\t\t\t\t[new webgl.Position2Attribute(), new webgl.ColorAttribute(), new webgl.TexCoordAttribute()];\r\n\t\t\t\tthis.mesh = new webgl.Mesh(context, attributes, maxVertices, maxVertices * 3);\r\n\t\t\t\tthis.srcBlend = this.context.gl.SRC_ALPHA;\r\n\t\t\t\tthis.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;\r\n\t\t\t}\r\n\t\t\tPolygonBatcher.prototype.begin = function (shader) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tif (this.isDrawing)\r\n\t\t\t\t\tthrow new Error(\"PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()\");\r\n\t\t\t\tthis.drawCalls = 0;\r\n\t\t\t\tthis.shader = shader;\r\n\t\t\t\tthis.lastTexture = null;\r\n\t\t\t\tthis.isDrawing = true;\r\n\t\t\t\tgl.enable(gl.BLEND);\r\n\t\t\t\tgl.blendFunc(this.srcBlend, this.dstBlend);\r\n\t\t\t};\r\n\t\t\tPolygonBatcher.prototype.setBlendMode = function (srcBlend, dstBlend) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tthis.srcBlend = srcBlend;\r\n\t\t\t\tthis.dstBlend = dstBlend;\r\n\t\t\t\tif (this.isDrawing) {\r\n\t\t\t\t\tthis.flush();\r\n\t\t\t\t\tgl.blendFunc(this.srcBlend, this.dstBlend);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tPolygonBatcher.prototype.draw = function (texture, vertices, indices) {\r\n\t\t\t\tif (texture != this.lastTexture) {\r\n\t\t\t\t\tthis.flush();\r\n\t\t\t\t\tthis.lastTexture = texture;\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.verticesLength + vertices.length > this.mesh.getVertices().length ||\r\n\t\t\t\t\tthis.indicesLength + indices.length > this.mesh.getIndices().length) {\r\n\t\t\t\t\tthis.flush();\r\n\t\t\t\t}\r\n\t\t\t\tvar indexStart = this.mesh.numVertices();\r\n\t\t\t\tthis.mesh.getVertices().set(vertices, this.verticesLength);\r\n\t\t\t\tthis.verticesLength += vertices.length;\r\n\t\t\t\tthis.mesh.setVerticesLength(this.verticesLength);\r\n\t\t\t\tvar indicesArray = this.mesh.getIndices();\r\n\t\t\t\tfor (var i = this.indicesLength, j = 0; j < indices.length; i++, j++)\r\n\t\t\t\t\tindicesArray[i] = indices[j] + indexStart;\r\n\t\t\t\tthis.indicesLength += indices.length;\r\n\t\t\t\tthis.mesh.setIndicesLength(this.indicesLength);\r\n\t\t\t};\r\n\t\t\tPolygonBatcher.prototype.flush = function () {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tif (this.verticesLength == 0)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tthis.lastTexture.bind();\r\n\t\t\t\tthis.mesh.draw(this.shader, gl.TRIANGLES);\r\n\t\t\t\tthis.verticesLength = 0;\r\n\t\t\t\tthis.indicesLength = 0;\r\n\t\t\t\tthis.mesh.setVerticesLength(0);\r\n\t\t\t\tthis.mesh.setIndicesLength(0);\r\n\t\t\t\tthis.drawCalls++;\r\n\t\t\t};\r\n\t\t\tPolygonBatcher.prototype.end = function () {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tif (!this.isDrawing)\r\n\t\t\t\t\tthrow new Error(\"PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()\");\r\n\t\t\t\tif (this.verticesLength > 0 || this.indicesLength > 0)\r\n\t\t\t\t\tthis.flush();\r\n\t\t\t\tthis.shader = null;\r\n\t\t\t\tthis.lastTexture = null;\r\n\t\t\t\tthis.isDrawing = false;\r\n\t\t\t\tgl.disable(gl.BLEND);\r\n\t\t\t};\r\n\t\t\tPolygonBatcher.prototype.getDrawCalls = function () { return this.drawCalls; };\r\n\t\t\tPolygonBatcher.prototype.dispose = function () {\r\n\t\t\t\tthis.mesh.dispose();\r\n\t\t\t};\r\n\t\t\treturn PolygonBatcher;\r\n\t\t}());\r\n\t\twebgl.PolygonBatcher = PolygonBatcher;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar SceneRenderer = (function () {\r\n\t\t\tfunction SceneRenderer(canvas, context, twoColorTint) {\r\n\t\t\t\tif (twoColorTint === void 0) { twoColorTint = true; }\r\n\t\t\t\tthis.twoColorTint = false;\r\n\t\t\t\tthis.activeRenderer = null;\r\n\t\t\t\tthis.QUAD = [\r\n\t\t\t\t\t0, 0, 1, 1, 1, 1, 0, 0,\r\n\t\t\t\t\t0, 0, 1, 1, 1, 1, 0, 0,\r\n\t\t\t\t\t0, 0, 1, 1, 1, 1, 0, 0,\r\n\t\t\t\t\t0, 0, 1, 1, 1, 1, 0, 0,\r\n\t\t\t\t];\r\n\t\t\t\tthis.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\r\n\t\t\t\tthis.WHITE = new spine.Color(1, 1, 1, 1);\r\n\t\t\t\tthis.canvas = canvas;\r\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n\t\t\t\tthis.twoColorTint = twoColorTint;\r\n\t\t\t\tthis.camera = new webgl.OrthoCamera(canvas.width, canvas.height);\r\n\t\t\t\tthis.batcherShader = twoColorTint ? webgl.Shader.newTwoColoredTextured(this.context) : webgl.Shader.newColoredTextured(this.context);\r\n\t\t\t\tthis.batcher = new webgl.PolygonBatcher(this.context, twoColorTint);\r\n\t\t\t\tthis.shapesShader = webgl.Shader.newColored(this.context);\r\n\t\t\t\tthis.shapes = new webgl.ShapeRenderer(this.context);\r\n\t\t\t\tthis.skeletonRenderer = new webgl.SkeletonRenderer(this.context, twoColorTint);\r\n\t\t\t\tthis.skeletonDebugRenderer = new webgl.SkeletonDebugRenderer(this.context);\r\n\t\t\t}\r\n\t\t\tSceneRenderer.prototype.begin = function () {\r\n\t\t\t\tthis.camera.update();\r\n\t\t\t\tthis.enableRenderer(this.batcher);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.drawSkeleton = function (skeleton, premultipliedAlpha, slotRangeStart, slotRangeEnd) {\r\n\t\t\t\tif (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\r\n\t\t\t\tif (slotRangeStart === void 0) { slotRangeStart = -1; }\r\n\t\t\t\tif (slotRangeEnd === void 0) { slotRangeEnd = -1; }\r\n\t\t\t\tthis.enableRenderer(this.batcher);\r\n\t\t\t\tthis.skeletonRenderer.premultipliedAlpha = premultipliedAlpha;\r\n\t\t\t\tthis.skeletonRenderer.draw(this.batcher, skeleton, slotRangeStart, slotRangeEnd);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.drawSkeletonDebug = function (skeleton, premultipliedAlpha, ignoredBones) {\r\n\t\t\t\tif (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\r\n\t\t\t\tif (ignoredBones === void 0) { ignoredBones = null; }\r\n\t\t\t\tthis.enableRenderer(this.shapes);\r\n\t\t\t\tthis.skeletonDebugRenderer.premultipliedAlpha = premultipliedAlpha;\r\n\t\t\t\tthis.skeletonDebugRenderer.draw(this.shapes, skeleton, ignoredBones);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.drawTexture = function (texture, x, y, width, height, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.enableRenderer(this.batcher);\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.WHITE;\r\n\t\t\t\tvar quad = this.QUAD;\r\n\t\t\t\tvar i = 0;\r\n\t\t\t\tquad[i++] = x;\r\n\t\t\t\tquad[i++] = y;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = 0;\r\n\t\t\t\tquad[i++] = 1;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x + width;\r\n\t\t\t\tquad[i++] = y;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = 1;\r\n\t\t\t\tquad[i++] = 1;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x + width;\r\n\t\t\t\tquad[i++] = y + height;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = 1;\r\n\t\t\t\tquad[i++] = 0;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x;\r\n\t\t\t\tquad[i++] = y + height;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = 0;\r\n\t\t\t\tquad[i++] = 0;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tthis.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.drawTextureUV = function (texture, x, y, width, height, u, v, u2, v2, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.enableRenderer(this.batcher);\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.WHITE;\r\n\t\t\t\tvar quad = this.QUAD;\r\n\t\t\t\tvar i = 0;\r\n\t\t\t\tquad[i++] = x;\r\n\t\t\t\tquad[i++] = y;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = u;\r\n\t\t\t\tquad[i++] = v;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x + width;\r\n\t\t\t\tquad[i++] = y;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = u2;\r\n\t\t\t\tquad[i++] = v;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x + width;\r\n\t\t\t\tquad[i++] = y + height;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = u2;\r\n\t\t\t\tquad[i++] = v2;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x;\r\n\t\t\t\tquad[i++] = y + height;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = u;\r\n\t\t\t\tquad[i++] = v2;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tthis.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.drawTextureRotated = function (texture, x, y, width, height, pivotX, pivotY, angle, color, premultipliedAlpha) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tif (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\r\n\t\t\t\tthis.enableRenderer(this.batcher);\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.WHITE;\r\n\t\t\t\tvar quad = this.QUAD;\r\n\t\t\t\tvar worldOriginX = x + pivotX;\r\n\t\t\t\tvar worldOriginY = y + pivotY;\r\n\t\t\t\tvar fx = -pivotX;\r\n\t\t\t\tvar fy = -pivotY;\r\n\t\t\t\tvar fx2 = width - pivotX;\r\n\t\t\t\tvar fy2 = height - pivotY;\r\n\t\t\t\tvar p1x = fx;\r\n\t\t\t\tvar p1y = fy;\r\n\t\t\t\tvar p2x = fx;\r\n\t\t\t\tvar p2y = fy2;\r\n\t\t\t\tvar p3x = fx2;\r\n\t\t\t\tvar p3y = fy2;\r\n\t\t\t\tvar p4x = fx2;\r\n\t\t\t\tvar p4y = fy;\r\n\t\t\t\tvar x1 = 0;\r\n\t\t\t\tvar y1 = 0;\r\n\t\t\t\tvar x2 = 0;\r\n\t\t\t\tvar y2 = 0;\r\n\t\t\t\tvar x3 = 0;\r\n\t\t\t\tvar y3 = 0;\r\n\t\t\t\tvar x4 = 0;\r\n\t\t\t\tvar y4 = 0;\r\n\t\t\t\tif (angle != 0) {\r\n\t\t\t\t\tvar cos = spine.MathUtils.cosDeg(angle);\r\n\t\t\t\t\tvar sin = spine.MathUtils.sinDeg(angle);\r\n\t\t\t\t\tx1 = cos * p1x - sin * p1y;\r\n\t\t\t\t\ty1 = sin * p1x + cos * p1y;\r\n\t\t\t\t\tx4 = cos * p2x - sin * p2y;\r\n\t\t\t\t\ty4 = sin * p2x + cos * p2y;\r\n\t\t\t\t\tx3 = cos * p3x - sin * p3y;\r\n\t\t\t\t\ty3 = sin * p3x + cos * p3y;\r\n\t\t\t\t\tx2 = x3 + (x1 - x4);\r\n\t\t\t\t\ty2 = y3 + (y1 - y4);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tx1 = p1x;\r\n\t\t\t\t\ty1 = p1y;\r\n\t\t\t\t\tx4 = p2x;\r\n\t\t\t\t\ty4 = p2y;\r\n\t\t\t\t\tx3 = p3x;\r\n\t\t\t\t\ty3 = p3y;\r\n\t\t\t\t\tx2 = p4x;\r\n\t\t\t\t\ty2 = p4y;\r\n\t\t\t\t}\r\n\t\t\t\tx1 += worldOriginX;\r\n\t\t\t\ty1 += worldOriginY;\r\n\t\t\t\tx2 += worldOriginX;\r\n\t\t\t\ty2 += worldOriginY;\r\n\t\t\t\tx3 += worldOriginX;\r\n\t\t\t\ty3 += worldOriginY;\r\n\t\t\t\tx4 += worldOriginX;\r\n\t\t\t\ty4 += worldOriginY;\r\n\t\t\t\tvar i = 0;\r\n\t\t\t\tquad[i++] = x1;\r\n\t\t\t\tquad[i++] = y1;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = 0;\r\n\t\t\t\tquad[i++] = 1;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x2;\r\n\t\t\t\tquad[i++] = y2;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = 1;\r\n\t\t\t\tquad[i++] = 1;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x3;\r\n\t\t\t\tquad[i++] = y3;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = 1;\r\n\t\t\t\tquad[i++] = 0;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x4;\r\n\t\t\t\tquad[i++] = y4;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = 0;\r\n\t\t\t\tquad[i++] = 0;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tthis.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.drawRegion = function (region, x, y, width, height, color, premultipliedAlpha) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tif (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\r\n\t\t\t\tthis.enableRenderer(this.batcher);\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.WHITE;\r\n\t\t\t\tvar quad = this.QUAD;\r\n\t\t\t\tvar i = 0;\r\n\t\t\t\tquad[i++] = x;\r\n\t\t\t\tquad[i++] = y;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = region.u;\r\n\t\t\t\tquad[i++] = region.v2;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x + width;\r\n\t\t\t\tquad[i++] = y;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = region.u2;\r\n\t\t\t\tquad[i++] = region.v2;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x + width;\r\n\t\t\t\tquad[i++] = y + height;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = region.u2;\r\n\t\t\t\tquad[i++] = region.v;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tquad[i++] = x;\r\n\t\t\t\tquad[i++] = y + height;\r\n\t\t\t\tquad[i++] = color.r;\r\n\t\t\t\tquad[i++] = color.g;\r\n\t\t\t\tquad[i++] = color.b;\r\n\t\t\t\tquad[i++] = color.a;\r\n\t\t\t\tquad[i++] = region.u;\r\n\t\t\t\tquad[i++] = region.v;\r\n\t\t\t\tif (this.twoColorTint) {\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t\tquad[i++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tthis.batcher.draw(region.texture, quad, this.QUAD_TRIANGLES);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.line = function (x, y, x2, y2, color, color2) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tif (color2 === void 0) { color2 = null; }\r\n\t\t\t\tthis.enableRenderer(this.shapes);\r\n\t\t\t\tthis.shapes.line(x, y, x2, y2, color);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.triangle = function (filled, x, y, x2, y2, x3, y3, color, color2, color3) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tif (color2 === void 0) { color2 = null; }\r\n\t\t\t\tif (color3 === void 0) { color3 = null; }\r\n\t\t\t\tthis.enableRenderer(this.shapes);\r\n\t\t\t\tthis.shapes.triangle(filled, x, y, x2, y2, x3, y3, color, color2, color3);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.quad = function (filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tif (color2 === void 0) { color2 = null; }\r\n\t\t\t\tif (color3 === void 0) { color3 = null; }\r\n\t\t\t\tif (color4 === void 0) { color4 = null; }\r\n\t\t\t\tthis.enableRenderer(this.shapes);\r\n\t\t\t\tthis.shapes.quad(filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.rect = function (filled, x, y, width, height, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.enableRenderer(this.shapes);\r\n\t\t\t\tthis.shapes.rect(filled, x, y, width, height, color);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.rectLine = function (filled, x1, y1, x2, y2, width, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.enableRenderer(this.shapes);\r\n\t\t\t\tthis.shapes.rectLine(filled, x1, y1, x2, y2, width, color);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.polygon = function (polygonVertices, offset, count, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.enableRenderer(this.shapes);\r\n\t\t\t\tthis.shapes.polygon(polygonVertices, offset, count, color);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.circle = function (filled, x, y, radius, color, segments) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tif (segments === void 0) { segments = 0; }\r\n\t\t\t\tthis.enableRenderer(this.shapes);\r\n\t\t\t\tthis.shapes.circle(filled, x, y, radius, color, segments);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.curve = function (x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.enableRenderer(this.shapes);\r\n\t\t\t\tthis.shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color);\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.end = function () {\r\n\t\t\t\tif (this.activeRenderer === this.batcher)\r\n\t\t\t\t\tthis.batcher.end();\r\n\t\t\t\telse if (this.activeRenderer === this.shapes)\r\n\t\t\t\t\tthis.shapes.end();\r\n\t\t\t\tthis.activeRenderer = null;\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.resize = function (resizeMode) {\r\n\t\t\t\tvar canvas = this.canvas;\r\n\t\t\t\tvar w = canvas.clientWidth;\r\n\t\t\t\tvar h = canvas.clientHeight;\r\n\t\t\t\tif (canvas.width != w || canvas.height != h) {\r\n\t\t\t\t\tcanvas.width = w;\r\n\t\t\t\t\tcanvas.height = h;\r\n\t\t\t\t}\r\n\t\t\t\tthis.context.gl.viewport(0, 0, canvas.width, canvas.height);\r\n\t\t\t\tif (resizeMode === ResizeMode.Stretch) {\r\n\t\t\t\t}\r\n\t\t\t\telse if (resizeMode === ResizeMode.Expand) {\r\n\t\t\t\t\tthis.camera.setViewport(w, h);\r\n\t\t\t\t}\r\n\t\t\t\telse if (resizeMode === ResizeMode.Fit) {\r\n\t\t\t\t\tvar sourceWidth = canvas.width, sourceHeight = canvas.height;\r\n\t\t\t\t\tvar targetWidth = this.camera.viewportWidth, targetHeight = this.camera.viewportHeight;\r\n\t\t\t\t\tvar targetRatio = targetHeight / targetWidth;\r\n\t\t\t\t\tvar sourceRatio = sourceHeight / sourceWidth;\r\n\t\t\t\t\tvar scale = targetRatio < sourceRatio ? targetWidth / sourceWidth : targetHeight / sourceHeight;\r\n\t\t\t\t\tthis.camera.viewportWidth = sourceWidth * scale;\r\n\t\t\t\t\tthis.camera.viewportHeight = sourceHeight * scale;\r\n\t\t\t\t}\r\n\t\t\t\tthis.camera.update();\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.enableRenderer = function (renderer) {\r\n\t\t\t\tif (this.activeRenderer === renderer)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tthis.end();\r\n\t\t\t\tif (renderer instanceof webgl.PolygonBatcher) {\r\n\t\t\t\t\tthis.batcherShader.bind();\r\n\t\t\t\t\tthis.batcherShader.setUniform4x4f(webgl.Shader.MVP_MATRIX, this.camera.projectionView.values);\r\n\t\t\t\t\tthis.batcherShader.setUniformi(\"u_texture\", 0);\r\n\t\t\t\t\tthis.batcher.begin(this.batcherShader);\r\n\t\t\t\t\tthis.activeRenderer = this.batcher;\r\n\t\t\t\t}\r\n\t\t\t\telse if (renderer instanceof webgl.ShapeRenderer) {\r\n\t\t\t\t\tthis.shapesShader.bind();\r\n\t\t\t\t\tthis.shapesShader.setUniform4x4f(webgl.Shader.MVP_MATRIX, this.camera.projectionView.values);\r\n\t\t\t\t\tthis.shapes.begin(this.shapesShader);\r\n\t\t\t\t\tthis.activeRenderer = this.shapes;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.activeRenderer = this.skeletonDebugRenderer;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tSceneRenderer.prototype.dispose = function () {\r\n\t\t\t\tthis.batcher.dispose();\r\n\t\t\t\tthis.batcherShader.dispose();\r\n\t\t\t\tthis.shapes.dispose();\r\n\t\t\t\tthis.shapesShader.dispose();\r\n\t\t\t\tthis.skeletonDebugRenderer.dispose();\r\n\t\t\t};\r\n\t\t\treturn SceneRenderer;\r\n\t\t}());\r\n\t\twebgl.SceneRenderer = SceneRenderer;\r\n\t\tvar ResizeMode;\r\n\t\t(function (ResizeMode) {\r\n\t\t\tResizeMode[ResizeMode[\"Stretch\"] = 0] = \"Stretch\";\r\n\t\t\tResizeMode[ResizeMode[\"Expand\"] = 1] = \"Expand\";\r\n\t\t\tResizeMode[ResizeMode[\"Fit\"] = 2] = \"Fit\";\r\n\t\t})(ResizeMode = webgl.ResizeMode || (webgl.ResizeMode = {}));\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar Shader = (function () {\r\n\t\t\tfunction Shader(context, vertexShader, fragmentShader) {\r\n\t\t\t\tthis.vertexShader = vertexShader;\r\n\t\t\t\tthis.fragmentShader = fragmentShader;\r\n\t\t\t\tthis.vs = null;\r\n\t\t\t\tthis.fs = null;\r\n\t\t\t\tthis.program = null;\r\n\t\t\t\tthis.tmp2x2 = new Float32Array(2 * 2);\r\n\t\t\t\tthis.tmp3x3 = new Float32Array(3 * 3);\r\n\t\t\t\tthis.tmp4x4 = new Float32Array(4 * 4);\r\n\t\t\t\tthis.vsSource = vertexShader;\r\n\t\t\t\tthis.fsSource = fragmentShader;\r\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n\t\t\t\tthis.context.addRestorable(this);\r\n\t\t\t\tthis.compile();\r\n\t\t\t}\r\n\t\t\tShader.prototype.getProgram = function () { return this.program; };\r\n\t\t\tShader.prototype.getVertexShader = function () { return this.vertexShader; };\r\n\t\t\tShader.prototype.getFragmentShader = function () { return this.fragmentShader; };\r\n\t\t\tShader.prototype.getVertexShaderSource = function () { return this.vsSource; };\r\n\t\t\tShader.prototype.getFragmentSource = function () { return this.fsSource; };\r\n\t\t\tShader.prototype.compile = function () {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tthis.vs = this.compileShader(gl.VERTEX_SHADER, this.vertexShader);\r\n\t\t\t\t\tthis.fs = this.compileShader(gl.FRAGMENT_SHADER, this.fragmentShader);\r\n\t\t\t\t\tthis.program = this.compileProgram(this.vs, this.fs);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tthis.dispose();\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tShader.prototype.compileShader = function (type, source) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tvar shader = gl.createShader(type);\r\n\t\t\t\tgl.shaderSource(shader, source);\r\n\t\t\t\tgl.compileShader(shader);\r\n\t\t\t\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n\t\t\t\t\tvar error = \"Couldn't compile shader: \" + gl.getShaderInfoLog(shader);\r\n\t\t\t\t\tgl.deleteShader(shader);\r\n\t\t\t\t\tif (!gl.isContextLost())\r\n\t\t\t\t\t\tthrow new Error(error);\r\n\t\t\t\t}\r\n\t\t\t\treturn shader;\r\n\t\t\t};\r\n\t\t\tShader.prototype.compileProgram = function (vs, fs) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tvar program = gl.createProgram();\r\n\t\t\t\tgl.attachShader(program, vs);\r\n\t\t\t\tgl.attachShader(program, fs);\r\n\t\t\t\tgl.linkProgram(program);\r\n\t\t\t\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n\t\t\t\t\tvar error = \"Couldn't compile shader program: \" + gl.getProgramInfoLog(program);\r\n\t\t\t\t\tgl.deleteProgram(program);\r\n\t\t\t\t\tif (!gl.isContextLost())\r\n\t\t\t\t\t\tthrow new Error(error);\r\n\t\t\t\t}\r\n\t\t\t\treturn program;\r\n\t\t\t};\r\n\t\t\tShader.prototype.restore = function () {\r\n\t\t\t\tthis.compile();\r\n\t\t\t};\r\n\t\t\tShader.prototype.bind = function () {\r\n\t\t\t\tthis.context.gl.useProgram(this.program);\r\n\t\t\t};\r\n\t\t\tShader.prototype.unbind = function () {\r\n\t\t\t\tthis.context.gl.useProgram(null);\r\n\t\t\t};\r\n\t\t\tShader.prototype.setUniformi = function (uniform, value) {\r\n\t\t\t\tthis.context.gl.uniform1i(this.getUniformLocation(uniform), value);\r\n\t\t\t};\r\n\t\t\tShader.prototype.setUniformf = function (uniform, value) {\r\n\t\t\t\tthis.context.gl.uniform1f(this.getUniformLocation(uniform), value);\r\n\t\t\t};\r\n\t\t\tShader.prototype.setUniform2f = function (uniform, value, value2) {\r\n\t\t\t\tthis.context.gl.uniform2f(this.getUniformLocation(uniform), value, value2);\r\n\t\t\t};\r\n\t\t\tShader.prototype.setUniform3f = function (uniform, value, value2, value3) {\r\n\t\t\t\tthis.context.gl.uniform3f(this.getUniformLocation(uniform), value, value2, value3);\r\n\t\t\t};\r\n\t\t\tShader.prototype.setUniform4f = function (uniform, value, value2, value3, value4) {\r\n\t\t\t\tthis.context.gl.uniform4f(this.getUniformLocation(uniform), value, value2, value3, value4);\r\n\t\t\t};\r\n\t\t\tShader.prototype.setUniform2x2f = function (uniform, value) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tthis.tmp2x2.set(value);\r\n\t\t\t\tgl.uniformMatrix2fv(this.getUniformLocation(uniform), false, this.tmp2x2);\r\n\t\t\t};\r\n\t\t\tShader.prototype.setUniform3x3f = function (uniform, value) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tthis.tmp3x3.set(value);\r\n\t\t\t\tgl.uniformMatrix3fv(this.getUniformLocation(uniform), false, this.tmp3x3);\r\n\t\t\t};\r\n\t\t\tShader.prototype.setUniform4x4f = function (uniform, value) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tthis.tmp4x4.set(value);\r\n\t\t\t\tgl.uniformMatrix4fv(this.getUniformLocation(uniform), false, this.tmp4x4);\r\n\t\t\t};\r\n\t\t\tShader.prototype.getUniformLocation = function (uniform) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tvar location = gl.getUniformLocation(this.program, uniform);\r\n\t\t\t\tif (!location && !gl.isContextLost())\r\n\t\t\t\t\tthrow new Error(\"Couldn't find location for uniform \" + uniform);\r\n\t\t\t\treturn location;\r\n\t\t\t};\r\n\t\t\tShader.prototype.getAttributeLocation = function (attribute) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tvar location = gl.getAttribLocation(this.program, attribute);\r\n\t\t\t\tif (location == -1 && !gl.isContextLost())\r\n\t\t\t\t\tthrow new Error(\"Couldn't find location for attribute \" + attribute);\r\n\t\t\t\treturn location;\r\n\t\t\t};\r\n\t\t\tShader.prototype.dispose = function () {\r\n\t\t\t\tthis.context.removeRestorable(this);\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tif (this.vs) {\r\n\t\t\t\t\tgl.deleteShader(this.vs);\r\n\t\t\t\t\tthis.vs = null;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.fs) {\r\n\t\t\t\t\tgl.deleteShader(this.fs);\r\n\t\t\t\t\tthis.fs = null;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.program) {\r\n\t\t\t\t\tgl.deleteProgram(this.program);\r\n\t\t\t\t\tthis.program = null;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tShader.newColoredTextured = function (context) {\r\n\t\t\t\tvar vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tattribute vec2 \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_color;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_color = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tv_texCoords = \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n\t\t\t\tvar fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_color;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\t\\t\\t\\tuniform sampler2D u_texture;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tgl_FragColor = v_color * texture2D(u_texture, v_texCoords);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n\t\t\t\treturn new Shader(context, vs, fs);\r\n\t\t\t};\r\n\t\t\tShader.newTwoColoredTextured = function (context) {\r\n\t\t\t\tvar vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR2 + \";\\n\\t\\t\\t\\tattribute vec2 \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_light;\\n\\t\\t\\t\\tvarying vec4 v_dark;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_light = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tv_dark = \" + Shader.COLOR2 + \";\\n\\t\\t\\t\\t\\tv_texCoords = \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n\t\t\t\tvar fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_light;\\n\\t\\t\\t\\tvarying LOWP vec4 v_dark;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\t\\t\\t\\tuniform sampler2D u_texture;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tvec4 texColor = texture2D(u_texture, v_texCoords);\\n\\t\\t\\t\\t\\tgl_FragColor.a = texColor.a * v_light.a;\\n\\t\\t\\t\\t\\tgl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n\t\t\t\treturn new Shader(context, vs, fs);\r\n\t\t\t};\r\n\t\t\tShader.newColored = function (context) {\r\n\t\t\t\tvar vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_color;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_color = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n\t\t\t\tvar fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_color;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tgl_FragColor = v_color;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n\t\t\t\treturn new Shader(context, vs, fs);\r\n\t\t\t};\r\n\t\t\tShader.MVP_MATRIX = \"u_projTrans\";\r\n\t\t\tShader.POSITION = \"a_position\";\r\n\t\t\tShader.COLOR = \"a_color\";\r\n\t\t\tShader.COLOR2 = \"a_color2\";\r\n\t\t\tShader.TEXCOORDS = \"a_texCoords\";\r\n\t\t\tShader.SAMPLER = \"u_texture\";\r\n\t\t\treturn Shader;\r\n\t\t}());\r\n\t\twebgl.Shader = Shader;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar ShapeRenderer = (function () {\r\n\t\t\tfunction ShapeRenderer(context, maxVertices) {\r\n\t\t\t\tif (maxVertices === void 0) { maxVertices = 10920; }\r\n\t\t\t\tthis.isDrawing = false;\r\n\t\t\t\tthis.shapeType = ShapeType.Filled;\r\n\t\t\t\tthis.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\t\tthis.vertexIndex = 0;\r\n\t\t\t\tthis.tmp = new spine.Vector2();\r\n\t\t\t\tif (maxVertices > 10920)\r\n\t\t\t\t\tthrow new Error(\"Can't have more than 10920 triangles per batch: \" + maxVertices);\r\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n\t\t\t\tthis.mesh = new webgl.Mesh(context, [new webgl.Position2Attribute(), new webgl.ColorAttribute()], maxVertices, 0);\r\n\t\t\t\tthis.srcBlend = this.context.gl.SRC_ALPHA;\r\n\t\t\t\tthis.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;\r\n\t\t\t}\r\n\t\t\tShapeRenderer.prototype.begin = function (shader) {\r\n\t\t\t\tif (this.isDrawing)\r\n\t\t\t\t\tthrow new Error(\"ShapeRenderer.begin() has already been called\");\r\n\t\t\t\tthis.shader = shader;\r\n\t\t\t\tthis.vertexIndex = 0;\r\n\t\t\t\tthis.isDrawing = true;\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tgl.enable(gl.BLEND);\r\n\t\t\t\tgl.blendFunc(this.srcBlend, this.dstBlend);\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.setBlendMode = function (srcBlend, dstBlend) {\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tthis.srcBlend = srcBlend;\r\n\t\t\t\tthis.dstBlend = dstBlend;\r\n\t\t\t\tif (this.isDrawing) {\r\n\t\t\t\t\tthis.flush();\r\n\t\t\t\t\tgl.blendFunc(this.srcBlend, this.dstBlend);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.setColor = function (color) {\r\n\t\t\t\tthis.color.setFromColor(color);\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.setColorWith = function (r, g, b, a) {\r\n\t\t\t\tthis.color.set(r, g, b, a);\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.point = function (x, y, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.check(ShapeType.Point, 1);\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.color;\r\n\t\t\t\tthis.vertex(x, y, color);\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.line = function (x, y, x2, y2, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.check(ShapeType.Line, 2);\r\n\t\t\t\tvar vertices = this.mesh.getVertices();\r\n\t\t\t\tvar idx = this.vertexIndex;\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.color;\r\n\t\t\t\tthis.vertex(x, y, color);\r\n\t\t\t\tthis.vertex(x2, y2, color);\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.triangle = function (filled, x, y, x2, y2, x3, y3, color, color2, color3) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tif (color2 === void 0) { color2 = null; }\r\n\t\t\t\tif (color3 === void 0) { color3 = null; }\r\n\t\t\t\tthis.check(filled ? ShapeType.Filled : ShapeType.Line, 3);\r\n\t\t\t\tvar vertices = this.mesh.getVertices();\r\n\t\t\t\tvar idx = this.vertexIndex;\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.color;\r\n\t\t\t\tif (color2 === null)\r\n\t\t\t\t\tcolor2 = this.color;\r\n\t\t\t\tif (color3 === null)\r\n\t\t\t\t\tcolor3 = this.color;\r\n\t\t\t\tif (filled) {\r\n\t\t\t\t\tthis.vertex(x, y, color);\r\n\t\t\t\t\tthis.vertex(x2, y2, color2);\r\n\t\t\t\t\tthis.vertex(x3, y3, color3);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.vertex(x, y, color);\r\n\t\t\t\t\tthis.vertex(x2, y2, color2);\r\n\t\t\t\t\tthis.vertex(x2, y2, color);\r\n\t\t\t\t\tthis.vertex(x3, y3, color2);\r\n\t\t\t\t\tthis.vertex(x3, y3, color);\r\n\t\t\t\t\tthis.vertex(x, y, color2);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.quad = function (filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tif (color2 === void 0) { color2 = null; }\r\n\t\t\t\tif (color3 === void 0) { color3 = null; }\r\n\t\t\t\tif (color4 === void 0) { color4 = null; }\r\n\t\t\t\tthis.check(filled ? ShapeType.Filled : ShapeType.Line, 3);\r\n\t\t\t\tvar vertices = this.mesh.getVertices();\r\n\t\t\t\tvar idx = this.vertexIndex;\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.color;\r\n\t\t\t\tif (color2 === null)\r\n\t\t\t\t\tcolor2 = this.color;\r\n\t\t\t\tif (color3 === null)\r\n\t\t\t\t\tcolor3 = this.color;\r\n\t\t\t\tif (color4 === null)\r\n\t\t\t\t\tcolor4 = this.color;\r\n\t\t\t\tif (filled) {\r\n\t\t\t\t\tthis.vertex(x, y, color);\r\n\t\t\t\t\tthis.vertex(x2, y2, color2);\r\n\t\t\t\t\tthis.vertex(x3, y3, color3);\r\n\t\t\t\t\tthis.vertex(x3, y3, color3);\r\n\t\t\t\t\tthis.vertex(x4, y4, color4);\r\n\t\t\t\t\tthis.vertex(x, y, color);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.vertex(x, y, color);\r\n\t\t\t\t\tthis.vertex(x2, y2, color2);\r\n\t\t\t\t\tthis.vertex(x2, y2, color2);\r\n\t\t\t\t\tthis.vertex(x3, y3, color3);\r\n\t\t\t\t\tthis.vertex(x3, y3, color3);\r\n\t\t\t\t\tthis.vertex(x4, y4, color4);\r\n\t\t\t\t\tthis.vertex(x4, y4, color4);\r\n\t\t\t\t\tthis.vertex(x, y, color);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.rect = function (filled, x, y, width, height, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.quad(filled, x, y, x + width, y, x + width, y + height, x, y + height, color, color, color, color);\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.rectLine = function (filled, x1, y1, x2, y2, width, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.check(filled ? ShapeType.Filled : ShapeType.Line, 8);\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.color;\r\n\t\t\t\tvar t = this.tmp.set(y2 - y1, x1 - x2);\r\n\t\t\t\tt.normalize();\r\n\t\t\t\twidth *= 0.5;\r\n\t\t\t\tvar tx = t.x * width;\r\n\t\t\t\tvar ty = t.y * width;\r\n\t\t\t\tif (!filled) {\r\n\t\t\t\t\tthis.vertex(x1 + tx, y1 + ty, color);\r\n\t\t\t\t\tthis.vertex(x1 - tx, y1 - ty, color);\r\n\t\t\t\t\tthis.vertex(x2 + tx, y2 + ty, color);\r\n\t\t\t\t\tthis.vertex(x2 - tx, y2 - ty, color);\r\n\t\t\t\t\tthis.vertex(x2 + tx, y2 + ty, color);\r\n\t\t\t\t\tthis.vertex(x1 + tx, y1 + ty, color);\r\n\t\t\t\t\tthis.vertex(x2 - tx, y2 - ty, color);\r\n\t\t\t\t\tthis.vertex(x1 - tx, y1 - ty, color);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.vertex(x1 + tx, y1 + ty, color);\r\n\t\t\t\t\tthis.vertex(x1 - tx, y1 - ty, color);\r\n\t\t\t\t\tthis.vertex(x2 + tx, y2 + ty, color);\r\n\t\t\t\t\tthis.vertex(x2 - tx, y2 - ty, color);\r\n\t\t\t\t\tthis.vertex(x2 + tx, y2 + ty, color);\r\n\t\t\t\t\tthis.vertex(x1 - tx, y1 - ty, color);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.x = function (x, y, size) {\r\n\t\t\t\tthis.line(x - size, y - size, x + size, y + size);\r\n\t\t\t\tthis.line(x - size, y + size, x + size, y - size);\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.polygon = function (polygonVertices, offset, count, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tif (count < 3)\r\n\t\t\t\t\tthrow new Error(\"Polygon must contain at least 3 vertices\");\r\n\t\t\t\tthis.check(ShapeType.Line, count * 2);\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.color;\r\n\t\t\t\tvar vertices = this.mesh.getVertices();\r\n\t\t\t\tvar idx = this.vertexIndex;\r\n\t\t\t\toffset <<= 1;\r\n\t\t\t\tcount <<= 1;\r\n\t\t\t\tvar firstX = polygonVertices[offset];\r\n\t\t\t\tvar firstY = polygonVertices[offset + 1];\r\n\t\t\t\tvar last = offset + count;\r\n\t\t\t\tfor (var i = offset, n = offset + count - 2; i < n; i += 2) {\r\n\t\t\t\t\tvar x1 = polygonVertices[i];\r\n\t\t\t\t\tvar y1 = polygonVertices[i + 1];\r\n\t\t\t\t\tvar x2 = 0;\r\n\t\t\t\t\tvar y2 = 0;\r\n\t\t\t\t\tif (i + 2 >= last) {\r\n\t\t\t\t\t\tx2 = firstX;\r\n\t\t\t\t\t\ty2 = firstY;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tx2 = polygonVertices[i + 2];\r\n\t\t\t\t\t\ty2 = polygonVertices[i + 3];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.vertex(x1, y1, color);\r\n\t\t\t\t\tthis.vertex(x2, y2, color);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.circle = function (filled, x, y, radius, color, segments) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tif (segments === void 0) { segments = 0; }\r\n\t\t\t\tif (segments === 0)\r\n\t\t\t\t\tsegments = Math.max(1, (6 * spine.MathUtils.cbrt(radius)) | 0);\r\n\t\t\t\tif (segments <= 0)\r\n\t\t\t\t\tthrow new Error(\"segments must be > 0.\");\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.color;\r\n\t\t\t\tvar angle = 2 * spine.MathUtils.PI / segments;\r\n\t\t\t\tvar cos = Math.cos(angle);\r\n\t\t\t\tvar sin = Math.sin(angle);\r\n\t\t\t\tvar cx = radius, cy = 0;\r\n\t\t\t\tif (!filled) {\r\n\t\t\t\t\tthis.check(ShapeType.Line, segments * 2 + 2);\r\n\t\t\t\t\tfor (var i = 0; i < segments; i++) {\r\n\t\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\r\n\t\t\t\t\t\tvar temp_1 = cx;\r\n\t\t\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\t\t\tcy = sin * temp_1 + cos * cy;\r\n\t\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.check(ShapeType.Filled, segments * 3 + 3);\r\n\t\t\t\t\tsegments--;\r\n\t\t\t\t\tfor (var i = 0; i < segments; i++) {\r\n\t\t\t\t\t\tthis.vertex(x, y, color);\r\n\t\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\r\n\t\t\t\t\t\tvar temp_2 = cx;\r\n\t\t\t\t\t\tcx = cos * cx - sin * cy;\r\n\t\t\t\t\t\tcy = sin * temp_2 + cos * cy;\r\n\t\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.vertex(x, y, color);\r\n\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\r\n\t\t\t\t}\r\n\t\t\t\tvar temp = cx;\r\n\t\t\t\tcx = radius;\r\n\t\t\t\tcy = 0;\r\n\t\t\t\tthis.vertex(x + cx, y + cy, color);\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.curve = function (x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {\r\n\t\t\t\tif (color === void 0) { color = null; }\r\n\t\t\t\tthis.check(ShapeType.Line, segments * 2 + 2);\r\n\t\t\t\tif (color === null)\r\n\t\t\t\t\tcolor = this.color;\r\n\t\t\t\tvar subdiv_step = 1 / segments;\r\n\t\t\t\tvar subdiv_step2 = subdiv_step * subdiv_step;\r\n\t\t\t\tvar subdiv_step3 = subdiv_step * subdiv_step * subdiv_step;\r\n\t\t\t\tvar pre1 = 3 * subdiv_step;\r\n\t\t\t\tvar pre2 = 3 * subdiv_step2;\r\n\t\t\t\tvar pre4 = 6 * subdiv_step2;\r\n\t\t\t\tvar pre5 = 6 * subdiv_step3;\r\n\t\t\t\tvar tmp1x = x1 - cx1 * 2 + cx2;\r\n\t\t\t\tvar tmp1y = y1 - cy1 * 2 + cy2;\r\n\t\t\t\tvar tmp2x = (cx1 - cx2) * 3 - x1 + x2;\r\n\t\t\t\tvar tmp2y = (cy1 - cy2) * 3 - y1 + y2;\r\n\t\t\t\tvar fx = x1;\r\n\t\t\t\tvar fy = y1;\r\n\t\t\t\tvar dfx = (cx1 - x1) * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;\r\n\t\t\t\tvar dfy = (cy1 - y1) * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;\r\n\t\t\t\tvar ddfx = tmp1x * pre4 + tmp2x * pre5;\r\n\t\t\t\tvar ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n\t\t\t\tvar dddfx = tmp2x * pre5;\r\n\t\t\t\tvar dddfy = tmp2y * pre5;\r\n\t\t\t\twhile (segments-- > 0) {\r\n\t\t\t\t\tthis.vertex(fx, fy, color);\r\n\t\t\t\t\tfx += dfx;\r\n\t\t\t\t\tfy += dfy;\r\n\t\t\t\t\tdfx += ddfx;\r\n\t\t\t\t\tdfy += ddfy;\r\n\t\t\t\t\tddfx += dddfx;\r\n\t\t\t\t\tddfy += dddfy;\r\n\t\t\t\t\tthis.vertex(fx, fy, color);\r\n\t\t\t\t}\r\n\t\t\t\tthis.vertex(fx, fy, color);\r\n\t\t\t\tthis.vertex(x2, y2, color);\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.vertex = function (x, y, color) {\r\n\t\t\t\tvar idx = this.vertexIndex;\r\n\t\t\t\tvar vertices = this.mesh.getVertices();\r\n\t\t\t\tvertices[idx++] = x;\r\n\t\t\t\tvertices[idx++] = y;\r\n\t\t\t\tvertices[idx++] = color.r;\r\n\t\t\t\tvertices[idx++] = color.g;\r\n\t\t\t\tvertices[idx++] = color.b;\r\n\t\t\t\tvertices[idx++] = color.a;\r\n\t\t\t\tthis.vertexIndex = idx;\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.end = function () {\r\n\t\t\t\tif (!this.isDrawing)\r\n\t\t\t\t\tthrow new Error(\"ShapeRenderer.begin() has not been called\");\r\n\t\t\t\tthis.flush();\r\n\t\t\t\tthis.context.gl.disable(this.context.gl.BLEND);\r\n\t\t\t\tthis.isDrawing = false;\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.flush = function () {\r\n\t\t\t\tif (this.vertexIndex == 0)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tthis.mesh.setVerticesLength(this.vertexIndex);\r\n\t\t\t\tthis.mesh.draw(this.shader, this.shapeType);\r\n\t\t\t\tthis.vertexIndex = 0;\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.check = function (shapeType, numVertices) {\r\n\t\t\t\tif (!this.isDrawing)\r\n\t\t\t\t\tthrow new Error(\"ShapeRenderer.begin() has not been called\");\r\n\t\t\t\tif (this.shapeType == shapeType) {\r\n\t\t\t\t\tif (this.mesh.maxVertices() - this.mesh.numVertices() < numVertices)\r\n\t\t\t\t\t\tthis.flush();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.flush();\r\n\t\t\t\t\tthis.shapeType = shapeType;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tShapeRenderer.prototype.dispose = function () {\r\n\t\t\t\tthis.mesh.dispose();\r\n\t\t\t};\r\n\t\t\treturn ShapeRenderer;\r\n\t\t}());\r\n\t\twebgl.ShapeRenderer = ShapeRenderer;\r\n\t\tvar ShapeType;\r\n\t\t(function (ShapeType) {\r\n\t\t\tShapeType[ShapeType[\"Point\"] = 0] = \"Point\";\r\n\t\t\tShapeType[ShapeType[\"Line\"] = 1] = \"Line\";\r\n\t\t\tShapeType[ShapeType[\"Filled\"] = 4] = \"Filled\";\r\n\t\t})(ShapeType = webgl.ShapeType || (webgl.ShapeType = {}));\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar SkeletonDebugRenderer = (function () {\r\n\t\t\tfunction SkeletonDebugRenderer(context) {\r\n\t\t\t\tthis.boneLineColor = new spine.Color(1, 0, 0, 1);\r\n\t\t\t\tthis.boneOriginColor = new spine.Color(0, 1, 0, 1);\r\n\t\t\t\tthis.attachmentLineColor = new spine.Color(0, 0, 1, 0.5);\r\n\t\t\t\tthis.triangleLineColor = new spine.Color(1, 0.64, 0, 0.5);\r\n\t\t\t\tthis.pathColor = new spine.Color().setFromString(\"FF7F00\");\r\n\t\t\t\tthis.clipColor = new spine.Color(0.8, 0, 0, 2);\r\n\t\t\t\tthis.aabbColor = new spine.Color(0, 1, 0, 0.5);\r\n\t\t\t\tthis.drawBones = true;\r\n\t\t\t\tthis.drawRegionAttachments = true;\r\n\t\t\t\tthis.drawBoundingBoxes = true;\r\n\t\t\t\tthis.drawMeshHull = true;\r\n\t\t\t\tthis.drawMeshTriangles = true;\r\n\t\t\t\tthis.drawPaths = true;\r\n\t\t\t\tthis.drawSkeletonXY = false;\r\n\t\t\t\tthis.drawClipping = true;\r\n\t\t\t\tthis.premultipliedAlpha = false;\r\n\t\t\t\tthis.scale = 1;\r\n\t\t\t\tthis.boneWidth = 2;\r\n\t\t\t\tthis.bounds = new spine.SkeletonBounds();\r\n\t\t\t\tthis.temp = new Array();\r\n\t\t\t\tthis.vertices = spine.Utils.newFloatArray(2 * 1024);\r\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n\t\t\t}\r\n\t\t\tSkeletonDebugRenderer.prototype.draw = function (shapes, skeleton, ignoredBones) {\r\n\t\t\t\tif (ignoredBones === void 0) { ignoredBones = null; }\r\n\t\t\t\tvar skeletonX = skeleton.x;\r\n\t\t\t\tvar skeletonY = skeleton.y;\r\n\t\t\t\tvar gl = this.context.gl;\r\n\t\t\t\tvar srcFunc = this.premultipliedAlpha ? gl.ONE : gl.SRC_ALPHA;\r\n\t\t\t\tshapes.setBlendMode(srcFunc, gl.ONE_MINUS_SRC_ALPHA);\r\n\t\t\t\tvar bones = skeleton.bones;\r\n\t\t\t\tif (this.drawBones) {\r\n\t\t\t\t\tshapes.setColor(this.boneLineColor);\r\n\t\t\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\t\t\tvar bone = bones[i];\r\n\t\t\t\t\t\tif (ignoredBones && ignoredBones.indexOf(bone.data.name) > -1)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tif (bone.parent == null)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tvar x = skeletonX + bone.data.length * bone.a + bone.worldX;\r\n\t\t\t\t\t\tvar y = skeletonY + bone.data.length * bone.c + bone.worldY;\r\n\t\t\t\t\t\tshapes.rectLine(true, skeletonX + bone.worldX, skeletonY + bone.worldY, x, y, this.boneWidth * this.scale);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.drawSkeletonXY)\r\n\t\t\t\t\t\tshapes.x(skeletonX, skeletonY, 4 * this.scale);\r\n\t\t\t\t}\r\n\t\t\t\tif (this.drawRegionAttachments) {\r\n\t\t\t\t\tshapes.setColor(this.attachmentLineColor);\r\n\t\t\t\t\tvar slots = skeleton.slots;\r\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\t\t\tvar slot = slots[i];\r\n\t\t\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\r\n\t\t\t\t\t\t\tvar regionAttachment = attachment;\r\n\t\t\t\t\t\t\tvar vertices = this.vertices;\r\n\t\t\t\t\t\t\tregionAttachment.computeWorldVertices(slot.bone, vertices, 0, 2);\r\n\t\t\t\t\t\t\tshapes.line(vertices[0], vertices[1], vertices[2], vertices[3]);\r\n\t\t\t\t\t\t\tshapes.line(vertices[2], vertices[3], vertices[4], vertices[5]);\r\n\t\t\t\t\t\t\tshapes.line(vertices[4], vertices[5], vertices[6], vertices[7]);\r\n\t\t\t\t\t\t\tshapes.line(vertices[6], vertices[7], vertices[0], vertices[1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.drawMeshHull || this.drawMeshTriangles) {\r\n\t\t\t\t\tvar slots = skeleton.slots;\r\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\t\t\tvar slot = slots[i];\r\n\t\t\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\t\t\tif (!(attachment instanceof spine.MeshAttachment))\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tvar mesh = attachment;\r\n\t\t\t\t\t\tvar vertices = this.vertices;\r\n\t\t\t\t\t\tmesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, 2);\r\n\t\t\t\t\t\tvar triangles = mesh.triangles;\r\n\t\t\t\t\t\tvar hullLength = mesh.hullLength;\r\n\t\t\t\t\t\tif (this.drawMeshTriangles) {\r\n\t\t\t\t\t\t\tshapes.setColor(this.triangleLineColor);\r\n\t\t\t\t\t\t\tfor (var ii = 0, nn = triangles.length; ii < nn; ii += 3) {\r\n\t\t\t\t\t\t\t\tvar v1 = triangles[ii] * 2, v2 = triangles[ii + 1] * 2, v3 = triangles[ii + 2] * 2;\r\n\t\t\t\t\t\t\t\tshapes.triangle(false, vertices[v1], vertices[v1 + 1], vertices[v2], vertices[v2 + 1], vertices[v3], vertices[v3 + 1]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (this.drawMeshHull && hullLength > 0) {\r\n\t\t\t\t\t\t\tshapes.setColor(this.attachmentLineColor);\r\n\t\t\t\t\t\t\thullLength = (hullLength >> 1) * 2;\r\n\t\t\t\t\t\t\tvar lastX = vertices[hullLength - 2], lastY = vertices[hullLength - 1];\r\n\t\t\t\t\t\t\tfor (var ii = 0, nn = hullLength; ii < nn; ii += 2) {\r\n\t\t\t\t\t\t\t\tvar x = vertices[ii], y = vertices[ii + 1];\r\n\t\t\t\t\t\t\t\tshapes.line(x, y, lastX, lastY);\r\n\t\t\t\t\t\t\t\tlastX = x;\r\n\t\t\t\t\t\t\t\tlastY = y;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.drawBoundingBoxes) {\r\n\t\t\t\t\tvar bounds = this.bounds;\r\n\t\t\t\t\tbounds.update(skeleton, true);\r\n\t\t\t\t\tshapes.setColor(this.aabbColor);\r\n\t\t\t\t\tshapes.rect(false, bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\r\n\t\t\t\t\tvar polygons = bounds.polygons;\r\n\t\t\t\t\tvar boxes = bounds.boundingBoxes;\r\n\t\t\t\t\tfor (var i = 0, n = polygons.length; i < n; i++) {\r\n\t\t\t\t\t\tvar polygon = polygons[i];\r\n\t\t\t\t\t\tshapes.setColor(boxes[i].color);\r\n\t\t\t\t\t\tshapes.polygon(polygon, 0, polygon.length);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.drawPaths) {\r\n\t\t\t\t\tvar slots = skeleton.slots;\r\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\t\t\tvar slot = slots[i];\r\n\t\t\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\t\t\tif (!(attachment instanceof spine.PathAttachment))\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tvar path = attachment;\r\n\t\t\t\t\t\tvar nn = path.worldVerticesLength;\r\n\t\t\t\t\t\tvar world = this.temp = spine.Utils.setArraySize(this.temp, nn, 0);\r\n\t\t\t\t\t\tpath.computeWorldVertices(slot, 0, nn, world, 0, 2);\r\n\t\t\t\t\t\tvar color = this.pathColor;\r\n\t\t\t\t\t\tvar x1 = world[2], y1 = world[3], x2 = 0, y2 = 0;\r\n\t\t\t\t\t\tif (path.closed) {\r\n\t\t\t\t\t\t\tshapes.setColor(color);\r\n\t\t\t\t\t\t\tvar cx1 = world[0], cy1 = world[1], cx2 = world[nn - 2], cy2 = world[nn - 1];\r\n\t\t\t\t\t\t\tx2 = world[nn - 4];\r\n\t\t\t\t\t\t\ty2 = world[nn - 3];\r\n\t\t\t\t\t\t\tshapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32);\r\n\t\t\t\t\t\t\tshapes.setColor(SkeletonDebugRenderer.LIGHT_GRAY);\r\n\t\t\t\t\t\t\tshapes.line(x1, y1, cx1, cy1);\r\n\t\t\t\t\t\t\tshapes.line(x2, y2, cx2, cy2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnn -= 4;\r\n\t\t\t\t\t\tfor (var ii = 4; ii < nn; ii += 6) {\r\n\t\t\t\t\t\t\tvar cx1 = world[ii], cy1 = world[ii + 1], cx2 = world[ii + 2], cy2 = world[ii + 3];\r\n\t\t\t\t\t\t\tx2 = world[ii + 4];\r\n\t\t\t\t\t\t\ty2 = world[ii + 5];\r\n\t\t\t\t\t\t\tshapes.setColor(color);\r\n\t\t\t\t\t\t\tshapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32);\r\n\t\t\t\t\t\t\tshapes.setColor(SkeletonDebugRenderer.LIGHT_GRAY);\r\n\t\t\t\t\t\t\tshapes.line(x1, y1, cx1, cy1);\r\n\t\t\t\t\t\t\tshapes.line(x2, y2, cx2, cy2);\r\n\t\t\t\t\t\t\tx1 = x2;\r\n\t\t\t\t\t\t\ty1 = y2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.drawBones) {\r\n\t\t\t\t\tshapes.setColor(this.boneOriginColor);\r\n\t\t\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\t\t\tvar bone = bones[i];\r\n\t\t\t\t\t\tif (ignoredBones && ignoredBones.indexOf(bone.data.name) > -1)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tshapes.circle(true, skeletonX + bone.worldX, skeletonY + bone.worldY, 3 * this.scale, SkeletonDebugRenderer.GREEN, 8);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.drawClipping) {\r\n\t\t\t\t\tvar slots = skeleton.slots;\r\n\t\t\t\t\tshapes.setColor(this.clipColor);\r\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\t\t\tvar slot = slots[i];\r\n\t\t\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\t\t\tif (!(attachment instanceof spine.ClippingAttachment))\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tvar clip = attachment;\r\n\t\t\t\t\t\tvar nn = clip.worldVerticesLength;\r\n\t\t\t\t\t\tvar world = this.temp = spine.Utils.setArraySize(this.temp, nn, 0);\r\n\t\t\t\t\t\tclip.computeWorldVertices(slot, 0, nn, world, 0, 2);\r\n\t\t\t\t\t\tfor (var i_12 = 0, n_2 = world.length; i_12 < n_2; i_12 += 2) {\r\n\t\t\t\t\t\t\tvar x = world[i_12];\r\n\t\t\t\t\t\t\tvar y = world[i_12 + 1];\r\n\t\t\t\t\t\t\tvar x2 = world[(i_12 + 2) % world.length];\r\n\t\t\t\t\t\t\tvar y2 = world[(i_12 + 3) % world.length];\r\n\t\t\t\t\t\t\tshapes.line(x, y, x2, y2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tSkeletonDebugRenderer.prototype.dispose = function () {\r\n\t\t\t};\r\n\t\t\tSkeletonDebugRenderer.LIGHT_GRAY = new spine.Color(192 / 255, 192 / 255, 192 / 255, 1);\r\n\t\t\tSkeletonDebugRenderer.GREEN = new spine.Color(0, 1, 0, 1);\r\n\t\t\treturn SkeletonDebugRenderer;\r\n\t\t}());\r\n\t\twebgl.SkeletonDebugRenderer = SkeletonDebugRenderer;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar Renderable = (function () {\r\n\t\t\tfunction Renderable(vertices, numVertices, numFloats) {\r\n\t\t\t\tthis.vertices = vertices;\r\n\t\t\t\tthis.numVertices = numVertices;\r\n\t\t\t\tthis.numFloats = numFloats;\r\n\t\t\t}\r\n\t\t\treturn Renderable;\r\n\t\t}());\r\n\t\t;\r\n\t\tvar SkeletonRenderer = (function () {\r\n\t\t\tfunction SkeletonRenderer(context, twoColorTint) {\r\n\t\t\t\tif (twoColorTint === void 0) { twoColorTint = true; }\r\n\t\t\t\tthis.premultipliedAlpha = false;\r\n\t\t\t\tthis.vertexEffect = null;\r\n\t\t\t\tthis.tempColor = new spine.Color();\r\n\t\t\t\tthis.tempColor2 = new spine.Color();\r\n\t\t\t\tthis.vertexSize = 2 + 2 + 4;\r\n\t\t\t\tthis.twoColorTint = false;\r\n\t\t\t\tthis.renderable = new Renderable(null, 0, 0);\r\n\t\t\t\tthis.clipper = new spine.SkeletonClipping();\r\n\t\t\t\tthis.temp = new spine.Vector2();\r\n\t\t\t\tthis.temp2 = new spine.Vector2();\r\n\t\t\t\tthis.temp3 = new spine.Color();\r\n\t\t\t\tthis.temp4 = new spine.Color();\r\n\t\t\t\tthis.twoColorTint = twoColorTint;\r\n\t\t\t\tif (twoColorTint)\r\n\t\t\t\t\tthis.vertexSize += 4;\r\n\t\t\t\tthis.vertices = spine.Utils.newFloatArray(this.vertexSize * 1024);\r\n\t\t\t}\r\n\t\t\tSkeletonRenderer.prototype.draw = function (batcher, skeleton, slotRangeStart, slotRangeEnd) {\r\n\t\t\t\tif (slotRangeStart === void 0) { slotRangeStart = -1; }\r\n\t\t\t\tif (slotRangeEnd === void 0) { slotRangeEnd = -1; }\r\n\t\t\t\tvar clipper = this.clipper;\r\n\t\t\t\tvar premultipliedAlpha = this.premultipliedAlpha;\r\n\t\t\t\tvar twoColorTint = this.twoColorTint;\r\n\t\t\t\tvar blendMode = null;\r\n\t\t\t\tvar tempPos = this.temp;\r\n\t\t\t\tvar tempUv = this.temp2;\r\n\t\t\t\tvar tempLight = this.temp3;\r\n\t\t\t\tvar tempDark = this.temp4;\r\n\t\t\t\tvar renderable = this.renderable;\r\n\t\t\t\tvar uvs = null;\r\n\t\t\t\tvar triangles = null;\r\n\t\t\t\tvar drawOrder = skeleton.drawOrder;\r\n\t\t\t\tvar attachmentColor = null;\r\n\t\t\t\tvar skeletonColor = skeleton.color;\r\n\t\t\t\tvar vertexSize = twoColorTint ? 12 : 8;\r\n\t\t\t\tvar inRange = false;\r\n\t\t\t\tif (slotRangeStart == -1)\r\n\t\t\t\t\tinRange = true;\r\n\t\t\t\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\r\n\t\t\t\t\tvar clippedVertexSize = clipper.isClipping() ? 2 : vertexSize;\r\n\t\t\t\t\tvar slot = drawOrder[i];\r\n\t\t\t\t\tif (slotRangeStart >= 0 && slotRangeStart == slot.data.index) {\r\n\t\t\t\t\t\tinRange = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!inRange) {\r\n\t\t\t\t\t\tclipper.clipEndWithSlot(slot);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (slotRangeEnd >= 0 && slotRangeEnd == slot.data.index) {\r\n\t\t\t\t\t\tinRange = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\t\tvar texture = null;\r\n\t\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\r\n\t\t\t\t\t\tvar region = attachment;\r\n\t\t\t\t\t\trenderable.vertices = this.vertices;\r\n\t\t\t\t\t\trenderable.numVertices = 4;\r\n\t\t\t\t\t\trenderable.numFloats = clippedVertexSize << 2;\r\n\t\t\t\t\t\tregion.computeWorldVertices(slot.bone, renderable.vertices, 0, clippedVertexSize);\r\n\t\t\t\t\t\ttriangles = SkeletonRenderer.QUAD_TRIANGLES;\r\n\t\t\t\t\t\tuvs = region.uvs;\r\n\t\t\t\t\t\ttexture = region.region.renderObject.texture;\r\n\t\t\t\t\t\tattachmentColor = region.color;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (attachment instanceof spine.MeshAttachment) {\r\n\t\t\t\t\t\tvar mesh = attachment;\r\n\t\t\t\t\t\trenderable.vertices = this.vertices;\r\n\t\t\t\t\t\trenderable.numVertices = (mesh.worldVerticesLength >> 1);\r\n\t\t\t\t\t\trenderable.numFloats = renderable.numVertices * clippedVertexSize;\r\n\t\t\t\t\t\tif (renderable.numFloats > renderable.vertices.length) {\r\n\t\t\t\t\t\t\trenderable.vertices = this.vertices = spine.Utils.newFloatArray(renderable.numFloats);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, renderable.vertices, 0, clippedVertexSize);\r\n\t\t\t\t\t\ttriangles = mesh.triangles;\r\n\t\t\t\t\t\ttexture = mesh.region.renderObject.texture;\r\n\t\t\t\t\t\tuvs = mesh.uvs;\r\n\t\t\t\t\t\tattachmentColor = mesh.color;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (attachment instanceof spine.ClippingAttachment) {\r\n\t\t\t\t\t\tvar clip = (attachment);\r\n\t\t\t\t\t\tclipper.clipStart(slot, clip);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (texture != null) {\r\n\t\t\t\t\t\tvar slotColor = slot.color;\r\n\t\t\t\t\t\tvar finalColor = this.tempColor;\r\n\t\t\t\t\t\tfinalColor.r = skeletonColor.r * slotColor.r * attachmentColor.r;\r\n\t\t\t\t\t\tfinalColor.g = skeletonColor.g * slotColor.g * attachmentColor.g;\r\n\t\t\t\t\t\tfinalColor.b = skeletonColor.b * slotColor.b * attachmentColor.b;\r\n\t\t\t\t\t\tfinalColor.a = skeletonColor.a * slotColor.a * attachmentColor.a;\r\n\t\t\t\t\t\tif (premultipliedAlpha) {\r\n\t\t\t\t\t\t\tfinalColor.r *= finalColor.a;\r\n\t\t\t\t\t\t\tfinalColor.g *= finalColor.a;\r\n\t\t\t\t\t\t\tfinalColor.b *= finalColor.a;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar darkColor = this.tempColor2;\r\n\t\t\t\t\t\tif (slot.darkColor == null)\r\n\t\t\t\t\t\t\tdarkColor.set(0, 0, 0, 1.0);\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (premultipliedAlpha) {\r\n\t\t\t\t\t\t\t\tdarkColor.r = slot.darkColor.r * finalColor.a;\r\n\t\t\t\t\t\t\t\tdarkColor.g = slot.darkColor.g * finalColor.a;\r\n\t\t\t\t\t\t\t\tdarkColor.b = slot.darkColor.b * finalColor.a;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tdarkColor.setFromColor(slot.darkColor);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tdarkColor.a = premultipliedAlpha ? 1.0 : 0.0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar slotBlendMode = slot.data.blendMode;\r\n\t\t\t\t\t\tif (slotBlendMode != blendMode) {\r\n\t\t\t\t\t\t\tblendMode = slotBlendMode;\r\n\t\t\t\t\t\t\tbatcher.setBlendMode(webgl.WebGLBlendModeConverter.getSourceGLBlendMode(blendMode, premultipliedAlpha), webgl.WebGLBlendModeConverter.getDestGLBlendMode(blendMode));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (clipper.isClipping()) {\r\n\t\t\t\t\t\t\tclipper.clipTriangles(renderable.vertices, renderable.numFloats, triangles, triangles.length, uvs, finalColor, darkColor, twoColorTint);\r\n\t\t\t\t\t\t\tvar clippedVertices = new Float32Array(clipper.clippedVertices);\r\n\t\t\t\t\t\t\tvar clippedTriangles = clipper.clippedTriangles;\r\n\t\t\t\t\t\t\tif (this.vertexEffect != null) {\r\n\t\t\t\t\t\t\t\tvar vertexEffect = this.vertexEffect;\r\n\t\t\t\t\t\t\t\tvar verts = clippedVertices;\r\n\t\t\t\t\t\t\t\tif (!twoColorTint) {\r\n\t\t\t\t\t\t\t\t\tfor (var v = 0, n_3 = clippedVertices.length; v < n_3; v += vertexSize) {\r\n\t\t\t\t\t\t\t\t\t\ttempPos.x = verts[v];\r\n\t\t\t\t\t\t\t\t\t\ttempPos.y = verts[v + 1];\r\n\t\t\t\t\t\t\t\t\t\ttempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\r\n\t\t\t\t\t\t\t\t\t\ttempUv.x = verts[v + 6];\r\n\t\t\t\t\t\t\t\t\t\ttempUv.y = verts[v + 7];\r\n\t\t\t\t\t\t\t\t\t\ttempDark.set(0, 0, 0, 0);\r\n\t\t\t\t\t\t\t\t\t\tvertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n\t\t\t\t\t\t\t\t\t\tverts[v] = tempPos.x;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = tempPos.y;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = tempLight.r;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = tempLight.g;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = tempLight.b;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = tempLight.a;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 6] = tempUv.x;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 7] = tempUv.y;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tfor (var v = 0, n_4 = clippedVertices.length; v < n_4; v += vertexSize) {\r\n\t\t\t\t\t\t\t\t\t\ttempPos.x = verts[v];\r\n\t\t\t\t\t\t\t\t\t\ttempPos.y = verts[v + 1];\r\n\t\t\t\t\t\t\t\t\t\ttempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\r\n\t\t\t\t\t\t\t\t\t\ttempUv.x = verts[v + 6];\r\n\t\t\t\t\t\t\t\t\t\ttempUv.y = verts[v + 7];\r\n\t\t\t\t\t\t\t\t\t\ttempDark.set(verts[v + 8], verts[v + 9], verts[v + 10], verts[v + 11]);\r\n\t\t\t\t\t\t\t\t\t\tvertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n\t\t\t\t\t\t\t\t\t\tverts[v] = tempPos.x;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = tempPos.y;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = tempLight.r;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = tempLight.g;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = tempLight.b;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = tempLight.a;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 6] = tempUv.x;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 7] = tempUv.y;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 8] = tempDark.r;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 9] = tempDark.g;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 10] = tempDark.b;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 11] = tempDark.a;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbatcher.draw(texture, clippedVertices, clippedTriangles);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tvar verts = renderable.vertices;\r\n\t\t\t\t\t\t\tif (this.vertexEffect != null) {\r\n\t\t\t\t\t\t\t\tvar vertexEffect = this.vertexEffect;\r\n\t\t\t\t\t\t\t\tif (!twoColorTint) {\r\n\t\t\t\t\t\t\t\t\tfor (var v = 0, u = 0, n_5 = renderable.numFloats; v < n_5; v += vertexSize, u += 2) {\r\n\t\t\t\t\t\t\t\t\t\ttempPos.x = verts[v];\r\n\t\t\t\t\t\t\t\t\t\ttempPos.y = verts[v + 1];\r\n\t\t\t\t\t\t\t\t\t\ttempUv.x = uvs[u];\r\n\t\t\t\t\t\t\t\t\t\ttempUv.y = uvs[u + 1];\r\n\t\t\t\t\t\t\t\t\t\ttempLight.setFromColor(finalColor);\r\n\t\t\t\t\t\t\t\t\t\ttempDark.set(0, 0, 0, 0);\r\n\t\t\t\t\t\t\t\t\t\tvertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n\t\t\t\t\t\t\t\t\t\tverts[v] = tempPos.x;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = tempPos.y;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = tempLight.r;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = tempLight.g;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = tempLight.b;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = tempLight.a;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 6] = tempUv.x;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 7] = tempUv.y;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tfor (var v = 0, u = 0, n_6 = renderable.numFloats; v < n_6; v += vertexSize, u += 2) {\r\n\t\t\t\t\t\t\t\t\t\ttempPos.x = verts[v];\r\n\t\t\t\t\t\t\t\t\t\ttempPos.y = verts[v + 1];\r\n\t\t\t\t\t\t\t\t\t\ttempUv.x = uvs[u];\r\n\t\t\t\t\t\t\t\t\t\ttempUv.y = uvs[u + 1];\r\n\t\t\t\t\t\t\t\t\t\ttempLight.setFromColor(finalColor);\r\n\t\t\t\t\t\t\t\t\t\ttempDark.setFromColor(darkColor);\r\n\t\t\t\t\t\t\t\t\t\tvertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n\t\t\t\t\t\t\t\t\t\tverts[v] = tempPos.x;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = tempPos.y;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = tempLight.r;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = tempLight.g;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = tempLight.b;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = tempLight.a;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 6] = tempUv.x;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 7] = tempUv.y;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 8] = tempDark.r;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 9] = tempDark.g;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 10] = tempDark.b;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 11] = tempDark.a;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tif (!twoColorTint) {\r\n\t\t\t\t\t\t\t\t\tfor (var v = 2, u = 0, n_7 = renderable.numFloats; v < n_7; v += vertexSize, u += 2) {\r\n\t\t\t\t\t\t\t\t\t\tverts[v] = finalColor.r;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = finalColor.g;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = finalColor.b;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = finalColor.a;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = uvs[u];\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = uvs[u + 1];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tfor (var v = 2, u = 0, n_8 = renderable.numFloats; v < n_8; v += vertexSize, u += 2) {\r\n\t\t\t\t\t\t\t\t\t\tverts[v] = finalColor.r;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = finalColor.g;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = finalColor.b;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = finalColor.a;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = uvs[u];\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = uvs[u + 1];\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 6] = darkColor.r;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 7] = darkColor.g;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 8] = darkColor.b;\r\n\t\t\t\t\t\t\t\t\t\tverts[v + 9] = darkColor.a;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar view = renderable.vertices.subarray(0, renderable.numFloats);\r\n\t\t\t\t\t\t\tbatcher.draw(texture, view, triangles);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclipper.clipEndWithSlot(slot);\r\n\t\t\t\t}\r\n\t\t\t\tclipper.clipEnd();\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\r\n\t\t\treturn SkeletonRenderer;\r\n\t\t}());\r\n\t\twebgl.SkeletonRenderer = SkeletonRenderer;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar Vector3 = (function () {\r\n\t\t\tfunction Vector3(x, y, z) {\r\n\t\t\t\tif (x === void 0) { x = 0; }\r\n\t\t\t\tif (y === void 0) { y = 0; }\r\n\t\t\t\tif (z === void 0) { z = 0; }\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\t\t\tthis.x = x;\r\n\t\t\t\tthis.y = y;\r\n\t\t\t\tthis.z = z;\r\n\t\t\t}\r\n\t\t\tVector3.prototype.setFrom = function (v) {\r\n\t\t\t\tthis.x = v.x;\r\n\t\t\t\tthis.y = v.y;\r\n\t\t\t\tthis.z = v.z;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tVector3.prototype.set = function (x, y, z) {\r\n\t\t\t\tthis.x = x;\r\n\t\t\t\tthis.y = y;\r\n\t\t\t\tthis.z = z;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tVector3.prototype.add = function (v) {\r\n\t\t\t\tthis.x += v.x;\r\n\t\t\t\tthis.y += v.y;\r\n\t\t\t\tthis.z += v.z;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tVector3.prototype.sub = function (v) {\r\n\t\t\t\tthis.x -= v.x;\r\n\t\t\t\tthis.y -= v.y;\r\n\t\t\t\tthis.z -= v.z;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tVector3.prototype.scale = function (s) {\r\n\t\t\t\tthis.x *= s;\r\n\t\t\t\tthis.y *= s;\r\n\t\t\t\tthis.z *= s;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tVector3.prototype.normalize = function () {\r\n\t\t\t\tvar len = this.length();\r\n\t\t\t\tif (len == 0)\r\n\t\t\t\t\treturn this;\r\n\t\t\t\tlen = 1 / len;\r\n\t\t\t\tthis.x *= len;\r\n\t\t\t\tthis.y *= len;\r\n\t\t\t\tthis.z *= len;\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t\tVector3.prototype.cross = function (v) {\r\n\t\t\t\treturn this.set(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);\r\n\t\t\t};\r\n\t\t\tVector3.prototype.multiply = function (matrix) {\r\n\t\t\t\tvar l_mat = matrix.values;\r\n\t\t\t\treturn this.set(this.x * l_mat[webgl.M00] + this.y * l_mat[webgl.M01] + this.z * l_mat[webgl.M02] + l_mat[webgl.M03], this.x * l_mat[webgl.M10] + this.y * l_mat[webgl.M11] + this.z * l_mat[webgl.M12] + l_mat[webgl.M13], this.x * l_mat[webgl.M20] + this.y * l_mat[webgl.M21] + this.z * l_mat[webgl.M22] + l_mat[webgl.M23]);\r\n\t\t\t};\r\n\t\t\tVector3.prototype.project = function (matrix) {\r\n\t\t\t\tvar l_mat = matrix.values;\r\n\t\t\t\tvar l_w = 1 / (this.x * l_mat[webgl.M30] + this.y * l_mat[webgl.M31] + this.z * l_mat[webgl.M32] + l_mat[webgl.M33]);\r\n\t\t\t\treturn this.set((this.x * l_mat[webgl.M00] + this.y * l_mat[webgl.M01] + this.z * l_mat[webgl.M02] + l_mat[webgl.M03]) * l_w, (this.x * l_mat[webgl.M10] + this.y * l_mat[webgl.M11] + this.z * l_mat[webgl.M12] + l_mat[webgl.M13]) * l_w, (this.x * l_mat[webgl.M20] + this.y * l_mat[webgl.M21] + this.z * l_mat[webgl.M22] + l_mat[webgl.M23]) * l_w);\r\n\t\t\t};\r\n\t\t\tVector3.prototype.dot = function (v) {\r\n\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\t\t\t};\r\n\t\t\tVector3.prototype.length = function () {\r\n\t\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n\t\t\t};\r\n\t\t\tVector3.prototype.distance = function (v) {\r\n\t\t\t\tvar a = v.x - this.x;\r\n\t\t\t\tvar b = v.y - this.y;\r\n\t\t\t\tvar c = v.z - this.z;\r\n\t\t\t\treturn Math.sqrt(a * a + b * b + c * c);\r\n\t\t\t};\r\n\t\t\treturn Vector3;\r\n\t\t}());\r\n\t\twebgl.Vector3 = Vector3;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar webgl;\r\n\t(function (webgl) {\r\n\t\tvar ManagedWebGLRenderingContext = (function () {\r\n\t\t\tfunction ManagedWebGLRenderingContext(canvasOrContext, contextConfig) {\r\n\t\t\t\tif (contextConfig === void 0) { contextConfig = { alpha: \"true\" }; }\r\n\t\t\t\tvar _this = this;\r\n\t\t\t\tthis.restorables = new Array();\r\n\t\t\t\tif (canvasOrContext instanceof HTMLCanvasElement) {\r\n\t\t\t\t\tvar canvas = canvasOrContext;\r\n\t\t\t\t\tthis.gl = (canvas.getContext(\"webgl\", contextConfig) || canvas.getContext(\"experimental-webgl\", contextConfig));\r\n\t\t\t\t\tthis.canvas = canvas;\r\n\t\t\t\t\tcanvas.addEventListener(\"webglcontextlost\", function (e) {\r\n\t\t\t\t\t\tvar event = e;\r\n\t\t\t\t\t\tif (e) {\r\n\t\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcanvas.addEventListener(\"webglcontextrestored\", function (e) {\r\n\t\t\t\t\t\tfor (var i = 0, n = _this.restorables.length; i < n; i++) {\r\n\t\t\t\t\t\t\t_this.restorables[i].restore();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.gl = canvasOrContext;\r\n\t\t\t\t\tthis.canvas = this.gl.canvas;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tManagedWebGLRenderingContext.prototype.addRestorable = function (restorable) {\r\n\t\t\t\tthis.restorables.push(restorable);\r\n\t\t\t};\r\n\t\t\tManagedWebGLRenderingContext.prototype.removeRestorable = function (restorable) {\r\n\t\t\t\tvar index = this.restorables.indexOf(restorable);\r\n\t\t\t\tif (index > -1)\r\n\t\t\t\t\tthis.restorables.splice(index, 1);\r\n\t\t\t};\r\n\t\t\treturn ManagedWebGLRenderingContext;\r\n\t\t}());\r\n\t\twebgl.ManagedWebGLRenderingContext = ManagedWebGLRenderingContext;\r\n\t\tvar WebGLBlendModeConverter = (function () {\r\n\t\t\tfunction WebGLBlendModeConverter() {\r\n\t\t\t}\r\n\t\t\tWebGLBlendModeConverter.getDestGLBlendMode = function (blendMode) {\r\n\t\t\t\tswitch (blendMode) {\r\n\t\t\t\t\tcase spine.BlendMode.Normal: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\r\n\t\t\t\t\tcase spine.BlendMode.Additive: return WebGLBlendModeConverter.ONE;\r\n\t\t\t\t\tcase spine.BlendMode.Multiply: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\r\n\t\t\t\t\tcase spine.BlendMode.Screen: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\r\n\t\t\t\t\tdefault: throw new Error(\"Unknown blend mode: \" + blendMode);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tWebGLBlendModeConverter.getSourceGLBlendMode = function (blendMode, premultipliedAlpha) {\r\n\t\t\t\tif (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\r\n\t\t\t\tswitch (blendMode) {\r\n\t\t\t\t\tcase spine.BlendMode.Normal: return premultipliedAlpha ? WebGLBlendModeConverter.ONE : WebGLBlendModeConverter.SRC_ALPHA;\r\n\t\t\t\t\tcase spine.BlendMode.Additive: return premultipliedAlpha ? WebGLBlendModeConverter.ONE : WebGLBlendModeConverter.SRC_ALPHA;\r\n\t\t\t\t\tcase spine.BlendMode.Multiply: return WebGLBlendModeConverter.DST_COLOR;\r\n\t\t\t\t\tcase spine.BlendMode.Screen: return WebGLBlendModeConverter.ONE;\r\n\t\t\t\t\tdefault: throw new Error(\"Unknown blend mode: \" + blendMode);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tWebGLBlendModeConverter.ZERO = 0;\r\n\t\t\tWebGLBlendModeConverter.ONE = 1;\r\n\t\t\tWebGLBlendModeConverter.SRC_COLOR = 0x0300;\r\n\t\t\tWebGLBlendModeConverter.ONE_MINUS_SRC_COLOR = 0x0301;\r\n\t\t\tWebGLBlendModeConverter.SRC_ALPHA = 0x0302;\r\n\t\t\tWebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA = 0x0303;\r\n\t\t\tWebGLBlendModeConverter.DST_ALPHA = 0x0304;\r\n\t\t\tWebGLBlendModeConverter.ONE_MINUS_DST_ALPHA = 0x0305;\r\n\t\t\tWebGLBlendModeConverter.DST_COLOR = 0x0306;\r\n\t\t\treturn WebGLBlendModeConverter;\r\n\t\t}());\r\n\t\twebgl.WebGLBlendModeConverter = WebGLBlendModeConverter;\r\n\t})(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\n//# sourceMappingURL=spine-webgl.js.map\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = spine;\n}.call(window));"],"sourceRoot":""}