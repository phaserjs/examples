(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Phaser", [], factory);
	else if(typeof exports === 'object')
		exports["Phaser"] = factory();
	else
		root["Phaser"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 351);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

var Point = function (x, y)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = x; }

    this.x = x;

    this.y = y;
};

Point.prototype.constructor = Point;

Point.prototype = {

    setTo: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    }

};

module.exports = Point;


/***/ },
/* 1 */
/***/ function(module, exports) {

var CONST = {

    VERSION: '3.0.0',

    AUTO: 0,
    CANVAS: 1,
    WEBGL: 2,

    IMAGE: 20

};

module.exports = CONST;


/***/ },
/* 2 */
/***/ function(module, exports) {

var MATH_CONST = {

    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI

};

module.exports = MATH_CONST;


/***/ },
/* 3 */
/***/ function(module, exports) {

var FILE_CONST = {

    LOADER_IDLE: 0,
    LOADER_LOADING: 1,
    LOADER_PROCESSING: 2,
    LOADER_COMPLETE: 3,
    LOADER_DESTROYED: 4,

    FILE_PENDING: 5,      // file is in the load queue but not yet started
    FILE_LOADING: 6,      // file has been started to load by the loader (onLoad called)
    FILE_LOADED: 7,       // file has loaded successfully, awaiting processing
    FILE_FAILED: 8,       // file failed to load
    FILE_PROCESSING: 9,   // file is being processed (onProcess callback)
    FILE_WAITING_LINKFILE: 10,   // file is being processed (onProcess callback)
    FILE_ERRORED: 11,   // file is being processed (onProcess callback)
    FILE_COMPLETE: 12,     // file has finished processing
    FILE_DESTROYED: 13,     // file has been destroyed

    TEXTURE_ATLAS_JSON_ARRAY: 20,
    TEXTURE_ATLAS_JSON_HASH: 21

};

module.exports = FILE_CONST;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var OS = {

    /**
    * @property {boolean} desktop - Is running on a desktop?
    * @default
    */
    desktop: false,

    /**
    * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView
    * @default
    */
    webApp: false,

    /**
    * @property {boolean} iOS - Is running on iOS?
    * @default
    */
    iOS: false,

    /**
    * @property {number} iOSVersion - If running in iOS this will contain the major version number.
    * @default
    */
    iOSVersion: 0,

    /**
    * @property {boolean} iPhone - Is running on iPhone?
    * @default
    */
    iPhone: false,

    /**
    * @property {boolean} iPad - Is running on iPad?
    * @default
    */
    iPad: false,

    /**
    * @property {boolean} cocoonJS - Is the game running under CocoonJS?
    * @default
    */
    cocoonJS: false,
    
    /**
    * @property {boolean} cocoonJSApp - Is this game running with CocoonJS.App?
    * @default
    */
    cocoonJSApp: false,
    
    /**
    * @property {boolean} cordova - Is the game running under Apache Cordova?
    * @default
    */
    cordova: false,
    
    /**
    * @property {boolean} node - Is the game running under Node.js?
    * @default
    */
    node: false,
    
    /**
    * @property {boolean} nodeWebkit - Is the game running under Node-Webkit?
    * @default
    */
    nodeWebkit: false,
    
    /**
    * @property {boolean} electron - Is the game running under GitHub Electron?
    * @default
    */
    electron: false,
    
    /**
    * @property {boolean} ejecta - Is the game running under Ejecta?
    * @default
    */
    ejecta: false,

    /**
    * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?
    * @default
    */
    crosswalk: false,

    /**
    * @property {boolean} android - Is running on android?
    * @default
    */
    android: false,

    /**
    * @property {boolean} chromeOS - Is running on chromeOS?
    * @default
    */
    chromeOS: false,

    /**
    * @property {boolean} linux - Is running on linux?
    * @default
    */
    linux: false,

    /**
    * @property {boolean} macOS - Is running on macOS?
    * @default
    */
    macOS: false,

    /**
    * @property {boolean} windows - Is running on windows?
    * @default
    */
    windows: false,

    /**
    * @property {boolean} windowsPhone - Is running on a Windows Phone?
    * @default
    */
    windowsPhone: false,

    /**
    * @property {boolean} vita - Is running on a PlayStation Vita?
    * @default
    */
    vita: false,

    /**
    * @property {boolean} kindle - Is running on an Amazon Kindle?
    * @default
    */
    kindle: false,

    /**
    * @property {number} pixelRatio - PixelRatio of the host device?
    * @default
    */
    pixelRatio: 1

};

function init ()
{
    var ua = navigator.userAgent;

    if (/Windows/.test(ua))
    {
        OS.windows = true;
    }
    else if (/Mac OS/.test(ua))
    {
        OS.macOS = true;
    }
    else if (/Linux/.test(ua))
    {
        OS.linux = true;
    }
    else if (/Android/.test(ua))
    {
        OS.android = true;
    }
    else if (/iP[ao]d|iPhone/i.test(ua))
    {
        OS.iOS = true;
        (navigator.appVersion).match(/OS (\d+)/);
        OS.iOSVersion = parseInt(RegExp.$1, 10);
    }
    else if (/Kindle/.test(ua) || (/\bKF[A-Z][A-Z]+/).test(ua) || (/Silk.*Mobile Safari/).test(ua))
    {
        OS.kindle = true;

        // This will NOT detect early generations of Kindle Fire, I think there is no reliable way...
        // E.g. "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-us; Silk/1.1.0-80) AppleWebKit/533.16 (KHTML, like Gecko) Version/5.0 Safari/533.16 Silk-Accelerated=true"
    }
    else if (/CrOS/.test(ua))
    {
        OS.chromeOS = true;
    }
    else if ((/Playstation Vita/).test(ua))
    {
        OS.vita = true;
    }

    if (/Windows Phone/i.test(ua) || (/IEMobile/i).test(ua))
    {
        OS.android = false;
        OS.iOS = false;
        OS.macOS = false;
        OS.windows = true;
        OS.windowsPhone = true;
    }

    var silk = (/Silk/).test(ua);

    if (OS.windows || OS.macOS || (OS.linux && !silk) || OS.chromeOS)
    {
        OS.desktop = true;
    }

    //  Windows Phone / Table reset
    if (OS.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua))))
    {
        OS.desktop = false;
    }

    //  WebApp mode in iOS
    if (navigator.standalone)
    {
        OS.webApp = true;
    }
    
    if (window.cordova !== undefined)
    {
        OS.cordova = true;
    }
    
    if ((typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined'))
    {
        OS.node = true;
    }
    
    if (OS.node && typeof process.versions === 'object')
    {
        OS.nodeWebkit = !!process.versions['node-webkit'];
        
        OS.electron = !!process.versions.electron;
    }
    
    if (navigator.isCocoonJS)
    {
        OS.cocoonJS = true;

        try
        {
            OS.cocoonJSApp = (typeof CocoonJS !== 'undefined');
        }
        catch (error)
        {
            OS.cocoonJSApp = false;
        }
    }

    if (window.ejecta !== undefined)
    {
        OS.ejecta = true;
    }

    if ((/Crosswalk/).test(ua))
    {
        OS.crosswalk = true;
    }

    OS.iPhone = ua.toLowerCase().indexOf('iphone') !== -1;
    OS.iPad = ua.toLowerCase().indexOf('ipad') !== -1;

    OS.pixelRatio = window['devicePixelRatio'] || 1;

    return OS;
}

module.exports = init();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(350)))

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);

var Browser = {

    /**
    * @property {boolean} arora - Set to true if running in Arora.
    * @default
    */
    arora: false,

    /**
    * @property {boolean} chrome - Set to true if running in Chrome.
    * @default
    */
    chrome: false,

    /**
    * @property {number} chromeVersion - If running in Chrome this will contain the major version number.
    * @default
    */
    chromeVersion: 0,

    /**
    * @property {boolean} epiphany - Set to true if running in Epiphany.
    * @default
    */
    epiphany: false,

    /**
    * @property {boolean} firefox - Set to true if running in Firefox.
    * @default
    */
    firefox: false,

    /**
    * @property {number} firefoxVersion - If running in Firefox this will contain the major version number.
    * @default
    */
    firefoxVersion: 0,

    /**
    * @property {boolean} mobileSafari - Set to true if running in Mobile Safari.
    * @default
    */
    mobileSafari: false,

    /**
    * @property {boolean} ie - Set to true if running in Internet Explorer.
    * @default
    */
    ie: false,

    /**
    * @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.
    * @default
    */
    ieVersion: 0,

    /**
    * @property {boolean} midori - Set to true if running in Midori.
    * @default
    */
    midori: false,

    /**
    * @property {boolean} opera - Set to true if running in Opera.
    * @default
    */
    opera: false,

    /**
    * @property {boolean} safari - Set to true if running in Safari.
    * @default
    */
    safari: false,

    /**
    * @property {number} safariVersion - If running in Safari this will contain the major version number.
    * @default
    */
    safariVersion: 0,

    /**
    * @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)
    * @default
    */
    trident: false,

    /**
    * @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}
    * @default
    */
    tridentVersion: 0,

    /**
    * @property {boolean} edge - Set to true if running in Microsoft Edge browser.
    * @default
    */
    edge: false,

    /**
    * @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)
    * @default
    */
    silk: false

};

function init ()
{
    var ua = navigator.userAgent;

    if ((/Arora/).test(ua))
    {
        Browser.arora = true;
    }
    else if (/Edge\/\d+/.test(ua))
    {
        Browser.edge = true;
    }
    else if ((/Chrome\/(\d+)/).test(ua) && !OS.windowsPhone)
    {
        Browser.chrome = true;
        Browser.chromeVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Epiphany/).test(ua))
    {
        Browser.epiphany = true;
    }
    else if ((/Firefox\D+(\d+)/).test(ua))
    {
        Browser.firefox = true;
        Browser.firefoxVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/AppleWebKit/).test(ua) && OS.iOS)
    {
        Browser.mobileSafari = true;
    }
    else if ((/MSIE (\d+\.\d+);/).test(ua))
    {
        Browser.ie = true;
        Browser.ieVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Midori/).test(ua))
    {
        Browser.midori = true;
    }
    else if ((/Opera/).test(ua))
    {
        Browser.opera = true;
    }
    else if ((/Safari/).test(ua) && !OS.windowsPhone)
    {
        Browser.safari = true;
    }
    else if ((/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/).test(ua))
    {
        Browser.ie = true;
        Browser.trident = true;
        Browser.tridentVersion = parseInt(RegExp.$1, 10);
        Browser.ieVersion = parseInt(RegExp.$3, 10);
    }

    //  Silk gets its own if clause because its ua also contains 'Safari'
    if ((/Silk/).test(ua))
    {
        Browser.silk = true;
    }

    return Browser;
}

module.exports = init();


/***/ },
/* 6 */
/***/ function(module, exports) {

var Angle = function (line)
{
    return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
};

module.exports = Angle;


/***/ },
/* 7 */
/***/ function(module, exports) {


//  Encapsulates a 2D rectangle defined by its corner point in the top-left
//  and its extends in x (width) and y (height)

var Rectangle = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Rectangle.prototype.constructor = Rectangle;

Rectangle.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    }

};

Object.defineProperties(Rectangle.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Rectangle;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

var GetURL = __webpack_require__(226);
var CONST = __webpack_require__(3);
var XHRLoader = __webpack_require__(227);
var XHRSettings = __webpack_require__(29);
var MergeXHRSettings = __webpack_require__(56);

var File = function (type, key, url, responseType, xhrSettings)
{
    //  file type (image, json, etc) for sorting within the Loader
    this.type = type;

    //  unique cache key (unique within its file type)
    this.key = key;

    //  The URL of the file, not including baseURL
    this.url = url;

    //  Set when the Loader calls 'load' on this file
    this.src = '';

    this.xhrSettings = XHRSettings(responseType);

    if (xhrSettings)
    {
        this.xhrSettings = MergeXHRSettings(this.xhrSettings, xhrSettings);
    }

    this.xhrLoader = null;

    this.state = CONST.FILE_PENDING;

    //  Set by onProgress (only if loading via XHR)
    this.bytesTotal = 0;
    this.bytesLoaded = -1;
    this.percentComplete = -1;

    //  For CORs based loading.
    //  If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)
    this.crossOrigin = undefined;

    //  The actual processed file data
    this.data = undefined;

    //  Multipart file? (i.e. an atlas and its json together)
    this.linkFile = undefined;
    this.linkType = '';

    this.callback = null;
};

File.prototype.constructor = File;

File.prototype = {

    resetXHR: function ()
    {
        this.xhrLoader.onload = undefined;
        this.xhrLoader.onerror = undefined;
        this.xhrLoader.onprogress = undefined;
    },

    //  Called when the Image loads
    //  ProgressEvent
    onLoad: function (event)
    {
        this.resetXHR();

        this.callback(this, true);
    },

    onError: function (event)
    {
        this.resetXHR();

        this.callback(this, false);
    },

    onProgress: function (event)
    {
        if (event.lengthComputable)
        {
            this.bytesLoaded = event.loaded;
            this.bytesTotal = event.total;

            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);
        }

        // console.log(this.percentComplete + '% (' + this.bytesLoaded + ' bytes)');
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.onComplete();

        callback(this);
    },

    onComplete: function ()
    {
        if (this.linkFile)
        {
            if (this.linkFile.state === CONST.FILE_WAITING_LINKFILE)
            {
                //  The linkfile has finished processing, and is waiting for this file, so let's do them both
                this.state = CONST.FILE_COMPLETE;
                this.linkFile.state = CONST.FILE_COMPLETE;
            }
            else
            {
                //  The linkfile still hasn't finished loading and/or processing yet
                this.state = CONST.FILE_WAITING_LINKFILE;
            }
        }
        else
        {
            this.state = CONST.FILE_COMPLETE;
        }
    },

    //  Called by the Loader, starts the actual file downloading
    load: function (callback, baseURL, globalXHR)
    {
        if (baseURL === undefined) { baseURL = ''; }

        this.callback = callback;

        this.src = GetURL(this, baseURL);

        if (this.src.indexOf('data:') === 0)
        {
            console.log('Local data URI');
        }
        else
        {
            this.xhrLoader = XHRLoader(this, globalXHR);
        }
    }
};

module.exports = File;


/***/ },
/* 9 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The GameObject Factory is a global level container of Factory instances.
* Factories register themselves with this container (when required)
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/

var factories = {};

var FactoryContainer = function ()
{
    // console.log('FactoryContainer is alive');

    this.register = function (factory)
    {
        if (factories.hasOwnProperty(factory.KEY))
        {
            // console.log('Already registered', factory.KEY);

            return this.getType(factory.KEY);
        }

        // console.log('registering', factory.KEY);

        factories[factory.KEY] = {
            add: factory.add,
            make: factory.make
        };

        return factory;
    };

    this.getType = function (key)
    {
        return factories[key];
    };

    this.load = function (dest, isFactory)
    {
        for (var factory in factories)
        {
            if (factories.hasOwnProperty(factory))
            {
                // console.log('Loading', factory);

                dest[factory] = (isFactory) ? factories[factory].add : factories[factory].make;
            }
        }

        return dest;
    };

    return this;
};

module.exports = FactoryContainer();


/***/ },
/* 10 */
/***/ function(module, exports) {

module.exports = {

    DEFAULT: 0,
    LINEAR: 0,
    NEAREST: 1

};


/***/ },
/* 11 */
/***/ function(module, exports) {

var Wrap = function (value, min, max)
{
    var range = max - min;

    if (range <= 0)
    {
        return 0;
    }

    var result = (value - min) % range;

    if (result < 0)
    {
        result += range;
    }

    return result + min;
};

module.exports = Wrap;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

var MathWrap = __webpack_require__(11);

var Wrap = function (angle)
{
    return MathWrap(angle, -Math.PI, Math.PI);
};

module.exports = Wrap;


/***/ },
/* 13 */
/***/ function(module, exports) {

//  Source object
//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
//  The default value to use if the key doesn't exist

var GetObjectValue = function (source, key, defaultValue)
{
    if (key.indexOf('.'))
    {
        var keys = key.split('.');
        var parent = source;
        var value = defaultValue;

        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++)
        {
            if (parent.hasOwnProperty(keys[i]))
            {
                //  Yes it has a key property, let's carry on down
                value = parent[keys[i]];

                parent = parent[keys[i]];
            }
            else
            {
                break;
            }
        }

        return value;
    }
    else
    {
        return (source.hasOwnProperty(key)) ? source[key] : defaultValue;
    }
};

module.exports = GetObjectValue;


/***/ },
/* 14 */
/***/ function(module, exports) {

var Event = function (type)
{
    this.type = type;

    this.target;

    this._propagate = true;
};

Event.prototype.constructor = Event;

Event.prototype = {

    reset: function (target)
    {
        this.target = target;

        this._propagate = true;
    },

    stopPropagation: function ()
    {
        this._propagate = false;
    }

};

module.exports = Event;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

var EventBinding = __webpack_require__(104);

var EventDispatcher = function ()
{
    this.bindings = {};
    this.filters = [];
    this.hasFilters = false;
};

EventDispatcher.prototype.constructor = EventDispatcher;

EventDispatcher.prototype = {

    getBinding: function (type)
    {
        if (this.bindings.hasOwnProperty(type))
        {
            return this.bindings[type];
        }
    },

    createBinding: function (type)
    {
        if (!this.getBinding(type))
        {
            this.bindings[type] = new EventBinding(this, type);
        }

        return this.bindings[type];
    },

    on: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, false);
        }

        return this;
    },

    once: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, true);
        }

        return this;
    },

    //  Add a callback that is notified every time this EventDispatcher dispatches an event
    //  no matter what the event type is. Filters are invoked first, before any bindings,
    //  and can stop events if they wish (in which case they'll never reach the bindings)
    filter: function (callback)
    {
        var i = this.filters.indexOf(callback);

        if (i === -1)
        {
            //  Add the filter
            this.filters.push(callback);
        }
        else
        {
            //  Remove the filter
            this.filters.splice(i, 1);
        }
        
        this.hasFilters = (this.filters.length > 0);

        return this;
    },

    has: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.has(listener);
        }
        else
        {
            return false;
        }
    },

    total: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.total();
        }
    },

    //  Removes an event listener.
    //  If there is no matching listener registered with the EventDispatcher, a call to this method has no effect.
    off: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.remove(listener);
        }

        return this;
    },

    _dispatchHandler: function (event)
    {
        event.reset(this);

        //  Pass the event through the filters first

        if (this.hasFilters)
        {
            for (var i = 0; i < this.filters.length; i++)
            {
                this.filters[i].call(this, event);

                //  Did the filter kill the event? If so, we can abort now
                if (!event._propagate)
                {
                    return;
                }
            }
        }

        var binding = this.getBinding(event.type);

        if (binding)
        {
            binding.dispatch(event);
        }
    },

    dispatch: function (event)
    {
        if (Array.isArray(event))
        {
            for (var i = 0; i < event.length; i++)
            {
                this._dispatchHandler(event[i]);
            }
        }
        else
        {
            this._dispatchHandler(event);
        }
    },

    //  Removes all listeners, but retains the event type entries
    removeAll: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.removeAll();
        }

        return this;
    },

    removeAllFilters: function ()
    {
        this.filters.length = 0;

        this.hasFilters = false;

        return this;
    },

    delete: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.destroy();

            delete this.bindings[type];
        }

        return this;
    },

    deleteAll: function ()
    {
        for (var binding in this.bindings)
        {
            binding.destroy();
        }

        this.bindings = {};
    },

    destroy: function ()
    {
        this.deleteAll();
        this.removeAllFilters();
    }

};

module.exports = EventDispatcher;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var ImageFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.image\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.png';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'image', key, url, 'blob', xhrSettings);
};

ImageFile.prototype = Object.create(File.prototype);
ImageFile.prototype.constructor = ImageFile;

ImageFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = new Image();

    this.data.crossOrigin = this.crossOrigin;

    var _this = this;

    this.data.onload = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.onComplete();

        callback(_this);
    };

    this.data.onerror = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.state = CONST.FILE_ERRORED;

        callback(_this);
    };

    this.data.src = URL.createObjectURL(this.xhrLoader.response);
};

module.exports = ImageFile;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

var IsPlainObject = __webpack_require__(75);

/**
* This is a slightly modified version of http://api.jquery.com/jQuery.extend/
* 
* @method Phaser.Utils.extend
* @param {boolean} deep - Perform a deep copy?
* @param {object} target - The target object to copy to.
* @return {object} The extended object.
*/
var Extend = function ()
{
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean")
    {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // extend Phaser if only one argument is passed
    if (length === i)
    {
        target = this;
        --i;
    }

    for (; i < length; i++)
    {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null)
        {
            // Extend the base object
            for (name in options)
            {
                src = target[name];
                copy = options[name];

                // Prevent never-ending loop
                if (target === copy)
                {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))
                {
                    if (copyIsArray)
                    {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    }
                    else
                    {
                        clone = src && IsPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[name] = Extend(deep, clone, copy);

                // Don't bring in undefined values
                }
                else if (copy !== undefined)
                {
                    target[name] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

module.exports = Extend;


/***/ },
/* 18 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Children Component features quick access to Group sorting related methods.
*
* @class
*/
var Children = function (gameObject)
{
    this.gameObject = gameObject;

    //  The objects that belong to this collection.
    //  The equivalent of the old `Sprite.children` array.
    this.list = [];

    this.position = 0;
};

Children.prototype.constructor = Children;

Children.prototype = {

    add: function (child, skipTransform)
    {
        if (skipTransform === undefined) { skipTransform = false; }

        // console.log('--->', this.gameObject.name, 'adds new child:', child.name);

        if (child.parent === this)
        {
            // console.log('Children.add 1');
            return child;
        }
        else if (child.parent)
        {
            // console.log('Children.add 2');
            child.parent.children.remove(child);
        }

        child.parent = this.gameObject;

        this.list.push(child);

        if (!skipTransform && this.gameObject.transform && child.transform)
        {
            // console.log(this.gameObject.name, 'adds transform from', child.name);
            this.gameObject.transform.add(child.transform);
        }

        // console.log('<--- end');

        return child;
    },

    addAt: function (child, index, skipTransform)
    {
        if (index === undefined) { index = 0; }
        if (skipTransform === undefined) { skipTransform = false; }

        if (this.list.length === 0)
        {
            return this.add(child);
        }

        if (index >= 0 && index <= this.list.length)
        {
            if (child.parent)
            {
                child.parent.children.remove(child);
            }

            child.parent = this;

            this.list.splice(index, 0, child);
        }

        if (!skipTransform && this.gameObject.transform && child.transform)
        {
            this.gameObject.transform.add(child.transform);
        }

        return child;

    },

    addMultiple: function (children, skipTransform)
    {
        if (Array.isArray(children))
        {
            for (var i = 0; i < children.length; i++)
            {
                this.add(children[i], skipTransform);
            }
        }

        return children;
    },

    getAt: function (index)
    {
        return this.list[index];
    },

    getIndex: function (child)
    {
        //  Return -1 if given child isn't a child of this parent
        return this.list.indexOf(child);
    },

    /**
    * Gets the first item from the set based on the property strictly equaling the value given.
    * Returns null if not found.
    *
    * @method Phaser.ArraySet#getByKey
    * @param {string} property - The property to check against the value.
    * @param {any} value - The value to check if the property strictly equals.
    * @return {any} The item that was found, or null if nothing matched.
    */
    getByKey: function (property, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i][property] === value)
            {
                return this.list[i];
            }
        }

        return null;
    },

    /**
    * Searches the Group for the first instance of a child with the `name`
    * property matching the given argument. Should more than one child have
    * the same name only the first instance is returned.
    *
    * @method Phaser.Group#getByName
    * @param {string} name - The name to search for.
    * @return {any} The first child with a matching name, or null if none were found.
    */
    getByName: function (name)
    {
        return this.getByKey('name', name);
    },

    /**
    * Returns a random child from the group.
    *
    * @method Phaser.Group#getRandom
    * @param {integer} [startIndex=0] - Offset from the front of the group (lowest child).
    * @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.
    * @return {any} A random child of this Group.
    */
    getRandom: function (startIndex, length)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (length === undefined) { length = this.list.length; }

        if (length === 0 || length > this.list.length)
        {
            return null;
        }

        var randomIndex = startIndex + Math.floor(Math.random() * length);

        return this.list[randomIndex];
    },

    /**
    * Returns all children in this Group.
    *
    * You can optionally specify a matching criteria using the `property` and `value` arguments.
    *
    * For example: `getAll('exists', true)` would return only children that have their exists property set.
    *
    * Optionally you can specify a start and end index. For example if this Group had 100 children,
    * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
    * the first 50 children in the Group.
    *
    * @method Phaser.Group#getAll
    * @param {string} [property] - An optional property to test against the value argument.
    * @param {any} [value] - If property is set then Child.property must strictly equal this value to be included in the results.
    * @param {integer} [startIndex=0] - The first child index to start the search from.
    * @param {integer} [endIndex] - The last child index to search up until.
    * @return {any} A random existing child of this Group.
    */
    getAll: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var output = [];

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (property)
            {
                if (child[property] === value)
                {
                    output.push(child);
                }
            }
            else
            {
                output.push(child);
            }
        }

        return output;
    },

    swap: function (child1, child2)
    {
        if (child1 === child2)
        {
            return;
        }

        var index1 = this.getIndex(child1);
        var index2 = this.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of the same parent');
        }

        this.list[index1] = child2;
        this.list[index2] = child1;
    },

    //   was setIndex
    moveTo: function (child, index)
    {
        var currentIndex = this.getIndex(child);

        if (currentIndex === -1 || index < 0 || index >= this.list.length)
        {
            throw new Error('Children.moveTo: The supplied index is out of bounds');
        }

        //  Remove
        this.list.splice(currentIndex, 1);

        //  Add in new location
        this.list.splice(index, 0, child);

        return child;
    },

    remove: function (child, skipTransform)
    {
        var index = this.list.indexOf(child);

        if (index !== -1)
        {
            child.parent = undefined;

            this.list.splice(index, 1);

            if (!skipTransform && this.gameObject.transform && child.transform)
            {
                this.gameObject.transform.remove(child.transform);
            }
        }
        
        return child;
    },

    removeAt: function (index, skipTransform)
    {
        var child = this.list[index];

        if (child)
        {
            child.parent = undefined;

            this.children.splice(index, 1);

            if (!skipTransform && this.gameObject.transform && child.transform)
            {
                this.gameObject.transform.remove(child.transform);
            }
        }

        return child;
    },

    removeBetween: function (beginIndex, endIndex)
    {
        if (beginIndex === undefined) { beginIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var range = endIndex - beginIndex;

        if (range > 0 && range <= endIndex)
        {
            var removed = this.list.splice(beginIndex, range);

            for (var i = 0; i < removed.length; i++)
            {
                removed[i].parent = undefined;
            }

            return removed;
        }
        else if (range === 0 && this.list.length === 0)
        {
            return [];
        }
        else
        {
            throw new Error('Children.removeBetween: Range Error, numeric values are outside the acceptable range');
        }
    },

    /**
    * Removes all the items.
    *
    * @method Phaser.ArraySet#removeAll
    */
    removeAll: function ()
    {
        var i = this.list.length;

        while (i--)
        {
            this.remove(this.list[i]);
        }

        return this;
    },

    //  Check to see if the given child is a child of this object, at any depth (recursively scans up the tree)
    contains: function (child)
    {
        if (!child)
        {
            return false;
        }
        else if (child.parent === this)
        {
            return true;
        }
        else
        {
            return this.contains(child.parent);
        }
    },

    /**
    * Brings the given child to the top of this group so it renders above all other children.
    *
    * @method Phaser.Group#bringToTop
    * @param {any} child - The child to bring to the top of this group.
    * @return {any} The child that was moved.
    */
    bringToTop: function (child)
    {
        if (child.parent === this && this.getIndex(child) < this.list.length)
        {
            this.remove(child);
            this.add(child);
        }

        return child;
    },

    /**
    * Sends the given child to the bottom of this group so it renders below all other children.
    *
    * @method Phaser.Group#sendToBack
    * @param {any} child - The child to send to the bottom of this group.
    * @return {any} The child that was moved.
    */
    sendToBack: function (child)
    {
        if (child.parent === this && this.getIndex(child) > 0)
        {
            this.remove(child);
            this.addAt(child, 0);
        }

        return child;
    },

    /**
    * Moves the given child up one place in this group unless it's already at the top.
    *
    * @method Phaser.Group#moveUp
    * @param {any} child - The child to move up in the group.
    * @return {any} The child that was moved.
    */
    moveUp: function (child)
    {
        var a = this.getIndex(child);

        if (a !== -1 && a < this.list.length - 1)
        {
            var b = this.getAt(a + 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Moves the given child down one place in this group unless it's already at the bottom.
    *
    * @method Phaser.Group#moveDown
    * @param {any} child - The child to move down in the group.
    * @return {any} The child that was moved.
    */
    moveDown: function (child)
    {
        var a = this.getIndex(child);

        if (a > 0)
        {
            var b = this.getAt(a - 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Reverses all children in this group.
    *
    * This operation applies only to immediate children and does not propagate to subgroups.
    *
    * @method Phaser.Group#reverse
    */
    reverse: function ()
    {
        this.list.reverse();

        return this;
    },

    shuffle: function ()
    {
        for (var i = this.list.length - 1; i > 0; i--)
        {
            var j = Math.floor(Math.random() * (i + 1));
            var temp = this.list[i];
            this.list[i] = this.list[j];
            this.list[j] = temp;
        }

        return this;
    },

    /**
    * Replaces a child of this Group with the given newChild. The newChild cannot be a member of this Group.
    *
    * If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
    *
    * If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
    *
    * @method Phaser.Group#replace
    * @param {any} oldChild - The child in this group that will be replaced.
    * @param {any} newChild - The child to be inserted into this group.
    * @return {any} Returns the oldChild that was replaced within this group.
    */
    replace: function (oldChild, newChild, skipTransform)
    {
        var index = this.getIndex(oldChild);

        if (index !== -1)
        {
            if (newChild.parent)
            {
                newChild.parent.remove(newChild, skipTransform);
            }

            this.remove(oldChild, skipTransform);

            this.addAt(newChild, index, skipTransform);

            return oldChild;
        }
    },

    //  Swaps a child from another parent, with one from this parent.
    //  child1 = the child of THIS parent
    //  child2 = the child of the OTHER parent
    exchange: function (child1, child2, skipTransform)
    {
        if (child1 === child2 || child1.parent === child2.parent)
        {
            return;
        }

        var parentChildren = child2.parent.children;

        var index1 = this.getIndex(child1);
        var index2 = parentChildren.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of parents');
        }

        this.remove(child1, skipTransform);

        parentChildren.remove(child2, skipTransform);

        this.addAt(child2, index1, skipTransform);

        parentChildren.addAt(child1, index2, skipTransform);
    },

    /**
    * Checks for the item within this list.
    *
    * @method Phaser.ArraySet#exists
    * @param {any} item - The element to get the list index for.
    * @return {boolean} True if the item is found in the list, otherwise false.
    */
    exists: function (child)
    {
        return (this.list.indexOf(child) > -1);
    },

    /**
    * Sets the property `key` to the given value on all members of this list.
    *
    * @method Phaser.ArraySet#setAll
    * @param {any} key - The property of the item to set.
    * @param {any} value - The value to set the property to.
    */
    setAll: function (key, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i])
            {
                this.list[i][key] = value;
            }
        }
    },

    /**
    * Passes all children to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (i = 0; i < this.list.length; i++)
        {
            args[0] = this.list[i];
            callback.apply(thisArg, args);
        }
    },

    /**
    * Moves all children from this Group to the Group given.
    *
    * @method Phaser.Group#moveAll
    * @param {Phaser.Group} group - The new Group to which the children will be moved to.
    * @param {boolean} [silent=false] - If true the children will not dispatch the `onAddedToGroup` event for the new Group.
    * @return {Phaser.Group} The Group to which all the children were moved.
    */
    reparent: function (newParent)
    {
        if (newParent !== this)
        {
            for (var i = 0; i < this.list.length; i++)
            {
                var child = this.remove(this.list[i]);

                newParent.add(child);
            }
        }

        return newParent;
    }

};

Object.defineProperties(Children.prototype, {

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    length: {

        enumerable: true,

        get: function ()
        {
            return this.list.length;
        }

    },

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    first: {

        enumerable: true,

        get: function ()
        {
            this.position = 0;

            if (this.list.length > 0)
            {
                return this.list[0];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the last item and resets the cursor to the end.
    *
    * @name Phaser.ArraySet#last
    * @property {any} last
    */
    last: {

        enumerable: true,

        get: function ()
        {
            if (this.list.length > 0)
            {
                this.position = this.list.length - 1;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the the next item (based on the cursor) and advances the cursor.
    *
    * @name Phaser.ArraySet#next
    * @property {any} next
    */
    next: {

        enumerable: true,

        get: function ()
        {
            if (this.position < this.list.length)
            {
                this.position++;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the the previous item (based on the cursor) and retreats the cursor.
    *
    * @name Phaser.ArraySet#previous
    * @property {any} previous
    */
    previous: {

        enumerable: true,

        get: function ()
        {
            if (this.position > 0)
            {
                this.position--;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    }

});

module.exports = Children;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Children: __webpack_require__(18),
    Color: __webpack_require__(92),
    Data: __webpack_require__(93),
    Transform: __webpack_require__(94)

};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);

/**
 * The pool into which the canvas elements are placed.
 *
 * @property pool
 * @type Array
 */
var pool = [];

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games on the same page
//  can share the one single pool

/**
* The CanvasPool is a global static object, that allows Phaser to recycle and pool Canvas DOM elements.
*
* @class Phaser.CanvasPool
* @static
*/
var CanvasPool = function ()
{
    /**
    * Creates a new Canvas DOM element, or pulls one from the pool if free.
    * 
    * @method Phaser.CanvasPool.create
    * @static
    * @param {any} parent - The parent of the canvas element.
    * @param {number} width - The width of the canvas element.
    * @param {number} height - The height of the canvas element.
    * @return {HTMLCanvasElement} The canvas element.
    */
    var create = function (parent, width, height, type)
    {
        if (width === undefined) { width = 1; }
        if (height === undefined) { height = 1; }
        if (type === undefined) { type = CONST.CANVAS; }

        var canvas;
        var container = first(type);

        if (container === null)
        {
            // console.log('CanvasPool.create new');

            container = {
                parent: parent,
                canvas: document.createElement('canvas'),
                type: type
            };

            pool.push(container);

            canvas = container.canvas;
        }
        else
        {
            // console.log('CanvasPool.create existing');

            container.parent = parent;

            canvas = container.canvas;
        }

        canvas.width = width;
        canvas.height = height;
        
        return canvas;
    };

    var create2D = function (parent, width, height)
    {
        return create(parent, width, height, CONST.CANVAS);
    };

    var createWebGL = function (parent, width, height)
    {
        return create(parent, width, height, CONST.WEBGL);
    };

    /**
    * Gets the first free canvas index from the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getFirst
    * @return {number}
    */
    var first = function (type)
    {
        if (type === undefined) { type = CONST.CANVAS; }

        pool.forEach(function (container)
        {
            if (!container.parent && container.type === type)
            {
                return container;
            }
        });

        return null;
    };

    /**
    * Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.
    * The canvas has its width and height set to 1, and its parent attribute nulled.
    * 
    * @static
    * @method Phaser.CanvasPool.remove
    * @param {any|HTMLCanvasElement} parent - The parent of the canvas element.
    */
    var remove = function (parent)
    {
        //  Check to see if the parent is a canvas object
        var isCanvas = parent instanceof HTMLCanvasElement;

        pool.forEach(function (container)
        {
            if ((isCanvas && container.canvas === parent) || (!isCanvas && container.parent === parent))
            {
                // console.log('CanvasPool.remove found and removed');
                container.parent = null;
                container.canvas.width = 1;
                container.canvas.height = 1;
            }
        });
    };

    /**
    * Gets the total number of used canvas elements in the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getTotal
    * @return {number} The number of in-use (parented) canvas elements in the pool.
    */
    var total = function ()
    {
        var c = 0;

        pool.forEach(function (container)
        {
            if (container.parent)
            {
                c++;
            }
        });

        return c;
    };

    /**
    * Gets the total number of free canvas elements in the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getFree
    * @return {number} The number of free (un-parented) canvas elements in the pool.
    */
    var free = function ()
    {
        return pool.length - total();
    };

    return {
        create: create,
        create2D: create2D,
        createWebGL: createWebGL,
        first: first,
        remove: remove,
        total: total,
        free: free,
        pool: pool
    };
};

//  If we export the called function here, it'll only be invoked once (not every time it's required).
module.exports = CanvasPool();


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var MATH_CONST = __webpack_require__(2);
var ScaleModes = __webpack_require__(10);
var Component = __webpack_require__(19);
var WrapAngle = __webpack_require__(12);

/**
* This is the base Game Object class that you can use when creating your own extended Game Objects.
* It hides away the 'private' stuff and exposes only the useful getters, setters and properties.
*
* @class
*/

//  Phaser.Texture and Phaser.Frame objects passed in here, instead of looked-up.
//  Allows override from non-standard GO types

var GameObject = function (state, x, y, texture, frame, parent)
{
    this.state = state;

    this.game = state.game;

    this.name = '';

    this.type = 0;

    this.parent = parent;

    //  Texture is globally shared between GameObjects, not specific to this one
    this.texture = texture;

    //  Frame is globally shared between GameObjects, not specific to this one
    this.frame = frame;

    //  All GameObjects have the following components, always:
    this.transform = new Component.Transform(this, x, y);

    //  Optional? Maybe set on a per GO basis?
    this.data = new Component.Data(this);

    this.color = new Component.Color(this);

    //  ----------------------------------------------------------------
    //  ----------------------------------------------------------------
    //  The following properties are debatable to have in this class
    //  ----------------------------------------------------------------
    //  ----------------------------------------------------------------

    this.scaleMode = ScaleModes.DEFAULT;

    //  Allows you to turn off a GameObject from rendering, but still render its children (if it has any)
    //  Maybe this should move?
    // this.skipRender = (key === undefined);
    this.skipRender = false;

    this.visible = true;

    //  Either null, or the Children component
    this.children = null;

    this.exists = true;
};

GameObject.prototype.constructor = GameObject;

GameObject.prototype = {

    preUpdate: function ()
    {
        //  NOOP
    },

    update: function ()
    {
        //  NOOP
    },

    postUpdate: function ()
    {
        //  NOOP
    },

    render: function ()
    {
        //  NOOP
    },

    destroy: function ()
    {
        //  NOOP
    }

};

Object.defineProperties(GameObject.prototype, {

    //  Transform getters / setters

    x: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posX;
        },

        set: function (value)
        {
            this.transform._posX = value;
            this.transform.dirty = true;
        }

    },

    y: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posY;
        },

        set: function (value)
        {
            this.transform._posY = value;
            this.transform.dirty = true;
        }

    },

    scale: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleY;
        },

        set: function (value)
        {
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    anchor: {

        enumerable: true,

        get: function ()
        {
            return this.transform._anchorX;
        },

        set: function (value)
        {
            this.transform.setAnchor(value);
        }

    },

    anchorX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._anchorX;
        },

        set: function (value)
        {
            this.transform._anchorX = value;
            this.transform.dirty = true;
        }

    },

    anchorY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._anchorY;
        },

        set: function (value)
        {
            this.transform._anchorY = value;
            this.transform.dirty = true;
        }

    },

    pivotX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotX;
        },

        set: function (value)
        {
            this.transform._pivotX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    pivotY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotY;
        },

        set: function (value)
        {
            this.transform._pivotY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    angle: {

        enumerable: true,

        get: function ()
        {
            return WrapAngle(this.rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            this.rotation = WrapAngle(value) * MATH_CONST.DEG_TO_RAD;
        }

    },

    rotation: {

        enumerable: true,

        get: function ()
        {
            return this.transform._rotation;
        },

        set: function (value)
        {
            if (this.transform._rotation === value)
            {
                return;
            }

            this.transform._rotation = value;
            this.transform.dirty = true;

            if (this.transform._rotation % MATH_CONST.PI2)
            {
                this.transform.cache.sr = Math.sin(this.transform._rotation);
                this.transform.cache.cr = Math.cos(this.transform._rotation);
                this.transform.updateCache();
                this.transform.hasLocalRotation = true;
            }
            else
            {
                this.transform.hasLocalRotation = false;
            }
        }

    },

    //  Color getters / setters

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this.color._alpha;
        },

        set: function (value)
        {
            this.color.alpha = value;
        }

    },

    blendMode: {

        enumerable: true,

        get: function ()
        {
            return this.color._blendMode;
        },

        set: function (value)
        {
            this.color.blendMode = value;
        }

    }

});

module.exports = GameObject;


/***/ },
/* 22 */
/***/ function(module, exports) {

var Contains = function (circle, x, y)
{
    //  Check if x/y are within the bounds first
    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom)
    {
        var dx = (circle.x - x) * (circle.x - x);
        var dy = (circle.y - y) * (circle.y - y);

        return (dx + dy) <= (circle.radius * circle.radius);
    }
    else
    {
        return false;
    }
};

module.exports = Contains;


/***/ },
/* 23 */
/***/ function(module, exports) {

var Contains = function (ellipse, x, y)
{
    if (ellipse.width <= 0 || ellipse.height <= 0)
    {
        return false;
    }
 
    //  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5
    var normx = ((x - ellipse.x) / ellipse.width) - 0.5;
    var normy = ((y - ellipse.y) / ellipse.height) - 0.5;
 
    normx *= normx;
    normy *= normy;
 
    return (normx + normy < 0.25);
};

module.exports = Contains;


/***/ },
/* 24 */
/***/ function(module, exports) {

/**
* Convert a distance along this curve into a `time` value which will be between 0 and 1.
* 
* For example if this curve has a length of 100 pixels then `findT(50)` would return `0.5`.
*
* @method Phaser.Hermite#findT
* @param {integer} distance - The distance into the curve in pixels. Should be a positive integer.
* @return {number} The time (`t`) value, a float between 0 and 1.
*/
var FindT = function (curve, distance)
{
    if (distance <= 0)
    {
        return 0;
    }

    //  Find the _points which bracket the distance value
    var ti = Math.floor(distance / curve.length * curve._accuracy);

    while (ti > 0 && curve._points[ti] > distance)
    {
        ti--;
    }

    while (ti < curve._accuracy && curve._points[ti] < distance)
    {
        ti++;
    }

    //  Linear interpolation to get a more accurate fix
    var dt = curve._points[ti] - curve._points[ti - 1];
    var d = distance - curve._points[ti - 1];

    return ((ti - 1) / curve._accuracy) + d / (dt * curve._accuracy);
};

module.exports = FindT;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

/**
* Get a point on the curve using the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getPoint
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @param {Phaser.Point|Object} [point] - An optional Phaser.Point, or Object containing public `x` and `y` properties. If given the resulting values will be stored in the Objects `x` and `y` properties. If omitted a new Phaser.Point object is created.
* @return {Phaser.Point} An Object with the x, y coordinate of the curve at the specified `t` value set in its `x` and `y` properties.
*/
var GetPoint = function (curve, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    if (t < 0)
    {
        t = 0;
    }

    if (t > 1)
    {
        t = 1;
    }

    var t2 = t * t;
    var t3 = t * t2;

    out.x = t3 * curve._ax + t2 * curve._bx + t * curve._v1x + curve._p1x;
    out.y = t3 * curve._ay + t2 * curve._by + t * curve._v1y + curve._p1y;

    return out;
};

module.exports = GetPoint;


/***/ },
/* 26 */
/***/ function(module, exports) {


var RotateAroundXY = function (line, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = line.x1 - x;
    var ty = line.y1 - y;

    line.x1 = tx * c - ty * s + x;
    line.y1 = tx * s + ty * c + y;

    tx = line.x2 - x;
    ty = line.y2 - y;

    line.x2 = tx * c - ty * s + x;
    line.y2 = tx * s + ty * c + y;

    return line;
};

module.exports = RotateAroundXY;


/***/ },
/* 27 */
/***/ function(module, exports) {

var Dot = function (pointA, pointB)
{
    return ((pointA.x * pointB.x) + (pointA.y * pointB.y));
};

module.exports = Dot;


/***/ },
/* 28 */
/***/ function(module, exports) {

var GetAspectRatio = function (rect)
{
    return (rect.height === 0) ? NaN : rect.width / rect.height;
};

module.exports = GetAspectRatio;


/***/ },
/* 29 */
/***/ function(module, exports) {

//  Creates an XHRSettings Object with default values

var XHRSettings = function (responseType, async, user, password, timeout)
{
    if (responseType === undefined) { responseType = ''; }
    if (async === undefined) { async = true; }
    if (user === undefined) { user = ''; }
    if (password === undefined) { password = ''; }
    if (timeout === undefined) { timeout = 0; }

    // Before sending a request, set the xhr.responseType to "text", 
    // "arraybuffer", "blob", or "document", depending on your data needs. 
    // Note, setting xhr.responseType = '' (or omitting) will default the response to "text".

    return {

        //  Ignored by the Loader, only used by File.
        responseType: responseType,

        async: async,

        //  credentials
        user: user,
        password: password,

        //  timeout in ms (0 = no timeout)
        timeout: timeout,

        //  setRequestHeader
        header: undefined,
        headerValue: undefined,

        //  overrideMimeType
        overrideMimeType: undefined

    };
    
};

module.exports = XHRSettings;


/***/ },
/* 30 */
/***/ function(module, exports) {

var CreateBuffer = function (gl, bufferType, usage, bufferData, bufferSize)
{
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    if (bufferData && ArrayBuffer.isView(bufferData))
    {
        gl.bufferData(bufferType, bufferData, usage);
    }
    else
    {
        gl.bufferData(bufferType, bufferSize, usage);
    }
    return buffer;
};

module.exports = CreateBuffer;


/***/ },
/* 31 */
/***/ function(module, exports) {

var IndexBuffer = function (byteSize)
{
    this.wordLength = 0;
    this.wordCapacity = byteSize / 2;
    this.buffer = new ArrayBuffer(byteSize);
    this.shortView = new Int16Array(this.buffer);
    this.wordView = new Uint16Array(this.buffer);
};

IndexBuffer.prototype.clear = function ()
{
    this.wordLength = 0;
};

IndexBuffer.prototype.getByteLength = function ()
{
    return this.wordLength * 2;
};

IndexBuffer.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

IndexBuffer.prototype.allocate = function (wordSize)
{
    var currentLength = this.wordLength;
    this.wordLength += wordSize;
    return currentLength;
};

IndexBuffer.prototype.getUsedBufferAsShort = function ()
{
    return this.shortView.subarray(0, this.dwordLength);
};

IndexBuffer.prototype.getUsedBufferAsWord = function ()
{
    return this.wordView.subarray(0, this.dwordLength);
};

module.exports = IndexBuffer;


/***/ },
/* 32 */
/***/ function(module, exports) {

var VertexBuffer = function (byteSize)
{
    this.dwordLength = 0;
    this.dwordCapacity = byteSize / 4;
    this.buffer = new ArrayBuffer(byteSize);
    this.floatView = new Float32Array(this.buffer);
    this.intView = new Int32Array(this.buffer);
    this.uintView = new Uint32Array(this.buffer);
};

VertexBuffer.prototype.clear = function ()
{
    this.dwordLength = 0;
};

VertexBuffer.prototype.getByteLength = function ()
{
    return this.dwordLength * 4;
};

VertexBuffer.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

VertexBuffer.prototype.allocate = function (dwordSize)
{
    var currentLength = this.dwordLength;
    this.dwordLength += dwordSize;
    return currentLength;
};

VertexBuffer.prototype.getUsedBufferAsFloat = function ()
{
    return this.floatView.subarray(0, this.dwordLength);
};

VertexBuffer.prototype.getUsedBufferAsInt = function ()
{
    return this.intView.subarray(0, this.dwordLength);
};

VertexBuffer.prototype.getUsedBufferAsUint = function ()
{
    return this.uintView.subarray(0, this.dwordLength);
};

module.exports = VertexBuffer;


/***/ },
/* 33 */
/***/ function(module, exports) {

var CreateProgram = function (gl, vertexShader, fragmentShader)
{
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Failed to link program. Error: \n' + gl.getProgramInfoLog(program));
        return null;
    }
    return program;
};

module.exports = CreateProgram;


/***/ },
/* 34 */
/***/ function(module, exports) {

var CreateShader = function (gl, shaderSource, shaderType)
{
    var shader = null;
    shader = gl.createShader(shaderType);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        console.error('Failed ' + (shaderType === gl.VERTEX_SHADER ? 'vertex' : shaderType === gl.FRAGMENT_SHADER ? 'fragment' : 'invalid') + ' shader compilation. Error: \n' + gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
};

module.exports = CreateShader;


/***/ },
/* 35 */
/***/ function(module, exports) {

var BindVertexArray = function (gl, vao)
{
    var attributes = vao.attributes;
    gl.bindBuffer(gl.ARRAY_BUFFER, vao.buffer);
    for (var index = 0, length = attributes.length; index < length; ++index)
    {
        var attrib = attributes[index];
        var location = attrib.location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(
            location,
            attrib.size,
            attrib.type,
            attrib.normalized,
            attrib.stride,
            attrib.offset
        );
    }
};

module.exports = BindVertexArray;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

var Attribute = __webpack_require__(320);

var CreateAttribDesc = function (gl, program, name, size, type, normalized, stride, offset)
{
    return new Attribute(
        gl.getAttribLocation(program, name),
        size,
        type,
        normalized,
        stride,
        offset
    );
};

module.exports = CreateAttribDesc;


/***/ },
/* 37 */
/***/ function(module, exports) {

var VertexArray = function (vbo, attributes)
{
    this.buffer = vbo;
    this.attributes = attributes;
};

module.exports = VertexArray;


/***/ },
/* 38 */
/***/ function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(20);

var CanvasFeatures = {

    supportNewBlendModes: false,

    supportInverseAlpha: false

};

function checkBlendMode ()
{
    var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
    var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';

    var magenta = new Image();
    magenta.src = pngHead + 'AP804Oa6' + pngEnd;

    var yellow = new Image();
    yellow.src = pngHead + '/wCKxvRF' + pngEnd;

    var canvas = CanvasPool.create(this, 6, 1);
    var context = canvas.getContext('2d');

    context.globalCompositeOperation = 'multiply';
    context.drawImage(magenta, 0, 0);
    context.drawImage(yellow, 2, 0);

    if (!context.getImageData(2, 0, 1, 1))
    {
        return false;
    }

    var data = context.getImageData(2, 0, 1, 1).data;

    CanvasPool.remove(this);

    return (data[0] === 255 && data[1] === 0 && data[2] === 0);
}

function checkInverseAlpha ()
{
    var canvas = CanvasPool.create(this, 2, 1);
    var context = canvas.getContext('2d');

    context.fillStyle = 'rgba(10, 20, 30, 0.5)';

    //  Draw a single pixel
    context.fillRect(0, 0, 1, 1);

    //  Get the color values
    var s1 = context.getImageData(0, 0, 1, 1);

    if (s1 === null)
    {
        return false;
    }

    //  Plot them to x2
    context.putImageData(s1, 1, 0);

    //  Get those values
    var s2 = context.getImageData(1, 0, 1, 1);

    //  Compare and return
    return (s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]);
}

function init ()
{
    if (document !== undefined)
    {
        CanvasFeatures.supportNewBlendModes = checkBlendMode();
        CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
    }

    return CanvasFeatures;
}

module.exports = init();


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);
var CanvasPool = __webpack_require__(20);

var Features = {

    /**
    * @property {boolean} canvas - Is canvas available?
    * @default
    */
    canvas: false,

    /**
    * @property {?boolean} canvasBitBltShift - True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.
    * @default
    */
    canvasBitBltShift: null,

    /**
    * @property {boolean} webGL - Is webGL available?
    * @default
    */
    webGL: false,

    /**
    * @property {boolean} file - Is file available?
    * @default
    */
    file: false,

    /**
    * @property {boolean} fileSystem - Is fileSystem available?
    * @default
    */
    fileSystem: false,

    /**
    * @property {boolean} localStorage - Is localStorage available?
    * @default
    */
    localStorage: false,

    /**
    * @property {boolean} worker - Is worker available?
    * @default
    */
    worker: false,

    /**
    * @property {boolean} pointerLock - Is Pointer Lock available?
    * @default
    */
    pointerLock: false,

    /**
    * @property {boolean} vibration - Does the device support the Vibration API?
    * @default
    */
    vibration: false,

    /**
    * @property {boolean} getUserMedia - Does the device support the getUserMedia API?
    * @default
    */
    getUserMedia: true,

    /**
    * @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)
    * @default
    */
    littleEndian: false,

    /**
    * @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?
    * @default
    */
    support32bit: false

};

/**
* Check Little or Big Endian system.
*
* @author Matt DesLauriers (@mattdesl)
*/
function checkIsLittleEndian ()
{
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);

    b[0] = 0xa1;
    b[1] = 0xb2;
    b[2] = 0xc3;
    b[3] = 0xd4;

    if (c[0] === 0xd4c3b2a1)
    {
        return true;
    }

    if (c[0] === 0xa1b2c3d4)
    {
        return false;
    }
    else
    {
        //  Could not determine endianness
        return null;
    }
}

function init ()
{
    Features.canvas = !!window['CanvasRenderingContext2D'] || OS.cocoonJS;

    try
    {
        Features.localStorage = !!localStorage.getItem;
    }
    catch (error)
    {
        Features.localStorage = false;
    }

    Features.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];
    Features.fileSystem = !!window['requestFileSystem'];

    var isUint8 = false;

    var testWebGL = function ()
    {
        if (window['WebGLRenderingContext'])
        {
            try
            {
                var canvas = CanvasPool.createWebGL(this);

                if (OS.cocoonJS)
                {
                    canvas.screencanvas = false;
                }

                var ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                var canvas2D = CanvasPool.create2D(this);

                var ctx2D = canvas2D.getContext('2d');

                //  Can't be done on a webgl context
                var image = ctx2D.createImageData(1, 1);
    
                /**
                * Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.
                *
                * @author Matt DesLauriers (@mattdesl)
                */
                isUint8 = image.data instanceof Uint8ClampedArray;

                CanvasPool.remove(canvas);
                CanvasPool.remove(canvas2D);

                return (ctx !== null);
            }
            catch (e)
            {
                return false;
            }
        }
        
        return false;
    };

    Features.webGL = testWebGL();

    Features.worker = !!window['Worker'];

    Features.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

    window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;

    // Older versions of firefox (< 21) apparently claim support but user media does not actually work
    if (Browser.firefox && Browser.firefoxVersion < 21)
    {
        Features.getUserMedia = false;
    }

    // Excludes iOS versions as they generally wrap UIWebView (eg. Safari WebKit) and it
    // is safer to not try and use the fast copy-over method.
    if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome))
    {
        Features.canvasBitBltShift = true;
    }

    // Known not to work
    if (Browser.safari || Browser.mobileSafari)
    {
        Features.canvasBitBltShift = false;
    }

    navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;

    if (navigator.vibrate)
    {
        Features.vibration = true;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined')
    {
        Features.littleEndian = checkIsLittleEndian();
    }

    Features.support32bit = (
        typeof ArrayBuffer !== 'undefined' &&
        typeof Uint8ClampedArray !== 'undefined' &&
        typeof Int32Array !== 'undefined' &&
        Features.littleEndian !== null &&
        isUint8
    );

    return Features;
}

module.exports = init();


/***/ },
/* 41 */
/***/ function(module, exports) {

var EVENT_CONST = {

    DISPATCHER_IDLE: 0,
    DISPATCHER_DISPATCHING: 1,
    DISPATCHER_REMOVING: 2,
    DISPATCHER_DESTROYED: 3,

    LISTENER_PENDING: 4,
    LISTENER_ACTIVE: 5,
    LISTENER_REMOVING: 6

};

module.exports = EVENT_CONST;


/***/ },
/* 42 */
/***/ function(module, exports) {

var Circle = function (x, y, radius)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (radius === undefined) { radius = 0; }

    this.x = x;

    this.y = y;

    this._radius = radius;
    this._diameter = radius * 2;
};

Circle.prototype.constructor = Circle;

Circle.prototype = {

    setTo: function (x, y, radius)
    {
        this.x = x;
        this.y = y;
        this._radius = radius;
        this._diameter = radius * 2;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    isEmpty: function ()
    {
        return (this._radius <= 0);
    }

};

Object.defineProperties(Circle.prototype, {

    radius: {

        enumerable: true,

        get: function ()
        {
            return this._radius;
        },

        set: function (value)
        {
            this._radius = value;
            this._diameter = value * 2;
        }

    },

    diameter: {

        enumerable: true,

        get: function ()
        {
            return this._diameter;
        },

        set: function (value)
        {
            this._diameter = value;
            this._radius = value * 0.5;
        }

    },

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x - this._radius;
        },

        set: function (value)
        {
            this.x = value + this._radius;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this._radius;
        },

        set: function (value)
        {
            this.x = value - this._radius;
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y - this._radius;
        },

        set: function (value)
        {
            this.y = value + this._radius;
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this._radius;
        },

        set: function (value)
        {
            this.y = value - this._radius;
        }

    }

});

module.exports = Circle;


/***/ },
/* 43 */
/***/ function(module, exports) {

var Ellipse = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Ellipse.prototype.constructor = Ellipse;

Ellipse.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    },

    //  AKA Semi Minor Axis
    getMinorRadius: function ()
    {
        return Math.min(this.width, this.height) / 2;
    },

    //  AKA Semi Major Axis
    getMajorRadius: function ()
    {
        return Math.max(this.width, this.height) / 2;
    }

};

Object.defineProperties(Ellipse.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Ellipse;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

var GetPoint = __webpack_require__(25);

/**
* Calculate and return the angle, in radians, of the curves tangent based on time.
*
* @method Phaser.Hermite#getAngle
* @param {number} [t=0] - The `t` (time) value at which to find the angle. Must be between 0 and 1.
* @return {number} The angle of the line at the specified `t` time value along the curve. The value is in radians.
*/
var GetAngle = function (curve, t)
{
    if (t === undefined) { t = 0; }

    GetPoint(curve, t - 0.01, curve._temp1);
    GetPoint(curve, t + 0.01, curve._temp2);

    return Math.atan2(curve._temp2.y - curve._temp1.y, curve._temp2.x - curve._temp1.x);
};

module.exports = GetAngle;


/***/ },
/* 45 */
/***/ function(module, exports) {

var PointToLine = function (point, line)
{
    return ((point.x - line.x1) * (line.y2 - line.y1) === (line.x2 - line.x1) * (point.y - line.y1));
};

module.exports = PointToLine;


/***/ },
/* 46 */
/***/ function(module, exports) {

var RectangleToRectangle = function (rectA, rectB)
{
    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0)
    {
        return false;
    }

    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
};

module.exports = RectangleToRectangle;


/***/ },
/* 47 */
/***/ function(module, exports) {

//  Defines a Line segment, a part of a line between two endpoints

var Line = function (x1, y1, x2, y2)
{
    if (x1 === undefined) { x1 = 0; }
    if (y1 === undefined) { y1 = 0; }
    if (x2 === undefined) { x2 = 0; }
    if (y2 === undefined) { y2 = 0; }

    this.x1 = x1;

    this.y1 = y1;

    this.x2 = x2;

    this.y2 = y2;
};

Line.prototype.constructor = Line;

Line.prototype = {

    setTo: function (x1, y1, x2, y2)
    {
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }

        this.x1 = x1;
        this.y1 = y1;

        this.x2 = x2;
        this.y2 = y2;

        return this;
    }

};

Object.defineProperties(Line.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 <= this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 > this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 <= this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 > this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    }

});

module.exports = Line;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Wrap = __webpack_require__(11);
var Angle = __webpack_require__(6);

var NormalAngle = function (line)
{
    var angle = Angle(line) - MATH_CONST.TAU;

    return Wrap(angle, -Math.PI, Math.PI);
};

module.exports = NormalAngle;


/***/ },
/* 49 */
/***/ function(module, exports) {

var GetMagnitude = function (point)
{
    return Math.sqrt((point.x * point.x) + (point.y * point.y));
};

module.exports = GetMagnitude;


/***/ },
/* 50 */
/***/ function(module, exports) {

var GetMagnitudeSq = function (point)
{
    return (point.x * point.x) + (point.y * point.y);
};

module.exports = GetMagnitudeSq;


/***/ },
/* 51 */
/***/ function(module, exports) {

var Multiply = function (point, x, y)
{
    point.x *= x;
    point.y *= y;

    return point;
};

module.exports = Multiply;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

var GetMagnitude = __webpack_require__(49);

var Normalize = function (point)
{
    if (point.x !== 0 && point.y !== 0)
    {
        var m = GetMagnitude(point);

        point.x /= m;
        point.y /= m;
    }

    return point;
};

module.exports = Normalize;


/***/ },
/* 53 */
/***/ function(module, exports) {

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var Contains = function (polygon, x, y)
{
    //  Adapted from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html by Jonas Raoni Soares Silva

    var inside = false;

    for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i)
    {
        var ix = polygon.points[i].x;
        var iy = polygon.points[i].y;

        var jx = polygon.points[j].x;
        var jy = polygon.points[j].y;

        if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))
        {
            inside = !inside;
        }
    }

    return inside;
};

module.exports = Contains;


/***/ },
/* 54 */
/***/ function(module, exports) {

var Polygon = function (points)
{
    /**
    * @property {number} area - The area of this Polygon.
    */
    this.area = 0;

    /**
    * @property {array} points - An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]
    */
    this.points = [];

    if (points)
    {
        this.setTo(points);
    }
};

Polygon.prototype.constructor = Polygon;

Polygon.prototype = {

    /**
     * Sets this Polygon to the given points.
     *
     * The points can be set from a variety of formats:
     *
     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
     *
     * `setTo` may also be called without any arguments to remove all points.
     *
     * @method Phaser.Polygon#setTo
     * @param {Phaser.Point[]|number[]|...Phaser.Point|...number} points - The points to set.
     * @return {Phaser.Polygon} This Polygon object
     */
    setTo: function (points)
    {
        this.area = 0;
        this.points = [];

        if (!Array.isArray(points))
        {
            return this;
        }

        var entry;
        var y0 = Number.MAX_VALUE;
        var p;

        //  The points argument is an array, so iterate through it
        for (var i = 0; i < points.length; i++)
        {
            p = { x: 0, y: 0 };

            if (typeof points[i] === 'number')
            {
                p.x = points[i];
                p.y = points[i + 1];
                i++;
            }
            else if (Array.isArray(entry))
            {
                //  An array of arrays?
                p.x = points[i][0];
                p.y = points[i][1];
            }
            else
            {
                p.x = points[i].x;
                p.y = points[i].y;
            }

            this.points.push(p);

            //  Lowest boundary
            if (p.y < y0)
            {
                y0 = p.y;
            }
        }

        this.calculateArea(y0);

        return this;
    },

    /**
     * Calculates the area of the Polygon. This is available in the property Polygon.area
     *
     * @method Phaser.Polygon#calculateArea
     * @private
     * @param {number} y0 - The lowest boundary
     * @return {number} The area of the Polygon.
     */
    calculateArea: function (y0)
    {
        if (this.points.length < 3)
        {
            this.area = 0;

            return this.area;
        }

        var sum = 0;
        var p1;
        var p2;

        for (var i = 0; i < this.points.length - 1; i++)
        {
            p1 = this.points[i];
            p2 = this.points[i + 1];

            sum += (p2.x - p1.x) * (p1.y + p2.y);
        }

        p1 = this.points[0];
        p2 = this.points[this.points.length - 1];

        sum += (p1.x - p2.x) * (p2.y + p1.y);

        this.area = -sum * 0.5;

        // var p1;
        // var p2;
        // var avgHeight;
        // var width;

        // for (var i = 0, len = this.points.length; i < len; i++)
        // {
        //     p1 = this.points[i];

        //     if (i === len - 1)
        //     {
        //         p2 = this.points[0];
        //     }
        //     else
        //     {
        //         p2 = this.points[i + 1];
        //     }

        //     avgHeight = ((p1.y - y0) + (p2.y - y0)) / 2;
        //     width = p1.x - p2.x;
        //     this.area += avgHeight * width;
        // }

        return this.area;
    }

};

module.exports = Polygon;


/***/ },
/* 55 */
/***/ function(module, exports) {

var Contains = function (rect, x, y)
{
    if (rect.width <= 0 || rect.height <= 0)
    {
        return false;
    }

    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);
};

module.exports = Contains;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

var XHRSettings = __webpack_require__(29);

//  Takes two XHR Objects and creates a new object

//  The new object is based on global initially, but any setting in
//  local overrides the global value.

var MergeXHRSettings = function (global, local)
{
    var output = (global === undefined) ? XHRSettings() : Object.assign(global);

    if (local)
    {
        for (var setting in local)
        {
            if (local[setting] !== undefined)
            {
                output[setting] = local[setting];
            }
        }
    }

    return output;

};

module.exports = MergeXHRSettings;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var JSONFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.json\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.json';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'json', key, url, 'text', xhrSettings);
};

JSONFile.prototype = Object.create(File.prototype);
JSONFile.prototype.constructor = JSONFile;

JSONFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = JSON.parse(this.xhrLoader.responseText);

    this.onComplete();

    callback(this);
};

module.exports = JSONFile;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

var Factorial = __webpack_require__(61);

var Bernstein = function (n, i)
{
    return Factorial(n) / Factorial(i) / Factorial(n - i);
};

module.exports = Bernstein;


/***/ },
/* 59 */
/***/ function(module, exports) {

var Between = function (min, max)
{
    return Math.floor(Math.random() * (max - min + 1) + min);
};

module.exports = Between;


/***/ },
/* 60 */
/***/ function(module, exports) {

var CatmullRom = function (p0, p1, p2, p3, t)
{
    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;

    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
};

module.exports = CatmullRom;


/***/ },
/* 61 */
/***/ function(module, exports) {

var Factorial = function (value)
{
    if (value === 0)
    {
        return 1;
    }

    var res = value;

    while (--value)
    {
        res *= value;
    }

    return res;
};

module.exports = Factorial;


/***/ },
/* 62 */
/***/ function(module, exports) {

var Linear = function (p0, p1, t)
{
    return (p1 - p0) * t + p0;
};

module.exports = Linear;


/***/ },
/* 63 */
/***/ function(module, exports) {

var RoundAwayFromZero = function (value)
{
    // "Opposite" of truncate.
    return (value > 0) ? Math.ceil(value) : Math.floor(value);
};

module.exports = RoundAwayFromZero;


/***/ },
/* 64 */
/***/ function(module, exports) {

var Normalize = function (angle)
{
    angle = angle % (2 * Math.PI);

    if (angle >= 0)
    {
        return angle;
    }
    else
    {
        return angle + 2 * Math.PI;
    }
};

module.exports = Normalize;


/***/ },
/* 65 */
/***/ function(module, exports) {

var DistanceBetween = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return Math.sqrt(dx * dx + dy * dy);
};

module.exports = DistanceBetween;


/***/ },
/* 66 */
/***/ function(module, exports) {

/**
* Checks if the given dimensions make a power of two texture.
* 
* @method Phaser.Math#isPowerOfTwo
* @param {number} width - The width to check.
* @param {number} height - The height to check.
* @return {boolean} True if the width and height are a power of two.
*/
var IsSizePowerOfTwo = function (width, height)
{
    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
};

module.exports = IsSizePowerOfTwo;


/***/ },
/* 67 */
/***/ function(module, exports) {

module.exports = {

    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16

};


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(314);
var VertexShader = __webpack_require__(317);

var CONST = {

    // VERTEX_SIZE = (sizeof(vec2) * 4) + (sizeof(float) + sizeof(uint32))
    VERTEX_SIZE: 40,
    INDEX_SIZE: 2,
    SPRITE_VERTEX_COUNT: 4,
    SPRITE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    SPRITE_VERTEX_COMPONENT_COUNT: 10,

    // Can't be bigger since index are 16-bit
    MAX_SPRITES: 10000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 69 */
/***/ function(module, exports) {

var CreateTexture2DImage = function (gl, pixels, filter, mipLevels)
{
    var texture = gl.createTexture();
    mipLevels = mipLevels || 0;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texImage2D(
        gl.TEXTURE_2D,
        mipLevels,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        pixels
    );
    return texture;
};

module.exports = CreateTexture2DImage;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(325);
var ScaleModes = __webpack_require__(10);
var GetObjectValue = __webpack_require__(13);

var Settings = function (state, config)
{
    if (typeof config === 'string')
    {
        config = { key: config };
    }
    else if (config === undefined)
    {
        //  Pass the 'hasOwnProperty' checks
        config = {};
    }

    this.state = state; //  Do we actually need this reference? This could just be a property bucket

    this.status = CONST.PENDING;

    //  Which part of this State is currently being processed?
    //  preload, create, update, shutdown, etc
    this.op = CONST.BOOT;

    this.key = GetObjectValue(config, 'key', '');
    this.active = GetObjectValue(config, 'active', false);
    this.visible = GetObjectValue(config, 'visible', true);
    this.scaleMode = GetObjectValue(config, 'scaleMode', ScaleModes.DEFAULT);
    this.fps = GetObjectValue(config, 'fps', 60);
    this.x = GetObjectValue(config, 'x', 0);
    this.y = GetObjectValue(config, 'y', 0);

    //  -1 means the State Manager will set it to be the Game dimensions
    this.width = GetObjectValue(config, 'width', -1);
    this.height = GetObjectValue(config, 'height', -1);

    //  Renderer Settings

    this.clearBeforeRender = GetObjectValue(config, 'clearBeforeRender', true);
    this.transparent = GetObjectValue(config, 'transparent', false);
    this.autoResize = GetObjectValue(config, 'autoResize', false);
    this.roundPixels = GetObjectValue(config, 'roundPixels', false);
    this.drawToPrimaryCanvas = GetObjectValue(config, 'drawToPrimaryCanvas', false);

};

//  Unless we add some actual functions in here, we'll make this just return an Object instead of an instance
Settings.prototype.constructor = Settings;

module.exports = Settings;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var EventDispatcher = __webpack_require__(15);
var GameObjectFactory = __webpack_require__(326);
// var GameObjectCreator = require('./systems/GameObjectCreator');
var Loader = __webpack_require__(327);
var MainLoop = __webpack_require__(328);
var UpdateManager = __webpack_require__(329);
var Component = __webpack_require__(19);
var Camera = __webpack_require__(90);

var Systems = function (state, config)
{
    this.state = state;

    this.config = config;

    this.events;

    //  Reference to the global Game level TextureManager.
    this.textures;

    //  State specific managers (Factory, Tweens, Loader, Physics, etc)
    this.add;
    this.make;
    this.input;
    this.load;
    this.tweens;
    this.mainloop;
    this.updates;

    //  State specific properties (transform, data, children, etc)
    this.camera;
    this.children;
    this.color;
    this.data;
    this.fbo;
    this.time;
    this.transform;
};

Systems.prototype.constructor = Systems;

Systems.prototype = {

    init: function ()
    {
        console.log('State.Systems.init');

        this.textures = this.state.game.textures;

        //  All of the systems can use the State level EventDispatcher, or their own
        this.events = new EventDispatcher();

        //  State specific managers (Factory, Tweens, Loader, Physics, etc)
        //  All these to be set by a State Config package

        this.add = new GameObjectFactory(this.state);
        // this.make = GameObjectCreator(this.state);
        this.mainloop = new MainLoop(this.state, this.state.settings.fps);
        this.updates = new UpdateManager(this.state);
        this.load = new Loader(this.state);

        // this.tweens = new Phaser.TweenManager(this.state);
        // this.input = new Phaser.State.Input(this.state);
        // this.physics = new Phaser.Physics.Arcade(this.state, 800, 600);

        //  State specific properties (transform, data, children, etc)
        this.camera = new Camera(this.state, 0, 0, 800, 600);
        this.children = new Component.Children(this.state);
        this.color = new Component.Color(this.state);
        this.data = new Component.Data(this.state);
        this.transform = this.camera.transform;

        //  Boot

        // this.input.init();

        //  Defaults

        this.state.events = this.events;
        this.state.add = this.add;
        this.state.load = this.load;
        this.state.children = this.children;
        this.state.color = this.color;
        this.state.data = this.data;
        this.state.camera = this.camera;
        this.state.transform = this.camera.transform;
        this.state.textures = this.textures;



        // this.state.input = this.input;
        // this.state.state = this.state.game.state;

        //  Here we can check which Systems to install as properties into the State object
        //  (default systems always exist in here, regardless)
    },

    begin: function (timestamp, frameDelta)
    {
    },

    update: function (timestep, physicsStep)
    {
    },

    preRender: function ()
    {
    },

    end: function (fps, panic)
    {
        if (panic)
        {
            // This pattern introduces non-deterministic behavior, but in this case
            // it's better than the alternative (the application would look like it
            // was running very quickly until the simulation caught up to real
            // time).
            var discardedTime = Math.round(this.mainloop.resetFrameDelta());

            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    }
};

module.exports = Systems;


/***/ },
/* 72 */
/***/ function(module, exports) {


var NOOP = function ()
{
    //  NOOP (No Operation) Callback
};

module.exports = NOOP;


/***/ },
/* 73 */
/***/ function(module, exports) {

/**
* Create an array representing the range of numbers (usually integers), between, and inclusive of,
* the given `start` and `end` arguments. For example:
*
* `var array = numberArray(2, 4); // array = [2, 3, 4]`
* `var array = numberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
* 
* This is equivalent to `numberArrayStep(start, end, 1)`.
* 
* You can optionally provide a prefix and / or suffix string. If given the array will contain
* strings, not integers. For example:
* 
* `var array = numberArray(1, 4, 'Level '); // array = ["Level 1", "Level 2", "Level 3", "Level 4"]`
* `var array = numberArray(5, 7, 'HD-', '.png'); // array = ["HD-5.png", "HD-6.png", "HD-7.png"]`
*
* @method Phaser.ArrayUtils#numberArray
* @param {number} start - The minimum value the array starts with.
* @param {number} end - The maximum value the array contains.
* @param {string} [prefix] - Optional prefix to place before the number. If provided the array will contain strings, not integers.
* @param {string} [suffix] - Optional suffix to place after the number. If provided the array will contain strings, not integers.
* @return {number[]|string[]} The array of number values, or strings if a prefix or suffix was provided.
*/
var NumberArray = function (start, end, prefix, suffix)
{
    var result = [];

    for (var i = start; i <= end; i++)
    {
        if (prefix || suffix)
        {
            var key = (prefix) ? prefix + i.toString() : i.toString();

            if (suffix)
            {
                key = key.concat(suffix);
            }

            result.push(key);
        }
        else
        {
            result.push(i);
        }
    }

    return result;
};

module.exports = NumberArray;


/***/ },
/* 74 */
/***/ function(module, exports) {

//  Removes a single item from an array and returns it
//  without creating gc (like the native splice does)
//  Based on code by Mike Reinstein

var SpliceOne = function (array, index)
{
    if (index >= array.length)
    {
        return;
    }

    var len = array.length - 1;

    var item = array[index];

    for (var i = index; i < len; i++)
    {
        array[i] = array[i + 1];
    }

    array.length = len;

    return item;
};

module.exports = SpliceOne;


/***/ },
/* 75 */
/***/ function(module, exports) {

/**
* This is a slightly modified version of jQuery.isPlainObject.
* A plain object is an object whose internal class property is [object Object].
* @method Phaser.Utils.isPlainObject
* @param {object} obj - The object to inspect.
* @return {boolean} - true if the object is plain, otherwise false.
*/
var IsPlainObject = function (obj)
{
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (typeof(obj) !== "object" || obj.nodeType || obj === obj.window)
    {
        return false;
    }

    // Support: Firefox <20
    // The try/catch suppresses exceptions thrown when attempting to access
    // the "constructor" property of certain host objects, ie. |window.location|
    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
    try {
        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf"))
        {
            return false;
        }
    } catch (e) {
        return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
};

module.exports = IsPlainObject;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Config = __webpack_require__(87);
var DebugHeader = __webpack_require__(89);
var Device = __webpack_require__(99);

var AddToDOM = __webpack_require__(100);
var RequestAnimationFrame = __webpack_require__(103);
var DOMContentLoaded = __webpack_require__(101);

var CreateRenderer = __webpack_require__(88);
var RandomDataGenerator = __webpack_require__(292);
var StateManager = __webpack_require__(324);
var TextureManager = __webpack_require__(333);

var Game = function (config)
{
    this.config = new Config(config);

    this.renderer = null;
    this.canvas = null;
    this.context = null;

    this.isBooted = false;
    this.isRunning = false;

    /**
    * @property {Phaser.RequestAnimationFrame} raf - Automatically handles the core game loop via requestAnimationFrame or setTimeout
    * @protected
    */
    this.raf = new RequestAnimationFrame(this);

    /**
    * @property {Phaser.TextureManager} textures - Reference to the Phaser Texture Manager.
    */
    this.textures = new TextureManager(this);

    /**
    * @property {Phaser.Cache} cache - Reference to the assets cache.
    */
    // this.cache = new Cache();

    /**
    * @property {Phaser.Input} input - Reference to the input manager
    */
    this.input = null;

    /**
    * @property {Phaser.StateManager} state - The StateManager. Phaser instance specific.
    */
    this.state = new StateManager(this, this.config.stateConfig);

    /**
    * @property {Phaser.Device} device - Contains device information and capabilities (singleton)
    */
    this.device = Device;

    //  Move this somewhere else? Math perhaps? Doesn't need to be a Game level system.
    this.rnd;

    //  Wait for the DOM Ready event, then call boot.
    DOMContentLoaded(this.boot.bind(this));

    //  For debugging only
    window.game = this;
};

Game.prototype.constructor = Game;

Game.prototype = {

    boot: function ()
    {
        this.isBooted = true;

        this.config.preBoot();

        //  Probably move within Math
        this.rnd = new RandomDataGenerator(this.config.seed);

        DebugHeader(this);

        CreateRenderer(this);

        AddToDOM(this.canvas, this.config.parent);

        this.state.boot();

        this.isRunning = true;

        this.config.postBoot();

        this.raf.start();
    },

    //  timestamp = DOMHighResTimeStamp
    update: function (timestamp)
    {
        this.state.step(timestamp);
    }

};

module.exports = Game;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Blitter = __webpack_require__(106);
var FactoryContainer = __webpack_require__(9);

var BlitterFactory = {

    KEY: 'blitter',

    /**
    * Create a new `Blitter` object.
    *
    * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
    *
    * It can still rotate, scale, crop and receive input events.
    * This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
    *
    * @method Phaser.GameObject.Factory#image
    * @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.
    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
    * @return {Phaser.Image} The newly created Image object.
    */
    add: function (x, y, key, frame, group)
    {
        if (group === undefined) { group = this.state; }

        // console.log('ImageFactory.add', key, x, y, frame, group);
        // console.log('into State', this.state);

        return group.children.add(new Blitter(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        // console.log('ImageFactory.make', key, x, y, frame);

        return new Blitter(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(BlitterFactory);


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Container = __webpack_require__(109);
var FactoryContainer = __webpack_require__(9);

var ContainerFactory = {

    KEY: 'container',

    add: function (parent, x, y)
    {
        if (parent === undefined) { parent = this.state; }

        return parent.children.add(new Container(this.state, parent, x, y));
    },

    make: function (parent, x, y)
    {
        return new Container(this.state, parent, x, y);
    }

};

module.exports = FactoryContainer.register(ContainerFactory);


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Image = __webpack_require__(111);
var FactoryContainer = __webpack_require__(9);

var ImageFactory = {

    KEY: 'image',

    /**
    * Create a new `Image` object.
    *
    * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
    *
    * It can still rotate, scale, crop and receive input events.
    * This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
    *
    * @method Phaser.GameObject.Factory#image
    * @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.
    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
    * @return {Phaser.Image} The newly created Image object.
    */
    add: function (x, y, key, frame, group)
    {
        if (group === undefined) { group = this.state; }

        // console.log('ImageFactory.add', key, x, y, frame, group);
        // console.log('into State', this.state);

        return group.children.add(new Image(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        // console.log('ImageFactory.make', key, x, y, frame);

        return new Image(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(ImageFactory);


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom

module.exports = {
    
    Circle: __webpack_require__(126),
    Ellipse: __webpack_require__(137),
    Hermite: __webpack_require__(144),
    Intersects: __webpack_require__(152),
    Line: __webpack_require__(172),
    Point: __webpack_require__(192),
    Polygon: __webpack_require__(197),
    Rectangle: __webpack_require__(224)

};


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    //  CONSTs (makes them visible under Phaser.Math)
    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,

    //  Collections of functions
    Angle: __webpack_require__(263),
    Distance: __webpack_require__(266),
    Easing: __webpack_require__(278),
    Fuzzy: __webpack_require__(284),
    Interpolation: __webpack_require__(288),
    Pow2: __webpack_require__(291),
    Snap: __webpack_require__(296),

    //  Single functions
    Average: __webpack_require__(236),
    Bernstein: __webpack_require__(58),
    Between: __webpack_require__(59),
    CatmullRom: __webpack_require__(60),
    CeilTo: __webpack_require__(237),
    Clamp: __webpack_require__(238),
    DegToRad: __webpack_require__(239),
    Difference: __webpack_require__(240),
    Factorial: __webpack_require__(61),
    FloatBetween: __webpack_require__(241),
    FloorTo: __webpack_require__(242),
    Linear: __webpack_require__(62),
    MaxAdd: __webpack_require__(243),
    MinSub: __webpack_require__(244),
    Percent: __webpack_require__(245),
    RadToDeg: __webpack_require__(246),
    Rotate: __webpack_require__(247),
    RotateAround: __webpack_require__(248),
    RotateAroundDistance: __webpack_require__(249),
    RoundAwayFromZero: __webpack_require__(63),
    RoundTo: __webpack_require__(250),
    SinCosTableGenerator: __webpack_require__(251),
    SmootherStep: __webpack_require__(253),
    SmoothStep: __webpack_require__(252),
    Within: __webpack_require__(254),
    Wrap: __webpack_require__(11)

};


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(303);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(304);
__webpack_require__(305);
__webpack_require__(302);


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Sound

module.exports = {

    Dynamic: __webpack_require__(322)

};


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    FindClosestInSorted: __webpack_require__(343),
    GetRandomElement: __webpack_require__(344),
    NumberArray: __webpack_require__(73),
    NumberArrayStep: __webpack_require__(345),
    RemoveRandomElement: __webpack_require__(346),
    RotateLeft: __webpack_require__(347),
    RotateRight: __webpack_require__(348),
    Shuffle: __webpack_require__(349),
    SpliceOne: __webpack_require__(74)

};


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Extend: __webpack_require__(17),
    IsPlainObject: __webpack_require__(75)

};


/***/ },
/* 86 */
/***/ function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			configurable: false,
			get: function() { return module.l; }
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			configurable: false,
			get: function() { return module.i; }
		});
		module.webpackPolyfill = 1;
	}
	return module;
}


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var NOOP = __webpack_require__(72);
var GetObjectValue = __webpack_require__(13);

var defaultBannerColor = [
    '#ff0000',
    '#ffff00',
    '#00ff00',
    '#00ffff',
    '#000000'
];

var defaultBannerTextColor = '#ffffff';

var Config = function (config)
{
    if (config === undefined) { config = {}; }

    this.width = GetObjectValue(config, 'width', 1024);
    this.height = GetObjectValue(config, 'height', 768);

    this.resolution = GetObjectValue(config, 'resolution', 1);

    this.renderType = GetObjectValue(config, 'type', CONST.AUTO);

    this.parent = GetObjectValue(config, 'parent', null);
    this.canvas = GetObjectValue(config, 'canvas', null);
    this.canvasStyle = GetObjectValue(config, 'canvasStyle', null);

    this.stateConfig = GetObjectValue(config, 'state', null);

    this.seed = GetObjectValue(config, 'seed', [ (Date.now() * Math.random()).toString() ]);

    this.gameTitle = GetObjectValue(config, 'title', '');
    this.gameURL = GetObjectValue(config, 'url', 'http://phaser.io');
    this.gameVersion = GetObjectValue(config, 'version', '');

    //  If you do: { banner: false } it won't display any banner at all
    this.hideBanner = (GetObjectValue(config, 'banner', null) === false);

    this.hidePhaser = GetObjectValue(config, 'banner.hidePhaser', false);
    this.bannerTextColor = GetObjectValue(config, 'banner.text', defaultBannerTextColor);
    this.bannerBackgroundColor = GetObjectValue(config, 'banner.background', defaultBannerColor);
   
    this.forceSetTimeOut = GetObjectValue(config, 'forceSetTimeOut', false);
    this.transparent = GetObjectValue(config, 'transparent', false);
    this.pixelArt = GetObjectValue(config, 'pixelArt', false);

    //  Callbacks
    this.preBoot = GetObjectValue(config, 'callbacks.preBoot', NOOP);
    this.postBoot = GetObjectValue(config, 'callbacks.postBoot', NOOP);
};

Config.prototype.constructor = Config;

module.exports = Config;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var CanvasPool = __webpack_require__(20);
var Features = __webpack_require__(40);
var CanvasRenderer = __webpack_require__(306);
var WebGLRenderer = __webpack_require__(309);

/**
* Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.
*
* @method Phaser.Game#setUpRenderer
* @protected
*/
var CreateRenderer = function (game)
{
    var config = game.config;

    //  Game either requested Canvas,
    //  or requested AUTO or WEBGL but the browser doesn't support it, so fall back to Canvas
    if (config.renderType === CONST.CANVAS || (config.renderType !== CONST.CANVAS && !Features.webGL))
    {
        if (Features.canvas)
        {
            //  They requested Canvas and their browser supports it
            config.renderType = CONST.CANVAS;
        }
        else
        {
            throw new Error('Cannot create Canvas or WebGL context, aborting.');
        }
    }
    else
    {
        //  Game requested WebGL and browser says it supports it
        config.renderType = CONST.WEBGL;
    }

    //  Does the game config provide its own canvas element to use?
    if (config.canvas)
    {
        game.canvas = config.canvas;
    }
    else
    {
        game.canvas = CanvasPool.create(game, config.width, config.height, config.renderType);
    }

    //  Does the game config provide some canvas css styles to use?
    if (config.canvasStyle)
    {
        game.canvas.style = config.canvasStyle;
    }

    //  Create the renderer
    if (config.renderType === CONST.WEBGL)
    {
        console.log('Creating WEBGL Renderer');
        game.renderer = new WebGLRenderer(game);
        game.context = null;
    }
    else
    {
        console.log('Creating Canvas Renderer');
        game.renderer = new CanvasRenderer(game);
        game.context = game.renderer.context;
    }
};

module.exports = CreateRenderer;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var CHECKSUM = __webpack_require__(91);

var DebugHeader = function (game)
{
    var config = game.config;

    if (config.hideBanner)
    {
        return;
    }

    var renderType = (config.renderType === CONST.CANVAS) ? 'Canvas' : 'WebGL';

    var ie = false;

    if (!ie)
    {
        var c = '';
        var args = [c];

        if (Array.isArray(config.bannerBackgroundColor))
        {
            var lastColor;

            config.bannerBackgroundColor.forEach(function(color) {

                c = c.concat('%c ');

                args.push('background: ' + color);

                lastColor = color;

            });

            //  inject the text color
            args[args.length - 1] = 'color: ' + config.bannerTextColor + '; background: ' + lastColor;
        }
        else
        {
            c = c.concat('%c ');

            args.push('color: ' + config.bannerTextColor + '; background: ' + config.bannerBackgroundColor);
        }

        //  URL link background color (always white)
        args.push('background: #fff');

        if (config.gameTitle)
        {
            c = c.concat(config.gameTitle);

            if (config.gameVersion)
            {
                c = c.concat(' v' + config.gameVersion);
            }

            if (!config.hidePhaser)
            {
                c = c.concat(' / ');
            }
        }

        if (!config.hidePhaser)
        {
            c = c.concat('Phaser v' + CONST.VERSION + ' (' + renderType + ')');
        }

        c = c.concat(' %c ' + config.gameURL);

        //  Inject the new string back into the args array
        args[0] = c;

        console.log.apply(console, args);
    }
    else if (window['console'])
    {
        console.log('Phaser v' + CONST.VERSION + ' / http://phaser.io');
    }

    // Keep this during dev build only
    console.log(CHECKSUM.build);

};

module.exports = DebugHeader;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Component = __webpack_require__(19);
var MATH_CONST = __webpack_require__(2);
var WrapAngle = __webpack_require__(12);

/**
* A Camera is your view into the game world. It has a position and size and renders only those objects within its field of view.
* The game automatically creates a single Stage sized camera on boot. Move the camera around the world with Phaser.Camera.x/y
*
* @class Phaser.Camera
* @constructor
* @param {Phaser.Game} game - Game reference to the currently running game.
* @param {number} id - Not being used at the moment, will be when Phaser supports multiple camera
* @param {number} x - Position of the camera on the X axis
* @param {number} y - Position of the camera on the Y axis
* @param {number} width - The width of the view rectangle
* @param {number} height - The height of the view rectangle
*/
var Camera = function (state, x, y, viewportWidth, viewportHeight)
{
    /**
     * The State that this Camera belongs to. A Camera can only belong to one State, and a State only
     * has one Camera.
    * @property {Phaser.State} state
    */
    this.state = state;

    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    this.game = state.game;

    this.viewportWidth = viewportWidth;

    this.viewportHeight = viewportHeight;

    this.transform = new Component.Transform(this, x, y);

    /**
    * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
    * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
    * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.
    *
    * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
    */
    // this.bounds = new Phaser.Rectangle(x, y, width, height);

    // this.bounds = new Phaser.Circle(x, y)

    /**
    * @property {boolean} atLimit - Whether this camera is flush with the World Bounds or not.
    */
    this.atLimit = { x: false, y: false };
};

Camera.prototype.constructor = Camera;

Camera.prototype = {

    /**
    * Method called to ensure the camera doesn't venture outside of the game world.
    * Called automatically by Camera.update.
    *
    * @method Phaser.Camera#checkBounds
    * @protected
    */
    checkBounds: function ()
    {
        this.atLimit.x = false;
        this.atLimit.y = false;

        // var vx = this.view.x + this._shake.x;
        // var vw = this.view.right + this._shake.x;
        // var vy = this.view.y + this._shake.y;
        // var vh = this.view.bottom + this._shake.y;

        var vx = this.x;
        var vw = this.x + this.viewportWidth;
        var vy = this.y;
        var vh = this.y + this.viewportHeight;

        //  Make sure we didn't go outside the cameras bounds
        if (vx <= this.bounds.x * this.scale.x)
        {
            this.atLimit.x = true;
            this.view.x = this.bounds.x * this.scale.x;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.x = 0;
            }
        }

        if (vw >= this.bounds.right * this.scale.x)
        {
            this.atLimit.x = true;
            this.view.x = (this.bounds.right * this.scale.x) - this.width;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.x = 0;
            }
        }

        if (vy <= this.bounds.top * this.scale.y)
        {
            this.atLimit.y = true;
            this.view.y = this.bounds.top * this.scale.y;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.y = 0;
            }
        }

        if (vh >= this.bounds.bottom * this.scale.y)
        {
            this.atLimit.y = true;
            this.view.y = (this.bounds.bottom * this.scale.y) - this.height;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.y = 0;
            }
        }

    }

};

Object.defineProperties(Camera.prototype, {

    //  Transform getters / setters

    x: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posX;
        },

        set: function (value)
        {
            this.transform._posX = value;
            this.transform.dirty = true;
        }

    },

    y: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posY;
        },

        set: function (value)
        {
            this.transform._posY = value;
            this.transform.dirty = true;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posX + (this.viewportWidth * this.transform._scaleX);
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posY + (this.viewportHeight * this.transform._scaleY);
        }

    },

    scale: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleY;
        },

        set: function (value)
        {
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    pivotX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotX;
        },

        set: function (value)
        {
            this.transform._pivotX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    pivotY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotY;
        },

        set: function (value)
        {
            this.transform._pivotY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    angle: {

        enumerable: true,

        get: function ()
        {
            return WrapAngle(this.rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            this.rotation = WrapAngle(value) * MATH_CONST.DEG_TO_RAD;
        }

    },

    rotation: {

        enumerable: true,

        get: function ()
        {
            return this.transform._rotation;
        },

        set: function (value)
        {
            if (this.transform._rotation === value)
            {
                return;
            }

            this.transform._rotation = value;
            this.transform.dirty = true;

            if (this.transform._rotation % MATH_CONST.PI2)
            {
                this.transform.cache.sr = Math.sin(this.transform._rotation);
                this.transform.cache.cr = Math.cos(this.transform._rotation);
                this.transform.updateCache();
                this.transform.hasLocalRotation = true;
            }
            else
            {
                this.transform.hasLocalRotation = false;
            }
        }

    },

});

module.exports = Camera;


/***/ },
/* 91 */
/***/ function(module, exports) {

var CHECKSUM = {
build: 'd280f080-e252-11e6-bada-f9ef445cacef'
};
module.exports = CHECKSUM;

/***/ },
/* 92 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Color Component allows you to control the alpha, blend mode, tint and background color
* of a Game Object.
*
* @class
*/
var Color = function (gameObject)
{
    this.gameObject = gameObject;

    this.state = gameObject.state;

    this._dirty = false;

    this._alpha = 1;
    this._worldAlpha = 1;

    this._blendMode = 0;

    this._tint = { topLeft: 0xffffff, topRight: 0xffffff, bottomLeft: 0xffffff, bottomRight: 0xffffff };
    this._glTint = { topLeft: 16777215, topRight: 16777215, bottomLeft: 16777215, bottomRight: 16777215 };
    this._hasTint = false;

    //  Between 0 and 255
    this._r = 0;
    this._g = 0;
    this._b = 0;

    //  Between 0 and 1
    this._a = 1;

    //  String version of RGBA
    this._rgba = '';

    //  32-bit version of ARGB
    this._glBg = 0;

    this._hasBackground = false;
};

Color.prototype.constructor = Color;

Color.prototype = {

    setBackground: function (red, green, blue, alpha)
    {
        if (red === undefined)
        {
            this._hasBackground = false;
            this._glBg = 0;
        }
        else
        {
            this._hasBackground = true;
            this._r = red;
            this._g = (green) ? green : 0;
            this._b = (blue) ? blue : 0;
            this._a = (alpha) ? alpha : 1;
        }

        this.dirty = true;
    },

    clearTint: function ()
    {
        this.setTint(0xffffff);

        this._hasTint = false;
    },

    setTint: function (topLeft, topRight, bottomLeft, bottomRight)
    {
        if (topRight === undefined)
        {
            topRight = topLeft;
            bottomLeft = topLeft;
            bottomRight = topLeft;
        }

        this.tintTopLeft = topLeft;
        this.tintTopRight = topRight;
        this.tintBottomLeft = bottomLeft;
        this.tintBottomRight = bottomRight;

        this._hasTint = true;

        this.dirty = true;
    },

    //  Called by the Dirty Manager
    update: function ()
    {
        this._dirty = false;

        if (this._hasBackground)
        {
            this._rgba = 'rgba(' + this._r + ',' + this._g + ',' + this._b + ',' + this._a + ')';
            this._glBg = this.getColor32(this._r, this._g, this._b, this._a);
        }

        //  Tint mults?

    },

    getColor: function (value)
    {
        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
    },

    getColor32: function (r, g, b, a)
    {
        a *= 255;

        return ((a << 24) | (b << 16) | (g << 8) | r) >>> 0;
    },

    destroy: function ()
    {
        this.gameObject = null;
        this.state = null;
        this._tint = [];
    }

};

Object.defineProperties(Color.prototype, {

    dirty: {

        enumerable: true,

        get: function ()
        {
            return this._dirty;
        },

        set: function (value)
        {
            if (value)
            {
                if (!this._dirty)
                {
                    this._dirty = true;

                    this.state.sys.updates.add(this);
                }
            }
            else
            {
                this._dirty = false;
            }
        }

    },

    tintTopLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topLeft;
        },

        set: function (value)
        {
            this._tint.topLeft = value;
            this._glTint.topLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintTopRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topRight;
        },

        set: function (value)
        {
            this._tint.topRight = value;
            this._glTint.topRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomLeft;
        },

        set: function (value)
        {
            this._tint.bottomLeft = value;
            this._glTint.bottomLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomRight;
        },

        set: function (value)
        {
            this._tint.bottomRight = value;
            this._glTint.bottomRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tint: {

        enumerable: true,

        get: function ()
        {
            return this._tint;
        },

        set: function (value)
        {
            this.setTint(value, value, value, value);
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            if (value !== this._alpha)
            {
                this._alpha = value;
                this.dirty = true;
            }
        }

    },

    blendMode: {

        enumerable: true,

        get: function ()
        {
            return this._blendMode;
        },

        set: function (value)
        {
            if (value !== this._blendMode && value >= 0 && value <= 16)
            {
                this._blendMode = value;
                this.dirty = true;
            }
        }

    },

    worldAlpha: {

        enumerable: true,

        get: function ()
        {
            if (this.gameObject.parent)
            {
                this._worldAlpha = this._alpha * this.gameObject.parent.color.worldAlpha;
            }

            return this._worldAlpha;
        },

        set: function (value)
        {
            this._worldAlpha = this._alpha * value;
        }

    },

    backgroundAlpha: {

        enumerable: true,

        get: function ()
        {
            return this._a;
        },

        set: function (value)
        {
            if (value !== this._a)
            {
                this._a = value;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    red: {

        enumerable: true,

        get: function ()
        {
            return this._r;
        },

        set: function (value)
        {
            if (value !== this._r)
            {
                this._r = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    green: {

        enumerable: true,

        get: function ()
        {
            return this._g;
        },

        set: function (value)
        {
            if (value !== this._g)
            {
                this._g = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    blue: {

        enumerable: true,

        get: function ()
        {
            return this._b;
        },

        set: function (value)
        {
            if (value !== this._b)
            {
                this._b = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    }

});

module.exports = Color;


/***/ },
/* 93 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Data Component features a means to store pieces of data specific to a Game Object,
* search it, query it, and retrieve it.
*
* @class
*/
var Data = function (parent)
{
    this.parent = parent;

    this.list = {};

    this._beforeCallbacks = {};
    this._afterCallbacks = {};

    this._frozen = false;
};

Data.prototype.constructor = Data;

Data.prototype = {

    //  Retrieves the value for the given key, or undefined if it doesn't exist.
    get: function (key)
    {
        return this.list[key];
    },

    getAll: function ()
    {
        var results = {};

        for (var key in this.list)
        {
            results[key] = this.list[key];
        }

        return results;
    },

    query: function (search)
    {
        var results = {};

        for (var key in this.list)
        {
            if (key.match(search))
            {
                results[key] = this.list[key];
            }
        }

        return results;
    },

    set: function (key, data)
    {
        if (this._frozen)
        {
            return this;
        }

        var listener;
        var result;

        //  If there is a 'before' callback, then check it for a result
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            listener = this._beforeCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                data = result;
            }
        }

        this.list[key] = data;

        //  If there is a 'after' callback, then check it for a result
        if (this._afterCallbacks.hasOwnProperty(key))
        {
            listener = this._afterCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                this.list[key] = result;
            }
        }

        return this;
    },

    before: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._beforeCallbacks[key];
        }
        else
        {
            this._beforeCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    after: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._afterCallbacks[key];
        }
        else
        {
            this._afterCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    /**
    * Passes all data entries to the given callback. Stores the result of the callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [scope] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the game object, key, and data.
    */
    each: function (callback, scope)
    {
        var args = [ this.parent, null, undefined ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var key in this.list)
        {
            args[1] = key;
            args[2] = this.list[key];

            callback.apply(scope, args);
        }
    },

    merge: function (data, overwrite)
    {
        if (overwrite === undefined) { overwrite = true; }

        //  Merge data from another component into this one
        for (var key in data)
        {
            if (overwrite || (!overwrite && !this.has(key)))
            {
                this.list[key] = data;
            }
        }
    },

    remove: function (key)
    {
        if (!this._frozen && this.has(key))
        {
            delete this.list[key];

            this.removeListeners(key);
        }
    },

    removeListeners: function (key)
    {
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            delete this._beforeCallbacks[key];
        }

        if (this._afterCallbacks.hasOwnProperty(key))
        {
            delete this._afterCallbacks[key];
        }
    },

    //  Gets the data associated with the given 'key', deletes it from this Data store, then returns it.
    pop: function (key)
    {
        var data = undefined;

        if (!this._frozen && this.has(key))
        {
            data = this.list[key];

            delete this.list[key];

            this.removeListeners(key);
        }

        return data;
    },

    has: function (key)
    {
        return this.list.hasOwnProperty(key);
    },

    reset: function ()
    {
        for (var key in this.list)
        {
            delete this.list[key];
        }

        for (key in this._beforeCallbacks)
        {
            delete this._beforeCallbacks[key];
        }

        for (key in this._afterCallbacks)
        {
            delete this._afterCallbacks[key];
        }

        this._frozen = false;
    }

};

Object.defineProperties(Data.prototype, {

    /**
    * Freeze this Data component, so no changes can be written to it.
    *
    * @name freeze
    * @property {boolean} freeze
    */
    freeze: {

        enumerable: true,

        get: function ()
        {
            return this._frozen;
        },

        set: function (value)
        {
            this._frozen = (value) ? true : false;
        }

    },

    count: {

        enumerable: true,

        get: function ()
        {
            var i = 0;

            for (var key in this.list)
            {
                if (this.list[key] !== undefined)
                {
                    i++;
                }
            }

            return i;
        }

    }

});

module.exports = Data;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var MATH_CONST = __webpack_require__(2);
var WrapAngle = __webpack_require__(12);

/**
* 2D Transformation Component.
*
* @class
*/
var Transform = function (gameObject, x, y, scaleX, scaleY)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (scaleX === undefined) { scaleX = 1; }
    if (scaleY === undefined) { scaleY = 1; }

    this.gameObject = gameObject;

    this.state = (gameObject.state) ? gameObject.state : gameObject.parent.state;

    this.game = this.state.game;

    //  a = scale X
    //  b = shear Y
    //  c = shear X
    //  d = scale Y
    //  tx / ty = translation

    //  World Transform
    this.world = { a: scaleX, b: 0, c: 0, d: scaleY, tx: x, ty: y };

    //  Previous Transform (used for interpolation)
    this.old = { a: scaleX, b: 0, c: 0, d: scaleY, tx: x, ty: y };

    //  Cached Transform Calculations
    this.cache = { a: 1, b: 0, c: 0, d: 1, sr: 0, cr: 0 };

    //  GL Vertex Data
    this.glVertextData = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };

    //  Canvas SetTransform data
    this.canvasData = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0, dx: 0, dy: 0 };

    this.immediate = false;

    this.interpolate = false;

    this.hasLocalRotation = false;

    //  Private value holders, accessed via the getters and setters
    this._posX = x;
    this._posY = y;
    this._scaleX = scaleX;
    this._scaleY = scaleY;
    this._rotation = 0;
    this._pivotX = 0;
    this._pivotY = 0;
    this._anchorX = 0;
    this._anchorY = 0;

    this._worldRotation = 0;
    this._worldScaleX = scaleX;
    this._worldScaleY = scaleY;

    this._dirty = true;
    this._dirtyVertex = true;

    this.state.sys.updates.add(this);

    //  The parent Transform (NOT the parent GameObject, although very often they are related)
    this.parent = null;

    //  Any child Transforms of this one - note that they don't have to belong to Game Objects
    //  that are children of the owner of this Transform
    this.children = [];
};

Transform.prototype.constructor = Transform;

Transform.prototype = {

    add: function (child)
    {
        return this.addAt(child, this.children.length);
    },

    addAt: function (child, index)
    {
        //  Invalid child?
        if (child === this || child.parent === this || index < 0 || index > this.children.length)
        {
            console.log('Invalid child');
            return child;
        }

        //  Child already parented? Remove it
        if (child.parent)
        {
            child.parent.remove(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        this.dirty = true;

        this.updateAncestors();

        return child;
    },

    remove: function (child)
    {
        //  Invalid child?
        if (child === this || child.parent !== this)
        {
            return child;
        }

        var index = this.children.indexOf(child);

        if (index !== -1)
        {
            return this.removeAt(index);
        }
    },

    removeAt: function (index)
    {
        //  Valid index?
        if (index >= 0 && index < this.children.length)
        {
            var child = this.children.splice(index, 1);

            if (child[0])
            {
                child[0].parent = null;

                return child[0];
            }
        }
    },

    enableInterpolation: function ()
    {
        this.interpolate = true;

        this.syncInterpolation();
    },

    syncInterpolation: function ()
    {
        this._dirty = true;

        this.update();

        var old = this.old;
        var world = this.world;

        old.a = world.a;
        old.b = world.b;
        old.c = world.c;
        old.d = world.d;
        old.tx = world.tx;
        old.ty = world.ty;
    },

    disableInterpolation: function ()
    {
        this.interpolate = false;
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._posX = x;
        this._posY = y;

        return this.update();
    },

    setScale: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._scaleX = x;
        this._scaleY = y;
        this.updateCache();

        return this.update();
    },

    setPivot: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._pivotX = x;
        this._pivotY = y;

        return this.update();
    },

    setAnchor: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._anchorX = x;
        this._anchorY = y;

        this.dirty = true;
    },

    setRotation: function (rotation)
    {
        this.rotation = rotation;

        return this.update();
    },

    //  Updates the Transform.world object, ready for rendering
    //  Assuming this Transform is a root node (i.e. no transform parent)
    updateFromRoot: function ()
    {
        var old = this.old;
        var world = this.world;

        old.a = world.a;
        old.b = world.b;
        old.c = world.c;
        old.d = world.d;
        old.tx = world.tx;
        old.ty = world.ty;

        if (this.hasLocalRotation)
        {
            // console.log(this.name, 'Transform.updateFromRoot');

            world.a = this.cache.a;
            world.b = this.cache.b;
            world.c = this.cache.c;
            world.d = this.cache.d;
            world.tx = this._posX - ((this._pivotX * this.cache.a) + (this._pivotY * this.cache.c));
            world.ty = this._posY - ((this._pivotX * this.cache.b) + (this._pivotY * this.cache.d));

            this._worldRotation = Math.atan2(-this.cache.c, this.cache.d);
        }
        else
        {
            // console.log(this.name, 'Transform.updateFromRoot FAST');

            world.a = this._scaleX;
            world.b = 0;
            world.c = 0;
            world.d = this._scaleY;
            world.tx = this._posX - (this._pivotX * this._scaleX);
            world.ty = this._posY - (this._pivotY * this._scaleY);

            this._worldRotation = 0;
        }

        this._worldScaleX = this._scaleX;
        this._worldScaleY = this._scaleY;

        return this;
    },

    updateFromParent: function ()
    {
        var old = this.old;
        var world = this.world;

        old.a = world.a;
        old.b = world.b;
        old.c = world.c;
        old.d = world.d;
        old.tx = world.tx;
        old.ty = world.ty;

        var parent = this.parent.world;
        var tx = 0;
        var ty = 0;
        var a;
        var b;
        var c;
        var d;

        if (this.hasLocalRotation)
        {
            // console.log(this.name, 'Transform.updateFromParent', this.parent.name);

            a = this.cache.a;
            b = this.cache.b;
            c = this.cache.c;
            d = this.cache.d;

            tx = this._posX - ((this._pivotX * a) + (this._pivotY * c));
            ty = this._posY - ((this._pivotX * b) + (this._pivotY * d));

            world.a = (a * parent.a) + (b * parent.c);
            world.b = (a * parent.b) + (b * parent.d);
            world.c = (c * parent.a) + (d * parent.c);
            world.d = (c * parent.b) + (d * parent.d);
        }
        else
        {
            // console.log(this.name, 'Transform.updateFromParent FAST', this.parent.name);

            tx = this._posX - (this._pivotX * this._scaleX);
            ty = this._posY - (this._pivotY * this._scaleY);

            world.a = this._scaleX * parent.a;
            world.b = this._scaleX * parent.b;
            world.c = this._scaleY * parent.c;
            world.d = this._scaleY * parent.d;
        }

        // this._worldRotation = Math.atan2(-this.world.c, this.world.d);

        world.tx = (tx * parent.a) + (ty * parent.c) + parent.tx;
        world.ty = (tx * parent.b) + (ty * parent.d) + parent.ty;

        a = world.a;
        b = world.b;
        c = world.c;
        d = world.d;

        var determ = (a * d) - (b * c);

        if (a || b)
        {
            var r = Math.sqrt((a * a) + (b * b));

            this._worldRotation = (b > 0) ? Math.acos(a / r) : -Math.acos(a / r);
            this._worldScaleX = r;
            this._worldScaleY = determ / r;
        }
        else if (c || d)
        {
            var s = Math.sqrt((c * c) + (d * d));

            this._worldRotation = MATH_CONST.TAU - ((d > 0) ? Math.acos(-c / s) : -Math.acos(c / s));
            this._worldScaleX = determ / s;
            this._worldScaleY = s;
        }
        else
        {
            this._worldScaleX = 0;
            this._worldScaleY = 0;
        }

        return this;
    },

    updateAncestors: function ()
    {
        // console.log(this.name, 'Transform.updateAncestors');

        //  No parent? Then just update the children and leave, our job is done
        if (!this.parent)
        {
            // console.log(this.name, 'updateAncestors has no parent Transform');

            this.updateFromRoot();

            this.updateChildren();

            this.dirty = false;

            return this;
        }

        // console.log(this.name, 'start updateAncestors while');

        //  Gets all parent nodes, starting from this Transform.
        //  Then updates from the top, down, but only on the ancestors,
        //  not any other children - will give us accurate worldX etc properties

        var node = this.parent;
        var nodes = [];

        do
        {
            nodes.push(node);
            node = node.parent;
        }
        while (node);

        //  We've got all the ancestors in the 'nodes' array, let's loop it

        while (nodes.length)
        {
            node = nodes.pop();

            if (node.parent)
            {
                node.updateFromParent();
            }
            else
            {
                node.updateFromRoot();
            }
        }

        //  By this point all of this Transforms ancestors have been
        //  updated, in the correct order, so we can now do this one
        //  and any of its children too

        this.update();
    },

    updateChildren: function ()
    {
        // console.log(this.name, 'Transform.updateChildren');

        for (var i = 0; i < this.children.length; i++)
        {
            this.children[i].update();
        }
    },

    updateFromDirtyParent: function ()
    {
        // console.log(this.name, 'is updateFromDirtyParent', this.parent.name);

        this.updateFromParent();

        if (this.children.length)
        {
            for (var i = 0; i < this.children.length; i++)
            {
                this.children[i].updateFromDirtyParent();
            }
        }

        this._dirty = false;
        this._dirtyVertex = true;
    },

    update: function ()
    {
        if (!this._dirty)
        {
            return;
        }

        //  If we got this far then this Transform is dirty
        //  so we need to update it from its parent
        //  and then force the update to all children

        if (this.parent)
        {
            this.updateFromParent();
        }
        else
        {
            this.updateFromRoot();
        }

        var len = this.children.length;

        if (len)
        {
            for (var i = 0; i < len; i++)
            {
                this.children[i].updateFromDirtyParent();
            }
        }

        this._dirty = false;
        this._dirtyVertex = true;
    },

    updateCache: function ()
    {
        this.cache.a = this.cache.cr * this._scaleX;
        this.cache.b = this.cache.sr * this._scaleX;
        this.cache.c = -this.cache.sr * this._scaleY;
        this.cache.d = this.cache.cr * this._scaleY;
    },

    updateVertexData: function (interpolationPercentage, renderer)
    {
        if (!this.gameObject.frame || (!this._dirtyVertex && !this.interpolate))
        {
            return;
        }

        var frame = this.gameObject.frame;

        var w0;
        var h0;
        var w1;
        var h1;

        if (frame.data.trim)
        {
            //  If the sprite is trimmed, add the extra space before transforming
            w1 = frame.x - (this._anchorX * frame.width);
            w0 = w1 + frame.cutWidth;

            h1 = frame.y - (this._anchorY * frame.height);
            h0 = h1 + frame.cutHeight;
        }
        else
        {
            w0 = frame.cutWidth * (1 - this._anchorX);
            w1 = frame.cutWidth * -this._anchorX;

            h0 = frame.cutHeight * (1 - this._anchorY);
            h1 = frame.cutHeight * -this._anchorY;
        }

        var resolution = frame.source.resolution;

        var wt = this.world;

        var a = wt.a / resolution;
        var b = wt.b / resolution;
        var c = wt.c / resolution;
        var d = wt.d / resolution;
        var tx = wt.tx;
        var ty = wt.ty;

        if (this.interpolate)
        {
            var old = this.old;

            // Interpolate with the last position to reduce stuttering.
            a = old.a + ((a - old.a) * interpolationPercentage);
            b = old.b + ((b - old.b) * interpolationPercentage);
            c = old.c + ((c - old.c) * interpolationPercentage);
            d = old.d + ((d - old.d) * interpolationPercentage);
            tx = old.tx + ((tx - old.tx) * interpolationPercentage);
            ty = old.ty + ((ty - old.ty) * interpolationPercentage);
        }

        if (frame.rotated)
        {
            // var cw = frame.cutWidth;
            var ch = frame.height;
            var a0 = a;
            var b0 = b;
            var c0 = c;
            var d0 = d;
            var _w1 = w1;
            var _w0 = w0;

            //  Offset before rotating
            tx = (wt.c * ch) + tx;
            ty = (wt.d * ch) + ty;
            
            //  Rotate matrix by 90 degrees with precalc values for sine and cosine of rad(90)
            a = (a0 * 6.123233995736766e-17) + -c0;
            b = (b0 * 6.123233995736766e-17) + -d0;
            c = a0 + (c0 * 6.123233995736766e-17);
            d = b0 + (d0 * 6.123233995736766e-17);

            // Update UV coordinates
            frame.updateUVsInverted();

            // Rotate dimensions
            w0 = h0;
            w1 = h1;
            h0 = _w0;
            h1 = _w1;
        }

        if (frame.autoRound === 1 || (frame.autoRound === -1 && renderer.roundPixels))
        {
            tx |= 0;
            ty |= 0;
        }

        var vert = this.glVertextData;

        //  Top Left Vert
        // vert.x0 = (a * w1) + (c * h1) + tx;
        // vert.y0 = (d * h1) + (b * w1) + ty;

        //  Top Right Vert
        // vert.x1 = (a * w0) + (c * h1) + tx;
        // vert.y1 = (d * h1) + (b * w0) + ty;

        //  Bottom Right Vert
        // vert.x2 = (a * w0) + (c * h0) + tx;
        // vert.y2 = (d * h0) + (b * w0) + ty;

        //  Bottom Left Vert
        // vert.x3 = (a * w1) + (c * h0) + tx;
        // vert.y3 = (d * h0) + (b * w1) + ty;
        
        return vert;
    },

    getVertexData: function (interpolationPercentage, renderer)
    {
        if (this.interpolate || this._dirtyVertex)
        {
            this.updateVertexData(interpolationPercentage, renderer);

            this._dirtyVertex = false;
        }

        return this.glVertextData;
    },

    cloneVertexData: function ()
    {
        var src = this.glVertextData;

        return {
            x0: src.x0,
            y0: src.y0,
            x1: src.x1,
            y1: src.y1,
            x2: src.x2,
            y2: src.y2,
            x3: src.x3,
            y3: src.y3
        };
    },

    getCanvasTransformData: function (interpolationPercentage, renderer)
    {
        var frame = this.gameObject.frame;

        var world = this.world;
        var data = this.canvasData;

        if (this.interpolate)
        {
            var old = this.old;

            // Interpolate with the last position to reduce stuttering.
            data.a = old.a + ((world.a - old.a) * interpolationPercentage);
            data.b = old.b + ((world.b - old.b) * interpolationPercentage);
            data.c = old.c + ((world.c - old.c) * interpolationPercentage);
            data.d = old.d + ((world.d - old.d) * interpolationPercentage);
            data.tx = old.tx + ((world.tx - old.tx) * interpolationPercentage);
            data.ty = old.ty + ((world.ty - old.ty) * interpolationPercentage);
            data.dx = old.dx + ((frame.x - (this.anchorX * frame.width)) * interpolationPercentage);
            data.dy = old.dy + ((frame.y - (this.anchorY * frame.height)) * interpolationPercentage);
        }
        else
        {
            //  Copy over the values to the canvasData object, in case the renderer needs to adjust them
            data.a = world.a;
            data.b = world.b;
            data.c = world.c;
            data.d = world.d;
            data.tx = world.tx;
            data.ty = world.ty;
            data.dx = frame.x - (this.anchorX * frame.width);
            data.dy = frame.y - (this.anchorY * frame.height);
        }

        if (frame.autoRound === 1 || (frame.autoRound === -1 && renderer.roundPixels))
        {
            data.tx |= 0;
            data.ty |= 0;
            data.dx |= 0;
            data.dy |= 0;
        }

        return data;
    }

};

Object.defineProperties(Transform.prototype, {

    //  Transform getters / setters

    x: {

        enumerable: true,

        get: function ()
        {
            return this._posX;
        },

        set: function (value)
        {
            this._posX = value;
            this.dirty = true;
        }

    },

    y: {

        enumerable: true,

        get: function ()
        {
            return this._posY;
        },

        set: function (value)
        {
            this._posY = value;
            this.dirty = true;
        }

    },

    scale: {

        enumerable: true,

        get: function ()
        {
            return this._scaleX;
        },

        set: function (value)
        {
            this._scaleX = value;
            this._scaleY = value;

            this.dirty = true;
            this.updateCache();
        }

    },

    scaleX: {

        enumerable: true,

        get: function ()
        {
            return this._scaleX;
        },

        set: function (value)
        {
            this._scaleX = value;

            this.dirty = true;
            this.updateCache();
        }

    },

    scaleY: {

        enumerable: true,

        get: function ()
        {
            return this._scaleY;
        },

        set: function (value)
        {
            this._scaleY = value;

            this.dirty = true;
            this.updateCache();
        }

    },

    anchor: {

        enumerable: true,

        get: function ()
        {
            return this._anchorX;
        },

        set: function (value)
        {
            this.setAnchor(value);
        }

    },

    anchorX: {

        enumerable: true,

        get: function ()
        {
            return this._anchorX;
        },

        set: function (value)
        {
            this._anchorX = value;
            this.dirty = true;
        }

    },

    anchorY: {

        enumerable: true,

        get: function ()
        {
            return this._anchorY;
        },

        set: function (value)
        {
            this._anchorY = value;
            this.dirty = true;
        }

    },

    pivotX: {

        enumerable: true,

        get: function ()
        {
            return this._pivotX;
        },

        set: function (value)
        {
            this._pivotX = value;
            this.dirty = true;
            this.updateCache();
        }

    },

    pivotY: {

        enumerable: true,

        get: function ()
        {
            return this._pivotY;
        },

        set: function (value)
        {
            this._pivotY = value;
            this.dirty = true;
            this.updateCache();
        }

    },

    angle: {

        enumerable: true,

        get: function ()
        {
            return WrapAngle(this.rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            this.rotation = WrapAngle(value) * MATH_CONST.DEG_TO_RAD;
        }

    },

    rotation: {

        enumerable: true,

        get: function ()
        {
            return this._rotation;
        },

        set: function (value)
        {
            if (this._rotation === value)
            {
                return;
            }

            this._rotation = value;
            this.dirty = true;

            if (this._rotation % MATH_CONST.PI2)
            {
                this.cache.sr = Math.sin(this._rotation);
                this.cache.cr = Math.cos(this._rotation);
                this.updateCache();
                this.hasLocalRotation = true;
            }
            else
            {
                this.hasLocalRotation = false;
            }
        }

    },

    //  Sets this *component* as being dirty
    dirty: {

        enumerable: true,

        get: function ()
        {
            return this._dirty;
        },

        set: function (value)
        {
            if (value)
            {
                if (!this._dirty)
                {
                    this._dirty = true;

                    if (this.immediate)
                    {
                        this.update();
                    }
                    else
                    {
                        this._dirtyVertex = true;
                        this.state.sys.updates.add(this);
                    }
                }
            }
            else
            {
                this._dirty = false;
            }
        }

    },

    //  GLOBAL read-only properties from here on
    //  Need *all* parents taken into account to get the correct values

    name: {

        enumerable: true,

        get: function ()
        {
            return (this.gameObject) ? this.gameObject.name : '';
        }

    },

    worldRotation: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this._worldRotation;
        }

    },

    worldScaleX: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this._worldScaleX;
        }

    },

    worldScaleY: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this._worldScaleY;
        }

    },

    worldX: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this.world.tx;
        }

    },

    worldY: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this.world.ty;
        }

    }

});

module.exports = Transform;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Audio = {

    /**
    * @property {boolean} audioData - Are Audio tags available?
    * @default
    */
    audioData: false,

    /**
    * @property {boolean} webAudio - Is the WebAudio API available?
    * @default
    */
    webAudio: false,

    /**
    * @property {boolean} ogg - Can this device play ogg files?
    * @default
    */
    ogg: false,

    /**
    * @property {boolean} opus - Can this device play opus files?
    * @default
    */
    opus: false,

    /**
    * @property {boolean} mp3 - Can this device play mp3 files?
    * @default
    */
    mp3: false,

    /**
    * @property {boolean} wav - Can this device play wav files?
    * @default
    */
    wav: false,

    /**
    * Can this device play m4a files?
    * @property {boolean} m4a - True if this device can play m4a files.
    * @default
    */
    m4a: false,

    /**
    * @property {boolean} webm - Can this device play webm files?
    * @default
    */
    webm: false,

    /**
    * @property {boolean} dolby - Can this device play EC-3 Dolby Digital Plus files?
    * @default
    */
    dolby: false

};

function init ()
{
    Audio.audioData = !!(window['Audio']);
    Audio.webAudio = !!(window['AudioContext'] || window['webkitAudioContext']);

    var audioElement = document.createElement('audio');

    var result = !!audioElement.canPlayType;

    try
    {
        if (result)
        {
            if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.ogg = true;
            }

            if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || audioElement.canPlayType('audio/opus;').replace(/^no$/, ''))
            {
                Audio.opus = true;
            }

            if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, ''))
            {
                Audio.mp3 = true;
            }

            //  Mimetypes accepted:
            //  developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
            //  bit.ly/iphoneoscodecs
            if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''))
            {
                Audio.wav = true;
            }

            if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, ''))
            {
                Audio.m4a = true;
            }

            if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.webm = true;
            }

            if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== '')
            {
                if (Browser.edge)
                {
                    Audio.dolby = true;
                }
                else if (Browser.safari && Browser.safariVersion >= 9)
                {
                    if ((/Mac OS X (\d+)_(\d+)/).test(navigator.userAgent))
                    {
                        var major = parseInt(RegExp.$1, 10);
                        var minor = parseInt(RegExp.$2, 10);

                        if ((major === 10 && minor >= 11) || major > 10)
                        {
                            Audio.dolby = true;
                        }
                    }
                }
            }
        }
    }
    catch (e)
    {
        //  Nothing to do here
    }

    return Audio;
}

module.exports = init();


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Fullscreen = {

    /**
    * @property {boolean} available - Does the browser support the Full Screen API?
    * @default
    */
    available: false,

    /**
    * @property {string} request - If the browser supports the Full Screen API this holds the call you need to use to activate it.
    * @default
    */
    request: '',

    /**
    * @property {string} cancel - If the browser supports the Full Screen API this holds the call you need to use to cancel it.
    * @default
    */
    cancel: '',

    /**
    * @property {boolean} keyboard - Does the browser support access to the Keyboard during Full Screen mode?
    * @default
    */
    keyboard: false

};

/**
* Checks for support of the Full Screen API.
*/
function init ()
{
    var fs = [
        'requestFullscreen',
        'requestFullScreen',
        'webkitRequestFullscreen',
        'webkitRequestFullScreen',
        'msRequestFullscreen',
        'msRequestFullScreen',
        'mozRequestFullScreen',
        'mozRequestFullscreen'
    ];

    var element = document.createElement('div');

    for (var i = 0; i < fs.length; i++)
    {
        if (element[fs[i]])
        {
            Fullscreen.available = true;
            Fullscreen.request = fs[i];
            break;
        }
    }

    var cfs = [
        'cancelFullScreen',
        'exitFullscreen',
        'webkitCancelFullScreen',
        'webkitExitFullscreen',
        'msCancelFullScreen',
        'msExitFullscreen',
        'mozCancelFullScreen',
        'mozExitFullscreen'
    ];

    if (Fullscreen.available)
    {
        for (var i = 0; i < cfs.length; i++)
        {
            if (document[cfs[i]])
            {
                Fullscreen.cancel = cfs[i];
                break;
            }
        }
    }

    //  Keyboard Input?
    if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT'])
    {
        Fullscreen.keyboard = true;
    }

    return Fullscreen;
}

module.exports = init();


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Input = {

    /**
    * @property {boolean} touch - Is touch available?
    * @default
    */
    touch: false,

    /**
    * @property {boolean} mspointer - Is mspointer available?
    * @default
    */
    mspointer: false,

    /**
    * @property {?string} wheelType - The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'
    * @default
    * @protected
    */
    wheelEvent: null
    
};

function init ()
{
    if ('ontouchstart' in document.documentElement || (window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1))
    {
        Input.touch = true;
    }

    if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled)
    {
        Input.mspointer = true;
    }

    if (!OS.cocoonJS)
    {
        // See https://developer.mozilla.org/en-US/docs/Web/Events/wheel
        if ('onwheel' in window || (Browser.ie && 'WheelEvent' in window))
        {
            // DOM3 Wheel Event: FF 17+, IE 9+, Chrome 31+, Safari 7+
            Input.wheelEvent = 'wheel';
        }
        else if ('onmousewheel' in window)
        {
            // Non-FF legacy: IE 6-9, Chrome 1-31, Safari 5-7.
            Input.wheelEvent = 'mousewheel';
        }
        else if (Browser.firefox && 'MouseScrollEvent' in window)
        {
            // FF prior to 17. This should probably be scrubbed.
            Input.wheelEvent = 'DOMMouseScroll';
        }
    }

    return Input;
}

module.exports = init();


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Video = {

    /**
    * @property {boolean} oggVideo - Can this device play ogg video files?
    * @default
    */
    oggVideo: false,

    /**
    * @property {boolean} h264Video - Can this device play h264 mp4 video files?
    * @default
    */
    h264Video: false,

    /**
    * @property {boolean} mp4Video - Can this device play h264 mp4 video files?
    * @default
    */
    mp4Video: false,

    /**
    * @property {boolean} webmVideo - Can this device play webm video files?
    * @default
    */
    webmVideo: false,

    /**
    * @property {boolean} vp9Video - Can this device play vp9 video files?
    * @default
    */
    vp9Video: false,

    /**
    * @property {boolean} hlsVideo - Can this device play hls video files?
    * @default
    */
    hlsVideo: false

};

function init ()
{
    var videoElement = document.createElement('video');
    var result = !!videoElement.canPlayType;

    try
    {
        if (result)
        {
            if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ''))
            {
                Video.oggVideo = true;
            }

            if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
                Video.h264Video = true;
                Video.mp4Video = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ''))
            {
                Video.webmVideo = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, ''))
            {
                Video.vp9Video = true;
            }

            if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                Video.hlsVideo = true;
            }
        }
    }
    catch (e)
    {
        //  Nothing to do
    }

    return Video;
}

module.exports = init();


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games can share it,
//  without having to re-poll the device all over again

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);
var Features = __webpack_require__(40);
var Input = __webpack_require__(97);
var Audio = __webpack_require__(95);
var Video = __webpack_require__(98);
var Fullscreen = __webpack_require__(96);
var CanvasFeatures = __webpack_require__(39);

module.exports = {

    OS: OS,
    Browser: Browser,
    Features: Features,
    Input: Input,
    Audio: Audio,
    Video: Video,
    Fullscreen: Fullscreen,
    CanvasFeatures: CanvasFeatures

};


/***/ },
/* 100 */
/***/ function(module, exports) {

var AddToDOM = function (element, parent, overflowHidden)
{
    if (overflowHidden === undefined) { overflowHidden = true; }

    var target;

    if (parent)
    {
        if (typeof parent === 'string')
        {
            //  Hopefully an element ID
            target = document.getElementById(parent);
        }
        else if (typeof parent === 'object' && parent.nodeType === 1)
        {
            //  Quick test for a HTMLelement
            target = parent;
        }
    }

    //  Fallback, covers an invalid ID and a non HTMLelement object
    if (!target)
    {
        target = document.body;
    }

    if (overflowHidden && target.style)
    {
        target.style.overflow = 'hidden';
    }

    target.appendChild(element);

    return element;
};

module.exports = AddToDOM;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var OS = __webpack_require__(4);

var isBooted = false;

var DOMContentLoaded = function (callback)
{
    if (isBooted)
    {
        return;
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive')
    {
        isBooted = true;
        
        callback();

        return;
    }

    var check = function ()
    {
        isBooted = true;

        document.removeEventListener('deviceready', check, true);
        document.removeEventListener('DOMContentLoaded', check, true);
        window.removeEventListener('load', check, true);

        callback();
    };

    if (!document.body)
    {
        window.setTimeout(check, 20);
    }
    else if (OS.cordova && !OS.cocoonJS)
    {
        //  Ref. http://docs.phonegap.com/en/3.5.0/cordova_events_events.md.html#deviceready
        document.addEventListener('deviceready', check, false);
    }
    else
    {
        document.addEventListener('DOMContentLoaded', check, true);
        window.addEventListener('load', check, true);
    }
};

module.exports = DOMContentLoaded;


/***/ },
/* 102 */
/***/ function(module, exports) {

var ParseXML = function (data)
{
    var xml = '';

    try
    {
        if (window['DOMParser'])
        {
            var domparser = new DOMParser();
            xml = domparser.parseFromString(data, 'text/xml');
        }
        else
        {
            xml = new ActiveXObject('Microsoft.XMLDOM');
            xml.loadXML(data);
        }
    }
    catch (e)
    {
        xml = null;
    }

    if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length)
    {
        return null;
    }
    else
    {
        return xml;
    }
};

module.exports = ParseXML;


/***/ },
/* 103 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Abstracts away the use of RAF or setTimeOut for the core game update loop.
*
* @class Phaser.RequestAnimationFrame
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
* @param {boolean} [forceSetTimeOut=false] - Tell Phaser to use setTimeOut even if raf is available.
*/
function RequestAnimationFrame (game)
{
    /**
    * @property {Phaser.Game} game - The currently running game.
    */
    this.game = game;

    /**
    * @property {boolean} isRunning - true if RequestAnimationFrame is running, otherwise false.
    * @default
    */
    this.isRunning = false;

    this.tick = 0;

    /**
    * @property {boolean} isSetTimeOut  - True if the browser is using setTimeout instead of rAf.
    */
    this.isSetTimeOut = false;

    /**
    * @property {number} timeOutID - The callback setTimeout or rAf callback ID used when calling cancel.
    */
    this.timeOutID = null;

    var _this = this;

    //  timestamp = DOMHighResTimeStamp
    var step = function (timestamp)
    {
        _this.tick = timestamp;

        _this.timeOutID = window.requestAnimationFrame(step);

        _this.game.update(timestamp);
    };

    var stepTimeout = function ()
    {
        _this.tick = Date.now();

        // _this.game.update(_this.tick);

        // _this.timeOutID = window.setTimeout(stepTimeout, _this.game.time.timeToCall);
    };

    /**
    * Starts the requestAnimationFrame running or setTimeout if unavailable in browser
    * @method Phaser.RequestAnimationFrame#start
    */
    this.start = function ()
    {
        this.isRunning = true;

        if (this.game.config.forceSetTimeOut)
        {
            this.isSetTimeOut = true;

            this.timeOutID = window.setTimeout(stepTimeout, 0);
        }
        else
        {
            this.isSetTimeOut = false;

            this.timeOutID = window.requestAnimationFrame(step);
        }
    };

    /**
    * Stops the requestAnimationFrame from running.
    * @method Phaser.RequestAnimationFrame#stop
    */
    this.stop = function ()
    {
        this.isRunning = false;

        if (this.isSetTimeOut)
        {
            clearTimeout(this.timeOutID);
        }
        else
        {
            window.cancelAnimationFrame(this.timeOutID);
        }
    };

    this.destroy = function ()
    {
        this.stop();

        this.game = undefined;
    };

}

RequestAnimationFrame.prototype.constructor = RequestAnimationFrame;

module.exports = RequestAnimationFrame;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(41);
var EventListener = __webpack_require__(105);

var EventBinding = function (dispatcher, type)
{
    this.dispatcher = dispatcher;
    this.type = type;
    this.state = CONST.DISPATCHER_IDLE;
    this.active = [];
};

EventBinding.prototype.constructor = EventBinding;

EventBinding.prototype = {

    total: function ()
    {
        var total = 0;

        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state !== CONST.LISTENER_REMOVING)
            {
                total++;
            }
        }

        return total;
    },

    get: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return this.active[i];
            }
        }
    },

    getIndex: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return i;
            }
        }

        return null;
    },

    has: function (callback)
    {
        return (this.get(callback));
    },

    add: function (callback, priority, once)
    {
        var listener = this.get(callback);

        if (!listener)
        {
            //  The listener doesn't exist, so create one
            listener = EventListener(this.type, callback, priority, once);
        }
        else
        {
            //  Listener already exists, abort
            return;
        }

        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we don't need a pending state
            listener.state = CONST.LISTENER_ACTIVE;

            this.active.push(listener);

            this.active.sort(this.sortHandler);
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  Add it to the list, but keep the state as pending.
            //  The call to 'tidy' will sort it out at the end of the dispatch.
            this.active.push(listener);
        }
    },

    sortHandler: function (listenerA, listenerB)
    {
        if (listenerB.priority < listenerA.priority)
        {
            return -1;
        }
        else if (listenerB.priority > listenerA.priority)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    },

    remove: function (callback)
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we can remove right away
            var i = this.getIndex(callback);

            if (i !== null)
            {
                this.active.splice(i, 1);
            }
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  The Dispatcher is working, so we flag the listener for removal at the end
            var listener = this.get(callback);

            if (listener)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }
        }
    },

    dispatch: function (event)
    {
        if (this.state !== CONST.DISPATCHER_IDLE)
        {
            throw new Error('Error: Failed to execute \'EventDispatcher.dispatch\' on \'' + this.type + '\': The event is already being dispatched.');
        }
        else if (this.active.length === 0)
        {
            //  This was a valid dispatch call, we just had nothing to do ...
            return;
        }

        this.state = CONST.DISPATCHER_DISPATCHING;

        var listener;

        for (var i = 0; i < this.active.length; i++)
        {
            listener = this.active[i];

            if (listener.state !== CONST.LISTENER_ACTIVE)
            {
                continue;
            }

            listener.callback.call(this.dispatcher, event);

            //  Has the callback changed the state of this binding?
            if (this.state !== CONST.DISPATCHER_DISPATCHING)
            {
                //  Yup! Let's break out
                break;
            }

            //  Was it a 'once' listener?
            if (listener.once)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }

            //  Has the event been halted by the callback?
            if (!event._propagate)
            {
                //  Break out, a listener has called Event.stopPropagation
                break;
            }
        }

        //  Dispatch over, or aborted
        if (this.state === CONST.DISPATCHER_REMOVING)
        {
            this.removeAll();

            //  All done, tidy the list in case there were any pending events added
            this.tidy();
        }
        else if (this.state === CONST.DISPATCHER_DESTROYED)
        {
            this.dispatcher.delete(this.type);
        }
        else
        {
            //  All done, just purge the list
            this.tidy();

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    //  Removes all listeners
    //  If this is currently being dispatched then don't remove 'pending' listeners
    //  (i.e. ones that were added during the dispatch), only active ones
    removeAll: function ()
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            this.active.length = 0;
        }
        else
        {
            for (var i = this.active.length - 1; i >= 0; i--)
            {
                if (this.active[i].state !== CONST.LISTENER_PENDING)
                {
                    this.active.pop();
                }
            }

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    tidy: function ()
    {
        var added = 0;

        var i = this.active.length - 1;

        do
        {
            if (this.active[i].state === CONST.LISTENER_REMOVING)
            {
                this.active.splice(i, 1);
            }
            else if (this.active[i].state === CONST.LISTENER_PENDING)
            {
                this.active[i].state === CONST.LISTENER_ACTIVE;
                added++;
            }

            i--;
        }
        while (i >= 0);

        if (added > 0)
        {
            this.active.sort(this.sortHandler);
        }
    },

    destroy: function ()
    {
        this.active.length = 0;
        this.dispatcher = undefined;
        this.type = '';
        this.state = CONST.DISPATCHER_DESTROYED;
    }

};

module.exports = EventBinding;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(41);

var EventListener = function (type, callback, priority, once)
{
    return {
        type: type,
        callback: callback,
        priority: priority,
        once: once,
        state: CONST.LISTENER_PENDING
    };
};

module.exports = EventListener;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var Bob = __webpack_require__(108);
var GameObject = __webpack_require__(21);
var Children = __webpack_require__(18);

/**
* A Blitter Game Object.
*
* The Blitter Game Object is a special type of Container, that contains Blitter.Bob objects.
* These objects can be thought of as just texture frames with a transform, and nothing more.
* Bobs don't have any update methods, or the ability to have children, or any kind of special effects.
* They are essentially just texture renderers, and the Blitter object creates and manages them.
*
* @class Blitter
* @extends Phaser.GameObject
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
* @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {string} [key] - The texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
* @param {string|number} [frame] - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
*/
var Blitter = function (state, x, y, key, frame)
{
    var _texture = state.game.textures.get(key);
    var _frame = _texture.get(frame);

    GameObject.call(this, state, x, y, _texture, _frame);

    this.type = CONST.BLITTER;

    this.children = new Children(this);
};

Blitter.prototype = Object.create(GameObject.prototype);
Blitter.prototype.constructor = Blitter;

// Blitter.prototype.renderCanvas = require('./BlitterCanvasRenderer');
Blitter.prototype.renderWebGL = __webpack_require__(107);

//  frame MUST be part of the Blitter texture
Blitter.prototype.create = function (x, y, frame, visible, index)
{
    if (frame === undefined) { frame = this.frame; }
    if (visible === undefined) { visible = true; }
    if (index === undefined) { index = 0; }

    var bob = new Bob(this, x, y, frame, visible);

    this.children.addAt(bob, index, false);

    return bob;
};

//  frame MUST be part of the Blitter texture
Blitter.prototype.createFromCallback = function (callback, quantity, frame, visible)
{
    var bobs = this.createMultiple(quantity, frame, visible);

    for (var i = 0; i < bobs.length; i++)
    {
        var bob = bobs[i];

        callback.call(this, bob, i);
    }

    return bobs;
};

//  frame MUST be part of the Blitter texture
Blitter.prototype.createMultiple = function (quantity, frame, visible)
{
    if (frame === undefined) { frame = this.frame; }
    if (visible === undefined) { visible = true; }

    if (!Array.isArray(frame))
    {
        frame = [ frame ];
    }

    var bobs = [];
    var _this = this;

    frame.forEach(function (singleFrame)
    {
        for (var i = 0; i < quantity; i++)
        {
            bobs.push(_this.create(0, 0, singleFrame, visible));
        }
    });

    return bobs;
};

module.exports = Blitter;


/***/ },
/* 107 */
/***/ function(module, exports) {


var BlitterWebGLRenderer = function (renderer, src, interpolationPercentage)
{
    var worldAlpha = src.color.worldAlpha;
    var len = src.children.list.length;

    //  Skip rendering?

    if (src.skipRender || !src.visible || worldAlpha === 0 || len === 0)
    {
        return;
    }

    //  Render children
    for (var i = 0; i < len; i++)
    {
        var bob = src.children.list[i];
        var frame = bob.frame;

        if (!bob.visible || !frame.cutWidth || !frame.cutHeight)
        {
            continue;
        }

        renderer.blitterBatch.add(bob.x, bob.y, frame, worldAlpha);
    }
};

module.exports = BlitterWebGLRenderer;


/***/ },
/* 108 */
/***/ function(module, exports) {

var Bob = function (blitter, x, y, frame, visible)
{
    this.parent = blitter;

    this.x = x;
    this.y = y;
    this.frame = frame;
    this.visible = visible;
};

module.exports = Bob;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var GameObject = __webpack_require__(21);
var ContainerWebGLRenderer = __webpack_require__(110);
var Children = __webpack_require__(18);

var Container = function (state, parent, x, y)
{
    GameObject.call(this, state, x, y, null, null, parent);

    this.type = CONST.CONTAINER;

    this.render = ContainerWebGLRenderer;

    this.children = new Children(this);
};

Container.prototype = Object.create(GameObject.prototype);
Container.prototype.constructor = Container;

Container.prototype.preUpdate = function ()
{
    this.children.preUpdate();
};

module.exports = Container;


/***/ },
/* 110 */
/***/ function(module, exports) {


var ContainerWebGLRenderer = function (renderer, src, interpolationPercentage)
{
    var alpha = src.color.worldAlpha * 255 << 24;

    //  Skip rendering?

    if (src.skipRender || !src.visible || alpha === 0 || src.children.list.length === 0)
    {
        return;
    }

    //  Render children
    for (var i = 0; i < src.children.list.length; i++)
    {
        var child = src.children.list[i];

        child.render(renderer, child);
    }
};

module.exports = ContainerWebGLRenderer;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var GameObject = __webpack_require__(21);

/**
* An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
* It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
*
* @class Phaser.GameObject.Image
* @extends Phaser.GameObject
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
* @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {string} [key] - The texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
* @param {string|number} [frame] - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
*/
var Image = function (state, x, y, key, frame)
{
    var _texture = state.game.textures.get(key);
    var _frame = _texture.get(frame);

    GameObject.call(this, state, x, y, _texture, _frame);

    this.type = CONST.IMAGE;
};

Image.prototype = Object.create(GameObject.prototype);
Image.prototype.constructor = Image;

Image.prototype.renderCanvas = __webpack_require__(112);
Image.prototype.renderWebGL = __webpack_require__(113);

Object.defineProperties(Image.prototype, {

    width: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX * this.frame.realWidth;
        },

        set: function (value)
        {
            this.scaleX = value / this.frame.realWidth;
        }

    },

    height: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleY * this.frame.realHeight;
        },

        set: function (value)
        {
            this.scaleY = value / this.frame.realHeight;
        }

    }

});

module.exports = Image;


/***/ },
/* 112 */
/***/ function(module, exports) {


var ImageCanvasRenderer = function (renderer, src, interpolationPercentage)
{
    var frame = src.frame;
    var alpha = src.color.worldAlpha * 255 << 24;

    //  Skip rendering?

    if (src.skipRender || !src.visible || alpha === 0 || !frame.cutWidth || !frame.cutHeight)
    {
        return;
    }

    var data = src.transform.getCanvasTransformData(interpolationPercentage, renderer);
    var tint = src.color._glTint;
    var bg = src.color._glBg;

    renderer.drawImage(frame, src.blendMode, data, alpha, tint, bg);
};

module.exports = ImageCanvasRenderer;


/***/ },
/* 113 */
/***/ function(module, exports) {


var ImageWebGLRenderer = function (renderer, src, interpolationPercentage)
{
    var frame = src.frame;
    var alpha = src.color.worldAlpha * 255 << 24;

    //  Skip rendering?

    if (src.skipRender || !src.visible || alpha === 0 || !frame.cutWidth || !frame.cutHeight)
    {
        return;
    }

    // var verts = src.transform.getVertexData(interpolationPercentage, renderer);
    // var index = src.frame.source.glTextureIndex;
    // var tint = src.color._glTint;
    // var bg = src.color._glBg;
    // renderer.batch.add(frame.source, src.blendMode, verts, frame.uvs, index, alpha, tint, bg);

    var transform = src.transform;
    renderer.setBlendMode(src.color._blendMode);
    renderer.spriteBatch.add(
        frame,
        transform._anchorX, transform._anchorY,
        transform.world.tx, transform.world.ty,
        transform._worldScaleX, transform._worldScaleY,
        transform._worldRotation,
        src.color._glTint
    );
};

module.exports = ImageWebGLRenderer;


/***/ },
/* 114 */
/***/ function(module, exports) {

var Area = function (circle)
{
    return (circle.radius > 0) ? Math.PI * circle.radius * circle.radius : 0;
};

module.exports = Area;


/***/ },
/* 115 */
/***/ function(module, exports) {

var Circumference = function (circle)
{
    return 2 * (Math.PI * circle.radius);
};

module.exports = Circumference;


/***/ },
/* 116 */
/***/ function(module, exports) {

/**
* Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
* @method Phaser.Circle.circumferencePoint
* @param {Phaser.Circle} a - The first Circle object.
* @param {number} angle - The angle in radians (unless asDegrees is true) to return the point from.
* @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.
* @return {Phaser.Point} The Point object holding the result.
*/
var CircumferencePoint = function (circle, angle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = circle.x + (circle.radius * Math.cos(angle));
    out.y = circle.y + (circle.radius * Math.sin(angle));

    return out;
};

module.exports = CircumferencePoint;


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

var Circle = __webpack_require__(42);

var Clone = function (source)
{
    return new Circle(source.x, source.y, source.radius);
};

module.exports = Clone;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(22);

var ContainsPoint = function (circle, point)
{
    return Contains(circle, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(22);

var ContainsRect = function (circle, rect)
{
    return (
        Contains(circle, rect.x, rect.y) &&
        Contains(circle, rect.right, rect.y) &&
        Contains(circle, rect.x, rect.bottom) &&
        Contains(circle, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 120 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.radius);
};

module.exports = CopyFrom;


/***/ },
/* 121 */
/***/ function(module, exports) {

var Equals = function (circle, toCompare)
{
    return (
        circle.x === toCompare.x &&
        circle.y === toCompare.y &&
        circle.radius === toCompare.radius
    );
};

module.exports = Equals;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var GetBounds = function (circle, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = circle.left;
    out.y = circle.top;
    out.width = circle.diameter;
    out.height = circle.diameter;

    return out;
};

module.exports = GetBounds;


/***/ },
/* 123 */
/***/ function(module, exports) {

var Offset = function (circle, x, y)
{
    circle.x += x;
    circle.y += y;

    return circle;
};

module.exports = Offset;


/***/ },
/* 124 */
/***/ function(module, exports) {

var OffsetPoint = function (circle, point)
{
    circle.x += point.x;
    circle.y += point.y;

    return circle;
};

module.exports = OffsetPoint;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

/**
* Returns a uniformly distributed random point from anywhere within this Circle.
* 
* @method Phaser.Circle#random
* @param {Phaser.Point|object} [out] - A Phaser.Point, or any object with public x/y properties, that the values will be set in.
*     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.
* @return {Phaser.Point} An object containing the random point in its `x` and `y` properties.
*/
var Random = function (circle, out)
{
    if (out === undefined) { out = new Point(); }

    var t = 2 * Math.PI * Math.random();
    var u = Math.random() + Math.random();
    var r = (u > 1) ? 2 - u : u;
    var x = r * Math.cos(t);
    var y = r * Math.sin(t);

    out.x = circle.x + (x * circle.radius);
    out.y = circle.y + (y * circle.radius);

    return out;
};

module.exports = Random;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Circle

var Circle = __webpack_require__(42);

Circle.Area = __webpack_require__(114);
Circle.Circumference = __webpack_require__(115);
Circle.CircumferencePoint = __webpack_require__(116);
Circle.Clone = __webpack_require__(117);
Circle.Contains = __webpack_require__(22);
Circle.ContainsPoint = __webpack_require__(118);
Circle.ContainsRect = __webpack_require__(119);
Circle.CopyFrom = __webpack_require__(120);
Circle.Equals = __webpack_require__(121);
Circle.GetBounds = __webpack_require__(122);
Circle.Offset = __webpack_require__(123);
Circle.OffsetPoint = __webpack_require__(124);
Circle.Random = __webpack_require__(125);

module.exports = Circle;


/***/ },
/* 127 */
/***/ function(module, exports) {

var Area = function (ellipse)
{
    if (ellipse.isEmpty())
    {
        return 0;
    }

    //  units squared
    return (ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI);
};

module.exports = Area;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

var Ellipse = __webpack_require__(43);

var Clone = function (source)
{
    return new Ellipse(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(23);

var ContainsPoint = function (ellipse, point)
{
    return Contains(ellipse, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(23);

var ContainsRect = function (ellipse, rect)
{
    return (
        Contains(ellipse, rect.x, rect.y) &&
        Contains(ellipse, rect.right, rect.y) &&
        Contains(ellipse, rect.x, rect.bottom) &&
        Contains(ellipse, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 131 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Ellipse} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ },
/* 132 */
/***/ function(module, exports) {

var Equals = function (ellipse, toCompare)
{
    return (
        ellipse.x === toCompare.x &&
        ellipse.y === toCompare.y &&
        ellipse.width === toCompare.width &&
        ellipse.height === toCompare.height
    );
};

module.exports = Equals;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var GetBounds = function (ellipse, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = ellipse.x - ellipse.width;
    out.y = ellipse.y - ellipse.height;
    out.width = ellipse.width;
    out.height = ellipse.height;

    return out;
};

module.exports = GetBounds;


/***/ },
/* 134 */
/***/ function(module, exports) {

var Offset = function (ellipse, x, y)
{
    ellipse.x += x;
    ellipse.y += y;

    return ellipse;
};

module.exports = Offset;


/***/ },
/* 135 */
/***/ function(module, exports) {

var OffsetPoint = function (ellipse, point)
{
    ellipse.x += point.x;
    ellipse.y += point.y;

    return ellipse;
};

module.exports = OffsetPoint;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Random = function (ellipse, out)
{
    if (out === undefined) { out = new Point(); }

    var p = Math.random() * Math.PI * 2;
    var s = Math.sqrt(Math.random());

    out.x = ellipse.x + ((s * Math.cos(p)) * ellipse.width / 2);
    out.y = ellipse.y + ((s * Math.sin(p)) * ellipse.height / 2);

    return out;
};

module.exports = Random;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Ellipse

var Ellipse = __webpack_require__(43);

Ellipse.Area = __webpack_require__(127);
Ellipse.Clone = __webpack_require__(128);
Ellipse.Contains = __webpack_require__(23);
Ellipse.ContainsPoint = __webpack_require__(129);
Ellipse.ContainsRect = __webpack_require__(130);
Ellipse.CopyFrom = __webpack_require__(131);
Ellipse.Equals = __webpack_require__(132);
Ellipse.GetBounds = __webpack_require__(133);
Ellipse.Offset = __webpack_require__(134);
Ellipse.OffsetPoint = __webpack_require__(135);
Ellipse.Random = __webpack_require__(136);

module.exports = Ellipse;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

var GetAngle = __webpack_require__(44);
var FindT = __webpack_require__(24);

/**
* Calculate and return the angle, in radians, of the curves tangent at the given pixel distance along the curves length.
*
* @method Phaser.Hermite#getAngleWithDistance
* @param {number} [distance=0] - The distance along the curve to get the angle from, in pixels.
* @return {number} The angle of the line at the specified distance along the curve. The value is in radians.
*/
var GetAngleWithDistance = function (curve, distance)
{
    if (distance === undefined) { distance = 0; }

    if (distance <= 0)
    {
        return Math.atan2(this._v1y, this._v1x);
    }
    else
    {
        return GetAngle(curve, FindT(curve, distance));
    }
};

module.exports = GetAngleWithDistance;


/***/ },
/* 139 */
/***/ function(module, exports) {

/**
* Get the angle of the curves entry point.
*
* @method Phaser.Hermite#getEntryTangent
* @param {Phaser.Point|Object} point - The Phaser.Point object, or an Object with public `x` and `y` properties, in which the tangent vector values will be stored.
* @return {Phaser.Point} A Point object containing the tangent vector of this Hermite curve.
*/
var GetEntryTangent = function (curve, point)
{
    point.x = curve._v1x;
    point.y = curve._v1y;

    return point;
};

module.exports = GetEntryTangent;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);
var GetPoint = __webpack_require__(25);
var FindT = __webpack_require__(24);

/**
* Get a point on the curve using the distance, in pixels, along the curve.
*
* @method Phaser.Hermite#getPointWithDistance
* @param {integer} [distance=0] - The distance along the curve to get the point from, given in pixels.
* @param {Phaser.Point|Object} [point] - An optional Phaser.Point, or Object containing public `x` and `y` properties. If given the resulting values will be stored in the Objects `x` and `y` properties. If omitted a new Phaser.Point object is created.
* @return {Phaser.Point} The point on the line at the specified 'distance' along the curve.
*/
var GetPointWithDistance = function (curve, distance, out)
{
    if (distance === undefined) { distance = 0; }
    if (out === undefined) { out = new Point(); }

    if (distance <= 0)
    {
        out.x = this._p1x;
        out.y = this._p1y;
    }
    else
    {
        GetPoint(curve, FindT(curve, distance), out);
    }
    
    return out;
};

module.exports = GetPointWithDistance;


/***/ },
/* 141 */
/***/ function(module, exports) {

/**
* Get the X component of a point on the curve based on the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getX
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @return {number} The X component of a point on the curve based on the `t` (time) value.
*/
var GetX = function (curve, t)
{
    if (t === undefined)
    {
        t = 0;
    }
    else
    {
        if (t < 0)
        {
            t = 0;
        }

        if (t > 1)
        {
            t = 1;
        }
    }

    var t2 = t * t;
    var t3 = t * t2;

    return (t3 * curve._ax + t2 * curve._bx + t * curve._v1x + curve._p1x);
};

module.exports = GetX;


/***/ },
/* 142 */
/***/ function(module, exports) {

/**
* Get the Y component of a point on the curve based on the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getY
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @return {number} The Y component of a point on the curve based on the `t` (time) value.
*/
var GetY = function (curve, t)
{
    if (t === undefined)
    {
        t = 0;
    }
    else
    {
        if (t < 0)
        {
            t = 0;
        }

        if (t > 1)
        {
            t = 1;
        }
    }

    var t2 = t * t;
    var t3 = t * t2;

    return (t3 * curve._ay + t2 * curve._by + t * curve._v1y + curve._p1y);
};

module.exports = GetY;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

/**
* @author       Richard Davey <rich@photonstorm.com>
* @author       Pete Baron <pete@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A data representation of a Hermite Curve (see http://en.wikipedia.org/wiki/Cubic_Hermite_spline)
* 
* A Hermite curve has a start and end point and tangent vectors for both of them.
* The curve will always pass through the two control points and the shape of it is controlled
* by the length and direction of the tangent vectors.  At the control points the curve will
* be facing exactly in the vector direction.
* 
* As these curves change speed (speed = distance between points separated by an equal change in
* 't' value - see Hermite.getPoint) this class attempts to reduce the variation by pre-calculating
* the `accuracy` number of points on the curve. The straight-line distances to these points are stored
* in the private 'points' array, and this information is used by Hermite.findT() to convert a pixel
* distance along the curve into a 'time' value.
* 
* Higher `accuracy` values will result in more even movement, but require more memory for the points
* list. 5 works, but 10 seems to be an ideal value for the length of curves found in most games on
* a desktop screen. If you use very long curves (more than 400 pixels) you may need to increase
* this value further.
*
* @class Phaser.Hermite
* @constructor
* @param {number} p1x - The x coordinate of the start of the curve.
* @param {number} p1y - The y coordinate of the start of the curve.
* @param {number} p2x - The x coordinate of the end of the curve.
* @param {number} p2y - The y coordinate of the end of the curve.
* @param {number} v1x - The x component of the tangent vector for the start of the curve.
* @param {number} v1y - The y component of the tangent vector for the start of the curve.
* @param {number} v2x - The x component of the tangent vector for the end of the curve.
* @param {number} v2y - The y component of the tangent vector for the end of the curve.
* @param {number} [accuracy=10] The amount of points to pre-calculate on the curve.
*/
var Hermite = function (p1x, p1y, p2x, p2y, v1x, v1y, v2x, v2y, accuracy)
{
    if (accuracy === undefined) { accuracy = 10; }

    /**
    * @property {number} _accuracy - The amount of points to pre-calculate on the curve.
    * @private
    */
    this._accuracy = accuracy;

    /**
    * @property {number} _p1x - The x coordinate of the start of the curve.
    * @private
    */
    this._p1x = p1x;

    /**
    * @property {number} _p1y - The y coordinate of the start of the curve.
    * @private
    */
    this._p1y = p1y;

    /**
    * @property {number} _p2x - The x coordinate of the end of the curve.
    * @private
    */
    this._p2x = p2x;

    /**
    * @property {number} _p2y - The y coordinate of the end of the curve.
    * @private
    */
    this._p2y = p2y;

    /**
    * @property {number} _v1x - The x component of the tangent vector for the start of the curve.
    * @private
    */
    this._v1x = v1x;

    /**
    * @property {number} _v1y - The y component of the tangent vector for the start of the curve.
    * @private
    */
    this._v1y = v1y;

    /**
    * @property {number} _v2x - The x component of the tangent vector for the end of the curve.
    * @private
    */
    this._v2x = v2x;

    /**
    * @property {number} _v2y - The y component of the tangent vector for the end of the curve.
    * @private
    */
    this._v2y = v2y;
    
    /**
    * @property {array} _points - A local array of cached points.
    * @private
    */
    this._points = [];

    /**
    * @property {Phaser.Point} _temp1 - A local cached Point object.
    * @private
    */
    this._temp1 = new Point();

    /**
    * @property {Phaser.Point} _temp2 - A local cached Point object.
    * @private
    */
    this._temp2 = new Point();

    this.recalculate();
};

Hermite.prototype.constructor = Hermite;

Hermite.prototype = {

    /**
    * Performs the curve calculations.
    *
    * This is called automatically if you change any of the curves public properties, such as `Hermite.p1x` or `Hermite.v2y`.
    *
    * If you adjust any of the internal private values, then call this to update the points.
    *
    * @method Phaser.Hermite#recalculate
    * @return {Phaser.Hermite} This object.
    */
    recalculate: function () {

        this._ax = (2 * this._p1x - 2 * this._p2x + this._v1x + this._v2x);
        this._ay = (2 * this._p1y - 2 * this._p2y + this._v1y + this._v2y);
        this._bx = (-3 * this._p1x + 3 * this._p2x - 2 * this._v1x - this._v2x);
        this._by = (-3 * this._p1y + 3 * this._p2y - 2 * this._v1y - this._v2y);

        this.length = this.calculateEvenPoints();

        return this;

    },

    /**
    * Calculate a number of points along the curve, based on `Hermite.accuracy`, and stores them in the private `_points` array.
    *
    * @method Phaser.Hermite#calculateEvenPoints
    * @return {number} The total length of the curve approximated as straight line distances between the points.
    */
    calculateEvenPoints: function () {

        var totalLength = 0;

        this._temp1.setTo(0, 0);                    //  pnt
        this._temp2.setTo(this._p1x, this._p1y);    //  lastPnt

        this._points[0] = 0;

        for (var i = 1; i <= this._accuracy; i++)
        {
            this.getPoint(i / this._accuracy, this._temp1);
            totalLength += this._temp1.distance(this._temp2);
            this._points[i] = totalLength;
            this._temp2.copyFrom(this._temp1);
        }

        return totalLength;

    }

};

Object.defineProperties(Hermite.prototype, {

    /**
    * @name Phaser.Hermite#accuracy
    * @property {number} accuracy - The amount of points to pre-calculate on the curve.
    */
    accuracy: {

        enumerable: true,

        get: function ()
        {
            return this._accuracy;
        },

        set: function (value)
        {
            if (value !== this._accuracy)
            {
                this._accuracy = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p1x
    * @property {number} p1x - The x coordinate of the start of the curve. Setting this value will recalculate the curve.
    */
    p1x: {

        enumerable: true,

        get: function () {

            return this._p1x;

        },

        set: function (value) {

            if (value !== this._p1x)
            {
                this._p1x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#p1y
    * @property {number} p1y - The y coordinate of the start of the curve. Setting this value will recalculate the curve.
    */
    p1y: {

        enumerable: true,

        get: function () {

            return this._p1y;

        },

        set: function (value) {

            if (value !== this._p1y)
            {
                this._p1y = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#p2x
    * @property {number} p2x - The x coordinate of the end of the curve. Setting this value will recalculate the curve.
    */
    p2x: {

        enumerable: true,

        get: function () {

            return this._p2x;

        },

        set: function (value) {

            if (value !== this._p2x)
            {
                this._p2x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#p2y
    * @property {number} p2y - The y coordinate of the end of the curve. Setting this value will recalculate the curve.
    */
    p2y: {

        enumerable: true,

        get: function () {

            return this._p2y;

        },

        set: function (value) {

            if (value !== this._p2y)
            {
                this._p2y = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v1x
    * @property {number} v1x - The x component of the tangent vector for the start of the curve. Setting this value will recalculate the curve.
    */
    v1x: {

        enumerable: true,

        get: function () {

            return this._v1x;

        },

        set: function (value) {

            if (value !== this._v1x)
            {
                this._v1x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v1y
    * @property {number} v1y - The y component of the tangent vector for the start of the curve. Setting this value will recalculate the curve.
    */
    v1y: {

        enumerable: true,

        get: function () {

            return this._v1y;

        },

        set: function (value) {

            if (value !== this._v1y)
            {
                this._v1y = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v2x
    * @property {number} v2x - The x component of the tangent vector for the end of the curve. Setting this value will recalculate the curve.
    */
    v2x: {

        enumerable: true,

        get: function () {

            return this._v2x;

        },

        set: function (value) {

            if (value !== this._v2x)
            {
                this._v2x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v2y
    * @property {number} v2y - The y component of the tangent vector for the end of the curve. Setting this value will recalculate the curve.
    */
    v2y: {

        enumerable: true,

        get: function () {

            return this._v2y;

        },

        set: function (value) {

            if (value !== this._v2y)
            {
                this._v2y = value;
                this.recalculate();
            }

        }

    }

});

module.exports = Hermite;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Hermite

var Hermite = __webpack_require__(143);

Hermite.FindT = __webpack_require__(24);
Hermite.GetAngle = __webpack_require__(44);
Hermite.GetAngleWithDistance = __webpack_require__(138);
Hermite.GetEntryTangent = __webpack_require__(139);
Hermite.GetPoint = __webpack_require__(25);
Hermite.GetPointWithDistance = __webpack_require__(140);
Hermite.GetX = __webpack_require__(141);
Hermite.GetY = __webpack_require__(142);

module.exports = Hermite;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

var DistanceBetween = __webpack_require__(65);

var CircleToCircle = function (circleA, circleB)
{
    return (DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= (circleA.radius + circleB.radius));
};

module.exports = CircleToCircle;


/***/ },
/* 146 */
/***/ function(module, exports) {

var CircleToRectangle = function (circle, rect)
{
    var halfWidth = rect.width / 2;
    var halfHeight = rect.height / 2;

    var cx = Math.abs(circle.x - rect.x - halfWidth);
    var xDist = halfWidth + circle.radius;

    if (cx <= halfWidth || cx > xDist)
    {
        return false;
    }

    var cy = Math.abs(circle.y - rect.y - halfHeight);
    var yDist = halfHeight + circle.radius;

    if (cy <= halfHeight || cy > yDist)
    {
        return false;
    }

    var xCornerDist = cx - halfWidth;
    var yCornerDist = cy - halfHeight;
    var xCornerDistSq = xCornerDist * xCornerDist;
    var yCornerDistSq = yCornerDist * yCornerDist;
    var maxCornerDistSq = circle.radius * circle.radius;

    return (xCornerDistSq + yCornerDistSq <= maxCornerDistSq);
};

module.exports = CircleToRectangle;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);
var RectangleToRectangle = __webpack_require__(46);

var GetRectangleIntersection = function (rectA, rectB, output)
{
    if (output === undefined) { output = new Rectangle(); }

    if (RectangleToRectangle(rectA, rectB))
    {
        output.x = Math.max(rectA.x, rectB.x);
        output.y = Math.max(rectA.y, rectB.y);
        output.width = Math.min(rectA.right, rectB.right) - output.x;
        output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
    }

    return output;
};

module.exports = GetRectangleIntersection;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var LineToLine = function (line1, line2, asSegment, out)
{
    if (asSegment === undefined) { asSegment = true; }
    if (out === undefined) { out = new Point(); }

    var a = line1.x1;
    var b = line1.y1;

    var e = line1.x2;
    var f = line1.y2;

    var a1 = b.y - a.y;
    var a2 = f.y - e.y;
    var b1 = a.x - b.x;
    var b2 = e.x - f.x;
    var c1 = (b.x * a.y) - (a.x * b.y);
    var c2 = (f.x * e.y) - (e.x * f.y);
    var denom = (a1 * b2) - (a2 * b1);

    if (denom === 0)
    {
        return null;
    }

    out.x = ((b1 * c2) - (b2 * c1)) / denom;
    out.y = ((a2 * c1) - (a1 * c2)) / denom;

    if (asSegment)
    {
        var uc = ((f.y - e.y) * (b.x - a.x) - (f.x - e.x) * (b.y - a.y));
        var ua = (((f.x - e.x) * (a.y - e.y)) - (f.y - e.y) * (a.x - e.x)) / uc;
        var ub = (((b.x - a.x) * (a.y - e.y)) - ((b.y - a.y) * (a.x - e.x))) / uc;

        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)
        {
            return out;
        }
        else
        {
            return null;
        }
    }

    return out;
};

module.exports = LineToLine;


/***/ },
/* 149 */
/***/ function(module, exports) {

/**
* Checks for intersection between the Line and a Rectangle shape, or a rectangle-like
* object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.
*
* An intersection is considered valid if:
*
* The line starts within, or ends within, the Rectangle.
* The line segment intersects one of the 4 rectangle edges.
*
* The for the purposes of this function rectangles are considered 'solid'.
*
* @method Phaser.Line.intersectsRectangle
* @param {Phaser.Line} line - The line to check for intersection with.
* @param {Phaser.Rectangle|object} rect - The rectangle, or rectangle-like object, to check for intersection with.
* @return {boolean} True if the line intersects with the rectangle edges, or starts or ends within the rectangle.
*/
var LineToRectangle = function (line, rect)
{
    var x1 = line.x1;
    var y1 = line.y2;

    var x2 = line.x2;
    var y2 = line.y2;

    var bx1 = rect.x;
    var by1 = rect.y;
    var bx2 = rect.right;
    var by2 = rect.bottom;

    var t = 0;

    //  If the start or end of the line is inside the rect then we assume
    //  collision, as rects are solid for our use-case.

    if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) ||
        (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2))
    {
        return true;
    }

    if (x1 < bx1 && x2 >= bx1)
    {
        //  Left edge
        t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);

        if (t > by1 && t <= by2)
        {
            return true;
        }
    }
    else if (x1 > bx2 && x2 <= bx2)
    {
        //  Right edge
        t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);

        if (t >= by1 && t <= by2)
        {
            return true;
        }
    }

    if (y1 < by1 && y2 >= by1)
    {
        //  Top edge
        t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }
    else if (y1 > by2 && y2 <= by2)
    {
        //  Bottom edge
        t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }

    return false;
};

module.exports = LineToRectangle;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

var PointToLine = __webpack_require__(45);

var PointToLineSegment = function (point, line)
{
    if (!PointToLine(point, line))
    {
        return false;
    }

    var xMin = Math.min(line.x1, line.x2);
    var xMax = Math.max(line.x1, line.x2);
    var yMin = Math.min(line.y1, line.y2);
    var yMax = Math.max(line.y1, line.y2);

    return ((point.x >= xMin && point.x <= xMax) && (point.y >= yMin && point.y <= yMax));
};

module.exports = PointToLineSegment;


/***/ },
/* 151 */
/***/ function(module, exports) {

var RectangleToValues = function (rect, left, right, top, bottom, tolerance)
{
    if (tolerance === undefined) { tolerance = 0; }

    return !(
        left > rect.right + tolerance ||
        right < rect.left - tolerance ||
        top > rect.bottom + tolerance ||
        bottom < rect.top - tolerance
    );
};

module.exports = RectangleToValues;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {


module.exports = {

    CircleToCircle: __webpack_require__(145),
    CircleToRectangle: __webpack_require__(146),
    GetRectangleIntersection: __webpack_require__(147),
    LineToLine: __webpack_require__(148),
    LineToRectangle: __webpack_require__(149),
    PointToLine: __webpack_require__(45),
    PointToLineSegment: __webpack_require__(150),
    RectangleToRectangle: __webpack_require__(46),
    RectangleToValues: __webpack_require__(151)

};


/***/ },
/* 153 */
/***/ function(module, exports) {


var CenterOn = function (line, x, y)
{
    var tx = x - ((line.x1 + line.x2) / 2);
    var ty = y - ((line.y1 + line.y2) / 2);

    line.x1 += tx;
    line.y1 += ty;

    line.x2 += tx;
    line.y2 += ty;

    return line;
};

module.exports = CenterOn;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

var Line = __webpack_require__(47);

var Clone = function (source)
{
    return new Line(source.x1, source.y1, source.x2, source.y2);
};

module.exports = Clone;


/***/ },
/* 155 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x1, source.y1, source.x2, source.y2);
};

module.exports = CopyFrom;


/***/ },
/* 156 */
/***/ function(module, exports) {

var Equals = function (line, toCompare)
{
    return (
        line.x1 === toCompare.x1 &&
        line.y1 === toCompare.y1 &&
        line.x2 === toCompare.x2 &&
        line.y2 === toCompare.y2
    );
};

module.exports = Equals;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var GetMidPoint = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = (line.x1 + line.x2) / 2;
    out.y = (line.y1 + line.y2) / 2;

    return out;
};

module.exports = GetMidPoint;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Angle = __webpack_require__(6);
var Point = __webpack_require__(0);

var GetNormal = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var a = Angle(line) - MATH_CONST.TAU;

    out.x = Math.cos(a);
    out.y = Math.sin(a);

    return out;
};

module.exports = GetNormal;


/***/ },
/* 159 */
/***/ function(module, exports) {

/**
* Using Bresenham's line algorithm this will return an array of all coordinates on this line.
* The start and end points are rounded before this runs as the algorithm works on integers.
*
* @method Phaser.Line#coordinatesOnLine
* @param {number} [stepRate=1] - How many steps will we return? 1 = every coordinate on the line, 2 = every other coordinate, etc.
* @param {array} [results] - The array to store the results in. If not provided a new one will be generated.
* @return {array} An array of coordinates.
*/
var GetPointsOnLine = function (line, stepRate, results)
{
    if (stepRate === undefined) { stepRate = 1; }
    if (results === undefined) { results = []; }

    var x1 = Math.round(line.x1);
    var y1 = Math.round(line.y1);
    var x2 = Math.round(line.x2);
    var y2 = Math.round(line.y2);

    var dx = Math.abs(x2 - x1);
    var dy = Math.abs(y2 - y1);
    var sx = (x1 < x2) ? 1 : -1;
    var sy = (y1 < y2) ? 1 : -1;
    var err = dx - dy;

    results.push([ x1, y1 ]);

    var i = 1;

    while (!((x1 === x2) && (y1 === y2)))
    {
        var e2 = err << 1;

        if (e2 > -dy)
        {
            err -= dy;
            x1 += sx;
        }

        if (e2 < dx)
        {
            err += dx;
            y1 += sy;
        }

        if (i % stepRate === 0)
        {
            results.push([ x1, y1 ]);
        }

        i++;
    }

    return results;
};

module.exports = GetPointsOnLine;


/***/ },
/* 160 */
/***/ function(module, exports) {

var Height = function (line)
{
    return Math.abs(line.y1 - line.y2);
};

module.exports = Height;


/***/ },
/* 161 */
/***/ function(module, exports) {

var Length = function (line)
{
    return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
};

module.exports = Length;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Angle = __webpack_require__(6);

var NormalX = function (line)
{
    return Math.cos(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalX;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Angle = __webpack_require__(6);

var NormalY = function (line)
{
    return Math.sin(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalY;


/***/ },
/* 164 */
/***/ function(module, exports) {

var PerpSlope = function (line)
{
    return -((line.x2 - line.x1) / (line.y2 - line.y1));
};

module.exports = PerpSlope;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Random = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var t = Math.random();

    out.x = line.x1 + t * (line.x2 - line.x1);
    out.y = line.y1 + t * (line.y2 - line.y1);

    return out;
};

module.exports = Random;


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

var Angle = __webpack_require__(6);
var NormalAngle = __webpack_require__(48);

/**
* Returns the reflected angle between two lines.
* This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.
*
* @method Phaser.Line.reflect
* @param {Phaser.Line} a - The base line.
* @param {Phaser.Line} b - The line to be reflected from the base line.
* @return {number} The reflected angle in radians.
*/
var ReflectAngle = function (lineA, lineB)
{
    return (2 * NormalAngle(lineB) - Math.PI - Angle(lineA));
};

module.exports = ReflectAngle;


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(26);

var Rotate = function (line, angle)
{
    var x = (line.x1 + line.x2) / 2;
    var y = (line.y1 + line.y2) / 2;

    return RotateAroundXY(line, x, y, angle);
};

module.exports = Rotate;


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(26);

var RotateAroundPoint = function (line, point, angle)
{
    return RotateAroundXY(line, point.x, point.y, angle);
};

module.exports = RotateAroundPoint;


/***/ },
/* 169 */
/***/ function(module, exports) {

var SetToAngle = function (line, x, y, angle, length)
{
    line.x1 = x;
    line.y1 = y;

    line.x2 = x + (Math.cos(angle) * length);
    line.y2 = y + (Math.sin(angle) * length);

    return line;
};

module.exports = SetToAngle;


/***/ },
/* 170 */
/***/ function(module, exports) {

var Slope = function (line)
{
    return (line.y2 - line.y1) / (line.x2 - line.x1);
};

module.exports = Slope;


/***/ },
/* 171 */
/***/ function(module, exports) {

var Width = function (line)
{
    return Math.abs(line.x1 - line.x2);
};

module.exports = Width;


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Line

var Line = __webpack_require__(47);

Line.Angle = __webpack_require__(6);
Line.CenterOn = __webpack_require__(153);
Line.Clone = __webpack_require__(154);
Line.CopyFrom = __webpack_require__(155);
Line.Equals = __webpack_require__(156);
Line.GetMidPoint = __webpack_require__(157);
Line.GetNormal = __webpack_require__(158);
Line.GetPointsOnLine = __webpack_require__(159);
Line.Height = __webpack_require__(160);
Line.Length = __webpack_require__(161);
Line.NormalAngle = __webpack_require__(48);
Line.NormalX = __webpack_require__(162);
Line.NormalY = __webpack_require__(163);
Line.PerpSlope = __webpack_require__(164);
Line.Random = __webpack_require__(165);
Line.ReflectAngle = __webpack_require__(166);
Line.Rotate = __webpack_require__(167);
Line.RotateAroundPoint = __webpack_require__(168);
Line.RotateAroundXY = __webpack_require__(26);
Line.SetToAngle = __webpack_require__(169);
Line.Slope = __webpack_require__(170);
Line.Width = __webpack_require__(171);

module.exports = Line;


/***/ },
/* 173 */
/***/ function(module, exports) {

var Add = function (point, x, y)
{
    point.x += x;
    point.y += y;

    return point;
};

module.exports = Add;


/***/ },
/* 174 */
/***/ function(module, exports) {

var Ceil = function (point)
{
    return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
};

module.exports = Ceil;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Clone = function (source)
{
    return new Point(source.x, source.y);
};

module.exports = Clone;


/***/ },
/* 176 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y);
};

module.exports = CopyFrom;


/***/ },
/* 177 */
/***/ function(module, exports) {

var Cross = function (pointA, pointB)
{
    return ((pointA.x * pointB.y) - (pointA.y * pointB.x));
};

module.exports = Cross;


/***/ },
/* 178 */
/***/ function(module, exports) {

var Divide = function (point, x, y)
{
    point.x /= x;
    point.y /= y;

    return point;
};

module.exports = Divide;


/***/ },
/* 179 */
/***/ function(module, exports) {

var Equals = function (point, toCompare)
{
    return (point.x === toCompare.x && point.y === toCompare.y);
};

module.exports = Equals;


/***/ },
/* 180 */
/***/ function(module, exports) {

var Floor = function (point)
{
    return point.setTo(Math.floor(point.x), Math.floor(point.y));
};

module.exports = Floor;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var GetCentroid = function (points, out)
{
    if (out === undefined) { out = new Point(); }

    if (!Array.isArray(points))
    {
        throw new Error('GetCentroid points argument must be an array');
    }

    var len = points.length;

    if (len < 1)
    {
        throw new Error('GetCentroid points array must not be empty');
    }
    else if (len === 1)
    {
        out.x = points[0].x;
        out.y = points[0].y;
    }
    else
    {
        for (var i = 0; i < len; i++)
        {
            out.x += points[i].x;
            out.y += points[i].y;
        }

        out.x /= len;
        out.y /= len;
    }

    return out;
};

module.exports = GetCentroid;


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Interpolate = function (pointA, pointB, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    out.x = pointA.x + ((pointB.x - pointA.x) * t);
    out.y = pointA.y + ((pointB.y - pointA.y) * t);

    return out;
};

module.exports = Interpolate;


/***/ },
/* 183 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var Invert = function (point)
{
    return point.setTo(point.y, point.x);
};

module.exports = Invert;


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Negative = function (point, out)
{
    if (out === undefined) { out = new Point(); }

    return out.setTo(-point.x, -point.y);
};

module.exports = Negative;


/***/ },
/* 185 */
/***/ function(module, exports) {

var NormalizeRightHand = function (point)
{
    return point.setTo(point.y * -1, point.x);
};

module.exports = NormalizeRightHand;


/***/ },
/* 186 */
/***/ function(module, exports) {

var Perp = function (point)
{
    return point.setTo(-point.y, point.x);
};

module.exports = Perp;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(27);
var Point = __webpack_require__(0);
var GetMagnitudeSq = __webpack_require__(50);

var Project = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB) / GetMagnitudeSq(pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = Project;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(27);
var Point = __webpack_require__(0);

var ProjectUnit = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = ProjectUnit;


/***/ },
/* 189 */
/***/ function(module, exports) {

var RPerp = function (point)
{
    return point.setTo(point.y, -point.x);
};

module.exports = RPerp;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(52);
var Multiply = __webpack_require__(51);

var SetMagnitude = function (point, magnitude)
{
    Normalize(point);

    return Multiply(point, magnitude, magnitude);
};

module.exports = SetMagnitude;


/***/ },
/* 191 */
/***/ function(module, exports) {

var Subtract = function (point, x, y)
{
    point.x -= x;
    point.y -= y;

    return point;
};

module.exports = Subtract;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Point

var Point = __webpack_require__(0);

Point.Add = __webpack_require__(173);
Point.Ceil = __webpack_require__(174);
Point.Clone = __webpack_require__(175);
Point.CopyFrom = __webpack_require__(176);
Point.Cross = __webpack_require__(177);
Point.Divide = __webpack_require__(178);
Point.Dot = __webpack_require__(27);
Point.Equals = __webpack_require__(179);
Point.Floor = __webpack_require__(180);
Point.GetCentroid = __webpack_require__(181);
Point.GetMagnitude = __webpack_require__(49);
Point.GetMagnitudeSq = __webpack_require__(50);
Point.Interpolate = __webpack_require__(182);
Point.Invert = __webpack_require__(183);
Point.Multiply = __webpack_require__(51);
Point.Negative = __webpack_require__(184);
Point.Normalize = __webpack_require__(52);
Point.NormalizeRightHand = __webpack_require__(185);
Point.Perp = __webpack_require__(186);
Point.Project = __webpack_require__(187);
Point.ProjectUnit = __webpack_require__(188);
Point.RPerp = __webpack_require__(189);
Point.SetMagnitude = __webpack_require__(190);
Point.Subtract = __webpack_require__(191);

module.exports = Point;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

var Polygon = __webpack_require__(54);

var Clone = function (polygon)
{
    return new Polygon(polygon.points);
};

module.exports = Clone;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(53);

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var ContainsPoint = function (polygon, point)
{
    return Contains(polygon, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 195 */
/***/ function(module, exports) {


var GetAABB = function (polygon)
{
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -minX;
    var maxY = -minY;
    var p;

    for (var i = 0; i < polygon.points.length; i++)
    {
        p = polygon.points[i];

        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
    }

    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
};

module.exports = GetAABB;


/***/ },
/* 196 */
/***/ function(module, exports) {

/**
 * Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]
 *
 * @method Phaser.Polygon#toNumberArray
 * @param {array} [output] - The array to append the points to. If not specified a new array will be created.
 * @return {array} The flattened array.
 */
var GetNumberArray = function (polygon, output)
{
    if (output === undefined) { output = []; }

    for (var i = 0; i < polygon.points.length; i++)
    {
        output.push(polygon.points[i].x);
        output.push(polygon.points[i].y);
    }

    return output;
};

module.exports = GetNumberArray;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Polygon

var Polygon = __webpack_require__(54);

Polygon.Clone = __webpack_require__(193);
Polygon.Contains = __webpack_require__(53);
Polygon.ContainsPoint = __webpack_require__(194);
Polygon.GetAABB = __webpack_require__(195);
Polygon.GetNumberArray = __webpack_require__(196);

module.exports = Polygon;


/***/ },
/* 198 */
/***/ function(module, exports) {

var Area = function (rect)
{
    return rect.width * rect.height;
};

module.exports = Area;


/***/ },
/* 199 */
/***/ function(module, exports) {

var Ceil = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);

    return rect;
};

module.exports = Ceil;


/***/ },
/* 200 */
/***/ function(module, exports) {

var CeilAll = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);
    rect.width = Math.ceil(rect.width);
    rect.height = Math.ceil(rect.height);

    return rect;
};

module.exports = CeilAll;


/***/ },
/* 201 */
/***/ function(module, exports) {

/**
* Centers this Rectangle so that the center coordinates match the given x and y values.
*
* @method Phaser.Rectangle#centerOn
* @param {number} x - The x coordinate to place the center of the Rectangle at.
* @param {number} y - The y coordinate to place the center of the Rectangle at.
* @return {Phaser.Rectangle} This Rectangle object
*/
var CenterOn = function (rect, x, y)
{
    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = CenterOn;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var Clone = function (source)
{
    return new Rectangle(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(55);

var ContainsPoint = function (rect, point)
{
    return Contains(rect, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 204 */
/***/ function(module, exports) {

//  Checks if rectB is fully contained within rectA

var ContainsRect = function (rectA, rectB)
{
    //  Volume check (if rectB volume > rectA then rectA cannot contain it)
    if ((rectB.width * rectB.height) > (rectA.width * rectA.height))
    {
        return false;
    }

    return
        (
            (rectB.x > rectA.x && rectB.x < rectA.right) && 
            (rectB.right > rectA.x && rectB.right < rectA.right)
        ) && (
            (rectB.y > rectA.y && rectB.y < rectA.bottom) && 
            (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom)
        );
    
};

module.exports = ContainsRect;


/***/ },
/* 205 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ },
/* 206 */
/***/ function(module, exports) {

var Equals = function (rect, toCompare)
{
    return (
        rect.x === toCompare.x &&
        rect.y === toCompare.y &&
        rect.width === toCompare.width &&
        rect.height === toCompare.height
    );
};

module.exports = Equals;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(28);

//  Fits the target rectangle into the source rectangle.
//  Preserves aspect ratio.
//  Scales and centers the target rectangle to the source rectangle

var FitInside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio < GetAspectRatio(source))
    {
        //  Taller than Wide
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Wider than Tall
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - (target.width / 2),
        (source.bottom / 2) - (target.height / 2)
    );
};

module.exports = FitInside;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(28);

//  Fits the target rectangle around the source rectangle.
//  Preserves aspect ration.
//  Scales and centers the target rectangle to the source rectangle

var FitOutside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio > GetAspectRatio(source))
    {
        //  Wider than Tall
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Taller than Wide
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - target.width / 2,
        (source.bottom / 2) - target.height / 2
    );
};

module.exports = FitOutside;


/***/ },
/* 209 */
/***/ function(module, exports) {

var Floor = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);

    return rect;
};

module.exports = Floor;


/***/ },
/* 210 */
/***/ function(module, exports) {

var FloorAll = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);
    rect.width = Math.floor(rect.width);
    rect.height = Math.floor(rect.height);

    return rect;
};

module.exports = FloorAll;


/***/ },
/* 211 */
/***/ function(module, exports) {

//  The center of the Rectangle object, expressed as a Point object 

var GetCenter = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.right / 2;
    out.y = rect.bottom / 2;

    return out;
};

module.exports = GetCenter;


/***/ },
/* 212 */
/***/ function(module, exports) {

//  The size of the Rectangle object, expressed as a Point object 
//  with the values of the width and height properties.

var GetSize = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.width;
    out.y = rect.height;

    return out;
};

module.exports = GetSize;


/***/ },
/* 213 */
/***/ function(module, exports) {

//  Increases the size of the Rectangle object by the specified amounts.
//  The center point of the Rectangle object stays the same, and its size increases 
//  to the left and right by the x value, and to the top and the bottom by the y value.

var Inflate = function (rect, x, y)
{
    //  Get the current center
    var cx = rect.x + (rect.width / 2);
    var cy = rect.y + (rect.height / 2);

    //  Inflate
    rect.width = 2 * x;
    rect.height = 2 * y;

    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = Inflate;


/***/ },
/* 214 */
/***/ function(module, exports) {

//  Merges the target Rectangle with a list of points.
//  The points is an array of objects with public x/y properties.

var MergePoints = function (target, points)
{
    var minX = target.x;
    var maxX = target.right;
    var minY = target.y;
    var maxY = target.bottom;

    for (var i = 0; i < points.length; i++)
    {
        minX = Math.min(minX, points[i].x);
        maxX = Math.max(maxX, points[i].x);
        minY = Math.min(minY, points[i].y);
        maxY = Math.max(maxY, points[i].y);
    }

    target.x = minX;
    target.y = minY;
    target.width = maxX - minX;
    target.height = maxY - minY;

    return target;
};

module.exports = MergePoints;


/***/ },
/* 215 */
/***/ function(module, exports) {

//  Merges source rectangle into target rectangle and returns target
//  Neither rect should have negative widths or heights

var MergeRect = function (target, source)
{
    var minX = Math.min(target.x, source.x);
    var maxX = Math.max(target.right, source.right);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, source.y);
    var maxY = Math.max(target.bottom, source.bottom);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeRect;


/***/ },
/* 216 */
/***/ function(module, exports) {


var MergeXY = function (target, x, y)
{
    var minX = Math.min(target.x, x);
    var maxX = Math.max(target.right, x);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, y);
    var maxY = Math.max(target.bottom, y);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeXY;


/***/ },
/* 217 */
/***/ function(module, exports) {

var Offset = function (rect, x, y)
{
    rect.x += x;
    rect.y += y;

    return rect;
};

module.exports = Offset;


/***/ },
/* 218 */
/***/ function(module, exports) {

var OffsetPoint = function (rect, point)
{
    rect.x += point.x;
    rect.y += point.y;

    return rect;
};

module.exports = OffsetPoint;


/***/ },
/* 219 */
/***/ function(module, exports) {

var Overlaps = function (rectA, rectB)
{
    return (
        rectA.x < rectB.right && 
        rectA.right > rectB.x && 
        rectA.y < rectB.bottom && 
        rectA.bottom > rectB.y
    );
};

module.exports = Overlaps;


/***/ },
/* 220 */
/***/ function(module, exports) {

var Perimeter = function (rect)
{
    return 2 * (rect.width + rect.height);
};

module.exports = Perimeter;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Random = function (rect, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = rect.x + (Math.random() * rect.width);
    out.y = rect.y + (Math.random() * rect.height);

    return out;
};

module.exports = Random;


/***/ },
/* 222 */
/***/ function(module, exports) {

/**
* Scales the width and height of this Rectangle by the given amounts.
* 
* @method Phaser.Rectangle#scale
* @param {number} x - The amount to scale the width of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the width, etc.
* @param {number} [y] - The amount to scale the height of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the height, etc.
* @return {Phaser.Rectangle} This Rectangle object
*/
var Scale = function (rect, x, y)
{
    if (y === undefined) { y = x; }

    rect.width *= x;
    rect.height *= y;

    return rect;
};

module.exports = Scale;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var Union = function (rectA, rectB, output)
{
    if (output === undefined) { output = Rectangle(); }

    var x = Math.min(rectA.x, rectB.x);
    var y = Math.min(rectA.y, rectB.y);

    return output.set(
        x,
        y,
        Math.max(rectA.right, rectB.right) - x,
        Math.max(rectA.bottom, rectB.bottom) - y
    );
    
};

module.exports = Union;


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Rectangle

var Rectangle = __webpack_require__(7);

Rectangle.Area = __webpack_require__(198);
Rectangle.Ceil = __webpack_require__(199);
Rectangle.CeilAll = __webpack_require__(200);
Rectangle.CenterOn = __webpack_require__(201);
Rectangle.Clone = __webpack_require__(202);
Rectangle.Contains = __webpack_require__(55);
Rectangle.ContainsPoint = __webpack_require__(203);
Rectangle.ContainsRect = __webpack_require__(204);
Rectangle.CopyFrom = __webpack_require__(205);
Rectangle.Equals = __webpack_require__(206);
Rectangle.FitInside = __webpack_require__(207);
Rectangle.FitOutside = __webpack_require__(208);
Rectangle.Floor = __webpack_require__(209);
Rectangle.FloorAll = __webpack_require__(210);
Rectangle.GetAspectRatio = __webpack_require__(28);
Rectangle.GetCenter = __webpack_require__(211);
Rectangle.GetSize = __webpack_require__(212);
Rectangle.Inflate = __webpack_require__(213);
Rectangle.MergePoints = __webpack_require__(214);
Rectangle.MergeRect = __webpack_require__(215);
Rectangle.MergeXY = __webpack_require__(216);
Rectangle.Offset = __webpack_require__(217);
Rectangle.OffsetPoint = __webpack_require__(218);
Rectangle.Overlaps = __webpack_require__(219);
Rectangle.Perimeter = __webpack_require__(220);
Rectangle.Random = __webpack_require__(221);
Rectangle.Scale = __webpack_require__(222);
Rectangle.Union = __webpack_require__(223);

module.exports = Rectangle;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var Set = __webpack_require__(330);
var XHRSettings = __webpack_require__(29);
var Event = __webpack_require__(230);
var EventDispatcher = __webpack_require__(15);

var BaseLoader = function ()
{
    //  To finish the loader ...
    //  
    //  3) Progress update
    //  4) JSON loader
    //  5) XML Loader
    //  6) Multi File support (atlas + data)
    //  7) Atlas Loader

    this.events = new EventDispatcher();

    //  Move to a 'setURL' method?
    this.baseURL = '';
    this.path = '';

    //  Read from Game / State Config
    this.enableParallel = true;
    this.maxParallelDownloads = 4;

    //  xhr specific global settings (can be overridden on a per-file basis)
    this.xhr = XHRSettings();

    this.crossOrigin = undefined;

    this.list = new Set();
    this.inflight = new Set();
    this.failed = new Set();
    this.queue = new Set();
    this.storage = new Set();

    this._state = CONST.LOADER_IDLE;
};

BaseLoader.prototype.contructor = BaseLoader;

BaseLoader.prototype = {

    addFile: function (file)
    {
        if (!this.isReady())
        {
            return -1;
        }

        file.path = this.path;

        this.list.set(file);

        return this;
    },

    //  Is the Loader actively loading (or processing loaded files)
    isLoading: function ()
    {
        return (this._state === CONST.LOADER_LOADING || this._state === CONST.LOADER_PROCESSING);
    },

    //  Is the Loader ready to start a new load?
    isReady: function ()
    {
        return (this._state === CONST.LOADER_IDLE || this._state === CONST.LOADER_COMPLETE || this._state === CONST.LOADER_FAILED);
    },

    start: function ()
    {
        console.log('BaseLoader start. Files to load:', this.list.size);

        if (!this.isReady())
        {
            return;
        }

        this.events.dispatch(new Event.LOADER_START_EVENT(this));

        if (this.list.size === 0)
        {
            this.finishedLoading();
        }
        else
        {
            this._state = CONST.LOADER_LOADING;

            this.failed.clear();
            this.inflight.clear();
            this.queue.clear();

            this.queue.debug = true;

            this.updateProgress();

            this.processLoadQueue();
        }
    },

    updateProgress: function ()
    {

    },

    processLoadQueue: function ()
    {
        // console.log('======== BaseLoader processLoadQueue');
        // console.log('List size', this.list.size);
        // console.log(this.inflight.size, 'items still in flight. Can load another', (this.maxParallelDownloads - this.inflight.size));

        var _this = this;

        this.list.each(function (file)
        {
            if (file.state === CONST.FILE_PENDING && _this.inflight.size < _this.maxParallelDownloads)
            {
                _this.inflight.set(file);

                _this.list.delete(file);

                _this.loadFile(file);
            }

            if (_this.inflight.size === _this.maxParallelDownloads)
            {
                //  Tells the Set iterator to abort
                return false;
            }

        });
    },

    //  private
    loadFile: function (file)
    {
        // console.log('LOADING', file.key);

        //  If the file doesn't have its own crossOrigin set,
        //  we'll use the Loaders (which is undefined by default)
        if (!file.crossOrigin)
        {
            file.crossOrigin = this.crossOrigin;
        }

        file.load(this.nextFile.bind(this), this.baseURL);
    },

    nextFile: function (previousFile, success)
    {
        // console.log('LOADED:', previousFile.src, success);

        //  Move the file that just loaded from the inflight list to the queue or failed Set

        if (success)
        {
            this.queue.set(previousFile);
        }
        else
        {
            this.failed.set(previousFile);
        }

        this.inflight.delete(previousFile);

        if (this.list.size > 0)
        {
            // console.log('nextFile - still something in the list');
            this.processLoadQueue();
        }
        else if (this.inflight.size === 0)
        {
            // console.log('nextFile calling finishedLoading');
            this.finishedLoading();
        }
    },

    finishedLoading: function ()
    {
        // console.log('---> BaseLoader.finishedLoading PROCESSING', this.queue.size, 'files');

        this._state = CONST.LOADER_PROCESSING;

        this.storage.clear();

        var _this = this;

        this.queue.each(function (file)
        {
            // console.log('%c Calling process on ' + file.key, 'color: #000000; background: #ffff00;');

            file.onProcess(_this.processUpdate.bind(_this));
        });
    },

    //  Called automatically by the File when it has finished processing
    processUpdate: function (file)
    {
        // console.log('-> processUpdate', file.key, file.state);

        //  This file has failed to load, so move it to the failed Set
        if (file.state === CONST.FILE_ERRORED)
        {
            this.failed.set(file);

            if (file.linkFile)
            {
                this.queue.delete(file.linkFile);
            }

            return this.removeFromQueue(file);
        }

        //  If we got here, then the file loaded

        //  Special handling for multi-part files

        if (file.linkFile)
        {
            if (file.state === CONST.FILE_COMPLETE && file.linkFile.state === CONST.FILE_COMPLETE)
            {
                //  Partner has loaded, so add them both to Storage

                this.storage.set({ type: file.linkType, fileA: file, fileB: file.linkFile });

                this.queue.delete(file.linkFile);

                this.removeFromQueue(file);
            }
        }
        else
        {
            this.storage.set(file);

            this.removeFromQueue(file);
        }
    },

    removeFromQueue: function (file)
    {
        this.queue.delete(file);

        if (this.queue.size === 0 && this._state === CONST.LOADER_PROCESSING)
        {
            //  We've processed all the files we loaded
            this.processComplete();
        }
    },

    processComplete: function ()
    {
        console.log('Loader Complete. Loaded:', this.storage.size, 'Failed:', this.failed.size);

        this.list.clear();
        this.inflight.clear();
        this.queue.clear();

        if (this.processCallback)
        {
            this.processCallback();
        }

        this._state = CONST.LOADER_COMPLETE;

        this.events.dispatch(new Event.LOADER_COMPLETE_EVENT(this));
    },

    reset: function ()
    {
        this.list.clear();
        this.inflight.clear();
        this.failed.clear();
        this.queue.clear();
        this.storage.clear();

        this.tag = '';
        this.path = '';
        this.baseURL = '';

        this._state = CONST.LOADER_IDLE;
    },

    destroy: function ()
    {
        this.reset();
        this._state = CONST.LOADER_DESTROYED;
    }

};

module.exports = BaseLoader;


/***/ },
/* 226 */
/***/ function(module, exports) {

var GetURL = function (file, baseURL)
{
    if (!file.url)
    {
        return false;
    }

    if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/))
    {
        return file.url;
    }
    else
    {
        return baseURL + file.url;
    }
};

module.exports = GetURL;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

var MergeXHRSettings = __webpack_require__(56);

var XHRLoader = function (file, globalXHRSettings)
{
    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);

    var xhr = new XMLHttpRequest();

    xhr.open('GET', file.src, config.async, config.user, config.password);

    xhr.responseType = file.xhrSettings.responseType;
    xhr.timeout = config.timeout;

    if (config.header && config.headerValue)
    {
        xhr.setRequestHeader(config.header, config.headerValue);
    }

    if (config.overrideMimeType)
    {
        xhr.overrideMimeType(config.overrideMimeType);
    }

    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)

    xhr.onload = file.onLoad.bind(file);
    xhr.onerror = file.onError.bind(file);
    xhr.onprogress = file.onProgress.bind(file);

    //  This is the only standard method, the ones above are browser additions (maybe not universal?)
    // xhr.onreadystatechange

    xhr.send();

    return xhr;
};

module.exports = XHRLoader;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(14);

var LoaderCompleteEvent = function (loader)
{
    Event.call(this, 'LOADER_COMPLETE_EVENT');

    this.loader = loader;
};

LoaderCompleteEvent.prototype = Object.create(Event.prototype);
LoaderCompleteEvent.prototype.constructor = LoaderCompleteEvent;

module.exports = LoaderCompleteEvent;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(14);

var LoaderStartEvent = function (loader)
{
    Event.call(this, 'LOADER_START_EVENT');

    this.loader = loader;
};

LoaderStartEvent.prototype = Object.create(Event.prototype);
LoaderStartEvent.prototype.constructor = LoaderStartEvent;

module.exports = LoaderStartEvent;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    LOADER_START_EVENT: __webpack_require__(229),
    LOADER_COMPLETE_EVENT: __webpack_require__(228)

};


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(16);
var JSONFile = __webpack_require__(57);

var AtlasJSONFile = function (key, textureURL, atlasURL, path, textureXhrSettings, atlasXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new JSONFile(key, atlasURL, path, atlasXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'atlasjson';
    data.linkType = 'atlasjson';

    return { texture: image, data: data };
};

module.exports = AtlasJSONFile;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var BinaryFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.binary\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.bin';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'binary', key, url, 'arraybuffer', xhrSettings);
};

BinaryFile.prototype = Object.create(File.prototype);
BinaryFile.prototype.constructor = BinaryFile;

BinaryFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.response;

    this.onComplete();

    callback(this);
};

module.exports = BinaryFile;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var GLSLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.glsl';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'glsl', key, url, 'text', xhrSettings);
};

GLSLFile.prototype = Object.create(File.prototype);
GLSLFile.prototype.constructor = GLSLFile;

GLSLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = GLSLFile;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var TextFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.text';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'text', key, url, 'text', xhrSettings);
};

TextFile.prototype = Object.create(File.prototype);
TextFile.prototype.constructor = TextFile;

TextFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = TextFile;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);
var ParseXML = __webpack_require__(102);

var XMLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.xml\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.xml';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'xml', key, url, 'text', xhrSettings);
};

XMLFile.prototype = Object.create(File.prototype);
XMLFile.prototype.constructor = XMLFile;

XMLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = ParseXML(this.xhrLoader.responseText);

    if (this.data === null)
    {
        throw new Error('XMLFile: Invalid XML');
    }

    this.onComplete();

    callback(this);
};

module.exports = XMLFile;


/***/ },
/* 236 */
/***/ function(module, exports) {

var Average = function (values)
{
    var sum = 0;

    for (var i = 0; i < values.length; i++)
    {
        sum += (+values[i]);
    }

    return sum / values.length;
};

module.exports = Average;


/***/ },
/* 237 */
/***/ function(module, exports) {

var CeilTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.ceil(value * p) / p;
};

module.exports = CeilTo;


/***/ },
/* 238 */
/***/ function(module, exports) {

/**
* Force a value within the boundaries by clamping it to the range `min`, `max`.
*
* @method Phaser.Math#clamp
* @param {float} v - The value to be clamped.
* @param {float} min - The minimum bounds.
* @param {float} max - The maximum bounds.
* @return {number} The clamped value.
*/
var Clamp = function (v, min, max)
{
    if (v < min)
    {
        return min;
    }
    else if (max < v)
    {
        return max;
    }
    else
    {
        return v;
    }
};

module.exports = Clamp;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(2);

var DegToRad = function (degrees)
{
    return degrees * CONST.DEG_TO_RAD;
};

module.exports = DegToRad;


/***/ },
/* 240 */
/***/ function(module, exports) {

var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ },
/* 241 */
/***/ function(module, exports) {

var FloatBetween = function (min, max)
{
    return Math.random() * (max - min + 1) + min;
};

module.exports = FloatBetween;


/***/ },
/* 242 */
/***/ function(module, exports) {

var FloorTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.floor(value * p) / p;
};

module.exports = FloorTo;


/***/ },
/* 243 */
/***/ function(module, exports) {


var MaxAdd = function (value, amount, max)
{
    return Math.min(value + amount, max);
};

module.exports = MaxAdd;


/***/ },
/* 244 */
/***/ function(module, exports) {

var MinSub = function (value, amount, min)
{
    return Math.max(value - amount, min);
};

module.exports = MinSub;


/***/ },
/* 245 */
/***/ function(module, exports) {

var Percent = function (a, b, base)
{
    if (base === undefined) { base = 0; }

    if (a > b || base > b)
    {
        return 1;
    }
    else if (a < base || base > a)
    {
        return 0;
    }
    else
    {
        return (a - base) / b;
    }
};

module.exports = Percent;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(2);

var RadToDeg = function (radians)
{
    return radians * CONST.RAD_TO_DEG;
};

module.exports = RadToDeg;


/***/ },
/* 247 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var Rotate = function (point, angle)
{
    var x = point.x;
    var y = point.y;

    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));
    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));

    return point;
};

module.exports = Rotate;


/***/ },
/* 248 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAround = function (point, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = point.x - x;
    var ty = point.y - y;

    point.x = tx * c - ty * s + x;
    point.y = tx * s + ty * c + y;

    return point;
};

module.exports = RotateAround;


/***/ },
/* 249 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAroundDistance = function (point, x, y, angle, distance)
{
    var t = angle + Math.atan2(point.y - y, point.x - x);

    point.x = x + (distance * Math.cos(t));
    point.y = y + (distance * Math.sin(t));

    return point;
};

module.exports = RotateAroundDistance;


/***/ },
/* 250 */
/***/ function(module, exports) {

var RoundTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.round(value * p) / p;
};

module.exports = RoundTo;


/***/ },
/* 251 */
/***/ function(module, exports) {


var SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)
{
    if (sinAmp === undefined) { sinAmp = 1; }
    if (cosAmp === undefined) { cosAmp = 1; }
    if (frequency === undefined) { frequency = 1; }

    frequency *= Math.PI / length;

    var cos = [];
    var sin = [];

    for (var c = 0; c < length; c++)
    {
        cosAmp -= sinAmp * frequency;
        sinAmp += cosAmp * frequency;

        cos[c] = cosAmp;
        sin[c] = sinAmp;
    }

    return {
        sin: sin,
        cos: cos,
        length: length
    };
};

module.exports = SinCosTableGenerator;


/***/ },
/* 252 */
/***/ function(module, exports) {

var SmoothStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * (3 - 2 * x);
};

module.exports = SmoothStep;


/***/ },
/* 253 */
/***/ function(module, exports) {

var SmootherStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * x * (x * (x * 6 - 15) + 10);
};

module.exports = SmootherStep;


/***/ },
/* 254 */
/***/ function(module, exports) {

/**
* Checks if two values are within the given tolerance of each other.
*
* @method Phaser.Math#within
* @param {number} a - The first number to check
* @param {number} b - The second number to check
* @param {number} tolerance - The tolerance. Anything equal to or less than this is considered within the range.
* @return {boolean} True if a is <= tolerance of b.
* @see {@link Phaser.Math.fuzzyEqual}
*/
var Within = function (a, b, tolerance)
{
    return (Math.abs(a - b) <= tolerance);
};

module.exports = Within;


/***/ },
/* 255 */
/***/ function(module, exports) {

var Between = function (x1, y1, x2, y2)
{
    return Math.atan2(y2 - y1, x2 - x1);
};

module.exports = Between;


/***/ },
/* 256 */
/***/ function(module, exports) {

var BetweenPoints = function (point1, point2)
{
    return Math.atan2(point2.y - point1.y, point2.x - point1.x);
};

module.exports = BetweenPoints;


/***/ },
/* 257 */
/***/ function(module, exports) {

var BetweenPointsY = function (point1, point2)
{
    return Math.atan2(point2.x - point1.x, point2.y - point1.y);
};

module.exports = BetweenPointsY;


/***/ },
/* 258 */
/***/ function(module, exports) {

var BetweenY = function (x1, y1, x2, y2)
{
    return Math.atan2(x2 - x1, y2 - y1);
};

module.exports = BetweenY;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(64);

var Reverse = function (angle)
{
    return Normalize(angle + Math.PI);
};

module.exports = Reverse;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);

/**
* Rotates currentAngle towards targetAngle, taking the shortest rotation distance.
* The lerp argument is the amount to rotate by in this call.
* 
* @method Phaser.Math#rotateToAngle
* @param {number} currentAngle - The current angle, in radians.
* @param {number} targetAngle - The target angle to rotate to, in radians.
* @param {number} [lerp=0.05] - The lerp value to add to the current angle.
* @return {number} The adjusted angle.
*/
var RotateTo = function (currentAngle, targetAngle, lerp)
{
    if (lerp === undefined) { lerp = 0.05; }

    if (currentAngle === targetAngle)
    {
        return currentAngle;
    }

    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))
    {
        currentAngle = targetAngle;
    }
    else
    {
        if (Math.abs(targetAngle - currentAngle) > Math.PI)
        {
            if (targetAngle < currentAngle)
            {
                targetAngle += MATH_CONST.PI2;
            }
            else
            {
                targetAngle -= MATH_CONST.PI2;
            }
        }

        if (targetAngle > currentAngle)
        {
            currentAngle += lerp;
        }
        else if (targetAngle < currentAngle)
        {
            currentAngle -= lerp;
        }
    }

    return currentAngle;
};

module.exports = RotateTo;


/***/ },
/* 261 */
/***/ function(module, exports) {

/**
* Gets the shortest angle between `angle1` and `angle2`.
* Both angles must be in the range -180 to 180, which is the same clamped
* range that `sprite.angle` uses, so you can pass in two sprite angles to
* this method, and get the shortest angle back between the two of them.
*
* The angle returned will be in the same range. If the returned angle is
* greater than 0 then it's a counter-clockwise rotation, if < 0 then it's
* a clockwise rotation.
* 
* @method Phaser.Math#getShortestAngle
* @param {number} angle1 - The first angle. In the range -180 to 180.
* @param {number} angle2 - The second angle. In the range -180 to 180.
* @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.
*/
var ShortestBetween = function (angle1, angle2)
{
    var difference = angle2 - angle1;

    if (difference === 0)
    {
        return 0;
    }

    var times = Math.floor((difference - (-180)) / 360);

    return difference - (times * 360);

};

module.exports = ShortestBetween;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

var Wrap = __webpack_require__(11);

var WrapDegrees = function (angle)
{
    return Wrap(angle, -180, 180);
};

module.exports = WrapDegrees;


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(255),
    BetweenY: __webpack_require__(258),
    BetweenPoints: __webpack_require__(256),
    BetweenPointsY: __webpack_require__(257),
    Reverse: __webpack_require__(259),
    RotateTo: __webpack_require__(260),
    ShortestBetween: __webpack_require__(261),
    Normalize: __webpack_require__(64),
    Wrap: __webpack_require__(12),
    WrapDegrees: __webpack_require__(262)

};


/***/ },
/* 264 */
/***/ function(module, exports) {

var DistancePower = function (x1, y1, x2, y2, pow)
{
    if (pow === undefined) { pow = 2; }

    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
};

module.exports = DistancePower;


/***/ },
/* 265 */
/***/ function(module, exports) {

var DistanceSquared = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return dx * dx + dy * dy;
};

module.exports = DistanceSquared;


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(65),
    Power: __webpack_require__(264),
    Squared: __webpack_require__(265)

};


/***/ },
/* 267 */
/***/ function(module, exports) {

function In (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return v * v * ((overshoot + 1) * v - overshoot);
}

function Out (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return --v * v * ((overshoot + 1) * v + overshoot) + 1;
}

function InOut (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    var s = overshoot * 1.525;

    if ((v *= 2) < 1)
    {
        return 0.5 * (v * v * ((s + 1) * v - s));
    }
    else
    {
        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 268 */
/***/ function(module, exports) {

function In (v)
{
    v = 1 - v;

    if (v < 1 / 2.75)
    {
        return 1 - (7.5625 * v * v);
    }
    else if (v < 2 / 2.75)
    {
        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
    }
    else if (v < 2.5 / 2.75)
    {
        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
    }
    else
    {
        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
    }
}

function Out (v)
{
    if (v < 1 / 2.75)
    {
        return 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }
}

function InOut (v)
{
    var reverse = false;

    if (v < 0.5)
    {
        v = 1 - (v * 2);
        reverse = true;
    }
    else
    {
        v = (v * 2) - 1;
    }

    if (v < 1 / 2.75)
    {
        v = 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }

    if (reverse)
    {
        return (1 - v) * 0.5;
    }
    else
    {
        return v * 0.5 + 0.5;
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 269 */
/***/ function(module, exports) {

function In (v)
{
    return 1 - Math.sqrt(1 - v * v);
}

function Out (v)
{
    return Math.sqrt(1 - (--v * v));
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return -0.5 * (Math.sqrt(1 - v * v) - 1);
    }
    else
    {
        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 270 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v;
}

function Out (v)
{
    return --v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 271 */
/***/ function(module, exports) {

function In (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
    }
}

function Out (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);
    }
}

function InOut (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        if ((v *= 2) < 1)
        {
            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
        }
        else
        {
            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
        }
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 272 */
/***/ function(module, exports) {

function In (v)
{
    return Math.pow(2, 10 * (v - 1)) - 0.001;
}

function Out (v)
{
    return 1 - Math.pow(2, -10 * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * Math.pow(2, 10 * (v - 1));
    }
    else
    {
        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 273 */
/***/ function(module, exports) {

/**
* Linear Easing (no variation).
*
* @method Lazer.Easing.Linear#None
* @param {number} v - The value to be tweened.
* @returns {number} v.
*/
var Linear = function (v)
{
    return v;
};

module.exports = Linear;


/***/ },
/* 274 */
/***/ function(module, exports) {

function In (v)
{
    return v * v;
}

function Out (v)
{
    return v * (2 - v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v;
    }
    else
    {
        return -0.5 * (--v * (v - 2) - 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 275 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v * v;
}

function Out (v)
{
    return 1 - (--v * v * v * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v;
    }
    else
    {
        return -0.5 * ((v -= 2) * v * v * v - 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 276 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v * v * v;
}

function Out (v)
{
    return --v * v * v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 277 */
/***/ function(module, exports) {

function In (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 1 - Math.cos(v * Math.PI / 2);
    }
}

function Out (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return Math.sin(v * Math.PI / 2);
    }
}

function InOut (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 0.5 * (1 - Math.cos(Math.PI * v));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Back: __webpack_require__(267),
    Bounce: __webpack_require__(268),
    Circular: __webpack_require__(269),
    Cubic: __webpack_require__(270),
    Elastic: __webpack_require__(271),
    Expo: __webpack_require__(272),
    Linear: __webpack_require__(273),
    Quadratic: __webpack_require__(274),
    Quartic: __webpack_require__(275),
    Quintic: __webpack_require__(276),
    Sine: __webpack_require__(277)

};


/***/ },
/* 279 */
/***/ function(module, exports) {

var Ceil = function (value, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.ceil(value - epsilon);
};

module.exports = Ceil;


/***/ },
/* 280 */
/***/ function(module, exports) {

var Equal = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.abs(a - b) < epsilon;
};

module.exports = Equal;


/***/ },
/* 281 */
/***/ function(module, exports) {

var Floor = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.floor(value + epsilon);
};

module.exports = Floor;


/***/ },
/* 282 */
/***/ function(module, exports) {

var GreaterThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a > b - epsilon;
};

module.exports = GreaterThan;


/***/ },
/* 283 */
/***/ function(module, exports) {

var LessThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a < b + epsilon;
};

module.exports = LessThan;


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(279),
    Equal: __webpack_require__(280),
    Floor: __webpack_require__(281),
    GreaterThan: __webpack_require__(282),
    LessThan: __webpack_require__(283)

};


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

var Bernstein = __webpack_require__(58);

var BezierInterpolation = function (v, k)
{
    var b = 0;
    var n = v.length - 1;

    for (var i = 0; i <= n; i++)
    {
        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
    }

    return b;
};

module.exports = BezierInterpolation;


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

var CatmullRom = __webpack_require__(60);

var CatmullRomInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (v[0] === v[m])
    {
        if (k < 0)
        {
            i = Math.floor(f = m * (1 + k));
        }

        return CatmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
    }
    else
    {
        if (k < 0)
        {
            return v[0] - (CatmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);
        }

        if (k > 1)
        {
            return v[m] - (CatmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
        }

        return CatmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
    }
};

module.exports = CatmullRomInterpolation;


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(62);

var LinearInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (k < 0)
    {
        return Linear(v[0], v[1], f);
    }

    if (k > 1)
    {
        return Linear(v[m], v[m - 1], m - f);
    }

    return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);
};

module.exports = LinearInterpolation;


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Bezier: __webpack_require__(285),
    CatmullRom: __webpack_require__(286),
    Linear: __webpack_require__(287)

};


/***/ },
/* 289 */
/***/ function(module, exports) {

//  Takes value and returns the nearest power of 2

var GetPowerOfTwo = function (value)
{
    //  Math.log(2)
    var index = Math.log(value) / 0.6931471805599453;

    return (1 << Math.ceil(index));
};

module.exports = GetPowerOfTwo;


/***/ },
/* 290 */
/***/ function(module, exports) {

//  Is value a power of 2?

var IsValuePowerOfTwo = function (value)
{
    return (value > 0 && (value & (value - 1)) === 0);
};

module.exports = IsValuePowerOfTwo;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {module.export = {

    GetNext: __webpack_require__(289),
    IsSize: __webpack_require__(66),
    IsValue: __webpack_require__(290)

};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(86)(module)))

/***/ },
/* 292 */
/***/ function(module, exports) {

/**
* @property {number} c - Internal var.
* @private
*/
var c = 1;

/**
* @property {number} s0 - Internal var.
* @private
*/
var s0 = 0;

/**
* @property {number} s1 - Internal var.
* @private
*/
var s1 = 0;

/**
* @property {number} s2 - Internal var.
* @private
*/
var s2 = 0;

/**
* @property {Array} sign - Internal var.
* @private
*/
var sign = [ -1, 1 ];

/**
* Private random helper.
*
* @method Phaser.RandomDataGenerator#rnd
* @private
* @return {number}
*/
var rnd = function ()
{
    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32

    c = t | 0;
    s0 = s1;
    s1 = s2;
    s2 = t - c;

    return s2;
};

/**
* Internal method that creates a seed hash.
*
* @method Phaser.RandomDataGenerator#hash
* @private
* @param {any} data
* @return {number} hashed value.
*/
var hash = function (data)
{
    var h, i, n;
    n = 0xefc8249d;
    data = data.toString();

    for (i = 0; i < data.length; i++)
    {
        n += data.charCodeAt(i);
        h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000;// 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10;// 2^-32
};


var RandomDataGenerator = function (seeds)
{
    if (typeof seeds === 'string')
    {
        this.state(seeds);
    }
    else
    {
        this.sow(seeds);
    }
};

RandomDataGenerator.prototype.constructor = RandomDataGenerator;

RandomDataGenerator.prototype = {

    /**
    * Reset the seed of the random data generator.
    *
    * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
    *
    * @method Phaser.RandomDataGenerator#sow
    * @param {any[]} seeds - The array of seeds: the `toString()` of each value is used.
    */
    sow: function (seeds)
    {
        // Always reset to default seed
        s0 = hash(' ');
        s1 = hash(s0);
        s2 = hash(s1);
        c = 1;

        if (!seeds)
        {
            return;
        }

        // Apply any seeds
        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)
        {
            var seed = seeds[i];

            s0 -= hash(seed);
            s0 += ~~(s0 < 0);
            s1 -= hash(seed);
            s1 += ~~(s1 < 0);
            s2 -= hash(seed);
            s2 += ~~(s2 < 0);
        }

    },

    /**
    * Returns a random integer between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#integer
    * @return {number} A random integer between 0 and 2^32.
    */
    integer: function ()
    {
        // 2^32
        return rnd() * 0x100000000;
    },

    /**
    * Returns a random real number between 0 and 1.
    *
    * @method Phaser.RandomDataGenerator#frac
    * @return {number} A random real number between 0 and 1.
    */
    frac: function ()
    {
        // 2^-53
        return rnd() + (rnd() * 0x200000 | 0) * 1.1102230246251565e-16;
    },

    /**
    * Returns a random real number between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#real
    * @return {number} A random real number between 0 and 2^32.
    */
    real: function ()
    {
        return this.integer() + this.frac();
    },

    /**
    * Returns a random integer between and including min and max.
    *
    * @method Phaser.RandomDataGenerator#integerInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    integerInRange: function (min, max)
    {
        return Math.floor(this.realInRange(0, max - min + 1) + min);
    },

    /**
    * Returns a random integer between and including min and max.
    * This method is an alias for RandomDataGenerator.integerInRange.
    *
    * @method Phaser.RandomDataGenerator#between
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    between: function (min, max)
    {
        return this.integerInRange(min, max);
    },

    /**
    * Returns a random real number between min and max.
    *
    * @method Phaser.RandomDataGenerator#realInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    realInRange: function (min, max)
    {
        return this.frac() * (max - min) + min;
    },

    /**
    * Returns a random real number between -1 and 1.
    *
    * @method Phaser.RandomDataGenerator#normal
    * @return {number} A random real number between -1 and 1.
    */
    normal: function ()
    {
        return 1 - (2 * this.frac());
    },

    /**
    * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
    *
    * @method Phaser.RandomDataGenerator#uuid
    * @return {string} A valid RFC4122 version4 ID hex string
    */
    uuid: function ()
    {
        var a = '';
        var b = '';

        for (b = a = ''; a++ < 36; b +=~a % 5 | a * 3&4 ? (a^15 ? 8^this.frac() * (a^20 ? 16 : 4) : 4).toString(16) : '-')
        {
        }

        return b;
    },

    /**
    * Returns a random member of `array`.
    *
    * @method Phaser.RandomDataGenerator#pick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    pick: function (array)
    {
        return array[this.integerInRange(0, array.length - 1)];
    },

    /**
    * Returns a sign to be used with multiplication operator.
    *
    * @method Phaser.RandomDataGenerator#sign
    * @return {number} -1 or +1.
    */
    sign: function ()
    {
        return this.pick(sign);
    },

    /**
    * Returns a random member of `array`, favoring the earlier entries.
    *
    * @method Phaser.RandomDataGenerator#weightedPick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    weightedPick: function (array)
    {
        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
    },

    /**
    * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
    *
    * @method Phaser.RandomDataGenerator#timestamp
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random timestamp between min and max.
    */
    timestamp: function (min, max)
    {
        return this.realInRange(min || 946684800000, max || 1577862000000);
    },

    /**
    * Returns a random angle between -180 and 180.
    *
    * @method Phaser.RandomDataGenerator#angle
    * @return {number} A random number between -180 and 180.
    */
    angle: function ()
    {
        return this.integerInRange(-180, 180);
    },

    /**
    * Returns a random rotation in radians, between -3.141 and 3.141
    *
    * @method Phaser.RandomDataGenerator#rotation
    * @return {number} A random number between -3.141 and 3.141
    */
    rotation: function ()
    {
        return this.realInRange(-3.141592653589793, 3.141592653589793);
    },

    /**
    * Gets or Sets the state of the generator. This allows you to retain the values
    * that the generator is using between games, i.e. in a game save file.
    *
    * To seed this generator with a previously saved state you can pass it as the
    * `seed` value in your game config, or call this method directly after Phaser has booted.
    *
    * Call this method with no parameters to return the current state.
    *
    * If providing a state it should match the same format that this method
    * returns, which is a string with a header `!rnd` followed by the `c`,
    * `s0`, `s1` and `s2` values respectively, each comma-delimited.
    *
    * @method Phaser.RandomDataGenerator#state
    * @param {string} [state] - Generator state to be set.
    * @return {string} The current state of the generator.
    */
    state: function (state)
    {
        if (typeof state === 'string' && state.match(/^!rnd/))
        {
            state = state.split(',');

            c = parseFloat(state[1]);
            s0 = parseFloat(state[2]);
            s1 = parseFloat(state[3]);
            s2 = parseFloat(state[4]);
        }

        return [ '!rnd', c, s0, s1, s2 ].join(',');
    }

};

module.exports = RandomDataGenerator;


/***/ },
/* 293 */
/***/ function(module, exports) {

var SnapCeil = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.ceil(value / gap);

    return start + value;
};

module.exports = SnapCeil;


/***/ },
/* 294 */
/***/ function(module, exports) {

var SnapFloor = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.floor(value / gap);

    return start + value;
};

module.exports = SnapFloor;


/***/ },
/* 295 */
/***/ function(module, exports) {

var SnapTo = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.round(value / gap);

    return start + value;
};

module.exports = SnapTo;


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(293),
    Floor: __webpack_require__(294),
    To: __webpack_require__(295)

};


/***/ },
/* 297 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function (fun /*, thisArg */)
    {
        'use strict';

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== 'function')
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}


/***/ },
/* 298 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}


/***/ },
/* 299 */
/***/ function(module, exports) {

/* Copyright 2013 Chris Wilson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*

This monkeypatch library is intended to be included in projects that are
written to the proper AudioContext spec (instead of webkitAudioContext),
and that use the new naming and proper bits of the Web Audio API (e.g.
using BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may
have to run on systems that only support the deprecated bits.

This library should be harmless to include if the browser supports
unprefixed "AudioContext", and/or if it supports the new names.

The patches this library handles:
if window.AudioContext is unsupported, it will be aliased to webkitAudioContext().
if AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or
noteGrainOn(), depending on parameters.

The following aliases only take effect if the new names are not already in place:

AudioBufferSourceNode.stop() is aliased to noteOff()
AudioContext.createGain() is aliased to createGainNode()
AudioContext.createDelay() is aliased to createDelayNode()
AudioContext.createScriptProcessor() is aliased to createJavaScriptNode()
AudioContext.createPeriodicWave() is aliased to createWaveTable()
OscillatorNode.start() is aliased to noteOn()
OscillatorNode.stop() is aliased to noteOff()
OscillatorNode.setPeriodicWave() is aliased to setWaveTable()
AudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()

This library does NOT patch the enumerated type changes, as it is
recommended in the specification that implementations support both integer
and string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel
BiquadFilterNode.type and OscillatorNode.type.

*/
(function (global, exports, perf) {
  'use strict';

  function fixSetTarget(param) {
    if (!param)	// if NYI, just return
      return;
    if (!param.setTargetAtTime)
      param.setTargetAtTime = param.setTargetValueAtTime;
  }

  if (window.hasOwnProperty('webkitAudioContext') &&
      !window.hasOwnProperty('AudioContext')) {
    window.AudioContext = webkitAudioContext;

    if (!AudioContext.prototype.hasOwnProperty('createGain'))
      AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
    if (!AudioContext.prototype.hasOwnProperty('createDelay'))
      AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
    if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor'))
      AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;
    if (!AudioContext.prototype.hasOwnProperty('createPeriodicWave'))
      AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;


    AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;
    AudioContext.prototype.createGain = function() {
      var node = this.internal_createGain();
      fixSetTarget(node.gain);
      return node;
    };

    AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;
    AudioContext.prototype.createDelay = function(maxDelayTime) {
      var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();
      fixSetTarget(node.delayTime);
      return node;
    };

    AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;
    AudioContext.prototype.createBufferSource = function() {
      var node = this.internal_createBufferSource();
      if (!node.start) {
        node.start = function ( when, offset, duration ) {
          if ( offset || duration )
            this.noteGrainOn( when || 0, offset, duration );
          else
            this.noteOn( when || 0 );
        };
      } else {
        node.internal_start = node.start;
        node.start = function( when, offset, duration ) {
          if( typeof duration !== 'undefined' )
            node.internal_start( when || 0, offset, duration );
          else
            node.internal_start( when || 0, offset || 0 );
        };
      }
      if (!node.stop) {
        node.stop = function ( when ) {
          this.noteOff( when || 0 );
        };
      } else {
        node.internal_stop = node.stop;
        node.stop = function( when ) {
          node.internal_stop( when || 0 );
        };
      }
      fixSetTarget(node.playbackRate);
      return node;
    };

    AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;
    AudioContext.prototype.createDynamicsCompressor = function() {
      var node = this.internal_createDynamicsCompressor();
      fixSetTarget(node.threshold);
      fixSetTarget(node.knee);
      fixSetTarget(node.ratio);
      fixSetTarget(node.reduction);
      fixSetTarget(node.attack);
      fixSetTarget(node.release);
      return node;
    };

    AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;
    AudioContext.prototype.createBiquadFilter = function() {
      var node = this.internal_createBiquadFilter();
      fixSetTarget(node.frequency);
      fixSetTarget(node.detune);
      fixSetTarget(node.Q);
      fixSetTarget(node.gain);
      return node;
    };

    if (AudioContext.prototype.hasOwnProperty( 'createOscillator' )) {
      AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;
      AudioContext.prototype.createOscillator = function() {
        var node = this.internal_createOscillator();
        if (!node.start) {
          node.start = function ( when ) {
            this.noteOn( when || 0 );
          };
        } else {
          node.internal_start = node.start;
          node.start = function ( when ) {
            node.internal_start( when || 0);
          };
        }
        if (!node.stop) {
          node.stop = function ( when ) {
            this.noteOff( when || 0 );
          };
        } else {
          node.internal_stop = node.stop;
          node.stop = function( when ) {
            node.internal_stop( when || 0 );
          };
        }
        if (!node.setPeriodicWave)
          node.setPeriodicWave = node.setWaveTable;
        fixSetTarget(node.frequency);
        fixSetTarget(node.detune);
        return node;
      };
    }
  }

  if (window.hasOwnProperty('webkitOfflineAudioContext') &&
      !window.hasOwnProperty('OfflineAudioContext')) {
    window.OfflineAudioContext = webkitOfflineAudioContext;
  }

}(window));



/***/ },
/* 300 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}

/**
* A polyfill for Function.prototype.bind
*/
if (!Function.prototype.bind) {

    /* jshint freeze: false */
    Function.prototype.bind = (function () {

        var slice = Array.prototype.slice;

        return function (thisArg) {

            var target = this, boundArgs = slice.call(arguments, 1);

            if (typeof target !== 'function')
            {
                throw new TypeError();
            }

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args);
            }

            bound.prototype = (function F(proto) {
                if (proto)
                {
                    F.prototype = proto;
                }

                if (!(this instanceof F))
                {
                    /* jshint supernew: true */
                    return new F;
                }
            })(target.prototype);

            return bound;
        };
    })();
}

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function(fun /*, thisArg */)
    {
        "use strict";

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== "function")
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}

/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ },
/* 301 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}


/***/ },
/* 302 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/


/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}


/***/ },
/* 303 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}


/***/ },
/* 304 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();
    if (!global.performance) {
        global.performance = {};
    }
    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
        global[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now(),
            delay = 16 + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(38)))

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(1);
var DrawImage = __webpack_require__(307);
var GetBlendModes = __webpack_require__(308);

var CanvasRenderer = function (game)
{
    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    //  Needed?
    this.game = game;

    //  Needed?
    this.type = CONST.CANVAS;

    //  Read all the following from game config (or State config?)
    this.clearBeforeRender = true;

    this.transparent = false;

    this.autoResize = false;

    // this.smoothProperty = Phaser.Canvas.getSmoothingPrefix(this.context);

    this.roundPixels = false;

    this.width = game.config.width * game.config.resolution;

    this.height = game.config.height * game.config.resolution;

    this.resolution = game.config.resolution;

    this.view = game.canvas;

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type CanvasRenderingContext2D
     */
    this.context = this.view.getContext('2d', { alpha: true });

    //  Map to the required function
    this.drawImage = DrawImage;

    this.blendModes = GetBlendModes();

    this.currentAlpha = 1;
    this.currentBlendMode = 0;
    this.currentScaleMode = 0;

    // this.tintMethod = this.tintWithPerPixel;

    this.init();
};

CanvasRenderer.prototype.constructor = CanvasRenderer;

CanvasRenderer.prototype = {

    init: function ()
    {
        this.resize(this.width, this.height);
    },

    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.view.width = this.width;
        this.view.height = this.height;

        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        // if (this.smoothProperty)
        // {
        //     this.context[this.smoothProperty] = (this.scaleMode === ScaleModes.LINEAR);
        // }
    },

    /**
     * Renders the State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, interpolationPercentage)
    {
        // console.log('%c render start ', 'color: #ffffff; background: #00ff00;');

        var ctx = this.context;

        //  Add Pre-render hook

        //  TODO: A State should have the option of having its own canvas to draw to

        ctx.setTransform(1, 0, 0, 1, 0, 0);

        //  If the alpha or blend mode didn't change since the last render, then don't set them again (saves 2 ops)

        if (this.currentAlpha !== 1)
        {
            ctx.globalAlpha = 1;
            this.currentAlpha = 1;
        }

        if (this.currentBlendMode !== 0)
        {
            ctx.globalCompositeOperation = 'source-over';
            this.currentBlendMode = 0;
        }

        this.currentScaleMode = 0;

        if (this.clearBeforeRender)
        {
            ctx.clearRect(0, 0, this.width, this.height);
        }

        for (var c = 0; c < state.sys.children.list.length; c++)
        {
            var child = state.sys.children.list[c];

            child.renderCanvas(this, child, interpolationPercentage);
        }

        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');

        //  Add Post-render hook
    },

    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @method destroy
     * @param [removeView=true] {boolean} Removes the Canvas element from the DOM.
     */
    destroy: function ()
    {
        //  CanvasPool

        this.view = null;
        this.context = null;
    }

};

module.exports = CanvasRenderer;


/***/ },
/* 307 */
/***/ function(module, exports) {


var DrawImage = function (frame, blendMode, transform, alpha, tint, bg)
{
    var ctx = this.context;
    var cd = frame.canvasData;

    //  Blend Mode

    if (this.currentBlendMode !== blendMode)
    {
        this.currentBlendMode = blendMode;
        ctx.globalCompositeOperation = this.blendModes[blendMode];
    }

    //  Alpha

    if (this.currentAlpha !== alpha)
    {
        this.currentAlpha = alpha;
        ctx.globalAlpha = alpha;
    }

    //  Smoothing (should this be a Game Object, or Frame / Texture level property?)

    if (this.currentScaleMode !== frame.source.scaleMode)
    {
        // this.currentScaleMode = source.scaleMode;
        // ctx[this.smoothProperty] = (source.scaleMode === ScaleModes.LINEAR);
    }

    ctx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
    ctx.drawImage(frame.source.image, cd.sx, cd.sy, cd.sWidth, cd.sHeight, transform.dx, transform.dy, cd.dWidth, cd.dHeight);

};

module.exports = DrawImage;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

var modes = __webpack_require__(67);
var CanvasFeatures = __webpack_require__(39);

var GetBlendModes = function ()
{
    var output = [];
    var useNew = CanvasFeatures.supportNewBlendModes;

    output[modes.NORMAL] = 'source-over';
    output[modes.ADD] = 'lighter';
    output[modes.MULTIPLY] = (useNew) ? 'multiply' : 'source-over';
    output[modes.SCREEN] = (useNew) ? 'screen' : 'source-over';
    output[modes.OVERLAY] = (useNew) ? 'overlay' : 'source-over';
    output[modes.DARKEN] = (useNew) ? 'darken' : 'source-over';
    output[modes.LIGHTEN] = (useNew) ? 'lighten' : 'source-over';
    output[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : 'source-over';
    output[modes.COLOR_BURN] = (useNew) ? 'color-burn' : 'source-over';
    output[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : 'source-over';
    output[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : 'source-over';
    output[modes.DIFFERENCE] = (useNew) ? 'difference' : 'source-over';
    output[modes.EXCLUSION] = (useNew) ? 'exclusion' : 'source-over';
    output[modes.HUE] = (useNew) ? 'hue' : 'source-over';
    output[modes.SATURATION] = (useNew) ? 'saturation' : 'source-over';
    output[modes.COLOR] = (useNew) ? 'color' : 'source-over';
    output[modes.LUMINOSITY] = (useNew) ? 'luminosity' : 'source-over';

    return output;
};

module.exports = GetBlendModes;


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @author       Mat Groves (@Doormat23)
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var CreateEmptyTexture = __webpack_require__(318);
var CreateTexture2DImage = __webpack_require__(69);
var BlitterBatch = __webpack_require__(310);
var SpriteBatch = __webpack_require__(315);
var SpriteBatch32 = __webpack_require__(316);
var BlendModes = __webpack_require__(67);

var WebGLRenderer = function (game)
{
    this.game = game;

    this.type = CONST.WEBGL;

    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.resolution = game.config.resolution;

    this.view = game.canvas;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.contextLost = false;
    this.maxTextures = 1;
    this.multiTexture = false;
    this.blendModes = [];

    this.gl = null;

    this.init();

    this.extensions = this.gl.getSupportedExtensions();

    this.blitterBatch = new BlitterBatch(game, this.gl, this);
    this.spriteBatch = null;
    if (this.extensions.indexOf('OES_element_index_uint') >= 0)
    {
        this.spriteBatch = new SpriteBatch32(game, this.gl, this);
    }
    else
    {
        this.spriteBatch = new SpriteBatch(game, this.gl, this);
    }

    this.batch = null;
    this.currentTexture2D = null;
};

WebGLRenderer.prototype.constructor = WebGLRenderer;

WebGLRenderer.prototype = {

    init: function ()
    {
        this.gl = this.view.getContext('webgl', this.config.WebGLContextOptions) || this.view.getContext('experimental-webgl', this.config.WebGLContextOptions);

        if (!this.gl)
        {
            this.contextLost = true;
            throw new Error('This browser does not support WebGL. Try using the Canvas renderer.');
        }

        var gl = this.gl;

        /*
        //  Will need supporting

        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

        if (this.maxTextures === 1)
        {
            this.multiTexture = false;
        }
        else
        {
            this.createMultiEmptyTextures();
        }

        this.emptyTexture = CreateEmptyTexture(this.gl, 1, 1, 0, 0);
        */

        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);

        gl.clearColor(1, 0, 0, 1);

        this.resize(this.width, this.height);

        /*
        //  Will need supporting

        this.extensions.compression = {};

        var etc1 = gl.getExtension('WEBGL_compressed_texture_etc1') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_etc1');
        var pvrtc = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        var s3tc = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');

        if (etc1)
        {
            this.extensions.compression.ETC1 = etc1;
        }

        if (pvrtc)
        {
            this.extensions.compression.PVRTC = pvrtc;
        }

        if (s3tc)
        {
            this.extensions.compression.S3TC = s3tc;
        }
        */

        //  Map Blend Modes

        var add = [ gl.SRC_ALPHA, gl.DST_ALPHA ];
        var normal = [ gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
        var multiply = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];
        var screen = [ gl.SRC_ALPHA, gl.ONE ];

        this.blendModes = [
            normal, add, multiply, screen, normal,
            normal, normal, normal, normal,
            normal, normal, normal, normal,
            normal, normal, normal, normal
        ];

        this.blendMode = -1;
    },

    createTexture2D: function (source)
    {
        var gl = this.gl;

        if (!source.glTexture)
        {
            source.glTexture = CreateTexture2DImage(gl, source.image, gl.NEAREST, 0);
        }

        this.currentTexture2D = source.glTexture;
    },

    setTexture2D: function (texture2D)
    {
        if (this.currentTexture2D !== texture2D)
        {
            if (this.batch)
            {
                this.batch.flush();
            }

            var gl = this.gl;

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture2D);

            this.currentTexture2D = texture2D;
        }
    },

    setBatch: function (batch, texture2D)
    {
        this.setTexture2D(texture2D);

        if (this.batch !== batch)
        {
            if (this.batch)
            {
                this.batch.flush();
            }

            batch.bind();

            this.batch = batch;
        }
    },

    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.view.width = this.width;
        this.view.height = this.height;

        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        this.gl.viewport(0, 0, this.width, this.height);

        //  Needed?
        // this.clipUnitX = 2 / this.width;
        // this.clipUnitY = 2 / this.height;

        //  Needed?
        // this.projection.x = (this.width / 2) / res;
        // this.projection.y = -(this.height / 2) / res;
    },

    /**
     * Renders the State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, interpolationPercentage)
    {
        // console.log('%c render start ', 'color: #ffffff; background: #00ff00;');

        //  No point rendering if our context has been blown up!
        if (this.contextLost)
        {
            return;
        }

        //  Add Pre-render hook

        var gl = this.gl;

        

        //  This is the old render loop - add what you need here to replace it,
        //  but please allow each State to render to its own Quad FBO

        //var fbo = state.sys.fbo;

        //fbo.activate();

        //  clear is needed for the FBO, otherwise corruption ...
        gl.clear(gl.COLOR_BUFFER_BIT);

        this.setBlendMode(BlendModes.NORMAL);

        //  Could move to the State Systems or MainLoop
        for (var c = 0; c < state.sys.children.list.length; c++)
        {
            var child = state.sys.children.list[c];
            child.renderWebGL(this, child, interpolationPercentage);
            var batch = this.batch;
            if (batch && batch.isFull())
                batch.flush();
        }
        var batch = this.batch;
        if (batch)
            batch.flush();

        //this.batch.stop();

        //  Call state.render here, so we can do some extra shizzle on the top
        //  Maybe pass in the FBO texture too?

        //fbo.render(null);

        //  Unbind the fbo texture and replace it with an empty texture.
        //  If we forget this we corrupt the main context texture!
        //  or get `RENDER WARNING: there is no texture bound to the unit 0` spam in the console
        //gl.bindTexture(gl.TEXTURE_2D, this.emptyTexture);

        

        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');

        //  Add Post-render hook
    },

    destroy: function ()
    {
        this.gl = null;
    },

    createFBO: function () {},

    setBlendMode: function (newBlendMode)
    {
        var gl = this.gl;
        var batch = this.batch;
        var blend = null;

        if (this.blendMode !== newBlendMode)
        {
            if (batch)
                batch.flush();
            blend = this.blendModes[newBlendMode];
            gl.enable(gl.BLEND);
            if (blend.length > 2)
            {
                gl.blendFuncSeparate(blend[0], blend[1], blend[2], blend[3]);
            }
            else
            {
                gl.blendFunc(blend[0], blend[1]);        
            }
            this.blendMode = newBlendMode;
        }
    }
};

module.exports = WebGLRenderer;


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

//  Could you move these into sub-folders please, i.e. 'vao', 'shader' etc?

var BindVertexArray = __webpack_require__(35);
var CreateProgram = __webpack_require__(33);
var CreateShader = __webpack_require__(34);
var CreateBuffer = __webpack_require__(30);
var CreateAttribDesc = __webpack_require__(36);
var VertexBuffer = __webpack_require__(32);
var IndexBuffer = __webpack_require__(31);
var VertexArray = __webpack_require__(37);

var PHASER_CONST = __webpack_require__(1);
var CONST = __webpack_require__(313);

var BlitterBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;

    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;

    this.glContext = gl;

    this.maxParticles = null;

    this.vertShader = null;
    this.fragShader = null;

    this.program = null;

    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;

    this.elementCount = 0;

    this.currentTexture2D = null;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

BlitterBatch.prototype.constructor = BlitterBatch;

BlitterBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new VertexBuffer(CONST.VERTEX_SIZE * CONST.PARTICLE_VERTEX_COUNT * CONST.MAX_PARTICLES);

        var indexDataBuffer = new IndexBuffer(CONST.INDEX_SIZE * CONST.PARTICLE_INDEX_COUNT * CONST.MAX_PARTICLES);

        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);

        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());

        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_tex_coord', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8),
            CreateAttribDesc(gl, program, 'a_alpha', 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 16)
        ];

        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);

        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;

        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;

        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;


        this.viewMatrixLocation = viewMatrixLocation;
           
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);

        var indexBuffer = indexDataBuffer.wordView;
        var max = CONST.MAX_PARTICLES * CONST.PARTICLE_INDEX_COUNT;

            // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.PARTICLE_INDEX_COUNT, indexB += CONST.PARTICLE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexDataBuffer.getUsedBufferAsWord());

        this.bind();

        this.resize(this.width, this.height);

        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    add: function (x, y, frame, alpha)
    {
        this.manager.setBatch(this, frame.texture.source[frame.sourceIndex].glTexture);

        // The user must check if the buffers are full before flushing
        // this is to give freedom of when should the renderer flush. var vertexDataBuffer = this.vertexDataBuffer;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBuffer = vertexDataBuffer.floatView;
        var vertexOffset = vertexDataBuffer.allocate(CONST.PARTICLE_VERTEX_COMPONENT_COUNT * CONST.PARTICLE_VERTEX_COUNT);
        var uvs = frame.uvs;
        var width = frame.width;
        var height = frame.height;

        vertexBuffer[vertexOffset++] = x;
        vertexBuffer[vertexOffset++] = y;
        vertexBuffer[vertexOffset++] = uvs.x0;
        vertexBuffer[vertexOffset++] = uvs.y0;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = x;
        vertexBuffer[vertexOffset++] = y + height;
        vertexBuffer[vertexOffset++] = uvs.x1;
        vertexBuffer[vertexOffset++] = uvs.y1;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = x + width;
        vertexBuffer[vertexOffset++] = y + height;
        vertexBuffer[vertexOffset++] = uvs.x2;
        vertexBuffer[vertexOffset++] = uvs.y2;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = x + width;
        vertexBuffer[vertexOffset++] = y;
        vertexBuffer[vertexOffset++] = uvs.x3;
        vertexBuffer[vertexOffset++] = uvs.y3;
        vertexBuffer[vertexOffset++] = alpha;

        this.elementCount += CONST.PARTICLE_INDEX_COUNT;
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);

        gl.clearColor(0, 0, 0, 1);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);

        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);

        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height)
    {
        var gl = this.glContext;
        var res = this.game.config.resolution;
        
        this.width = width * res;
        this.height = height * res;
        
        this.view.width = this.width;
        this.view.height = this.height;
        
        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        gl.viewport(0, 0, this.width, this.height);

        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.view.width, 0, 0, 0,
                0, -2 / this.view.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    }

};

module.exports = BlitterBatch;


/***/ },
/* 311 */
/***/ function(module, exports) {

module.exports = [
    'precision lowp float;',
    'uniform sampler2D u_sampler2D;',
    'varying vec2 v_tex_coord;',
    'varying float v_alpha;',
    'void main() {',
    '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord) * vec4(1.0, 1.0, 1.0, v_alpha);',
    '}'
].join('\n');


/***/ },
/* 312 */
/***/ function(module, exports) {

module.exports = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec2 a_tex_coord;',
    'attribute float a_alpha;',
    'varying vec2 v_tex_coord;',
    'varying float v_alpha;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_tex_coord = a_tex_coord;',
    '	v_alpha = a_alpha;',
    '}'
].join('\n');


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(311);
var VertexShader = __webpack_require__(312);

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec2) + sizeof(float)
    VERTEX_SIZE: 20,
    INDEX_SIZE: 2,
    PARTICLE_VERTEX_COUNT: 4,
    PARTICLE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    PARTICLE_VERTEX_COMPONENT_COUNT: 5,

    // Can't be bigger since index are 16-bit
    MAX_PARTICLES: 10000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 314 */
/***/ function(module, exports) {

module.exports = [
    'precision lowp float;',
    'uniform sampler2D u_sampler2D;',
    'varying vec2 v_tex_coord;',
    'varying vec3 v_color;',
    'void main() {',
    '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord) * vec4(v_color, 1.0);',
    '}'
].join('\n');


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

var BindVertexArray = __webpack_require__(35);
var CreateProgram = __webpack_require__(33);
var CreateShader = __webpack_require__(34);
var CreateBuffer = __webpack_require__(30);
var CreateAttribDesc = __webpack_require__(36);
var VertexBuffer = __webpack_require__(32);
var IndexBuffer = __webpack_require__(31);
var VertexArray = __webpack_require__(37);

var PHASER_CONST = __webpack_require__(1);
var CONST = __webpack_require__(68);

var SpriteBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;

    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;

    this.glContext = gl;

    this.maxSprites = null;

    this.vertShader = null;
    this.fragShader = null;

    this.program = null;

    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;

    this.elementCount = 0;

    this.currentTexture2D = null;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

SpriteBatch.prototype.constructor = SpriteBatch;

SpriteBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new VertexBuffer(CONST.VERTEX_SIZE * CONST.SPRITE_VERTEX_COUNT * CONST.MAX_SPRITES);

        var indexDataBuffer = new IndexBuffer(CONST.INDEX_SIZE * CONST.SPRITE_INDEX_COUNT * CONST.MAX_SPRITES);

        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);

        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());

        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_tex_coord', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8),
            CreateAttribDesc(gl, program, 'a_translate', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 16),
            CreateAttribDesc(gl, program, 'a_scale', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 24),
            CreateAttribDesc(gl, program, 'a_rotation', 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 32),
            CreateAttribDesc(gl, program, 'a_color', 3, 5121, true, CONST.VERTEX_SIZE, 36)
        ];

        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);

        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;

        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;

        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;


        this.viewMatrixLocation = viewMatrixLocation;
           
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);

        var indexBuffer = indexDataBuffer.wordView;
        var max = CONST.MAX_SPRITES * CONST.SPRITE_INDEX_COUNT;

            // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.SPRITE_INDEX_COUNT, indexB += CONST.SPRITE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexBuffer);

        this.bind();

        this.resize(this.width, this.height);

        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    add: function (frame, anchorX, anchorY, translateX, translateY, scaleX, scaleY, rotation, vertexColor)
    {
        this.manager.setBatch(this, frame.texture.source[frame.sourceIndex].glTexture);

        // The user must check if the buffers are full before flushing
        // this is to give freedom of when should the renderer flush. var vertexDataBuffer = this.vertexDataBuffer;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = vertexDataBuffer.allocate(CONST.SPRITE_VERTEX_COMPONENT_COUNT * CONST.SPRITE_VERTEX_COUNT);
        var uvs = frame.uvs;
        var width = frame.width;
        var height = frame.height;
        var x = width * -anchorX;
        var y = height * -anchorY;

        vertexBufferF32[vertexOffset++] = x;
        vertexBufferF32[vertexOffset++] = y;
        vertexBufferF32[vertexOffset++] = uvs.x0;
        vertexBufferF32[vertexOffset++] = uvs.y0;
        vertexBufferF32[vertexOffset++] = translateX;
        vertexBufferF32[vertexOffset++] = translateY;
        vertexBufferF32[vertexOffset++] = scaleX;
        vertexBufferF32[vertexOffset++] = scaleY;
        vertexBufferF32[vertexOffset++] = rotation;
        vertexBufferU32[vertexOffset++] = vertexColor.topLeft;

        vertexBufferF32[vertexOffset++] = x;
        vertexBufferF32[vertexOffset++] = y + height;
        vertexBufferF32[vertexOffset++] = uvs.x1;
        vertexBufferF32[vertexOffset++] = uvs.y1;
        vertexBufferF32[vertexOffset++] = translateX;
        vertexBufferF32[vertexOffset++] = translateY;
        vertexBufferF32[vertexOffset++] = scaleX;
        vertexBufferF32[vertexOffset++] = scaleY;
        vertexBufferF32[vertexOffset++] = rotation;
        vertexBufferU32[vertexOffset++] = vertexColor.bottomLeft;
    
        vertexBufferF32[vertexOffset++] = x + width;
        vertexBufferF32[vertexOffset++] = y + height;
        vertexBufferF32[vertexOffset++] = uvs.x2;
        vertexBufferF32[vertexOffset++] = uvs.y2;
        vertexBufferF32[vertexOffset++] = translateX;
        vertexBufferF32[vertexOffset++] = translateY;
        vertexBufferF32[vertexOffset++] = scaleX;
        vertexBufferF32[vertexOffset++] = scaleY;
        vertexBufferF32[vertexOffset++] = rotation;
        vertexBufferU32[vertexOffset++] = vertexColor.bottomRight;

        vertexBufferF32[vertexOffset++] = x + width;
        vertexBufferF32[vertexOffset++] = y;
        vertexBufferF32[vertexOffset++] = uvs.x3;
        vertexBufferF32[vertexOffset++] = uvs.y3;
        vertexBufferF32[vertexOffset++] = translateX;
        vertexBufferF32[vertexOffset++] = translateY;
        vertexBufferF32[vertexOffset++] = scaleX;
        vertexBufferF32[vertexOffset++] = scaleY;
        vertexBufferF32[vertexOffset++] = rotation;
        vertexBufferU32[vertexOffset++] = vertexColor.topRight;

        this.elementCount += CONST.SPRITE_INDEX_COUNT;
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);

        gl.clearColor(0, 0, 0, 1);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);

        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);

        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height)
    {
        var gl = this.glContext;
        var res = this.game.config.resolution;
        
        this.width = width * res;
        this.height = height * res;
        
        this.view.width = this.width;
        this.view.height = this.height;
        
        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        gl.viewport(0, 0, this.width, this.height);

        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.view.width, 0, 0, 0,
                0, -2 / this.view.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    }

};

module.exports = SpriteBatch;


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

var BindVertexArray = __webpack_require__(35);
var CreateProgram = __webpack_require__(33);
var CreateShader = __webpack_require__(34);
var CreateBuffer = __webpack_require__(30);
var CreateAttribDesc = __webpack_require__(36);
var VertexBuffer = __webpack_require__(32);
var IndexBuffer = __webpack_require__(31);
var VertexArray = __webpack_require__(37);

var PHASER_CONST = __webpack_require__(1);
var CONST = __webpack_require__(68);

var SpriteBatch32 = function (game, gl, manager)
{
    gl.getExtension('OES_element_index_uint');
    CONST.INDEX_SIZE = 4;
    CONST.MAX_SPRITES = 100000;

    this.game = game;
    this.type = PHASER_CONST.WEBGL;

    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;

    this.glContext = gl;

    this.maxSprites = null;

    this.vertShader = null;
    this.fragShader = null;

    this.program = null;

    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;

    this.elementCount = 0;

    this.currentTexture2D = null;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

SpriteBatch32.prototype.constructor = SpriteBatch32;

SpriteBatch32.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new VertexBuffer(CONST.VERTEX_SIZE * CONST.SPRITE_VERTEX_COUNT * CONST.MAX_SPRITES);

        var indexDataBuffer = new VertexBuffer(CONST.INDEX_SIZE * CONST.SPRITE_INDEX_COUNT * CONST.MAX_SPRITES);

        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);

        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());

        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_tex_coord', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8),
            CreateAttribDesc(gl, program, 'a_translate', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 16),
            CreateAttribDesc(gl, program, 'a_scale', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 24),
            CreateAttribDesc(gl, program, 'a_rotation', 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 32),
            CreateAttribDesc(gl, program, 'a_color', 3, 5121, true, CONST.VERTEX_SIZE, 36)
        ];

        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);

        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;

        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;

        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;


        this.viewMatrixLocation = viewMatrixLocation;
           
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);

        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_SPRITES * CONST.SPRITE_INDEX_COUNT;

            // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.SPRITE_INDEX_COUNT, indexB += CONST.SPRITE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexBuffer);

        this.bind();

        this.resize(this.width, this.height);

        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    add: function (frame, anchorX, anchorY, translateX, translateY, scaleX, scaleY, rotation, vertexColor)
    {
        this.manager.setBatch(this, frame.texture.source[frame.sourceIndex].glTexture);

        // The user must check if the buffers are full before flushing
        // this is to give freedom of when should the renderer flush. var vertexDataBuffer = this.vertexDataBuffer;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = vertexDataBuffer.allocate(CONST.SPRITE_VERTEX_COMPONENT_COUNT * CONST.SPRITE_VERTEX_COUNT);
        var uvs = frame.uvs;
        var width = frame.width;
        var height = frame.height;
        var x = width * -anchorX;
        var y = height * -anchorY;
        
        vertexBufferF32[vertexOffset++] = x;
        vertexBufferF32[vertexOffset++] = y;
        vertexBufferF32[vertexOffset++] = uvs.x0;
        vertexBufferF32[vertexOffset++] = uvs.y0;
        vertexBufferF32[vertexOffset++] = translateX;
        vertexBufferF32[vertexOffset++] = translateY;
        vertexBufferF32[vertexOffset++] = scaleX;
        vertexBufferF32[vertexOffset++] = scaleY;
        vertexBufferF32[vertexOffset++] = rotation;
        vertexBufferU32[vertexOffset++] = vertexColor.topLeft;

        vertexBufferF32[vertexOffset++] = x;
        vertexBufferF32[vertexOffset++] = y + height;
        vertexBufferF32[vertexOffset++] = uvs.x1;
        vertexBufferF32[vertexOffset++] = uvs.y1;
        vertexBufferF32[vertexOffset++] = translateX;
        vertexBufferF32[vertexOffset++] = translateY;
        vertexBufferF32[vertexOffset++] = scaleX;
        vertexBufferF32[vertexOffset++] = scaleY;
        vertexBufferF32[vertexOffset++] = rotation;
        vertexBufferU32[vertexOffset++] = vertexColor.bottomLeft;
    
        vertexBufferF32[vertexOffset++] = x + width;
        vertexBufferF32[vertexOffset++] = y + height;
        vertexBufferF32[vertexOffset++] = uvs.x2;
        vertexBufferF32[vertexOffset++] = uvs.y2;
        vertexBufferF32[vertexOffset++] = translateX;
        vertexBufferF32[vertexOffset++] = translateY;
        vertexBufferF32[vertexOffset++] = scaleX;
        vertexBufferF32[vertexOffset++] = scaleY;
        vertexBufferF32[vertexOffset++] = rotation;
        vertexBufferU32[vertexOffset++] = vertexColor.bottomRight;

        vertexBufferF32[vertexOffset++] = x + width;
        vertexBufferF32[vertexOffset++] = y;
        vertexBufferF32[vertexOffset++] = uvs.x3;
        vertexBufferF32[vertexOffset++] = uvs.y3;
        vertexBufferF32[vertexOffset++] = translateX;
        vertexBufferF32[vertexOffset++] = translateY;
        vertexBufferF32[vertexOffset++] = scaleX;
        vertexBufferF32[vertexOffset++] = scaleY;
        vertexBufferF32[vertexOffset++] = rotation;
        vertexBufferU32[vertexOffset++] = vertexColor.topRight;

        this.elementCount += CONST.SPRITE_INDEX_COUNT;
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);

        gl.clearColor(0, 0, 0, 1);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);

        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_INT, 0);

        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height)
    {
        var gl = this.glContext;
        var res = this.game.config.resolution;
        
        this.width = width * res;
        this.height = height * res;
        
        this.view.width = this.width;
        this.view.height = this.height;
        
        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        gl.viewport(0, 0, this.width, this.height);

        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.view.width, 0, 0, 0,
                0, -2 / this.view.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    }

};

module.exports = SpriteBatch32;


/***/ },
/* 317 */
/***/ function(module, exports) {

module.exports = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec2 a_tex_coord;',
    'attribute vec2 a_translate;',
    'attribute vec2 a_scale;',
    'attribute vec3 a_color;',
    'attribute float a_rotation;',
    'varying vec2 v_tex_coord;',
    'varying vec3 v_color;',
    'void main () {',
    '   float t_cos = cos(a_rotation);',
    '   float t_sin = sin(a_rotation);',
    '   vec2 t_position = (a_position );',
    '   t_position = vec2(t_position.x * t_cos - t_position.y * t_sin, t_position.x * t_sin + t_position.y * t_cos);',
    '   gl_Position = u_view_matrix * vec4((t_position * a_scale) + a_translate, 1.0, 1.0);',
    '   v_tex_coord = a_tex_coord;',
    '   v_color = a_color;',
    '}'
].join('\n');


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(10);

var CreateEmptyTexture = function (gl, width, height, scaleMode, textureIndex)
{
    var texture = gl.createTexture();
    var glScaleMode = (scaleMode === ScaleModes.LINEAR) ? gl.LINEAR : gl.NEAREST;

    gl.activeTexture(gl.TEXTURE0 + textureIndex);
    gl.bindTexture(gl.TEXTURE_2D, texture);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    //  We'll read from this texture, but it won't have mipmaps, so turn them off:
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glScaleMode);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glScaleMode);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    return texture;
};

module.exports = CreateEmptyTexture;


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(10);
var CreateTexture2DImage = __webpack_require__(69);

var CreateTexture2DFromSource = function (gl, source)
{
    var filter;

    if (source.scaleMode === ScaleModes.LINEAR)
    {
        filter = gl.LINEAR;
    }
    else if (source.scaleMode === ScaleModes.NEAREST)
    {
        filter = gl.NEAREST;
    }

    source.glTexture = CreateTexture2DImage(gl, source.image, filter, source.mipmapLevel)
};

module.exports = CreateTexture2DFromSource;


/***/ },
/* 320 */
/***/ function(module, exports) {

var Attribute = function (location, size, type, normalized, stride, offset)
{
    this.location = location;
    this.size = size;
    this.type = type;
    this.normalized = normalized;
    this.stride = stride;
    this.offset = offset;
};

module.exports = Attribute;


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {


var Between = __webpack_require__(59);
var GetObjectValue = __webpack_require__(13);

//  Phaser.Sound.Dynamic.FX

//  Based on Sound.js by KittyKatAttack
//  https://github.com/kittykatattack/sound.js

// frequency,      //The sound's fequency pitch in Hertz
// attack,              //The time, in seconds, to fade the sound in
// decay,               //The time, in seconds, to fade the sound out
// type,                //waveform type: "sine", "triangle", "square", "sawtooth"
// volume,         //The sound's maximum volume
// panValue,            //The speaker pan. left: -1, middle: 0, right: 1
// wait,                //The time, in seconds, to wait before playing the sound
// pitchBend,     //The number of Hz in which to bend the sound's pitch down
// reverse,             //If `reverse` is true the pitch will bend up
// random,         //A range, in Hz, within which to randomize the pitch
// dissonance,          //A value in Hz. It creates 2 dissonant frequencies above and below the target pitch
// echo,                //An array: [delayTimeInSeconds, feedbackTimeInSeconds, filterValueInHz]
// reverb,              //An array: [durationInSeconds, decayRateInSeconds, reverse]
// timeout              //A number, in seconds, which is the maximum duration for sound effects

var FX = function (ctx, config)
{
    this.audioContext = ctx;

    this.frequencyValue = GetObjectValue(config, 'frequency', 200);
    this.attack = GetObjectValue(config, 'attack', 0);
    this.decay = GetObjectValue(config, 'decay', 1);
    this.type = GetObjectValue(config, 'type', 'sine');
    this.volumeValue = GetObjectValue(config, 'volume', 1);
    this.panValue = GetObjectValue(config, 'pan', 0);
    this.wait = GetObjectValue(config, 'wait', 0);
    this.pitchBendAmount = GetObjectValue(config, 'pitchBend', 0);
    this.reverse = GetObjectValue(config, 'reverse', false);
    this.randomValue = GetObjectValue(config, 'random', 0);
    this.dissonance = GetObjectValue(config, 'dissonance', 0);
    this.echo = GetObjectValue(config, 'echo', false);
    this.echoDelay = GetObjectValue(config, 'echo.delay', 0);
    this.echoFeedback = GetObjectValue(config, 'echo.feedback', 0);
    this.echoFilter = GetObjectValue(config, 'echo.filter', 0);
    this.reverb = GetObjectValue(config, 'reverb', false);
    this.reverbDuration = GetObjectValue(config, 'reverb.duration', 0);
    this.reverbDecay = GetObjectValue(config, 'reverb.decay', 0);
    this.reverbReverse = GetObjectValue(config, 'reverb.reverse', false);
    this.timeout = GetObjectValue(config, 'timeout', false);

    this.volume = ctx.createGain();
    this.pan = (!ctx.createStereoPanner) ? ctx.createPanner() : ctx.createStereoPanner();

    this.volume.connect(this.pan);
    this.pan.connect(ctx.destination);

    //  Set the values

    this.volume.gain.value = this.volumeValue;

    if (!ctx.createStereoPanner)
    {
        this.pan.setPosition(this.panValue, 0, 1 - Math.abs(this.panValue));
    }
    else
    {
        this.pan.pan.value = this.panValue;
    }

    //  Create an oscillator, gain and pan nodes, and connect them together to the destination

    var oscillator = ctx.createOscillator();

    oscillator.connect(this.volume);
    oscillator.type = this.type;

    //  Optionally randomize the pitch if `randomValue` > 0.
    //  A random pitch is selected that's within the range specified by `frequencyValue`.
    //  The random pitch will be either above or below the target frequency.

    if (this.randomValue > 0)
    {
        oscillator.frequency.value = Between(
            this.frequencyValue - this.randomValue / 2,
            this.frequencyValue + this.randomValue / 2
        );
    }
    else
    {
        oscillator.frequency.value = this.frequencyValue;
    }

    //  Apply effects

    if (this.attack > 0)
    {
        this.fadeIn(this.volume);
    }

    this.fadeOut(this.volume);

    if (this.pitchBendAmount > 0)
    {
        this.pitchBend(oscillator);
    }

    if (this.echo)
    {
        this.addEcho(this.volume);
    }

    if (this.reverb)
    {
        this.addReverb(this.volume);
    }

    if (this.dissonance > 0)
    {
        this.addDissonance();
    }

    this.play(oscillator);

    var _this = this;

    oscillator.onended = function ()
    {
        console.log('onended');
        _this.pan.disconnect();
        _this.volume.disconnect();
    };
};

FX.prototype.constructor = FX;

FX.prototype = {

    play: function (oscillator)
    {
        oscillator.start(this.audioContext.currentTime + this.wait);

        //Oscillators have to be stopped otherwise they accumulate in 
        //memory and tax the CPU. They'll be stopped after a default
        //timeout of 2 seconds, which should be enough for most sound 
        //effects. Override this in the `soundEffect` parameters if you
        //need a longer sound

        oscillator.stop(this.audioContext.currentTime + this.wait + 2);
    },

    fadeIn: function (volume)
    {
        volume.gain.value = 0;

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait);

        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);
    },

    fadeOut: function (volume)
    {
        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait + this.attack + this.decay);
    },

    addReverb: function (volume)
    {
        var convolver = this.audioContext.createConvolver();

        convolver.buffer = this.impulseResponse(this.reverbDuration, this.reverbDecay, this.reverbReverse, this.audioContext);

        volume.connect(convolver);

        convolver.connect(this.pan);
    },

    addEcho: function (volume)
    {
        var feedback = this.audioContext.createGain();
        var delay = this.audioContext.createDelay();
        var filter = this.audioContext.createBiquadFilter();

        //  Set the node values

        feedback.gain.value = this.echoFeedback;
        delay.delayTime.value = this.echoDelay;

        if (this.echoFilter)
        {
            filter.frequency.value = this.echoFilter;
        }

        //  Create the delay feedback loop (with optional filtering)

        delay.connect(feedback);

        if (this.echoFilter)
        {
            feedback.connect(filter);
            filter.connect(delay);
        }
        else
        {
            feedback.connect(delay);
        }

        //  Connect the delay node to the oscillator volume node

        volume.connect(delay);

        //  Connect the delay node to the main sound chains pan node,
        //  so that the echo effect is directed to the correct speaker

        delay.connect(this.pan);
    },

    pitchBend: function (oscillator)
    {
        var frequency = oscillator.frequency.value;

        if (!this.reverse)
        {
            //  If reverse is false, make the sound drop in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency - this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }
        else
        {
            //  If reverse is true, make the sound rise in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency + this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }

    },

    addDissonance: function ()
    {
        //  Create two more oscillators and gain nodes

        var ctx = this.audioContext;

        var d1 = ctx.createOscillator();
        var d2 = ctx.createOscillator();
        var d1Volume = ctx.createGain();
        var d2Volume = ctx.createGain();

        //  Set the volume to the `volumeValue`
        d1Volume.gain.value = this.volumeValue;
        d2Volume.gain.value = this.volumeValue;

        //  Connect the oscillators to the gain and destination nodes
        d1.connect(d1Volume);
        d2.connect(d2Volume);

        d1Volume.connect(ctx.destination);
        d2Volume.connect(ctx.destination);

        //  Set the waveform to "sawtooth" for a harsh effect
        d1.type = 'sawtooth';
        d2.type = 'sawtooth';

        //  Make the two oscillators play at frequencies above and below the main sound's frequency.
        //  Use whatever value was supplied by the `dissonance` argument
        d1.frequency.value = this.frequencyValue + this.dissonance;
        d2.frequency.value = this.frequencyValue - this.dissonance;

        //  Fade in / out, pitch bend and play the oscillators to match the main sound
        if (this.attack > 0)
        {
            this.fadeIn(d1Volume);
            this.fadeIn(d2Volume);
        }

        if (this.decay > 0)
        {
            this.fadeOut(d1Volume);
            this.fadeOut(d2Volume);
        }

        if (this.pitchBendAmount > 0)
        {
            this.pitchBend(d1);
            this.pitchBend(d2);
        }

        if (this.echo)
        {
            this.addEcho(d1Volume);
            this.addEcho(d2Volume);
        }

        if (this.reverb)
        {
            this.addReverb(d1Volume);
            this.addReverb(d2Volume);
        }

        this.play(d1);
        this.play(d2);
    },

    impulseResponse: function (duration, decay, reverse)
    {
        //  The length of the buffer.
        var length = this.audioContext.sampleRate * duration;

        //  Create an audio buffer (an empty sound container) to store the reverb effect.
        var impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);

        //  Use `getChannelData` to initialize empty arrays to store sound data for the left and right channels.
        var left = impulse.getChannelData(0);
        var right = impulse.getChannelData(1);

        //  Loop through each sample-frame and fill the channel data with random noise.
        for (var i = 0; i < length; i++)
        {
            //  Apply the reverse effect, if `reverse` is `true`.
            var n = (reverse) ? length - i : i;

            //  Fill the left and right channels with random white noise which decays exponentially.
            left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
            right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
        }

        //  Return the `impulse`.
        return impulse;
    }

};

module.exports = FX;


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Sound.Dynamic

module.exports = {

    FX: __webpack_require__(321)

};


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Settings = __webpack_require__(70);
var Systems = __webpack_require__(71);

/**
* A Base State Class.
*
* @class Phaser.State
* @constructor
*/
var State = function (config)
{
    //  The properties a State *must* have, that cannot be changed without breaking it:

    this.game = null;

    //  Maybe just an object? Doesn't have to instantiate I don't think ...
    this.settings = new Settings(this, config);

    this.sys = new Systems(this, config);

    //  Reference to sys.children, set during sys.init only
    this.children;
};

State.prototype.constructor = State;

State.prototype = {

    //  Can be overridden by your own States
    preUpdate: function ()
    {
    },

    //  Can be overridden by your own States
    update: function ()
    {
    },

    //  Can be overridden by your own States
    postUpdate: function ()
    {
    },

    //  Can be overridden by your own States
    render: function ()
    {
    }

};

module.exports = State;


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var NOOP = __webpack_require__(72);
var State = __webpack_require__(323);
var Settings = __webpack_require__(70);
var Systems = __webpack_require__(71);
var GetObjectValue = __webpack_require__(13);
// var LoaderEvent = require('../loader/events/');

/**
* The State Manager is responsible for loading, setting up and switching game states.
*
* @class Phaser.StateManager
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var StateManager = function (game, stateConfig)
{
    this.game = game;

    //  Everything kept in here
    this.keys = {};
    this.states = [];

    //  Only active states are kept in here
    this.active = [];

    this._pending = [];

    if (stateConfig)
    {
        if (Array.isArray(stateConfig))
        {
            for (var i = 0; i < stateConfig.length; i++)
            {
                //  The i === 0 part just starts the first State given
                this._pending.push({
                    index: i,
                    key: 'default',
                    state: stateConfig[i],
                    autoStart: (i === 0)
                });
            }
        }
        else
        {
            this._pending.push({
                index: 0,
                key: 'default',
                state: stateConfig,
                autoStart: true
            });
        }
    }
};

StateManager.prototype.constructor = StateManager;

StateManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.StateManager#boot
    * @private
    */
    boot: function ()
    {
        // this.game.onPause.add(this.pause, this);
        // this.game.onResume.add(this.resume, this);

        for (var i = 0; i < this._pending.length; i++)
        {
            var entry = this._pending[i];

            this.add(entry.key, entry.state, entry.autoStart);
        }

        //  Clear the pending list
        this._pending = [];
    },

    getKey: function (key, stateConfig)
    {
        if (!key) { key = 'default'; }

        if (stateConfig instanceof State)
        {
            key = stateConfig.settings.key;
        }
        else if (typeof stateConfig === 'object' && stateConfig.hasOwnProperty('key'))
        {
            key = stateConfig.key;
        }

        //  By this point it's either 'default' or extracted from the State

        if (this.keys.hasOwnProperty(key))
        {
            throw new Error('Cannot add a State with duplicate key: ' + key);
        }
        else
        {
            return key;
        }
    },

    /**
    * Adds a new State into the StateManager. You must give each State a unique key by which you'll identify it.
    * The State can be either a Phaser.State object (or an object that extends it), a plain JavaScript object or a function.
    * If a function is given a new state object will be created by calling it.
    *
    * @method Phaser.StateManager#add
    * @param {string} key - A unique key you use to reference this state, i.e. "MainMenu", "Level1".
    * @param {Phaser.State|object|function} state  - The state you want to switch to.
    * @param {boolean} [autoStart=false]  - If true the State will be started immediately after adding it.
    */
    add: function (key, stateConfig, autoStart)
    {
        if (autoStart === undefined) { autoStart = false; }

        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            this._pending.push({
                index: this._pending.length,
                key: key,
                state: stateConfig,
                autoStart: autoStart
            });

            // console.log('StateManager not yet booted, adding to list', this._pending.length);

            return;
        }

        key = this.getKey(key, stateConfig);

        var newState;

        if (stateConfig instanceof State)
        {
            // console.log('StateManager.add from instance', key);
            newState = this.createStateFromInstance(key, stateConfig);
        }
        else if (typeof stateConfig === 'object')
        {
            // console.log('StateManager.add from object', key);

            stateConfig.key = key;

            newState = this.createStateFromObject(key, stateConfig);
        }
        else if (typeof stateConfig === 'function')
        {
            // console.log('StateManager.add from function', key);

            newState = this.createStateFromFunction(key, stateConfig);
        }

        this.keys[key] = newState;

        this.states.push(newState);

        if (autoStart || newState.settings.active)
        {
            if (this.game.isBooted)
            {
                this.start(key);
            }
            else
            {
                this._start.push(key);
            }
        }

        return newState;
    },

    createStateFromInstance: function (key, newState)
    {
        newState.game = this.game;

        newState.settings.key = key;

        newState.sys.init();

        if (this.game.config.renderType === CONST.WEBGL)
        {
            this.createStateFrameBuffer(newState);
        }

        return newState;
    },

    createStateFromObject: function (key, stateConfig)
    {
        var newState = new State(stateConfig);

        newState.game = this.game;

        newState.sys.init();

        if (this.game.config.renderType === CONST.WEBGL)
        {
            this.createStateFrameBuffer(newState);
        }

        return this.setupCallbacks(newState, stateConfig);
    },

    createStateFromFunction: function (key, state)
    {
        var newState = new state();

        if (newState instanceof State)
        {
            return this.createStateFromInstance(key, newState);
        }
        else
        {
            newState.game = this.game;

            newState.settings = new Settings(newState, key);
            newState.sys = new Systems(newState);

            newState.sys.init();

            if (this.game.config.renderType === CONST.WEBGL)
            {
                this.createStateFrameBuffer(newState);
            }

            //  Default required functions
            return this.setupCallbacks(newState);
        }
    },

    setupCallbacks: function (newState, stateConfig)
    {
        if (stateConfig === undefined) { stateConfig = newState; }

        //  Extract callbacks or set NOOP

        newState.init = GetObjectValue(stateConfig, 'init', NOOP);
        newState.preload = GetObjectValue(stateConfig, 'preload', NOOP);
        newState.create = GetObjectValue(stateConfig, 'create', NOOP);
        newState.shutdown = GetObjectValue(stateConfig, 'shutdown', NOOP);

        newState.preUpdate = GetObjectValue(stateConfig, 'preUpdate', NOOP);
        newState.update = GetObjectValue(stateConfig, 'update', NOOP);
        newState.postUpdate = GetObjectValue(stateConfig, 'postUpdate', NOOP);
        newState.render = GetObjectValue(stateConfig, 'render', NOOP);

        return newState;
    },

    createStateFrameBuffer: function (newState)
    {
        var x = newState.settings.x;
        var y = newState.settings.y;

        if (newState.settings.width === -1)
        {
            newState.settings.width = this.game.config.width;
        }

        if (newState.settings.height === -1)
        {
            newState.settings.height = this.game.config.height;
        }

        var width = newState.settings.width;
        var height = newState.settings.height;

        newState.sys.fbo = this.game.renderer.createFBO(newState, x, y, width, height);
    },

    getState: function (key)
    {
        return this.keys[key];
    },

    getStateIndex: function (state)
    {
        return this.states.indexOf(state);
    },

    getActiveStateIndex: function (state)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state === state)
            {
                return this.active[i].index;
            }
        }

        return -1;
    },

    isActive: function (key)
    {
        var state = this.getState(key);

        return (state && state.settings.active && this.active.indexOf(state) !== -1);
    },

    start: function (key)
    {
        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            // console.log('StateManager not yet booted, setting autoStart on pending list');

            for (var i = 0; i < this._pending.length; i++)
            {
                var entry = this._pending[i];

                if (entry.key === key)
                {
                    entry.autoStart = true;
                }
            }

            return;
        }

        var state = this.getState(key);

        if (state)
        {
            //  Already started? Nothing more to do here ...
            if (this.isActive(key))
            {
                return;
            }

            state.settings.active = true;

            //  + arguments
            if (state.init)
            {
                state.init.call(state);
            }

            if (state.preload && state.sys.load)
            {
                state.sys.load.reset();

                state.preload.call(state, this.game);

                //  Is the loader empty?
                if (state.sys.load.list.size === 0)
                {
                    this.startCreate(state);
                }
                else
                {
                    //  Start the loader going as we have something in the queue

                    state.sys.load.events.once('LOADER_COMPLETE_EVENT', this.loadComplete.bind(this));

                    state.sys.load.start();
                }
            }
            else
            {
                //  No preload? Then there was nothing to load either
                this.startCreate(state);
            }

        }
    },

    loadComplete: function (event)
    {
        var state = event.loader.state;

        //  Make sure to do load-update one last time before state is set to _created

        //  Stop doing this ...
        if (state.hasOwnProperty('loadUpdate'))
        {
            state.loadUpdate.call(state);
        }

        this.startCreate(state);
    },

    startCreate: function (state)
    {
        if (state.create)
        {
            state.create.call(state);
        }

        //  Insert at the correct index, or it just all goes wrong :)

        var i = this.getStateIndex(state);

        this.active.push({ index: i, state: state });

        //  Sort the 'active' array based on the index property
        this.active.sort(this.sortStates.bind(this));

        state.sys.updates.running = true;

        state.sys.mainloop.start();
    },

    pause: function (key)
    {
        var index = this.getActiveStateIndex(key);

        if (index > -1)
        {
            var state = this.getState(key);

            state.settings.active = false;

            this.active.splice(index, 1);

            this.active.sort(this.sortStates.bind(this));
        }
    },

    sortStates: function (stateA, stateB)
    {
        //  Sort descending
        if (stateA.index < stateB.index)
        {
            return -1;
        }
        else if (stateA.index > stateB.index)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    },

    //  See if we can reduce this down to just update and render

    step: function (timestamp)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            if (state.sys.mainloop.running)
            {
                state.sys.mainloop.step(timestamp);
            }
        }
    },

    /*
    preUpdate: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            for (var c = 0; c < state.sys.children.list.length; c++)
            {
                state.sys.children.list[c].preUpdate();
            }

            state.preUpdate();
        }
    },

    update: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            //  Invoke State Main Loop here - updating all of its systems (tweens, physics, etc)

            //  This shouldn't be called if the State is still loading
            //  Have a State.STATUS const in the Settings, dictating what is going on

            for (var c = 0; c < state.sys.children.list.length; c++)
            {
                var child = state.sys.children.list[c];

                if (child.exists)
                {
                    child.update();
                }
            }

            state.update();
        }
    },

    postUpdate: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            for (var c = 0; c < state.sys.children.list.length; c++)
            {
                state.sys.children.list[c].postUpdate();
            }

            state.postUpdate();
        }
    },

    render: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            //  Can put all kinds of other checks in here, like MainLoop, FPS, etc.
            if (!state.settings.visible || state.sys.color.alpha === 0 || state.sys.children.list.length === 0)
            {
                continue;
            }

            this.game.renderer.render(state);
        }
    },
    */

};

module.exports = StateManager;


/***/ },
/* 325 */
/***/ function(module, exports) {


module.exports = {

    PENDING: 0,
    INSTALLED: 1,

    BOOT: 0,
    INIT: 1,
    PRELOAD: 2,
    CREATE: 3,
    UPDATE: 4,
    RENDER: 5,
    SHUTDOWN: 6

};


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var FactoryContainer = __webpack_require__(9);

/**
* The GameObject Factory is a quick way to create many common game objects. The Factory is owned by the State.
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/

var GameObjectFactory = {

    /**
    * @property {Phaser.State} state - The State that owns this Factory
    * @protected
    */
    state: null

};

function init (state)
{
    console.log('Creating GameObjectFactory instance for State');

    GameObjectFactory.state = state;

    //   Load the factories into this Object

    return FactoryContainer.load(GameObjectFactory, true);

    // return GameObjectFactory;
}

module.exports = init;


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(3);
var BaseLoader = __webpack_require__(225);
var NumberArray = __webpack_require__(73);

var ImageFile = __webpack_require__(16);
var JSONFile = __webpack_require__(57);
var XMLFile = __webpack_require__(235);
var BinaryFile = __webpack_require__(232);
var GLSLFile = __webpack_require__(233);
var TextFile = __webpack_require__(234);
var AtlasJSONFile = __webpack_require__(231);

var Loader = function (state)
{
    BaseLoader.call(this);

    /**
    * @property {Phaser.State} state - The State that owns this Factory
    * @protected
    */
    this.state = state;

    this._multilist = {};
};

Loader.prototype = Object.create(BaseLoader.prototype);
Loader.prototype.constructor = Loader;

Loader.prototype.image = function (key, url, xhrSettings)
{
    var file = new ImageFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.json = function (key, url, xhrSettings)
{
    var file = new JSONFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.xml = function (key, url, xhrSettings)
{
    var file = new XMLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.binary = function (key, url, xhrSettings)
{
    var file = new BinaryFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.text = function (key, url, xhrSettings)
{
    var file = new TextFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.glsl = function (key, url, xhrSettings)
{
    var file = new GLSLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.atlas = function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
{
    //  Returns an object with two properties: 'texture' and 'data'
    var files = new AtlasJSONFile(key, textureURL, atlasURL, this.path, textureXhrSettings, atlasXhrSettings);

    this.addFile(files.texture);
    this.addFile(files.data);

    return this;
};

Loader.prototype.multiatlas = function (key, textureURLs, atlasURLs, textureXhrSettings, atlasXhrSettings)
{
    if (typeof textureURLs === 'number')
    {
        var total = textureURLs;

        textureURLs = NumberArray(0, total, key + '-', '.png');
        atlasURLs = NumberArray(0, total, key + '-', '.json');
    }
    else
    {
        if (!Array.isArray(textureURLs))
        {
            textureURLs = [ textureURLs ];
        }

        if (!Array.isArray(atlasURLs))
        {
            atlasURLs = [ atlasURLs ];
        }
    }

    var file;
    var i = 0;
    var multiKey;

    this._multilist[key] = [];

    for (i = 0; i < textureURLs.length; i++)
    {
        multiKey = '_MA_IMG_' + key + '_' + i.toString();

        file = new ImageFile(multiKey, textureURLs[i], this.path, textureXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }

    for (i = 0; i < atlasURLs.length; i++)
    {
        multiKey = '_MA_JSON_' + key + '_' + i.toString();

        file = new JSONFile(multiKey, atlasURLs[i], this.path, atlasXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }
};

//  The Loader has finished
Loader.prototype.processCallback = function ()
{
    if (this.storage.size === 0)
    {
        return;
    }

    //  The global Texture Manager
    var textures = this.state.sys.textures;

    //  Process multiatlas groups first

    var file;

    for (var key in this._multilist)
    {
        var data = [];
        var images = [];
        var keys = this._multilist[key];

        for (var i = 0; i < keys.length; i++)
        {
            file = this.storage.get('key', keys[i]);

            if (file)
            {
                if (file.type === 'image')
                {
                    images.push(file.data);
                }
                else if (file.type === 'json')
                {
                    data.push(file.data);
                }

                this.storage.delete(file);
            }
        }

        //  Do we have everything needed?
        if (images.length + data.length === keys.length)
        {
            //  Yup, add them to the Texture Manager

            //  Is the data JSON Hash or JSON Array?
            if (Array.isArray(data[0].frames))
            {
                textures.addAtlasJSONArray(key, images, data);
            }
            else
            {
                textures.addAtlasJSONHash(key, images, data);
            }
        }
    }

    this.storage.each(function (file)
    {
        if (file.type === 'image')
        {
            textures.addImage(file.key, file.data);
        }
        else if (file.type === 'atlasjson')
        {
            var fileA = file.fileA;
            var fileB = file.fileB;

            if (fileA.type === 'image')
            {
                textures.addAtlas(fileA.key, fileA.data, fileB.data);
            }
            else
            {
                textures.addAtlas(fileB.key, fileB.data, fileA.data);
            }
        }
        else if (file.type === 'json')
        {
            // console.dir(file.data);
        }
    });

    this.storage.clear();
};

module.exports = Loader;


/***/ },
/* 328 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// My thanks to Isaac Sukin for creating MainLoop.js, on which lots of this is based.

var MainLoop = function (state, framerate)
{
    /**
    * @property {Phaser.State} state
    */
    this.state = state;

    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    this.game = state.game;

    // The amount of time (in milliseconds) to simulate each time update() runs.
    this.timestep = 1000 / framerate;

    this.physicsStep = 1 / framerate;

    // The cumulative amount of in-app time that hasn't been simulated yet.
    // See the comments inside animate() for details.
    this.frameDelta = 0;

    // The timestamp in milliseconds of the last time the main loop was run.
    // Used to compute the time elapsed between frames.
    this.lastFrameTimeMs = 0;

    // An exponential moving average of the frames per second.
    this.fps = 60;

    // The timestamp (in milliseconds) of the last time the `fps` moving
    // average was updated.
    this.lastFpsUpdate = 0;

    // The number of frames delivered in the current second.
    this.framesThisSecond = 0;

    // The number of times update() is called in a given frame. This is only
    // relevant inside of animate(), but a reference is held externally so that
    // this variable is not marked for garbage collection every time the main
    // loop runs.
    this.numUpdateSteps = 0;

    // The minimum amount of time in milliseconds that must pass since the last
    // frame was executed before another frame can be executed. The
    // multiplicative inverse caps the FPS (the default of zero means there is
    // no cap).
    this.minFrameDelay = 0;

    // Whether the main loop is running.
    this.running = false;

    // `true` if `MainLoop.start()` has been called and the most recent time it
    // was called has not been followed by a call to `MainLoop.stop()`. This is
    // different than `running` because there is a delay of a few milliseconds
    // after `MainLoop.start()` is called before the application is considered
    // "running." This delay is due to waiting for the next frame.
    this.started = false;

    // Whether the simulation has fallen too far behind real time.
    // Specifically, `panic` will be set to `true` if too many updates occur in
    // one frame. This is only relevant inside of animate(), but a reference is
    // held externally so that this variable is not marked for garbage
    // collection every time the main loop runs.
    this.panic = false;
};

MainLoop.prototype.constructor = MainLoop;

MainLoop.prototype = {

    setMaxFPS: function (fps)
    {
        if (fps === 0)
        {
            this.stop();
        }
        else
        {
            this.minFrameDelay = 1000 / fps;
        }
    },

    getMaxFPS: function ()
    {
        return 1000 / this.minFrameDelay;
    },

    resetFrameDelta: function ()
    {
        var oldFrameDelta = this.frameDelta;

        this.frameDelta = 0;

        return oldFrameDelta;
    },

    start: function ()
    {
        if (this.started)
        {
            return this;
        }

        this.started = true;
        this.running = true;

        this.lastFrameTimeMs = window.performance.now();
        this.lastFpsUpdate = window.performance.now();
        this.framesThisSecond = 0;
    },

    //  timestamp = DOMHighResTimeStamp
    step: function (timestamp)
    {
        // Throttle the frame rate (if minFrameDelay is set to a non-zero value by
        // `MainLoop.setMaxAllowedFPS()`).
        if (timestamp < this.lastFrameTimeMs + this.minFrameDelay)
        {
            return;
        }

        // frameDelta is the cumulative amount of in-app time that hasn't been
        // simulated yet. Add the time since the last frame. We need to track total
        // not-yet-simulated time (as opposed to just the time elapsed since the
        // last frame) because not all actually elapsed time is guaranteed to be
        // simulated each frame. See the comments below for details.
        this.frameDelta += timestamp - this.lastFrameTimeMs;
        this.lastFrameTimeMs = timestamp;

        // Run any updates that are not dependent on time in the simulation.

        //  Here we'll need to run things like tween.update, input.update, etc.
        this.state.sys.begin(timestamp, this.frameDelta);

        // Update the estimate of the frame rate, `fps`. Every second, the number
        // of frames that occurred in that second are included in an exponential
        // moving average of all frames per second, with an alpha of 0.25. This
        // means that more recent seconds affect the estimated frame rate more than
        // older seconds.
        if (timestamp > this.lastFpsUpdate + 1000)
        {
            // Compute the new exponential moving average with an alpha of 0.25.
            // Using constants inline is okay here.
            this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;

            this.lastFpsUpdate = timestamp;
            this.framesThisSecond = 0;
        }

        this.framesThisSecond++;

        this.numUpdateSteps = 0;

        var step = this.timestep;

        while (this.frameDelta >= step)
        {
            // this.update(this.timestep);

            this.state.sys.update(step, this.physicsStep);

            for (var c = 0; c < this.state.sys.children.list.length; c++)
            {
                var child = this.state.sys.children.list[c];

                if (child.exists)
                {
                    child.update(step);
                }
            }

            //  Dev level callback
            this.state.update(step);

            this.frameDelta -= this.timestep;

            if (++this.numUpdateSteps >= 240)
            {
                this.panic = true;
                break;
            }
        }

        this.state.sys.preRender();

        this.state.sys.updates.start();

        if (this.state.settings.visible && this.state.sys.color.alpha !== 0)
        {
            this.game.renderer.render(this.state, this.frameDelta / this.timestep);
        }

        this.state.sys.updates.stop();

        // Run any updates that are not dependent on time in the simulation.
        this.state.sys.end(this.fps, this.panic);

        this.panic = false;
    },

    /*
    update: function (timestep)
    {
        this.state.sys.update(timestep);

        var c;
        var child;

        for (var c = 0; c < this.state.sys.children.list.length; c++)
        {
            var child = this.state.sys.children.list[c];

            if (child.exists)
            {
                child.update(timestep);
            }
        }

        //  Dev level callback
        this.state.update(timestep);

        for (c = 0; c < this.state.sys.children.list.length; c++)
        {
            var child = this.state.sys.children.list[c];

            if (child.exists)
            {
                child.update(timestep);
            }
        }
    },
    */

    stop: function ()
    {
        this.running = false;
        this.started = false;

        return this;
    }

};

module.exports = MainLoop;


/***/ },
/* 329 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Dirty! Manager
*
* @class
*/
var UpdateManager = function (state)
{
    this.state = state;

    this.game = state.game;

    this.list = [];

    // this.i = 1;

    this.running = false;
    
    this.processed = 0;
};

UpdateManager.prototype.constructor = UpdateManager;

UpdateManager.prototype = {

    stop: function ()
    {
        if (!this.running)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.stop', this.processed);

        this.list.length = 0;

        // this.i++;
    },

    start: function ()
    {
        if (!this.running)
        {
            return;
        }

        var len = this.list.length;

        if (len === 0)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.start', len);

        this.processed = 0;

        for (var i = 0; i < len; i++)
        {
            //  Because it may have already been processed (as a child of another Transform that was updated)
            if (this.list[i] && this.list[i]._dirty)
            {
                this.processed++;
                this.list[i].update();
            }
        }
    },

    add: function (transform)
    {
        this.list.push(transform);
    }

};

module.exports = UpdateManager;


/***/ },
/* 330 */
/***/ function(module, exports) {

// A Set is a collection of unique elements.

var Set = function (elements)
{
    this.entries = [];

    if (Array.isArray(elements))
    {
        for (var i = 0; i < elements.length; i++)
        {
            this.add(elements[i]);
        }
    }
};

Set.prototype.constructor = Set;

Set.prototype = {

    set: function (value)
    {
        if (this.entries.indexOf(value) === -1)
        {
            this.entries.push(value);
        }

        return this;
    },

    get: function (property, value)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];

            if (entry[property] === value)
            {
                return entry;
            }
        }
    },

    delete: function (value)
    {
        var index = this.entries.indexOf(value);

        if (index > -1)
        {
            this.entries.splice(index, 1);
        }

        return this;
    },

    dump: function ()
    {
        console.group('Set');

        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];
            console.log(entry);
        }

        console.groupEnd();
    },


    //  For when you know this Set will be modified during the iteration
    each: function (callback)
    {
        var temp = this.entries.slice();

        for (var i = 0; i < temp.length; i++)
        {
            if (callback(temp[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    //  For when you absolutely know this Set won't be modified during the iteration
    iterate: function (callback)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            if (callback(this.entries[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    clear: function ()
    {
        this.entries.length = 0;

        return this;
    },

    contains: function (value)
    {
        return (this.entries.indexOf(value) > -1);
    },

    union: function (set)
    {
        var newSet = new Set();

        set.values.forEach(function (value)
        {
            newSet.add(value);
        });

        this.entries.forEach(function (value)
        {
            newSet.add(value);
        });

        return newSet;
    },

    intersect: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    },

    difference: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (!set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    }

};

Object.defineProperties(Set.prototype, {

    size: {

        enumerable: true,

        get: function ()
        {
            return this.entries.length;
        },

        set: function (value)
        {
            return this.entries.length = value;
        }

    }

});

module.exports = Set;


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Extend = __webpack_require__(17);

/**
* A Frame is a section of a Texture.
*
* @class Phaser.Frame
* @constructor
* @param {Phaser.Texture} texture - The Texture this Frame belongs to.
* @param {string} name - The unique (within the Texture) name of this Frame.
* @param {number} x - X position of the frame within the Texture.
* @param {number} y - Y position of the frame within the Texture.
* @param {number} width - Width of the frame within the Texture.
* @param {number} height - Height of the frame within the Texture.
*/
var Frame = function (texture, name, sourceIndex, x, y, width, height)
{
    /**
    * @property {Phaser.Texture} texture - The Texture this frame belongs to.
    */
    this.texture = texture;

    /**
    * @property {string} name - The name of this frame within the Texture.
    */
    this.name = name;

    this.source = texture.source[sourceIndex];

    this.sourceIndex = sourceIndex;

    /**
    * @property {number} cutX - X position within the source image to cut from.
    */
    this.cutX = x;

    /**
    * @property {number} cutY - Y position within the source image to cut from.
    */
    this.cutY = y;

    /**
    * @property {number} cutWidth - The width of the area in the source image to cut.
    */
    this.cutWidth = width;

    /**
    * @property {number} cutHeight - The height of the area in the source image to cut.
    */
    this.cutHeight = height;

    /**
    * @property {number} x - The X rendering offset of this Frame, taking trim into account.
    */
    this.x = 0;

    /**
    * @property {number} y - The Y rendering offset of this Frame, taking trim into account.
    */
    this.y = 0;

    /**
    * @property {number} width - The rendering width of this Frame, taking trim into account.
    */
    this.width = width;

    /**
    * @property {number} height - The rendering height of this Frame, taking trim into account.
    */
    this.height = height;

    /**
    * Is this frame is rotated or not in the Texture?
    * Rotation allows you to use rotated frames in texture atlas packing.
    * It has nothing to do with Sprite rotation.
    *
    * @property {boolean} rotated
    * @default
    */
    this.rotated = false;

    /**
    * Is this a tiling texture? As used by the likes of a TilingSprite.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} isTiling
    * @default
    */
    this.isTiling = false;

    /**
    * This will let a renderer know that a tinted parent has updated its texture.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} requiresReTint
    * @default
    */
    this.requiresReTint = false;

    //  Over-rides the Renderer setting? -1 = use Renderer Setting, 0 = No rounding, 1 = Round
    this.autoRound = -1;

    /**
    * The un-modified source frame, trim and UV data.
    *
    * @private
    * @property {object} data
    */
    this.data = {
        cut: {
            x: x,
            y: y,
            w: width,
            h: height,
            r: x + width,
            b: y + height
        },
        trim: false,
        sourceSize: {
            w: width,
            h: height
        },
        spriteSourceSize: {
            x: 0,
            y: 0,
            w: width,
            h: height
        },
        uvs: {
            x0: 0,
            y0: 0,
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            x3: 0,
            y3: 0
        },
        drawImage: {
            sx: x,
            sy: y,
            sWidth: width,
            sHeight: height,
            dWidth: width,
            dHeight: height
        }
    };

    this.updateUVs();
};

Frame.prototype.constructor = Frame;

Frame.prototype = {

    /**
    * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.
    *
    * @method Phaser.TextureFrame#setTrim
    * @param {number} actualWidth - The width of the frame before being trimmed.
    * @param {number} actualHeight - The height of the frame before being trimmed.
    * @param {number} destX - The destination X position of the trimmed frame for display.
    * @param {number} destY - The destination Y position of the trimmed frame for display.
    * @param {number} destWidth - The destination width of the trimmed frame for display.
    * @param {number} destHeight - The destination height of the trimmed frame for display.
    */
    setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)
    {
        var data = this.data;
        var ss = data.spriteSourceSize;
        var di = data.drawImage;

        //  Store actual values

        data.trim = true;

        data.sourceSize.w = actualWidth;
        data.sourceSize.h = actualHeight;

        ss.x = destX;
        ss.y = destY;
        ss.w = destWidth;
        ss.h = destHeight;

        //  Adjust properties
        this.x = destX;
        this.y = destY;
        this.width = destWidth;
        this.height = destHeight;

        //  drawImage data
        // di.sx = destX;
        // di.sy = destY;
        // di.sWidth = destWidth;
        // di.sHeight = destHeight;
        // di.dWidth = destWidth;
        // di.dHeight = destHeight;

        this.updateUVs();

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVs
    * @private
    */
    updateUVs: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x0 = this.cutX / tw;
        uvs.y0 = this.cutY / th;

        uvs.x1 = this.cutX / tw;
        uvs.y1 = (this.cutY + this.cutHeight) / th;

        uvs.x2 = (this.cutX + this.cutWidth) / tw;
        uvs.y2 = (this.cutY + this.cutHeight) / th;

        uvs.x3 = (this.cutX + this.cutWidth) / tw;
        uvs.y3 = this.cutY / th;

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVsInverted
    * @private
    */
    updateUVsInverted: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x3 = (this.cutX + this.cutHeight) / tw;
        uvs.y3 = (this.cutY + this.cutWidth) / th;

        uvs.x2 = this.cutX / tw;        
        uvs.y2 = (this.cutY + this.cutWidth) / th;
        
        uvs.x1 = this.cutX / tw;
        uvs.y1 = this.cutY / th;
        
        uvs.x0 = (this.cutX + this.cutHeight) / tw;
        uvs.y0 = this.cutY / th;

        return this;
    },

    clone: function ()
    {
        var clone = new Frame(this.texture, this.name, this.sourceIndex);

        clone.cutX = this.cutX;
        clone.cutY = this.cutY;
        clone.cutWidth = this.cutWidth;
        clone.cutHeight = this.cutHeight;

        clone.x = this.x;
        clone.y = this.y;
        clone.width = this.width;
        clone.height = this.height;

        clone.rotated = this.rotated;

        clone.data = Extend(true, clone.data, this.data);

        clone.updateUVs();

        return clone;
    },

    destroy: function ()
    {
    }

};

Object.defineProperties(Frame.prototype, {

    /**
    * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realWidth
    * @property {any} realWidth
    */
    realWidth: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.w;
        }

    },

    /**
    * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realHeight
    * @property {any} realHeight
    */
    realHeight: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.h;
        }

    },

    /**
    * UVs
    *
    * @name Phaser.TextureFrame#uvs
    * @property {Object} uvs
    */
    uvs: {

        enumerable: true,

        get: function ()
        {
            return this.data.uvs;
        }

    },

    /**
    * Canvas Draw Image data
    *
    * @name Phaser.TextureFrame#canvasData
    * @property {Object} canvasData
    */
    canvasData: {

        enumerable: true,

        get: function ()
        {
            return this.data.drawImage;
        }

    }

});

module.exports = Frame;


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Frame = __webpack_require__(331);
var TextureSource = __webpack_require__(334);

/**
* A Texture consists of a source, usually an Image from the Cache, or a Canvas, and a collection
* of Frames. The Frames represent the different areas of the Texture. For example a texture atlas
* may have many Frames, one for each element within the atlas. Where-as a single image would have
* just one frame, that encompasses the whole image.
*
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* @class Phaser.Texture
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var Texture = function (manager, key, source)
{
    this.manager = manager;

    if (!Array.isArray(source))
    {
        source = [ source ];
    }

    this.key = key;

    /**
    * The source that is used to create the texture.
    * Usually an Image, but can also be a Canvas.
    *
    * @property source
    * @type array
    */
    this.source = [];

    /**
    * @property {object} frames - Frames
    */
    this.frames = {};

    this.frameTotal = 0;

    //  Load the Sources
    for (var i = 0; i < source.length; i++)
    {
        this.source.push(new TextureSource(this, source[i]));
    }
};

Texture.prototype.constructor = Texture;

Texture.prototype = {

    add: function (name, sourceIndex, x, y, width, height)
    {
        var frame = new Frame(this, name, sourceIndex, x, y, width, height);

        this.frames[name] = frame;

        this.frameTotal++;

        return frame;
    },

    get: function (name)
    {
        if (name === undefined || name === null || this.frameTotal === 1)
        {
            name = '__BASE';
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'];
        }
        else
        {
            return frame;
        }
    },

    setTextureIndex: function (index)
    {
        for (var i = 0; i < this.source.length; i++)
        {
            this.source[i].glTextureIndex = index;

            console.log(this.source[i].image.currentSrc, 'index = ', index);

            index++;
        }

        return index;
    },

    /**
    * Destroys this base texture
    *
    * @method destroy
    */
    destroy: function ()
    {
        //  Need to iterate though the TextureSources, and unload each one
        //  then clear out the frames

        /*
        if (this.source)
        {
            Phaser.CanvasPool.removeByCanvas(this.source);
        }

        this.source = null;
        */
    }

};

/**
* Helper function that creates a base texture from the given canvas element.
*
* @static
* @method fromCanvas
* @param canvas {Canvas} The canvas element source of the texture
* @param scaleMode {Number} See {{#crossLink "PIXI/scaleModes:property"}}Phaser.scaleModes{{/crossLink}} for possible values
* @return {BaseTexture}
Phaser.Texture.fromCanvas = function (canvas, scaleMode)
{
    if (canvas.width === 0)
    {
        canvas.width = 1;
    }

    if (canvas.height === 0)
    {
        canvas.height = 1;
    }

    return new Phaser.Texture(canvas, scaleMode);
};
*/

module.exports = Texture;


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Parser = __webpack_require__(342);
var Texture = __webpack_require__(332);

/**
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* Access it via `state.textures`.
*
* @class Phaser.TextureManager
* @constructor
*/
var TextureManager = function (game)
{
    this.game = game;

    this.list = {};
};

TextureManager.prototype.constructor = TextureManager;

TextureManager.prototype = {

    addImage: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Image(texture, 0);

        return texture;
    },

    addCanvas: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Canvas(texture, 0);

        return texture;
    },

    addAtlas: function (key, source, data)
    {
        //  Is it a Hash or an Array?

        if (Array.isArray(data.frames))
        {
            return this.addAtlasJSONArray(key, source, data);
        }
        else
        {
            return this.addAtlasJSONHash(key, source, data);
        }
    },

    addAtlasJSONArray: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONArray(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONArray(texture, 0, data);
        }

        return texture;
    },

    addAtlasJSONHash: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONHash(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONHash(texture, 0, data);
        }

        return texture;
    },

    addSpriteSheet: function (key, source, frameWidth, frameHeight, startFrame, endFrame, margin, spacing)
    {
        var texture = this.create(key, source);

        var width = texture.source[0].width;
        var height = texture.source[0].height;

        Parser.SpriteSheet(texture, 0, 0, 0, width, height, frameWidth, frameHeight, startFrame, endFrame, margin, spacing);

        return texture;
    },

    addSpriteSheetFromAtlas: function (key, atlasKey, atlasFrame, frameWidth, frameHeight, startFrame, endFrame, margin, spacing)
    {
        var atlas = this.get(atlasKey);
        var sheet = atlas.get(atlasFrame);

        if (sheet)
        {
            var texture = this.create(key, sheet.source.image);

            Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, frameWidth, frameHeight, startFrame, endFrame, margin, spacing);

            return texture;
        }
    },

    addAtlasStarlingXML: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.StarlingXML(texture, i, data[i]);
            }
        }
        else
        {
            Parser.StarlingXML(texture, 0, data);
        }

        return texture;
    },

    addAtlasPyxel: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.Pyxel(texture, i, data[i]);
            }
        }
        else
        {
            Parser.Pyxel(texture, 0, data);
        }

        return texture;
    },

    create: function (key, source)
    {
        var texture = new Texture(this, key, source);

        this.list[key] = texture;

        return texture;
    },

    exists: function (key)
    {
        return (this.list.hasOwnProperty(key));
    },

    get: function (key)
    {
        if (key === undefined) { key = '__DEFAULT'; }

        if (this.list[key])
        {
            return this.list[key];
        }
        else
        {
            return this.list['__MISSING'];
        }
    },

    cloneFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame).clone();
        }
    },

    getFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame);
        }
    },

    setTexture: function (gameObject, key, frame)
    {
        if (this.list[key])
        {
            gameObject.texture = this.list[key];
            gameObject.frame = gameObject.texture.get(frame);
        }

        return gameObject;
    },

    /**
    * Passes all Textures to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var texture in this.list)
        {
            args[0] = this.list[texture];

            callback.apply(thisArg, args);
        }
    }

};

module.exports = TextureManager;


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var ScaleModes = __webpack_require__(10);
var IsSizePowerOfTwo = __webpack_require__(66);
var CreateTexture2DFromSource = __webpack_require__(319);

/**
*
* @class Phaser.TextureSource
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var TextureSource = function (texture, source)
{
    this.texture = texture;

    this.image = source;

    this.compressionAlgorithm = null;

    /**
    * The Resolution of the texture.
    *
    * @property resolution
    * @type Number
    */
    this.resolution = 1;
    
    /**
    * The width of the Texture.
    *
    * @property width
    * @type Number
    * @readOnly
    */
    this.width = source.naturalWidth || source.width || 0;

    /**
    * The height of the Texture.
    *
    * @property height
    * @type Number
    * @readOnly
    */
    this.height = source.naturalHeight || source.height || 0;

    /**
    * The scale mode to apply when scaling this texture.
    * NEAREST or DEFAULT
    *
    * @property scaleMode
    * @type {Number}
    * @default Phaser.scaleModes.DEFAULT;
    */
    this.scaleMode = ScaleModes.DEFAULT;

    /**
    * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
    *
    * @property premultipliedAlpha
    * @type Boolean
    * @default true
    */
    this.premultipliedAlpha = true;

    /**
    * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
    * Also the texture must be a power of two size to work
    *
    * @property mipmapLevel
    * @type {integer}
    */
    this.mipmapLevel = 0;

    /**
    * A BaseTexture can be set to skip the rendering phase in the WebGL Sprite Batch.
    *
    * You may want to do this if you have a parent Sprite with no visible texture (i.e. uses the internal `__default` texture)
    * that has children that you do want to render, without causing a batch flush in the process.
    *
    * @property renderable
    * @type Boolean
    */
    this.renderable = true;

    /**
    * @property isPowerOf2
    * @type boolean
    */
    this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);

    /**
    * @property glTexture
    */
    this.glTexture = null;

    /**
    * The multi texture batching index number.
    * @property glTextureIndex
    * @type Number
    */
    this.glTextureIndex = 0;

    /**
    * The timestamp when this texture was last used by the WebGL renderer.
    * Can be used to purge out 'dead' textures from GPU memory.
    * @property glLastUsed
    * @type Number
    */
    this.glLastUsed = 0;

    /**
    * @property glDirty
    */
    this.glDirty = true;

    var game = texture.manager.game;

    if (game.config.renderType === CONST.WEBGL)
    {
        CreateTexture2DFromSource(game.renderer.gl, this);
    }
};

module.exports = TextureSource;


/***/ },
/* 335 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var CanvasTextureParser = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = CanvasTextureParser;


/***/ },
/* 336 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var ImageTextureParser = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = ImageTextureParser;


/***/ },
/* 337 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Array format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONArrayTextureParser = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Array given, missing \'frames\' array');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed array
    var frames = json['frames'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        var src = frames[i];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
        }
    }

    return texture;
};

module.exports = JSONArrayTextureParser;


/***/ },
/* 338 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in JSON Hash format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONHashTextureParser = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Hash given, missing \'frames\' Object');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed Object
    var frames = json['frames'];
    var newFrame;

    for (var key in frames)
    {
        var src = frames[key];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
        }
    }

    return texture;
};

module.exports = JSONHashTextureParser;


/***/ },
/* 339 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a Pyxel JSON File and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Pyxel JSON format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var PyxelTextureParser = function (texture, json)
{
    //  Malformed? There are a few keys to check here.
    var signature = [ 'layers', 'tilewidth', 'tileheight', 'tileswide', 'tileshigh' ];

    signature.forEach(function (key)
    {
        if (!json[key])
        {
            // console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + key + '" key.');
            // console.log(json);
            return;
        }
    });

    // For this purpose, I only care about parsing tilemaps with a single layer.
    if (json['layers'].length !== 1)
    {
        // console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.');
        // console.log(json);
        return;
    }

    var data = new Phaser.FrameData();

    var tileheight = json['tileheight'];
    var tilewidth = json['tilewidth'];

    var frames = json['layers'][0]['tiles'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        newFrame = data.addFrame(new Phaser.Frame(
            i,
            frames[i].x,
            frames[i].y,
            tilewidth,
            tileheight,
            "frame_" + i  // No names are included in pyxel tilemap data.
        ));

        // No trim data is included.
        newFrame.setTrim(false);
    }

    return data;
};

module.exports = PyxelTextureParser;


/***/ },
/* 340 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.SpriteSheet
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @param {number} frameWidth - The fixed width of each frame.
* @param {number} frameHeight - The fixed height of each frame.
* @param {number} [startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
* @param {number} [endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
* @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.
* @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var SpriteSheetTextureParser = function (texture, sourceIndex, x, y, width, height, frameWidth, frameHeight, startFrame, endFrame, margin, spacing)
{
    if (startFrame === undefined) { startFrame = 0; }
    if (endFrame === undefined) { endFrame = -1; }
    if (margin === undefined) { margin = 0; }
    if (spacing === undefined) { spacing = 0; }

    var row = Math.floor((width - margin) / (frameWidth + spacing));
    var column = Math.floor((height - margin) / (frameHeight + spacing));
    var total = row * column;

    if (startFrame > total || startFrame < -total)
    {
        startFrame = 0;
    }

    if (startFrame < 0)
    {
        //  Allow negative skipframes.
        startFrame = total + startFrame;
    }

    if (endFrame !== -1)
    {
        total = startFrame + (endFrame + 1);
    }

    var fx = margin;
    var fy = margin;
    var ax = 0;
    var ay = 0;

    for (var i = 0; i < total; i++)
    {
        ax = 0;
        ay = 0;

        var w = fx + frameWidth;
        var h = fy + frameHeight;

        if (w > width)
        {
            ax = w - width;
        }

        if (h > height)
        {
            ay = h - height;
        }

        texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);

        fx += frameWidth + spacing;

        if (fx + frameWidth > width)
        {
            fx = margin;
            fy += frameHeight + spacing;
        }
    }

    return texture;
};

module.exports = SpriteSheetTextureParser;


/***/ },
/* 341 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses the XML and extracts the frame data from it.
*
* @class Phaser.TextureParser.StarlingXML
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} xml - The XML data from the Texture Atlas. Must be in Starling XML format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var StarlingXMLTextureParser = function (texture, xml)
{
    //  Malformed?
    if (!xml.getElementsByTagName('TextureAtlas'))
    {
        // console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
        return;
    }

    //  Let's create some frames then
    var data = new Phaser.FrameData();
    var frames = xml.getElementsByTagName('SubTexture');
    var newFrame;

    var name;
    var frame;
    var x;
    var y;
    var width;
    var height;
    var frameX;
    var frameY;
    var frameWidth;
    var frameHeight;

    for (var i = 0; i < frames.length; i++)
    {
        frame = frames[i].attributes;

        name = frame.name.value;
        x = parseInt(frame.x.value, 10);
        y = parseInt(frame.y.value, 10);
        width = parseInt(frame.width.value, 10);
        height = parseInt(frame.height.value, 10);

        frameX = null;
        frameY = null;

        if (frame.frameX)
        {
            frameX = Math.abs(parseInt(frame.frameX.value, 10));
            frameY = Math.abs(parseInt(frame.frameY.value, 10));
            frameWidth = parseInt(frame.frameWidth.value, 10);
            frameHeight = parseInt(frame.frameHeight.value, 10);
        }

        newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name));

        //  Trimmed?
        if (frameX !== null || frameY !== null)
        {
            newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);
        }
    }

    return data;

};

module.exports = StarlingXMLTextureParser;


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {


module.exports = {
    Canvas: __webpack_require__(335),
    Image: __webpack_require__(336),
    SpriteSheet: __webpack_require__(340),
    JSONArray: __webpack_require__(337),
    JSONHash: __webpack_require__(338),
    StarlingXML: __webpack_require__(341),
    Pyxel: __webpack_require__(339)
};


/***/ },
/* 343 */
/***/ function(module, exports) {

/**
* Snaps a value to the nearest value in an array.
* The result will always be in the range `[first_value, last_value]`.
*
* @method
* @param {number} value - The search value
* @param {number[]} arr - The input array which _must_ be sorted.
* @return {number} The nearest value found.
*/
var FindClosestInSorted = function (value, array)
{
    if (!array.length)
    {
        return NaN;
    }
    else if (array.length === 1 || value < array[0])
    {
        return array[0];
    }

    var i = 1;

    while (array[i] < value)
    {
        i++;
    }

    var low = array[i - 1];
    var high = (i < array.length) ? array[i] : Number.POSITIVE_INFINITY;

    return ((high - value) <= (value - low)) ? high : low;
};

module.exports = FindClosestInSorted;


/***/ },
/* 344 */
/***/ function(module, exports) {

/**
* Fetch a random entry from the given array.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was selected.
*/

var GetRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return (array[randomIndex] === undefined) ? null : array[randomIndex];
};

module.exports = GetRandomElement;


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

var RoundAwayFromZero = __webpack_require__(63);

/**
* Create an array of numbers (positive and/or negative) progressing from `start`
* up to but not including `end` by advancing by `step`.
*
* If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.
*
* Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;
* for forward compatibility make sure to pass in actual numbers.
*
* @method Phaser.ArrayUtils#numberArrayStep
* @param {number} start - The start of the range.
* @param {number} [end] - The end of the range.
* @param {number} [step=1] - The value to increment or decrement by.
* @returns {Array} Returns the new array of numbers.
* @example
* NumberArrayStep(4);
* // => [0, 1, 2, 3]
*
* NumberArrayStep(1, 5);
* // => [1, 2, 3, 4]
*
* NumberArrayStep(0, 20, 5);
* // => [0, 5, 10, 15]
*
* NumberArrayStep(0, -4, -1);
* // => [0, -1, -2, -3]
*
* NumberArrayStep(1, 4, 0);
* // => [1, 1, 1]
*
* NumberArrayStep(0);
* // => []
*/
var NumberArrayStep = function (start, end, step)
{
    if (start === undefined) { start = 0; }
    if (end === undefined) { end = null; }
    if (step === undefined) { step = 1; }

    if (end === null)
    {
        end = start;
        start = 0;
    }

    var result = [];

    var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);

    for (var i = 0; i < total; i++)
    {
        result.push(start);
        start += step;
    }

    return result;
};

module.exports = NumberArrayStep;


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

var SpliceOne = __webpack_require__(74);

/**
* Removes a random object from the given array and returns it.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was removed.
*/

var RemoveRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return SpliceOne(array, randomIndex);
};

module.exports = RemoveRandomElement;


/***/ },
/* 347 */
/***/ function(module, exports) {

/**
* Moves the element at the start of the array to the end, shifting all items in the process.
* The "rotation" happens to the left.
*
* @method Phaser.ArrayUtils.rotate
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateLeft = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.shift();
        array.push(element);
    }

    return element;
};

module.exports = RotateLeft;


/***/ },
/* 348 */
/***/ function(module, exports) {

/**
* Moves the element at the end of the array to the start, shifting all items in the process.
* The "rotation" happens to the right.
*
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateRight = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.pop();
        array.unshift(element);
    }

    return element;
};

module.exports = RotateRight;


/***/ },
/* 349 */
/***/ function(module, exports) {

/**
* A standard Fisher-Yates Array shuffle implementation which modifies the array in place.
*
* @method
* @param {any[]} array - The array to shuffle.
* @return {any[]} The original array, now shuffled.
*/
var Shuffle = function (array)
{
    for (var i = array.length - 1; i > 0; i--)
    {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    return array;
};

module.exports = Shuffle;


/***/ },
/* 350 */
/***/ function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {__webpack_require__(82);

var CONST = __webpack_require__(1);
var Extend = __webpack_require__(17);

//  This object is exported globally

var Phaser = {

    Game: __webpack_require__(76),

    Event: __webpack_require__(14),
    EventDispatcher: __webpack_require__(15),

    Math: __webpack_require__(81),

    Geom: __webpack_require__(80),

    GameObjects: {

        Factory: __webpack_require__(9)

    },

    Loader: {

        ImageFile: __webpack_require__(16)

    },

    Sound: __webpack_require__(83),

    Utils: {

        Array: __webpack_require__(84),
        Objects: __webpack_require__(85)

    }

};

//  Required, but don't need Phaser level exports

__webpack_require__(77);
__webpack_require__(79);
__webpack_require__(78);

//   Merge in the consts

Phaser = Extend(false, Phaser, CONST);

//  Export it

module.exports = Phaser;

global.Phaser = Phaser;

/*
 * Sometimes, the elegant implementation is just a function.
 * Not a method. Not a class. Not a framework. Just a function.
 * - John Carmack
 */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(38)))

/***/ }
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA5ZTk4ZGVlYzFiNDI0YjRmNjIxZSIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9jb25zdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9PUy5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL09TLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9Ccm93c2VyLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvQW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL0ZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvU2NhbGVNb2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9XcmFwLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL1dyYXAuanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2FuZ2xlL1dyYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL0dldE9iamVjdFZhbHVlLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlLmpzIiwid2VicGFjazovLy8uLi91dGlscy9vYmplY3QvRXh0ZW5kLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvb2JqZWN0L0V4dGVuZC5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9DYW52YXNQb29sLmpzIiwid2VicGFjazovLy9zcmMvZG9tL0NhbnZhc1Bvb2wuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL0dhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9Db250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvRmluZFQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9HZXRQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaGVybWl0ZS9HZXRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1JvdGF0ZUFyb3VuZFhZLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0RvdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvR2V0QXNwZWN0UmF0aW8uanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9YSFJTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvYnVmZmVyL0NyZWF0ZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvYnVmZmVyL0luZGV4QnVmZmVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9idWZmZXIvVmVydGV4QnVmZmVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9zaGFkZXIvQ3JlYXRlUHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0JpbmRWZXJ0ZXhBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYy5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL1ZlcnRleEFycmF5LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9DYW52YXNGZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9DYW52YXNGZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL0ZlYXR1cmVzLmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL0ZlYXR1cmVzLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL0VsbGlwc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9HZXRBbmdsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaGVybWl0ZS9HZXRBbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9MaW5lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0dldE1hZ25pdHVkZVNxLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L011bHRpcGx5LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L05vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvTm9ybWFsaXplLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9seWdvbi9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9Db250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL01lcmdlWEhSU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvSlNPTkZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvQmVybnN0ZWluLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9CZXJuc3RlaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvQmV0d2Vlbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9DYXRtdWxsUm9tLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0ZhY3RvcmlhbC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9MaW5lYXIuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvUm91bmRBd2F5RnJvbVplcm8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvTm9ybWFsaXplLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlQmV0d2Vlbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9wb3cyL0lzU2l6ZVBvd2VyT2ZUd28uanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL0JsZW5kTW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL2NvbnN0LmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJESW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL1NldHRpbmdzLmpzIiwid2VicGFjazovLy9zcmMvc3RhdGUvU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL1N5c3RlbXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9TeXN0ZW1zLmpzIiwid2VicGFjazovLy8uLi91dGlscy9OT09QLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9OdW1iZXJBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvU3BsaWNlT25lLmpzIiwid2VicGFjazovLy8uLi91dGlscy9vYmplY3QvSXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vYm9vdC9HYW1lLmpzIiwid2VicGFjazovLy9zcmMvYm9vdC9HYW1lLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9wb2x5ZmlsbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vc291bmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9zb3VuZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvb2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvb2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2Jvb3QvQ29uZmlnLmpzIiwid2VicGFjazovLy9zcmMvYm9vdC9Db25maWcuanMiLCJ3ZWJwYWNrOi8vLy4uL2Jvb3QvQ3JlYXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ib290L0NyZWF0ZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9ib290L0RlYnVnSGVhZGVyLmpzIiwid2VicGFjazovLy9zcmMvYm9vdC9EZWJ1Z0hlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vY2FtZXJhL0NhbWVyYS5qcyIsIndlYnBhY2s6Ly8vc3JjL2NhbWVyYS9DYW1lcmEuanMiLCJ3ZWJwYWNrOi8vLy4uL2NoZWNrc3VtLmpzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL0NvbG9yLmpzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvVHJhbnNmb3JtLmpzIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9UcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9BdWRpby5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9BdWRpby5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL0Z1bGxzY3JlZW4uanMiLCJ3ZWJwYWNrOi8vL3NyYy9kZXZpY2UvRnVsbHNjcmVlbi5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL0lucHV0LmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL0lucHV0LmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvVmlkZW8uanMiLCJ3ZWJwYWNrOi8vL3NyYy9kZXZpY2UvVmlkZW8uanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL0FkZFRvRE9NLmpzIiwid2VicGFjazovLy8uLi9kb20vRE9NQ29udGVudExvYWRlZC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RvbS9ET01Db250ZW50TG9hZGVkLmpzIiwid2VicGFjazovLy8uLi9kb20vUGFyc2VYTUwuanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL2V2ZW50cy9FdmVudEJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ldmVudHMvRXZlbnRCaW5kaW5nLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vc3JjL2V2ZW50cy9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlcldlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQm9iLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lcldlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQXJlYS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ2lyY3VtZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ2lyY3VtZmVyZW5jZVBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vY2lyY2xlL0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvRXF1YWxzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9HZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2NpcmNsZS9HZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvT2Zmc2V0UG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vY2lyY2xlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2NpcmNsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vZWxsaXBzZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vZWxsaXBzZS9Db250YWluc1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL0dldEJvdW5kcy5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vZWxsaXBzZS9HZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9PZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9PZmZzZXRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vZWxsaXBzZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vZWxsaXBzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldEFuZ2xlV2l0aERpc3RhbmNlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL0dldEFuZ2xlV2l0aERpc3RhbmNlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0RW50cnlUYW5nZW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0UG9pbnRXaXRoRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2hlcm1pdGUvR2V0UG9pbnRXaXRoRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9HZXRYLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0WS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0hlcm1pdGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2hlcm1pdGUvSGVybWl0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL0dldFJlY3RhbmdsZUludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9MaW5lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZVNlZ21lbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmVTZWdtZW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9WYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0NlbnRlck9uLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0dldE1pZFBvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL0dldE1pZFBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvR2V0Tm9ybWFsLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL0dldE5vcm1hbC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0dldFBvaW50c09uTGluZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0hlaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL05vcm1hbFguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvTm9ybWFsWC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL05vcm1hbFkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvTm9ybWFsWS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1BlcnBTbG9wZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9SZWZsZWN0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvUmVmbGVjdEFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvUm90YXRlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1JvdGF0ZUFyb3VuZFBvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL1JvdGF0ZUFyb3VuZFBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvU2V0VG9BbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1Nsb3BlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvV2lkdGguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9BZGQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvQ2VpbC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvQ3Jvc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvRGl2aWRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9GbG9vci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9HZXRDZW50cm9pZC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvR2V0Q2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvSW50ZXJwb2xhdGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L0ludGVycG9sYXRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0ludmVydC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9OZWdhdGl2ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvTmVnYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvTm9ybWFsaXplUmlnaHRIYW5kLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1BlcnAuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvUHJvamVjdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvUHJvamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Qcm9qZWN0VW5pdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvUHJvamVjdFVuaXQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvUlBlcnAuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvU2V0TWFnbml0dWRlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9TZXRNYWduaXR1ZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvU3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvbHlnb24vQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9seWdvbi9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2x5Z29uL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9seWdvbi9HZXRBQUJCLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vR2V0TnVtYmVyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9seWdvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9seWdvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQXJlYS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ2VpbC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ2VpbEFsbC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ2VudGVyT24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0Nsb25lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9Db250YWluc1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NvcHlGcm9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0ZpdEluc2lkZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL0ZpdEluc2lkZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvRml0T3V0c2lkZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL0ZpdE91dHNpZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0Zsb29yLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9GbG9vckFsbC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvR2V0Q2VudGVyLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9HZXRTaXplLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9JbmZsYXRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVBvaW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VSZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVhZLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9PZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL09mZnNldFBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9PdmVybGFwcy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvUGVyaW1ldGVyLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL1NjYWxlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9Vbmlvbi5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL1VuaW9uLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvQmFzZUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9CYXNlTG9hZGVyLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvR2V0VVJMLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvWEhSTG9hZGVyLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL1hIUkxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2V2ZW50cy9Mb2FkZXJDb21wbGV0ZUV2ZW50LmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2V2ZW50cy9Mb2FkZXJDb21wbGV0ZUV2ZW50LmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZXZlbnRzL0xvYWRlclN0YXJ0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZXZlbnRzL0xvYWRlclN0YXJ0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9ldmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZXZlbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0F0bGFzSlNPTkZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL0F0bGFzSlNPTkZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvQmluYXJ5RmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvQmluYXJ5RmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9HTFNMRmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvVGV4dEZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL1RleHRGaWxlLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL1hNTEZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL1hNTEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvQXZlcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9DZWlsVG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvQ2xhbXAuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvRGVnVG9SYWQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL0RlZ1RvUmFkLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvRmxvYXRCZXR3ZWVuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0Zsb29yVG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvTWF4QWRkLmpzIiwid2VicGFjazovLy8uLi9tYXRoL01pblN1Yi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9QZXJjZW50LmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JhZFRvRGVnLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9SYWRUb0RlZy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvUm90YXRlQXJvdW5kLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JvdGF0ZUFyb3VuZERpc3RhbmNlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JvdW5kVG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvU2luQ29zVGFibGVHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvU21vb3RoU3RlcC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9TbW9vdGhlclN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvV2l0aGluLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL0JldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvQmV0d2VlblBvaW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9CZXR3ZWVuUG9pbnRzWS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9CZXR3ZWVuWS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9SZXZlcnNlLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9hbmdsZS9SZXZlcnNlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL1JvdGF0ZVRvLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9hbmdsZS9Sb3RhdGVUby5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9TaG9ydGVzdEJldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2FuZ2xlL1dyYXBEZWdyZWVzLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9hbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZVBvd2VyLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlU3F1YXJlZC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvZGlzdGFuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0JhY2suanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0JvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvQ2lyY3VsYXIuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0N1YmljLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9FbGFzdGljLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9FeHBvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9MaW5lYXIuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL1F1YWRyYXRpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvUXVhcnRpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvUXVpbnRpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvU2luZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2Vhc2luZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9mdXp6eS9DZWlsLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L0VxdWFsLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L0Zsb29yLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L0dyZWF0ZXJUaGFuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L0xlc3NUaGFuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9mdXp6eS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0JlemllckludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2ludGVycG9sYXRpb24vQmV6aWVySW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2ludGVycG9sYXRpb24vTGluZWFySW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2ludGVycG9sYXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2ludGVycG9sYXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvcG93Mi9HZXRQb3dlck9mVHdvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3BvdzIvSXNWYWx1ZVBvd2VyT2ZUd28uanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL3BvdzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvcG93Mi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9yYW5kb20tZGF0YS1nZW5lcmF0b3IvUmFuZG9tRGF0YUdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9zbmFwL1NuYXBDZWlsLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3NuYXAvU25hcEZsb29yLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3NuYXAvU25hcFRvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3NuYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL3NuYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9BcnJheS5mb3JFYWNoLmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvQXJyYXkuaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL0F1ZGlvQ29udGV4dE1vbmtleVBhdGNoLmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvRnVuY3Rpb24uYmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL01hdGgudHJ1bmMuanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9VaW50MzJBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9wZXJmb3JtYW5jZS5ub3cuanMiLCJ3ZWJwYWNrOi8vL3NyYy9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL2NhbnZhcy91dGlscy9EcmF3SW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL2NhbnZhcy91dGlscy9HZXRCbGVuZE1vZGVzLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvY2FudmFzL3V0aWxzL0dldEJsZW5kTW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvQmxpdHRlckJhdGNoLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL0JsaXR0ZXJCYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL0ZyYWdtZW50U2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvVmVydGV4U2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvY29uc3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL0ZyYWdtZW50U2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9TcHJpdGVCYXRjaC5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL1Nwcml0ZUJhdGNoLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9TcHJpdGVCYXRjaDMyLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvU3ByaXRlQmF0Y2gzMi5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvVmVydGV4U2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9DcmVhdGVFbXB0eVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC91dGlscy9DcmVhdGVFbXB0eVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vc291bmQvZHluYW1pYy9GWC5qcyIsIndlYnBhY2s6Ly8vc3JjL3NvdW5kL2R5bmFtaWMvRlguanMiLCJ3ZWJwYWNrOi8vLy4uL3NvdW5kL2R5bmFtaWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9zb3VuZC9keW5hbWljL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3N0YXRlL1N0YXRlLmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9TdGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9TdGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL2NvbnN0LmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvc3RhdGUvc3lzdGVtcy9HYW1lT2JqZWN0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvc3lzdGVtcy9Mb2FkZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvc3lzdGVtcy9NYWluTG9vcC5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvc3lzdGVtcy9VcGRhdGVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9zdHJ1Y3RzL1NldC5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvRnJhbWUuanMiLCJ3ZWJwYWNrOi8vL3NyYy90ZXh0dXJlcy9GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3RleHR1cmVzL1RleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL1RleHR1cmVNYW5hZ2VyLmpzIiwid2VicGFjazovLy9zcmMvdGV4dHVyZXMvVGV4dHVyZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL1RleHR1cmVTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy90ZXh0dXJlcy9UZXh0dXJlU291cmNlLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL0NhbnZhc1RleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvSW1hZ2VUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL0pTT05BcnJheVRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvSlNPTkhhc2hUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL1B5eGVsVGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9TcHJpdGVTaGVldFRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvU3RhcmxpbmdYTUxUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvdGV4dHVyZXMvcGFyc2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvRmluZENsb3Nlc3RJblNvcnRlZC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvR2V0UmFuZG9tRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXlTdGVwLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXlTdGVwLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9SZW1vdmVSYW5kb21FbGVtZW50LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYXJyYXkvUmVtb3ZlUmFuZG9tRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvUm90YXRlTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvUm90YXRlUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L1NodWZmbGUuanMiLCJ3ZWJwYWNrOi8vL2Q6L3dhbXAvd3d3L3BoYXNlci92My9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoYXNlci5qcyIsIndlYnBhY2s6Ly8vLi4vcGhhc2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDOURBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTzs7QUFFakM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzNCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNaQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3ZCQSwrQ0NBQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsR0FBRyx1QkFBdUIsT0FBTztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDclFBLFNDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU8sc0dBQXNHO0FBQzlIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRTVLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNKQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTztBQUNqQyw4QkFBOEIsV0FBVztBQUN6QywrQkFBK0IsWUFBWTs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3JLQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7O0FBRWxEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFN0lBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMvREE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuQkEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzNCQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBRXJMQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBRTdXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQ0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxvQkFBb0I7QUFDOUIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBRWpDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hELDhCQUE4QixjQUFjO0FBQzVDLDZCQUE2QixXQUFXO0FBQ3hDLGlDQUFpQyxlQUFlO0FBQ2hELGdDQUFnQyxhQUFhOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BCQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhLEVBQUU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7OztBQ2xCQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFL0VBLFNDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFbk9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2JBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTztBQUNqQywrQkFBK0IsWUFBWTs7QUFFM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFdkNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkEscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUV0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVqREE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBRWpJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDRCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSwwQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRTNHQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLHdFQUF3RTtBQUN0RixjQUFjLGNBQWM7QUFDNUIsY0FBYyxhQUFhO0FBQzNCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9COztBQUV0RDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRWhEQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCOztBQUV4RDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUUzQkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyx3RUFBd0U7QUFDdEYsY0FBYyxjQUFjO0FBQzVCLGNBQWMsYUFBYTtBQUMzQixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVoREE7O0FBRUE7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUViQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMEJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwwQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOzs7Ozs7O0FFOUNBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTs7Ozs7OztBQ1JBOztBQUVBOztBQUVBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTkE7O0FBRUEseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7Ozs7OztBRVpBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOzs7Ozs7O0FFTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixhQUFhOztBQUU1QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFN0RBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFekVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFM0ZBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMLENBQUM7O0FBRUQ7Ozs7Ozs7QUV0VkE7QUFDQTtBQUNBO0FBQ0EsMEI7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBRWxnQ0EsU0NBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVyREE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUMvR0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBLGNDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUEEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVaQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZCxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBLGdCQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1Qjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWRBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFZkE7O0FBRUEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUEsZUNBQSxtQkRBQSxD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Q0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBRTNaQTs7QUFFQSxjQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSwrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwwQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSwrQkNBQSxtQkRBQSxDQ0FBLEdE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RUE7Ozs7Ozs7QUVkQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsWUFBWTtBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRWpCQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRVZBLHFCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTs7QUFFQSxXQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFM0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUEE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2QsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXJDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFYkE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2QsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTs7Ozs7OztBRVRBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQSxVQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVuQkEsVUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFbEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVWQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRTNCQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFM0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkEsZ0JDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCOztBQUVyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRWxCQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUEsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsMEJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMkJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esd0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esd0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7OztBRWhDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnRkFBZ0YscUJBQXFCOztBQUVyRztBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MseURBQXlEOztBQUUzRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXBTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakJBLHVCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFckNBLFlDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVaQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFWkE7O0FBRUEsd0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMkJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTEEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7Ozs7Ozs7O0FFbEJBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixXQUFXOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUV0Q0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBRXRDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FFdENBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFN0NBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLDZCQUE2QixXQUFXOztBQUV4Qzs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEIsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsTUFBTTtBQUNoQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6QkEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLDZCQUE2QixXQUFXOztBQUV4Qzs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6Qyw2QkFBNkIsV0FBVzs7QUFFeEM7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0MsK0JBQStCLFlBQVk7QUFDM0Msa0NBQWtDLGVBQWU7O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxRQUFRO0FBQ25CLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQSxpQkNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUM5QkEsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQTs7QUFFQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUViQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7O0FBRXJDO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7O0FBRUEsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTkE7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdERBOztBQUVBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCOztBQUVsRDtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7O0FBRWxEO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCOztBQUVsRDtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7O0FBRUEsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVSQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNwTEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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aUI7QUFDakI7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwyQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQkFBcUI7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSx5REFBeUQscUJBQXFCOztBQUU5RTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFdlVBOztBQUVBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxtQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVsUUE7QUFDQSwwQkFBMEI7QUFDMUIsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0Isa0JBQWtCO0FBQ2xCLDBGQUEwRjtBQUMxRixNQUFNO0FBQ047Ozs7Ozs7QUNSQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCLG1CQUFtQjtBQUNuQixpRUFBaUU7QUFDakUsa0NBQWtDO0FBQ2xDLHdCQUF3QjtBQUN4QixNQUFNO0FBQ047Ozs7Ozs7QUNaQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXRCQTtBQUNBLDBCQUEwQjtBQUMxQixtQ0FBbUM7QUFDbkMsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEIsZ0ZBQWdGO0FBQ2hGLE1BQU07QUFDTjs7Ozs7OztBQ1JBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxtQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFMVJBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxtQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRTlSQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLG1CQUFtQjtBQUNuQixzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHdDQUF3QztBQUN4QyxvSEFBb0g7QUFDcEgsMkZBQTJGO0FBQzNGLGtDQUFrQztBQUNsQywwQkFBMEI7QUFDMUIsTUFBTTtBQUNOOzs7Ozs7O0FDbkJBLGlCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUV0QkEsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsMkJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ1RBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCOztBQUVoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLHlCQUF5Qjs7QUFFbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFF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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7Ozs7OztBRTFOQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFbElBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FB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QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7OENDbkx0QyxtQkNBQSxDREFBLEVDQUE7O0FBRUEsWURBQSxtQkNBQSxDREFBLENDQUE7QUFDQSxhREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQTs7QUFFQTs7QUFFQSxVREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQSxXREFBLG1CQ0FBLENEQUEsRUNBQTtBQUNBLHFCREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQSxVREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQSxVREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQTs7QUFFQSxpQkRBQSxtQkNBQSxDREFBLENDQUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxtQkRBQSxtQkNBQSxDREFBLEVDQUE7O0FBRUEsS0FBSzs7QUFFTCxXREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQTs7QUFFQSxlREFBLG1CQ0FBLENEQUEsRUNBQTtBQUNBLGlCREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQTs7QUFFQTs7QUFFQTs7QURFQSxtQkNBQSxDREFBLEVDQUE7QURDQSxtQkNBQSxDREFBLEVDQUE7QURDQSxtQkNBQSxDREFBLEVDQUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJwaGFzZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIlBoYXNlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQaGFzZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUGhhc2VyXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb3J5IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vcnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzNTEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDllOThkZWVjMWI0MjRiNGY2MjFlIiwidmFyIFBvaW50ID0gZnVuY3Rpb24gKHgsIHkpXHJcbntcclxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgIHRoaXMueSA9IHk7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludDtcclxuXHJcblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHtcclxuXHJcbiAgICBWRVJTSU9OOiAnMy4wLjAnLFxyXG5cclxuICAgIEFVVE86IDAsXHJcbiAgICBDQU5WQVM6IDEsXHJcbiAgICBXRUJHTDogMixcclxuXHJcbiAgICBJTUFHRTogMjBcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUSF9DT05TVCA9IHtcclxuXHJcbiAgICBQSTI6IE1hdGguUEkgKiAyLFxyXG4gICAgVEFVOiBNYXRoLlBJICogMC41LFxyXG4gICAgRVBTSUxPTjogMS4wZS02LFxyXG4gICAgREVHX1RPX1JBRDogTWF0aC5QSSAvIDE4MCxcclxuICAgIFJBRF9UT19ERUc6IDE4MCAvIE1hdGguUElcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1BVEhfQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZJTEVfQ09OU1QgPSB7XHJcblxyXG4gICAgTE9BREVSX0lETEU6IDAsXHJcbiAgICBMT0FERVJfTE9BRElORzogMSxcclxuICAgIExPQURFUl9QUk9DRVNTSU5HOiAyLFxyXG4gICAgTE9BREVSX0NPTVBMRVRFOiAzLFxyXG4gICAgTE9BREVSX0RFU1RST1lFRDogNCxcclxuXHJcbiAgICBGSUxFX1BFTkRJTkc6IDUsICAgICAgLy8gZmlsZSBpcyBpbiB0aGUgbG9hZCBxdWV1ZSBidXQgbm90IHlldCBzdGFydGVkXHJcbiAgICBGSUxFX0xPQURJTkc6IDYsICAgICAgLy8gZmlsZSBoYXMgYmVlbiBzdGFydGVkIHRvIGxvYWQgYnkgdGhlIGxvYWRlciAob25Mb2FkIGNhbGxlZClcclxuICAgIEZJTEVfTE9BREVEOiA3LCAgICAgICAvLyBmaWxlIGhhcyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LCBhd2FpdGluZyBwcm9jZXNzaW5nXHJcbiAgICBGSUxFX0ZBSUxFRDogOCwgICAgICAgLy8gZmlsZSBmYWlsZWQgdG8gbG9hZFxyXG4gICAgRklMRV9QUk9DRVNTSU5HOiA5LCAgIC8vIGZpbGUgaXMgYmVpbmcgcHJvY2Vzc2VkIChvblByb2Nlc3MgY2FsbGJhY2spXHJcbiAgICBGSUxFX1dBSVRJTkdfTElOS0ZJTEU6IDEwLCAgIC8vIGZpbGUgaXMgYmVpbmcgcHJvY2Vzc2VkIChvblByb2Nlc3MgY2FsbGJhY2spXHJcbiAgICBGSUxFX0VSUk9SRUQ6IDExLCAgIC8vIGZpbGUgaXMgYmVpbmcgcHJvY2Vzc2VkIChvblByb2Nlc3MgY2FsbGJhY2spXHJcbiAgICBGSUxFX0NPTVBMRVRFOiAxMiwgICAgIC8vIGZpbGUgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmdcclxuICAgIEZJTEVfREVTVFJPWUVEOiAxMywgICAgIC8vIGZpbGUgaGFzIGJlZW4gZGVzdHJveWVkXHJcblxyXG4gICAgVEVYVFVSRV9BVExBU19KU09OX0FSUkFZOiAyMCxcclxuICAgIFRFWFRVUkVfQVRMQVNfSlNPTl9IQVNIOiAyMVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRklMRV9DT05TVDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9PUy5qcyIsInZhciBPUyA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBkZXNrdG9wIC0gSXMgcnVubmluZyBvbiBhIGRlc2t0b3A/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZGVza3RvcDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2ViQXBwIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBhcyBhIFdlYkFwcCwgaS5lLiB3aXRoaW4gYSBXZWJWaWV3XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgd2ViQXBwOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpT1MgLSBJcyBydW5uaW5nIG9uIGlPUz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBpT1M6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gaU9TVmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gaU9TIHRoaXMgd2lsbCBjb250YWluIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBpT1NWZXJzaW9uOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlQaG9uZSAtIElzIHJ1bm5pbmcgb24gaVBob25lP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGlQaG9uZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaVBhZCAtIElzIHJ1bm5pbmcgb24gaVBhZD9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBpUGFkOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjb2Nvb25KUyAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgQ29jb29uSlM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY29jb29uSlM6IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjb2Nvb25KU0FwcCAtIElzIHRoaXMgZ2FtZSBydW5uaW5nIHdpdGggQ29jb29uSlMuQXBwP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNvY29vbkpTQXBwOiBmYWxzZSxcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29yZG92YSAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgQXBhY2hlIENvcmRvdmE/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY29yZG92YTogZmFsc2UsXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG5vZGUgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIE5vZGUuanM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbm9kZTogZmFsc2UsXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG5vZGVXZWJraXQgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIE5vZGUtV2Via2l0P1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG5vZGVXZWJraXQ6IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlbGVjdHJvbiAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgR2l0SHViIEVsZWN0cm9uP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGVsZWN0cm9uOiBmYWxzZSxcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZWplY3RhIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBFamVjdGE/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZWplY3RhOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjcm9zc3dhbGsgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIHRoZSBJbnRlbCBDcm9zc3dhbGsgWERLP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNyb3Nzd2FsazogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5kcm9pZCAtIElzIHJ1bm5pbmcgb24gYW5kcm9pZD9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBhbmRyb2lkOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjaHJvbWVPUyAtIElzIHJ1bm5pbmcgb24gY2hyb21lT1M/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY2hyb21lT1M6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGxpbnV4IC0gSXMgcnVubmluZyBvbiBsaW51eD9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBsaW51eDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFjT1MgLSBJcyBydW5uaW5nIG9uIG1hY09TP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG1hY09TOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3aW5kb3dzIC0gSXMgcnVubmluZyBvbiB3aW5kb3dzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdpbmRvd3M6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdpbmRvd3NQaG9uZSAtIElzIHJ1bm5pbmcgb24gYSBXaW5kb3dzIFBob25lP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdpbmRvd3NQaG9uZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdml0YSAtIElzIHJ1bm5pbmcgb24gYSBQbGF5U3RhdGlvbiBWaXRhP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHZpdGE6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGtpbmRsZSAtIElzIHJ1bm5pbmcgb24gYW4gQW1hem9uIEtpbmRsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBraW5kbGU6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcGl4ZWxSYXRpbyAtIFBpeGVsUmF0aW8gb2YgdGhlIGhvc3QgZGV2aWNlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHBpeGVsUmF0aW86IDFcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XHJcblxyXG4gICAgaWYgKC9XaW5kb3dzLy50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy53aW5kb3dzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9NYWMgT1MvLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLm1hY09TID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9MaW51eC8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MubGludXggPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL0FuZHJvaWQvLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmFuZHJvaWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL2lQW2FvXWR8aVBob25lL2kudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuaU9TID0gdHJ1ZTtcclxuICAgICAgICAobmF2aWdhdG9yLmFwcFZlcnNpb24pLm1hdGNoKC9PUyAoXFxkKykvKTtcclxuICAgICAgICBPUy5pT1NWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvS2luZGxlLy50ZXN0KHVhKSB8fCAoL1xcYktGW0EtWl1bQS1aXSsvKS50ZXN0KHVhKSB8fCAoL1NpbGsuKk1vYmlsZSBTYWZhcmkvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5raW5kbGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBUaGlzIHdpbGwgTk9UIGRldGVjdCBlYXJseSBnZW5lcmF0aW9ucyBvZiBLaW5kbGUgRmlyZSwgSSB0aGluayB0aGVyZSBpcyBubyByZWxpYWJsZSB3YXkuLi5cclxuICAgICAgICAvLyBFLmcuIFwiTW96aWxsYS81LjAgKE1hY2ludG9zaDsgVTsgSW50ZWwgTWFjIE9TIFggMTBfNl8zOyBlbi11czsgU2lsay8xLjEuMC04MCkgQXBwbGVXZWJLaXQvNTMzLjE2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi81LjAgU2FmYXJpLzUzMy4xNiBTaWxrLUFjY2VsZXJhdGVkPXRydWVcIlxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL0NyT1MvLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmNocm9tZU9TID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvUGxheXN0YXRpb24gVml0YS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLnZpdGEgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgvV2luZG93cyBQaG9uZS9pLnRlc3QodWEpIHx8ICgvSUVNb2JpbGUvaSkudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuYW5kcm9pZCA9IGZhbHNlO1xyXG4gICAgICAgIE9TLmlPUyA9IGZhbHNlO1xyXG4gICAgICAgIE9TLm1hY09TID0gZmFsc2U7XHJcbiAgICAgICAgT1Mud2luZG93cyA9IHRydWU7XHJcbiAgICAgICAgT1Mud2luZG93c1Bob25lID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2lsayA9ICgvU2lsay8pLnRlc3QodWEpO1xyXG5cclxuICAgIGlmIChPUy53aW5kb3dzIHx8IE9TLm1hY09TIHx8IChPUy5saW51eCAmJiAhc2lsaykgfHwgT1MuY2hyb21lT1MpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuZGVza3RvcCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFdpbmRvd3MgUGhvbmUgLyBUYWJsZSByZXNldFxyXG4gICAgaWYgKE9TLndpbmRvd3NQaG9uZSB8fCAoKC9XaW5kb3dzIE5UL2kudGVzdCh1YSkpICYmICgvVG91Y2gvaS50ZXN0KHVhKSkpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmRlc2t0b3AgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgV2ViQXBwIG1vZGUgaW4gaU9TXHJcbiAgICBpZiAobmF2aWdhdG9yLnN0YW5kYWxvbmUpXHJcbiAgICB7XHJcbiAgICAgICAgT1Mud2ViQXBwID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICE9PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuY29yZG92YSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICgodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCcpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLm5vZGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoT1Mubm9kZSAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PT0gJ29iamVjdCcpXHJcbiAgICB7XHJcbiAgICAgICAgT1Mubm9kZVdlYmtpdCA9ICEhcHJvY2Vzcy52ZXJzaW9uc1snbm9kZS13ZWJraXQnXTtcclxuICAgICAgICBcclxuICAgICAgICBPUy5lbGVjdHJvbiA9ICEhcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKG5hdmlnYXRvci5pc0NvY29vbkpTKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmNvY29vbkpTID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdHJ5XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBPUy5jb2Nvb25KU0FwcCA9ICh0eXBlb2YgQ29jb29uSlMgIT09ICd1bmRlZmluZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgT1MuY29jb29uSlNBcHAgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdpbmRvdy5lamVjdGEgIT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICBPUy5lamVjdGEgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgoL0Nyb3Nzd2Fsay8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmNyb3Nzd2FsayA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgT1MuaVBob25lID0gdWEudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdpcGhvbmUnKSAhPT0gLTE7XHJcbiAgICBPUy5pUGFkID0gdWEudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdpcGFkJykgIT09IC0xO1xyXG5cclxuICAgIE9TLnBpeGVsUmF0aW8gPSB3aW5kb3dbJ2RldmljZVBpeGVsUmF0aW8nXSB8fCAxO1xyXG5cclxuICAgIHJldHVybiBPUztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9PUy5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcblxyXG52YXIgQnJvd3NlciA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhcm9yYSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gQXJvcmEuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgYXJvcmE6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNocm9tZSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gQ2hyb21lLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNocm9tZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaHJvbWVWZXJzaW9uIC0gSWYgcnVubmluZyBpbiBDaHJvbWUgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNocm9tZVZlcnNpb246IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXBpcGhhbnkgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIEVwaXBoYW55LlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGVwaXBoYW55OiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBmaXJlZm94IC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBGaXJlZm94LlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGZpcmVmb3g6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gZmlyZWZveFZlcnNpb24gLSBJZiBydW5uaW5nIGluIEZpcmVmb3ggdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGZpcmVmb3hWZXJzaW9uOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1vYmlsZVNhZmFyaSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gTW9iaWxlIFNhZmFyaS5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtb2JpbGVTYWZhcmk6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGllIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBJbnRlcm5ldCBFeHBsb3Jlci5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBpZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZVZlcnNpb24gLSBJZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyIHRoaXMgd2lsbCBjb250YWluIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci4gQmV5b25kIElFMTAgeW91IHNob3VsZCB1c2UgRGV2aWNlLnRyaWRlbnQgYW5kIERldmljZS50cmlkZW50VmVyc2lvbi5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBpZVZlcnNpb246IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWlkb3JpIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBNaWRvcmkuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbWlkb3JpOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBvcGVyYSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gT3BlcmEuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgb3BlcmE6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNhZmFyaSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gU2FmYXJpLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHNhZmFyaTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzYWZhcmlWZXJzaW9uIC0gSWYgcnVubmluZyBpbiBTYWZhcmkgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHNhZmFyaVZlcnNpb246IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdHJpZGVudCAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgYSBUcmlkZW50IHZlcnNpb24gb2YgSW50ZXJuZXQgRXhwbG9yZXIgKElFMTErKVxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRyaWRlbnQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdHJpZGVudFZlcnNpb24gLSBJZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyIDExIHRoaXMgd2lsbCBjb250YWluIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci4gU2VlIHtAbGluayBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvbXM1Mzc1MDModj12cy44NSkuYXNweH1cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0cmlkZW50VmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlZGdlIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBNaWNyb3NvZnQgRWRnZSBicm93c2VyLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGVkZ2U6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNpbGsgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIHRoZSBTaWxrIGJyb3dzZXIgKGFzIHVzZWQgb24gdGhlIEFtYXpvbiBLaW5kbGUpXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgc2lsazogZmFsc2VcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XHJcblxyXG4gICAgaWYgKCgvQXJvcmEvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmFyb3JhID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9FZGdlXFwvXFxkKy8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5lZGdlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvQ2hyb21lXFwvKFxcZCspLykudGVzdCh1YSkgJiYgIU9TLndpbmRvd3NQaG9uZSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmNocm9tZSA9IHRydWU7XHJcbiAgICAgICAgQnJvd3Nlci5jaHJvbWVWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL0VwaXBoYW55LykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5lcGlwaGFueSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL0ZpcmVmb3hcXEQrKFxcZCspLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcclxuICAgICAgICBCcm93c2VyLmZpcmVmb3hWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL0FwcGxlV2ViS2l0LykudGVzdCh1YSkgJiYgT1MuaU9TKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIubW9iaWxlU2FmYXJpID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvTVNJRSAoXFxkK1xcLlxcZCspOy8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuaWUgPSB0cnVlO1xyXG4gICAgICAgIEJyb3dzZXIuaWVWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL01pZG9yaS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIubWlkb3JpID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvT3BlcmEvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLm9wZXJhID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvU2FmYXJpLykudGVzdCh1YSkgJiYgIU9TLndpbmRvd3NQaG9uZSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLnNhZmFyaSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL1RyaWRlbnRcXC8oXFxkK1xcLlxcZCspKC4qKXJ2OihcXGQrXFwuXFxkKykvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmllID0gdHJ1ZTtcclxuICAgICAgICBCcm93c2VyLnRyaWRlbnQgPSB0cnVlO1xyXG4gICAgICAgIEJyb3dzZXIudHJpZGVudFZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgICAgICBCcm93c2VyLmllVmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMywgMTApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTaWxrIGdldHMgaXRzIG93biBpZiBjbGF1c2UgYmVjYXVzZSBpdHMgdWEgYWxzbyBjb250YWlucyAnU2FmYXJpJ1xyXG4gICAgaWYgKCgvU2lsay8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuc2lsayA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEJyb3dzZXI7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvQnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvQnJvd3Nlci5qcyIsInZhciBBbmdsZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMihsaW5lLnkyIC0gbGluZS55MSwgbGluZS54MiAtIGxpbmUueDEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0FuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4vLyAgRW5jYXBzdWxhdGVzIGEgMkQgcmVjdGFuZ2xlIGRlZmluZWQgYnkgaXRzIGNvcm5lciBwb2ludCBpbiB0aGUgdG9wLWxlZnRcclxuLy8gIGFuZCBpdHMgZXh0ZW5kcyBpbiB4ICh3aWR0aCkgYW5kIHkgKGhlaWdodClcclxuXHJcbnZhciBSZWN0YW5nbGUgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSAwOyB9XHJcbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMDsgfVxyXG5cclxuICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgdGhpcy55ID0geTtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbn07XHJcblxyXG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjdGFuZ2xlO1xyXG5cclxuUmVjdGFuZ2xlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEVtcHR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldFRvKDAsIDAsIDAsIDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gd2lkdGg7IH1cclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWN0YW5nbGUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgbGVmdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMucmlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy54KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB2YWx1ZSAtIHRoaXMueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMuYm90dG9tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gKHRoaXMuYm90dG9tIC0gdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLnkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdmFsdWUgLSB0aGlzLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvUmVjdGFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRVUkwgPSByZXF1aXJlKCcuL0dldFVSTCcpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBYSFJMb2FkZXIgPSByZXF1aXJlKCcuL1hIUkxvYWRlcicpO1xyXG52YXIgWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL1hIUlNldHRpbmdzJyk7XHJcbnZhciBNZXJnZVhIUlNldHRpbmdzID0gcmVxdWlyZSgnLi9NZXJnZVhIUlNldHRpbmdzJyk7XHJcblxyXG52YXIgRmlsZSA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHVybCwgcmVzcG9uc2VUeXBlLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgLy8gIGZpbGUgdHlwZSAoaW1hZ2UsIGpzb24sIGV0YykgZm9yIHNvcnRpbmcgd2l0aGluIHRoZSBMb2FkZXJcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgLy8gIHVuaXF1ZSBjYWNoZSBrZXkgKHVuaXF1ZSB3aXRoaW4gaXRzIGZpbGUgdHlwZSlcclxuICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cclxuICAgIC8vICBUaGUgVVJMIG9mIHRoZSBmaWxlLCBub3QgaW5jbHVkaW5nIGJhc2VVUkxcclxuICAgIHRoaXMudXJsID0gdXJsO1xyXG5cclxuICAgIC8vICBTZXQgd2hlbiB0aGUgTG9hZGVyIGNhbGxzICdsb2FkJyBvbiB0aGlzIGZpbGVcclxuICAgIHRoaXMuc3JjID0gJyc7XHJcblxyXG4gICAgdGhpcy54aHJTZXR0aW5ncyA9IFhIUlNldHRpbmdzKHJlc3BvbnNlVHlwZSk7XHJcblxyXG4gICAgaWYgKHhoclNldHRpbmdzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueGhyU2V0dGluZ3MgPSBNZXJnZVhIUlNldHRpbmdzKHRoaXMueGhyU2V0dGluZ3MsIHhoclNldHRpbmdzKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnhockxvYWRlciA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUEVORElORztcclxuXHJcbiAgICAvLyAgU2V0IGJ5IG9uUHJvZ3Jlc3MgKG9ubHkgaWYgbG9hZGluZyB2aWEgWEhSKVxyXG4gICAgdGhpcy5ieXRlc1RvdGFsID0gMDtcclxuICAgIHRoaXMuYnl0ZXNMb2FkZWQgPSAtMTtcclxuICAgIHRoaXMucGVyY2VudENvbXBsZXRlID0gLTE7XHJcblxyXG4gICAgLy8gIEZvciBDT1JzIGJhc2VkIGxvYWRpbmcuXHJcbiAgICAvLyAgSWYgdGhpcyBpcyB1bmRlZmluZWQgdGhlbiB0aGUgRmlsZSB3aWxsIGNoZWNrIEJhc2VMb2FkZXIuY3Jvc3NPcmlnaW4gYW5kIHVzZSB0aGF0IChpZiBzZXQpXHJcbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8vICBUaGUgYWN0dWFsIHByb2Nlc3NlZCBmaWxlIGRhdGFcclxuICAgIHRoaXMuZGF0YSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvLyAgTXVsdGlwYXJ0IGZpbGU/IChpLmUuIGFuIGF0bGFzIGFuZCBpdHMganNvbiB0b2dldGhlcilcclxuICAgIHRoaXMubGlua0ZpbGUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmxpbmtUeXBlID0gJyc7XHJcblxyXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XHJcbn07XHJcblxyXG5GaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpbGU7XHJcblxyXG5GaWxlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICByZXNldFhIUjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnhockxvYWRlci5vbmxvYWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy54aHJMb2FkZXIub25lcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnhockxvYWRlci5vbnByb2dyZXNzID0gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIHdoZW4gdGhlIEltYWdlIGxvYWRzXHJcbiAgICAvLyAgUHJvZ3Jlc3NFdmVudFxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZXNldFhIUigpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMsIHRydWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZXNldFhIUigpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMsIGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKGV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5ieXRlc0xvYWRlZCA9IGV2ZW50LmxvYWRlZDtcclxuICAgICAgICAgICAgdGhpcy5ieXRlc1RvdGFsID0gZXZlbnQudG90YWw7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBlcmNlbnRDb21wbGV0ZSA9IE1hdGgubWluKCh0aGlzLmJ5dGVzTG9hZGVkIC8gdGhpcy5ieXRlc1RvdGFsKSwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnBlcmNlbnRDb21wbGV0ZSArICclICgnICsgdGhpcy5ieXRlc0xvYWRlZCArICcgYnl0ZXMpJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uUHJvY2VzczogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgICAgICBjYWxsYmFjayh0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5saW5rRmlsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmtGaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX1dBSVRJTkdfTElOS0ZJTEUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBUaGUgbGlua2ZpbGUgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcsIGFuZCBpcyB3YWl0aW5nIGZvciB0aGlzIGZpbGUsIHNvIGxldCdzIGRvIHRoZW0gYm90aFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfQ09NUExFVEU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtGaWxlLnN0YXRlID0gQ09OU1QuRklMRV9DT01QTEVURTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBUaGUgbGlua2ZpbGUgc3RpbGwgaGFzbid0IGZpbmlzaGVkIGxvYWRpbmcgYW5kL29yIHByb2Nlc3NpbmcgeWV0XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9XQUlUSU5HX0xJTktGSUxFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0NPTVBMRVRFO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGxlZCBieSB0aGUgTG9hZGVyLCBzdGFydHMgdGhlIGFjdHVhbCBmaWxlIGRvd25sb2FkaW5nXHJcbiAgICBsb2FkOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGJhc2VVUkwsIGdsb2JhbFhIUilcclxuICAgIHtcclxuICAgICAgICBpZiAoYmFzZVVSTCA9PT0gdW5kZWZpbmVkKSB7IGJhc2VVUkwgPSAnJzsgfVxyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG4gICAgICAgIHRoaXMuc3JjID0gR2V0VVJMKHRoaXMsIGJhc2VVUkwpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zcmMuaW5kZXhPZignZGF0YTonKSA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2NhbCBkYXRhIFVSSScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnhockxvYWRlciA9IFhIUkxvYWRlcih0aGlzLCBnbG9iYWxYSFIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL0ZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL0ZpbGUuanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgZ2xvYmFsIGxldmVsIGNvbnRhaW5lciBvZiBGYWN0b3J5IGluc3RhbmNlcy5cclxuKiBGYWN0b3JpZXMgcmVnaXN0ZXIgdGhlbXNlbHZlcyB3aXRoIHRoaXMgY29udGFpbmVyICh3aGVuIHJlcXVpcmVkKVxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5HYW1lT2JqZWN0LkZhY3RvcnlcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXHJcbiovXHJcblxyXG52YXIgZmFjdG9yaWVzID0ge307XHJcblxyXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIC8vIGNvbnNvbGUubG9nKCdGYWN0b3J5Q29udGFpbmVyIGlzIGFsaXZlJyk7XHJcblxyXG4gICAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uIChmYWN0b3J5KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChmYWN0b3JpZXMuaGFzT3duUHJvcGVydHkoZmFjdG9yeS5LRVkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0FscmVhZHkgcmVnaXN0ZXJlZCcsIGZhY3RvcnkuS0VZKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoZmFjdG9yeS5LRVkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlZ2lzdGVyaW5nJywgZmFjdG9yeS5LRVkpO1xyXG5cclxuICAgICAgICBmYWN0b3JpZXNbZmFjdG9yeS5LRVldID0ge1xyXG4gICAgICAgICAgICBhZGQ6IGZhY3RvcnkuYWRkLFxyXG4gICAgICAgICAgICBtYWtlOiBmYWN0b3J5Lm1ha2VcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gZmFjdG9yeTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nZXRUeXBlID0gZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFjdG9yaWVzW2tleV07XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uIChkZXN0LCBpc0ZhY3RvcnkpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgZmFjdG9yeSBpbiBmYWN0b3JpZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yaWVzLmhhc093blByb3BlcnR5KGZhY3RvcnkpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTG9hZGluZycsIGZhY3RvcnkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlc3RbZmFjdG9yeV0gPSAoaXNGYWN0b3J5KSA/IGZhY3Rvcmllc1tmYWN0b3J5XS5hZGQgOiBmYWN0b3JpZXNbZmFjdG9yeV0ubWFrZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgREVGQVVMVDogMCxcclxuICAgIExJTkVBUjogMCxcclxuICAgIE5FQVJFU1Q6IDFcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL1NjYWxlTW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXcmFwID0gZnVuY3Rpb24gKHZhbHVlLCBtaW4sIG1heClcclxue1xyXG4gICAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xyXG5cclxuICAgIGlmIChyYW5nZSA8PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHQgPSAodmFsdWUgLSBtaW4pICUgcmFuZ2U7XHJcblxyXG4gICAgaWYgKHJlc3VsdCA8IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHJhbmdlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQgKyBtaW47XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvV3JhcC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1hdGhXcmFwID0gcmVxdWlyZSgnLi4vV3JhcCcpO1xyXG5cclxudmFyIFdyYXAgPSBmdW5jdGlvbiAoYW5nbGUpXHJcbntcclxuICAgIHJldHVybiBNYXRoV3JhcChhbmdsZSwgLU1hdGguUEksIE1hdGguUEkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXcmFwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL1dyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvYW5nbGUvV3JhcC5qcyIsIi8vICBTb3VyY2Ugb2JqZWN0XHJcbi8vICBUaGUga2V5IGFzIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBrZXlzLCBpLmUuICdiYW5uZXInLCBvciAnYmFubmVyLmhpZGVCYW5uZXInXHJcbi8vICBUaGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0XHJcblxyXG52YXIgR2V0T2JqZWN0VmFsdWUgPSBmdW5jdGlvbiAoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSlcclxue1xyXG4gICAgaWYgKGtleS5pbmRleE9mKCcuJykpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcclxuICAgICAgICB2YXIgcGFyZW50ID0gc291cmNlO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuXHJcbiAgICAgICAgLy8gIFVzZSBmb3IgbG9vcCBoZXJlIHNvIHdlIGNhbiBicmVhayBlYXJseVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaGFzT3duUHJvcGVydHkoa2V5c1tpXSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBZZXMgaXQgaGFzIGEga2V5IHByb3BlcnR5LCBsZXQncyBjYXJyeSBvbiBkb3duXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmVudFtrZXlzW2ldXTtcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRba2V5c1tpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpID8gc291cmNlW2tleV0gOiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE9iamVjdFZhbHVlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9HZXRPYmplY3RWYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gZnVuY3Rpb24gKHR5cGUpXHJcbntcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgdGhpcy50YXJnZXQ7XHJcblxyXG4gICAgdGhpcy5fcHJvcGFnYXRlID0gdHJ1ZTtcclxufTtcclxuXHJcbkV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50O1xyXG5cclxuRXZlbnQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAodGFyZ2V0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG5cclxuICAgICAgICB0aGlzLl9wcm9wYWdhdGUgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZXZlbnRzL0V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnRCaW5kaW5nID0gcmVxdWlyZSgnLi9FdmVudEJpbmRpbmcnKTtcclxuXHJcbnZhciBFdmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLmJpbmRpbmdzID0ge307XHJcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcclxuICAgIHRoaXMuaGFzRmlsdGVycyA9IGZhbHNlO1xyXG59O1xyXG5cclxuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50RGlzcGF0Y2hlcjtcclxuXHJcbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgZ2V0QmluZGluZzogZnVuY3Rpb24gKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3MuaGFzT3duUHJvcGVydHkodHlwZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nc1t0eXBlXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUJpbmRpbmc6IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5nZXRCaW5kaW5nKHR5cGUpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlXSA9IG5ldyBFdmVudEJpbmRpbmcodGhpcywgdHlwZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nc1t0eXBlXTtcclxuICAgIH0sXHJcblxyXG4gICAgb246IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgcHJpb3JpdHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHsgcHJpb3JpdHkgPSAwOyB9XHJcblxyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5jcmVhdGVCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuYWRkKGxpc3RlbmVyLCBwcmlvcml0eSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uY2U6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgcHJpb3JpdHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHsgcHJpb3JpdHkgPSAwOyB9XHJcblxyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5jcmVhdGVCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuYWRkKGxpc3RlbmVyLCBwcmlvcml0eSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEFkZCBhIGNhbGxiYWNrIHRoYXQgaXMgbm90aWZpZWQgZXZlcnkgdGltZSB0aGlzIEV2ZW50RGlzcGF0Y2hlciBkaXNwYXRjaGVzIGFuIGV2ZW50XHJcbiAgICAvLyAgbm8gbWF0dGVyIHdoYXQgdGhlIGV2ZW50IHR5cGUgaXMuIEZpbHRlcnMgYXJlIGludm9rZWQgZmlyc3QsIGJlZm9yZSBhbnkgYmluZGluZ3MsXHJcbiAgICAvLyAgYW5kIGNhbiBzdG9wIGV2ZW50cyBpZiB0aGV5IHdpc2ggKGluIHdoaWNoIGNhc2UgdGhleSdsbCBuZXZlciByZWFjaCB0aGUgYmluZGluZ3MpXHJcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuZmlsdGVycy5pbmRleE9mKGNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgaWYgKGkgPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEFkZCB0aGUgZmlsdGVyXHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFJlbW92ZSB0aGUgZmlsdGVyXHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuaGFzRmlsdGVycyA9ICh0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXM6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcilcclxuICAgIHtcclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZGluZy5oYXMobGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB0b3RhbDogZnVuY3Rpb24gKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcodHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChiaW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmcudG90YWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgLy8gIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGxpc3RlbmVyIHJlZ2lzdGVyZWQgd2l0aCB0aGUgRXZlbnREaXNwYXRjaGVyLCBhIGNhbGwgdG8gdGhpcyBtZXRob2QgaGFzIG5vIGVmZmVjdC5cclxuICAgIG9mZjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcucmVtb3ZlKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBfZGlzcGF0Y2hIYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgZXZlbnQucmVzZXQodGhpcyk7XHJcblxyXG4gICAgICAgIC8vICBQYXNzIHRoZSBldmVudCB0aHJvdWdoIHRoZSBmaWx0ZXJzIGZpcnN0XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhhc0ZpbHRlcnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICBEaWQgdGhlIGZpbHRlciBraWxsIHRoZSBldmVudD8gSWYgc28sIHdlIGNhbiBhYm9ydCBub3dcclxuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuX3Byb3BhZ2F0ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKGV2ZW50LnR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuZGlzcGF0Y2goZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEhhbmRsZXIoZXZlbnRbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoSGFuZGxlcihldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBidXQgcmV0YWlucyB0aGUgZXZlbnQgdHlwZSBlbnRyaWVzXHJcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQWxsRmlsdGVyczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZpbHRlcnMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5oYXNGaWx0ZXJzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZWxldGU6IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuZGVzdHJveSgpO1xyXG5cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbdHlwZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGVsZXRlQWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGJpbmRpbmcgaW4gdGhpcy5iaW5kaW5ncylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZGVsZXRlQWxsKCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxGaWx0ZXJzKCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudERpc3BhdGNoZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2V2ZW50cy9FdmVudERpc3BhdGNoZXIuanMiLCJcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcblxyXG52YXIgSW1hZ2VGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLmltYWdlXFwnIGludmFsaWQga2V5IHByb3ZpZGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdXJsKVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLnBuZyc7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBGaWxlLmNhbGwodGhpcywgJ2ltYWdlJywga2V5LCB1cmwsICdibG9iJywgeGhyU2V0dGluZ3MpO1xyXG59O1xyXG5cclxuSW1hZ2VGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5JbWFnZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1hZ2VGaWxlO1xyXG5cclxuSW1hZ2VGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgdGhpcy5kYXRhLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuZGF0YS5vbmxvYWQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoX3RoaXMuZGF0YS5zcmMpO1xyXG5cclxuICAgICAgICBfdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKF90aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kYXRhLm9uZXJyb3IgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoX3RoaXMuZGF0YS5zcmMpO1xyXG5cclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfRVJST1JFRDtcclxuXHJcbiAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRhdGEuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLnhockxvYWRlci5yZXNwb25zZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlRmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9JbWFnZUZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlLmpzIiwidmFyIElzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL0lzUGxhaW5PYmplY3QnKTtcclxuXHJcbi8qKlxyXG4qIFRoaXMgaXMgYSBzbGlnaHRseSBtb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuZXh0ZW5kL1xyXG4qIFxyXG4qIEBtZXRob2QgUGhhc2VyLlV0aWxzLmV4dGVuZFxyXG4qIEBwYXJhbSB7Ym9vbGVhbn0gZGVlcCAtIFBlcmZvcm0gYSBkZWVwIGNvcHk/XHJcbiogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IHRvIGNvcHkgdG8uXHJcbiogQHJldHVybiB7b2JqZWN0fSBUaGUgZXh0ZW5kZWQgb2JqZWN0LlxyXG4qL1xyXG52YXIgRXh0ZW5kID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxyXG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxyXG4gICAgICAgIGRlZXAgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXHJcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIpXHJcbiAgICB7XHJcbiAgICAgICAgZGVlcCA9IHRhcmdldDtcclxuICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XHJcbiAgICAgICAgLy8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxyXG4gICAgICAgIGkgPSAyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGV4dGVuZCBQaGFzZXIgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXHJcbiAgICBpZiAobGVuZ3RoID09PSBpKVxyXG4gICAge1xyXG4gICAgICAgIHRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgLS1pO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgIGlmICgob3B0aW9ucyA9IGFyZ3VtZW50c1tpXSkgIT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcclxuICAgICAgICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNyYyA9IHRhcmdldFtuYW1lXTtcclxuICAgICAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zW25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGNvcHkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBjb3B5ICYmIChJc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29weSkpKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29weUlzQXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgSXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBFeHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvcHkgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBjb3B5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFeHRlbmQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL29iamVjdC9FeHRlbmQuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL29iamVjdC9FeHRlbmQuanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBUaGUgQ2hpbGRyZW4gQ29tcG9uZW50IGZlYXR1cmVzIHF1aWNrIGFjY2VzcyB0byBHcm91cCBzb3J0aW5nIHJlbGF0ZWQgbWV0aG9kcy5cclxuKlxyXG4qIEBjbGFzc1xyXG4qL1xyXG52YXIgQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxue1xyXG4gICAgdGhpcy5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdDtcclxuXHJcbiAgICAvLyAgVGhlIG9iamVjdHMgdGhhdCBiZWxvbmcgdG8gdGhpcyBjb2xsZWN0aW9uLlxyXG4gICAgLy8gIFRoZSBlcXVpdmFsZW50IG9mIHRoZSBvbGQgYFNwcml0ZS5jaGlsZHJlbmAgYXJyYXkuXHJcbiAgICB0aGlzLmxpc3QgPSBbXTtcclxuXHJcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxufTtcclxuXHJcbkNoaWxkcmVuLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENoaWxkcmVuO1xyXG5cclxuQ2hpbGRyZW4ucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGNoaWxkLCBza2lwVHJhbnNmb3JtKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChza2lwVHJhbnNmb3JtID09PSB1bmRlZmluZWQpIHsgc2tpcFRyYW5zZm9ybSA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0+JywgdGhpcy5nYW1lT2JqZWN0Lm5hbWUsICdhZGRzIG5ldyBjaGlsZDonLCBjaGlsZC5uYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDaGlsZHJlbi5hZGQgMScpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnBhcmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDaGlsZHJlbi5hZGQgMicpO1xyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQuY2hpbGRyZW4ucmVtb3ZlKGNoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXMuZ2FtZU9iamVjdDtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0LnB1c2goY2hpbGQpO1xyXG5cclxuICAgICAgICBpZiAoIXNraXBUcmFuc2Zvcm0gJiYgdGhpcy5nYW1lT2JqZWN0LnRyYW5zZm9ybSAmJiBjaGlsZC50cmFuc2Zvcm0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmdhbWVPYmplY3QubmFtZSwgJ2FkZHMgdHJhbnNmb3JtIGZyb20nLCBjaGlsZC5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lT2JqZWN0LnRyYW5zZm9ybS5hZGQoY2hpbGQudHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCc8LS0tIGVuZCcpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEF0OiBmdW5jdGlvbiAoY2hpbGQsIGluZGV4LCBza2lwVHJhbnNmb3JtKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gMDsgfVxyXG4gICAgICAgIGlmIChza2lwVHJhbnNmb3JtID09PSB1bmRlZmluZWQpIHsgc2tpcFRyYW5zZm9ybSA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxpc3QubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGNoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDw9IHRoaXMubGlzdC5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQuY2hpbGRyZW4ucmVtb3ZlKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGlzdC5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghc2tpcFRyYW5zZm9ybSAmJiB0aGlzLmdhbWVPYmplY3QudHJhbnNmb3JtICYmIGNoaWxkLnRyYW5zZm9ybSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZU9iamVjdC50cmFuc2Zvcm0uYWRkKGNoaWxkLnRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRNdWx0aXBsZTogZnVuY3Rpb24gKGNoaWxkcmVuLCBza2lwVHJhbnNmb3JtKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGNoaWxkcmVuW2ldLCBza2lwVHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBdDogZnVuY3Rpb24gKGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RbaW5kZXhdO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBSZXR1cm4gLTEgaWYgZ2l2ZW4gY2hpbGQgaXNuJ3QgYSBjaGlsZCBvZiB0aGlzIHBhcmVudFxyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QuaW5kZXhPZihjaGlsZCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHZXRzIHRoZSBmaXJzdCBpdGVtIGZyb20gdGhlIHNldCBiYXNlZCBvbiB0aGUgcHJvcGVydHkgc3RyaWN0bHkgZXF1YWxpbmcgdGhlIHZhbHVlIGdpdmVuLlxyXG4gICAgKiBSZXR1cm5zIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5BcnJheVNldCNnZXRCeUtleVxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgcHJvcGVydHkgdG8gY2hlY2sgYWdhaW5zdCB0aGUgdmFsdWUuXHJcbiAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjayBpZiB0aGUgcHJvcGVydHkgc3RyaWN0bHkgZXF1YWxzLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBpdGVtIHRoYXQgd2FzIGZvdW5kLCBvciBudWxsIGlmIG5vdGhpbmcgbWF0Y2hlZC5cclxuICAgICovXHJcbiAgICBnZXRCeUtleTogZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RbaV1bcHJvcGVydHldID09PSB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTZWFyY2hlcyB0aGUgR3JvdXAgZm9yIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhIGNoaWxkIHdpdGggdGhlIGBuYW1lYFxyXG4gICAgKiBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgZ2l2ZW4gYXJndW1lbnQuIFNob3VsZCBtb3JlIHRoYW4gb25lIGNoaWxkIGhhdmVcclxuICAgICogdGhlIHNhbWUgbmFtZSBvbmx5IHRoZSBmaXJzdCBpbnN0YW5jZSBpcyByZXR1cm5lZC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjZ2V0QnlOYW1lXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgdG8gc2VhcmNoIGZvci5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgZmlyc3QgY2hpbGQgd2l0aCBhIG1hdGNoaW5nIG5hbWUsIG9yIG51bGwgaWYgbm9uZSB3ZXJlIGZvdW5kLlxyXG4gICAgKi9cclxuICAgIGdldEJ5TmFtZTogZnVuY3Rpb24gKG5hbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnlLZXkoJ25hbWUnLCBuYW1lKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gY2hpbGQgZnJvbSB0aGUgZ3JvdXAuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI2dldFJhbmRvbVxyXG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydEluZGV4PTBdIC0gT2Zmc2V0IGZyb20gdGhlIGZyb250IG9mIHRoZSBncm91cCAobG93ZXN0IGNoaWxkKS5cclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoPSh0byB0b3ApXSAtIFJlc3RyaWN0aW9uIG9uIHRoZSBudW1iZXIgb2YgdmFsdWVzIHlvdSB3YW50IHRvIHJhbmRvbWx5IHNlbGVjdCBmcm9tLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IEEgcmFuZG9tIGNoaWxkIG9mIHRoaXMgR3JvdXAuXHJcbiAgICAqL1xyXG4gICAgZ2V0UmFuZG9tOiBmdW5jdGlvbiAoc3RhcnRJbmRleCwgbGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSB1bmRlZmluZWQpIHsgc3RhcnRJbmRleCA9IDA7IH1cclxuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsgbGVuZ3RoID0gdGhpcy5saXN0Lmxlbmd0aDsgfVxyXG5cclxuICAgICAgICBpZiAobGVuZ3RoID09PSAwIHx8IGxlbmd0aCA+IHRoaXMubGlzdC5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByYW5kb21JbmRleCA9IHN0YXJ0SW5kZXggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW5ndGgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0W3JhbmRvbUluZGV4XTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYWxsIGNoaWxkcmVuIGluIHRoaXMgR3JvdXAuXHJcbiAgICAqXHJcbiAgICAqIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IGEgbWF0Y2hpbmcgY3JpdGVyaWEgdXNpbmcgdGhlIGBwcm9wZXJ0eWAgYW5kIGB2YWx1ZWAgYXJndW1lbnRzLlxyXG4gICAgKlxyXG4gICAgKiBGb3IgZXhhbXBsZTogYGdldEFsbCgnZXhpc3RzJywgdHJ1ZSlgIHdvdWxkIHJldHVybiBvbmx5IGNoaWxkcmVuIHRoYXQgaGF2ZSB0aGVpciBleGlzdHMgcHJvcGVydHkgc2V0LlxyXG4gICAgKlxyXG4gICAgKiBPcHRpb25hbGx5IHlvdSBjYW4gc3BlY2lmeSBhIHN0YXJ0IGFuZCBlbmQgaW5kZXguIEZvciBleGFtcGxlIGlmIHRoaXMgR3JvdXAgaGFkIDEwMCBjaGlsZHJlbixcclxuICAgICogYW5kIHlvdSBzZXQgYHN0YXJ0SW5kZXhgIHRvIDAgYW5kIGBlbmRJbmRleGAgdG8gNTAsIGl0IHdvdWxkIHJldHVybiBtYXRjaGVzIGZyb20gb25seVxyXG4gICAgKiB0aGUgZmlyc3QgNTAgY2hpbGRyZW4gaW4gdGhlIEdyb3VwLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNnZXRBbGxcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBBbiBvcHRpb25hbCBwcm9wZXJ0eSB0byB0ZXN0IGFnYWluc3QgdGhlIHZhbHVlIGFyZ3VtZW50LlxyXG4gICAgKiBAcGFyYW0ge2FueX0gW3ZhbHVlXSAtIElmIHByb3BlcnR5IGlzIHNldCB0aGVuIENoaWxkLnByb3BlcnR5IG11c3Qgc3RyaWN0bHkgZXF1YWwgdGhpcyB2YWx1ZSB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0cy5cclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnRJbmRleD0wXSAtIFRoZSBmaXJzdCBjaGlsZCBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGZyb20uXHJcbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZEluZGV4XSAtIFRoZSBsYXN0IGNoaWxkIGluZGV4IHRvIHNlYXJjaCB1cCB1bnRpbC5cclxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBleGlzdGluZyBjaGlsZCBvZiB0aGlzIEdyb3VwLlxyXG4gICAgKi9cclxuICAgIGdldEFsbDogZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCkgeyBzdGFydEluZGV4ID0gMDsgfVxyXG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IGVuZEluZGV4ID0gdGhpcy5saXN0Lmxlbmd0aDsgfVxyXG5cclxuICAgICAgICB2YXIgb3V0cHV0ID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMubGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkW3Byb3BlcnR5XSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSxcclxuXHJcbiAgICBzd2FwOiBmdW5jdGlvbiAoY2hpbGQxLCBjaGlsZDIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNoaWxkMSA9PT0gY2hpbGQyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGluZGV4MSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQxKTtcclxuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5nZXRJbmRleChjaGlsZDIpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXgxIDwgMCB8fCBpbmRleDIgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZHJlbi5zd2FwOiBTdXBwbGllZCBvYmplY3RzIG11c3QgYmUgY2hpbGRyZW4gb2YgdGhlIHNhbWUgcGFyZW50Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxpc3RbaW5kZXgxXSA9IGNoaWxkMjtcclxuICAgICAgICB0aGlzLmxpc3RbaW5kZXgyXSA9IGNoaWxkMTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gICB3YXMgc2V0SW5kZXhcclxuICAgIG1vdmVUbzogZnVuY3Rpb24gKGNoaWxkLCBpbmRleClcclxuICAgIHtcclxuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5nZXRJbmRleChjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxpc3QubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZHJlbi5tb3ZlVG86IFRoZSBzdXBwbGllZCBpbmRleCBpcyBvdXQgb2YgYm91bmRzJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgUmVtb3ZlXHJcbiAgICAgICAgdGhpcy5saXN0LnNwbGljZShjdXJyZW50SW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAvLyAgQWRkIGluIG5ldyBsb2NhdGlvblxyXG4gICAgICAgIHRoaXMubGlzdC5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCwgc2tpcFRyYW5zZm9ybSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxpc3QuaW5kZXhPZihjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghc2tpcFRyYW5zZm9ybSAmJiB0aGlzLmdhbWVPYmplY3QudHJhbnNmb3JtICYmIGNoaWxkLnRyYW5zZm9ybSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lT2JqZWN0LnRyYW5zZm9ybS5yZW1vdmUoY2hpbGQudHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUF0OiBmdW5jdGlvbiAoaW5kZXgsIHNraXBUcmFuc2Zvcm0pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5saXN0W2luZGV4XTtcclxuXHJcbiAgICAgICAgaWYgKGNoaWxkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFza2lwVHJhbnNmb3JtICYmIHRoaXMuZ2FtZU9iamVjdC50cmFuc2Zvcm0gJiYgY2hpbGQudHJhbnNmb3JtKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWVPYmplY3QudHJhbnNmb3JtLnJlbW92ZShjaGlsZC50cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUJldHdlZW46IGZ1bmN0aW9uIChiZWdpbkluZGV4LCBlbmRJbmRleClcclxuICAgIHtcclxuICAgICAgICBpZiAoYmVnaW5JbmRleCA9PT0gdW5kZWZpbmVkKSB7IGJlZ2luSW5kZXggPSAwOyB9XHJcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgZW5kSW5kZXggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XHJcblxyXG4gICAgICAgIHZhciByYW5nZSA9IGVuZEluZGV4IC0gYmVnaW5JbmRleDtcclxuXHJcbiAgICAgICAgaWYgKHJhbmdlID4gMCAmJiByYW5nZSA8PSBlbmRJbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5saXN0LnNwbGljZShiZWdpbkluZGV4LCByYW5nZSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRbaV0ucGFyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmFuZ2UgPT09IDAgJiYgdGhpcy5saXN0Lmxlbmd0aCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZHJlbi5yZW1vdmVCZXR3ZWVuOiBSYW5nZSBFcnJvciwgbnVtZXJpYyB2YWx1ZXMgYXJlIG91dHNpZGUgdGhlIGFjY2VwdGFibGUgcmFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZW1vdmVzIGFsbCB0aGUgaXRlbXMuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkFycmF5U2V0I3JlbW92ZUFsbFxyXG4gICAgKi9cclxuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMubGlzdC5sZW5ndGg7XHJcblxyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLmxpc3RbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDaGVjayB0byBzZWUgaWYgdGhlIGdpdmVuIGNoaWxkIGlzIGEgY2hpbGQgb2YgdGhpcyBvYmplY3QsIGF0IGFueSBkZXB0aCAocmVjdXJzaXZlbHkgc2NhbnMgdXAgdGhlIHRyZWUpXHJcbiAgICBjb250YWluczogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghY2hpbGQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWlucyhjaGlsZC5wYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEJyaW5ncyB0aGUgZ2l2ZW4gY2hpbGQgdG8gdGhlIHRvcCBvZiB0aGlzIGdyb3VwIHNvIGl0IHJlbmRlcnMgYWJvdmUgYWxsIG90aGVyIGNoaWxkcmVuLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNicmluZ1RvVG9wXHJcbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBicmluZyB0byB0aGUgdG9wIG9mIHRoaXMgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGNoaWxkIHRoYXQgd2FzIG1vdmVkLlxyXG4gICAgKi9cclxuICAgIGJyaW5nVG9Ub3A6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzICYmIHRoaXMuZ2V0SW5kZXgoY2hpbGQpIDwgdGhpcy5saXN0Lmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogU2VuZHMgdGhlIGdpdmVuIGNoaWxkIHRvIHRoZSBib3R0b20gb2YgdGhpcyBncm91cCBzbyBpdCByZW5kZXJzIGJlbG93IGFsbCBvdGhlciBjaGlsZHJlbi5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjc2VuZFRvQmFja1xyXG4gICAgKiBAcGFyYW0ge2FueX0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gc2VuZCB0byB0aGUgYm90dG9tIG9mIHRoaXMgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGNoaWxkIHRoYXQgd2FzIG1vdmVkLlxyXG4gICAgKi9cclxuICAgIHNlbmRUb0JhY2s6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzICYmIHRoaXMuZ2V0SW5kZXgoY2hpbGQpID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRBdChjaGlsZCwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBNb3ZlcyB0aGUgZ2l2ZW4gY2hpbGQgdXAgb25lIHBsYWNlIGluIHRoaXMgZ3JvdXAgdW5sZXNzIGl0J3MgYWxyZWFkeSBhdCB0aGUgdG9wLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNtb3ZlVXBcclxuICAgICogQHBhcmFtIHthbnl9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIG1vdmUgdXAgaW4gdGhlIGdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBjaGlsZCB0aGF0IHdhcyBtb3ZlZC5cclxuICAgICovXHJcbiAgICBtb3ZlVXA6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQpO1xyXG5cclxuICAgICAgICBpZiAoYSAhPT0gLTEgJiYgYSA8IHRoaXMubGlzdC5sZW5ndGggLSAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmdldEF0KGEgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN3YXAoY2hpbGQsIGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBNb3ZlcyB0aGUgZ2l2ZW4gY2hpbGQgZG93biBvbmUgcGxhY2UgaW4gdGhpcyBncm91cCB1bmxlc3MgaXQncyBhbHJlYWR5IGF0IHRoZSBib3R0b20uXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI21vdmVEb3duXHJcbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBtb3ZlIGRvd24gaW4gdGhlIGdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBjaGlsZCB0aGF0IHdhcyBtb3ZlZC5cclxuICAgICovXHJcbiAgICBtb3ZlRG93bjogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRJbmRleChjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChhID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5nZXRBdChhIC0gMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zd2FwKGNoaWxkLCBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV2ZXJzZXMgYWxsIGNoaWxkcmVuIGluIHRoaXMgZ3JvdXAuXHJcbiAgICAqXHJcbiAgICAqIFRoaXMgb3BlcmF0aW9uIGFwcGxpZXMgb25seSB0byBpbW1lZGlhdGUgY2hpbGRyZW4gYW5kIGRvZXMgbm90IHByb3BhZ2F0ZSB0byBzdWJncm91cHMuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI3JldmVyc2VcclxuICAgICovXHJcbiAgICByZXZlcnNlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubGlzdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzaHVmZmxlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxpc3QubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5saXN0W2ldO1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RbaV0gPSB0aGlzLmxpc3Rbal07XHJcbiAgICAgICAgICAgIHRoaXMubGlzdFtqXSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJlcGxhY2VzIGEgY2hpbGQgb2YgdGhpcyBHcm91cCB3aXRoIHRoZSBnaXZlbiBuZXdDaGlsZC4gVGhlIG5ld0NoaWxkIGNhbm5vdCBiZSBhIG1lbWJlciBvZiB0aGlzIEdyb3VwLlxyXG4gICAgKlxyXG4gICAgKiBJZiBgR3JvdXAuZW5hYmxlQm9keWAgaXMgc2V0LCB0aGVuIGEgcGh5c2ljcyBib2R5IHdpbGwgYmUgY3JlYXRlZCBvbiB0aGUgb2JqZWN0LCBzbyBsb25nIGFzIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxyXG4gICAgKlxyXG4gICAgKiBJZiBgR3JvdXAuaW5wdXRFbmFibGVDaGlsZHJlbmAgaXMgc2V0LCB0aGVuIGFuIElucHV0IEhhbmRsZXIgd2lsbCBiZSBjcmVhdGVkIG9uIHRoZSBvYmplY3QsIHNvIGxvbmcgYXMgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI3JlcGxhY2VcclxuICAgICogQHBhcmFtIHthbnl9IG9sZENoaWxkIC0gVGhlIGNoaWxkIGluIHRoaXMgZ3JvdXAgdGhhdCB3aWxsIGJlIHJlcGxhY2VkLlxyXG4gICAgKiBAcGFyYW0ge2FueX0gbmV3Q2hpbGQgLSBUaGUgY2hpbGQgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGlzIGdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IFJldHVybnMgdGhlIG9sZENoaWxkIHRoYXQgd2FzIHJlcGxhY2VkIHdpdGhpbiB0aGlzIGdyb3VwLlxyXG4gICAgKi9cclxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChvbGRDaGlsZCwgbmV3Q2hpbGQsIHNraXBUcmFuc2Zvcm0pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleChvbGRDaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQucGFyZW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZC5wYXJlbnQucmVtb3ZlKG5ld0NoaWxkLCBza2lwVHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUob2xkQ2hpbGQsIHNraXBUcmFuc2Zvcm0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGRBdChuZXdDaGlsZCwgaW5kZXgsIHNraXBUcmFuc2Zvcm0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG9sZENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFN3YXBzIGEgY2hpbGQgZnJvbSBhbm90aGVyIHBhcmVudCwgd2l0aCBvbmUgZnJvbSB0aGlzIHBhcmVudC5cclxuICAgIC8vICBjaGlsZDEgPSB0aGUgY2hpbGQgb2YgVEhJUyBwYXJlbnRcclxuICAgIC8vICBjaGlsZDIgPSB0aGUgY2hpbGQgb2YgdGhlIE9USEVSIHBhcmVudFxyXG4gICAgZXhjaGFuZ2U6IGZ1bmN0aW9uIChjaGlsZDEsIGNoaWxkMiwgc2tpcFRyYW5zZm9ybSlcclxuICAgIHtcclxuICAgICAgICBpZiAoY2hpbGQxID09PSBjaGlsZDIgfHwgY2hpbGQxLnBhcmVudCA9PT0gY2hpbGQyLnBhcmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwYXJlbnRDaGlsZHJlbiA9IGNoaWxkMi5wYXJlbnQuY2hpbGRyZW47XHJcblxyXG4gICAgICAgIHZhciBpbmRleDEgPSB0aGlzLmdldEluZGV4KGNoaWxkMSk7XHJcbiAgICAgICAgdmFyIGluZGV4MiA9IHBhcmVudENoaWxkcmVuLmdldEluZGV4KGNoaWxkMik7XHJcblxyXG4gICAgICAgIGlmIChpbmRleDEgPCAwIHx8IGluZGV4MiA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLnN3YXA6IFN1cHBsaWVkIG9iamVjdHMgbXVzdCBiZSBjaGlsZHJlbiBvZiBwYXJlbnRzJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlbW92ZShjaGlsZDEsIHNraXBUcmFuc2Zvcm0pO1xyXG5cclxuICAgICAgICBwYXJlbnRDaGlsZHJlbi5yZW1vdmUoY2hpbGQyLCBza2lwVHJhbnNmb3JtKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRBdChjaGlsZDIsIGluZGV4MSwgc2tpcFRyYW5zZm9ybSk7XHJcblxyXG4gICAgICAgIHBhcmVudENoaWxkcmVuLmFkZEF0KGNoaWxkMSwgaW5kZXgyLCBza2lwVHJhbnNmb3JtKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENoZWNrcyBmb3IgdGhlIGl0ZW0gd2l0aGluIHRoaXMgbGlzdC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjZXhpc3RzXHJcbiAgICAqIEBwYXJhbSB7YW55fSBpdGVtIC0gVGhlIGVsZW1lbnQgdG8gZ2V0IHRoZSBsaXN0IGluZGV4IGZvci5cclxuICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaXRlbSBpcyBmb3VuZCBpbiB0aGUgbGlzdCwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gICAgKi9cclxuICAgIGV4aXN0czogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5saXN0LmluZGV4T2YoY2hpbGQpID4gLTEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGtleWAgdG8gdGhlIGdpdmVuIHZhbHVlIG9uIGFsbCBtZW1iZXJzIG9mIHRoaXMgbGlzdC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjc2V0QWxsXHJcbiAgICAqIEBwYXJhbSB7YW55fSBrZXkgLSBUaGUgcHJvcGVydHkgb2YgdGhlIGl0ZW0gdG8gc2V0LlxyXG4gICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBwcm9wZXJ0eSB0by5cclxuICAgICovXHJcbiAgICBzZXRBbGw6IGZ1bmN0aW9uIChrZXksIHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdFtpXSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2ldW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFBhc3NlcyBhbGwgY2hpbGRyZW4gdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIGVhY2hcclxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cclxuICAgICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXHJcbiAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3VtZW50c10gLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjaywgYWZ0ZXIgdGhlIGNoaWxkLlxyXG4gICAgKi9cclxuICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZylcclxuICAgIHtcclxuICAgICAgICB2YXIgYXJncyA9IFsgbnVsbCBdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB0aGlzLmxpc3RbaV07XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIE1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgR3JvdXAgdG8gdGhlIEdyb3VwIGdpdmVuLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNtb3ZlQWxsXHJcbiAgICAqIEBwYXJhbSB7UGhhc2VyLkdyb3VwfSBncm91cCAtIFRoZSBuZXcgR3JvdXAgdG8gd2hpY2ggdGhlIGNoaWxkcmVuIHdpbGwgYmUgbW92ZWQgdG8uXHJcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudD1mYWxzZV0gLSBJZiB0cnVlIHRoZSBjaGlsZHJlbiB3aWxsIG5vdCBkaXNwYXRjaCB0aGUgYG9uQWRkZWRUb0dyb3VwYCBldmVudCBmb3IgdGhlIG5ldyBHcm91cC5cclxuICAgICogQHJldHVybiB7UGhhc2VyLkdyb3VwfSBUaGUgR3JvdXAgdG8gd2hpY2ggYWxsIHRoZSBjaGlsZHJlbiB3ZXJlIG1vdmVkLlxyXG4gICAgKi9cclxuICAgIHJlcGFyZW50OiBmdW5jdGlvbiAobmV3UGFyZW50KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChuZXdQYXJlbnQgIT09IHRoaXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5yZW1vdmUodGhpcy5saXN0W2ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQuYWRkKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1BhcmVudDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGlsZHJlbi5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSBhbmQgcmVzZXRzIHRoZSBjdXJzb3IgdG8gdGhlIHN0YXJ0LlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuQXJyYXlTZXQjZmlyc3RcclxuICAgICogQHByb3BlcnR5IHthbnl9IGZpcnN0XHJcbiAgICAqL1xyXG4gICAgbGVuZ3RoOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3QubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIGFuZCByZXNldHMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5BcnJheVNldCNmaXJzdFxyXG4gICAgKiBAcHJvcGVydHkge2FueX0gZmlyc3RcclxuICAgICovXHJcbiAgICBmaXJzdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3QubGVuZ3RoID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIGxhc3QgaXRlbSBhbmQgcmVzZXRzIHRoZSBjdXJzb3IgdG8gdGhlIGVuZC5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLkFycmF5U2V0I2xhc3RcclxuICAgICogQHByb3BlcnR5IHthbnl9IGxhc3RcclxuICAgICovXHJcbiAgICBsYXN0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3QubGVuZ3RoID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMubGlzdC5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbdGhpcy5wb3NpdGlvbl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRoZSB0aGUgbmV4dCBpdGVtIChiYXNlZCBvbiB0aGUgY3Vyc29yKSBhbmQgYWR2YW5jZXMgdGhlIGN1cnNvci5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLkFycmF5U2V0I25leHRcclxuICAgICogQHByb3BlcnR5IHthbnl9IG5leHRcclxuICAgICovXHJcbiAgICBuZXh0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uIDwgdGhpcy5saXN0Lmxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbdGhpcy5wb3NpdGlvbl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRoZSB0aGUgcHJldmlvdXMgaXRlbSAoYmFzZWQgb24gdGhlIGN1cnNvcikgYW5kIHJldHJlYXRzIHRoZSBjdXJzb3IuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5BcnJheVNldCNwcmV2aW91c1xyXG4gICAgKiBAcHJvcGVydHkge2FueX0gcHJldmlvdXNcclxuICAgICovXHJcbiAgICBwcmV2aW91czoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24tLTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W3RoaXMucG9zaXRpb25dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENoaWxkcmVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL0NoaWxkcmVuLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBDaGlsZHJlbjogcmVxdWlyZSgnLi9DaGlsZHJlbicpLFxyXG4gICAgQ29sb3I6IHJlcXVpcmUoJy4vQ29sb3InKSxcclxuICAgIERhdGE6IHJlcXVpcmUoJy4vRGF0YScpLFxyXG4gICAgVHJhbnNmb3JtOiByZXF1aXJlKCcuL1RyYW5zZm9ybScpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzL2luZGV4LmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcG9vbCBpbnRvIHdoaWNoIHRoZSBjYW52YXMgZWxlbWVudHMgYXJlIHBsYWNlZC5cclxuICpcclxuICogQHByb3BlcnR5IHBvb2xcclxuICogQHR5cGUgQXJyYXlcclxuICovXHJcbnZhciBwb29sID0gW107XHJcblxyXG4vLyAgVGhpcyBzaW5nbGV0b24gaXMgaW5zdGFudGlhdGVkIGFzIHNvb24gYXMgUGhhc2VyIGxvYWRzLFxyXG4vLyAgYmVmb3JlIGEgUGhhc2VyLkdhbWUgaW5zdGFuY2UgaGFzIGV2ZW4gYmVlbiBjcmVhdGVkLlxyXG4vLyAgV2hpY2ggbWVhbnMgYWxsIGluc3RhbmNlcyBvZiBQaGFzZXIgR2FtZXMgb24gdGhlIHNhbWUgcGFnZVxyXG4vLyAgY2FuIHNoYXJlIHRoZSBvbmUgc2luZ2xlIHBvb2xcclxuXHJcbi8qKlxyXG4qIFRoZSBDYW52YXNQb29sIGlzIGEgZ2xvYmFsIHN0YXRpYyBvYmplY3QsIHRoYXQgYWxsb3dzIFBoYXNlciB0byByZWN5Y2xlIGFuZCBwb29sIENhbnZhcyBET00gZWxlbWVudHMuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLkNhbnZhc1Bvb2xcclxuKiBAc3RhdGljXHJcbiovXHJcbnZhciBDYW52YXNQb29sID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgLyoqXHJcbiAgICAqIENyZWF0ZXMgYSBuZXcgQ2FudmFzIERPTSBlbGVtZW50LCBvciBwdWxscyBvbmUgZnJvbSB0aGUgcG9vbCBpZiBmcmVlLlxyXG4gICAgKiBcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5jcmVhdGVcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAcGFyYW0ge2FueX0gcGFyZW50IC0gVGhlIHBhcmVudCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgZWxlbWVudC5cclxuICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IFRoZSBjYW52YXMgZWxlbWVudC5cclxuICAgICovXHJcbiAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodCwgdHlwZSlcclxuICAgIHtcclxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDE7IH1cclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMTsgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHsgdHlwZSA9IENPTlNULkNBTlZBUzsgfVxyXG5cclxuICAgICAgICB2YXIgY2FudmFzO1xyXG4gICAgICAgIHZhciBjb250YWluZXIgPSBmaXJzdCh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXNQb29sLmNyZWF0ZSBuZXcnKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHtcclxuICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxyXG4gICAgICAgICAgICAgICAgY2FudmFzOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHBvb2wucHVzaChjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgY2FudmFzID0gY29udGFpbmVyLmNhbnZhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NhbnZhc1Bvb2wuY3JlYXRlIGV4aXN0aW5nJyk7XHJcblxyXG4gICAgICAgICAgICBjb250YWluZXIucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgY2FudmFzID0gY29udGFpbmVyLmNhbnZhcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNyZWF0ZTJEID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlKHBhcmVudCwgd2lkdGgsIGhlaWdodCwgQ09OU1QuQ0FOVkFTKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNyZWF0ZVdlYkdMID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlKHBhcmVudCwgd2lkdGgsIGhlaWdodCwgQ09OU1QuV0VCR0wpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogR2V0cyB0aGUgZmlyc3QgZnJlZSBjYW52YXMgaW5kZXggZnJvbSB0aGUgcG9vbC5cclxuICAgICogXHJcbiAgICAqIEBzdGF0aWNcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5nZXRGaXJzdFxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAqL1xyXG4gICAgdmFyIGZpcnN0ID0gZnVuY3Rpb24gKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkgeyB0eXBlID0gQ09OU1QuQ0FOVkFTOyB9XHJcblxyXG4gICAgICAgIHBvb2wuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIucGFyZW50ICYmIGNvbnRhaW5lci50eXBlID09PSB0eXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogTG9va3MgdXAgYSBjYW52YXMgYmFzZWQgb24gaXRzIHBhcmVudCwgYW5kIGlmIGZvdW5kIHB1dHMgaXQgYmFjayBpbiB0aGUgcG9vbCwgZnJlZWluZyBpdCB1cCBmb3IgcmUtdXNlLlxyXG4gICAgKiBUaGUgY2FudmFzIGhhcyBpdHMgd2lkdGggYW5kIGhlaWdodCBzZXQgdG8gMSwgYW5kIGl0cyBwYXJlbnQgYXR0cmlidXRlIG51bGxlZC5cclxuICAgICogXHJcbiAgICAqIEBzdGF0aWNcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5yZW1vdmVcclxuICAgICogQHBhcmFtIHthbnl8SFRNTENhbnZhc0VsZW1lbnR9IHBhcmVudCAtIFRoZSBwYXJlbnQgb2YgdGhlIGNhbnZhcyBlbGVtZW50LlxyXG4gICAgKi9cclxuICAgIHZhciByZW1vdmUgPSBmdW5jdGlvbiAocGFyZW50KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBDaGVjayB0byBzZWUgaWYgdGhlIHBhcmVudCBpcyBhIGNhbnZhcyBvYmplY3RcclxuICAgICAgICB2YXIgaXNDYW52YXMgPSBwYXJlbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcclxuXHJcbiAgICAgICAgcG9vbC5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWluZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoKGlzQ2FudmFzICYmIGNvbnRhaW5lci5jYW52YXMgPT09IHBhcmVudCkgfHwgKCFpc0NhbnZhcyAmJiBjb250YWluZXIucGFyZW50ID09PSBwYXJlbnQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2FudmFzUG9vbC5yZW1vdmUgZm91bmQgYW5kIHJlbW92ZWQnKTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNhbnZhcy53aWR0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLmhlaWdodCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiB1c2VkIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cclxuICAgICogXHJcbiAgICAqIEBzdGF0aWNcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5nZXRUb3RhbFxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgaW4tdXNlIChwYXJlbnRlZCkgY2FudmFzIGVsZW1lbnRzIGluIHRoZSBwb29sLlxyXG4gICAgKi9cclxuICAgIHZhciB0b3RhbCA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGMgPSAwO1xyXG5cclxuICAgICAgICBwb29sLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhaW5lcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXIucGFyZW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2YgZnJlZSBjYW52YXMgZWxlbWVudHMgaW4gdGhlIHBvb2wuXHJcbiAgICAqIFxyXG4gICAgKiBAc3RhdGljXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkNhbnZhc1Bvb2wuZ2V0RnJlZVxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZnJlZSAodW4tcGFyZW50ZWQpIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cclxuICAgICovXHJcbiAgICB2YXIgZnJlZSA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHBvb2wubGVuZ3RoIC0gdG90YWwoKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjcmVhdGU6IGNyZWF0ZSxcclxuICAgICAgICBjcmVhdGUyRDogY3JlYXRlMkQsXHJcbiAgICAgICAgY3JlYXRlV2ViR0w6IGNyZWF0ZVdlYkdMLFxyXG4gICAgICAgIGZpcnN0OiBmaXJzdCxcclxuICAgICAgICByZW1vdmU6IHJlbW92ZSxcclxuICAgICAgICB0b3RhbDogdG90YWwsXHJcbiAgICAgICAgZnJlZTogZnJlZSxcclxuICAgICAgICBwb29sOiBwb29sXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLy8gIElmIHdlIGV4cG9ydCB0aGUgY2FsbGVkIGZ1bmN0aW9uIGhlcmUsIGl0J2xsIG9ubHkgYmUgaW52b2tlZCBvbmNlIChub3QgZXZlcnkgdGltZSBpdCdzIHJlcXVpcmVkKS5cclxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNQb29sKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9DYW52YXNQb29sLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kb20vQ2FudmFzUG9vbC5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgU2NhbGVNb2RlcyA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL1NjYWxlTW9kZXMnKTtcclxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMnKTtcclxudmFyIFdyYXBBbmdsZSA9IHJlcXVpcmUoJy4uL21hdGgvYW5nbGUvV3JhcCcpO1xyXG5cclxuLyoqXHJcbiogVGhpcyBpcyB0aGUgYmFzZSBHYW1lIE9iamVjdCBjbGFzcyB0aGF0IHlvdSBjYW4gdXNlIHdoZW4gY3JlYXRpbmcgeW91ciBvd24gZXh0ZW5kZWQgR2FtZSBPYmplY3RzLlxyXG4qIEl0IGhpZGVzIGF3YXkgdGhlICdwcml2YXRlJyBzdHVmZiBhbmQgZXhwb3NlcyBvbmx5IHRoZSB1c2VmdWwgZ2V0dGVycywgc2V0dGVycyBhbmQgcHJvcGVydGllcy5cclxuKlxyXG4qIEBjbGFzc1xyXG4qL1xyXG5cclxuLy8gIFBoYXNlci5UZXh0dXJlIGFuZCBQaGFzZXIuRnJhbWUgb2JqZWN0cyBwYXNzZWQgaW4gaGVyZSwgaW5zdGVhZCBvZiBsb29rZWQtdXAuXHJcbi8vICBBbGxvd3Mgb3ZlcnJpZGUgZnJvbSBub24tc3RhbmRhcmQgR08gdHlwZXNcclxuXHJcbnZhciBHYW1lT2JqZWN0ID0gZnVuY3Rpb24gKHN0YXRlLCB4LCB5LCB0ZXh0dXJlLCBmcmFtZSwgcGFyZW50KVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5nYW1lID0gc3RhdGUuZ2FtZTtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSAnJztcclxuXHJcbiAgICB0aGlzLnR5cGUgPSAwO1xyXG5cclxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgIC8vICBUZXh0dXJlIGlzIGdsb2JhbGx5IHNoYXJlZCBiZXR3ZWVuIEdhbWVPYmplY3RzLCBub3Qgc3BlY2lmaWMgdG8gdGhpcyBvbmVcclxuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XHJcblxyXG4gICAgLy8gIEZyYW1lIGlzIGdsb2JhbGx5IHNoYXJlZCBiZXR3ZWVuIEdhbWVPYmplY3RzLCBub3Qgc3BlY2lmaWMgdG8gdGhpcyBvbmVcclxuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcclxuXHJcbiAgICAvLyAgQWxsIEdhbWVPYmplY3RzIGhhdmUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzLCBhbHdheXM6XHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBDb21wb25lbnQuVHJhbnNmb3JtKHRoaXMsIHgsIHkpO1xyXG5cclxuICAgIC8vICBPcHRpb25hbD8gTWF5YmUgc2V0IG9uIGEgcGVyIEdPIGJhc2lzP1xyXG4gICAgdGhpcy5kYXRhID0gbmV3IENvbXBvbmVudC5EYXRhKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuY29sb3IgPSBuZXcgQ29tcG9uZW50LkNvbG9yKHRoaXMpO1xyXG5cclxuICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgZGViYXRhYmxlIHRvIGhhdmUgaW4gdGhpcyBjbGFzc1xyXG4gICAgLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgdGhpcy5zY2FsZU1vZGUgPSBTY2FsZU1vZGVzLkRFRkFVTFQ7XHJcblxyXG4gICAgLy8gIEFsbG93cyB5b3UgdG8gdHVybiBvZmYgYSBHYW1lT2JqZWN0IGZyb20gcmVuZGVyaW5nLCBidXQgc3RpbGwgcmVuZGVyIGl0cyBjaGlsZHJlbiAoaWYgaXQgaGFzIGFueSlcclxuICAgIC8vICBNYXliZSB0aGlzIHNob3VsZCBtb3ZlP1xyXG4gICAgLy8gdGhpcy5za2lwUmVuZGVyID0gKGtleSA9PT0gdW5kZWZpbmVkKTtcclxuICAgIHRoaXMuc2tpcFJlbmRlciA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgLy8gIEVpdGhlciBudWxsLCBvciB0aGUgQ2hpbGRyZW4gY29tcG9uZW50XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmV4aXN0cyA9IHRydWU7XHJcbn07XHJcblxyXG5HYW1lT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdhbWVPYmplY3Q7XHJcblxyXG5HYW1lT2JqZWN0LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBwcmVVcGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE5PT1BcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBOT09QXHJcbiAgICB9LFxyXG5cclxuICAgIHBvc3RVcGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE5PT1BcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBOT09QXHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE5PT1BcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhHYW1lT2JqZWN0LnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8vICBUcmFuc2Zvcm0gZ2V0dGVycyAvIHNldHRlcnNcclxuXHJcbiAgICB4OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcG9zWDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9wb3NYID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB5OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcG9zWTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9wb3NZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX3NjYWxlWDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9zY2FsZVggPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3NjYWxlWSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGVYOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3NjYWxlWCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGVZOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3NjYWxlWSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYW5jaG9yOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fYW5jaG9yWDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnNldEFuY2hvcih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYW5jaG9yWDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX2FuY2hvclg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fYW5jaG9yWCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYW5jaG9yWToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX2FuY2hvclk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fYW5jaG9yWSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGl2b3RYOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcGl2b3RYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3Bpdm90WCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGl2b3RZOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcGl2b3RZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3Bpdm90WSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYW5nbGU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFdyYXBBbmdsZSh0aGlzLnJvdGF0aW9uICogTUFUSF9DT05TVC5SQURfVE9fREVHKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSBXcmFwQW5nbGUodmFsdWUpICogTUFUSF9DT05TVC5ERUdfVE9fUkFEO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0aW9uOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcm90YXRpb247XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0uX3JvdGF0aW9uID09PSB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcm90YXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uZGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbiAlIE1BVEhfQ09OU1QuUEkyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5jYWNoZS5zciA9IE1hdGguc2luKHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5jYWNoZS5jciA9IE1hdGguY29zKHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uaGFzTG9jYWxSb3RhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5oYXNMb2NhbFJvdGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ29sb3IgZ2V0dGVycyAvIHNldHRlcnNcclxuXHJcbiAgICBhbHBoYToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5fYWxwaGE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yLmFscGhhID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYmxlbmRNb2RlOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yLl9ibGVuZE1vZGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yLmJsZW5kTW9kZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZU9iamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvR2FtZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvR2FtZU9iamVjdC5qcyIsInZhciBDb250YWlucyA9IGZ1bmN0aW9uIChjaXJjbGUsIHgsIHkpXHJcbntcclxuICAgIC8vICBDaGVjayBpZiB4L3kgYXJlIHdpdGhpbiB0aGUgYm91bmRzIGZpcnN0XHJcbiAgICBpZiAoY2lyY2xlLnJhZGl1cyA+IDAgJiYgeCA+PSBjaXJjbGUubGVmdCAmJiB4IDw9IGNpcmNsZS5yaWdodCAmJiB5ID49IGNpcmNsZS50b3AgJiYgeSA8PSBjaXJjbGUuYm90dG9tKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkeCA9IChjaXJjbGUueCAtIHgpICogKGNpcmNsZS54IC0geCk7XHJcbiAgICAgICAgdmFyIGR5ID0gKGNpcmNsZS55IC0geSkgKiAoY2lyY2xlLnkgLSB5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChkeCArIGR5KSA8PSAoY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NvbnRhaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29udGFpbnMgPSBmdW5jdGlvbiAoZWxsaXBzZSwgeCwgeSlcclxue1xyXG4gICAgaWYgKGVsbGlwc2Uud2lkdGggPD0gMCB8fCBlbGxpcHNlLmhlaWdodCA8PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuIFxyXG4gICAgLy8gIE5vcm1hbGl6ZSB0aGUgY29vcmRzIHRvIGFuIGVsbGlwc2Ugd2l0aCBjZW50ZXIgMCwwIGFuZCBhIHJhZGl1cyBvZiAwLjVcclxuICAgIHZhciBub3JteCA9ICgoeCAtIGVsbGlwc2UueCkgLyBlbGxpcHNlLndpZHRoKSAtIDAuNTtcclxuICAgIHZhciBub3JteSA9ICgoeSAtIGVsbGlwc2UueSkgLyBlbGxpcHNlLmhlaWdodCkgLSAwLjU7XHJcbiBcclxuICAgIG5vcm14ICo9IG5vcm14O1xyXG4gICAgbm9ybXkgKj0gbm9ybXk7XHJcbiBcclxuICAgIHJldHVybiAobm9ybXggKyBub3JteSA8IDAuMjUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWlucztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb252ZXJ0IGEgZGlzdGFuY2UgYWxvbmcgdGhpcyBjdXJ2ZSBpbnRvIGEgYHRpbWVgIHZhbHVlIHdoaWNoIHdpbGwgYmUgYmV0d2VlbiAwIGFuZCAxLlxyXG4qIFxyXG4qIEZvciBleGFtcGxlIGlmIHRoaXMgY3VydmUgaGFzIGEgbGVuZ3RoIG9mIDEwMCBwaXhlbHMgdGhlbiBgZmluZFQoNTApYCB3b3VsZCByZXR1cm4gYDAuNWAuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2ZpbmRUXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBkaXN0YW5jZSAtIFRoZSBkaXN0YW5jZSBpbnRvIHRoZSBjdXJ2ZSBpbiBwaXhlbHMuIFNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgdGltZSAoYHRgKSB2YWx1ZSwgYSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXHJcbiovXHJcbnZhciBGaW5kVCA9IGZ1bmN0aW9uIChjdXJ2ZSwgZGlzdGFuY2UpXHJcbntcclxuICAgIGlmIChkaXN0YW5jZSA8PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBGaW5kIHRoZSBfcG9pbnRzIHdoaWNoIGJyYWNrZXQgdGhlIGRpc3RhbmNlIHZhbHVlXHJcbiAgICB2YXIgdGkgPSBNYXRoLmZsb29yKGRpc3RhbmNlIC8gY3VydmUubGVuZ3RoICogY3VydmUuX2FjY3VyYWN5KTtcclxuXHJcbiAgICB3aGlsZSAodGkgPiAwICYmIGN1cnZlLl9wb2ludHNbdGldID4gZGlzdGFuY2UpXHJcbiAgICB7XHJcbiAgICAgICAgdGktLTtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAodGkgPCBjdXJ2ZS5fYWNjdXJhY3kgJiYgY3VydmUuX3BvaW50c1t0aV0gPCBkaXN0YW5jZSlcclxuICAgIHtcclxuICAgICAgICB0aSsrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBMaW5lYXIgaW50ZXJwb2xhdGlvbiB0byBnZXQgYSBtb3JlIGFjY3VyYXRlIGZpeFxyXG4gICAgdmFyIGR0ID0gY3VydmUuX3BvaW50c1t0aV0gLSBjdXJ2ZS5fcG9pbnRzW3RpIC0gMV07XHJcbiAgICB2YXIgZCA9IGRpc3RhbmNlIC0gY3VydmUuX3BvaW50c1t0aSAtIDFdO1xyXG5cclxuICAgIHJldHVybiAoKHRpIC0gMSkgLyBjdXJ2ZS5fYWNjdXJhY3kpICsgZCAvIChkdCAqIGN1cnZlLl9hY2N1cmFjeSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpbmRUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvRmluZFQuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG4vKipcclxuKiBHZXQgYSBwb2ludCBvbiB0aGUgY3VydmUgdXNpbmcgdGhlIGB0YCAodGltZSkgdmFsdWUsIHdoaWNoIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRQb2ludFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbdD0wXSAtIFRoZSB0aW1lIHZhbHVlIGFsb25nIHRoZSBjdXJ2ZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgYSBwb2ludC4gVGhpcyBpcyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiB0aGUgY3VydmUgYW5kIDEgdGhlIGVuZC5cclxuKiBAcGFyYW0ge1BoYXNlci5Qb2ludHxPYmplY3R9IFtwb2ludF0gLSBBbiBvcHRpb25hbCBQaGFzZXIuUG9pbnQsIG9yIE9iamVjdCBjb250YWluaW5nIHB1YmxpYyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLiBJZiBnaXZlbiB0aGUgcmVzdWx0aW5nIHZhbHVlcyB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgT2JqZWN0cyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLiBJZiBvbWl0dGVkIGEgbmV3IFBoYXNlci5Qb2ludCBvYmplY3QgaXMgY3JlYXRlZC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuUG9pbnR9IEFuIE9iamVjdCB3aXRoIHRoZSB4LCB5IGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGF0IHRoZSBzcGVjaWZpZWQgYHRgIHZhbHVlIHNldCBpbiBpdHMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy5cclxuKi9cclxudmFyIEdldFBvaW50ID0gZnVuY3Rpb24gKGN1cnZlLCB0LCBvdXQpXHJcbntcclxuICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHsgdCA9IDA7IH1cclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIGlmICh0IDwgMClcclxuICAgIHtcclxuICAgICAgICB0ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodCA+IDEpXHJcbiAgICB7XHJcbiAgICAgICAgdCA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHQyID0gdCAqIHQ7XHJcbiAgICB2YXIgdDMgPSB0ICogdDI7XHJcblxyXG4gICAgb3V0LnggPSB0MyAqIGN1cnZlLl9heCArIHQyICogY3VydmUuX2J4ICsgdCAqIGN1cnZlLl92MXggKyBjdXJ2ZS5fcDF4O1xyXG4gICAgb3V0LnkgPSB0MyAqIGN1cnZlLl9heSArIHQyICogY3VydmUuX2J5ICsgdCAqIGN1cnZlLl92MXkgKyBjdXJ2ZS5fcDF5O1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0UG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9HZXRQb2ludC5qcyIsIlxyXG52YXIgUm90YXRlQXJvdW5kWFkgPSBmdW5jdGlvbiAobGluZSwgeCwgeSwgYW5nbGUpXHJcbntcclxuICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgdmFyIHR4ID0gbGluZS54MSAtIHg7XHJcbiAgICB2YXIgdHkgPSBsaW5lLnkxIC0geTtcclxuXHJcbiAgICBsaW5lLngxID0gdHggKiBjIC0gdHkgKiBzICsgeDtcclxuICAgIGxpbmUueTEgPSB0eCAqIHMgKyB0eSAqIGMgKyB5O1xyXG5cclxuICAgIHR4ID0gbGluZS54MiAtIHg7XHJcbiAgICB0eSA9IGxpbmUueTIgLSB5O1xyXG5cclxuICAgIGxpbmUueDIgPSB0eCAqIGMgLSB0eSAqIHMgKyB4O1xyXG4gICAgbGluZS55MiA9IHR4ICogcyArIHR5ICogYyArIHk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZFhZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kWFkuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEb3QgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIpXHJcbntcclxuICAgIHJldHVybiAoKHBvaW50QS54ICogcG9pbnRCLngpICsgKHBvaW50QS55ICogcG9pbnRCLnkpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRG90O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0RvdC5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEFzcGVjdFJhdGlvID0gZnVuY3Rpb24gKHJlY3QpXHJcbntcclxuICAgIHJldHVybiAocmVjdC5oZWlnaHQgPT09IDApID8gTmFOIDogcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBc3BlY3RSYXRpbztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvR2V0QXNwZWN0UmF0aW8uanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBDcmVhdGVzIGFuIFhIUlNldHRpbmdzIE9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcblxyXG52YXIgWEhSU2V0dGluZ3MgPSBmdW5jdGlvbiAocmVzcG9uc2VUeXBlLCBhc3luYywgdXNlciwgcGFzc3dvcmQsIHRpbWVvdXQpXHJcbntcclxuICAgIGlmIChyZXNwb25zZVR5cGUgPT09IHVuZGVmaW5lZCkgeyByZXNwb25zZVR5cGUgPSAnJzsgfVxyXG4gICAgaWYgKGFzeW5jID09PSB1bmRlZmluZWQpIHsgYXN5bmMgPSB0cnVlOyB9XHJcbiAgICBpZiAodXNlciA9PT0gdW5kZWZpbmVkKSB7IHVzZXIgPSAnJzsgfVxyXG4gICAgaWYgKHBhc3N3b3JkID09PSB1bmRlZmluZWQpIHsgcGFzc3dvcmQgPSAnJzsgfVxyXG4gICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkgeyB0aW1lb3V0ID0gMDsgfVxyXG5cclxuICAgIC8vIEJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCwgc2V0IHRoZSB4aHIucmVzcG9uc2VUeXBlIHRvIFwidGV4dFwiLCBcclxuICAgIC8vIFwiYXJyYXlidWZmZXJcIiwgXCJibG9iXCIsIG9yIFwiZG9jdW1lbnRcIiwgZGVwZW5kaW5nIG9uIHlvdXIgZGF0YSBuZWVkcy4gXHJcbiAgICAvLyBOb3RlLCBzZXR0aW5nIHhoci5yZXNwb25zZVR5cGUgPSAnJyAob3Igb21pdHRpbmcpIHdpbGwgZGVmYXVsdCB0aGUgcmVzcG9uc2UgdG8gXCJ0ZXh0XCIuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgLy8gIElnbm9yZWQgYnkgdGhlIExvYWRlciwgb25seSB1c2VkIGJ5IEZpbGUuXHJcbiAgICAgICAgcmVzcG9uc2VUeXBlOiByZXNwb25zZVR5cGUsXHJcblxyXG4gICAgICAgIGFzeW5jOiBhc3luYyxcclxuXHJcbiAgICAgICAgLy8gIGNyZWRlbnRpYWxzXHJcbiAgICAgICAgdXNlcjogdXNlcixcclxuICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXHJcblxyXG4gICAgICAgIC8vICB0aW1lb3V0IGluIG1zICgwID0gbm8gdGltZW91dClcclxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxyXG5cclxuICAgICAgICAvLyAgc2V0UmVxdWVzdEhlYWRlclxyXG4gICAgICAgIGhlYWRlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgIGhlYWRlclZhbHVlOiB1bmRlZmluZWQsXHJcblxyXG4gICAgICAgIC8vICBvdmVycmlkZU1pbWVUeXBlXHJcbiAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogdW5kZWZpbmVkXHJcblxyXG4gICAgfTtcclxuICAgIFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYSFJTZXR0aW5ncztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL1hIUlNldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3JlYXRlQnVmZmVyID0gZnVuY3Rpb24gKGdsLCBidWZmZXJUeXBlLCB1c2FnZSwgYnVmZmVyRGF0YSwgYnVmZmVyU2l6ZSlcclxue1xyXG4gICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihidWZmZXJUeXBlLCBidWZmZXIpO1xyXG4gICAgaWYgKGJ1ZmZlckRhdGEgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlckRhdGEpKVxyXG4gICAge1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoYnVmZmVyVHlwZSwgYnVmZmVyRGF0YSwgdXNhZ2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoYnVmZmVyVHlwZSwgYnVmZmVyU2l6ZSwgdXNhZ2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlQnVmZmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy9idWZmZXIvQ3JlYXRlQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW5kZXhCdWZmZXIgPSBmdW5jdGlvbiAoYnl0ZVNpemUpXHJcbntcclxuICAgIHRoaXMud29yZExlbmd0aCA9IDA7XHJcbiAgICB0aGlzLndvcmRDYXBhY2l0eSA9IGJ5dGVTaXplIC8gMjtcclxuICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTaXplKTtcclxuICAgIHRoaXMuc2hvcnRWaWV3ID0gbmV3IEludDE2QXJyYXkodGhpcy5idWZmZXIpO1xyXG4gICAgdGhpcy53b3JkVmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbn07XHJcblxyXG5JbmRleEJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLndvcmRMZW5ndGggPSAwO1xyXG59O1xyXG5cclxuSW5kZXhCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy53b3JkTGVuZ3RoICogMjtcclxufTtcclxuXHJcbkluZGV4QnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlQ2FwYWNpdHkgPSBmdW5jdGlvbiAoKSBcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbn07XHJcblxyXG5JbmRleEJ1ZmZlci5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbiAod29yZFNpemUpXHJcbntcclxuICAgIHZhciBjdXJyZW50TGVuZ3RoID0gdGhpcy53b3JkTGVuZ3RoO1xyXG4gICAgdGhpcy53b3JkTGVuZ3RoICs9IHdvcmRTaXplO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRMZW5ndGg7XHJcbn07XHJcblxyXG5JbmRleEJ1ZmZlci5wcm90b3R5cGUuZ2V0VXNlZEJ1ZmZlckFzU2hvcnQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5zaG9ydFZpZXcuc3ViYXJyYXkoMCwgdGhpcy5kd29yZExlbmd0aCk7XHJcbn07XHJcblxyXG5JbmRleEJ1ZmZlci5wcm90b3R5cGUuZ2V0VXNlZEJ1ZmZlckFzV29yZCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLndvcmRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmRleEJ1ZmZlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvYnVmZmVyL0luZGV4QnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVmVydGV4QnVmZmVyID0gZnVuY3Rpb24gKGJ5dGVTaXplKVxyXG57XHJcbiAgICB0aGlzLmR3b3JkTGVuZ3RoID0gMDtcclxuICAgIHRoaXMuZHdvcmRDYXBhY2l0eSA9IGJ5dGVTaXplIC8gNDtcclxuICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTaXplKTtcclxuICAgIHRoaXMuZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICB0aGlzLmludFZpZXcgPSBuZXcgSW50MzJBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICB0aGlzLnVpbnRWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuYnVmZmVyKTtcclxufTtcclxuXHJcblZlcnRleEJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLmR3b3JkTGVuZ3RoID0gMDtcclxufTtcclxuXHJcblZlcnRleEJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZUxlbmd0aCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmR3b3JkTGVuZ3RoICogNDtcclxufTtcclxuXHJcblZlcnRleEJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZUNhcGFjaXR5ID0gZnVuY3Rpb24gKCkgXHJcbntcclxuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG59O1xyXG5cclxuVmVydGV4QnVmZmVyLnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uIChkd29yZFNpemUpXHJcbntcclxuICAgIHZhciBjdXJyZW50TGVuZ3RoID0gdGhpcy5kd29yZExlbmd0aDtcclxuICAgIHRoaXMuZHdvcmRMZW5ndGggKz0gZHdvcmRTaXplO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRMZW5ndGg7XHJcbn07XHJcblxyXG5WZXJ0ZXhCdWZmZXIucHJvdG90eXBlLmdldFVzZWRCdWZmZXJBc0Zsb2F0ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuZmxvYXRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xyXG59O1xyXG5cclxuVmVydGV4QnVmZmVyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNJbnQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5pbnRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xyXG59O1xyXG5cclxuVmVydGV4QnVmZmVyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNVaW50ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMudWludFZpZXcuc3ViYXJyYXkoMCwgdGhpcy5kd29yZExlbmd0aCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEJ1ZmZlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvYnVmZmVyL1ZlcnRleEJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbiAoZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpXHJcbntcclxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XHJcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICBnbC52YWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsaW5rIHByb2dyYW0uIEVycm9yOiBcXG4nICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb2dyYW07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVByb2dyYW07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3JlYXRlU2hhZGVyID0gZnVuY3Rpb24gKGdsLCBzaGFkZXJTb3VyY2UsIHNoYWRlclR5cGUpXHJcbntcclxuICAgIHZhciBzaGFkZXIgPSBudWxsO1xyXG4gICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xyXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCAnICsgKHNoYWRlclR5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyAndmVydGV4JyA6IHNoYWRlclR5cGUgPT09IGdsLkZSQUdNRU5UX1NIQURFUiA/ICdmcmFnbWVudCcgOiAnaW52YWxpZCcpICsgJyBzaGFkZXIgY29tcGlsYXRpb24uIEVycm9yOiBcXG4nICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBzaGFkZXI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVNoYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJpbmRWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uIChnbCwgdmFvKVxyXG57XHJcbiAgICB2YXIgYXR0cmlidXRlcyA9IHZhby5hdHRyaWJ1dGVzO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZhby5idWZmZXIpO1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGF0dHJpYiA9IGF0dHJpYnV0ZXNbaW5kZXhdO1xyXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGF0dHJpYi5sb2NhdGlvbjtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuICAgICAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgICAgIGF0dHJpYi5zaXplLFxyXG4gICAgICAgICAgICBhdHRyaWIudHlwZSxcclxuICAgICAgICAgICAgYXR0cmliLm5vcm1hbGl6ZWQsXHJcbiAgICAgICAgICAgIGF0dHJpYi5zdHJpZGUsXHJcbiAgICAgICAgICAgIGF0dHJpYi5vZmZzZXRcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaW5kVmVydGV4QXJyYXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9CaW5kVmVydGV4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL0F0dHJpYnV0ZScpO1xyXG5cclxudmFyIENyZWF0ZUF0dHJpYkRlc2MgPSBmdW5jdGlvbiAoZ2wsIHByb2dyYW0sIG5hbWUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KVxyXG57XHJcbiAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZShcclxuICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcclxuICAgICAgICBzaXplLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgbm9ybWFsaXplZCxcclxuICAgICAgICBzdHJpZGUsXHJcbiAgICAgICAgb2Zmc2V0XHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVBdHRyaWJEZXNjO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MuanMiLCJ2YXIgVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAodmJvLCBhdHRyaWJ1dGVzKVxyXG57XHJcbiAgICB0aGlzLmJ1ZmZlciA9IHZibztcclxuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEFycmF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vVmVydGV4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vZG9tL0NhbnZhc1Bvb2wnKTtcclxuXHJcbnZhciBDYW52YXNGZWF0dXJlcyA9IHtcclxuXHJcbiAgICBzdXBwb3J0TmV3QmxlbmRNb2RlczogZmFsc2UsXHJcblxyXG4gICAgc3VwcG9ydEludmVyc2VBbHBoYTogZmFsc2VcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBjaGVja0JsZW5kTW9kZSAoKVxyXG57XHJcbiAgICB2YXIgcG5nSGVhZCA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFRQUFBQUJBUU1BQUFERDhwMk9BQUFBQTFCTVZFWC8nO1xyXG4gICAgdmFyIHBuZ0VuZCA9ICdBQUFBQ2tsRVFWUUkxMk5nQUFBQUFnQUI0aUc4TXdBQUFBQkpSVTVFcmtKZ2dnPT0nO1xyXG5cclxuICAgIHZhciBtYWdlbnRhID0gbmV3IEltYWdlKCk7XHJcbiAgICBtYWdlbnRhLnNyYyA9IHBuZ0hlYWQgKyAnQVA4MDRPYTYnICsgcG5nRW5kO1xyXG5cclxuICAgIHZhciB5ZWxsb3cgPSBuZXcgSW1hZ2UoKTtcclxuICAgIHllbGxvdy5zcmMgPSBwbmdIZWFkICsgJy93Q0t4dlJGJyArIHBuZ0VuZDtcclxuXHJcbiAgICB2YXIgY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGUodGhpcywgNiwgMSk7XHJcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ211bHRpcGx5JztcclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKG1hZ2VudGEsIDAsIDApO1xyXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoeWVsbG93LCAyLCAwKTtcclxuXHJcbiAgICBpZiAoIWNvbnRleHQuZ2V0SW1hZ2VEYXRhKDIsIDAsIDEsIDEpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDIsIDAsIDEsIDEpLmRhdGE7XHJcblxyXG4gICAgQ2FudmFzUG9vbC5yZW1vdmUodGhpcyk7XHJcblxyXG4gICAgcmV0dXJuIChkYXRhWzBdID09PSAyNTUgJiYgZGF0YVsxXSA9PT0gMCAmJiBkYXRhWzJdID09PSAwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tJbnZlcnNlQWxwaGEgKClcclxue1xyXG4gICAgdmFyIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKHRoaXMsIDIsIDEpO1xyXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDEwLCAyMCwgMzAsIDAuNSknO1xyXG5cclxuICAgIC8vICBEcmF3IGEgc2luZ2xlIHBpeGVsXHJcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xyXG5cclxuICAgIC8vICBHZXQgdGhlIGNvbG9yIHZhbHVlc1xyXG4gICAgdmFyIHMxID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XHJcblxyXG4gICAgaWYgKHMxID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgUGxvdCB0aGVtIHRvIHgyXHJcbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShzMSwgMSwgMCk7XHJcblxyXG4gICAgLy8gIEdldCB0aG9zZSB2YWx1ZXNcclxuICAgIHZhciBzMiA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDEsIDAsIDEsIDEpO1xyXG5cclxuICAgIC8vICBDb21wYXJlIGFuZCByZXR1cm5cclxuICAgIHJldHVybiAoczIuZGF0YVswXSA9PT0gczEuZGF0YVswXSAmJiBzMi5kYXRhWzFdID09PSBzMS5kYXRhWzFdICYmIHMyLmRhdGFbMl0gPT09IHMxLmRhdGFbMl0gJiYgczIuZGF0YVszXSA9PT0gczEuZGF0YVszXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgaWYgKGRvY3VtZW50ICE9PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgQ2FudmFzRmVhdHVyZXMuc3VwcG9ydE5ld0JsZW5kTW9kZXMgPSBjaGVja0JsZW5kTW9kZSgpO1xyXG4gICAgICAgIENhbnZhc0ZlYXR1cmVzLnN1cHBvcnRJbnZlcnNlQWxwaGEgPSBjaGVja0ludmVyc2VBbHBoYSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBDYW52YXNGZWF0dXJlcztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9DYW52YXNGZWF0dXJlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL0NhbnZhc0ZlYXR1cmVzLmpzIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xyXG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xyXG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XHJcblxyXG52YXIgRmVhdHVyZXMgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FudmFzIC0gSXMgY2FudmFzIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjYW52YXM6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkgez9ib29sZWFufSBjYW52YXNCaXRCbHRTaGlmdCAtIFRydWUgaWYgY2FudmFzIHN1cHBvcnRzIGEgJ2NvcHknIGJpdGJsdCBvbnRvIGl0c2VsZiB3aGVuIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIHJlZ2lvbnMgb3ZlcmxhcC5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjYW52YXNCaXRCbHRTaGlmdDogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3ZWJHTCAtIElzIHdlYkdMIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJHTDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmlsZSAtIElzIGZpbGUgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGZpbGU6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZpbGVTeXN0ZW0gLSBJcyBmaWxlU3lzdGVtIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBmaWxlU3lzdGVtOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBsb2NhbFN0b3JhZ2UgLSBJcyBsb2NhbFN0b3JhZ2UgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGxvY2FsU3RvcmFnZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd29ya2VyIC0gSXMgd29ya2VyIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3b3JrZXI6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHBvaW50ZXJMb2NrIC0gSXMgUG9pbnRlciBMb2NrIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBwb2ludGVyTG9jazogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmlicmF0aW9uIC0gRG9lcyB0aGUgZGV2aWNlIHN1cHBvcnQgdGhlIFZpYnJhdGlvbiBBUEk/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdmlicmF0aW9uOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBnZXRVc2VyTWVkaWEgLSBEb2VzIHRoZSBkZXZpY2Ugc3VwcG9ydCB0aGUgZ2V0VXNlck1lZGlhIEFQST9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBnZXRVc2VyTWVkaWE6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuIC0gSXMgdGhlIGRldmljZSBiaWcgb3IgbGl0dGxlIGVuZGlhbj8gKG9ubHkgZGV0ZWN0ZWQgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWRBcnJheXMpXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbGl0dGxlRW5kaWFuOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBzdXBwb3J0MzJiaXQgLSBEb2VzIHRoZSBkZXZpY2UgY29udGV4dCBzdXBwb3J0IDMyYml0IHBpeGVsIG1hbmlwdWxhdGlvbiB1c2luZyBhcnJheSBidWZmZXIgdmlld3M/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgc3VwcG9ydDMyYml0OiBmYWxzZVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4qIENoZWNrIExpdHRsZSBvciBCaWcgRW5kaWFuIHN5c3RlbS5cclxuKlxyXG4qIEBhdXRob3IgTWF0dCBEZXNMYXVyaWVycyAoQG1hdHRkZXNsKVxyXG4qL1xyXG5mdW5jdGlvbiBjaGVja0lzTGl0dGxlRW5kaWFuICgpXHJcbntcclxuICAgIHZhciBhID0gbmV3IEFycmF5QnVmZmVyKDQpO1xyXG4gICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShhKTtcclxuICAgIHZhciBjID0gbmV3IFVpbnQzMkFycmF5KGEpO1xyXG5cclxuICAgIGJbMF0gPSAweGExO1xyXG4gICAgYlsxXSA9IDB4YjI7XHJcbiAgICBiWzJdID0gMHhjMztcclxuICAgIGJbM10gPSAweGQ0O1xyXG5cclxuICAgIGlmIChjWzBdID09PSAweGQ0YzNiMmExKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjWzBdID09PSAweGExYjJjM2Q0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgQ291bGQgbm90IGRldGVybWluZSBlbmRpYW5uZXNzXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgRmVhdHVyZXMuY2FudmFzID0gISF3aW5kb3dbJ0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCddIHx8IE9TLmNvY29vbkpTO1xyXG5cclxuICAgIHRyeVxyXG4gICAge1xyXG4gICAgICAgIEZlYXR1cmVzLmxvY2FsU3RvcmFnZSA9ICEhbG9jYWxTdG9yYWdlLmdldEl0ZW07XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpXHJcbiAgICB7XHJcbiAgICAgICAgRmVhdHVyZXMubG9jYWxTdG9yYWdlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgRmVhdHVyZXMuZmlsZSA9ICEhd2luZG93WydGaWxlJ10gJiYgISF3aW5kb3dbJ0ZpbGVSZWFkZXInXSAmJiAhIXdpbmRvd1snRmlsZUxpc3QnXSAmJiAhIXdpbmRvd1snQmxvYiddO1xyXG4gICAgRmVhdHVyZXMuZmlsZVN5c3RlbSA9ICEhd2luZG93WydyZXF1ZXN0RmlsZVN5c3RlbSddO1xyXG5cclxuICAgIHZhciBpc1VpbnQ4ID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIHRlc3RXZWJHTCA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHdpbmRvd1snV2ViR0xSZW5kZXJpbmdDb250ZXh0J10pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0cnlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlV2ViR0wodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKE9TLmNvY29vbkpTKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zY3JlZW5jYW52YXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjYW52YXMyRCA9IENhbnZhc1Bvb2wuY3JlYXRlMkQodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGN0eDJEID0gY2FudmFzMkQuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgQ2FuJ3QgYmUgZG9uZSBvbiBhIHdlYmdsIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IGN0eDJELmNyZWF0ZUltYWdlRGF0YSgxLCAxKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAqIFRlc3QgdG8gc2VlIGlmIEltYWdlRGF0YSB1c2VzIENhbnZhc1BpeGVsQXJyYXkgb3IgVWludDhDbGFtcGVkQXJyYXkuXHJcbiAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAqIEBhdXRob3IgTWF0dCBEZXNMYXVyaWVycyAoQG1hdHRkZXNsKVxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlzVWludDggPSBpbWFnZS5kYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgQ2FudmFzUG9vbC5yZW1vdmUoY2FudmFzKTtcclxuICAgICAgICAgICAgICAgIENhbnZhc1Bvb2wucmVtb3ZlKGNhbnZhczJEKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGN0eCAhPT0gbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIEZlYXR1cmVzLndlYkdMID0gdGVzdFdlYkdMKCk7XHJcblxyXG4gICAgRmVhdHVyZXMud29ya2VyID0gISF3aW5kb3dbJ1dvcmtlciddO1xyXG5cclxuICAgIEZlYXR1cmVzLnBvaW50ZXJMb2NrID0gJ3BvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQgfHwgJ21velBvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQgfHwgJ3dlYmtpdFBvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQ7XHJcblxyXG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iub0dldFVzZXJNZWRpYTtcclxuXHJcbiAgICB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xyXG5cclxuICAgIEZlYXR1cmVzLmdldFVzZXJNZWRpYSA9IEZlYXR1cmVzLmdldFVzZXJNZWRpYSAmJiAhIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgISF3aW5kb3cuVVJMO1xyXG5cclxuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIGZpcmVmb3ggKDwgMjEpIGFwcGFyZW50bHkgY2xhaW0gc3VwcG9ydCBidXQgdXNlciBtZWRpYSBkb2VzIG5vdCBhY3R1YWxseSB3b3JrXHJcbiAgICBpZiAoQnJvd3Nlci5maXJlZm94ICYmIEJyb3dzZXIuZmlyZWZveFZlcnNpb24gPCAyMSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5nZXRVc2VyTWVkaWEgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeGNsdWRlcyBpT1MgdmVyc2lvbnMgYXMgdGhleSBnZW5lcmFsbHkgd3JhcCBVSVdlYlZpZXcgKGVnLiBTYWZhcmkgV2ViS2l0KSBhbmQgaXRcclxuICAgIC8vIGlzIHNhZmVyIHRvIG5vdCB0cnkgYW5kIHVzZSB0aGUgZmFzdCBjb3B5LW92ZXIgbWV0aG9kLlxyXG4gICAgaWYgKCFPUy5pT1MgJiYgKEJyb3dzZXIuaWUgfHwgQnJvd3Nlci5maXJlZm94IHx8IEJyb3dzZXIuY2hyb21lKSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5jYW52YXNCaXRCbHRTaGlmdCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gS25vd24gbm90IHRvIHdvcmtcclxuICAgIGlmIChCcm93c2VyLnNhZmFyaSB8fCBCcm93c2VyLm1vYmlsZVNhZmFyaSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5jYW52YXNCaXRCbHRTaGlmdCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIG5hdmlnYXRvci52aWJyYXRlID0gbmF2aWdhdG9yLnZpYnJhdGUgfHwgbmF2aWdhdG9yLndlYmtpdFZpYnJhdGUgfHwgbmF2aWdhdG9yLm1velZpYnJhdGUgfHwgbmF2aWdhdG9yLm1zVmlicmF0ZTtcclxuXHJcbiAgICBpZiAobmF2aWdhdG9yLnZpYnJhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgRmVhdHVyZXMudmlicmF0aW9uID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJylcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5saXR0bGVFbmRpYW4gPSBjaGVja0lzTGl0dGxlRW5kaWFuKCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmVhdHVyZXMuc3VwcG9ydDMyYml0ID0gKFxyXG4gICAgICAgIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgdHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgRmVhdHVyZXMubGl0dGxlRW5kaWFuICE9PSBudWxsICYmXHJcbiAgICAgICAgaXNVaW50OFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gRmVhdHVyZXM7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvRmVhdHVyZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9GZWF0dXJlcy5qcyIsInZhciBFVkVOVF9DT05TVCA9IHtcclxuXHJcbiAgICBESVNQQVRDSEVSX0lETEU6IDAsXHJcbiAgICBESVNQQVRDSEVSX0RJU1BBVENISU5HOiAxLFxyXG4gICAgRElTUEFUQ0hFUl9SRU1PVklORzogMixcclxuICAgIERJU1BBVENIRVJfREVTVFJPWUVEOiAzLFxyXG5cclxuICAgIExJU1RFTkVSX1BFTkRJTkc6IDQsXHJcbiAgICBMSVNURU5FUl9BQ1RJVkU6IDUsXHJcbiAgICBMSVNURU5FUl9SRU1PVklORzogNlxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRVZFTlRfQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2V2ZW50cy9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENpcmNsZSA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMpXHJcbntcclxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cclxuICAgIGlmIChyYWRpdXMgPT09IHVuZGVmaW5lZCkgeyByYWRpdXMgPSAwOyB9XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuXHJcbiAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcclxuICAgIHRoaXMuX2RpYW1ldGVyID0gcmFkaXVzICogMjtcclxufTtcclxuXHJcbkNpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGU7XHJcblxyXG5DaXJjbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldFRvOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XHJcbiAgICAgICAgdGhpcy5fZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VG8oMCwgMCwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9yYWRpdXMgPD0gMCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2lyY2xlLnByb3RvdHlwZSwge1xyXG5cclxuICAgIHJhZGl1czoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpYW1ldGVyID0gdmFsdWUgKiAyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpYW1ldGVyOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWFtZXRlcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpYW1ldGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHZhbHVlICogMC41O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlZnQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAtIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlICsgdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZSAtIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3A6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSAtIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlICsgdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy55ID0gdmFsdWUgLSB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSAwOyB9XHJcbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMDsgfVxyXG5cclxuICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgdGhpcy55ID0geTtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbn07XHJcblxyXG5FbGxpcHNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVsbGlwc2U7XHJcblxyXG5FbGxpcHNlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEVtcHR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldFRvKDAsIDAsIDAsIDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gd2lkdGg7IH1cclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEFLQSBTZW1pIE1pbm9yIEF4aXNcclxuICAgIGdldE1pbm9yUmFkaXVzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQUtBIFNlbWkgTWFqb3IgQXhpc1xyXG4gICAgZ2V0TWFqb3JSYWRpdXM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSAvIDI7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRWxsaXBzZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBsZWZ0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5yaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByaWdodDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLngpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHZhbHVlIC0gdGhpcy54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9wOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5ib3R0b20pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAodGhpcy5ib3R0b20gLSB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b206IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMueSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB2YWx1ZSAtIHRoaXMueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRWxsaXBzZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0VsbGlwc2UuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRQb2ludCA9IHJlcXVpcmUoJy4vR2V0UG9pbnQnKTtcclxuXHJcbi8qKlxyXG4qIENhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSBhbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIGN1cnZlcyB0YW5nZW50IGJhc2VkIG9uIHRpbWUuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldEFuZ2xlXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt0PTBdIC0gVGhlIGB0YCAodGltZSkgdmFsdWUgYXQgd2hpY2ggdG8gZmluZCB0aGUgYW5nbGUuIE11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGF0IHRoZSBzcGVjaWZpZWQgYHRgIHRpbWUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlLiBUaGUgdmFsdWUgaXMgaW4gcmFkaWFucy5cclxuKi9cclxudmFyIEdldEFuZ2xlID0gZnVuY3Rpb24gKGN1cnZlLCB0KVxyXG57XHJcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7IHQgPSAwOyB9XHJcblxyXG4gICAgR2V0UG9pbnQoY3VydmUsIHQgLSAwLjAxLCBjdXJ2ZS5fdGVtcDEpO1xyXG4gICAgR2V0UG9pbnQoY3VydmUsIHQgKyAwLjAxLCBjdXJ2ZS5fdGVtcDIpO1xyXG5cclxuICAgIHJldHVybiBNYXRoLmF0YW4yKGN1cnZlLl90ZW1wMi55IC0gY3VydmUuX3RlbXAxLnksIGN1cnZlLl90ZW1wMi54IC0gY3VydmUuX3RlbXAxLngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9oZXJtaXRlL0dldEFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2hlcm1pdGUvR2V0QW5nbGUuanMiLCJ2YXIgUG9pbnRUb0xpbmUgPSBmdW5jdGlvbiAocG9pbnQsIGxpbmUpXHJcbntcclxuICAgIHJldHVybiAoKHBvaW50LnggLSBsaW5lLngxKSAqIChsaW5lLnkyIC0gbGluZS55MSkgPT09IChsaW5lLngyIC0gbGluZS54MSkgKiAocG9pbnQueSAtIGxpbmUueTEpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb0xpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZVRvUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qilcclxue1xyXG4gICAgaWYgKHJlY3RBLndpZHRoIDw9IDAgfHwgcmVjdEEuaGVpZ2h0IDw9IDAgfHwgcmVjdEIud2lkdGggPD0gMCB8fCByZWN0Qi5oZWlnaHQgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICEocmVjdEEucmlnaHQgPCByZWN0Qi54IHx8IHJlY3RBLmJvdHRvbSA8IHJlY3RCLnkgfHwgcmVjdEEueCA+IHJlY3RCLnJpZ2h0IHx8IHJlY3RBLnkgPiByZWN0Qi5ib3R0b20pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGVUb1JlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvUmVjdGFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgRGVmaW5lcyBhIExpbmUgc2VnbWVudCwgYSBwYXJ0IG9mIGEgbGluZSBiZXR3ZWVuIHR3byBlbmRwb2ludHNcclxuXHJcbnZhciBMaW5lID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG57XHJcbiAgICBpZiAoeDEgPT09IHVuZGVmaW5lZCkgeyB4MSA9IDA7IH1cclxuICAgIGlmICh5MSA9PT0gdW5kZWZpbmVkKSB7IHkxID0gMDsgfVxyXG4gICAgaWYgKHgyID09PSB1bmRlZmluZWQpIHsgeDIgPSAwOyB9XHJcbiAgICBpZiAoeTIgPT09IHVuZGVmaW5lZCkgeyB5MiA9IDA7IH1cclxuXHJcbiAgICB0aGlzLngxID0geDE7XHJcblxyXG4gICAgdGhpcy55MSA9IHkxO1xyXG5cclxuICAgIHRoaXMueDIgPSB4MjtcclxuXHJcbiAgICB0aGlzLnkyID0geTI7XHJcbn07XHJcblxyXG5MaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmU7XHJcblxyXG5MaW5lLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4MSA9PT0gdW5kZWZpbmVkKSB7IHgxID0gMDsgfVxyXG4gICAgICAgIGlmICh5MSA9PT0gdW5kZWZpbmVkKSB7IHkxID0gMDsgfVxyXG4gICAgICAgIGlmICh4MiA9PT0gdW5kZWZpbmVkKSB7IHgyID0gMDsgfVxyXG4gICAgICAgIGlmICh5MiA9PT0gdW5kZWZpbmVkKSB7IHkyID0gMDsgfVxyXG5cclxuICAgICAgICB0aGlzLngxID0geDE7XHJcbiAgICAgICAgdGhpcy55MSA9IHkxO1xyXG5cclxuICAgICAgICB0aGlzLngyID0geDI7XHJcbiAgICAgICAgdGhpcy55MiA9IHkyO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhMaW5lLnByb3RvdHlwZSwge1xyXG5cclxuICAgIGxlZnQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMueDEsIHRoaXMueDIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueDEgPD0gdGhpcy54MilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMueDEsIHRoaXMueDIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueDEgPiB0aGlzLngyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLngyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3A6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMueTEsIHRoaXMueTIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueTEgPD0gdGhpcy55MilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnkxLCB0aGlzLnkyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnkxID4gdGhpcy55MilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBXcmFwID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9XcmFwJyk7XHJcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxuXHJcbnZhciBOb3JtYWxBbmdsZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICB2YXIgYW5nbGUgPSBBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVO1xyXG5cclxuICAgIHJldHVybiBXcmFwKGFuZ2xlLCAtTWF0aC5QSSwgTWF0aC5QSSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbEFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9Ob3JtYWxBbmdsZS5qcyIsInZhciBHZXRNYWduaXR1ZGUgPSBmdW5jdGlvbiAocG9pbnQpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnNxcnQoKHBvaW50LnggKiBwb2ludC54KSArIChwb2ludC55ICogcG9pbnQueSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRNYWduaXR1ZGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TWFnbml0dWRlU3EgPSBmdW5jdGlvbiAocG9pbnQpXHJcbntcclxuICAgIHJldHVybiAocG9pbnQueCAqIHBvaW50LngpICsgKHBvaW50LnkgKiBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0TWFnbml0dWRlU3E7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlU3EuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNdWx0aXBseSA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcclxue1xyXG4gICAgcG9pbnQueCAqPSB4O1xyXG4gICAgcG9pbnQueSAqPSB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTXVsdGlwbHk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvTXVsdGlwbHkuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRNYWduaXR1ZGUgPSByZXF1aXJlKCcuL0dldE1hZ25pdHVkZScpO1xyXG5cclxudmFyIE5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgaWYgKHBvaW50LnggIT09IDAgJiYgcG9pbnQueSAhPT0gMClcclxuICAgIHtcclxuICAgICAgICB2YXIgbSA9IEdldE1hZ25pdHVkZShwb2ludCk7XHJcblxyXG4gICAgICAgIHBvaW50LnggLz0gbTtcclxuICAgICAgICBwb2ludC55IC89IG07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxpemU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvTm9ybWFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L05vcm1hbGl6ZS5qcyIsIi8qKlxyXG4qIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgcG9seWdvbi5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jY29udGFpbnNcclxuKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0byB0ZXN0LlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uLCBvdGhlcndpc2UgZmFsc2UuXHJcbiovXHJcbnZhciBDb250YWlucyA9IGZ1bmN0aW9uIChwb2x5Z29uLCB4LCB5KVxyXG57XHJcbiAgICAvLyAgQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cuZWNzZS5ycGkuZWR1L0hvbWVwYWdlcy93cmYvUmVzZWFyY2gvU2hvcnRfTm90ZXMvcG5wb2x5Lmh0bWwgYnkgSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhXHJcblxyXG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAtMSwgaiA9IHBvbHlnb24ucG9pbnRzLmxlbmd0aCAtIDE7ICsraSA8IHBvbHlnb24ucG9pbnRzLmxlbmd0aDsgaiA9IGkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGl4ID0gcG9seWdvbi5wb2ludHNbaV0ueDtcclxuICAgICAgICB2YXIgaXkgPSBwb2x5Z29uLnBvaW50c1tpXS55O1xyXG5cclxuICAgICAgICB2YXIganggPSBwb2x5Z29uLnBvaW50c1tqXS54O1xyXG4gICAgICAgIHZhciBqeSA9IHBvbHlnb24ucG9pbnRzW2pdLnk7XHJcblxyXG4gICAgICAgIGlmICgoKGl5IDw9IHkgJiYgeSA8IGp5KSB8fCAoankgPD0geSAmJiB5IDwgaXkpKSAmJiAoeCA8IChqeCAtIGl4KSAqICh5IC0gaXkpIC8gKGp5IC0gaXkpICsgaXgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluc2lkZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9seWdvbi9Db250YWlucy5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzKVxyXG57XHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFyZWEgLSBUaGUgYXJlYSBvZiB0aGlzIFBvbHlnb24uXHJcbiAgICAqL1xyXG4gICAgdGhpcy5hcmVhID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHthcnJheX0gcG9pbnRzIC0gQW4gYXJyYXkgb2YgbnVtYmVyIHBhaXIgb2JqZWN0cyB0aGF0IG1ha2UgdXAgdGhpcyBwb2x5Z29uLiBJLmUuIFsge3gseX0sIHt4LHl9LCB7eCx5fSBdXHJcbiAgICAqL1xyXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcclxuXHJcbiAgICBpZiAocG9pbnRzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0VG8ocG9pbnRzKTtcclxuICAgIH1cclxufTtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWdvbjtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGlzIFBvbHlnb24gdG8gdGhlIGdpdmVuIHBvaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcG9pbnRzIGNhbiBiZSBzZXQgZnJvbSBhIHZhcmlldHkgb2YgZm9ybWF0czpcclxuICAgICAqXHJcbiAgICAgKiAtIEFuIGFycmF5IG9mIFBvaW50IG9iamVjdHM6IGBbbmV3IFBoYXNlci5Qb2ludCh4MSwgeTEpLCAuLi5dYFxyXG4gICAgICogLSBBbiBhcnJheSBvZiBvYmplY3RzIHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzOiBgW29iajEsIG9iajIsIC4uLl1gXHJcbiAgICAgKiAtIEFuIGFycmF5IG9mIHBhaXJlZCBudW1iZXJzIHRoYXQgcmVwcmVzZW50IHBvaW50IGNvb3JkaW5hdGVzOiBgW3gxLHkxLCB4Mix5MiwgLi4uXWBcclxuICAgICAqIC0gQW4gYXJyYXkgb2YgYXJyYXlzIHdpdGggdHdvIGVsZW1lbnRzIHJlcHJlc2VudGluZyB4L3kgY29vcmRpbmF0ZXM6IGBbW3gxLCB5MV0sIFt4MiwgeTJdLCAuLi5dYFxyXG4gICAgICpcclxuICAgICAqIGBzZXRUb2AgbWF5IGFsc28gYmUgY2FsbGVkIHdpdGhvdXQgYW55IGFyZ3VtZW50cyB0byByZW1vdmUgYWxsIHBvaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIFBoYXNlci5Qb2x5Z29uI3NldFRvXHJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5Qb2ludFtdfG51bWJlcltdfC4uLlBoYXNlci5Qb2ludHwuLi5udW1iZXJ9IHBvaW50cyAtIFRoZSBwb2ludHMgdG8gc2V0LlxyXG4gICAgICogQHJldHVybiB7UGhhc2VyLlBvbHlnb259IFRoaXMgUG9seWdvbiBvYmplY3RcclxuICAgICAqL1xyXG4gICAgc2V0VG86IGZ1bmN0aW9uIChwb2ludHMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hcmVhID0gMDtcclxuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGVudHJ5O1xyXG4gICAgICAgIHZhciB5MCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdmFyIHA7XHJcblxyXG4gICAgICAgIC8vICBUaGUgcG9pbnRzIGFyZ3VtZW50IGlzIGFuIGFycmF5LCBzbyBpdGVyYXRlIHRocm91Z2ggaXRcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHAgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRzW2ldID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcC54ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIEFuIGFycmF5IG9mIGFycmF5cz9cclxuICAgICAgICAgICAgICAgIHAueCA9IHBvaW50c1tpXVswXTtcclxuICAgICAgICAgICAgICAgIHAueSA9IHBvaW50c1tpXVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHAueCA9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2ldLnk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2gocCk7XHJcblxyXG4gICAgICAgICAgICAvLyAgTG93ZXN0IGJvdW5kYXJ5XHJcbiAgICAgICAgICAgIGlmIChwLnkgPCB5MClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgeTAgPSBwLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQXJlYSh5MCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFyZWEgb2YgdGhlIFBvbHlnb24uIFRoaXMgaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9wZXJ0eSBQb2x5Z29uLmFyZWFcclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIFBoYXNlci5Qb2x5Z29uI2NhbGN1bGF0ZUFyZWFcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTAgLSBUaGUgbG93ZXN0IGJvdW5kYXJ5XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhcmVhIG9mIHRoZSBQb2x5Z29uLlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVBcmVhOiBmdW5jdGlvbiAoeTApXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA8IDMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFyZWEgPSAwO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJlYTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgIHZhciBwMTtcclxuICAgICAgICB2YXIgcDI7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoIC0gMTsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcDEgPSB0aGlzLnBvaW50c1tpXTtcclxuICAgICAgICAgICAgcDIgPSB0aGlzLnBvaW50c1tpICsgMV07XHJcblxyXG4gICAgICAgICAgICBzdW0gKz0gKHAyLnggLSBwMS54KSAqIChwMS55ICsgcDIueSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwMSA9IHRoaXMucG9pbnRzWzBdO1xyXG4gICAgICAgIHAyID0gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAgIHN1bSArPSAocDEueCAtIHAyLngpICogKHAyLnkgKyBwMS55KTtcclxuXHJcbiAgICAgICAgdGhpcy5hcmVhID0gLXN1bSAqIDAuNTtcclxuXHJcbiAgICAgICAgLy8gdmFyIHAxO1xyXG4gICAgICAgIC8vIHZhciBwMjtcclxuICAgICAgICAvLyB2YXIgYXZnSGVpZ2h0O1xyXG4gICAgICAgIC8vIHZhciB3aWR0aDtcclxuXHJcbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgcDEgPSB0aGlzLnBvaW50c1tpXTtcclxuXHJcbiAgICAgICAgLy8gICAgIGlmIChpID09PSBsZW4gLSAxKVxyXG4gICAgICAgIC8vICAgICB7XHJcbiAgICAgICAgLy8gICAgICAgICBwMiA9IHRoaXMucG9pbnRzWzBdO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gICAgIGVsc2VcclxuICAgICAgICAvLyAgICAge1xyXG4gICAgICAgIC8vICAgICAgICAgcDIgPSB0aGlzLnBvaW50c1tpICsgMV07XHJcbiAgICAgICAgLy8gICAgIH1cclxuXHJcbiAgICAgICAgLy8gICAgIGF2Z0hlaWdodCA9ICgocDEueSAtIHkwKSArIChwMi55IC0geTApKSAvIDI7XHJcbiAgICAgICAgLy8gICAgIHdpZHRoID0gcDEueCAtIHAyLng7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuYXJlYSArPSBhdmdIZWlnaHQgKiB3aWR0aDtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvbHlnb24vUG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIGlmIChyZWN0LndpZHRoIDw9IDAgfHwgcmVjdC5oZWlnaHQgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChyZWN0LnggPD0geCAmJiByZWN0LnggKyByZWN0LndpZHRoID49IHggJiYgcmVjdC55IDw9IHkgJiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPj0geSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9Db250YWlucy5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFhIUlNldHRpbmdzID0gcmVxdWlyZSgnLi9YSFJTZXR0aW5ncycpO1xyXG5cclxuLy8gIFRha2VzIHR3byBYSFIgT2JqZWN0cyBhbmQgY3JlYXRlcyBhIG5ldyBvYmplY3RcclxuXHJcbi8vICBUaGUgbmV3IG9iamVjdCBpcyBiYXNlZCBvbiBnbG9iYWwgaW5pdGlhbGx5LCBidXQgYW55IHNldHRpbmcgaW5cclxuLy8gIGxvY2FsIG92ZXJyaWRlcyB0aGUgZ2xvYmFsIHZhbHVlLlxyXG5cclxudmFyIE1lcmdlWEhSU2V0dGluZ3MgPSBmdW5jdGlvbiAoZ2xvYmFsLCBsb2NhbClcclxue1xyXG4gICAgdmFyIG91dHB1dCA9IChnbG9iYWwgPT09IHVuZGVmaW5lZCkgPyBYSFJTZXR0aW5ncygpIDogT2JqZWN0LmFzc2lnbihnbG9iYWwpO1xyXG5cclxuICAgIGlmIChsb2NhbClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBzZXR0aW5nIGluIGxvY2FsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGxvY2FsW3NldHRpbmddICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dFtzZXR0aW5nXSA9IGxvY2FsW3NldHRpbmddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVhIUlNldHRpbmdzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL01lcmdlWEhSU2V0dGluZ3MuanMiLCJcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcblxyXG52YXIgSlNPTkZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxyXG5cclxuICAgIGlmICgha2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIuanNvblxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5qc29uJztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIEZpbGUuY2FsbCh0aGlzLCAnanNvbicsIGtleSwgdXJsLCAndGV4dCcsIHhoclNldHRpbmdzKTtcclxufTtcclxuXHJcbkpTT05GaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5KU09ORmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKU09ORmlsZTtcclxuXHJcbkpTT05GaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gSlNPTi5wYXJzZSh0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQpO1xyXG5cclxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgIGNhbGxiYWNrKHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKU09ORmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qcyIsInZhciBGYWN0b3JpYWwgPSByZXF1aXJlKCcuL0ZhY3RvcmlhbCcpO1xyXG5cclxudmFyIEJlcm5zdGVpbiA9IGZ1bmN0aW9uIChuLCBpKVxyXG57XHJcbiAgICByZXR1cm4gRmFjdG9yaWFsKG4pIC8gRmFjdG9yaWFsKGkpIC8gRmFjdG9yaWFsKG4gLSBpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmVybnN0ZWluO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0Jlcm5zdGVpbi5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9CZXJuc3RlaW4uanMiLCJ2YXIgQmV0d2VlbiA9IGZ1bmN0aW9uIChtaW4sIG1heClcclxue1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhdG11bGxSb20gPSBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHQpXHJcbntcclxuICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNSwgdjEgPSAocDMgLSBwMSkgKiAwLjUsIHQyID0gdCAqIHQsIHQzID0gdCAqIHQyO1xyXG5cclxuICAgIHJldHVybiAoMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2F0bXVsbFJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9DYXRtdWxsUm9tLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmFjdG9yaWFsID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlcyA9IHZhbHVlO1xyXG5cclxuICAgIHdoaWxlICgtLXZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJlcyAqPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3JpYWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRmFjdG9yaWFsLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGluZWFyID0gZnVuY3Rpb24gKHAwLCBwMSwgdClcclxue1xyXG4gICAgcmV0dXJuIChwMSAtIHAwKSAqIHQgKyBwMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZWFyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0xpbmVhci5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJvdW5kQXdheUZyb21aZXJvID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICAvLyBcIk9wcG9zaXRlXCIgb2YgdHJ1bmNhdGUuXHJcbiAgICByZXR1cm4gKHZhbHVlID4gMCkgPyBNYXRoLmNlaWwodmFsdWUpIDogTWF0aC5mbG9vcih2YWx1ZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kQXdheUZyb21aZXJvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdW5kQXdheUZyb21aZXJvLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTm9ybWFsaXplID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICBhbmdsZSA9IGFuZ2xlICUgKDIgKiBNYXRoLlBJKTtcclxuXHJcbiAgICBpZiAoYW5nbGUgPj0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlICsgMiAqIE1hdGguUEk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbGl6ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9Ob3JtYWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXN0YW5jZUJldHdlZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbntcclxuICAgIHZhciBkeCA9IHgxIC0geDI7XHJcbiAgICB2YXIgZHkgPSB5MSAtIHkyO1xyXG5cclxuICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZUJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDaGVja3MgaWYgdGhlIGdpdmVuIGRpbWVuc2lvbnMgbWFrZSBhIHBvd2VyIG9mIHR3byB0ZXh0dXJlLlxyXG4qIFxyXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjaXNQb3dlck9mVHdvXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHRvIGNoZWNrLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IHRvIGNoZWNrLlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGEgcG93ZXIgb2YgdHdvLlxyXG4qL1xyXG52YXIgSXNTaXplUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICByZXR1cm4gKHdpZHRoID4gMCAmJiAod2lkdGggJiAod2lkdGggLSAxKSkgPT09IDAgJiYgaGVpZ2h0ID4gMCAmJiAoaGVpZ2h0ICYgKGhlaWdodCAtIDEpKSA9PT0gMCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElzU2l6ZVBvd2VyT2ZUd287XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBOT1JNQUw6IDAsXHJcbiAgICBBREQ6IDEsXHJcbiAgICBNVUxUSVBMWTogMixcclxuICAgIFNDUkVFTjogMyxcclxuICAgIE9WRVJMQVk6IDQsXHJcbiAgICBEQVJLRU46IDUsXHJcbiAgICBMSUdIVEVOOiA2LFxyXG4gICAgQ09MT1JfRE9ER0U6IDcsXHJcbiAgICBDT0xPUl9CVVJOOiA4LFxyXG4gICAgSEFSRF9MSUdIVDogOSxcclxuICAgIFNPRlRfTElHSFQ6IDEwLFxyXG4gICAgRElGRkVSRU5DRTogMTEsXHJcbiAgICBFWENMVVNJT046IDEyLFxyXG4gICAgSFVFOiAxMyxcclxuICAgIFNBVFVSQVRJT046IDE0LFxyXG4gICAgQ09MT1I6IDE1LFxyXG4gICAgTFVNSU5PU0lUWTogMTZcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL0JsZW5kTW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGcmFnbWVudFNoYWRlciA9IHJlcXVpcmUoJy4vRnJhZ21lbnRTaGFkZXInKTtcclxudmFyIFZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4vVmVydGV4U2hhZGVyJyk7XHJcblxyXG52YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgLy8gVkVSVEVYX1NJWkUgPSAoc2l6ZW9mKHZlYzIpICogNCkgKyAoc2l6ZW9mKGZsb2F0KSArIHNpemVvZih1aW50MzIpKVxyXG4gICAgVkVSVEVYX1NJWkU6IDQwLFxyXG4gICAgSU5ERVhfU0laRTogMixcclxuICAgIFNQUklURV9WRVJURVhfQ09VTlQ6IDQsXHJcbiAgICBTUFJJVEVfSU5ERVhfQ09VTlQ6IDYsXHJcblxyXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXHJcbiAgICBTUFJJVEVfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVDogMTAsXHJcblxyXG4gICAgLy8gQ2FuJ3QgYmUgYmlnZ2VyIHNpbmNlIGluZGV4IGFyZSAxNi1iaXRcclxuICAgIE1BWF9TUFJJVEVTOiAxMDAwMCxcclxuXHJcbiAgICBWRVJURVhfU0hBREVSX1NPVVJDRTogVmVydGV4U2hhZGVyLFxyXG4gICAgRlJBR01FTlRfU0hBREVSX1NPVVJDRTogRnJhZ21lbnRTaGFkZXJcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvY29uc3QuanMiLCJ2YXIgQ3JlYXRlVGV4dHVyZTJESW1hZ2UgPSBmdW5jdGlvbiAoZ2wsIHBpeGVscywgZmlsdGVyLCBtaXBMZXZlbHMpXHJcbntcclxuICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgbWlwTGV2ZWxzID0gbWlwTGV2ZWxzIHx8IDA7XHJcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXIpO1xyXG4gICAgZ2wudGV4SW1hZ2UyRChcclxuICAgICAgICBnbC5URVhUVVJFXzJELFxyXG4gICAgICAgIG1pcExldmVscyxcclxuICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgIGdsLlJHQkEsXHJcbiAgICAgICAgZ2wuVU5TSUdORURfQllURSxcclxuICAgICAgICBwaXhlbHNcclxuICAgICk7XHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlVGV4dHVyZTJESW1hZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJESW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIFNjYWxlTW9kZXMgPSByZXF1aXJlKCcuLi9yZW5kZXJlci9TY2FsZU1vZGVzJyk7XHJcbnZhciBHZXRPYmplY3RWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL0dldE9iamVjdFZhbHVlJyk7XHJcblxyXG52YXIgU2V0dGluZ3MgPSBmdW5jdGlvbiAoc3RhdGUsIGNvbmZpZylcclxue1xyXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKVxyXG4gICAge1xyXG4gICAgICAgIGNvbmZpZyA9IHsga2V5OiBjb25maWcgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBQYXNzIHRoZSAnaGFzT3duUHJvcGVydHknIGNoZWNrc1xyXG4gICAgICAgIGNvbmZpZyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTsgLy8gIERvIHdlIGFjdHVhbGx5IG5lZWQgdGhpcyByZWZlcmVuY2U/IFRoaXMgY291bGQganVzdCBiZSBhIHByb3BlcnR5IGJ1Y2tldFxyXG5cclxuICAgIHRoaXMuc3RhdHVzID0gQ09OU1QuUEVORElORztcclxuXHJcbiAgICAvLyAgV2hpY2ggcGFydCBvZiB0aGlzIFN0YXRlIGlzIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQ/XHJcbiAgICAvLyAgcHJlbG9hZCwgY3JlYXRlLCB1cGRhdGUsIHNodXRkb3duLCBldGNcclxuICAgIHRoaXMub3AgPSBDT05TVC5CT09UO1xyXG5cclxuICAgIHRoaXMua2V5ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAna2V5JywgJycpO1xyXG4gICAgdGhpcy5hY3RpdmUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdhY3RpdmUnLCBmYWxzZSk7XHJcbiAgICB0aGlzLnZpc2libGUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd2aXNpYmxlJywgdHJ1ZSk7XHJcbiAgICB0aGlzLnNjYWxlTW9kZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3NjYWxlTW9kZScsIFNjYWxlTW9kZXMuREVGQVVMVCk7XHJcbiAgICB0aGlzLmZwcyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2ZwcycsIDYwKTtcclxuICAgIHRoaXMueCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3gnLCAwKTtcclxuICAgIHRoaXMueSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3knLCAwKTtcclxuXHJcbiAgICAvLyAgLTEgbWVhbnMgdGhlIFN0YXRlIE1hbmFnZXIgd2lsbCBzZXQgaXQgdG8gYmUgdGhlIEdhbWUgZGltZW5zaW9uc1xyXG4gICAgdGhpcy53aWR0aCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3dpZHRoJywgLTEpO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdoZWlnaHQnLCAtMSk7XHJcblxyXG4gICAgLy8gIFJlbmRlcmVyIFNldHRpbmdzXHJcblxyXG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2NsZWFyQmVmb3JlUmVuZGVyJywgdHJ1ZSk7XHJcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndHJhbnNwYXJlbnQnLCBmYWxzZSk7XHJcbiAgICB0aGlzLmF1dG9SZXNpemUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdhdXRvUmVzaXplJywgZmFsc2UpO1xyXG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JvdW5kUGl4ZWxzJywgZmFsc2UpO1xyXG4gICAgdGhpcy5kcmF3VG9QcmltYXJ5Q2FudmFzID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZHJhd1RvUHJpbWFyeUNhbnZhcycsIGZhbHNlKTtcclxuXHJcbn07XHJcblxyXG4vLyAgVW5sZXNzIHdlIGFkZCBzb21lIGFjdHVhbCBmdW5jdGlvbnMgaW4gaGVyZSwgd2UnbGwgbWFrZSB0aGlzIGp1c3QgcmV0dXJuIGFuIE9iamVjdCBpbnN0ZWFkIG9mIGFuIGluc3RhbmNlXHJcblNldHRpbmdzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldHRpbmdzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5ncztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvU2V0dGluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL1NldHRpbmdzLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxudmFyIEdhbWVPYmplY3RGYWN0b3J5ID0gcmVxdWlyZSgnLi9zeXN0ZW1zL0dhbWVPYmplY3RGYWN0b3J5Jyk7XHJcbi8vIHZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xyXG52YXIgTG9hZGVyID0gcmVxdWlyZSgnLi9zeXN0ZW1zL0xvYWRlcicpO1xyXG52YXIgTWFpbkxvb3AgPSByZXF1aXJlKCcuL3N5c3RlbXMvTWFpbkxvb3AnKTtcclxudmFyIFVwZGF0ZU1hbmFnZXIgPSByZXF1aXJlKCcuL3N5c3RlbXMvVXBkYXRlTWFuYWdlcicpO1xyXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cycpO1xyXG52YXIgQ2FtZXJhID0gcmVxdWlyZSgnLi4vY2FtZXJhL0NhbWVyYScpO1xyXG5cclxudmFyIFN5c3RlbXMgPSBmdW5jdGlvbiAoc3RhdGUsIGNvbmZpZylcclxue1xyXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG5cclxuICAgIHRoaXMuZXZlbnRzO1xyXG5cclxuICAgIC8vICBSZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBHYW1lIGxldmVsIFRleHR1cmVNYW5hZ2VyLlxyXG4gICAgdGhpcy50ZXh0dXJlcztcclxuXHJcbiAgICAvLyAgU3RhdGUgc3BlY2lmaWMgbWFuYWdlcnMgKEZhY3RvcnksIFR3ZWVucywgTG9hZGVyLCBQaHlzaWNzLCBldGMpXHJcbiAgICB0aGlzLmFkZDtcclxuICAgIHRoaXMubWFrZTtcclxuICAgIHRoaXMuaW5wdXQ7XHJcbiAgICB0aGlzLmxvYWQ7XHJcbiAgICB0aGlzLnR3ZWVucztcclxuICAgIHRoaXMubWFpbmxvb3A7XHJcbiAgICB0aGlzLnVwZGF0ZXM7XHJcblxyXG4gICAgLy8gIFN0YXRlIHNwZWNpZmljIHByb3BlcnRpZXMgKHRyYW5zZm9ybSwgZGF0YSwgY2hpbGRyZW4sIGV0YylcclxuICAgIHRoaXMuY2FtZXJhO1xyXG4gICAgdGhpcy5jaGlsZHJlbjtcclxuICAgIHRoaXMuY29sb3I7XHJcbiAgICB0aGlzLmRhdGE7XHJcbiAgICB0aGlzLmZibztcclxuICAgIHRoaXMudGltZTtcclxuICAgIHRoaXMudHJhbnNmb3JtO1xyXG59O1xyXG5cclxuU3lzdGVtcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeXN0ZW1zO1xyXG5cclxuU3lzdGVtcy5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnU3RhdGUuU3lzdGVtcy5pbml0Jyk7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB0aGlzLnN0YXRlLmdhbWUudGV4dHVyZXM7XHJcblxyXG4gICAgICAgIC8vICBBbGwgb2YgdGhlIHN5c3RlbXMgY2FuIHVzZSB0aGUgU3RhdGUgbGV2ZWwgRXZlbnREaXNwYXRjaGVyLCBvciB0aGVpciBvd25cclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICAgICAgLy8gIFN0YXRlIHNwZWNpZmljIG1hbmFnZXJzIChGYWN0b3J5LCBUd2VlbnMsIExvYWRlciwgUGh5c2ljcywgZXRjKVxyXG4gICAgICAgIC8vICBBbGwgdGhlc2UgdG8gYmUgc2V0IGJ5IGEgU3RhdGUgQ29uZmlnIHBhY2thZ2VcclxuXHJcbiAgICAgICAgdGhpcy5hZGQgPSBuZXcgR2FtZU9iamVjdEZhY3RvcnkodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgLy8gdGhpcy5tYWtlID0gR2FtZU9iamVjdENyZWF0b3IodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5tYWlubG9vcCA9IG5ldyBNYWluTG9vcCh0aGlzLnN0YXRlLCB0aGlzLnN0YXRlLnNldHRpbmdzLmZwcyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVzID0gbmV3IFVwZGF0ZU1hbmFnZXIodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5sb2FkID0gbmV3IExvYWRlcih0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy50d2VlbnMgPSBuZXcgUGhhc2VyLlR3ZWVuTWFuYWdlcih0aGlzLnN0YXRlKTtcclxuICAgICAgICAvLyB0aGlzLmlucHV0ID0gbmV3IFBoYXNlci5TdGF0ZS5JbnB1dCh0aGlzLnN0YXRlKTtcclxuICAgICAgICAvLyB0aGlzLnBoeXNpY3MgPSBuZXcgUGhhc2VyLlBoeXNpY3MuQXJjYWRlKHRoaXMuc3RhdGUsIDgwMCwgNjAwKTtcclxuXHJcbiAgICAgICAgLy8gIFN0YXRlIHNwZWNpZmljIHByb3BlcnRpZXMgKHRyYW5zZm9ybSwgZGF0YSwgY2hpbGRyZW4sIGV0YylcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmEodGhpcy5zdGF0ZSwgMCwgMCwgODAwLCA2MDApO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgQ29tcG9uZW50LkNoaWxkcmVuKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgQ29tcG9uZW50LkNvbG9yKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBDb21wb25lbnQuRGF0YSh0aGlzLnN0YXRlKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMuY2FtZXJhLnRyYW5zZm9ybTtcclxuXHJcbiAgICAgICAgLy8gIEJvb3RcclxuXHJcbiAgICAgICAgLy8gdGhpcy5pbnB1dC5pbml0KCk7XHJcblxyXG4gICAgICAgIC8vICBEZWZhdWx0c1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLmV2ZW50cyA9IHRoaXMuZXZlbnRzO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuYWRkID0gdGhpcy5hZGQ7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5sb2FkID0gdGhpcy5sb2FkO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuY29sb3IgPSB0aGlzLmNvbG9yO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgICAgICB0aGlzLnN0YXRlLmNhbWVyYSA9IHRoaXMuY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuc3RhdGUudHJhbnNmb3JtID0gdGhpcy5jYW1lcmEudHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMuc3RhdGUudGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIHRoaXMuc3RhdGUuaW5wdXQgPSB0aGlzLmlucHV0O1xyXG4gICAgICAgIC8vIHRoaXMuc3RhdGUuc3RhdGUgPSB0aGlzLnN0YXRlLmdhbWUuc3RhdGU7XHJcblxyXG4gICAgICAgIC8vICBIZXJlIHdlIGNhbiBjaGVjayB3aGljaCBTeXN0ZW1zIHRvIGluc3RhbGwgYXMgcHJvcGVydGllcyBpbnRvIHRoZSBTdGF0ZSBvYmplY3RcclxuICAgICAgICAvLyAgKGRlZmF1bHQgc3lzdGVtcyBhbHdheXMgZXhpc3QgaW4gaGVyZSwgcmVnYXJkbGVzcylcclxuICAgIH0sXHJcblxyXG4gICAgYmVnaW46IGZ1bmN0aW9uICh0aW1lc3RhbXAsIGZyYW1lRGVsdGEpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGVwLCBwaHlzaWNzU3RlcClcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgcHJlUmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfSxcclxuXHJcbiAgICBlbmQ6IGZ1bmN0aW9uIChmcHMsIHBhbmljKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChwYW5pYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgcGF0dGVybiBpbnRyb2R1Y2VzIG5vbi1kZXRlcm1pbmlzdGljIGJlaGF2aW9yLCBidXQgaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgICAgIC8vIGl0J3MgYmV0dGVyIHRoYW4gdGhlIGFsdGVybmF0aXZlICh0aGUgYXBwbGljYXRpb24gd291bGQgbG9vayBsaWtlIGl0XHJcbiAgICAgICAgICAgIC8vIHdhcyBydW5uaW5nIHZlcnkgcXVpY2tseSB1bnRpbCB0aGUgc2ltdWxhdGlvbiBjYXVnaHQgdXAgdG8gcmVhbFxyXG4gICAgICAgICAgICAvLyB0aW1lKS5cclxuICAgICAgICAgICAgdmFyIGRpc2NhcmRlZFRpbWUgPSBNYXRoLnJvdW5kKHRoaXMubWFpbmxvb3AucmVzZXRGcmFtZURlbHRhKCkpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNYWluIGxvb3AgcGFuaWNrZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIGJyb3dzZXIgdGFiIHdhcyBwdXQgaW4gdGhlIGJhY2tncm91bmQuIERpc2NhcmRpbmcgJyArIGRpc2NhcmRlZFRpbWUgKyAnbXMnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5c3RlbXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1N5c3RlbXMuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL1N5c3RlbXMuanMiLCJcclxudmFyIE5PT1AgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvLyAgTk9PUCAoTm8gT3BlcmF0aW9uKSBDYWxsYmFja1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOT09QO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9OT09QLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDcmVhdGUgYW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSByYW5nZSBvZiBudW1iZXJzICh1c3VhbGx5IGludGVnZXJzKSwgYmV0d2VlbiwgYW5kIGluY2x1c2l2ZSBvZixcclxuKiB0aGUgZ2l2ZW4gYHN0YXJ0YCBhbmQgYGVuZGAgYXJndW1lbnRzLiBGb3IgZXhhbXBsZTpcclxuKlxyXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgyLCA0KTsgLy8gYXJyYXkgPSBbMiwgMywgNF1gXHJcbiogYHZhciBhcnJheSA9IG51bWJlckFycmF5KDAsIDkpOyAvLyBhcnJheSA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XWBcclxuKiBcclxuKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYG51bWJlckFycmF5U3RlcChzdGFydCwgZW5kLCAxKWAuXHJcbiogXHJcbiogWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYSBwcmVmaXggYW5kIC8gb3Igc3VmZml4IHN0cmluZy4gSWYgZ2l2ZW4gdGhlIGFycmF5IHdpbGwgY29udGFpblxyXG4qIHN0cmluZ3MsIG5vdCBpbnRlZ2Vycy4gRm9yIGV4YW1wbGU6XHJcbiogXHJcbiogYHZhciBhcnJheSA9IG51bWJlckFycmF5KDEsIDQsICdMZXZlbCAnKTsgLy8gYXJyYXkgPSBbXCJMZXZlbCAxXCIsIFwiTGV2ZWwgMlwiLCBcIkxldmVsIDNcIiwgXCJMZXZlbCA0XCJdYFxyXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSg1LCA3LCAnSEQtJywgJy5wbmcnKTsgLy8gYXJyYXkgPSBbXCJIRC01LnBuZ1wiLCBcIkhELTYucG5nXCIsIFwiSEQtNy5wbmdcIl1gXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5BcnJheVV0aWxzI251bWJlckFycmF5XHJcbiogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gVGhlIG1pbmltdW0gdmFsdWUgdGhlIGFycmF5IHN0YXJ0cyB3aXRoLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBUaGUgbWF4aW11bSB2YWx1ZSB0aGUgYXJyYXkgY29udGFpbnMuXHJcbiogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdIC0gT3B0aW9uYWwgcHJlZml4IHRvIHBsYWNlIGJlZm9yZSB0aGUgbnVtYmVyLiBJZiBwcm92aWRlZCB0aGUgYXJyYXkgd2lsbCBjb250YWluIHN0cmluZ3MsIG5vdCBpbnRlZ2Vycy5cclxuKiBAcGFyYW0ge3N0cmluZ30gW3N1ZmZpeF0gLSBPcHRpb25hbCBzdWZmaXggdG8gcGxhY2UgYWZ0ZXIgdGhlIG51bWJlci4gSWYgcHJvdmlkZWQgdGhlIGFycmF5IHdpbGwgY29udGFpbiBzdHJpbmdzLCBub3QgaW50ZWdlcnMuXHJcbiogQHJldHVybiB7bnVtYmVyW118c3RyaW5nW119IFRoZSBhcnJheSBvZiBudW1iZXIgdmFsdWVzLCBvciBzdHJpbmdzIGlmIGEgcHJlZml4IG9yIHN1ZmZpeCB3YXMgcHJvdmlkZWQuXHJcbiovXHJcbnZhciBOdW1iZXJBcnJheSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwcmVmaXgsIHN1ZmZpeClcclxue1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpZiAocHJlZml4IHx8IHN1ZmZpeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSAocHJlZml4KSA/IHByZWZpeCArIGkudG9TdHJpbmcoKSA6IGkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdWZmaXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IGtleS5jb25jYXQoc3VmZml4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlckFycmF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9OdW1iZXJBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFJlbW92ZXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIGFycmF5IGFuZCByZXR1cm5zIGl0XHJcbi8vICB3aXRob3V0IGNyZWF0aW5nIGdjIChsaWtlIHRoZSBuYXRpdmUgc3BsaWNlIGRvZXMpXHJcbi8vICBCYXNlZCBvbiBjb2RlIGJ5IE1pa2UgUmVpbnN0ZWluXHJcblxyXG52YXIgU3BsaWNlT25lID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleClcclxue1xyXG4gICAgaWYgKGluZGV4ID49IGFycmF5Lmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aCAtIDE7XHJcblxyXG4gICAgdmFyIGl0ZW0gPSBhcnJheVtpbmRleF07XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgbGVuOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XHJcbiAgICB9XHJcblxyXG4gICAgYXJyYXkubGVuZ3RoID0gbGVuO1xyXG5cclxuICAgIHJldHVybiBpdGVtO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcGxpY2VPbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L1NwbGljZU9uZS5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhpcyBpcyBhIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgalF1ZXJ5LmlzUGxhaW5PYmplY3QuXHJcbiogQSBwbGFpbiBvYmplY3QgaXMgYW4gb2JqZWN0IHdob3NlIGludGVybmFsIGNsYXNzIHByb3BlcnR5IGlzIFtvYmplY3QgT2JqZWN0XS5cclxuKiBAbWV0aG9kIFBoYXNlci5VdGlscy5pc1BsYWluT2JqZWN0XHJcbiogQHBhcmFtIHtvYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cclxuKiBAcmV0dXJuIHtib29sZWFufSAtIHRydWUgaWYgdGhlIG9iamVjdCBpcyBwbGFpbiwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4qL1xyXG52YXIgSXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIChvYmopXHJcbntcclxuICAgIC8vIE5vdCBwbGFpbiBvYmplY3RzOlxyXG4gICAgLy8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxyXG4gICAgLy8gLSBET00gbm9kZXNcclxuICAgIC8vIC0gd2luZG93XHJcbiAgICBpZiAodHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IG9iaiA9PT0gb2JqLndpbmRvdylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3VwcG9ydDogRmlyZWZveCA8MjBcclxuICAgIC8vIFRoZSB0cnkvY2F0Y2ggc3VwcHJlc3NlcyBleGNlcHRpb25zIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYWNjZXNzXHJcbiAgICAvLyB0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IG9mIGNlcnRhaW4gaG9zdCBvYmplY3RzLCBpZS4gfHdpbmRvdy5sb2NhdGlvbnxcclxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTgxNDYyMlxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmICEoe30pLmhhc093blByb3BlcnR5LmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIGZ1bmN0aW9uIGhhc24ndCByZXR1cm5lZCBhbHJlYWR5LCB3ZSdyZSBjb25maWRlbnQgdGhhdFxyXG4gICAgLy8gfG9ianwgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZWQgYnkge30gb3IgY29uc3RydWN0ZWQgd2l0aCBuZXcgT2JqZWN0XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXNQbGFpbk9iamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvb2JqZWN0L0lzUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDb25maWcgPSByZXF1aXJlKCcuL0NvbmZpZycpO1xyXG52YXIgRGVidWdIZWFkZXIgPSByZXF1aXJlKCcuL0RlYnVnSGVhZGVyJyk7XHJcbnZhciBEZXZpY2UgPSByZXF1aXJlKCcuLi9kZXZpY2UnKTtcclxuXHJcbnZhciBBZGRUb0RPTSA9IHJlcXVpcmUoJy4uL2RvbS9BZGRUb0RPTScpO1xyXG52YXIgUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi4vZG9tL1JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xyXG52YXIgRE9NQ29udGVudExvYWRlZCA9IHJlcXVpcmUoJy4uL2RvbS9ET01Db250ZW50TG9hZGVkJyk7XHJcblxyXG52YXIgQ3JlYXRlUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NyZWF0ZVJlbmRlcmVyJyk7XHJcbnZhciBSYW5kb21EYXRhR2VuZXJhdG9yID0gcmVxdWlyZSgnLi4vbWF0aC9yYW5kb20tZGF0YS1nZW5lcmF0b3IvUmFuZG9tRGF0YUdlbmVyYXRvcicpO1xyXG52YXIgU3RhdGVNYW5hZ2VyID0gcmVxdWlyZSgnLi4vc3RhdGUvU3RhdGVNYW5hZ2VyJyk7XHJcbnZhciBUZXh0dXJlTWFuYWdlciA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1RleHR1cmVNYW5hZ2VyJyk7XHJcblxyXG52YXIgR2FtZSA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyhjb25maWcpO1xyXG5cclxuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xyXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmlzQm9vdGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5SZXF1ZXN0QW5pbWF0aW9uRnJhbWV9IHJhZiAtIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyB0aGUgY29yZSBnYW1lIGxvb3AgdmlhIHJlcXVlc3RBbmltYXRpb25GcmFtZSBvciBzZXRUaW1lb3V0XHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICovXHJcbiAgICB0aGlzLnJhZiA9IG5ldyBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlRleHR1cmVNYW5hZ2VyfSB0ZXh0dXJlcyAtIFJlZmVyZW5jZSB0byB0aGUgUGhhc2VyIFRleHR1cmUgTWFuYWdlci5cclxuICAgICovXHJcbiAgICB0aGlzLnRleHR1cmVzID0gbmV3IFRleHR1cmVNYW5hZ2VyKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5DYWNoZX0gY2FjaGUgLSBSZWZlcmVuY2UgdG8gdGhlIGFzc2V0cyBjYWNoZS5cclxuICAgICovXHJcbiAgICAvLyB0aGlzLmNhY2hlID0gbmV3IENhY2hlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLklucHV0fSBpbnB1dCAtIFJlZmVyZW5jZSB0byB0aGUgaW5wdXQgbWFuYWdlclxyXG4gICAgKi9cclxuICAgIHRoaXMuaW5wdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5TdGF0ZU1hbmFnZXJ9IHN0YXRlIC0gVGhlIFN0YXRlTWFuYWdlci4gUGhhc2VyIGluc3RhbmNlIHNwZWNpZmljLlxyXG4gICAgKi9cclxuICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGVNYW5hZ2VyKHRoaXMsIHRoaXMuY29uZmlnLnN0YXRlQ29uZmlnKTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuRGV2aWNlfSBkZXZpY2UgLSBDb250YWlucyBkZXZpY2UgaW5mb3JtYXRpb24gYW5kIGNhcGFiaWxpdGllcyAoc2luZ2xldG9uKVxyXG4gICAgKi9cclxuICAgIHRoaXMuZGV2aWNlID0gRGV2aWNlO1xyXG5cclxuICAgIC8vICBNb3ZlIHRoaXMgc29tZXdoZXJlIGVsc2U/IE1hdGggcGVyaGFwcz8gRG9lc24ndCBuZWVkIHRvIGJlIGEgR2FtZSBsZXZlbCBzeXN0ZW0uXHJcbiAgICB0aGlzLnJuZDtcclxuXHJcbiAgICAvLyAgV2FpdCBmb3IgdGhlIERPTSBSZWFkeSBldmVudCwgdGhlbiBjYWxsIGJvb3QuXHJcbiAgICBET01Db250ZW50TG9hZGVkKHRoaXMuYm9vdC5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAvLyAgRm9yIGRlYnVnZ2luZyBvbmx5XHJcbiAgICB3aW5kb3cuZ2FtZSA9IHRoaXM7XHJcbn07XHJcblxyXG5HYW1lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdhbWU7XHJcblxyXG5HYW1lLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBib290OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaXNCb290ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZy5wcmVCb290KCk7XHJcblxyXG4gICAgICAgIC8vICBQcm9iYWJseSBtb3ZlIHdpdGhpbiBNYXRoXHJcbiAgICAgICAgdGhpcy5ybmQgPSBuZXcgUmFuZG9tRGF0YUdlbmVyYXRvcih0aGlzLmNvbmZpZy5zZWVkKTtcclxuXHJcbiAgICAgICAgRGVidWdIZWFkZXIodGhpcyk7XHJcblxyXG4gICAgICAgIENyZWF0ZVJlbmRlcmVyKHRoaXMpO1xyXG5cclxuICAgICAgICBBZGRUb0RPTSh0aGlzLmNhbnZhcywgdGhpcy5jb25maWcucGFyZW50KTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5ib290KCk7XHJcblxyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcucG9zdEJvb3QoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yYWYuc3RhcnQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIHRpbWVzdGFtcCA9IERPTUhpZ2hSZXNUaW1lU3RhbXBcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGFtcClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXRlLnN0ZXAodGltZXN0YW1wKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2Jvb3QvR2FtZS5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYm9vdC9HYW1lLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEJsaXR0ZXIgPSByZXF1aXJlKCcuL0JsaXR0ZXInKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgQmxpdHRlckZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAnYmxpdHRlcicsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENyZWF0ZSBhIG5ldyBgQmxpdHRlcmAgb2JqZWN0LlxyXG4gICAgKlxyXG4gICAgKiBBbiBJbWFnZSBpcyBhIGxpZ2h0LXdlaWdodCBvYmplY3QgeW91IGNhbiB1c2UgdG8gZGlzcGxheSBhbnl0aGluZyB0aGF0IGRvZXNuJ3QgbmVlZCBwaHlzaWNzIG9yIGFuaW1hdGlvbi5cclxuICAgICpcclxuICAgICogSXQgY2FuIHN0aWxsIHJvdGF0ZSwgc2NhbGUsIGNyb3AgYW5kIHJlY2VpdmUgaW5wdXQgZXZlbnRzLlxyXG4gICAgKiBUaGlzIG1ha2VzIGl0IHBlcmZlY3QgZm9yIGxvZ29zLCBiYWNrZ3JvdW5kcywgc2ltcGxlIGJ1dHRvbnMgYW5kIG90aGVyIG5vbi1TcHJpdGUgZ3JhcGhpY3MuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdhbWVPYmplY3QuRmFjdG9yeSNpbWFnZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBJbWFnZS4gVGhlIGNvb3JkaW5hdGUgaXMgcmVsYXRpdmUgdG8gYW55IHBhcmVudCBjb250YWluZXIgdGhpcyBJbWFnZSBtYXkgYmUgaW4uXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cclxuICAgICogQHBhcmFtIHtzdHJpbmd8UGhhc2VyLlJlbmRlclRleHR1cmV8UGhhc2VyLkJpdG1hcERhdGF8UGhhc2VyLlZpZGVvfFBJWEkuVGV4dHVyZX0gW2tleV0gLSBUaGUgaW1hZ2UgdXNlZCBhcyBhIHRleHR1cmUgYnkgdGhpcyBkaXNwbGF5IG9iamVjdCBkdXJpbmcgcmVuZGVyaW5nLiBJZiBhIHN0cmluZyBQaGFzZXIgd2lsbCBnZXQgZm9yIGFuIGVudHJ5IGluIHRoZSBJbWFnZSBDYWNoZS4gT3IgaXQgY2FuIGJlIGFuIGluc3RhbmNlIG9mIGEgUmVuZGVyVGV4dHVyZSwgQml0bWFwRGF0YSwgVmlkZW8gb3IgUElYSS5UZXh0dXJlLlxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtmcmFtZV0gLSBJZiBhIFRleHR1cmUgQXRsYXMgb3IgU3ByaXRlIFNoZWV0IGlzIHVzZWQgdGhpcyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIGZyYW1lIHRvIGJlIHVzZWQuIFVzZSBlaXRoZXIgYW4gaW50ZWdlciBmb3IgYSBGcmFtZSBJRCBvciBhIHN0cmluZyBmb3IgYSBmcmFtZSBuYW1lLlxyXG4gICAgKiBAcGFyYW0ge1BoYXNlci5Hcm91cH0gW2dyb3VwXSAtIE9wdGlvbmFsIEdyb3VwIHRvIGFkZCB0aGUgb2JqZWN0IHRvLiBJZiBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFdvcmxkIGdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuSW1hZ2V9IFRoZSBuZXdseSBjcmVhdGVkIEltYWdlIG9iamVjdC5cclxuICAgICovXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lLCBncm91cClcclxuICAgIHtcclxuICAgICAgICBpZiAoZ3JvdXAgPT09IHVuZGVmaW5lZCkgeyBncm91cCA9IHRoaXMuc3RhdGU7IH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0ltYWdlRmFjdG9yeS5hZGQnLCBrZXksIHgsIHksIGZyYW1lLCBncm91cCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2ludG8gU3RhdGUnLCB0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGdyb3VwLmNoaWxkcmVuLmFkZChuZXcgQmxpdHRlcih0aGlzLnN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2U6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdJbWFnZUZhY3RvcnkubWFrZScsIGtleSwgeCwgeSwgZnJhbWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEJsaXR0ZXIodGhpcy5zdGF0ZSwgeCwgeSwga2V5LCBmcmFtZSk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyLnJlZ2lzdGVyKEJsaXR0ZXJGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyRmFjdG9yeS5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDb250YWluZXIgPSByZXF1aXJlKCcuL0NvbnRhaW5lcicpO1xyXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKTtcclxuXHJcbnZhciBDb250YWluZXJGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ2NvbnRhaW5lcicsXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAocGFyZW50LCB4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkgeyBwYXJlbnQgPSB0aGlzLnN0YXRlOyB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGRyZW4uYWRkKG5ldyBDb250YWluZXIodGhpcy5zdGF0ZSwgcGFyZW50LCB4LCB5KSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2U6IGZ1bmN0aW9uIChwYXJlbnQsIHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb250YWluZXIodGhpcy5zdGF0ZSwgcGFyZW50LCB4LCB5KTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoQ29udGFpbmVyRmFjdG9yeSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyRmFjdG9yeS5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBJbWFnZSA9IHJlcXVpcmUoJy4vSW1hZ2UnKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgSW1hZ2VGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ2ltYWdlJyxcclxuXHJcbiAgICAvKipcclxuICAgICogQ3JlYXRlIGEgbmV3IGBJbWFnZWAgb2JqZWN0LlxyXG4gICAgKlxyXG4gICAgKiBBbiBJbWFnZSBpcyBhIGxpZ2h0LXdlaWdodCBvYmplY3QgeW91IGNhbiB1c2UgdG8gZGlzcGxheSBhbnl0aGluZyB0aGF0IGRvZXNuJ3QgbmVlZCBwaHlzaWNzIG9yIGFuaW1hdGlvbi5cclxuICAgICpcclxuICAgICogSXQgY2FuIHN0aWxsIHJvdGF0ZSwgc2NhbGUsIGNyb3AgYW5kIHJlY2VpdmUgaW5wdXQgZXZlbnRzLlxyXG4gICAgKiBUaGlzIG1ha2VzIGl0IHBlcmZlY3QgZm9yIGxvZ29zLCBiYWNrZ3JvdW5kcywgc2ltcGxlIGJ1dHRvbnMgYW5kIG90aGVyIG5vbi1TcHJpdGUgZ3JhcGhpY3MuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdhbWVPYmplY3QuRmFjdG9yeSNpbWFnZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBJbWFnZS4gVGhlIGNvb3JkaW5hdGUgaXMgcmVsYXRpdmUgdG8gYW55IHBhcmVudCBjb250YWluZXIgdGhpcyBJbWFnZSBtYXkgYmUgaW4uXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cclxuICAgICogQHBhcmFtIHtzdHJpbmd8UGhhc2VyLlJlbmRlclRleHR1cmV8UGhhc2VyLkJpdG1hcERhdGF8UGhhc2VyLlZpZGVvfFBJWEkuVGV4dHVyZX0gW2tleV0gLSBUaGUgaW1hZ2UgdXNlZCBhcyBhIHRleHR1cmUgYnkgdGhpcyBkaXNwbGF5IG9iamVjdCBkdXJpbmcgcmVuZGVyaW5nLiBJZiBhIHN0cmluZyBQaGFzZXIgd2lsbCBnZXQgZm9yIGFuIGVudHJ5IGluIHRoZSBJbWFnZSBDYWNoZS4gT3IgaXQgY2FuIGJlIGFuIGluc3RhbmNlIG9mIGEgUmVuZGVyVGV4dHVyZSwgQml0bWFwRGF0YSwgVmlkZW8gb3IgUElYSS5UZXh0dXJlLlxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtmcmFtZV0gLSBJZiBhIFRleHR1cmUgQXRsYXMgb3IgU3ByaXRlIFNoZWV0IGlzIHVzZWQgdGhpcyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIGZyYW1lIHRvIGJlIHVzZWQuIFVzZSBlaXRoZXIgYW4gaW50ZWdlciBmb3IgYSBGcmFtZSBJRCBvciBhIHN0cmluZyBmb3IgYSBmcmFtZSBuYW1lLlxyXG4gICAgKiBAcGFyYW0ge1BoYXNlci5Hcm91cH0gW2dyb3VwXSAtIE9wdGlvbmFsIEdyb3VwIHRvIGFkZCB0aGUgb2JqZWN0IHRvLiBJZiBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFdvcmxkIGdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuSW1hZ2V9IFRoZSBuZXdseSBjcmVhdGVkIEltYWdlIG9iamVjdC5cclxuICAgICovXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lLCBncm91cClcclxuICAgIHtcclxuICAgICAgICBpZiAoZ3JvdXAgPT09IHVuZGVmaW5lZCkgeyBncm91cCA9IHRoaXMuc3RhdGU7IH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0ltYWdlRmFjdG9yeS5hZGQnLCBrZXksIHgsIHksIGZyYW1lLCBncm91cCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2ludG8gU3RhdGUnLCB0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGdyb3VwLmNoaWxkcmVuLmFkZChuZXcgSW1hZ2UodGhpcy5zdGF0ZSwgeCwgeSwga2V5LCBmcmFtZSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlOiBmdW5jdGlvbiAoeCwgeSwga2V5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnSW1hZ2VGYWN0b3J5Lm1ha2UnLCBrZXksIHgsIHksIGZyYW1lKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbWFnZSh0aGlzLnN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoSW1hZ2VGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanMiLCIvLyAgUGhhc2VyLkdlb21cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXHJcbiAgICBDaXJjbGU6IHJlcXVpcmUoJy4vY2lyY2xlJyksXHJcbiAgICBFbGxpcHNlOiByZXF1aXJlKCcuL2VsbGlwc2UnKSxcclxuICAgIEhlcm1pdGU6IHJlcXVpcmUoJy4vaGVybWl0ZScpLFxyXG4gICAgSW50ZXJzZWN0czogcmVxdWlyZSgnLi9pbnRlcnNlY3RzJyksXHJcbiAgICBMaW5lOiByZXF1aXJlKCcuL2xpbmUnKSxcclxuICAgIFBvaW50OiByZXF1aXJlKCcuL3BvaW50JyksXHJcbiAgICBQb2x5Z29uOiByZXF1aXJlKCcuL3BvbHlnb24nKSxcclxuICAgIFJlY3RhbmdsZTogcmVxdWlyZSgnLi9yZWN0YW5nbGUnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIC8vICBDT05TVHMgKG1ha2VzIHRoZW0gdmlzaWJsZSB1bmRlciBQaGFzZXIuTWF0aClcclxuICAgIFBJMjogTWF0aC5QSSAqIDIsXHJcbiAgICBUQVU6IE1hdGguUEkgKiAwLjUsXHJcbiAgICBFUFNJTE9OOiAxLjBlLTYsXHJcbiAgICBERUdfVE9fUkFEOiBNYXRoLlBJIC8gMTgwLFxyXG4gICAgUkFEX1RPX0RFRzogMTgwIC8gTWF0aC5QSSxcclxuXHJcbiAgICAvLyAgQ29sbGVjdGlvbnMgb2YgZnVuY3Rpb25zXHJcbiAgICBBbmdsZTogcmVxdWlyZSgnLi9hbmdsZS8nKSxcclxuICAgIERpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlLycpLFxyXG4gICAgRWFzaW5nOiByZXF1aXJlKCcuL2Vhc2luZy8nKSxcclxuICAgIEZ1enp5OiByZXF1aXJlKCcuL2Z1enp5LycpLFxyXG4gICAgSW50ZXJwb2xhdGlvbjogcmVxdWlyZSgnLi9pbnRlcnBvbGF0aW9uLycpLFxyXG4gICAgUG93MjogcmVxdWlyZSgnLi9wb3cyLycpLFxyXG4gICAgU25hcDogcmVxdWlyZSgnLi9zbmFwLycpLFxyXG5cclxuICAgIC8vICBTaW5nbGUgZnVuY3Rpb25zXHJcbiAgICBBdmVyYWdlOiByZXF1aXJlKCcuL0F2ZXJhZ2UnKSxcclxuICAgIEJlcm5zdGVpbjogcmVxdWlyZSgnLi9CZXJuc3RlaW4nKSxcclxuICAgIEJldHdlZW46IHJlcXVpcmUoJy4vQmV0d2VlbicpLFxyXG4gICAgQ2F0bXVsbFJvbTogcmVxdWlyZSgnLi9DYXRtdWxsUm9tJyksXHJcbiAgICBDZWlsVG86IHJlcXVpcmUoJy4vQ2VpbFRvJyksXHJcbiAgICBDbGFtcDogcmVxdWlyZSgnLi9DbGFtcCcpLFxyXG4gICAgRGVnVG9SYWQ6IHJlcXVpcmUoJy4vRGVnVG9SYWQnKSxcclxuICAgIERpZmZlcmVuY2U6IHJlcXVpcmUoJy4vRGlmZmVyZW5jZScpLFxyXG4gICAgRmFjdG9yaWFsOiByZXF1aXJlKCcuL0ZhY3RvcmlhbCcpLFxyXG4gICAgRmxvYXRCZXR3ZWVuOiByZXF1aXJlKCcuL0Zsb2F0QmV0d2VlbicpLFxyXG4gICAgRmxvb3JUbzogcmVxdWlyZSgnLi9GbG9vclRvJyksXHJcbiAgICBMaW5lYXI6IHJlcXVpcmUoJy4vTGluZWFyJyksXHJcbiAgICBNYXhBZGQ6IHJlcXVpcmUoJy4vTWF4QWRkJyksXHJcbiAgICBNaW5TdWI6IHJlcXVpcmUoJy4vTWluU3ViJyksXHJcbiAgICBQZXJjZW50OiByZXF1aXJlKCcuL1BlcmNlbnQnKSxcclxuICAgIFJhZFRvRGVnOiByZXF1aXJlKCcuL1JhZFRvRGVnJyksXHJcbiAgICBSb3RhdGU6IHJlcXVpcmUoJy4vUm90YXRlJyksXHJcbiAgICBSb3RhdGVBcm91bmQ6IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kJyksXHJcbiAgICBSb3RhdGVBcm91bmREaXN0YW5jZTogcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmREaXN0YW5jZScpLFxyXG4gICAgUm91bmRBd2F5RnJvbVplcm86IHJlcXVpcmUoJy4vUm91bmRBd2F5RnJvbVplcm8nKSxcclxuICAgIFJvdW5kVG86IHJlcXVpcmUoJy4vUm91bmRUbycpLFxyXG4gICAgU2luQ29zVGFibGVHZW5lcmF0b3I6IHJlcXVpcmUoJy4vU2luQ29zVGFibGVHZW5lcmF0b3InKSxcclxuICAgIFNtb290aGVyU3RlcDogcmVxdWlyZSgnLi9TbW9vdGhlclN0ZXAnKSxcclxuICAgIFNtb290aFN0ZXA6IHJlcXVpcmUoJy4vU21vb3RoU3RlcCcpLFxyXG4gICAgV2l0aGluOiByZXF1aXJlKCcuL1dpdGhpbicpLFxyXG4gICAgV3JhcDogcmVxdWlyZSgnLi9XcmFwJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvaW5kZXguanMiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9wb2x5ZmlsbHMvaW5kZXguanMiLCJyZXF1aXJlKCcuL0FycmF5LmZvckVhY2gnKTtcclxucmVxdWlyZSgnLi9BcnJheS5pc0FycmF5Jyk7XHJcbnJlcXVpcmUoJy4vQXVkaW9Db250ZXh0TW9ua2V5UGF0Y2gnKTtcclxucmVxdWlyZSgnLi9jb25zb2xlJyk7XHJcbnJlcXVpcmUoJy4vRnVuY3Rpb24uYmluZCcpO1xyXG5yZXF1aXJlKCcuL01hdGgudHJ1bmMnKTtcclxucmVxdWlyZSgnLi9wZXJmb3JtYW5jZS5ub3cnKTtcclxucmVxdWlyZSgnLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcclxucmVxdWlyZSgnLi9VaW50MzJBcnJheScpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuU291bmRcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIER5bmFtaWM6IHJlcXVpcmUoJy4vZHluYW1pYycpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zb3VuZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc291bmQvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBGaW5kQ2xvc2VzdEluU29ydGVkOiByZXF1aXJlKCcuL0ZpbmRDbG9zZXN0SW5Tb3J0ZWQnKSxcclxuICAgIEdldFJhbmRvbUVsZW1lbnQ6IHJlcXVpcmUoJy4vR2V0UmFuZG9tRWxlbWVudCcpLFxyXG4gICAgTnVtYmVyQXJyYXk6IHJlcXVpcmUoJy4vTnVtYmVyQXJyYXknKSxcclxuICAgIE51bWJlckFycmF5U3RlcDogcmVxdWlyZSgnLi9OdW1iZXJBcnJheVN0ZXAnKSxcclxuICAgIFJlbW92ZVJhbmRvbUVsZW1lbnQ6IHJlcXVpcmUoJy4vUmVtb3ZlUmFuZG9tRWxlbWVudCcpLFxyXG4gICAgUm90YXRlTGVmdDogcmVxdWlyZSgnLi9Sb3RhdGVMZWZ0JyksXHJcbiAgICBSb3RhdGVSaWdodDogcmVxdWlyZSgnLi9Sb3RhdGVSaWdodCcpLFxyXG4gICAgU2h1ZmZsZTogcmVxdWlyZSgnLi9TaHVmZmxlJyksXHJcbiAgICBTcGxpY2VPbmU6IHJlcXVpcmUoJy4vU3BsaWNlT25lJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hcnJheS9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEV4dGVuZDogcmVxdWlyZSgnLi9FeHRlbmQnKSxcclxuICAgIElzUGxhaW5PYmplY3Q6IHJlcXVpcmUoJy4vSXNQbGFpbk9iamVjdCcpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9vYmplY3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL29iamVjdC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlLmw7IH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGUuaTsgfVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBOT09QID0gcmVxdWlyZSgnLi4vdXRpbHMvTk9PUCcpO1xyXG52YXIgR2V0T2JqZWN0VmFsdWUgPSByZXF1aXJlKCcuLi91dGlscy9HZXRPYmplY3RWYWx1ZScpO1xyXG5cclxudmFyIGRlZmF1bHRCYW5uZXJDb2xvciA9IFtcclxuICAgICcjZmYwMDAwJyxcclxuICAgICcjZmZmZjAwJyxcclxuICAgICcjMDBmZjAwJyxcclxuICAgICcjMDBmZmZmJyxcclxuICAgICcjMDAwMDAwJ1xyXG5dO1xyXG5cclxudmFyIGRlZmF1bHRCYW5uZXJUZXh0Q29sb3IgPSAnI2ZmZmZmZic7XHJcblxyXG52YXIgQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZylcclxue1xyXG4gICAgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7IGNvbmZpZyA9IHt9OyB9XHJcblxyXG4gICAgdGhpcy53aWR0aCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3dpZHRoJywgMTAyNCk7XHJcbiAgICB0aGlzLmhlaWdodCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2hlaWdodCcsIDc2OCk7XHJcblxyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmVzb2x1dGlvbicsIDEpO1xyXG5cclxuICAgIHRoaXMucmVuZGVyVHlwZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3R5cGUnLCBDT05TVC5BVVRPKTtcclxuXHJcbiAgICB0aGlzLnBhcmVudCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3BhcmVudCcsIG51bGwpO1xyXG4gICAgdGhpcy5jYW52YXMgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdjYW52YXMnLCBudWxsKTtcclxuICAgIHRoaXMuY2FudmFzU3R5bGUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdjYW52YXNTdHlsZScsIG51bGwpO1xyXG5cclxuICAgIHRoaXMuc3RhdGVDb25maWcgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdzdGF0ZScsIG51bGwpO1xyXG5cclxuICAgIHRoaXMuc2VlZCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3NlZWQnLCBbIChEYXRlLm5vdygpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKSBdKTtcclxuXHJcbiAgICB0aGlzLmdhbWVUaXRsZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3RpdGxlJywgJycpO1xyXG4gICAgdGhpcy5nYW1lVVJMID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndXJsJywgJ2h0dHA6Ly9waGFzZXIuaW8nKTtcclxuICAgIHRoaXMuZ2FtZVZlcnNpb24gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd2ZXJzaW9uJywgJycpO1xyXG5cclxuICAgIC8vICBJZiB5b3UgZG86IHsgYmFubmVyOiBmYWxzZSB9IGl0IHdvbid0IGRpc3BsYXkgYW55IGJhbm5lciBhdCBhbGxcclxuICAgIHRoaXMuaGlkZUJhbm5lciA9IChHZXRPYmplY3RWYWx1ZShjb25maWcsICdiYW5uZXInLCBudWxsKSA9PT0gZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuaGlkZVBoYXNlciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Jhbm5lci5oaWRlUGhhc2VyJywgZmFsc2UpO1xyXG4gICAgdGhpcy5iYW5uZXJUZXh0Q29sb3IgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdiYW5uZXIudGV4dCcsIGRlZmF1bHRCYW5uZXJUZXh0Q29sb3IpO1xyXG4gICAgdGhpcy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdiYW5uZXIuYmFja2dyb3VuZCcsIGRlZmF1bHRCYW5uZXJDb2xvcik7XHJcbiAgIFxyXG4gICAgdGhpcy5mb3JjZVNldFRpbWVPdXQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdmb3JjZVNldFRpbWVPdXQnLCBmYWxzZSk7XHJcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndHJhbnNwYXJlbnQnLCBmYWxzZSk7XHJcbiAgICB0aGlzLnBpeGVsQXJ0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncGl4ZWxBcnQnLCBmYWxzZSk7XHJcblxyXG4gICAgLy8gIENhbGxiYWNrc1xyXG4gICAgdGhpcy5wcmVCb290ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2FsbGJhY2tzLnByZUJvb3QnLCBOT09QKTtcclxuICAgIHRoaXMucG9zdEJvb3QgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdjYWxsYmFja3MucG9zdEJvb3QnLCBOT09QKTtcclxufTtcclxuXHJcbkNvbmZpZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25maWc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbmZpZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYm9vdC9Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2Jvb3QvQ29uZmlnLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzUG9vbCcpO1xyXG52YXIgRmVhdHVyZXMgPSByZXF1aXJlKCcuLi9kZXZpY2UvRmVhdHVyZXMnKTtcclxudmFyIENhbnZhc1JlbmRlcmVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvY2FudmFzL0NhbnZhc1JlbmRlcmVyJyk7XHJcbnZhciBXZWJHTFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvd2ViZ2wvV2ViR0xSZW5kZXJlcicpO1xyXG5cclxuLyoqXHJcbiogQ2hlY2tzIGlmIHRoZSBkZXZpY2UgaXMgY2FwYWJsZSBvZiB1c2luZyB0aGUgcmVxdWVzdGVkIHJlbmRlcmVyIGFuZCBzZXRzIGl0IHVwIG9yIGFuIGFsdGVybmF0aXZlIGlmIG5vdC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkdhbWUjc2V0VXBSZW5kZXJlclxyXG4qIEBwcm90ZWN0ZWRcclxuKi9cclxudmFyIENyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24gKGdhbWUpXHJcbntcclxuICAgIHZhciBjb25maWcgPSBnYW1lLmNvbmZpZztcclxuXHJcbiAgICAvLyAgR2FtZSBlaXRoZXIgcmVxdWVzdGVkIENhbnZhcyxcclxuICAgIC8vICBvciByZXF1ZXN0ZWQgQVVUTyBvciBXRUJHTCBidXQgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGl0LCBzbyBmYWxsIGJhY2sgdG8gQ2FudmFzXHJcbiAgICBpZiAoY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULkNBTlZBUyB8fCAoY29uZmlnLnJlbmRlclR5cGUgIT09IENPTlNULkNBTlZBUyAmJiAhRmVhdHVyZXMud2ViR0wpKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChGZWF0dXJlcy5jYW52YXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVGhleSByZXF1ZXN0ZWQgQ2FudmFzIGFuZCB0aGVpciBicm93c2VyIHN1cHBvcnRzIGl0XHJcbiAgICAgICAgICAgIGNvbmZpZy5yZW5kZXJUeXBlID0gQ09OU1QuQ0FOVkFTO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgQ2FudmFzIG9yIFdlYkdMIGNvbnRleHQsIGFib3J0aW5nLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgR2FtZSByZXF1ZXN0ZWQgV2ViR0wgYW5kIGJyb3dzZXIgc2F5cyBpdCBzdXBwb3J0cyBpdFxyXG4gICAgICAgIGNvbmZpZy5yZW5kZXJUeXBlID0gQ09OU1QuV0VCR0w7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIERvZXMgdGhlIGdhbWUgY29uZmlnIHByb3ZpZGUgaXRzIG93biBjYW52YXMgZWxlbWVudCB0byB1c2U/XHJcbiAgICBpZiAoY29uZmlnLmNhbnZhcylcclxuICAgIHtcclxuICAgICAgICBnYW1lLmNhbnZhcyA9IGNvbmZpZy5jYW52YXM7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZS5jYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZShnYW1lLCBjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQsIGNvbmZpZy5yZW5kZXJUeXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRG9lcyB0aGUgZ2FtZSBjb25maWcgcHJvdmlkZSBzb21lIGNhbnZhcyBjc3Mgc3R5bGVzIHRvIHVzZT9cclxuICAgIGlmIChjb25maWcuY2FudmFzU3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZS5jYW52YXMuc3R5bGUgPSBjb25maWcuY2FudmFzU3R5bGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIENyZWF0ZSB0aGUgcmVuZGVyZXJcclxuICAgIGlmIChjb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuV0VCR0wpXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIFdFQkdMIFJlbmRlcmVyJyk7XHJcbiAgICAgICAgZ2FtZS5yZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKGdhbWUpO1xyXG4gICAgICAgIGdhbWUuY29udGV4dCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIENhbnZhcyBSZW5kZXJlcicpO1xyXG4gICAgICAgIGdhbWUucmVuZGVyZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIoZ2FtZSk7XHJcbiAgICAgICAgZ2FtZS5jb250ZXh0ID0gZ2FtZS5yZW5kZXJlci5jb250ZXh0O1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYm9vdC9DcmVhdGVSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYm9vdC9DcmVhdGVSZW5kZXJlci5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBDSEVDS1NVTSA9IHJlcXVpcmUoJy4uL2NoZWNrc3VtJyk7XHJcblxyXG52YXIgRGVidWdIZWFkZXIgPSBmdW5jdGlvbiAoZ2FtZSlcclxue1xyXG4gICAgdmFyIGNvbmZpZyA9IGdhbWUuY29uZmlnO1xyXG5cclxuICAgIGlmIChjb25maWcuaGlkZUJhbm5lcilcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlbmRlclR5cGUgPSAoY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULkNBTlZBUykgPyAnQ2FudmFzJyA6ICdXZWJHTCc7XHJcblxyXG4gICAgdmFyIGllID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKCFpZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYyA9ICcnO1xyXG4gICAgICAgIHZhciBhcmdzID0gW2NdO1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcuYmFubmVyQmFja2dyb3VuZENvbG9yKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0Q29sb3I7XHJcblxyXG4gICAgICAgICAgICBjb25maWcuYmFubmVyQmFja2dyb3VuZENvbG9yLmZvckVhY2goZnVuY3Rpb24oY29sb3IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjID0gYy5jb25jYXQoJyVjICcpO1xyXG5cclxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnYmFja2dyb3VuZDogJyArIGNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0Q29sb3IgPSBjb2xvcjtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gIGluamVjdCB0aGUgdGV4dCBjb2xvclxyXG4gICAgICAgICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSAnY29sb3I6ICcgKyBjb25maWcuYmFubmVyVGV4dENvbG9yICsgJzsgYmFja2dyb3VuZDogJyArIGxhc3RDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYyA9IGMuY29uY2F0KCclYyAnKTtcclxuXHJcbiAgICAgICAgICAgIGFyZ3MucHVzaCgnY29sb3I6ICcgKyBjb25maWcuYmFubmVyVGV4dENvbG9yICsgJzsgYmFja2dyb3VuZDogJyArIGNvbmZpZy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFVSTCBsaW5rIGJhY2tncm91bmQgY29sb3IgKGFsd2F5cyB3aGl0ZSlcclxuICAgICAgICBhcmdzLnB1c2goJ2JhY2tncm91bmQ6ICNmZmYnKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5nYW1lVGl0bGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjID0gYy5jb25jYXQoY29uZmlnLmdhbWVUaXRsZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmdhbWVWZXJzaW9uKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjID0gYy5jb25jYXQoJyB2JyArIGNvbmZpZy5nYW1lVmVyc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghY29uZmlnLmhpZGVQaGFzZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnIC8gJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY29uZmlnLmhpZGVQaGFzZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjID0gYy5jb25jYXQoJ1BoYXNlciB2JyArIENPTlNULlZFUlNJT04gKyAnICgnICsgcmVuZGVyVHlwZSArICcpJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjID0gYy5jb25jYXQoJyAlYyAnICsgY29uZmlnLmdhbWVVUkwpO1xyXG5cclxuICAgICAgICAvLyAgSW5qZWN0IHRoZSBuZXcgc3RyaW5nIGJhY2sgaW50byB0aGUgYXJncyBhcnJheVxyXG4gICAgICAgIGFyZ3NbMF0gPSBjO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHdpbmRvd1snY29uc29sZSddKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdQaGFzZXIgdicgKyBDT05TVC5WRVJTSU9OICsgJyAvIGh0dHA6Ly9waGFzZXIuaW8nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBLZWVwIHRoaXMgZHVyaW5nIGRldiBidWlsZCBvbmx5XHJcbiAgICBjb25zb2xlLmxvZyhDSEVDS1NVTS5idWlsZCk7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWJ1Z0hlYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYm9vdC9EZWJ1Z0hlYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYm9vdC9EZWJ1Z0hlYWRlci5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzJyk7XHJcbnZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgV3JhcEFuZ2xlID0gcmVxdWlyZSgnLi4vbWF0aC9hbmdsZS9XcmFwJyk7XHJcblxyXG4vKipcclxuKiBBIENhbWVyYSBpcyB5b3VyIHZpZXcgaW50byB0aGUgZ2FtZSB3b3JsZC4gSXQgaGFzIGEgcG9zaXRpb24gYW5kIHNpemUgYW5kIHJlbmRlcnMgb25seSB0aG9zZSBvYmplY3RzIHdpdGhpbiBpdHMgZmllbGQgb2Ygdmlldy5cclxuKiBUaGUgZ2FtZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgYSBzaW5nbGUgU3RhZ2Ugc2l6ZWQgY2FtZXJhIG9uIGJvb3QuIE1vdmUgdGhlIGNhbWVyYSBhcm91bmQgdGhlIHdvcmxkIHdpdGggUGhhc2VyLkNhbWVyYS54L3lcclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuQ2FtZXJhXHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEdhbWUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBpZCAtIE5vdCBiZWluZyB1c2VkIGF0IHRoZSBtb21lbnQsIHdpbGwgYmUgd2hlbiBQaGFzZXIgc3VwcG9ydHMgbXVsdGlwbGUgY2FtZXJhXHJcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBQb3NpdGlvbiBvZiB0aGUgY2FtZXJhIG9uIHRoZSBYIGF4aXNcclxuKiBAcGFyYW0ge251bWJlcn0geSAtIFBvc2l0aW9uIG9mIHRoZSBjYW1lcmEgb24gdGhlIFkgYXhpc1xyXG4qIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdmlldyByZWN0YW5nbGVcclxuKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdmlldyByZWN0YW5nbGVcclxuKi9cclxudmFyIENhbWVyYSA9IGZ1bmN0aW9uIChzdGF0ZSwgeCwgeSwgdmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQpXHJcbntcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFN0YXRlIHRoYXQgdGhpcyBDYW1lcmEgYmVsb25ncyB0by4gQSBDYW1lcmEgY2FuIG9ubHkgYmVsb25nIHRvIG9uZSBTdGF0ZSwgYW5kIGEgU3RhdGUgb25seVxyXG4gICAgICogaGFzIG9uZSBDYW1lcmEuXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlN0YXRlfSBzdGF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBHYW1lLlxyXG4gICAgKi9cclxuICAgIHRoaXMuZ2FtZSA9IHN0YXRlLmdhbWU7XHJcblxyXG4gICAgdGhpcy52aWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aDtcclxuXHJcbiAgICB0aGlzLnZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQ7XHJcblxyXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBuZXcgQ29tcG9uZW50LlRyYW5zZm9ybSh0aGlzLCB4LCB5KTtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIENhbWVyYSBpcyBib3VuZCB0byB0aGlzIFJlY3RhbmdsZSBhbmQgY2Fubm90IG1vdmUgb3V0c2lkZSBvZiBpdC4gQnkgZGVmYXVsdCBpdCBpcyBlbmFibGVkIGFuZCBzZXQgdG8gdGhlIHNpemUgb2YgdGhlIFdvcmxkLlxyXG4gICAgKiBUaGUgUmVjdGFuZ2xlIGNhbiBiZSBsb2NhdGVkIGFueXdoZXJlIGluIHRoZSB3b3JsZCBhbmQgdXBkYXRlZCBhcyBvZnRlbiBhcyB5b3UgbGlrZS4gSWYgeW91IGRvbid0IHdpc2ggdGhlIENhbWVyYSB0byBiZSBib3VuZFxyXG4gICAgKiBhdCBhbGwgdGhlbiBzZXQgdGhpcyB0byBudWxsLiBUaGUgdmFsdWVzIGNhbiBiZSBhbnl0aGluZyBhbmQgYXJlIGluIFdvcmxkIGNvb3JkaW5hdGVzLCB3aXRoIDAsMCBiZWluZyB0aGUgdG9wLWxlZnQgb2YgdGhlIHdvcmxkLlxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5SZWN0YW5nbGV9IGJvdW5kcyAtIFRoZSBSZWN0YW5nbGUgaW4gd2hpY2ggdGhlIENhbWVyYSBpcyBib3VuZGVkLiBTZXQgdG8gbnVsbCB0byBhbGxvdyBmb3IgbW92ZW1lbnQgYW55d2hlcmUuXHJcbiAgICAqL1xyXG4gICAgLy8gdGhpcy5ib3VuZHMgPSBuZXcgUGhhc2VyLlJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAvLyB0aGlzLmJvdW5kcyA9IG5ldyBQaGFzZXIuQ2lyY2xlKHgsIHkpXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXRMaW1pdCAtIFdoZXRoZXIgdGhpcyBjYW1lcmEgaXMgZmx1c2ggd2l0aCB0aGUgV29ybGQgQm91bmRzIG9yIG5vdC5cclxuICAgICovXHJcbiAgICB0aGlzLmF0TGltaXQgPSB7IHg6IGZhbHNlLCB5OiBmYWxzZSB9O1xyXG59O1xyXG5cclxuQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbWVyYTtcclxuXHJcbkNhbWVyYS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIE1ldGhvZCBjYWxsZWQgdG8gZW5zdXJlIHRoZSBjYW1lcmEgZG9lc24ndCB2ZW50dXJlIG91dHNpZGUgb2YgdGhlIGdhbWUgd29ybGQuXHJcbiAgICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IENhbWVyYS51cGRhdGUuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkNhbWVyYSNjaGVja0JvdW5kc1xyXG4gICAgKiBAcHJvdGVjdGVkXHJcbiAgICAqL1xyXG4gICAgY2hlY2tCb3VuZHM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hdExpbWl0LnggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmF0TGltaXQueSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyB2YXIgdnggPSB0aGlzLnZpZXcueCArIHRoaXMuX3NoYWtlLng7XHJcbiAgICAgICAgLy8gdmFyIHZ3ID0gdGhpcy52aWV3LnJpZ2h0ICsgdGhpcy5fc2hha2UueDtcclxuICAgICAgICAvLyB2YXIgdnkgPSB0aGlzLnZpZXcueSArIHRoaXMuX3NoYWtlLnk7XHJcbiAgICAgICAgLy8gdmFyIHZoID0gdGhpcy52aWV3LmJvdHRvbSArIHRoaXMuX3NoYWtlLnk7XHJcblxyXG4gICAgICAgIHZhciB2eCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgdncgPSB0aGlzLnggKyB0aGlzLnZpZXdwb3J0V2lkdGg7XHJcbiAgICAgICAgdmFyIHZ5ID0gdGhpcy55O1xyXG4gICAgICAgIHZhciB2aCA9IHRoaXMueSArIHRoaXMudmlld3BvcnRIZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vICBNYWtlIHN1cmUgd2UgZGlkbid0IGdvIG91dHNpZGUgdGhlIGNhbWVyYXMgYm91bmRzXHJcbiAgICAgICAgaWYgKHZ4IDw9IHRoaXMuYm91bmRzLnggKiB0aGlzLnNjYWxlLngpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmF0TGltaXQueCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy54ID0gdGhpcy5ib3VuZHMueCAqIHRoaXMuc2NhbGUueDtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2hha2Uuc2hha2VCb3VuZHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBUaGUgY2FtZXJhIGlzIHVwIGFnYWluc3QgdGhlIGJvdW5kcywgc28gcmVzZXQgdGhlIHNoYWtlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZS54ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZ3ID49IHRoaXMuYm91bmRzLnJpZ2h0ICogdGhpcy5zY2FsZS54KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hdExpbWl0LnggPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcueCA9ICh0aGlzLmJvdW5kcy5yaWdodCAqIHRoaXMuc2NhbGUueCkgLSB0aGlzLndpZHRoO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaGFrZS5zaGFrZUJvdW5kcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRoZSBjYW1lcmEgaXMgdXAgYWdhaW5zdCB0aGUgYm91bmRzLCBzbyByZXNldCB0aGUgc2hha2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlLnggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodnkgPD0gdGhpcy5ib3VuZHMudG9wICogdGhpcy5zY2FsZS55KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hdExpbWl0LnkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcueSA9IHRoaXMuYm91bmRzLnRvcCAqIHRoaXMuc2NhbGUueTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2hha2Uuc2hha2VCb3VuZHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBUaGUgY2FtZXJhIGlzIHVwIGFnYWluc3QgdGhlIGJvdW5kcywgc28gcmVzZXQgdGhlIHNoYWtlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZS55ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZoID49IHRoaXMuYm91bmRzLmJvdHRvbSAqIHRoaXMuc2NhbGUueSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYXRMaW1pdC55ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnkgPSAodGhpcy5ib3VuZHMuYm90dG9tICogdGhpcy5zY2FsZS55KSAtIHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaGFrZS5zaGFrZUJvdW5kcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRoZSBjYW1lcmEgaXMgdXAgYWdhaW5zdCB0aGUgYm91bmRzLCBzbyByZXNldCB0aGUgc2hha2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlLnkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDYW1lcmEucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLy8gIFRyYW5zZm9ybSBnZXR0ZXJzIC8gc2V0dGVyc1xyXG5cclxuICAgIHg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9wb3NYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3Bvc1ggPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9wb3NZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3Bvc1kgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcG9zWCArICh0aGlzLnZpZXdwb3J0V2lkdGggKiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b206IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9wb3NZICsgKHRoaXMudmlld3BvcnRIZWlnaHQgKiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX3NjYWxlWDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9zY2FsZVggPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3NjYWxlWSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGVYOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3NjYWxlWCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGVZOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3NjYWxlWSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGl2b3RYOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcGl2b3RYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3Bpdm90WCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGl2b3RZOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcGl2b3RZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3Bpdm90WSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYW5nbGU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFdyYXBBbmdsZSh0aGlzLnJvdGF0aW9uICogTUFUSF9DT05TVC5SQURfVE9fREVHKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSBXcmFwQW5nbGUodmFsdWUpICogTUFUSF9DT05TVC5ERUdfVE9fUkFEO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0aW9uOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcm90YXRpb247XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0uX3JvdGF0aW9uID09PSB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcm90YXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uZGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbiAlIE1BVEhfQ09OU1QuUEkyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5jYWNoZS5zciA9IE1hdGguc2luKHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5jYWNoZS5jciA9IE1hdGguY29zKHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uaGFzTG9jYWxSb3RhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5oYXNMb2NhbFJvdGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYW1lcmE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NhbWVyYS9DYW1lcmEuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NhbWVyYS9DYW1lcmEuanMiLCJ2YXIgQ0hFQ0tTVU0gPSB7XG5idWlsZDogJ2QyODBmMDgwLWUyNTItMTFlNi1iYWRhLWY5ZWY0NDVjYWNlZidcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENIRUNLU1VNO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NoZWNrc3VtLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBUaGUgQ29sb3IgQ29tcG9uZW50IGFsbG93cyB5b3UgdG8gY29udHJvbCB0aGUgYWxwaGEsIGJsZW5kIG1vZGUsIHRpbnQgYW5kIGJhY2tncm91bmQgY29sb3JcclxuKiBvZiBhIEdhbWUgT2JqZWN0LlxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcbnZhciBDb2xvciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xyXG5cclxuICAgIHRoaXMuc3RhdGUgPSBnYW1lT2JqZWN0LnN0YXRlO1xyXG5cclxuICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fYWxwaGEgPSAxO1xyXG4gICAgdGhpcy5fd29ybGRBbHBoYSA9IDE7XHJcblxyXG4gICAgdGhpcy5fYmxlbmRNb2RlID0gMDtcclxuXHJcbiAgICB0aGlzLl90aW50ID0geyB0b3BMZWZ0OiAweGZmZmZmZiwgdG9wUmlnaHQ6IDB4ZmZmZmZmLCBib3R0b21MZWZ0OiAweGZmZmZmZiwgYm90dG9tUmlnaHQ6IDB4ZmZmZmZmIH07XHJcbiAgICB0aGlzLl9nbFRpbnQgPSB7IHRvcExlZnQ6IDE2Nzc3MjE1LCB0b3BSaWdodDogMTY3NzcyMTUsIGJvdHRvbUxlZnQ6IDE2Nzc3MjE1LCBib3R0b21SaWdodDogMTY3NzcyMTUgfTtcclxuICAgIHRoaXMuX2hhc1RpbnQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyAgQmV0d2VlbiAwIGFuZCAyNTVcclxuICAgIHRoaXMuX3IgPSAwO1xyXG4gICAgdGhpcy5fZyA9IDA7XHJcbiAgICB0aGlzLl9iID0gMDtcclxuXHJcbiAgICAvLyAgQmV0d2VlbiAwIGFuZCAxXHJcbiAgICB0aGlzLl9hID0gMTtcclxuXHJcbiAgICAvLyAgU3RyaW5nIHZlcnNpb24gb2YgUkdCQVxyXG4gICAgdGhpcy5fcmdiYSA9ICcnO1xyXG5cclxuICAgIC8vICAzMi1iaXQgdmVyc2lvbiBvZiBBUkdCXHJcbiAgICB0aGlzLl9nbEJnID0gMDtcclxuXHJcbiAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gZmFsc2U7XHJcbn07XHJcblxyXG5Db2xvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xvcjtcclxuXHJcbkNvbG9yLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRCYWNrZ3JvdW5kOiBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHJlZCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9nbEJnID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3IgPSByZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2cgPSAoZ3JlZW4pID8gZ3JlZW4gOiAwO1xyXG4gICAgICAgICAgICB0aGlzLl9iID0gKGJsdWUpID8gYmx1ZSA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2EgPSAoYWxwaGEpID8gYWxwaGEgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyVGludDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNldFRpbnQoMHhmZmZmZmYpO1xyXG5cclxuICAgICAgICB0aGlzLl9oYXNUaW50ID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRpbnQ6IGZ1bmN0aW9uICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRvcFJpZ2h0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0b3BSaWdodCA9IHRvcExlZnQ7XHJcbiAgICAgICAgICAgIGJvdHRvbUxlZnQgPSB0b3BMZWZ0O1xyXG4gICAgICAgICAgICBib3R0b21SaWdodCA9IHRvcExlZnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRpbnRUb3BMZWZ0ID0gdG9wTGVmdDtcclxuICAgICAgICB0aGlzLnRpbnRUb3BSaWdodCA9IHRvcFJpZ2h0O1xyXG4gICAgICAgIHRoaXMudGludEJvdHRvbUxlZnQgPSBib3R0b21MZWZ0O1xyXG4gICAgICAgIHRoaXMudGludEJvdHRvbVJpZ2h0ID0gYm90dG9tUmlnaHQ7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhc1RpbnQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGxlZCBieSB0aGUgRGlydHkgTWFuYWdlclxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9oYXNCYWNrZ3JvdW5kKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fcmdiYSA9ICdyZ2JhKCcgKyB0aGlzLl9yICsgJywnICsgdGhpcy5fZyArICcsJyArIHRoaXMuX2IgKyAnLCcgKyB0aGlzLl9hICsgJyknO1xyXG4gICAgICAgICAgICB0aGlzLl9nbEJnID0gdGhpcy5nZXRDb2xvcjMyKHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRoaXMuX2EpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFRpbnQgbXVsdHM/XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDb2xvcjogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUgPj4gMTYpICsgKHZhbHVlICYgMHhmZjAwKSArICgodmFsdWUgJiAweGZmKSA8PCAxNik7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldENvbG9yMzI6IGZ1bmN0aW9uIChyLCBnLCBiLCBhKVxyXG4gICAge1xyXG4gICAgICAgIGEgKj0gMjU1O1xyXG5cclxuICAgICAgICByZXR1cm4gKChhIDw8IDI0KSB8IChiIDw8IDE2KSB8IChnIDw8IDgpIHwgcikgPj4+IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90aW50ID0gW107XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29sb3IucHJvdG90eXBlLCB7XHJcblxyXG4gICAgZGlydHk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpcnR5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zeXMudXBkYXRlcy5hZGQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdGludFRvcExlZnQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQudG9wTGVmdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbnQudG9wTGVmdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9nbFRpbnQudG9wTGVmdCA9IHRoaXMuZ2V0Q29sb3IodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0aW50VG9wUmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQudG9wUmlnaHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl90aW50LnRvcFJpZ2h0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsVGludC50b3BSaWdodCA9IHRoaXMuZ2V0Q29sb3IodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0aW50Qm90dG9tTGVmdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludC5ib3R0b21MZWZ0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fdGludC5ib3R0b21MZWZ0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsVGludC5ib3R0b21MZWZ0ID0gdGhpcy5nZXRDb2xvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRpbnRCb3R0b21SaWdodDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludC5ib3R0b21SaWdodDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbnQuYm90dG9tUmlnaHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZ2xUaW50LmJvdHRvbVJpZ2h0ID0gdGhpcy5nZXRDb2xvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRpbnQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNldFRpbnQodmFsdWUsIHZhbHVlLCB2YWx1ZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFscGhhOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbHBoYTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYWxwaGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FscGhhID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJsZW5kTW9kZToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9ibGVuZE1vZGUgJiYgdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxNilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmxlbmRNb2RlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHdvcmxkQWxwaGE6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FtZU9iamVjdC5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmxkQWxwaGEgPSB0aGlzLl9hbHBoYSAqIHRoaXMuZ2FtZU9iamVjdC5wYXJlbnQuY29sb3Iud29ybGRBbHBoYTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmxkQWxwaGE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl93b3JsZEFscGhhID0gdGhpcy5fYWxwaGEgKiB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBiYWNrZ3JvdW5kQWxwaGE6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2E7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2EpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2EgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZWQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3I7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3IgPSB2YWx1ZSB8IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ3JlZW46IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2c7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2cpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2cgPSB2YWx1ZSB8IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYmx1ZToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYiA9IHZhbHVlIHwgMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBUaGUgRGF0YSBDb21wb25lbnQgZmVhdHVyZXMgYSBtZWFucyB0byBzdG9yZSBwaWVjZXMgb2YgZGF0YSBzcGVjaWZpYyB0byBhIEdhbWUgT2JqZWN0LFxyXG4qIHNlYXJjaCBpdCwgcXVlcnkgaXQsIGFuZCByZXRyaWV2ZSBpdC5cclxuKlxyXG4qIEBjbGFzc1xyXG4qL1xyXG52YXIgRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQpXHJcbntcclxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgIHRoaXMubGlzdCA9IHt9O1xyXG5cclxuICAgIHRoaXMuX2JlZm9yZUNhbGxiYWNrcyA9IHt9O1xyXG4gICAgdGhpcy5fYWZ0ZXJDYWxsYmFja3MgPSB7fTtcclxuXHJcbiAgICB0aGlzLl9mcm96ZW4gPSBmYWxzZTtcclxufTtcclxuXHJcbkRhdGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGF0YTtcclxuXHJcbkRhdGEucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8vICBSZXRyaWV2ZXMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5LCBvciB1bmRlZmluZWQgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICAgIGdldDogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0W2tleV07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzdWx0c1trZXldID0gdGhpcy5saXN0W2tleV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH0sXHJcblxyXG4gICAgcXVlcnk6IGZ1bmN0aW9uIChzZWFyY2gpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChrZXkubWF0Y2goc2VhcmNoKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gdGhpcy5saXN0W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Zyb3plbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxpc3RlbmVyO1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgICAgIC8vICBJZiB0aGVyZSBpcyBhICdiZWZvcmUnIGNhbGxiYWNrLCB0aGVuIGNoZWNrIGl0IGZvciBhIHJlc3VsdFxyXG4gICAgICAgIGlmICh0aGlzLl9iZWZvcmVDYWxsYmFja3MuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyID0gdGhpcy5fYmVmb3JlQ2FsbGJhY2tzW2tleV07XHJcblxyXG4gICAgICAgICAgICByZXN1bHQgPSBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKGxpc3RlbmVyLnNjb3BlLCB0aGlzLnBhcmVudCwga2V5LCBkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5saXN0W2tleV0gPSBkYXRhO1xyXG5cclxuICAgICAgICAvLyAgSWYgdGhlcmUgaXMgYSAnYWZ0ZXInIGNhbGxiYWNrLCB0aGVuIGNoZWNrIGl0IGZvciBhIHJlc3VsdFxyXG4gICAgICAgIGlmICh0aGlzLl9hZnRlckNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIgPSB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIuY2FsbGJhY2suY2FsbChsaXN0ZW5lci5zY29wZSwgdGhpcy5wYXJlbnQsIGtleSwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdFtrZXldID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgYmVmb3JlOiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaywgc2NvcGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUmVtb3ZlIGVudHJ5XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzW2tleV0gPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgc2NvcGU6IHNjb3BlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZnRlcjogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2ssIHNjb3BlKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFJlbW92ZSBlbnRyeVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUgfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBQYXNzZXMgYWxsIGRhdGEgZW50cmllcyB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suIFN0b3JlcyB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjay5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBlYWNoXHJcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBbc2NvcGVdIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgICogQHBhcmFtIHsuLi4qfSBbYXJndW1lbnRzXSAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBhZnRlciB0aGUgZ2FtZSBvYmplY3QsIGtleSwgYW5kIGRhdGEuXHJcbiAgICAqL1xyXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYXJncyA9IFsgdGhpcy5wYXJlbnQsIG51bGwsIHVuZGVmaW5lZCBdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3NbMV0gPSBrZXk7XHJcbiAgICAgICAgICAgIGFyZ3NbMl0gPSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1lcmdlOiBmdW5jdGlvbiAoZGF0YSwgb3ZlcndyaXRlKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChvdmVyd3JpdGUgPT09IHVuZGVmaW5lZCkgeyBvdmVyd3JpdGUgPSB0cnVlOyB9XHJcblxyXG4gICAgICAgIC8vICBNZXJnZSBkYXRhIGZyb20gYW5vdGhlciBjb21wb25lbnQgaW50byB0aGlzIG9uZVxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZSB8fCAoIW92ZXJ3cml0ZSAmJiAhdGhpcy5oYXMoa2V5KSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdFtrZXldID0gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5fZnJvemVuICYmIHRoaXMuaGFzKGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyhrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLl9iZWZvcmVDYWxsYmFja3MuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9hZnRlckNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2FmdGVyQ2FsbGJhY2tzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgR2V0cyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuICdrZXknLCBkZWxldGVzIGl0IGZyb20gdGhpcyBEYXRhIHN0b3JlLCB0aGVuIHJldHVybnMgaXQuXHJcbiAgICBwb3A6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fZnJvemVuICYmIHRoaXMuaGFzKGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5saXN0W2tleV07XHJcblxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyhrZXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhczogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0Lmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGtleSBpbiB0aGlzLl9iZWZvcmVDYWxsYmFja3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzW2tleV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGtleSBpbiB0aGlzLl9hZnRlckNhbGxiYWNrcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZnJvemVuID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGF0YS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICogRnJlZXplIHRoaXMgRGF0YSBjb21wb25lbnQsIHNvIG5vIGNoYW5nZXMgY2FuIGJlIHdyaXR0ZW4gdG8gaXQuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIGZyZWV6ZVxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZyZWV6ZVxyXG4gICAgKi9cclxuICAgIGZyZWV6ZToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJvemVuO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fZnJvemVuID0gKHZhbHVlKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3VudDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0W2tleV0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uL21hdGgvY29uc3QnKTtcclxudmFyIFdyYXBBbmdsZSA9IHJlcXVpcmUoJy4uL21hdGgvYW5nbGUvV3JhcCcpO1xyXG5cclxuLyoqXHJcbiogMkQgVHJhbnNmb3JtYXRpb24gQ29tcG9uZW50LlxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcbnZhciBUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgeCwgeSwgc2NhbGVYLCBzY2FsZVkpXHJcbntcclxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cclxuICAgIGlmIChzY2FsZVggPT09IHVuZGVmaW5lZCkgeyBzY2FsZVggPSAxOyB9XHJcbiAgICBpZiAoc2NhbGVZID09PSB1bmRlZmluZWQpIHsgc2NhbGVZID0gMTsgfVxyXG5cclxuICAgIHRoaXMuZ2FtZU9iamVjdCA9IGdhbWVPYmplY3Q7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IChnYW1lT2JqZWN0LnN0YXRlKSA/IGdhbWVPYmplY3Quc3RhdGUgOiBnYW1lT2JqZWN0LnBhcmVudC5zdGF0ZTtcclxuXHJcbiAgICB0aGlzLmdhbWUgPSB0aGlzLnN0YXRlLmdhbWU7XHJcblxyXG4gICAgLy8gIGEgPSBzY2FsZSBYXHJcbiAgICAvLyAgYiA9IHNoZWFyIFlcclxuICAgIC8vICBjID0gc2hlYXIgWFxyXG4gICAgLy8gIGQgPSBzY2FsZSBZXHJcbiAgICAvLyAgdHggLyB0eSA9IHRyYW5zbGF0aW9uXHJcblxyXG4gICAgLy8gIFdvcmxkIFRyYW5zZm9ybVxyXG4gICAgdGhpcy53b3JsZCA9IHsgYTogc2NhbGVYLCBiOiAwLCBjOiAwLCBkOiBzY2FsZVksIHR4OiB4LCB0eTogeSB9O1xyXG5cclxuICAgIC8vICBQcmV2aW91cyBUcmFuc2Zvcm0gKHVzZWQgZm9yIGludGVycG9sYXRpb24pXHJcbiAgICB0aGlzLm9sZCA9IHsgYTogc2NhbGVYLCBiOiAwLCBjOiAwLCBkOiBzY2FsZVksIHR4OiB4LCB0eTogeSB9O1xyXG5cclxuICAgIC8vICBDYWNoZWQgVHJhbnNmb3JtIENhbGN1bGF0aW9uc1xyXG4gICAgdGhpcy5jYWNoZSA9IHsgYTogMSwgYjogMCwgYzogMCwgZDogMSwgc3I6IDAsIGNyOiAwIH07XHJcblxyXG4gICAgLy8gIEdMIFZlcnRleCBEYXRhXHJcbiAgICB0aGlzLmdsVmVydGV4dERhdGEgPSB7IHgwOiAwLCB5MDogMCwgeDE6IDAsIHkxOiAwLCB4MjogMCwgeTI6IDAsIHgzOiAwLCB5MzogMCB9O1xyXG5cclxuICAgIC8vICBDYW52YXMgU2V0VHJhbnNmb3JtIGRhdGFcclxuICAgIHRoaXMuY2FudmFzRGF0YSA9IHsgYTogMSwgYjogMCwgYzogMCwgZDogMSwgdHg6IDAsIHR5OiAwLCBkeDogMCwgZHk6IDAgfTtcclxuXHJcbiAgICB0aGlzLmltbWVkaWF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuaW50ZXJwb2xhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmhhc0xvY2FsUm90YXRpb24gPSBmYWxzZTtcclxuXHJcbiAgICAvLyAgUHJpdmF0ZSB2YWx1ZSBob2xkZXJzLCBhY2Nlc3NlZCB2aWEgdGhlIGdldHRlcnMgYW5kIHNldHRlcnNcclxuICAgIHRoaXMuX3Bvc1ggPSB4O1xyXG4gICAgdGhpcy5fcG9zWSA9IHk7XHJcbiAgICB0aGlzLl9zY2FsZVggPSBzY2FsZVg7XHJcbiAgICB0aGlzLl9zY2FsZVkgPSBzY2FsZVk7XHJcbiAgICB0aGlzLl9yb3RhdGlvbiA9IDA7XHJcbiAgICB0aGlzLl9waXZvdFggPSAwO1xyXG4gICAgdGhpcy5fcGl2b3RZID0gMDtcclxuICAgIHRoaXMuX2FuY2hvclggPSAwO1xyXG4gICAgdGhpcy5fYW5jaG9yWSA9IDA7XHJcblxyXG4gICAgdGhpcy5fd29ybGRSb3RhdGlvbiA9IDA7XHJcbiAgICB0aGlzLl93b3JsZFNjYWxlWCA9IHNjYWxlWDtcclxuICAgIHRoaXMuX3dvcmxkU2NhbGVZID0gc2NhbGVZO1xyXG5cclxuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgIHRoaXMuX2RpcnR5VmVydGV4ID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnN0YXRlLnN5cy51cGRhdGVzLmFkZCh0aGlzKTtcclxuXHJcbiAgICAvLyAgVGhlIHBhcmVudCBUcmFuc2Zvcm0gKE5PVCB0aGUgcGFyZW50IEdhbWVPYmplY3QsIGFsdGhvdWdoIHZlcnkgb2Z0ZW4gdGhleSBhcmUgcmVsYXRlZClcclxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAvLyAgQW55IGNoaWxkIFRyYW5zZm9ybXMgb2YgdGhpcyBvbmUgLSBub3RlIHRoYXQgdGhleSBkb24ndCBoYXZlIHRvIGJlbG9uZyB0byBHYW1lIE9iamVjdHNcclxuICAgIC8vICB0aGF0IGFyZSBjaGlsZHJlbiBvZiB0aGUgb3duZXIgb2YgdGhpcyBUcmFuc2Zvcm1cclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxufTtcclxuXHJcblRyYW5zZm9ybS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmFuc2Zvcm07XHJcblxyXG5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZEF0KGNoaWxkLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEF0OiBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBJbnZhbGlkIGNoaWxkP1xyXG4gICAgICAgIGlmIChjaGlsZCA9PT0gdGhpcyB8fCBjaGlsZC5wYXJlbnQgPT09IHRoaXMgfHwgaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBjaGlsZCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQ2hpbGQgYWxyZWFkeSBwYXJlbnRlZD8gUmVtb3ZlIGl0XHJcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlQW5jZXN0b3JzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEludmFsaWQgY2hpbGQ/XHJcbiAgICAgICAgaWYgKGNoaWxkID09PSB0aGlzIHx8IGNoaWxkLnBhcmVudCAhPT0gdGhpcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBdChpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVBdDogZnVuY3Rpb24gKGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBWYWxpZCBpbmRleD9cclxuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoaWxkWzBdKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZFswXS5wYXJlbnQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZW5hYmxlSW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmludGVycG9sYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5zeW5jSW50ZXJwb2xhdGlvbigpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzeW5jSW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG4gICAgICAgIHZhciBvbGQgPSB0aGlzLm9sZDtcclxuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xyXG5cclxuICAgICAgICBvbGQuYSA9IHdvcmxkLmE7XHJcbiAgICAgICAgb2xkLmIgPSB3b3JsZC5iO1xyXG4gICAgICAgIG9sZC5jID0gd29ybGQuYztcclxuICAgICAgICBvbGQuZCA9IHdvcmxkLmQ7XHJcbiAgICAgICAgb2xkLnR4ID0gd29ybGQudHg7XHJcbiAgICAgICAgb2xkLnR5ID0gd29ybGQudHk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc2FibGVJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGUgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy5fcG9zWCA9IHg7XHJcbiAgICAgICAgdGhpcy5fcG9zWSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTY2FsZTogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLl9zY2FsZVggPSB4O1xyXG4gICAgICAgIHRoaXMuX3NjYWxlWSA9IHk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UGl2b3Q6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy5fcGl2b3RYID0geDtcclxuICAgICAgICB0aGlzLl9waXZvdFkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0QW5jaG9yOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMuX2FuY2hvclggPSB4O1xyXG4gICAgICAgIHRoaXMuX2FuY2hvclkgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Um90YXRpb246IGZ1bmN0aW9uIChyb3RhdGlvbilcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgVXBkYXRlcyB0aGUgVHJhbnNmb3JtLndvcmxkIG9iamVjdCwgcmVhZHkgZm9yIHJlbmRlcmluZ1xyXG4gICAgLy8gIEFzc3VtaW5nIHRoaXMgVHJhbnNmb3JtIGlzIGEgcm9vdCBub2RlIChpLmUuIG5vIHRyYW5zZm9ybSBwYXJlbnQpXHJcbiAgICB1cGRhdGVGcm9tUm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgb2xkID0gdGhpcy5vbGQ7XHJcbiAgICAgICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcclxuXHJcbiAgICAgICAgb2xkLmEgPSB3b3JsZC5hO1xyXG4gICAgICAgIG9sZC5iID0gd29ybGQuYjtcclxuICAgICAgICBvbGQuYyA9IHdvcmxkLmM7XHJcbiAgICAgICAgb2xkLmQgPSB3b3JsZC5kO1xyXG4gICAgICAgIG9sZC50eCA9IHdvcmxkLnR4O1xyXG4gICAgICAgIG9sZC50eSA9IHdvcmxkLnR5O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oYXNMb2NhbFJvdGF0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5uYW1lLCAnVHJhbnNmb3JtLnVwZGF0ZUZyb21Sb290Jyk7XHJcblxyXG4gICAgICAgICAgICB3b3JsZC5hID0gdGhpcy5jYWNoZS5hO1xyXG4gICAgICAgICAgICB3b3JsZC5iID0gdGhpcy5jYWNoZS5iO1xyXG4gICAgICAgICAgICB3b3JsZC5jID0gdGhpcy5jYWNoZS5jO1xyXG4gICAgICAgICAgICB3b3JsZC5kID0gdGhpcy5jYWNoZS5kO1xyXG4gICAgICAgICAgICB3b3JsZC50eCA9IHRoaXMuX3Bvc1ggLSAoKHRoaXMuX3Bpdm90WCAqIHRoaXMuY2FjaGUuYSkgKyAodGhpcy5fcGl2b3RZICogdGhpcy5jYWNoZS5jKSk7XHJcbiAgICAgICAgICAgIHdvcmxkLnR5ID0gdGhpcy5fcG9zWSAtICgodGhpcy5fcGl2b3RYICogdGhpcy5jYWNoZS5iKSArICh0aGlzLl9waXZvdFkgKiB0aGlzLmNhY2hlLmQpKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkUm90YXRpb24gPSBNYXRoLmF0YW4yKC10aGlzLmNhY2hlLmMsIHRoaXMuY2FjaGUuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ1RyYW5zZm9ybS51cGRhdGVGcm9tUm9vdCBGQVNUJyk7XHJcblxyXG4gICAgICAgICAgICB3b3JsZC5hID0gdGhpcy5fc2NhbGVYO1xyXG4gICAgICAgICAgICB3b3JsZC5iID0gMDtcclxuICAgICAgICAgICAgd29ybGQuYyA9IDA7XHJcbiAgICAgICAgICAgIHdvcmxkLmQgPSB0aGlzLl9zY2FsZVk7XHJcbiAgICAgICAgICAgIHdvcmxkLnR4ID0gdGhpcy5fcG9zWCAtICh0aGlzLl9waXZvdFggKiB0aGlzLl9zY2FsZVgpO1xyXG4gICAgICAgICAgICB3b3JsZC50eSA9IHRoaXMuX3Bvc1kgLSAodGhpcy5fcGl2b3RZICogdGhpcy5fc2NhbGVZKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkUm90YXRpb24gPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fd29ybGRTY2FsZVggPSB0aGlzLl9zY2FsZVg7XHJcbiAgICAgICAgdGhpcy5fd29ybGRTY2FsZVkgPSB0aGlzLl9zY2FsZVk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVGcm9tUGFyZW50OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvbGQgPSB0aGlzLm9sZDtcclxuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xyXG5cclxuICAgICAgICBvbGQuYSA9IHdvcmxkLmE7XHJcbiAgICAgICAgb2xkLmIgPSB3b3JsZC5iO1xyXG4gICAgICAgIG9sZC5jID0gd29ybGQuYztcclxuICAgICAgICBvbGQuZCA9IHdvcmxkLmQ7XHJcbiAgICAgICAgb2xkLnR4ID0gd29ybGQudHg7XHJcbiAgICAgICAgb2xkLnR5ID0gd29ybGQudHk7XHJcblxyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudC53b3JsZDtcclxuICAgICAgICB2YXIgdHggPSAwO1xyXG4gICAgICAgIHZhciB0eSA9IDA7XHJcbiAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgdmFyIGI7XHJcbiAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgdmFyIGQ7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhhc0xvY2FsUm90YXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdUcmFuc2Zvcm0udXBkYXRlRnJvbVBhcmVudCcsIHRoaXMucGFyZW50Lm5hbWUpO1xyXG5cclxuICAgICAgICAgICAgYSA9IHRoaXMuY2FjaGUuYTtcclxuICAgICAgICAgICAgYiA9IHRoaXMuY2FjaGUuYjtcclxuICAgICAgICAgICAgYyA9IHRoaXMuY2FjaGUuYztcclxuICAgICAgICAgICAgZCA9IHRoaXMuY2FjaGUuZDtcclxuXHJcbiAgICAgICAgICAgIHR4ID0gdGhpcy5fcG9zWCAtICgodGhpcy5fcGl2b3RYICogYSkgKyAodGhpcy5fcGl2b3RZICogYykpO1xyXG4gICAgICAgICAgICB0eSA9IHRoaXMuX3Bvc1kgLSAoKHRoaXMuX3Bpdm90WCAqIGIpICsgKHRoaXMuX3Bpdm90WSAqIGQpKTtcclxuXHJcbiAgICAgICAgICAgIHdvcmxkLmEgPSAoYSAqIHBhcmVudC5hKSArIChiICogcGFyZW50LmMpO1xyXG4gICAgICAgICAgICB3b3JsZC5iID0gKGEgKiBwYXJlbnQuYikgKyAoYiAqIHBhcmVudC5kKTtcclxuICAgICAgICAgICAgd29ybGQuYyA9IChjICogcGFyZW50LmEpICsgKGQgKiBwYXJlbnQuYyk7XHJcbiAgICAgICAgICAgIHdvcmxkLmQgPSAoYyAqIHBhcmVudC5iKSArIChkICogcGFyZW50LmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdUcmFuc2Zvcm0udXBkYXRlRnJvbVBhcmVudCBGQVNUJywgdGhpcy5wYXJlbnQubmFtZSk7XHJcblxyXG4gICAgICAgICAgICB0eCA9IHRoaXMuX3Bvc1ggLSAodGhpcy5fcGl2b3RYICogdGhpcy5fc2NhbGVYKTtcclxuICAgICAgICAgICAgdHkgPSB0aGlzLl9wb3NZIC0gKHRoaXMuX3Bpdm90WSAqIHRoaXMuX3NjYWxlWSk7XHJcblxyXG4gICAgICAgICAgICB3b3JsZC5hID0gdGhpcy5fc2NhbGVYICogcGFyZW50LmE7XHJcbiAgICAgICAgICAgIHdvcmxkLmIgPSB0aGlzLl9zY2FsZVggKiBwYXJlbnQuYjtcclxuICAgICAgICAgICAgd29ybGQuYyA9IHRoaXMuX3NjYWxlWSAqIHBhcmVudC5jO1xyXG4gICAgICAgICAgICB3b3JsZC5kID0gdGhpcy5fc2NhbGVZICogcGFyZW50LmQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0aGlzLl93b3JsZFJvdGF0aW9uID0gTWF0aC5hdGFuMigtdGhpcy53b3JsZC5jLCB0aGlzLndvcmxkLmQpO1xyXG5cclxuICAgICAgICB3b3JsZC50eCA9ICh0eCAqIHBhcmVudC5hKSArICh0eSAqIHBhcmVudC5jKSArIHBhcmVudC50eDtcclxuICAgICAgICB3b3JsZC50eSA9ICh0eCAqIHBhcmVudC5iKSArICh0eSAqIHBhcmVudC5kKSArIHBhcmVudC50eTtcclxuXHJcbiAgICAgICAgYSA9IHdvcmxkLmE7XHJcbiAgICAgICAgYiA9IHdvcmxkLmI7XHJcbiAgICAgICAgYyA9IHdvcmxkLmM7XHJcbiAgICAgICAgZCA9IHdvcmxkLmQ7XHJcblxyXG4gICAgICAgIHZhciBkZXRlcm0gPSAoYSAqIGQpIC0gKGIgKiBjKTtcclxuXHJcbiAgICAgICAgaWYgKGEgfHwgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5zcXJ0KChhICogYSkgKyAoYiAqIGIpKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkUm90YXRpb24gPSAoYiA+IDApID8gTWF0aC5hY29zKGEgLyByKSA6IC1NYXRoLmFjb3MoYSAvIHIpO1xyXG4gICAgICAgICAgICB0aGlzLl93b3JsZFNjYWxlWCA9IHI7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkU2NhbGVZID0gZGV0ZXJtIC8gcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyB8fCBkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoKGMgKiBjKSArIChkICogZCkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fd29ybGRSb3RhdGlvbiA9IE1BVEhfQ09OU1QuVEFVIC0gKChkID4gMCkgPyBNYXRoLmFjb3MoLWMgLyBzKSA6IC1NYXRoLmFjb3MoYyAvIHMpKTtcclxuICAgICAgICAgICAgdGhpcy5fd29ybGRTY2FsZVggPSBkZXRlcm0gLyBzO1xyXG4gICAgICAgICAgICB0aGlzLl93b3JsZFNjYWxlWSA9IHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkU2NhbGVYID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fd29ybGRTY2FsZVkgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUFuY2VzdG9yczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdUcmFuc2Zvcm0udXBkYXRlQW5jZXN0b3JzJyk7XHJcblxyXG4gICAgICAgIC8vICBObyBwYXJlbnQ/IFRoZW4ganVzdCB1cGRhdGUgdGhlIGNoaWxkcmVuIGFuZCBsZWF2ZSwgb3VyIGpvYiBpcyBkb25lXHJcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ3VwZGF0ZUFuY2VzdG9ycyBoYXMgbm8gcGFyZW50IFRyYW5zZm9ybScpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tUm9vdCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdzdGFydCB1cGRhdGVBbmNlc3RvcnMgd2hpbGUnKTtcclxuXHJcbiAgICAgICAgLy8gIEdldHMgYWxsIHBhcmVudCBub2Rlcywgc3RhcnRpbmcgZnJvbSB0aGlzIFRyYW5zZm9ybS5cclxuICAgICAgICAvLyAgVGhlbiB1cGRhdGVzIGZyb20gdGhlIHRvcCwgZG93biwgYnV0IG9ubHkgb24gdGhlIGFuY2VzdG9ycyxcclxuICAgICAgICAvLyAgbm90IGFueSBvdGhlciBjaGlsZHJlbiAtIHdpbGwgZ2l2ZSB1cyBhY2N1cmF0ZSB3b3JsZFggZXRjIHByb3BlcnRpZXNcclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZG9cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpO1xyXG5cclxuICAgICAgICAvLyAgV2UndmUgZ290IGFsbCB0aGUgYW5jZXN0b3JzIGluIHRoZSAnbm9kZXMnIGFycmF5LCBsZXQncyBsb29wIGl0XHJcblxyXG4gICAgICAgIHdoaWxlIChub2Rlcy5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZXMucG9wKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlRnJvbVBhcmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVGcm9tUm9vdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQnkgdGhpcyBwb2ludCBhbGwgb2YgdGhpcyBUcmFuc2Zvcm1zIGFuY2VzdG9ycyBoYXZlIGJlZW5cclxuICAgICAgICAvLyAgdXBkYXRlZCwgaW4gdGhlIGNvcnJlY3Qgb3JkZXIsIHNvIHdlIGNhbiBub3cgZG8gdGhpcyBvbmVcclxuICAgICAgICAvLyAgYW5kIGFueSBvZiBpdHMgY2hpbGRyZW4gdG9vXHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ1RyYW5zZm9ybS51cGRhdGVDaGlsZHJlbicpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlRnJvbURpcnR5UGFyZW50OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ2lzIHVwZGF0ZUZyb21EaXJ0eVBhcmVudCcsIHRoaXMucGFyZW50Lm5hbWUpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZUZyb21QYXJlbnQoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZUZyb21EaXJ0eVBhcmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5VmVydGV4ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGlydHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgSWYgd2UgZ290IHRoaXMgZmFyIHRoZW4gdGhpcyBUcmFuc2Zvcm0gaXMgZGlydHlcclxuICAgICAgICAvLyAgc28gd2UgbmVlZCB0byB1cGRhdGUgaXQgZnJvbSBpdHMgcGFyZW50XHJcbiAgICAgICAgLy8gIGFuZCB0aGVuIGZvcmNlIHRoZSB1cGRhdGUgdG8gYWxsIGNoaWxkcmVuXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbVBhcmVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZyb21Sb290KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChsZW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZUZyb21EaXJ0eVBhcmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5VmVydGV4ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlQ2FjaGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jYWNoZS5hID0gdGhpcy5jYWNoZS5jciAqIHRoaXMuX3NjYWxlWDtcclxuICAgICAgICB0aGlzLmNhY2hlLmIgPSB0aGlzLmNhY2hlLnNyICogdGhpcy5fc2NhbGVYO1xyXG4gICAgICAgIHRoaXMuY2FjaGUuYyA9IC10aGlzLmNhY2hlLnNyICogdGhpcy5fc2NhbGVZO1xyXG4gICAgICAgIHRoaXMuY2FjaGUuZCA9IHRoaXMuY2FjaGUuY3IgKiB0aGlzLl9zY2FsZVk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVZlcnRleERhdGE6IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgcmVuZGVyZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmdhbWVPYmplY3QuZnJhbWUgfHwgKCF0aGlzLl9kaXJ0eVZlcnRleCAmJiAhdGhpcy5pbnRlcnBvbGF0ZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmdhbWVPYmplY3QuZnJhbWU7XHJcblxyXG4gICAgICAgIHZhciB3MDtcclxuICAgICAgICB2YXIgaDA7XHJcbiAgICAgICAgdmFyIHcxO1xyXG4gICAgICAgIHZhciBoMTtcclxuXHJcbiAgICAgICAgaWYgKGZyYW1lLmRhdGEudHJpbSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBJZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWQsIGFkZCB0aGUgZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZ1xyXG4gICAgICAgICAgICB3MSA9IGZyYW1lLnggLSAodGhpcy5fYW5jaG9yWCAqIGZyYW1lLndpZHRoKTtcclxuICAgICAgICAgICAgdzAgPSB3MSArIGZyYW1lLmN1dFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgaDEgPSBmcmFtZS55IC0gKHRoaXMuX2FuY2hvclkgKiBmcmFtZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICBoMCA9IGgxICsgZnJhbWUuY3V0SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3MCA9IGZyYW1lLmN1dFdpZHRoICogKDEgLSB0aGlzLl9hbmNob3JYKTtcclxuICAgICAgICAgICAgdzEgPSBmcmFtZS5jdXRXaWR0aCAqIC10aGlzLl9hbmNob3JYO1xyXG5cclxuICAgICAgICAgICAgaDAgPSBmcmFtZS5jdXRIZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvclkpO1xyXG4gICAgICAgICAgICBoMSA9IGZyYW1lLmN1dEhlaWdodCAqIC10aGlzLl9hbmNob3JZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBmcmFtZS5zb3VyY2UucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgdmFyIHd0ID0gdGhpcy53b3JsZDtcclxuXHJcbiAgICAgICAgdmFyIGEgPSB3dC5hIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgYiA9IHd0LmIgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciBjID0gd3QuYyAvIHJlc29sdXRpb247XHJcbiAgICAgICAgdmFyIGQgPSB3dC5kIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgdHggPSB3dC50eDtcclxuICAgICAgICB2YXIgdHkgPSB3dC50eTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgb2xkID0gdGhpcy5vbGQ7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnRlcnBvbGF0ZSB3aXRoIHRoZSBsYXN0IHBvc2l0aW9uIHRvIHJlZHVjZSBzdHV0dGVyaW5nLlxyXG4gICAgICAgICAgICBhID0gb2xkLmEgKyAoKGEgLSBvbGQuYSkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIGIgPSBvbGQuYiArICgoYiAtIG9sZC5iKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcclxuICAgICAgICAgICAgYyA9IG9sZC5jICsgKChjIC0gb2xkLmMpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICBkID0gb2xkLmQgKyAoKGQgLSBvbGQuZCkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIHR4ID0gb2xkLnR4ICsgKCh0eCAtIG9sZC50eCkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIHR5ID0gb2xkLnR5ICsgKCh0eSAtIG9sZC50eSkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZnJhbWUucm90YXRlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIHZhciBjdyA9IGZyYW1lLmN1dFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgY2ggPSBmcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBhMCA9IGE7XHJcbiAgICAgICAgICAgIHZhciBiMCA9IGI7XHJcbiAgICAgICAgICAgIHZhciBjMCA9IGM7XHJcbiAgICAgICAgICAgIHZhciBkMCA9IGQ7XHJcbiAgICAgICAgICAgIHZhciBfdzEgPSB3MTtcclxuICAgICAgICAgICAgdmFyIF93MCA9IHcwO1xyXG5cclxuICAgICAgICAgICAgLy8gIE9mZnNldCBiZWZvcmUgcm90YXRpbmdcclxuICAgICAgICAgICAgdHggPSAod3QuYyAqIGNoKSArIHR4O1xyXG4gICAgICAgICAgICB0eSA9ICh3dC5kICogY2gpICsgdHk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyAgUm90YXRlIG1hdHJpeCBieSA5MCBkZWdyZWVzIHdpdGggcHJlY2FsYyB2YWx1ZXMgZm9yIHNpbmUgYW5kIGNvc2luZSBvZiByYWQoOTApXHJcbiAgICAgICAgICAgIGEgPSAoYTAgKiA2LjEyMzIzMzk5NTczNjc2NmUtMTcpICsgLWMwO1xyXG4gICAgICAgICAgICBiID0gKGIwICogNi4xMjMyMzM5OTU3MzY3NjZlLTE3KSArIC1kMDtcclxuICAgICAgICAgICAgYyA9IGEwICsgKGMwICogNi4xMjMyMzM5OTU3MzY3NjZlLTE3KTtcclxuICAgICAgICAgICAgZCA9IGIwICsgKGQwICogNi4xMjMyMzM5OTU3MzY3NjZlLTE3KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBVViBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICBmcmFtZS51cGRhdGVVVnNJbnZlcnRlZCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUm90YXRlIGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgdzAgPSBoMDtcclxuICAgICAgICAgICAgdzEgPSBoMTtcclxuICAgICAgICAgICAgaDAgPSBfdzA7XHJcbiAgICAgICAgICAgIGgxID0gX3cxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZyYW1lLmF1dG9Sb3VuZCA9PT0gMSB8fCAoZnJhbWUuYXV0b1JvdW5kID09PSAtMSAmJiByZW5kZXJlci5yb3VuZFBpeGVscykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0eCB8PSAwO1xyXG4gICAgICAgICAgICB0eSB8PSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHZlcnQgPSB0aGlzLmdsVmVydGV4dERhdGE7XHJcblxyXG4gICAgICAgIC8vICBUb3AgTGVmdCBWZXJ0XHJcbiAgICAgICAgLy8gdmVydC54MCA9IChhICogdzEpICsgKGMgKiBoMSkgKyB0eDtcclxuICAgICAgICAvLyB2ZXJ0LnkwID0gKGQgKiBoMSkgKyAoYiAqIHcxKSArIHR5O1xyXG5cclxuICAgICAgICAvLyAgVG9wIFJpZ2h0IFZlcnRcclxuICAgICAgICAvLyB2ZXJ0LngxID0gKGEgKiB3MCkgKyAoYyAqIGgxKSArIHR4O1xyXG4gICAgICAgIC8vIHZlcnQueTEgPSAoZCAqIGgxKSArIChiICogdzApICsgdHk7XHJcblxyXG4gICAgICAgIC8vICBCb3R0b20gUmlnaHQgVmVydFxyXG4gICAgICAgIC8vIHZlcnQueDIgPSAoYSAqIHcwKSArIChjICogaDApICsgdHg7XHJcbiAgICAgICAgLy8gdmVydC55MiA9IChkICogaDApICsgKGIgKiB3MCkgKyB0eTtcclxuXHJcbiAgICAgICAgLy8gIEJvdHRvbSBMZWZ0IFZlcnRcclxuICAgICAgICAvLyB2ZXJ0LngzID0gKGEgKiB3MSkgKyAoYyAqIGgwKSArIHR4O1xyXG4gICAgICAgIC8vIHZlcnQueTMgPSAoZCAqIGgwKSArIChiICogdzEpICsgdHk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHZlcnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFZlcnRleERhdGE6IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgcmVuZGVyZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGUgfHwgdGhpcy5fZGlydHlWZXJ0ZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZlcnRleERhdGEoaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIHJlbmRlcmVyKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5VmVydGV4ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5nbFZlcnRleHREYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZVZlcnRleERhdGE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHNyYyA9IHRoaXMuZ2xWZXJ0ZXh0RGF0YTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDA6IHNyYy54MCxcclxuICAgICAgICAgICAgeTA6IHNyYy55MCxcclxuICAgICAgICAgICAgeDE6IHNyYy54MSxcclxuICAgICAgICAgICAgeTE6IHNyYy55MSxcclxuICAgICAgICAgICAgeDI6IHNyYy54MixcclxuICAgICAgICAgICAgeTI6IHNyYy55MixcclxuICAgICAgICAgICAgeDM6IHNyYy54MyxcclxuICAgICAgICAgICAgeTM6IHNyYy55M1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldENhbnZhc1RyYW5zZm9ybURhdGE6IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgcmVuZGVyZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5nYW1lT2JqZWN0LmZyYW1lO1xyXG5cclxuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5jYW52YXNEYXRhO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pbnRlcnBvbGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBvbGQgPSB0aGlzLm9sZDtcclxuXHJcbiAgICAgICAgICAgIC8vIEludGVycG9sYXRlIHdpdGggdGhlIGxhc3QgcG9zaXRpb24gdG8gcmVkdWNlIHN0dXR0ZXJpbmcuXHJcbiAgICAgICAgICAgIGRhdGEuYSA9IG9sZC5hICsgKCh3b3JsZC5hIC0gb2xkLmEpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICBkYXRhLmIgPSBvbGQuYiArICgod29ybGQuYiAtIG9sZC5iKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcclxuICAgICAgICAgICAgZGF0YS5jID0gb2xkLmMgKyAoKHdvcmxkLmMgLSBvbGQuYykgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIGRhdGEuZCA9IG9sZC5kICsgKCh3b3JsZC5kIC0gb2xkLmQpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICBkYXRhLnR4ID0gb2xkLnR4ICsgKCh3b3JsZC50eCAtIG9sZC50eCkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIGRhdGEudHkgPSBvbGQudHkgKyAoKHdvcmxkLnR5IC0gb2xkLnR5KSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcclxuICAgICAgICAgICAgZGF0YS5keCA9IG9sZC5keCArICgoZnJhbWUueCAtICh0aGlzLmFuY2hvclggKiBmcmFtZS53aWR0aCkpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICBkYXRhLmR5ID0gb2xkLmR5ICsgKChmcmFtZS55IC0gKHRoaXMuYW5jaG9yWSAqIGZyYW1lLmhlaWdodCkpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQ29weSBvdmVyIHRoZSB2YWx1ZXMgdG8gdGhlIGNhbnZhc0RhdGEgb2JqZWN0LCBpbiBjYXNlIHRoZSByZW5kZXJlciBuZWVkcyB0byBhZGp1c3QgdGhlbVxyXG4gICAgICAgICAgICBkYXRhLmEgPSB3b3JsZC5hO1xyXG4gICAgICAgICAgICBkYXRhLmIgPSB3b3JsZC5iO1xyXG4gICAgICAgICAgICBkYXRhLmMgPSB3b3JsZC5jO1xyXG4gICAgICAgICAgICBkYXRhLmQgPSB3b3JsZC5kO1xyXG4gICAgICAgICAgICBkYXRhLnR4ID0gd29ybGQudHg7XHJcbiAgICAgICAgICAgIGRhdGEudHkgPSB3b3JsZC50eTtcclxuICAgICAgICAgICAgZGF0YS5keCA9IGZyYW1lLnggLSAodGhpcy5hbmNob3JYICogZnJhbWUud2lkdGgpO1xyXG4gICAgICAgICAgICBkYXRhLmR5ID0gZnJhbWUueSAtICh0aGlzLmFuY2hvclkgKiBmcmFtZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZyYW1lLmF1dG9Sb3VuZCA9PT0gMSB8fCAoZnJhbWUuYXV0b1JvdW5kID09PSAtMSAmJiByZW5kZXJlci5yb3VuZFBpeGVscykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkYXRhLnR4IHw9IDA7XHJcbiAgICAgICAgICAgIGRhdGEudHkgfD0gMDtcclxuICAgICAgICAgICAgZGF0YS5keCB8PSAwO1xyXG4gICAgICAgICAgICBkYXRhLmR5IHw9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm0ucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLy8gIFRyYW5zZm9ybSBnZXR0ZXJzIC8gc2V0dGVyc1xyXG5cclxuICAgIHg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc1g7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3NYID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc1k7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3NZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZVggPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc2NhbGVZID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlWDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc2NhbGVYID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlWToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc2NhbGVZID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFuY2hvcjoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yWDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QW5jaG9yKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmNob3JYOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5jaG9yWCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmNob3JZOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5jaG9yWSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwaXZvdFg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90WCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBpdm90WToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fcGl2b3RZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYW5nbGU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFdyYXBBbmdsZSh0aGlzLnJvdGF0aW9uICogTUFUSF9DT05TVC5SQURfVE9fREVHKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSBXcmFwQW5nbGUodmFsdWUpICogTUFUSF9DT05TVC5ERUdfVE9fUkFEO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0aW9uOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3RhdGlvbiA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fcm90YXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm90YXRpb24gJSBNQVRIX0NPTlNULlBJMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5zciA9IE1hdGguc2luKHRoaXMuX3JvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuY3IgPSBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0xvY2FsUm90YXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNMb2NhbFJvdGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU2V0cyB0aGlzICpjb21wb25lbnQqIGFzIGJlaW5nIGRpcnR5XHJcbiAgICBkaXJ0eToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlydHk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbW1lZGlhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eVZlcnRleCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3lzLnVwZGF0ZXMuYWRkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgR0xPQkFMIHJlYWQtb25seSBwcm9wZXJ0aWVzIGZyb20gaGVyZSBvblxyXG4gICAgLy8gIE5lZWQgKmFsbCogcGFyZW50cyB0YWtlbiBpbnRvIGFjY291bnQgdG8gZ2V0IHRoZSBjb3JyZWN0IHZhbHVlc1xyXG5cclxuICAgIG5hbWU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmdhbWVPYmplY3QpID8gdGhpcy5nYW1lT2JqZWN0Lm5hbWUgOiAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB3b3JsZFJvdGF0aW9uOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5jZXN0b3JzKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRSb3RhdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB3b3JsZFNjYWxlWDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuY2VzdG9ycygpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmxkU2NhbGVYO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHdvcmxkU2NhbGVZOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5jZXN0b3JzKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRTY2FsZVk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgd29ybGRYOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5jZXN0b3JzKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53b3JsZC50eDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB3b3JsZFk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVBbmNlc3RvcnMoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndvcmxkLnR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL1RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9UcmFuc2Zvcm0uanMiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcblxyXG52YXIgQXVkaW8gPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXVkaW9EYXRhIC0gQXJlIEF1ZGlvIHRhZ3MgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGF1ZGlvRGF0YTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2ViQXVkaW8gLSBJcyB0aGUgV2ViQXVkaW8gQVBJIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJBdWRpbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2dnIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgb2dnIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG9nZzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B1cyAtIENhbiB0aGlzIGRldmljZSBwbGF5IG9wdXMgZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgb3B1czogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXAzIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgbXAzIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG1wMzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2F2IC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgd2F2IGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdhdjogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENhbiB0aGlzIGRldmljZSBwbGF5IG00YSBmaWxlcz9cclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtNGEgLSBUcnVlIGlmIHRoaXMgZGV2aWNlIGNhbiBwbGF5IG00YSBmaWxlcy5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtNGE6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlYm0gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSB3ZWJtIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdlYm06IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGRvbGJ5IC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgRUMtMyBEb2xieSBEaWdpdGFsIFBsdXMgZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZG9sYnk6IGZhbHNlXHJcblxyXG59O1xyXG5cclxuZnVuY3Rpb24gaW5pdCAoKVxyXG57XHJcbiAgICBBdWRpby5hdWRpb0RhdGEgPSAhISh3aW5kb3dbJ0F1ZGlvJ10pO1xyXG4gICAgQXVkaW8ud2ViQXVkaW8gPSAhISh3aW5kb3dbJ0F1ZGlvQ29udGV4dCddIHx8IHdpbmRvd1snd2Via2l0QXVkaW9Db250ZXh0J10pO1xyXG5cclxuICAgIHZhciBhdWRpb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSAhIWF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZTtcclxuXHJcbiAgICB0cnlcclxuICAgIHtcclxuICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF1ZGlvLm9nZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwib3B1c1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSB8fCBhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL29wdXM7JykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXVkaW8ub3B1cyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWc7JykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXVkaW8ubXAzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIE1pbWV0eXBlcyBhY2NlcHRlZDpcclxuICAgICAgICAgICAgLy8gIGRldmVsb3Blci5tb3ppbGxhLm9yZy9Fbi9NZWRpYV9mb3JtYXRzX3N1cHBvcnRlZF9ieV90aGVfYXVkaW9fYW5kX3ZpZGVvX2VsZW1lbnRzXHJcbiAgICAgICAgICAgIC8vICBiaXQubHkvaXBob25lb3Njb2RlY3NcclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vd2F2OyBjb2RlY3M9XCIxXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdWRpby53YXYgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby94LW00YTsnKSB8fCBhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdWRpby5tNGEgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF1ZGlvLndlYm0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9tcDQ7Y29kZWNzPVwiZWMtM1wiJykgIT09ICcnKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQnJvd3Nlci5lZGdlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEF1ZGlvLmRvbGJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJyb3dzZXIuc2FmYXJpICYmIEJyb3dzZXIuc2FmYXJpVmVyc2lvbiA+PSA5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoL01hYyBPUyBYIChcXGQrKV8oXFxkKykvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ham9yID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5vciA9IHBhcnNlSW50KFJlZ0V4cC4kMiwgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYWpvciA9PT0gMTAgJiYgbWlub3IgPj0gMTEpIHx8IG1ham9yID4gMTApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1ZGlvLmRvbGJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBOb3RoaW5nIHRvIGRvIGhlcmVcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQXVkaW87XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvQXVkaW8uanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9BdWRpby5qcyIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcclxudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcclxuXHJcbnZhciBGdWxsc2NyZWVuID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGF2YWlsYWJsZSAtIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCB0aGUgRnVsbCBTY3JlZW4gQVBJP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGF2YWlsYWJsZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXF1ZXN0IC0gSWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEZ1bGwgU2NyZWVuIEFQSSB0aGlzIGhvbGRzIHRoZSBjYWxsIHlvdSBuZWVkIHRvIHVzZSB0byBhY3RpdmF0ZSBpdC5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICByZXF1ZXN0OiAnJyxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNhbmNlbCAtIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBGdWxsIFNjcmVlbiBBUEkgdGhpcyBob2xkcyB0aGUgY2FsbCB5b3UgbmVlZCB0byB1c2UgdG8gY2FuY2VsIGl0LlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNhbmNlbDogJycsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0ga2V5Ym9hcmQgLSBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgYWNjZXNzIHRvIHRoZSBLZXlib2FyZCBkdXJpbmcgRnVsbCBTY3JlZW4gbW9kZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBrZXlib2FyZDogZmFsc2VcclxuXHJcbn07XHJcblxyXG4vKipcclxuKiBDaGVja3MgZm9yIHN1cHBvcnQgb2YgdGhlIEZ1bGwgU2NyZWVuIEFQSS5cclxuKi9cclxuZnVuY3Rpb24gaW5pdCAoKVxyXG57XHJcbiAgICB2YXIgZnMgPSBbXHJcbiAgICAgICAgJ3JlcXVlc3RGdWxsc2NyZWVuJyxcclxuICAgICAgICAncmVxdWVzdEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsXHJcbiAgICAgICAgJ3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJyxcclxuICAgICAgICAnbXNSZXF1ZXN0RnVsbHNjcmVlbicsXHJcbiAgICAgICAgJ21zUmVxdWVzdEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICdtb3pSZXF1ZXN0RnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ21velJlcXVlc3RGdWxsc2NyZWVuJ1xyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRbZnNbaV1dKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRnVsbHNjcmVlbi5hdmFpbGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBGdWxsc2NyZWVuLnJlcXVlc3QgPSBmc1tpXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjZnMgPSBbXHJcbiAgICAgICAgJ2NhbmNlbEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICdleGl0RnVsbHNjcmVlbicsXHJcbiAgICAgICAgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsXHJcbiAgICAgICAgJ21zQ2FuY2VsRnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ21zRXhpdEZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICdtb3pDYW5jZWxGdWxsU2NyZWVuJyxcclxuICAgICAgICAnbW96RXhpdEZ1bGxzY3JlZW4nXHJcbiAgICBdO1xyXG5cclxuICAgIGlmIChGdWxsc2NyZWVuLmF2YWlsYWJsZSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNmcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudFtjZnNbaV1dKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGdWxsc2NyZWVuLmNhbmNlbCA9IGNmc1tpXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBLZXlib2FyZCBJbnB1dD9cclxuICAgIGlmICh3aW5kb3dbJ0VsZW1lbnQnXSAmJiBFbGVtZW50WydBTExPV19LRVlCT0FSRF9JTlBVVCddKVxyXG4gICAge1xyXG4gICAgICAgIEZ1bGxzY3JlZW4ua2V5Ym9hcmQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBGdWxsc2NyZWVuO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL0Z1bGxzY3JlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9GdWxsc2NyZWVuLmpzIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xyXG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xyXG5cclxudmFyIElucHV0ID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHRvdWNoIC0gSXMgdG91Y2ggYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRvdWNoOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtc3BvaW50ZXIgLSBJcyBtc3BvaW50ZXIgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG1zcG9pbnRlcjogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gd2hlZWxUeXBlIC0gVGhlIG5ld2VzdCB0eXBlIG9mIFdoZWVsL1Njcm9sbCBldmVudCBzdXBwb3J0ZWQ6ICd3aGVlbCcsICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJ1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKiBAcHJvdGVjdGVkXHJcbiAgICAqL1xyXG4gICAgd2hlZWxFdmVudDogbnVsbFxyXG4gICAgXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgKHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+PSAxKSlcclxuICAgIHtcclxuICAgICAgICBJbnB1dC50b3VjaCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCB8fCB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIElucHV0Lm1zcG9pbnRlciA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFPUy5jb2Nvb25KUylcclxuICAgIHtcclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsXHJcbiAgICAgICAgaWYgKCdvbndoZWVsJyBpbiB3aW5kb3cgfHwgKEJyb3dzZXIuaWUgJiYgJ1doZWVsRXZlbnQnIGluIHdpbmRvdykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBET00zIFdoZWVsIEV2ZW50OiBGRiAxNyssIElFIDkrLCBDaHJvbWUgMzErLCBTYWZhcmkgNytcclxuICAgICAgICAgICAgSW5wdXQud2hlZWxFdmVudCA9ICd3aGVlbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdvbm1vdXNld2hlZWwnIGluIHdpbmRvdylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIE5vbi1GRiBsZWdhY3k6IElFIDYtOSwgQ2hyb21lIDEtMzEsIFNhZmFyaSA1LTcuXHJcbiAgICAgICAgICAgIElucHV0LndoZWVsRXZlbnQgPSAnbW91c2V3aGVlbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEJyb3dzZXIuZmlyZWZveCAmJiAnTW91c2VTY3JvbGxFdmVudCcgaW4gd2luZG93KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRkYgcHJpb3IgdG8gMTcuIFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHNjcnViYmVkLlxyXG4gICAgICAgICAgICBJbnB1dC53aGVlbEV2ZW50ID0gJ0RPTU1vdXNlU2Nyb2xsJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIElucHV0O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL0lucHV0LmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvSW5wdXQuanMiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcblxyXG52YXIgVmlkZW8gPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2dnVmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBvZ2cgdmlkZW8gZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgb2dnVmlkZW86IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGgyNjRWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IGgyNjQgbXA0IHZpZGVvIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGgyNjRWaWRlbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXA0VmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBoMjY0IG1wNCB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtcDRWaWRlbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2VibVZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgd2VibSB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJtVmlkZW86IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZwOVZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgdnA5IHZpZGVvIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHZwOVZpZGVvOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBobHNWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IGhscyB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBobHNWaWRlbzogZmFsc2VcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIHZhciB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgdmFyIHJlc3VsdCA9ICEhdmlkZW9FbGVtZW50LmNhblBsYXlUeXBlO1xyXG5cclxuICAgIHRyeVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby9vZ2c7IGNvZGVjcz1cInRoZW9yYVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmlkZW8ub2dnVmlkZW8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IFF1aWNrVGltZSwgdGhpcyB2YWx1ZSB3aWxsIGJlIGB1bmRlZmluZWRgLiBnaXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvaXNzdWVzLzU0NlxyXG4gICAgICAgICAgICAgICAgVmlkZW8uaDI2NFZpZGVvID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIFZpZGVvLm1wNFZpZGVvID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5jYW5QbGF5VHlwZSgndmlkZW8vd2VibTsgY29kZWNzPVwidnA4LCB2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZpZGVvLndlYm1WaWRlbyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGUoJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZwOVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmlkZW8udnA5VmlkZW8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCdhcHBsaWNhdGlvbi94LW1wZWdVUkw7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWaWRlby5obHNWaWRlbyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSlcclxuICAgIHtcclxuICAgICAgICAvLyAgTm90aGluZyB0byBkb1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBWaWRlbztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9WaWRlby5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL1ZpZGVvLmpzIiwiLy8gIFRoaXMgc2luZ2xldG9uIGlzIGluc3RhbnRpYXRlZCBhcyBzb29uIGFzIFBoYXNlciBsb2FkcyxcclxuLy8gIGJlZm9yZSBhIFBoYXNlci5HYW1lIGluc3RhbmNlIGhhcyBldmVuIGJlZW4gY3JlYXRlZC5cclxuLy8gIFdoaWNoIG1lYW5zIGFsbCBpbnN0YW5jZXMgb2YgUGhhc2VyIEdhbWVzIGNhbiBzaGFyZSBpdCxcclxuLy8gIHdpdGhvdXQgaGF2aW5nIHRvIHJlLXBvbGwgdGhlIGRldmljZSBhbGwgb3ZlciBhZ2FpblxyXG5cclxudmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xyXG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xyXG52YXIgRmVhdHVyZXMgPSByZXF1aXJlKCcuL0ZlYXR1cmVzJyk7XHJcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vSW5wdXQnKTtcclxudmFyIEF1ZGlvID0gcmVxdWlyZSgnLi9BdWRpbycpO1xyXG52YXIgVmlkZW8gPSByZXF1aXJlKCcuL1ZpZGVvJyk7XHJcbnZhciBGdWxsc2NyZWVuID0gcmVxdWlyZSgnLi9GdWxsc2NyZWVuJyk7XHJcbnZhciBDYW52YXNGZWF0dXJlcyA9IHJlcXVpcmUoJy4vQ2FudmFzRmVhdHVyZXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE9TOiBPUyxcclxuICAgIEJyb3dzZXI6IEJyb3dzZXIsXHJcbiAgICBGZWF0dXJlczogRmVhdHVyZXMsXHJcbiAgICBJbnB1dDogSW5wdXQsXHJcbiAgICBBdWRpbzogQXVkaW8sXHJcbiAgICBWaWRlbzogVmlkZW8sXHJcbiAgICBGdWxsc2NyZWVuOiBGdWxsc2NyZWVuLFxyXG4gICAgQ2FudmFzRmVhdHVyZXM6IENhbnZhc0ZlYXR1cmVzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9pbmRleC5qcyIsInZhciBBZGRUb0RPTSA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQsIG92ZXJmbG93SGlkZGVuKVxyXG57XHJcbiAgICBpZiAob3ZlcmZsb3dIaWRkZW4gPT09IHVuZGVmaW5lZCkgeyBvdmVyZmxvd0hpZGRlbiA9IHRydWU7IH1cclxuXHJcbiAgICB2YXIgdGFyZ2V0O1xyXG5cclxuICAgIGlmIChwYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEhvcGVmdWxseSBhbiBlbGVtZW50IElEXHJcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdvYmplY3QnICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBRdWljayB0ZXN0IGZvciBhIEhUTUxlbGVtZW50XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZhbGxiYWNrLCBjb3ZlcnMgYW4gaW52YWxpZCBJRCBhbmQgYSBub24gSFRNTGVsZW1lbnQgb2JqZWN0XHJcbiAgICBpZiAoIXRhcmdldClcclxuICAgIHtcclxuICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvdmVyZmxvd0hpZGRlbiAmJiB0YXJnZXQuc3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGRUb0RPTTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL0FkZFRvRE9NLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIE9TID0gcmVxdWlyZSgnLi4vZGV2aWNlL09TJyk7XHJcblxyXG52YXIgaXNCb290ZWQgPSBmYWxzZTtcclxuXHJcbnZhciBET01Db250ZW50TG9hZGVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG57XHJcbiAgICBpZiAoaXNCb290ZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScpXHJcbiAgICB7XHJcbiAgICAgICAgaXNCb290ZWQgPSB0cnVlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlzQm9vdGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBjaGVjaywgdHJ1ZSk7XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGNoZWNrLCB0cnVlKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGNoZWNrLCB0cnVlKTtcclxuXHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKCFkb2N1bWVudC5ib2R5KVxyXG4gICAge1xyXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNoZWNrLCAyMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChPUy5jb3Jkb3ZhICYmICFPUy5jb2Nvb25KUylcclxuICAgIHtcclxuICAgICAgICAvLyAgUmVmLiBodHRwOi8vZG9jcy5waG9uZWdhcC5jb20vZW4vMy41LjAvY29yZG92YV9ldmVudHNfZXZlbnRzLm1kLmh0bWwjZGV2aWNlcmVhZHlcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGNoZWNrLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGNoZWNrLCB0cnVlKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGNoZWNrLCB0cnVlKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRE9NQ29udGVudExvYWRlZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL0RPTUNvbnRlbnRMb2FkZWQuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kb20vRE9NQ29udGVudExvYWRlZC5qcyIsInZhciBQYXJzZVhNTCA9IGZ1bmN0aW9uIChkYXRhKVxyXG57XHJcbiAgICB2YXIgeG1sID0gJyc7XHJcblxyXG4gICAgdHJ5XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHdpbmRvd1snRE9NUGFyc2VyJ10pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZG9tcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xyXG4gICAgICAgICAgICB4bWwgPSBkb21wYXJzZXIucGFyc2VGcm9tU3RyaW5nKGRhdGEsICd0ZXh0L3htbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4bWwgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xyXG4gICAgICAgICAgICB4bWwubG9hZFhNTChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSlcclxuICAgIHtcclxuICAgICAgICB4bWwgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgheG1sIHx8ICF4bWwuZG9jdW1lbnRFbGVtZW50IHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKS5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHhtbDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFyc2VYTUw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9QYXJzZVhNTC5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIEFic3RyYWN0cyBhd2F5IHRoZSB1c2Ugb2YgUkFGIG9yIHNldFRpbWVPdXQgZm9yIHRoZSBjb3JlIGdhbWUgdXBkYXRlIGxvb3AuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cclxuKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZVNldFRpbWVPdXQ9ZmFsc2VdIC0gVGVsbCBQaGFzZXIgdG8gdXNlIHNldFRpbWVPdXQgZXZlbiBpZiByYWYgaXMgYXZhaWxhYmxlLlxyXG4qL1xyXG5mdW5jdGlvbiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKGdhbWUpXHJcbntcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5HYW1lfSBnYW1lIC0gVGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpc1J1bm5pbmcgLSB0cnVlIGlmIFJlcXVlc3RBbmltYXRpb25GcmFtZSBpcyBydW5uaW5nLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnRpY2sgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU2V0VGltZU91dCAgLSBUcnVlIGlmIHRoZSBicm93c2VyIGlzIHVzaW5nIHNldFRpbWVvdXQgaW5zdGVhZCBvZiByQWYuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5pc1NldFRpbWVPdXQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVPdXRJRCAtIFRoZSBjYWxsYmFjayBzZXRUaW1lb3V0IG9yIHJBZiBjYWxsYmFjayBJRCB1c2VkIHdoZW4gY2FsbGluZyBjYW5jZWwuXHJcbiAgICAqL1xyXG4gICAgdGhpcy50aW1lT3V0SUQgPSBudWxsO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgLy8gIHRpbWVzdGFtcCA9IERPTUhpZ2hSZXNUaW1lU3RhbXBcclxuICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKHRpbWVzdGFtcClcclxuICAgIHtcclxuICAgICAgICBfdGhpcy50aWNrID0gdGltZXN0YW1wO1xyXG5cclxuICAgICAgICBfdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xyXG5cclxuICAgICAgICBfdGhpcy5nYW1lLnVwZGF0ZSh0aW1lc3RhbXApO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3RlcFRpbWVvdXQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIF90aGlzLnRpY2sgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICAvLyBfdGhpcy5nYW1lLnVwZGF0ZShfdGhpcy50aWNrKTtcclxuXHJcbiAgICAgICAgLy8gX3RoaXMudGltZU91dElEID0gd2luZG93LnNldFRpbWVvdXQoc3RlcFRpbWVvdXQsIF90aGlzLmdhbWUudGltZS50aW1lVG9DYWxsKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFN0YXJ0cyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHJ1bm5pbmcgb3Igc2V0VGltZW91dCBpZiB1bmF2YWlsYWJsZSBpbiBicm93c2VyXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZSNzdGFydFxyXG4gICAgKi9cclxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZ2FtZS5jb25maWcuZm9yY2VTZXRUaW1lT3V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5pc1NldFRpbWVPdXQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cuc2V0VGltZW91dChzdGVwVGltZW91dCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTZXRUaW1lT3V0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRpbWVPdXRJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogU3RvcHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tIHJ1bm5pbmcuXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZSNzdG9wXHJcbiAgICAqL1xyXG4gICAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc1NldFRpbWVPdXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lT3V0SUQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy50aW1lT3V0SUQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbn1cclxuXHJcblJlcXVlc3RBbmltYXRpb25GcmFtZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL1JlcXVlc3RBbmltYXRpb25GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuL0V2ZW50TGlzdGVuZXInKTtcclxuXHJcbnZhciBFdmVudEJpbmRpbmcgPSBmdW5jdGlvbiAoZGlzcGF0Y2hlciwgdHlwZSlcclxue1xyXG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRElTUEFUQ0hFUl9JRExFO1xyXG4gICAgdGhpcy5hY3RpdmUgPSBbXTtcclxufTtcclxuXHJcbkV2ZW50QmluZGluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFdmVudEJpbmRpbmc7XHJcblxyXG5FdmVudEJpbmRpbmcucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHRvdGFsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0b3RhbCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgIT09IENPTlNULkxJU1RFTkVSX1JFTU9WSU5HKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG90YWw7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgaGFzOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldChjYWxsYmFjaykpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgcHJpb3JpdHksIG9uY2UpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5nZXQoY2FsbGJhY2spO1xyXG5cclxuICAgICAgICBpZiAoIWxpc3RlbmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRoZSBsaXN0ZW5lciBkb2Vzbid0IGV4aXN0LCBzbyBjcmVhdGUgb25lXHJcbiAgICAgICAgICAgIGxpc3RlbmVyID0gRXZlbnRMaXN0ZW5lcih0aGlzLnR5cGUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBMaXN0ZW5lciBhbHJlYWR5IGV4aXN0cywgYWJvcnRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfSURMRSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGUgRGlzcGF0Y2hlciBpc24ndCBkb2luZyBhbnl0aGluZywgc28gd2UgZG9uJ3QgbmVlZCBhIHBlbmRpbmcgc3RhdGVcclxuICAgICAgICAgICAgbGlzdGVuZXIuc3RhdGUgPSBDT05TVC5MSVNURU5FUl9BQ1RJVkU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5wdXNoKGxpc3RlbmVyKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNvcnQodGhpcy5zb3J0SGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfRElTUEFUQ0hJTkcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQWRkIGl0IHRvIHRoZSBsaXN0LCBidXQga2VlcCB0aGUgc3RhdGUgYXMgcGVuZGluZy5cclxuICAgICAgICAgICAgLy8gIFRoZSBjYWxsIHRvICd0aWR5JyB3aWxsIHNvcnQgaXQgb3V0IGF0IHRoZSBlbmQgb2YgdGhlIGRpc3BhdGNoLlxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNvcnRIYW5kbGVyOiBmdW5jdGlvbiAobGlzdGVuZXJBLCBsaXN0ZW5lckIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyQi5wcmlvcml0eSA8IGxpc3RlbmVyQS5wcmlvcml0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGlzdGVuZXJCLnByaW9yaXR5ID4gbGlzdGVuZXJBLnByaW9yaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfSURMRSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGUgRGlzcGF0Y2hlciBpc24ndCBkb2luZyBhbnl0aGluZywgc28gd2UgY2FuIHJlbW92ZSByaWdodCBhd2F5XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5nZXRJbmRleChjYWxsYmFjayk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaSAhPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfRElTUEFUQ0hJTkcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVGhlIERpc3BhdGNoZXIgaXMgd29ya2luZywgc28gd2UgZmxhZyB0aGUgbGlzdGVuZXIgZm9yIHJlbW92YWwgYXQgdGhlIGVuZFxyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmdldChjYWxsYmFjayk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnN0YXRlID0gQ09OU1QuTElTVEVORVJfUkVNT1ZJTkc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IENPTlNULkRJU1BBVENIRVJfSURMRSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3I6IEZhaWxlZCB0byBleGVjdXRlIFxcJ0V2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaFxcJyBvbiBcXCcnICsgdGhpcy50eXBlICsgJ1xcJzogVGhlIGV2ZW50IGlzIGFscmVhZHkgYmVpbmcgZGlzcGF0Y2hlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRoaXMgd2FzIGEgdmFsaWQgZGlzcGF0Y2ggY2FsbCwgd2UganVzdCBoYWQgbm90aGluZyB0byBkbyAuLi5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfRElTUEFUQ0hJTkc7XHJcblxyXG4gICAgICAgIHZhciBsaXN0ZW5lcjtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyID0gdGhpcy5hY3RpdmVbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIuc3RhdGUgIT09IENPTlNULkxJU1RFTkVSX0FDVElWRSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrLmNhbGwodGhpcy5kaXNwYXRjaGVyLCBldmVudCk7XHJcblxyXG4gICAgICAgICAgICAvLyAgSGFzIHRoZSBjYWxsYmFjayBjaGFuZ2VkIHRoZSBzdGF0ZSBvZiB0aGlzIGJpbmRpbmc/XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBDT05TVC5ESVNQQVRDSEVSX0RJU1BBVENISU5HKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgWXVwISBMZXQncyBicmVhayBvdXRcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAgV2FzIGl0IGEgJ29uY2UnIGxpc3RlbmVyP1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIub25jZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuc3RhdGUgPSBDT05TVC5MSVNURU5FUl9SRU1PVklORztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIEhhcyB0aGUgZXZlbnQgYmVlbiBoYWx0ZWQgYnkgdGhlIGNhbGxiYWNrP1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50Ll9wcm9wYWdhdGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBCcmVhayBvdXQsIGEgbGlzdGVuZXIgaGFzIGNhbGxlZCBFdmVudC5zdG9wUHJvcGFnYXRpb25cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgRGlzcGF0Y2ggb3Zlciwgb3IgYWJvcnRlZFxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX1JFTU9WSU5HKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBBbGwgZG9uZSwgdGlkeSB0aGUgbGlzdCBpbiBjYXNlIHRoZXJlIHdlcmUgYW55IHBlbmRpbmcgZXZlbnRzIGFkZGVkXHJcbiAgICAgICAgICAgIHRoaXMudGlkeSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0RFU1RST1lFRClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5kZWxldGUodGhpcy50eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEFsbCBkb25lLCBqdXN0IHB1cmdlIHRoZSBsaXN0XHJcbiAgICAgICAgICAgIHRoaXMudGlkeSgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfSURMRTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBSZW1vdmVzIGFsbCBsaXN0ZW5lcnNcclxuICAgIC8vICBJZiB0aGlzIGlzIGN1cnJlbnRseSBiZWluZyBkaXNwYXRjaGVkIHRoZW4gZG9uJ3QgcmVtb3ZlICdwZW5kaW5nJyBsaXN0ZW5lcnNcclxuICAgIC8vICAoaS5lLiBvbmVzIHRoYXQgd2VyZSBhZGRlZCBkdXJpbmcgdGhlIGRpc3BhdGNoKSwgb25seSBhY3RpdmUgb25lc1xyXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5hY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5zdGF0ZSAhPT0gQ09OU1QuTElTVEVORVJfUEVORElORylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5wb3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfSURMRTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHRpZHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFkZGVkID0gMDtcclxuXHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmFjdGl2ZS5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgICBkb1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLnN0YXRlID09PSBDT05TVC5MSVNURU5FUl9SRU1PVklORylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlW2ldLnN0YXRlID09PSBDT05TVC5MSVNURU5FUl9QRU5ESU5HKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVtpXS5zdGF0ZSA9PT0gQ09OU1QuTElTVEVORVJfQUNUSVZFO1xyXG4gICAgICAgICAgICAgICAgYWRkZWQrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoaSA+PSAwKTtcclxuXHJcbiAgICAgICAgaWYgKGFkZGVkID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNvcnQodGhpcy5zb3J0SGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5ESVNQQVRDSEVSX0RFU1RST1lFRDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50QmluZGluZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZXZlbnRzL0V2ZW50QmluZGluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2V2ZW50cy9FdmVudEJpbmRpbmcuanMiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaywgcHJpb3JpdHksIG9uY2UpXHJcbntcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXHJcbiAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxyXG4gICAgICAgIG9uY2U6IG9uY2UsXHJcbiAgICAgICAgc3RhdGU6IENPTlNULkxJU1RFTkVSX1BFTkRJTkdcclxuICAgIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2V2ZW50cy9FdmVudExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZXZlbnRzL0V2ZW50TGlzdGVuZXIuanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xyXG52YXIgQm9iID0gcmVxdWlyZSgnLi9Cb2InKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDaGlsZHJlbiA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvQ2hpbGRyZW4nKTtcclxuXHJcbi8qKlxyXG4qIEEgQmxpdHRlciBHYW1lIE9iamVjdC5cclxuKlxyXG4qIFRoZSBCbGl0dGVyIEdhbWUgT2JqZWN0IGlzIGEgc3BlY2lhbCB0eXBlIG9mIENvbnRhaW5lciwgdGhhdCBjb250YWlucyBCbGl0dGVyLkJvYiBvYmplY3RzLlxyXG4qIFRoZXNlIG9iamVjdHMgY2FuIGJlIHRob3VnaHQgb2YgYXMganVzdCB0ZXh0dXJlIGZyYW1lcyB3aXRoIGEgdHJhbnNmb3JtLCBhbmQgbm90aGluZyBtb3JlLlxyXG4qIEJvYnMgZG9uJ3QgaGF2ZSBhbnkgdXBkYXRlIG1ldGhvZHMsIG9yIHRoZSBhYmlsaXR5IHRvIGhhdmUgY2hpbGRyZW4sIG9yIGFueSBraW5kIG9mIHNwZWNpYWwgZWZmZWN0cy5cclxuKiBUaGV5IGFyZSBlc3NlbnRpYWxseSBqdXN0IHRleHR1cmUgcmVuZGVyZXJzLCBhbmQgdGhlIEJsaXR0ZXIgb2JqZWN0IGNyZWF0ZXMgYW5kIG1hbmFnZXMgdGhlbS5cclxuKlxyXG4qIEBjbGFzcyBCbGl0dGVyXHJcbiogQGV4dGVuZHMgUGhhc2VyLkdhbWVPYmplY3RcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgSW1hZ2UuIFRoZSBjb29yZGluYXRlIGlzIHJlbGF0aXZlIHRvIGFueSBwYXJlbnQgY29udGFpbmVyIHRoaXMgSW1hZ2UgbWF5IGJlIGluLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cclxuKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gLSBUaGUgdGV4dHVyZSB1c2VkIGJ5IHRoZSBJbWFnZSBkdXJpbmcgcmVuZGVyaW5nLiBJdCBjYW4gYmUgYSBzdHJpbmcgd2hpY2ggaXMgYSByZWZlcmVuY2UgdG8gdGhlIENhY2hlIGVudHJ5LCBvciBhbiBpbnN0YW5jZSBvZiBhIFJlbmRlclRleHR1cmUsIEJpdG1hcERhdGEgb3IgUElYSS5UZXh0dXJlLlxyXG4qIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2ZyYW1lXSAtIElmIHRoaXMgSW1hZ2UgaXMgdXNpbmcgcGFydCBvZiBhIHNwcml0ZSBzaGVldCBvciB0ZXh0dXJlIGF0bGFzIHlvdSBjYW4gc3BlY2lmeSB0aGUgZXhhY3QgZnJhbWUgdG8gdXNlIGJ5IGdpdmluZyBhIHN0cmluZyBvciBudW1lcmljIGluZGV4LlxyXG4qL1xyXG52YXIgQmxpdHRlciA9IGZ1bmN0aW9uIChzdGF0ZSwgeCwgeSwga2V5LCBmcmFtZSlcclxue1xyXG4gICAgdmFyIF90ZXh0dXJlID0gc3RhdGUuZ2FtZS50ZXh0dXJlcy5nZXQoa2V5KTtcclxuICAgIHZhciBfZnJhbWUgPSBfdGV4dHVyZS5nZXQoZnJhbWUpO1xyXG5cclxuICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSwgeCwgeSwgX3RleHR1cmUsIF9mcmFtZSk7XHJcblxyXG4gICAgdGhpcy50eXBlID0gQ09OU1QuQkxJVFRFUjtcclxuXHJcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3IENoaWxkcmVuKHRoaXMpO1xyXG59O1xyXG5cclxuQmxpdHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdhbWVPYmplY3QucHJvdG90eXBlKTtcclxuQmxpdHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbGl0dGVyO1xyXG5cclxuLy8gQmxpdHRlci5wcm90b3R5cGUucmVuZGVyQ2FudmFzID0gcmVxdWlyZSgnLi9CbGl0dGVyQ2FudmFzUmVuZGVyZXInKTtcclxuQmxpdHRlci5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuL0JsaXR0ZXJXZWJHTFJlbmRlcmVyJyk7XHJcblxyXG4vLyAgZnJhbWUgTVVTVCBiZSBwYXJ0IG9mIHRoZSBCbGl0dGVyIHRleHR1cmVcclxuQmxpdHRlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHgsIHksIGZyYW1lLCB2aXNpYmxlLCBpbmRleClcclxue1xyXG4gICAgaWYgKGZyYW1lID09PSB1bmRlZmluZWQpIHsgZnJhbWUgPSB0aGlzLmZyYW1lOyB9XHJcbiAgICBpZiAodmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB7IHZpc2libGUgPSB0cnVlOyB9XHJcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IDA7IH1cclxuXHJcbiAgICB2YXIgYm9iID0gbmV3IEJvYih0aGlzLCB4LCB5LCBmcmFtZSwgdmlzaWJsZSk7XHJcblxyXG4gICAgdGhpcy5jaGlsZHJlbi5hZGRBdChib2IsIGluZGV4LCBmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIGJvYjtcclxufTtcclxuXHJcbi8vICBmcmFtZSBNVVNUIGJlIHBhcnQgb2YgdGhlIEJsaXR0ZXIgdGV4dHVyZVxyXG5CbGl0dGVyLnByb3RvdHlwZS5jcmVhdGVGcm9tQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHF1YW50aXR5LCBmcmFtZSwgdmlzaWJsZSlcclxue1xyXG4gICAgdmFyIGJvYnMgPSB0aGlzLmNyZWF0ZU11bHRpcGxlKHF1YW50aXR5LCBmcmFtZSwgdmlzaWJsZSk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2JzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBib2IgPSBib2JzW2ldO1xyXG5cclxuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGJvYiwgaSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJvYnM7XHJcbn07XHJcblxyXG4vLyAgZnJhbWUgTVVTVCBiZSBwYXJ0IG9mIHRoZSBCbGl0dGVyIHRleHR1cmVcclxuQmxpdHRlci5wcm90b3R5cGUuY3JlYXRlTXVsdGlwbGUgPSBmdW5jdGlvbiAocXVhbnRpdHksIGZyYW1lLCB2aXNpYmxlKVxyXG57XHJcbiAgICBpZiAoZnJhbWUgPT09IHVuZGVmaW5lZCkgeyBmcmFtZSA9IHRoaXMuZnJhbWU7IH1cclxuICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHsgdmlzaWJsZSA9IHRydWU7IH1cclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJhbWUpKVxyXG4gICAge1xyXG4gICAgICAgIGZyYW1lID0gWyBmcmFtZSBdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBib2JzID0gW107XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIGZyYW1lLmZvckVhY2goZnVuY3Rpb24gKHNpbmdsZUZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVhbnRpdHk7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJvYnMucHVzaChfdGhpcy5jcmVhdGUoMCwgMCwgc2luZ2xlRnJhbWUsIHZpc2libGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gYm9icztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxpdHRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyLmpzIiwiXHJcbnZhciBCbGl0dGVyV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSlcclxue1xyXG4gICAgdmFyIHdvcmxkQWxwaGEgPSBzcmMuY29sb3Iud29ybGRBbHBoYTtcclxuICAgIHZhciBsZW4gPSBzcmMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7XHJcblxyXG4gICAgLy8gIFNraXAgcmVuZGVyaW5nP1xyXG5cclxuICAgIGlmIChzcmMuc2tpcFJlbmRlciB8fCAhc3JjLnZpc2libGUgfHwgd29ybGRBbHBoYSA9PT0gMCB8fCBsZW4gPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBSZW5kZXIgY2hpbGRyZW5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJvYiA9IHNyYy5jaGlsZHJlbi5saXN0W2ldO1xyXG4gICAgICAgIHZhciBmcmFtZSA9IGJvYi5mcmFtZTtcclxuXHJcbiAgICAgICAgaWYgKCFib2IudmlzaWJsZSB8fCAhZnJhbWUuY3V0V2lkdGggfHwgIWZyYW1lLmN1dEhlaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVuZGVyZXIuYmxpdHRlckJhdGNoLmFkZChib2IueCwgYm9iLnksIGZyYW1lLCB3b3JsZEFscGhhKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxpdHRlcldlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlcldlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQm9iID0gZnVuY3Rpb24gKGJsaXR0ZXIsIHgsIHksIGZyYW1lLCB2aXNpYmxlKVxyXG57XHJcbiAgICB0aGlzLnBhcmVudCA9IGJsaXR0ZXI7XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICB0aGlzLmZyYW1lID0gZnJhbWU7XHJcbiAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCb2I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQm9iLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb250YWluZXJXZWJHTFJlbmRlcmVyID0gcmVxdWlyZSgnLi9Db250YWluZXJXZWJHTFJlbmRlcmVyJyk7XHJcbnZhciBDaGlsZHJlbiA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvQ2hpbGRyZW4nKTtcclxuXHJcbnZhciBDb250YWluZXIgPSBmdW5jdGlvbiAoc3RhdGUsIHBhcmVudCwgeCwgeSlcclxue1xyXG4gICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHN0YXRlLCB4LCB5LCBudWxsLCBudWxsLCBwYXJlbnQpO1xyXG5cclxuICAgIHRoaXMudHlwZSA9IENPTlNULkNPTlRBSU5FUjtcclxuXHJcbiAgICB0aGlzLnJlbmRlciA9IENvbnRhaW5lcldlYkdMUmVuZGVyZXI7XHJcblxyXG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBDaGlsZHJlbih0aGlzKTtcclxufTtcclxuXHJcbkNvbnRhaW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdhbWVPYmplY3QucHJvdG90eXBlKTtcclxuQ29udGFpbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhaW5lcjtcclxuXHJcbkNvbnRhaW5lci5wcm90b3R5cGUucHJlVXBkYXRlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5jaGlsZHJlbi5wcmVVcGRhdGUoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qcyIsIlxyXG52YXIgQ29udGFpbmVyV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSlcclxue1xyXG4gICAgdmFyIGFscGhhID0gc3JjLmNvbG9yLndvcmxkQWxwaGEgKiAyNTUgPDwgMjQ7XHJcblxyXG4gICAgLy8gIFNraXAgcmVuZGVyaW5nP1xyXG5cclxuICAgIGlmIChzcmMuc2tpcFJlbmRlciB8fCAhc3JjLnZpc2libGUgfHwgYWxwaGEgPT09IDAgfHwgc3JjLmNoaWxkcmVuLmxpc3QubGVuZ3RoID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgUmVuZGVyIGNoaWxkcmVuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyYy5jaGlsZHJlbi5saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IHNyYy5jaGlsZHJlbi5saXN0W2ldO1xyXG5cclxuICAgICAgICBjaGlsZC5yZW5kZXIocmVuZGVyZXIsIGNoaWxkKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyV2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lcldlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxuXHJcbi8qKlxyXG4qIEFuIEltYWdlIGlzIGEgbGlnaHQtd2VpZ2h0IG9iamVjdCB5b3UgY2FuIHVzZSB0byBkaXNwbGF5IGFueXRoaW5nIHRoYXQgZG9lc24ndCBuZWVkIHBoeXNpY3Mgb3IgYW5pbWF0aW9uLlxyXG4qIEl0IGNhbiBzdGlsbCByb3RhdGUsIHNjYWxlLCBjcm9wIGFuZCByZWNlaXZlIGlucHV0IGV2ZW50cy4gVGhpcyBtYWtlcyBpdCBwZXJmZWN0IGZvciBsb2dvcywgYmFja2dyb3VuZHMsIHNpbXBsZSBidXR0b25zIGFuZCBvdGhlciBub24tU3ByaXRlIGdyYXBoaWNzLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5HYW1lT2JqZWN0LkltYWdlXHJcbiogQGV4dGVuZHMgUGhhc2VyLkdhbWVPYmplY3RcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgSW1hZ2UuIFRoZSBjb29yZGluYXRlIGlzIHJlbGF0aXZlIHRvIGFueSBwYXJlbnQgY29udGFpbmVyIHRoaXMgSW1hZ2UgbWF5IGJlIGluLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cclxuKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gLSBUaGUgdGV4dHVyZSB1c2VkIGJ5IHRoZSBJbWFnZSBkdXJpbmcgcmVuZGVyaW5nLiBJdCBjYW4gYmUgYSBzdHJpbmcgd2hpY2ggaXMgYSByZWZlcmVuY2UgdG8gdGhlIENhY2hlIGVudHJ5LCBvciBhbiBpbnN0YW5jZSBvZiBhIFJlbmRlclRleHR1cmUsIEJpdG1hcERhdGEgb3IgUElYSS5UZXh0dXJlLlxyXG4qIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2ZyYW1lXSAtIElmIHRoaXMgSW1hZ2UgaXMgdXNpbmcgcGFydCBvZiBhIHNwcml0ZSBzaGVldCBvciB0ZXh0dXJlIGF0bGFzIHlvdSBjYW4gc3BlY2lmeSB0aGUgZXhhY3QgZnJhbWUgdG8gdXNlIGJ5IGdpdmluZyBhIHN0cmluZyBvciBudW1lcmljIGluZGV4LlxyXG4qL1xyXG52YXIgSW1hZ2UgPSBmdW5jdGlvbiAoc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpXHJcbntcclxuICAgIHZhciBfdGV4dHVyZSA9IHN0YXRlLmdhbWUudGV4dHVyZXMuZ2V0KGtleSk7XHJcbiAgICB2YXIgX2ZyYW1lID0gX3RleHR1cmUuZ2V0KGZyYW1lKTtcclxuXHJcbiAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUsIHgsIHksIF90ZXh0dXJlLCBfZnJhbWUpO1xyXG5cclxuICAgIHRoaXMudHlwZSA9IENPTlNULklNQUdFO1xyXG59O1xyXG5cclxuSW1hZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHYW1lT2JqZWN0LnByb3RvdHlwZSk7XHJcbkltYWdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEltYWdlO1xyXG5cclxuSW1hZ2UucHJvdG90eXBlLnJlbmRlckNhbnZhcyA9IHJlcXVpcmUoJy4vSW1hZ2VDYW52YXNSZW5kZXJlcicpO1xyXG5JbWFnZS5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSByZXF1aXJlKCcuL0ltYWdlV2ViR0xSZW5kZXJlcicpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSW1hZ2UucHJvdG90eXBlLCB7XHJcblxyXG4gICAgd2lkdGg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9zY2FsZVggKiB0aGlzLmZyYW1lLnJlYWxXaWR0aDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gdmFsdWUgLyB0aGlzLmZyYW1lLnJlYWxXaWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBoZWlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9zY2FsZVkgKiB0aGlzLmZyYW1lLnJlYWxIZWlnaHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHZhbHVlIC8gdGhpcy5mcmFtZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2UuanMiLCJcclxudmFyIEltYWdlQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpXHJcbntcclxuICAgIHZhciBmcmFtZSA9IHNyYy5mcmFtZTtcclxuICAgIHZhciBhbHBoYSA9IHNyYy5jb2xvci53b3JsZEFscGhhICogMjU1IDw8IDI0O1xyXG5cclxuICAgIC8vICBTa2lwIHJlbmRlcmluZz9cclxuXHJcbiAgICBpZiAoc3JjLnNraXBSZW5kZXIgfHwgIXNyYy52aXNpYmxlIHx8IGFscGhhID09PSAwIHx8ICFmcmFtZS5jdXRXaWR0aCB8fCAhZnJhbWUuY3V0SGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IHNyYy50cmFuc2Zvcm0uZ2V0Q2FudmFzVHJhbnNmb3JtRGF0YShpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgcmVuZGVyZXIpO1xyXG4gICAgdmFyIHRpbnQgPSBzcmMuY29sb3IuX2dsVGludDtcclxuICAgIHZhciBiZyA9IHNyYy5jb2xvci5fZ2xCZztcclxuXHJcbiAgICByZW5kZXJlci5kcmF3SW1hZ2UoZnJhbWUsIHNyYy5ibGVuZE1vZGUsIGRhdGEsIGFscGhhLCB0aW50LCBiZyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlQ2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIEltYWdlV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSlcclxue1xyXG4gICAgdmFyIGZyYW1lID0gc3JjLmZyYW1lO1xyXG4gICAgdmFyIGFscGhhID0gc3JjLmNvbG9yLndvcmxkQWxwaGEgKiAyNTUgPDwgMjQ7XHJcblxyXG4gICAgLy8gIFNraXAgcmVuZGVyaW5nP1xyXG5cclxuICAgIGlmIChzcmMuc2tpcFJlbmRlciB8fCAhc3JjLnZpc2libGUgfHwgYWxwaGEgPT09IDAgfHwgIWZyYW1lLmN1dFdpZHRoIHx8ICFmcmFtZS5jdXRIZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHZhciB2ZXJ0cyA9IHNyYy50cmFuc2Zvcm0uZ2V0VmVydGV4RGF0YShpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgcmVuZGVyZXIpO1xyXG4gICAgLy8gdmFyIGluZGV4ID0gc3JjLmZyYW1lLnNvdXJjZS5nbFRleHR1cmVJbmRleDtcclxuICAgIC8vIHZhciB0aW50ID0gc3JjLmNvbG9yLl9nbFRpbnQ7XHJcbiAgICAvLyB2YXIgYmcgPSBzcmMuY29sb3IuX2dsQmc7XHJcbiAgICAvLyByZW5kZXJlci5iYXRjaC5hZGQoZnJhbWUuc291cmNlLCBzcmMuYmxlbmRNb2RlLCB2ZXJ0cywgZnJhbWUudXZzLCBpbmRleCwgYWxwaGEsIHRpbnQsIGJnKTtcclxuXHJcbiAgICB2YXIgdHJhbnNmb3JtID0gc3JjLnRyYW5zZm9ybTtcclxuICAgIHJlbmRlcmVyLnNldEJsZW5kTW9kZShzcmMuY29sb3IuX2JsZW5kTW9kZSk7XHJcbiAgICByZW5kZXJlci5zcHJpdGVCYXRjaC5hZGQoXHJcbiAgICAgICAgZnJhbWUsXHJcbiAgICAgICAgdHJhbnNmb3JtLl9hbmNob3JYLCB0cmFuc2Zvcm0uX2FuY2hvclksXHJcbiAgICAgICAgdHJhbnNmb3JtLndvcmxkLnR4LCB0cmFuc2Zvcm0ud29ybGQudHksXHJcbiAgICAgICAgdHJhbnNmb3JtLl93b3JsZFNjYWxlWCwgdHJhbnNmb3JtLl93b3JsZFNjYWxlWSxcclxuICAgICAgICB0cmFuc2Zvcm0uX3dvcmxkUm90YXRpb24sXHJcbiAgICAgICAgc3JjLmNvbG9yLl9nbFRpbnRcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlV2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEFyZWEgPSBmdW5jdGlvbiAoY2lyY2xlKVxyXG57XHJcbiAgICByZXR1cm4gKGNpcmNsZS5yYWRpdXMgPiAwKSA/IE1hdGguUEkgKiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cyA6IDA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0FyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2lyY3VtZmVyZW5jZSA9IGZ1bmN0aW9uIChjaXJjbGUpXHJcbntcclxuICAgIHJldHVybiAyICogKE1hdGguUEkgKiBjaXJjbGUucmFkaXVzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VtZmVyZW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ2lyY3VtZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFJldHVybnMgYSBQb2ludCBvYmplY3QgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgY2lyY3VtZmVyZW5jZSBvZiB0aGUgQ2lyY2xlIGJhc2VkIG9uIHRoZSBnaXZlbiBhbmdsZS5cclxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUuY2lyY3VtZmVyZW5jZVBvaW50XHJcbiogQHBhcmFtIHtQaGFzZXIuQ2lyY2xlfSBhIC0gVGhlIGZpcnN0IENpcmNsZSBvYmplY3QuXHJcbiogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIC0gVGhlIGFuZ2xlIGluIHJhZGlhbnMgKHVubGVzcyBhc0RlZ3JlZXMgaXMgdHJ1ZSkgdG8gcmV0dXJuIHRoZSBwb2ludCBmcm9tLlxyXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fSBbb3V0XSAtIEFuIG9wdGlvbmFsIFBvaW50IG9iamVjdCB0byBwdXQgdGhlIHJlc3VsdCBpbiB0by4gSWYgbm9uZSBzcGVjaWZpZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuUG9pbnR9IFRoZSBQb2ludCBvYmplY3QgaG9sZGluZyB0aGUgcmVzdWx0LlxyXG4qL1xyXG52YXIgQ2lyY3VtZmVyZW5jZVBvaW50ID0gZnVuY3Rpb24gKGNpcmNsZSwgYW5nbGUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgb3V0LnggPSBjaXJjbGUueCArIChjaXJjbGUucmFkaXVzICogTWF0aC5jb3MoYW5nbGUpKTtcclxuICAgIG91dC55ID0gY2lyY2xlLnkgKyAoY2lyY2xlLnJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VtZmVyZW5jZVBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9DaXJjdW1mZXJlbmNlUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2lyY2xlID0gcmVxdWlyZSgnLi9DaXJjbGUnKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXHJcbntcclxuICAgIHJldHVybiBuZXcgQ2lyY2xlKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLnJhZGl1cyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vY2lyY2xlL0Nsb25lLmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoY2lyY2xlLCBwb2ludClcclxue1xyXG4gICAgcmV0dXJuIENvbnRhaW5zKGNpcmNsZSwgcG9pbnQueCwgcG9pbnQueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChjaXJjbGUsIHJlY3QpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgQ29udGFpbnMoY2lyY2xlLCByZWN0LngsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QucmlnaHQsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QueCwgcmVjdC5ib3R0b20pICYmXHJcbiAgICAgICAgQ29udGFpbnMoY2lyY2xlLCByZWN0LnJpZ2h0LCByZWN0LmJvdHRvbSlcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnNSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9jaXJjbGUvQ29udGFpbnNSZWN0LmpzIiwiLyoqXHJcbiogQ29waWVzIHRoZSB4LCB5IGFuZCBkaWFtZXRlciBwcm9wZXJ0aWVzIGZyb20gYW55IGdpdmVuIG9iamVjdCB0byB0aGlzIENpcmNsZS5cclxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cclxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXHJcbiogQHJldHVybiB7Q2lyY2xlfSBUaGlzIENpcmNsZSBvYmplY3QuXHJcbiovXHJcbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLnJhZGl1cyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAoY2lyY2xlLCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgY2lyY2xlLnggPT09IHRvQ29tcGFyZS54ICYmXHJcbiAgICAgICAgY2lyY2xlLnkgPT09IHRvQ29tcGFyZS55ICYmXHJcbiAgICAgICAgY2lyY2xlLnJhZGl1cyA9PT0gdG9Db21wYXJlLnJhZGl1c1xyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi4vcmVjdGFuZ2xlL1JlY3RhbmdsZScpO1xyXG5cclxudmFyIEdldEJvdW5kcyA9IGZ1bmN0aW9uIChjaXJjbGUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBSZWN0YW5nbGUoKTsgfVxyXG5cclxuICAgIG91dC54ID0gY2lyY2xlLmxlZnQ7XHJcbiAgICBvdXQueSA9IGNpcmNsZS50b3A7XHJcbiAgICBvdXQud2lkdGggPSBjaXJjbGUuZGlhbWV0ZXI7XHJcbiAgICBvdXQuaGVpZ2h0ID0gY2lyY2xlLmRpYW1ldGVyO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEJvdW5kcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvR2V0Qm91bmRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9jaXJjbGUvR2V0Qm91bmRzLmpzIiwidmFyIE9mZnNldCA9IGZ1bmN0aW9uIChjaXJjbGUsIHgsIHkpXHJcbntcclxuICAgIGNpcmNsZS54ICs9IHg7XHJcbiAgICBjaXJjbGUueSArPSB5O1xyXG5cclxuICAgIHJldHVybiBjaXJjbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvT2Zmc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldFBvaW50ID0gZnVuY3Rpb24gKGNpcmNsZSwgcG9pbnQpXHJcbntcclxuICAgIGNpcmNsZS54ICs9IHBvaW50Lng7XHJcbiAgICBjaXJjbGUueSArPSBwb2ludC55O1xyXG5cclxuICAgIHJldHVybiBjaXJjbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9PZmZzZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG4vKipcclxuKiBSZXR1cm5zIGEgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIHJhbmRvbSBwb2ludCBmcm9tIGFueXdoZXJlIHdpdGhpbiB0aGlzIENpcmNsZS5cclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjcmFuZG9tXHJcbiogQHBhcmFtIHtQaGFzZXIuUG9pbnR8b2JqZWN0fSBbb3V0XSAtIEEgUGhhc2VyLlBvaW50LCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzLCB0aGF0IHRoZSB2YWx1ZXMgd2lsbCBiZSBzZXQgaW4uXHJcbiogICAgIElmIG5vIG9iamVjdCBpcyBwcm92aWRlZCBhIG5ldyBQaGFzZXIuUG9pbnQgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC4gSW4gaGlnaCBwZXJmb3JtYW5jZSBhcmVhcyBhdm9pZCB0aGlzIGJ5IHJlLXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuUG9pbnR9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSByYW5kb20gcG9pbnQgaW4gaXRzIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuXHJcbiovXHJcbnZhciBSYW5kb20gPSBmdW5jdGlvbiAoY2lyY2xlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgdmFyIHUgPSBNYXRoLnJhbmRvbSgpICsgTWF0aC5yYW5kb20oKTtcclxuICAgIHZhciByID0gKHUgPiAxKSA/IDIgLSB1IDogdTtcclxuICAgIHZhciB4ID0gciAqIE1hdGguY29zKHQpO1xyXG4gICAgdmFyIHkgPSByICogTWF0aC5zaW4odCk7XHJcblxyXG4gICAgb3V0LnggPSBjaXJjbGUueCArICh4ICogY2lyY2xlLnJhZGl1cyk7XHJcbiAgICBvdXQueSA9IGNpcmNsZS55ICsgKHkgKiBjaXJjbGUucmFkaXVzKTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vY2lyY2xlL1JhbmRvbS5qcyIsIi8vICBQaGFzZXIuR2VvbS5DaXJjbGVcclxuXHJcbnZhciBDaXJjbGUgPSByZXF1aXJlKCcuL0NpcmNsZScpO1xyXG5cclxuQ2lyY2xlLkFyZWEgPSByZXF1aXJlKCcuL0FyZWEnKTtcclxuQ2lyY2xlLkNpcmN1bWZlcmVuY2UgPSByZXF1aXJlKCcuL0NpcmN1bWZlcmVuY2UnKTtcclxuQ2lyY2xlLkNpcmN1bWZlcmVuY2VQb2ludCA9IHJlcXVpcmUoJy4vQ2lyY3VtZmVyZW5jZVBvaW50Jyk7XHJcbkNpcmNsZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuQ2lyY2xlLkNvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5DaXJjbGUuQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xyXG5DaXJjbGUuQ29udGFpbnNSZWN0ID0gcmVxdWlyZSgnLi9Db250YWluc1JlY3QnKTtcclxuQ2lyY2xlLkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xyXG5DaXJjbGUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcclxuQ2lyY2xlLkdldEJvdW5kcyA9IHJlcXVpcmUoJy4vR2V0Qm91bmRzJyk7XHJcbkNpcmNsZS5PZmZzZXQgPSByZXF1aXJlKCcuL09mZnNldCcpO1xyXG5DaXJjbGUuT2Zmc2V0UG9pbnQgPSByZXF1aXJlKCcuL09mZnNldFBvaW50Jyk7XHJcbkNpcmNsZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9jaXJjbGUvaW5kZXguanMiLCJ2YXIgQXJlYSA9IGZ1bmN0aW9uIChlbGxpcHNlKVxyXG57XHJcbiAgICBpZiAoZWxsaXBzZS5pc0VtcHR5KCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIHVuaXRzIHNxdWFyZWRcclxuICAgIHJldHVybiAoZWxsaXBzZS5nZXRNYWpvclJhZGl1cygpICogZWxsaXBzZS5nZXRNaW5vclJhZGl1cygpICogTWF0aC5QSSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9BcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVsbGlwc2UgPSByZXF1aXJlKCcuL0VsbGlwc2UnKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXHJcbntcclxuICAgIHJldHVybiBuZXcgRWxsaXBzZShzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvQ2xvbmUuanMiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgQ29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChlbGxpcHNlLCBwb2ludClcclxue1xyXG4gICAgcmV0dXJuIENvbnRhaW5zKGVsbGlwc2UsIHBvaW50LngsIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ29udGFpbnNQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9Db250YWluc1BvaW50LmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChlbGxpcHNlLCByZWN0KVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QueCwgcmVjdC55KSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QucmlnaHQsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhlbGxpcHNlLCByZWN0LngsIHJlY3QuYm90dG9tKSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNSZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ29udGFpbnNSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUmVjdC5qcyIsIi8qKlxyXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0VsbGlwc2V9IFRoaXMgQ2lyY2xlIG9iamVjdC5cclxuKi9cclxudmFyIENvcHlGcm9tID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdClcclxue1xyXG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0NvcHlGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFscyA9IGZ1bmN0aW9uIChlbGxpcHNlLCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgZWxsaXBzZS54ID09PSB0b0NvbXBhcmUueCAmJlxyXG4gICAgICAgIGVsbGlwc2UueSA9PT0gdG9Db21wYXJlLnkgJiZcclxuICAgICAgICBlbGxpcHNlLndpZHRoID09PSB0b0NvbXBhcmUud2lkdGggJiZcclxuICAgICAgICBlbGxpcHNlLmhlaWdodCA9PT0gdG9Db21wYXJlLmhlaWdodFxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4uL3JlY3RhbmdsZS9SZWN0YW5nbGUnKTtcclxuXHJcbnZhciBHZXRCb3VuZHMgPSBmdW5jdGlvbiAoZWxsaXBzZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFJlY3RhbmdsZSgpOyB9XHJcblxyXG4gICAgb3V0LnggPSBlbGxpcHNlLnggLSBlbGxpcHNlLndpZHRoO1xyXG4gICAgb3V0LnkgPSBlbGxpcHNlLnkgLSBlbGxpcHNlLmhlaWdodDtcclxuICAgIG91dC53aWR0aCA9IGVsbGlwc2Uud2lkdGg7XHJcbiAgICBvdXQuaGVpZ2h0ID0gZWxsaXBzZS5oZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qm91bmRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvR2V0Qm91bmRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9lbGxpcHNlL0dldEJvdW5kcy5qcyIsInZhciBPZmZzZXQgPSBmdW5jdGlvbiAoZWxsaXBzZSwgeCwgeSlcclxue1xyXG4gICAgZWxsaXBzZS54ICs9IHg7XHJcbiAgICBlbGxpcHNlLnkgKz0geTtcclxuXHJcbiAgICByZXR1cm4gZWxsaXBzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvT2Zmc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldFBvaW50ID0gZnVuY3Rpb24gKGVsbGlwc2UsIHBvaW50KVxyXG57XHJcbiAgICBlbGxpcHNlLnggKz0gcG9pbnQueDtcclxuICAgIGVsbGlwc2UueSArPSBwb2ludC55O1xyXG5cclxuICAgIHJldHVybiBlbGxpcHNlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL09mZnNldFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbnZhciBSYW5kb20gPSBmdW5jdGlvbiAoZWxsaXBzZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgcCA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcclxuICAgIHZhciBzID0gTWF0aC5zcXJ0KE1hdGgucmFuZG9tKCkpO1xyXG5cclxuICAgIG91dC54ID0gZWxsaXBzZS54ICsgKChzICogTWF0aC5jb3MocCkpICogZWxsaXBzZS53aWR0aCAvIDIpO1xyXG4gICAgb3V0LnkgPSBlbGxpcHNlLnkgKyAoKHMgKiBNYXRoLnNpbihwKSkgKiBlbGxpcHNlLmhlaWdodCAvIDIpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9SYW5kb20uanMiLCIvLyAgUGhhc2VyLkdlb20uRWxsaXBzZVxyXG5cclxudmFyIEVsbGlwc2UgPSByZXF1aXJlKCcuL0VsbGlwc2UnKTtcclxuXHJcbkVsbGlwc2UuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xyXG5FbGxpcHNlLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5FbGxpcHNlLkNvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5FbGxpcHNlLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcclxuRWxsaXBzZS5Db250YWluc1JlY3QgPSByZXF1aXJlKCcuL0NvbnRhaW5zUmVjdCcpO1xyXG5FbGxpcHNlLkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xyXG5FbGxpcHNlLkVxdWFscyA9IHJlcXVpcmUoJy4vRXF1YWxzJyk7XHJcbkVsbGlwc2UuR2V0Qm91bmRzID0gcmVxdWlyZSgnLi9HZXRCb3VuZHMnKTtcclxuRWxsaXBzZS5PZmZzZXQgPSByZXF1aXJlKCcuL09mZnNldCcpO1xyXG5FbGxpcHNlLk9mZnNldFBvaW50ID0gcmVxdWlyZSgnLi9PZmZzZXRQb2ludCcpO1xyXG5FbGxpcHNlLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVsbGlwc2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9pbmRleC5qcyIsInZhciBHZXRBbmdsZSA9IHJlcXVpcmUoJy4vR2V0QW5nbGUnKTtcclxudmFyIEZpbmRUID0gcmVxdWlyZSgnLi9GaW5kVCcpO1xyXG5cclxuLyoqXHJcbiogQ2FsY3VsYXRlIGFuZCByZXR1cm4gdGhlIGFuZ2xlLCBpbiByYWRpYW5zLCBvZiB0aGUgY3VydmVzIHRhbmdlbnQgYXQgdGhlIGdpdmVuIHBpeGVsIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZXMgbGVuZ3RoLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRBbmdsZVdpdGhEaXN0YW5jZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbZGlzdGFuY2U9MF0gLSBUaGUgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlIHRvIGdldCB0aGUgYW5nbGUgZnJvbSwgaW4gcGl4ZWxzLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGF0IHRoZSBzcGVjaWZpZWQgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlLiBUaGUgdmFsdWUgaXMgaW4gcmFkaWFucy5cclxuKi9cclxudmFyIEdldEFuZ2xlV2l0aERpc3RhbmNlID0gZnVuY3Rpb24gKGN1cnZlLCBkaXN0YW5jZSlcclxue1xyXG4gICAgaWYgKGRpc3RhbmNlID09PSB1bmRlZmluZWQpIHsgZGlzdGFuY2UgPSAwOyB9XHJcblxyXG4gICAgaWYgKGRpc3RhbmNlIDw9IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5fdjF5LCB0aGlzLl92MXgpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBHZXRBbmdsZShjdXJ2ZSwgRmluZFQoY3VydmUsIGRpc3RhbmNlKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEFuZ2xlV2l0aERpc3RhbmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0QW5nbGVXaXRoRGlzdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2hlcm1pdGUvR2V0QW5nbGVXaXRoRGlzdGFuY2UuanMiLCIvKipcclxuKiBHZXQgdGhlIGFuZ2xlIG9mIHRoZSBjdXJ2ZXMgZW50cnkgcG9pbnQuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldEVudHJ5VGFuZ2VudFxyXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fE9iamVjdH0gcG9pbnQgLSBUaGUgUGhhc2VyLlBvaW50IG9iamVjdCwgb3IgYW4gT2JqZWN0IHdpdGggcHVibGljIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMsIGluIHdoaWNoIHRoZSB0YW5nZW50IHZlY3RvciB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQuXHJcbiogQHJldHVybiB7UGhhc2VyLlBvaW50fSBBIFBvaW50IG9iamVjdCBjb250YWluaW5nIHRoZSB0YW5nZW50IHZlY3RvciBvZiB0aGlzIEhlcm1pdGUgY3VydmUuXHJcbiovXHJcbnZhciBHZXRFbnRyeVRhbmdlbnQgPSBmdW5jdGlvbiAoY3VydmUsIHBvaW50KVxyXG57XHJcbiAgICBwb2ludC54ID0gY3VydmUuX3YxeDtcclxuICAgIHBvaW50LnkgPSBjdXJ2ZS5fdjF5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0RW50cnlUYW5nZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0RW50cnlUYW5nZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxudmFyIEdldFBvaW50ID0gcmVxdWlyZSgnLi9HZXRQb2ludCcpO1xyXG52YXIgRmluZFQgPSByZXF1aXJlKCcuL0ZpbmRUJyk7XHJcblxyXG4vKipcclxuKiBHZXQgYSBwb2ludCBvbiB0aGUgY3VydmUgdXNpbmcgdGhlIGRpc3RhbmNlLCBpbiBwaXhlbHMsIGFsb25nIHRoZSBjdXJ2ZS5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZ2V0UG9pbnRXaXRoRGlzdGFuY2VcclxuKiBAcGFyYW0ge2ludGVnZXJ9IFtkaXN0YW5jZT0wXSAtIFRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgdG8gZ2V0IHRoZSBwb2ludCBmcm9tLCBnaXZlbiBpbiBwaXhlbHMuXHJcbiogQHBhcmFtIHtQaGFzZXIuUG9pbnR8T2JqZWN0fSBbcG9pbnRdIC0gQW4gb3B0aW9uYWwgUGhhc2VyLlBvaW50LCBvciBPYmplY3QgY29udGFpbmluZyBwdWJsaWMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy4gSWYgZ2l2ZW4gdGhlIHJlc3VsdGluZyB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIE9iamVjdHMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy4gSWYgb21pdHRlZCBhIG5ldyBQaGFzZXIuUG9pbnQgb2JqZWN0IGlzIGNyZWF0ZWQuXHJcbiogQHJldHVybiB7UGhhc2VyLlBvaW50fSBUaGUgcG9pbnQgb24gdGhlIGxpbmUgYXQgdGhlIHNwZWNpZmllZCAnZGlzdGFuY2UnIGFsb25nIHRoZSBjdXJ2ZS5cclxuKi9cclxudmFyIEdldFBvaW50V2l0aERpc3RhbmNlID0gZnVuY3Rpb24gKGN1cnZlLCBkaXN0YW5jZSwgb3V0KVxyXG57XHJcbiAgICBpZiAoZGlzdGFuY2UgPT09IHVuZGVmaW5lZCkgeyBkaXN0YW5jZSA9IDA7IH1cclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIGlmIChkaXN0YW5jZSA8PSAwKVxyXG4gICAge1xyXG4gICAgICAgIG91dC54ID0gdGhpcy5fcDF4O1xyXG4gICAgICAgIG91dC55ID0gdGhpcy5fcDF5O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIEdldFBvaW50KGN1cnZlLCBGaW5kVChjdXJ2ZSwgZGlzdGFuY2UpLCBvdXQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRQb2ludFdpdGhEaXN0YW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9oZXJtaXRlL0dldFBvaW50V2l0aERpc3RhbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL0dldFBvaW50V2l0aERpc3RhbmNlLmpzIiwiLyoqXHJcbiogR2V0IHRoZSBYIGNvbXBvbmVudCBvZiBhIHBvaW50IG9uIHRoZSBjdXJ2ZSBiYXNlZCBvbiB0aGUgYHRgICh0aW1lKSB2YWx1ZSwgd2hpY2ggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldFhcclxuKiBAcGFyYW0ge251bWJlcn0gW3Q9MF0gLSBUaGUgdGltZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgZnJvbSB3aGljaCB0byBleHRyYWN0IGEgcG9pbnQuIFRoaXMgaXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIHdoZXJlIDAgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlIGFuZCAxIHRoZSBlbmQuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgWCBjb21wb25lbnQgb2YgYSBwb2ludCBvbiB0aGUgY3VydmUgYmFzZWQgb24gdGhlIGB0YCAodGltZSkgdmFsdWUuXHJcbiovXHJcbnZhciBHZXRYID0gZnVuY3Rpb24gKGN1cnZlLCB0KVxyXG57XHJcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHQgPSAwO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0IDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHQgPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0MiA9IHQgKiB0O1xyXG4gICAgdmFyIHQzID0gdCAqIHQyO1xyXG5cclxuICAgIHJldHVybiAodDMgKiBjdXJ2ZS5fYXggKyB0MiAqIGN1cnZlLl9ieCArIHQgKiBjdXJ2ZS5fdjF4ICsgY3VydmUuX3AxeCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRYLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogR2V0IHRoZSBZIGNvbXBvbmVudCBvZiBhIHBvaW50IG9uIHRoZSBjdXJ2ZSBiYXNlZCBvbiB0aGUgYHRgICh0aW1lKSB2YWx1ZSwgd2hpY2ggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldFlcclxuKiBAcGFyYW0ge251bWJlcn0gW3Q9MF0gLSBUaGUgdGltZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgZnJvbSB3aGljaCB0byBleHRyYWN0IGEgcG9pbnQuIFRoaXMgaXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIHdoZXJlIDAgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlIGFuZCAxIHRoZSBlbmQuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgWSBjb21wb25lbnQgb2YgYSBwb2ludCBvbiB0aGUgY3VydmUgYmFzZWQgb24gdGhlIGB0YCAodGltZSkgdmFsdWUuXHJcbiovXHJcbnZhciBHZXRZID0gZnVuY3Rpb24gKGN1cnZlLCB0KVxyXG57XHJcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHQgPSAwO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0IDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHQgPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0MiA9IHQgKiB0O1xyXG4gICAgdmFyIHQzID0gdCAqIHQyO1xyXG5cclxuICAgIHJldHVybiAodDMgKiBjdXJ2ZS5fYXkgKyB0MiAqIGN1cnZlLl9ieSArIHQgKiBjdXJ2ZS5fdjF5ICsgY3VydmUuX3AxeSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRZLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGF1dGhvciAgICAgICBQZXRlIEJhcm9uIDxwZXRlQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogQSBkYXRhIHJlcHJlc2VudGF0aW9uIG9mIGEgSGVybWl0ZSBDdXJ2ZSAoc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfSGVybWl0ZV9zcGxpbmUpXHJcbiogXHJcbiogQSBIZXJtaXRlIGN1cnZlIGhhcyBhIHN0YXJ0IGFuZCBlbmQgcG9pbnQgYW5kIHRhbmdlbnQgdmVjdG9ycyBmb3IgYm90aCBvZiB0aGVtLlxyXG4qIFRoZSBjdXJ2ZSB3aWxsIGFsd2F5cyBwYXNzIHRocm91Z2ggdGhlIHR3byBjb250cm9sIHBvaW50cyBhbmQgdGhlIHNoYXBlIG9mIGl0IGlzIGNvbnRyb2xsZWRcclxuKiBieSB0aGUgbGVuZ3RoIGFuZCBkaXJlY3Rpb24gb2YgdGhlIHRhbmdlbnQgdmVjdG9ycy4gIEF0IHRoZSBjb250cm9sIHBvaW50cyB0aGUgY3VydmUgd2lsbFxyXG4qIGJlIGZhY2luZyBleGFjdGx5IGluIHRoZSB2ZWN0b3IgZGlyZWN0aW9uLlxyXG4qIFxyXG4qIEFzIHRoZXNlIGN1cnZlcyBjaGFuZ2Ugc3BlZWQgKHNwZWVkID0gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgc2VwYXJhdGVkIGJ5IGFuIGVxdWFsIGNoYW5nZSBpblxyXG4qICd0JyB2YWx1ZSAtIHNlZSBIZXJtaXRlLmdldFBvaW50KSB0aGlzIGNsYXNzIGF0dGVtcHRzIHRvIHJlZHVjZSB0aGUgdmFyaWF0aW9uIGJ5IHByZS1jYWxjdWxhdGluZ1xyXG4qIHRoZSBgYWNjdXJhY3lgIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlLiBUaGUgc3RyYWlnaHQtbGluZSBkaXN0YW5jZXMgdG8gdGhlc2UgcG9pbnRzIGFyZSBzdG9yZWRcclxuKiBpbiB0aGUgcHJpdmF0ZSAncG9pbnRzJyBhcnJheSwgYW5kIHRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZCBieSBIZXJtaXRlLmZpbmRUKCkgdG8gY29udmVydCBhIHBpeGVsXHJcbiogZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlIGludG8gYSAndGltZScgdmFsdWUuXHJcbiogXHJcbiogSGlnaGVyIGBhY2N1cmFjeWAgdmFsdWVzIHdpbGwgcmVzdWx0IGluIG1vcmUgZXZlbiBtb3ZlbWVudCwgYnV0IHJlcXVpcmUgbW9yZSBtZW1vcnkgZm9yIHRoZSBwb2ludHNcclxuKiBsaXN0LiA1IHdvcmtzLCBidXQgMTAgc2VlbXMgdG8gYmUgYW4gaWRlYWwgdmFsdWUgZm9yIHRoZSBsZW5ndGggb2YgY3VydmVzIGZvdW5kIGluIG1vc3QgZ2FtZXMgb25cclxuKiBhIGRlc2t0b3Agc2NyZWVuLiBJZiB5b3UgdXNlIHZlcnkgbG9uZyBjdXJ2ZXMgKG1vcmUgdGhhbiA0MDAgcGl4ZWxzKSB5b3UgbWF5IG5lZWQgdG8gaW5jcmVhc2VcclxuKiB0aGlzIHZhbHVlIGZ1cnRoZXIuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLkhlcm1pdGVcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge251bWJlcn0gcDF4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBwMXkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHAyeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHAyeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHYxeCAtIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHYxeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHYyeCAtIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB2MnkgLSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW2FjY3VyYWN5PTEwXSBUaGUgYW1vdW50IG9mIHBvaW50cyB0byBwcmUtY2FsY3VsYXRlIG9uIHRoZSBjdXJ2ZS5cclxuKi9cclxudmFyIEhlcm1pdGUgPSBmdW5jdGlvbiAocDF4LCBwMXksIHAyeCwgcDJ5LCB2MXgsIHYxeSwgdjJ4LCB2MnksIGFjY3VyYWN5KVxyXG57XHJcbiAgICBpZiAoYWNjdXJhY3kgPT09IHVuZGVmaW5lZCkgeyBhY2N1cmFjeSA9IDEwOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfYWNjdXJhY3kgLSBUaGUgYW1vdW50IG9mIHBvaW50cyB0byBwcmUtY2FsY3VsYXRlIG9uIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl9hY2N1cmFjeSA9IGFjY3VyYWN5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX3AxeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl9wMXggPSBwMXg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfcDF5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3AxeSA9IHAxeTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9wMnggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3AyeCA9IHAyeDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9wMnkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3AyeSA9IHAyeTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF92MXggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3YxeCA9IHYxeDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF92MXkgLSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3YxeSA9IHYxeTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF92MnggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl92MnggPSB2Mng7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjJ5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fdjJ5ID0gdjJ5O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHthcnJheX0gX3BvaW50cyAtIEEgbG9jYWwgYXJyYXkgb2YgY2FjaGVkIHBvaW50cy5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl9wb2ludHMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuUG9pbnR9IF90ZW1wMSAtIEEgbG9jYWwgY2FjaGVkIFBvaW50IG9iamVjdC5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl90ZW1wMSA9IG5ldyBQb2ludCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5Qb2ludH0gX3RlbXAyIC0gQSBsb2NhbCBjYWNoZWQgUG9pbnQgb2JqZWN0LlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3RlbXAyID0gbmV3IFBvaW50KCk7XHJcblxyXG4gICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG59O1xyXG5cclxuSGVybWl0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIZXJtaXRlO1xyXG5cclxuSGVybWl0ZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFBlcmZvcm1zIHRoZSBjdXJ2ZSBjYWxjdWxhdGlvbnMuXHJcbiAgICAqXHJcbiAgICAqIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgaWYgeW91IGNoYW5nZSBhbnkgb2YgdGhlIGN1cnZlcyBwdWJsaWMgcHJvcGVydGllcywgc3VjaCBhcyBgSGVybWl0ZS5wMXhgIG9yIGBIZXJtaXRlLnYyeWAuXHJcbiAgICAqXHJcbiAgICAqIElmIHlvdSBhZGp1c3QgYW55IG9mIHRoZSBpbnRlcm5hbCBwcml2YXRlIHZhbHVlcywgdGhlbiBjYWxsIHRoaXMgdG8gdXBkYXRlIHRoZSBwb2ludHMuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjcmVjYWxjdWxhdGVcclxuICAgICogQHJldHVybiB7UGhhc2VyLkhlcm1pdGV9IFRoaXMgb2JqZWN0LlxyXG4gICAgKi9cclxuICAgIHJlY2FsY3VsYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX2F4ID0gKDIgKiB0aGlzLl9wMXggLSAyICogdGhpcy5fcDJ4ICsgdGhpcy5fdjF4ICsgdGhpcy5fdjJ4KTtcclxuICAgICAgICB0aGlzLl9heSA9ICgyICogdGhpcy5fcDF5IC0gMiAqIHRoaXMuX3AyeSArIHRoaXMuX3YxeSArIHRoaXMuX3YyeSk7XHJcbiAgICAgICAgdGhpcy5fYnggPSAoLTMgKiB0aGlzLl9wMXggKyAzICogdGhpcy5fcDJ4IC0gMiAqIHRoaXMuX3YxeCAtIHRoaXMuX3YyeCk7XHJcbiAgICAgICAgdGhpcy5fYnkgPSAoLTMgKiB0aGlzLl9wMXkgKyAzICogdGhpcy5fcDJ5IC0gMiAqIHRoaXMuX3YxeSAtIHRoaXMuX3YyeSk7XHJcblxyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5jYWxjdWxhdGVFdmVuUG9pbnRzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENhbGN1bGF0ZSBhIG51bWJlciBvZiBwb2ludHMgYWxvbmcgdGhlIGN1cnZlLCBiYXNlZCBvbiBgSGVybWl0ZS5hY2N1cmFjeWAsIGFuZCBzdG9yZXMgdGhlbSBpbiB0aGUgcHJpdmF0ZSBgX3BvaW50c2AgYXJyYXkuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjY2FsY3VsYXRlRXZlblBvaW50c1xyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGN1cnZlIGFwcHJveGltYXRlZCBhcyBzdHJhaWdodCBsaW5lIGRpc3RhbmNlcyBiZXR3ZWVuIHRoZSBwb2ludHMuXHJcbiAgICAqL1xyXG4gICAgY2FsY3VsYXRlRXZlblBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgdG90YWxMZW5ndGggPSAwO1xyXG5cclxuICAgICAgICB0aGlzLl90ZW1wMS5zZXRUbygwLCAwKTsgICAgICAgICAgICAgICAgICAgIC8vICBwbnRcclxuICAgICAgICB0aGlzLl90ZW1wMi5zZXRUbyh0aGlzLl9wMXgsIHRoaXMuX3AxeSk7ICAgIC8vICBsYXN0UG50XHJcblxyXG4gICAgICAgIHRoaXMuX3BvaW50c1swXSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHRoaXMuX2FjY3VyYWN5OyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmdldFBvaW50KGkgLyB0aGlzLl9hY2N1cmFjeSwgdGhpcy5fdGVtcDEpO1xyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSB0aGlzLl90ZW1wMS5kaXN0YW5jZSh0aGlzLl90ZW1wMik7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50c1tpXSA9IHRvdGFsTGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLl90ZW1wMi5jb3B5RnJvbSh0aGlzLl90ZW1wMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG90YWxMZW5ndGg7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhlcm1pdGUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI2FjY3VyYWN5XHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhY2N1cmFjeSAtIFRoZSBhbW91bnQgb2YgcG9pbnRzIHRvIHByZS1jYWxjdWxhdGUgb24gdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIGFjY3VyYWN5OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY2N1cmFjeTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYWNjdXJhY3kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjY3VyYWN5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjcDF4XHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwMXggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cclxuICAgICovXHJcbiAgICBwMXg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcDF4O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wMXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3AxeCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSNwMXlcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHAxeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHAxeToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wMXk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3AxeSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcDF5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3AyeFxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcDJ4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHAyeDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wMng7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3AyeClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcDJ4ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3AyeVxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcDJ5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHAyeToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wMnk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3AyeSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcDJ5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3YxeFxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjF4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHYxeDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92MXg7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3YxeClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdjF4ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3YxeVxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjF5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHYxeToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92MXk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3YxeSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdjF5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3YyeFxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjJ4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cclxuICAgICovXHJcbiAgICB2Mng6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdjJ4O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92MngpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3YyeCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSN2MnlcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHYyeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCByZWNhbGN1bGF0ZSB0aGUgY3VydmUuXHJcbiAgICAqL1xyXG4gICAgdjJ5OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YyeTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdjJ5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92MnkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhlcm1pdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9IZXJtaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL0hlcm1pdGUuanMiLCIvLyAgUGhhc2VyLkdlb20uSGVybWl0ZVxyXG5cclxudmFyIEhlcm1pdGUgPSByZXF1aXJlKCcuL0hlcm1pdGUnKTtcclxuXHJcbkhlcm1pdGUuRmluZFQgPSByZXF1aXJlKCcuL0ZpbmRUJyk7XHJcbkhlcm1pdGUuR2V0QW5nbGUgPSByZXF1aXJlKCcuL0dldEFuZ2xlJyk7XHJcbkhlcm1pdGUuR2V0QW5nbGVXaXRoRGlzdGFuY2UgPSByZXF1aXJlKCcuL0dldEFuZ2xlV2l0aERpc3RhbmNlJyk7XHJcbkhlcm1pdGUuR2V0RW50cnlUYW5nZW50ID0gcmVxdWlyZSgnLi9HZXRFbnRyeVRhbmdlbnQnKTtcclxuSGVybWl0ZS5HZXRQb2ludCA9IHJlcXVpcmUoJy4vR2V0UG9pbnQnKTtcclxuSGVybWl0ZS5HZXRQb2ludFdpdGhEaXN0YW5jZSA9IHJlcXVpcmUoJy4vR2V0UG9pbnRXaXRoRGlzdGFuY2UnKTtcclxuSGVybWl0ZS5HZXRYID0gcmVxdWlyZSgnLi9HZXRYJyk7XHJcbkhlcm1pdGUuR2V0WSA9IHJlcXVpcmUoJy4vR2V0WScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIZXJtaXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2hlcm1pdGUvaW5kZXguanMiLCJ2YXIgRGlzdGFuY2VCZXR3ZWVuID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZUJldHdlZW4nKTtcclxuXHJcbnZhciBDaXJjbGVUb0NpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGVBLCBjaXJjbGVCKVxyXG57XHJcbiAgICByZXR1cm4gKERpc3RhbmNlQmV0d2VlbihjaXJjbGVBLngsIGNpcmNsZUEueSwgY2lyY2xlQi54LCBjaXJjbGVCLnkpIDw9IChjaXJjbGVBLnJhZGl1cyArIGNpcmNsZUIucmFkaXVzKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZVRvQ2lyY2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanMiLCJ2YXIgQ2lyY2xlVG9SZWN0YW5nbGUgPSBmdW5jdGlvbiAoY2lyY2xlLCByZWN0KVxyXG57XHJcbiAgICB2YXIgaGFsZldpZHRoID0gcmVjdC53aWR0aCAvIDI7XHJcbiAgICB2YXIgaGFsZkhlaWdodCA9IHJlY3QuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICB2YXIgY3ggPSBNYXRoLmFicyhjaXJjbGUueCAtIHJlY3QueCAtIGhhbGZXaWR0aCk7XHJcbiAgICB2YXIgeERpc3QgPSBoYWxmV2lkdGggKyBjaXJjbGUucmFkaXVzO1xyXG5cclxuICAgIGlmIChjeCA8PSBoYWxmV2lkdGggfHwgY3ggPiB4RGlzdClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGN5ID0gTWF0aC5hYnMoY2lyY2xlLnkgLSByZWN0LnkgLSBoYWxmSGVpZ2h0KTtcclxuICAgIHZhciB5RGlzdCA9IGhhbGZIZWlnaHQgKyBjaXJjbGUucmFkaXVzO1xyXG5cclxuICAgIGlmIChjeSA8PSBoYWxmSGVpZ2h0IHx8IGN5ID4geURpc3QpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4Q29ybmVyRGlzdCA9IGN4IC0gaGFsZldpZHRoO1xyXG4gICAgdmFyIHlDb3JuZXJEaXN0ID0gY3kgLSBoYWxmSGVpZ2h0O1xyXG4gICAgdmFyIHhDb3JuZXJEaXN0U3EgPSB4Q29ybmVyRGlzdCAqIHhDb3JuZXJEaXN0O1xyXG4gICAgdmFyIHlDb3JuZXJEaXN0U3EgPSB5Q29ybmVyRGlzdCAqIHlDb3JuZXJEaXN0O1xyXG4gICAgdmFyIG1heENvcm5lckRpc3RTcSA9IGNpcmNsZS5yYWRpdXMgKiBjaXJjbGUucmFkaXVzO1xyXG5cclxuICAgIHJldHVybiAoeENvcm5lckRpc3RTcSArIHlDb3JuZXJEaXN0U3EgPD0gbWF4Q29ybmVyRGlzdFNxKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlVG9SZWN0YW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XHJcbnZhciBSZWN0YW5nbGVUb1JlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlVG9SZWN0YW5nbGUnKTtcclxuXHJcbnZhciBHZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBvdXRwdXQpXHJcbntcclxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSBuZXcgUmVjdGFuZ2xlKCk7IH1cclxuXHJcbiAgICBpZiAoUmVjdGFuZ2xlVG9SZWN0YW5nbGUocmVjdEEsIHJlY3RCKSlcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQueCA9IE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpO1xyXG4gICAgICAgIG91dHB1dC55ID0gTWF0aC5tYXgocmVjdEEueSwgcmVjdEIueSk7XHJcbiAgICAgICAgb3V0cHV0LndpZHRoID0gTWF0aC5taW4ocmVjdEEucmlnaHQsIHJlY3RCLnJpZ2h0KSAtIG91dHB1dC54O1xyXG4gICAgICAgIG91dHB1dC5oZWlnaHQgPSBNYXRoLm1pbihyZWN0QS5ib3R0b20sIHJlY3RCLmJvdHRvbSkgLSBvdXRwdXQueTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2ludGVyc2VjdHMvR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uLmpzIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbnZhciBMaW5lVG9MaW5lID0gZnVuY3Rpb24gKGxpbmUxLCBsaW5lMiwgYXNTZWdtZW50LCBvdXQpXHJcbntcclxuICAgIGlmIChhc1NlZ21lbnQgPT09IHVuZGVmaW5lZCkgeyBhc1NlZ21lbnQgPSB0cnVlOyB9XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgYSA9IGxpbmUxLngxO1xyXG4gICAgdmFyIGIgPSBsaW5lMS55MTtcclxuXHJcbiAgICB2YXIgZSA9IGxpbmUxLngyO1xyXG4gICAgdmFyIGYgPSBsaW5lMS55MjtcclxuXHJcbiAgICB2YXIgYTEgPSBiLnkgLSBhLnk7XHJcbiAgICB2YXIgYTIgPSBmLnkgLSBlLnk7XHJcbiAgICB2YXIgYjEgPSBhLnggLSBiLng7XHJcbiAgICB2YXIgYjIgPSBlLnggLSBmLng7XHJcbiAgICB2YXIgYzEgPSAoYi54ICogYS55KSAtIChhLnggKiBiLnkpO1xyXG4gICAgdmFyIGMyID0gKGYueCAqIGUueSkgLSAoZS54ICogZi55KTtcclxuICAgIHZhciBkZW5vbSA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcclxuXHJcbiAgICBpZiAoZGVub20gPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgb3V0LnggPSAoKGIxICogYzIpIC0gKGIyICogYzEpKSAvIGRlbm9tO1xyXG4gICAgb3V0LnkgPSAoKGEyICogYzEpIC0gKGExICogYzIpKSAvIGRlbm9tO1xyXG5cclxuICAgIGlmIChhc1NlZ21lbnQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHVjID0gKChmLnkgLSBlLnkpICogKGIueCAtIGEueCkgLSAoZi54IC0gZS54KSAqIChiLnkgLSBhLnkpKTtcclxuICAgICAgICB2YXIgdWEgPSAoKChmLnggLSBlLngpICogKGEueSAtIGUueSkpIC0gKGYueSAtIGUueSkgKiAoYS54IC0gZS54KSkgLyB1YztcclxuICAgICAgICB2YXIgdWIgPSAoKChiLnggLSBhLngpICogKGEueSAtIGUueSkpIC0gKChiLnkgLSBhLnkpICogKGEueCAtIGUueCkpKSAvIHVjO1xyXG5cclxuICAgICAgICBpZiAodWEgPj0gMCAmJiB1YSA8PSAxICYmIHViID49IDAgJiYgdWIgPD0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVG9MaW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9MaW5lLmpzIiwiLyoqXHJcbiogQ2hlY2tzIGZvciBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgTGluZSBhbmQgYSBSZWN0YW5nbGUgc2hhcGUsIG9yIGEgcmVjdGFuZ2xlLWxpa2VcclxuKiBvYmplY3QsIHdpdGggcHVibGljIGB4YCwgYHlgLCBgcmlnaHRgIGFuZCBgYm90dG9tYCBwcm9wZXJ0aWVzLCBzdWNoIGFzIGEgU3ByaXRlIG9yIEJvZHkuXHJcbipcclxuKiBBbiBpbnRlcnNlY3Rpb24gaXMgY29uc2lkZXJlZCB2YWxpZCBpZjpcclxuKlxyXG4qIFRoZSBsaW5lIHN0YXJ0cyB3aXRoaW4sIG9yIGVuZHMgd2l0aGluLCB0aGUgUmVjdGFuZ2xlLlxyXG4qIFRoZSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyBvbmUgb2YgdGhlIDQgcmVjdGFuZ2xlIGVkZ2VzLlxyXG4qXHJcbiogVGhlIGZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBmdW5jdGlvbiByZWN0YW5nbGVzIGFyZSBjb25zaWRlcmVkICdzb2xpZCcuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5MaW5lLmludGVyc2VjdHNSZWN0YW5nbGVcclxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBsaW5lIC0gVGhlIGxpbmUgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoLlxyXG4qIEBwYXJhbSB7UGhhc2VyLlJlY3RhbmdsZXxvYmplY3R9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlLCBvciByZWN0YW5nbGUtbGlrZSBvYmplY3QsIHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aC5cclxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBsaW5lIGludGVyc2VjdHMgd2l0aCB0aGUgcmVjdGFuZ2xlIGVkZ2VzLCBvciBzdGFydHMgb3IgZW5kcyB3aXRoaW4gdGhlIHJlY3RhbmdsZS5cclxuKi9cclxudmFyIExpbmVUb1JlY3RhbmdsZSA9IGZ1bmN0aW9uIChsaW5lLCByZWN0KVxyXG57XHJcbiAgICB2YXIgeDEgPSBsaW5lLngxO1xyXG4gICAgdmFyIHkxID0gbGluZS55MjtcclxuXHJcbiAgICB2YXIgeDIgPSBsaW5lLngyO1xyXG4gICAgdmFyIHkyID0gbGluZS55MjtcclxuXHJcbiAgICB2YXIgYngxID0gcmVjdC54O1xyXG4gICAgdmFyIGJ5MSA9IHJlY3QueTtcclxuICAgIHZhciBieDIgPSByZWN0LnJpZ2h0O1xyXG4gICAgdmFyIGJ5MiA9IHJlY3QuYm90dG9tO1xyXG5cclxuICAgIHZhciB0ID0gMDtcclxuXHJcbiAgICAvLyAgSWYgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgbGluZSBpcyBpbnNpZGUgdGhlIHJlY3QgdGhlbiB3ZSBhc3N1bWVcclxuICAgIC8vICBjb2xsaXNpb24sIGFzIHJlY3RzIGFyZSBzb2xpZCBmb3Igb3VyIHVzZS1jYXNlLlxyXG5cclxuICAgIGlmICgoeDEgPj0gYngxICYmIHgxIDw9IGJ4MiAmJiB5MSA+PSBieTEgJiYgeTEgPD0gYnkyKSB8fFxyXG4gICAgICAgICh4MiA+PSBieDEgJiYgeDIgPD0gYngyICYmIHkyID49IGJ5MSAmJiB5MiA8PSBieTIpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh4MSA8IGJ4MSAmJiB4MiA+PSBieDEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIExlZnQgZWRnZVxyXG4gICAgICAgIHQgPSB5MSArICh5MiAtIHkxKSAqIChieDEgLSB4MSkgLyAoeDIgLSB4MSk7XHJcblxyXG4gICAgICAgIGlmICh0ID4gYnkxICYmIHQgPD0gYnkyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoeDEgPiBieDIgJiYgeDIgPD0gYngyKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBSaWdodCBlZGdlXHJcbiAgICAgICAgdCA9IHkxICsgKHkyIC0geTEpICogKGJ4MiAtIHgxKSAvICh4MiAtIHgxKTtcclxuXHJcbiAgICAgICAgaWYgKHQgPj0gYnkxICYmIHQgPD0gYnkyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh5MSA8IGJ5MSAmJiB5MiA+PSBieTEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRvcCBlZGdlXHJcbiAgICAgICAgdCA9IHgxICsgKHgyIC0geDEpICogKGJ5MSAtIHkxKSAvICh5MiAtIHkxKTtcclxuXHJcbiAgICAgICAgaWYgKHQgPj0gYngxICYmIHQgPD0gYngyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoeTEgPiBieTIgJiYgeTIgPD0gYnkyKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBCb3R0b20gZWRnZVxyXG4gICAgICAgIHQgPSB4MSArICh4MiAtIHgxKSAqIChieTIgLSB5MSkgLyAoeTIgLSB5MSk7XHJcblxyXG4gICAgICAgIGlmICh0ID49IGJ4MSAmJiB0IDw9IGJ4MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVUb1JlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludFRvTGluZSA9IHJlcXVpcmUoJy4vUG9pbnRUb0xpbmUnKTtcclxuXHJcbnZhciBQb2ludFRvTGluZVNlZ21lbnQgPSBmdW5jdGlvbiAocG9pbnQsIGxpbmUpXHJcbntcclxuICAgIGlmICghUG9pbnRUb0xpbmUocG9pbnQsIGxpbmUpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeE1pbiA9IE1hdGgubWluKGxpbmUueDEsIGxpbmUueDIpO1xyXG4gICAgdmFyIHhNYXggPSBNYXRoLm1heChsaW5lLngxLCBsaW5lLngyKTtcclxuICAgIHZhciB5TWluID0gTWF0aC5taW4obGluZS55MSwgbGluZS55Mik7XHJcbiAgICB2YXIgeU1heCA9IE1hdGgubWF4KGxpbmUueTEsIGxpbmUueTIpO1xyXG5cclxuICAgIHJldHVybiAoKHBvaW50LnggPj0geE1pbiAmJiBwb2ludC54IDw9IHhNYXgpICYmIChwb2ludC55ID49IHlNaW4gJiYgcG9pbnQueSA8PSB5TWF4KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50VG9MaW5lU2VnbWVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lU2VnbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZVNlZ21lbnQuanMiLCJ2YXIgUmVjdGFuZ2xlVG9WYWx1ZXMgPSBmdW5jdGlvbiAocmVjdCwgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCB0b2xlcmFuY2UpXHJcbntcclxuICAgIGlmICh0b2xlcmFuY2UgPT09IHVuZGVmaW5lZCkgeyB0b2xlcmFuY2UgPSAwOyB9XHJcblxyXG4gICAgcmV0dXJuICEoXHJcbiAgICAgICAgbGVmdCA+IHJlY3QucmlnaHQgKyB0b2xlcmFuY2UgfHxcclxuICAgICAgICByaWdodCA8IHJlY3QubGVmdCAtIHRvbGVyYW5jZSB8fFxyXG4gICAgICAgIHRvcCA+IHJlY3QuYm90dG9tICsgdG9sZXJhbmNlIHx8XHJcbiAgICAgICAgYm90dG9tIDwgcmVjdC50b3AgLSB0b2xlcmFuY2VcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZVRvVmFsdWVzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9WYWx1ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2lyY2xlVG9DaXJjbGU6IHJlcXVpcmUoJy4vQ2lyY2xlVG9DaXJjbGUnKSxcclxuICAgIENpcmNsZVRvUmVjdGFuZ2xlOiByZXF1aXJlKCcuL0NpcmNsZVRvUmVjdGFuZ2xlJyksXHJcbiAgICBHZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb246IHJlcXVpcmUoJy4vR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uJyksXHJcbiAgICBMaW5lVG9MaW5lOiByZXF1aXJlKCcuL0xpbmVUb0xpbmUnKSxcclxuICAgIExpbmVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9MaW5lVG9SZWN0YW5nbGUnKSxcclxuICAgIFBvaW50VG9MaW5lOiByZXF1aXJlKCcuL1BvaW50VG9MaW5lJyksXHJcbiAgICBQb2ludFRvTGluZVNlZ21lbnQ6IHJlcXVpcmUoJy4vUG9pbnRUb0xpbmVTZWdtZW50JyksXHJcbiAgICBSZWN0YW5nbGVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9SZWN0YW5nbGVUb1JlY3RhbmdsZScpLFxyXG4gICAgUmVjdGFuZ2xlVG9WYWx1ZXM6IHJlcXVpcmUoJy4vUmVjdGFuZ2xlVG9WYWx1ZXMnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9pbnRlcnNlY3RzL2luZGV4LmpzIiwiXHJcbnZhciBDZW50ZXJPbiA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5KVxyXG57XHJcbiAgICB2YXIgdHggPSB4IC0gKChsaW5lLngxICsgbGluZS54MikgLyAyKTtcclxuICAgIHZhciB0eSA9IHkgLSAoKGxpbmUueTEgKyBsaW5lLnkyKSAvIDIpO1xyXG5cclxuICAgIGxpbmUueDEgKz0gdHg7XHJcbiAgICBsaW5lLnkxICs9IHR5O1xyXG5cclxuICAgIGxpbmUueDIgKz0gdHg7XHJcbiAgICBsaW5lLnkyICs9IHR5O1xyXG5cclxuICAgIHJldHVybiBsaW5lO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpbmUgPSByZXF1aXJlKCcuL0xpbmUnKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXHJcbntcclxuICAgIHJldHVybiBuZXcgTGluZShzb3VyY2UueDEsIHNvdXJjZS55MSwgc291cmNlLngyLCBzb3VyY2UueTIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL0Nsb25lLmpzIiwiLyoqXHJcbiogQ29waWVzIHRoZSB4LCB5IGFuZCBkaWFtZXRlciBwcm9wZXJ0aWVzIGZyb20gYW55IGdpdmVuIG9iamVjdCB0byB0aGlzIENpcmNsZS5cclxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cclxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXHJcbiogQHJldHVybiB7Q2lyY2xlfSBUaGlzIENpcmNsZSBvYmplY3QuXHJcbiovXHJcbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54MSwgc291cmNlLnkxLCBzb3VyY2UueDIsIHNvdXJjZS55Mik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKGxpbmUsIHRvQ29tcGFyZSlcclxue1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICBsaW5lLngxID09PSB0b0NvbXBhcmUueDEgJiZcclxuICAgICAgICBsaW5lLnkxID09PSB0b0NvbXBhcmUueTEgJiZcclxuICAgICAgICBsaW5lLngyID09PSB0b0NvbXBhcmUueDIgJiZcclxuICAgICAgICBsaW5lLnkyID09PSB0b0NvbXBhcmUueTJcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgR2V0TWlkUG9pbnQgPSBmdW5jdGlvbiAobGluZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBvdXQueCA9IChsaW5lLngxICsgbGluZS54MikgLyAyO1xyXG4gICAgb3V0LnkgPSAobGluZS55MSArIGxpbmUueTIpIC8gMjtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRNaWRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0dldE1pZFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL0dldE1pZFBvaW50LmpzIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbnZhciBHZXROb3JtYWwgPSBmdW5jdGlvbiAobGluZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgYSA9IEFuZ2xlKGxpbmUpIC0gTUFUSF9DT05TVC5UQVU7XHJcblxyXG4gICAgb3V0LnggPSBNYXRoLmNvcyhhKTtcclxuICAgIG91dC55ID0gTWF0aC5zaW4oYSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Tm9ybWFsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvR2V0Tm9ybWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL0dldE5vcm1hbC5qcyIsIi8qKlxyXG4qIFVzaW5nIEJyZXNlbmhhbSdzIGxpbmUgYWxnb3JpdGhtIHRoaXMgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIGNvb3JkaW5hdGVzIG9uIHRoaXMgbGluZS5cclxuKiBUaGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIHJvdW5kZWQgYmVmb3JlIHRoaXMgcnVucyBhcyB0aGUgYWxnb3JpdGhtIHdvcmtzIG9uIGludGVnZXJzLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuTGluZSNjb29yZGluYXRlc09uTGluZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3RlcFJhdGU9MV0gLSBIb3cgbWFueSBzdGVwcyB3aWxsIHdlIHJldHVybj8gMSA9IGV2ZXJ5IGNvb3JkaW5hdGUgb24gdGhlIGxpbmUsIDIgPSBldmVyeSBvdGhlciBjb29yZGluYXRlLCBldGMuXHJcbiogQHBhcmFtIHthcnJheX0gW3Jlc3VsdHNdIC0gVGhlIGFycmF5IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLiBJZiBub3QgcHJvdmlkZWQgYSBuZXcgb25lIHdpbGwgYmUgZ2VuZXJhdGVkLlxyXG4qIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBjb29yZGluYXRlcy5cclxuKi9cclxudmFyIEdldFBvaW50c09uTGluZSA9IGZ1bmN0aW9uIChsaW5lLCBzdGVwUmF0ZSwgcmVzdWx0cylcclxue1xyXG4gICAgaWYgKHN0ZXBSYXRlID09PSB1bmRlZmluZWQpIHsgc3RlcFJhdGUgPSAxOyB9XHJcbiAgICBpZiAocmVzdWx0cyA9PT0gdW5kZWZpbmVkKSB7IHJlc3VsdHMgPSBbXTsgfVxyXG5cclxuICAgIHZhciB4MSA9IE1hdGgucm91bmQobGluZS54MSk7XHJcbiAgICB2YXIgeTEgPSBNYXRoLnJvdW5kKGxpbmUueTEpO1xyXG4gICAgdmFyIHgyID0gTWF0aC5yb3VuZChsaW5lLngyKTtcclxuICAgIHZhciB5MiA9IE1hdGgucm91bmQobGluZS55Mik7XHJcblxyXG4gICAgdmFyIGR4ID0gTWF0aC5hYnMoeDIgLSB4MSk7XHJcbiAgICB2YXIgZHkgPSBNYXRoLmFicyh5MiAtIHkxKTtcclxuICAgIHZhciBzeCA9ICh4MSA8IHgyKSA/IDEgOiAtMTtcclxuICAgIHZhciBzeSA9ICh5MSA8IHkyKSA/IDEgOiAtMTtcclxuICAgIHZhciBlcnIgPSBkeCAtIGR5O1xyXG5cclxuICAgIHJlc3VsdHMucHVzaChbIHgxLCB5MSBdKTtcclxuXHJcbiAgICB2YXIgaSA9IDE7XHJcblxyXG4gICAgd2hpbGUgKCEoKHgxID09PSB4MikgJiYgKHkxID09PSB5MikpKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBlMiA9IGVyciA8PCAxO1xyXG5cclxuICAgICAgICBpZiAoZTIgPiAtZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBlcnIgLT0gZHk7XHJcbiAgICAgICAgICAgIHgxICs9IHN4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGUyIDwgZHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBlcnIgKz0gZHg7XHJcbiAgICAgICAgICAgIHkxICs9IHN5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkgJSBzdGVwUmF0ZSA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChbIHgxLCB5MSBdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UG9pbnRzT25MaW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvR2V0UG9pbnRzT25MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEhlaWdodCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hYnMobGluZS55MSAtIGxpbmUueTIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIZWlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9IZWlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGVuZ3RoID0gZnVuY3Rpb24gKGxpbmUpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnNxcnQoKGxpbmUueDIgLSBsaW5lLngxKSAqIChsaW5lLngyIC0gbGluZS54MSkgKyAobGluZS55MiAtIGxpbmUueTEpICogKGxpbmUueTIgLSBsaW5lLnkxKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExlbmd0aDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0xlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XHJcblxyXG52YXIgTm9ybWFsWCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5jb3MoQW5nbGUobGluZSkgLSBNQVRIX0NPTlNULlRBVSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbFg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9Ob3JtYWxYLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL05vcm1hbFguanMiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcclxudmFyIEFuZ2xlID0gcmVxdWlyZSgnLi9BbmdsZScpO1xyXG5cclxudmFyIE5vcm1hbFkgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGguc2luKEFuZ2xlKGxpbmUpIC0gTUFUSF9DT05TVC5UQVUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTm9ybWFsWS5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9Ob3JtYWxZLmpzIiwidmFyIFBlcnBTbG9wZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gLSgobGluZS54MiAtIGxpbmUueDEpIC8gKGxpbmUueTIgLSBsaW5lLnkxKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBlcnBTbG9wZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1BlcnBTbG9wZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGxpbmUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIHQgPSBNYXRoLnJhbmRvbSgpO1xyXG5cclxuICAgIG91dC54ID0gbGluZS54MSArIHQgKiAobGluZS54MiAtIGxpbmUueDEpO1xyXG4gICAgb3V0LnkgPSBsaW5lLnkxICsgdCAqIChsaW5lLnkyIC0gbGluZS55MSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL1JhbmRvbS5qcyIsInZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxudmFyIE5vcm1hbEFuZ2xlID0gcmVxdWlyZSgnLi9Ob3JtYWxBbmdsZScpO1xyXG5cclxuLyoqXHJcbiogUmV0dXJucyB0aGUgcmVmbGVjdGVkIGFuZ2xlIGJldHdlZW4gdHdvIGxpbmVzLlxyXG4qIFRoaXMgaXMgdGhlIG91dGdvaW5nIGFuZ2xlIGJhc2VkIG9uIHRoZSBhbmdsZSBvZiBMaW5lIDEgYW5kIHRoZSBub3JtYWxBbmdsZSBvZiBMaW5lIDIuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5MaW5lLnJlZmxlY3RcclxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBhIC0gVGhlIGJhc2UgbGluZS5cclxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBiIC0gVGhlIGxpbmUgdG8gYmUgcmVmbGVjdGVkIGZyb20gdGhlIGJhc2UgbGluZS5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWZsZWN0ZWQgYW5nbGUgaW4gcmFkaWFucy5cclxuKi9cclxudmFyIFJlZmxlY3RBbmdsZSA9IGZ1bmN0aW9uIChsaW5lQSwgbGluZUIpXHJcbntcclxuICAgIHJldHVybiAoMiAqIE5vcm1hbEFuZ2xlKGxpbmVCKSAtIE1hdGguUEkgLSBBbmdsZShsaW5lQSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0QW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9SZWZsZWN0QW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvUmVmbGVjdEFuZ2xlLmpzIiwidmFyIFJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xyXG5cclxudmFyIFJvdGF0ZSA9IGZ1bmN0aW9uIChsaW5lLCBhbmdsZSlcclxue1xyXG4gICAgdmFyIHggPSAobGluZS54MSArIGxpbmUueDIpIC8gMjtcclxuICAgIHZhciB5ID0gKGxpbmUueTEgKyBsaW5lLnkyKSAvIDI7XHJcblxyXG4gICAgcmV0dXJuIFJvdGF0ZUFyb3VuZFhZKGxpbmUsIHgsIHksIGFuZ2xlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUm90YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL1JvdGF0ZS5qcyIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcclxuXHJcbnZhciBSb3RhdGVBcm91bmRQb2ludCA9IGZ1bmN0aW9uIChsaW5lLCBwb2ludCwgYW5nbGUpXHJcbntcclxuICAgIHJldHVybiBSb3RhdGVBcm91bmRYWShsaW5lLCBwb2ludC54LCBwb2ludC55LCBhbmdsZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCJ2YXIgU2V0VG9BbmdsZSA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5LCBhbmdsZSwgbGVuZ3RoKVxyXG57XHJcbiAgICBsaW5lLngxID0geDtcclxuICAgIGxpbmUueTEgPSB5O1xyXG5cclxuICAgIGxpbmUueDIgPSB4ICsgKE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCk7XHJcbiAgICBsaW5lLnkyID0geSArIChNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGgpO1xyXG5cclxuICAgIHJldHVybiBsaW5lO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRUb0FuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvU2V0VG9BbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbG9wZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gKGxpbmUueTIgLSBsaW5lLnkxKSAvIChsaW5lLngyIC0gbGluZS54MSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNsb3BlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvU2xvcGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgV2lkdGggPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKGxpbmUueDEgLSBsaW5lLngyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2lkdGg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9XaWR0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5MaW5lXHJcblxyXG52YXIgTGluZSA9IHJlcXVpcmUoJy4vTGluZScpO1xyXG5cclxuTGluZS5BbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxuTGluZS5DZW50ZXJPbiA9IHJlcXVpcmUoJy4vQ2VudGVyT24nKTtcclxuTGluZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuTGluZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcclxuTGluZS5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5MaW5lLkdldE1pZFBvaW50ID0gcmVxdWlyZSgnLi9HZXRNaWRQb2ludCcpO1xyXG5MaW5lLkdldE5vcm1hbCA9IHJlcXVpcmUoJy4vR2V0Tm9ybWFsJyk7XHJcbkxpbmUuR2V0UG9pbnRzT25MaW5lID0gcmVxdWlyZSgnLi9HZXRQb2ludHNPbkxpbmUnKTtcclxuTGluZS5IZWlnaHQgPSByZXF1aXJlKCcuL0hlaWdodCcpO1xyXG5MaW5lLkxlbmd0aCA9IHJlcXVpcmUoJy4vTGVuZ3RoJyk7XHJcbkxpbmUuTm9ybWFsQW5nbGUgPSByZXF1aXJlKCcuL05vcm1hbEFuZ2xlJyk7XHJcbkxpbmUuTm9ybWFsWCA9IHJlcXVpcmUoJy4vTm9ybWFsWCcpO1xyXG5MaW5lLk5vcm1hbFkgPSByZXF1aXJlKCcuL05vcm1hbFknKTtcclxuTGluZS5QZXJwU2xvcGUgPSByZXF1aXJlKCcuL1BlcnBTbG9wZScpO1xyXG5MaW5lLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XHJcbkxpbmUuUmVmbGVjdEFuZ2xlID0gcmVxdWlyZSgnLi9SZWZsZWN0QW5nbGUnKTtcclxuTGluZS5Sb3RhdGUgPSByZXF1aXJlKCcuL1JvdGF0ZScpO1xyXG5MaW5lLlJvdGF0ZUFyb3VuZFBvaW50ID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRQb2ludCcpO1xyXG5MaW5lLlJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xyXG5MaW5lLlNldFRvQW5nbGUgPSByZXF1aXJlKCcuL1NldFRvQW5nbGUnKTtcclxuTGluZS5TbG9wZSA9IHJlcXVpcmUoJy4vU2xvcGUnKTtcclxuTGluZS5XaWR0aCA9IHJlcXVpcmUoJy4vV2lkdGgnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL2luZGV4LmpzIiwidmFyIEFkZCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcclxue1xyXG4gICAgcG9pbnQueCArPSB4O1xyXG4gICAgcG9pbnQueSArPSB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0FkZC5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZWlsID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oTWF0aC5jZWlsKHBvaW50LngpLCBNYXRoLmNlaWwocG9pbnQueSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZWlsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHNvdXJjZS54LCBzb3VyY2UueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9DbG9uZS5qcyIsIi8qKlxyXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxyXG4qL1xyXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxyXG57XHJcbiAgICByZXR1cm4gZGVzdC5zZXRUbyhzb3VyY2UueCwgc291cmNlLnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDcm9zcyA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qilcclxue1xyXG4gICAgcmV0dXJuICgocG9pbnRBLnggKiBwb2ludEIueSkgLSAocG9pbnRBLnkgKiBwb2ludEIueCkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcm9zcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Dcm9zcy5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXZpZGUgPSBmdW5jdGlvbiAocG9pbnQsIHgsIHkpXHJcbntcclxuICAgIHBvaW50LnggLz0geDtcclxuICAgIHBvaW50LnkgLz0geTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpdmlkZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9EaXZpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKHBvaW50LCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAocG9pbnQueCA9PT0gdG9Db21wYXJlLnggJiYgcG9pbnQueSA9PT0gdG9Db21wYXJlLnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFcXVhbHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oTWF0aC5mbG9vcihwb2ludC54KSwgTWF0aC5mbG9vcihwb2ludC55KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0Zsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxudmFyIEdldENlbnRyb2lkID0gZnVuY3Rpb24gKHBvaW50cywgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldENlbnRyb2lkIHBvaW50cyBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGxlbiA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZXRDZW50cm9pZCBwb2ludHMgYXJyYXkgbXVzdCBub3QgYmUgZW1wdHknKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlbiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IHBvaW50c1swXS54O1xyXG4gICAgICAgIG91dC55ID0gcG9pbnRzWzBdLnk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dC54ICs9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICBvdXQueSArPSBwb2ludHNbaV0ueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG91dC54IC89IGxlbjtcclxuICAgICAgICBvdXQueSAvPSBsZW47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Q2VudHJvaWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvR2V0Q2VudHJvaWQuanNcbi8vIG1vZHVsZSBpZCA9IDE4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L0dldENlbnRyb2lkLmpzIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxudmFyIEludGVycG9sYXRlID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCB0LCBvdXQpXHJcbntcclxuICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHsgdCA9IDA7IH1cclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIG91dC54ID0gcG9pbnRBLnggKyAoKHBvaW50Qi54IC0gcG9pbnRBLngpICogdCk7XHJcbiAgICBvdXQueSA9IHBvaW50QS55ICsgKChwb2ludEIueSAtIHBvaW50QS55KSAqIHQpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludGVycG9sYXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0ludGVycG9sYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9JbnRlcnBvbGF0ZS5qcyIsIi8qKlxyXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxyXG4qL1xyXG52YXIgSW52ZXJ0ID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8ocG9pbnQueSwgcG9pbnQueCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludmVydDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9JbnZlcnQuanNcbi8vIG1vZHVsZSBpZCA9IDE4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgTmVnYXRpdmUgPSBmdW5jdGlvbiAocG9pbnQsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgcmV0dXJuIG91dC5zZXRUbygtcG9pbnQueCwgLXBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOZWdhdGl2ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9OZWdhdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvTmVnYXRpdmUuanMiLCJ2YXIgTm9ybWFsaXplUmlnaHRIYW5kID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8ocG9pbnQueSAqIC0xLCBwb2ludC54KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsaXplUmlnaHRIYW5kO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L05vcm1hbGl6ZVJpZ2h0SGFuZC5qc1xuLy8gbW9kdWxlIGlkID0gMTg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJwID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oLXBvaW50LnksIHBvaW50LngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1BlcnAuanNcbi8vIG1vZHVsZSBpZCA9IDE4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRG90ID0gcmVxdWlyZSgnLi9Eb3QnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG52YXIgR2V0TWFnbml0dWRlU3EgPSByZXF1aXJlKCcuL0dldE1hZ25pdHVkZVNxJyk7XHJcblxyXG52YXIgUHJvamVjdCA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qiwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgYW10ID0gRG90KHBvaW50QSwgcG9pbnRCKSAvIEdldE1hZ25pdHVkZVNxKHBvaW50Qik7XHJcblxyXG4gICAgaWYgKGFtdCAhPT0gMClcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IGFtdCAqIHBvaW50Qi54O1xyXG4gICAgICAgIG91dC55ID0gYW10ICogcG9pbnRCLnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Qcm9qZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9Qcm9qZWN0LmpzIiwidmFyIERvdCA9IHJlcXVpcmUoJy4vRG90Jyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcclxuXHJcbnZhciBQcm9qZWN0VW5pdCA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qiwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgYW10ID0gRG90KHBvaW50QSwgcG9pbnRCKTtcclxuXHJcbiAgICBpZiAoYW10ICE9PSAwKVxyXG4gICAge1xyXG4gICAgICAgIG91dC54ID0gYW10ICogcG9pbnRCLng7XHJcbiAgICAgICAgb3V0LnkgPSBhbXQgKiBwb2ludEIueTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0VW5pdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Qcm9qZWN0VW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvUHJvamVjdFVuaXQuanMiLCJ2YXIgUlBlcnAgPSBmdW5jdGlvbiAocG9pbnQpXHJcbntcclxuICAgIHJldHVybiBwb2ludC5zZXRUbyhwb2ludC55LCAtcG9pbnQueCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJQZXJwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1JQZXJwLmpzXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vTm9ybWFsaXplJyk7XHJcbnZhciBNdWx0aXBseSA9IHJlcXVpcmUoJy4vTXVsdGlwbHknKTtcclxuXHJcbnZhciBTZXRNYWduaXR1ZGUgPSBmdW5jdGlvbiAocG9pbnQsIG1hZ25pdHVkZSlcclxue1xyXG4gICAgTm9ybWFsaXplKHBvaW50KTtcclxuXHJcbiAgICByZXR1cm4gTXVsdGlwbHkocG9pbnQsIG1hZ25pdHVkZSwgbWFnbml0dWRlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0TWFnbml0dWRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvU2V0TWFnbml0dWRlLmpzIiwidmFyIFN1YnRyYWN0ID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5KVxyXG57XHJcbiAgICBwb2ludC54IC09IHg7XHJcbiAgICBwb2ludC55IC09IHk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdWJ0cmFjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9TdWJ0cmFjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5Qb2ludFxyXG5cclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxuUG9pbnQuQWRkID0gcmVxdWlyZSgnLi9BZGQnKTtcclxuUG9pbnQuQ2VpbCA9IHJlcXVpcmUoJy4vQ2VpbCcpO1xyXG5Qb2ludC5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuUG9pbnQuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcblBvaW50LkNyb3NzID0gcmVxdWlyZSgnLi9Dcm9zcycpO1xyXG5Qb2ludC5EaXZpZGUgPSByZXF1aXJlKCcuL0RpdmlkZScpO1xyXG5Qb2ludC5Eb3QgPSByZXF1aXJlKCcuL0RvdCcpO1xyXG5Qb2ludC5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5Qb2ludC5GbG9vciA9IHJlcXVpcmUoJy4vRmxvb3InKTtcclxuUG9pbnQuR2V0Q2VudHJvaWQgPSByZXF1aXJlKCcuL0dldENlbnRyb2lkJyk7XHJcblBvaW50LkdldE1hZ25pdHVkZSA9IHJlcXVpcmUoJy4vR2V0TWFnbml0dWRlJyk7XHJcblBvaW50LkdldE1hZ25pdHVkZVNxID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGVTcScpO1xyXG5Qb2ludC5JbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vSW50ZXJwb2xhdGUnKTtcclxuUG9pbnQuSW52ZXJ0ID0gcmVxdWlyZSgnLi9JbnZlcnQnKTtcclxuUG9pbnQuTXVsdGlwbHkgPSByZXF1aXJlKCcuL011bHRpcGx5Jyk7XHJcblBvaW50Lk5lZ2F0aXZlID0gcmVxdWlyZSgnLi9OZWdhdGl2ZScpO1xyXG5Qb2ludC5Ob3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xyXG5Qb2ludC5Ob3JtYWxpemVSaWdodEhhbmQgPSByZXF1aXJlKCcuL05vcm1hbGl6ZVJpZ2h0SGFuZCcpO1xyXG5Qb2ludC5QZXJwID0gcmVxdWlyZSgnLi9QZXJwJyk7XHJcblBvaW50LlByb2plY3QgPSByZXF1aXJlKCcuL1Byb2plY3QnKTtcclxuUG9pbnQuUHJvamVjdFVuaXQgPSByZXF1aXJlKCcuL1Byb2plY3RVbml0Jyk7XHJcblBvaW50LlJQZXJwID0gcmVxdWlyZSgnLi9SUGVycCcpO1xyXG5Qb2ludC5TZXRNYWduaXR1ZGUgPSByZXF1aXJlKCcuL1NldE1hZ25pdHVkZScpO1xyXG5Qb2ludC5TdWJ0cmFjdCA9IHJlcXVpcmUoJy4vU3VidHJhY3QnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L2luZGV4LmpzIiwidmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChwb2x5Z29uKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFBvbHlnb24ocG9seWdvbi5wb2ludHMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2x5Z29uL0Nsb25lLmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxuLyoqXHJcbiogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuUG9seWdvbiNjb250YWluc1xyXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdG8gdGVzdC5cclxuKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHBvbHlnb24sIG90aGVyd2lzZSBmYWxzZS5cclxuKi9cclxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocG9seWdvbiwgcG9pbnQpXHJcbntcclxuICAgIHJldHVybiBDb250YWlucyhwb2x5Z29uLCBwb2ludC54LCBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qcyIsIlxyXG52YXIgR2V0QUFCQiA9IGZ1bmN0aW9uIChwb2x5Z29uKVxyXG57XHJcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcclxuICAgIHZhciBtYXhYID0gLW1pblg7XHJcbiAgICB2YXIgbWF4WSA9IC1taW5ZO1xyXG4gICAgdmFyIHA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBwID0gcG9seWdvbi5wb2ludHNbaV07XHJcblxyXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBwLngpO1xyXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwLnkpO1xyXG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLngpO1xyXG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBwLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogbWluWCxcclxuICAgICAgICB5OiBtaW5ZLFxyXG4gICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcclxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBQUJCO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvbHlnb24vR2V0QUFCQi5qc1xuLy8gbW9kdWxlIGlkID0gMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBFeHBvcnQgdGhlIHBvaW50cyBhcyBhbiBhcnJheSBvZiBmbGF0IG51bWJlcnMsIGZvbGxvd2luZyB0aGUgc2VxdWVuY2UgWyB4LHksIHgseSwgeCx5IF1cclxuICpcclxuICogQG1ldGhvZCBQaGFzZXIuUG9seWdvbiN0b051bWJlckFycmF5XHJcbiAqIEBwYXJhbSB7YXJyYXl9IFtvdXRwdXRdIC0gVGhlIGFycmF5IHRvIGFwcGVuZCB0aGUgcG9pbnRzIHRvLiBJZiBub3Qgc3BlY2lmaWVkIGEgbmV3IGFycmF5IHdpbGwgYmUgY3JlYXRlZC5cclxuICogQHJldHVybiB7YXJyYXl9IFRoZSBmbGF0dGVuZWQgYXJyYXkuXHJcbiAqL1xyXG52YXIgR2V0TnVtYmVyQXJyYXkgPSBmdW5jdGlvbiAocG9seWdvbiwgb3V0cHV0KVxyXG57XHJcbiAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHsgb3V0cHV0ID0gW107IH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ucG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5wdXNoKHBvbHlnb24ucG9pbnRzW2ldLngpO1xyXG4gICAgICAgIG91dHB1dC5wdXNoKHBvbHlnb24ucG9pbnRzW2ldLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE51bWJlckFycmF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvbHlnb24vR2V0TnVtYmVyQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdlb20uUG9seWdvblxyXG5cclxudmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcclxuXHJcblBvbHlnb24uQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcblBvbHlnb24uQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblBvbHlnb24uQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xyXG5Qb2x5Z29uLkdldEFBQkIgPSByZXF1aXJlKCcuL0dldEFBQkInKTtcclxuUG9seWdvbi5HZXROdW1iZXJBcnJheSA9IHJlcXVpcmUoJy4vR2V0TnVtYmVyQXJyYXknKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2x5Z29uL2luZGV4LmpzIiwidmFyIEFyZWEgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmV0dXJuIHJlY3Qud2lkdGggKiByZWN0LmhlaWdodDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXJlYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQXJlYS5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZWlsID0gZnVuY3Rpb24gKHJlY3QpXHJcbntcclxuICAgIHJlY3QueCA9IE1hdGguY2VpbChyZWN0LngpO1xyXG4gICAgcmVjdC55ID0gTWF0aC5jZWlsKHJlY3QueSk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlaWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbEFsbCA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZWN0LnggPSBNYXRoLmNlaWwocmVjdC54KTtcclxuICAgIHJlY3QueSA9IE1hdGguY2VpbChyZWN0LnkpO1xyXG4gICAgcmVjdC53aWR0aCA9IE1hdGguY2VpbChyZWN0LndpZHRoKTtcclxuICAgIHJlY3QuaGVpZ2h0ID0gTWF0aC5jZWlsKHJlY3QuaGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VpbEFsbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQ2VpbEFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENlbnRlcnMgdGhpcyBSZWN0YW5nbGUgc28gdGhhdCB0aGUgY2VudGVyIGNvb3JkaW5hdGVzIG1hdGNoIHRoZSBnaXZlbiB4IGFuZCB5IHZhbHVlcy5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlJlY3RhbmdsZSNjZW50ZXJPblxyXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSB0byBwbGFjZSB0aGUgY2VudGVyIG9mIHRoZSBSZWN0YW5nbGUgYXQuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIHRvIHBsYWNlIHRoZSBjZW50ZXIgb2YgdGhlIFJlY3RhbmdsZSBhdC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuUmVjdGFuZ2xlfSBUaGlzIFJlY3RhbmdsZSBvYmplY3RcclxuKi9cclxudmFyIENlbnRlck9uID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIHJlY3QueCA9IHggLSAocmVjdC53aWR0aCAvIDIpO1xyXG4gICAgcmVjdC55ID0geSAtIChyZWN0LmhlaWdodCAvIDIpO1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQ2VudGVyT24uanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXHJcbntcclxuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvQ2xvbmUuanMiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgQ29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChyZWN0LCBwb2ludClcclxue1xyXG4gICAgcmV0dXJuIENvbnRhaW5zKHJlY3QsIHBvaW50LngsIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9Db250YWluc1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNQb2ludC5qcyIsIi8vICBDaGVja3MgaWYgcmVjdEIgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiByZWN0QVxyXG5cclxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIpXHJcbntcclxuICAgIC8vICBWb2x1bWUgY2hlY2sgKGlmIHJlY3RCIHZvbHVtZSA+IHJlY3RBIHRoZW4gcmVjdEEgY2Fubm90IGNvbnRhaW4gaXQpXHJcbiAgICBpZiAoKHJlY3RCLndpZHRoICogcmVjdEIuaGVpZ2h0KSA+IChyZWN0QS53aWR0aCAqIHJlY3RBLmhlaWdodCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVyblxyXG4gICAgICAgIChcclxuICAgICAgICAgICAgKHJlY3RCLnggPiByZWN0QS54ICYmIHJlY3RCLnggPCByZWN0QS5yaWdodCkgJiYgXHJcbiAgICAgICAgICAgIChyZWN0Qi5yaWdodCA+IHJlY3RBLnggJiYgcmVjdEIucmlnaHQgPCByZWN0QS5yaWdodClcclxuICAgICAgICApICYmIChcclxuICAgICAgICAgICAgKHJlY3RCLnkgPiByZWN0QS55ICYmIHJlY3RCLnkgPCByZWN0QS5ib3R0b20pICYmIFxyXG4gICAgICAgICAgICAocmVjdEIuYm90dG9tID4gcmVjdEEueSAmJiByZWN0Qi5ib3R0b20gPCByZWN0QS5ib3R0b20pXHJcbiAgICAgICAgKTtcclxuICAgIFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1JlY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxyXG4qL1xyXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxyXG57XHJcbiAgICByZXR1cm4gZGVzdC5zZXRUbyhzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMjA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAocmVjdCwgdG9Db21wYXJlKVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHJlY3QueCA9PT0gdG9Db21wYXJlLnggJiZcclxuICAgICAgICByZWN0LnkgPT09IHRvQ29tcGFyZS55ICYmXHJcbiAgICAgICAgcmVjdC53aWR0aCA9PT0gdG9Db21wYXJlLndpZHRoICYmXHJcbiAgICAgICAgcmVjdC5oZWlnaHQgPT09IHRvQ29tcGFyZS5oZWlnaHRcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEFzcGVjdFJhdGlvID0gcmVxdWlyZSgnLi9HZXRBc3BlY3RSYXRpbycpO1xyXG5cclxuLy8gIEZpdHMgdGhlIHRhcmdldCByZWN0YW5nbGUgaW50byB0aGUgc291cmNlIHJlY3RhbmdsZS5cclxuLy8gIFByZXNlcnZlcyBhc3BlY3QgcmF0aW8uXHJcbi8vICBTY2FsZXMgYW5kIGNlbnRlcnMgdGhlIHRhcmdldCByZWN0YW5nbGUgdG8gdGhlIHNvdXJjZSByZWN0YW5nbGVcclxuXHJcbnZhciBGaXRJbnNpZGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpXHJcbntcclxuICAgIHZhciByYXRpbyA9IEdldEFzcGVjdFJhdGlvKHRhcmdldCk7XHJcblxyXG4gICAgaWYgKHJhdGlvIDwgR2V0QXNwZWN0UmF0aW8oc291cmNlKSlcclxuICAgIHtcclxuICAgICAgICAvLyAgVGFsbGVyIHRoYW4gV2lkZVxyXG4gICAgICAgIHRhcmdldC5zZXRTaXplKHNvdXJjZS5oZWlnaHQgKiByYXRpbywgc291cmNlLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFdpZGVyIHRoYW4gVGFsbFxyXG4gICAgICAgIHRhcmdldC5zZXRTaXplKHNvdXJjZS53aWR0aCwgc291cmNlLndpZHRoICogcmF0aW8pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXQuc2V0UG9zaXRpb24oXHJcbiAgICAgICAgKHNvdXJjZS5yaWdodCAvIDIpIC0gKHRhcmdldC53aWR0aCAvIDIpLFxyXG4gICAgICAgIChzb3VyY2UuYm90dG9tIC8gMikgLSAodGFyZ2V0LmhlaWdodCAvIDIpXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaXRJbnNpZGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0ZpdEluc2lkZS5qc1xuLy8gbW9kdWxlIGlkID0gMjA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL0ZpdEluc2lkZS5qcyIsInZhciBHZXRBc3BlY3RSYXRpbyA9IHJlcXVpcmUoJy4vR2V0QXNwZWN0UmF0aW8nKTtcclxuXHJcbi8vICBGaXRzIHRoZSB0YXJnZXQgcmVjdGFuZ2xlIGFyb3VuZCB0aGUgc291cmNlIHJlY3RhbmdsZS5cclxuLy8gIFByZXNlcnZlcyBhc3BlY3QgcmF0aW9uLlxyXG4vLyAgU2NhbGVzIGFuZCBjZW50ZXJzIHRoZSB0YXJnZXQgcmVjdGFuZ2xlIHRvIHRoZSBzb3VyY2UgcmVjdGFuZ2xlXHJcblxyXG52YXIgRml0T3V0c2lkZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSlcclxue1xyXG4gICAgdmFyIHJhdGlvID0gR2V0QXNwZWN0UmF0aW8odGFyZ2V0KTtcclxuXHJcbiAgICBpZiAocmF0aW8gPiBHZXRBc3BlY3RSYXRpbyhzb3VyY2UpKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBXaWRlciB0aGFuIFRhbGxcclxuICAgICAgICB0YXJnZXQuc2V0U2l6ZShzb3VyY2UuaGVpZ2h0ICogcmF0aW8sIHNvdXJjZS5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUYWxsZXIgdGhhbiBXaWRlXHJcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLndpZHRoLCBzb3VyY2Uud2lkdGggKiByYXRpbyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldC5zZXRQb3NpdGlvbihcclxuICAgICAgICAoc291cmNlLnJpZ2h0IC8gMikgLSB0YXJnZXQud2lkdGggLyAyLFxyXG4gICAgICAgIChzb3VyY2UuYm90dG9tIC8gMikgLSB0YXJnZXQuaGVpZ2h0IC8gMlxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRml0T3V0c2lkZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvRml0T3V0c2lkZS5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL0ZpdE91dHNpZGUuanMiLCJ2YXIgRmxvb3IgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmVjdC54ID0gTWF0aC5mbG9vcihyZWN0LngpO1xyXG4gICAgcmVjdC55ID0gTWF0aC5mbG9vcihyZWN0LnkpO1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvRmxvb3IuanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvb3JBbGwgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmVjdC54ID0gTWF0aC5mbG9vcihyZWN0LngpO1xyXG4gICAgcmVjdC55ID0gTWF0aC5mbG9vcihyZWN0LnkpO1xyXG4gICAgcmVjdC53aWR0aCA9IE1hdGguZmxvb3IocmVjdC53aWR0aCk7XHJcbiAgICByZWN0LmhlaWdodCA9IE1hdGguZmxvb3IocmVjdC5oZWlnaHQpO1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9vckFsbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvRmxvb3JBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgVGhlIGNlbnRlciBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCwgZXhwcmVzc2VkIGFzIGEgUG9pbnQgb2JqZWN0IFxyXG5cclxudmFyIEdldENlbnRlciA9IGZ1bmN0aW9uIChyZWN0LCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIG91dC54ID0gcmVjdC5yaWdodCAvIDI7XHJcbiAgICBvdXQueSA9IHJlY3QuYm90dG9tIC8gMjtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRDZW50ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0dldENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGUgc2l6ZSBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCwgZXhwcmVzc2VkIGFzIGEgUG9pbnQgb2JqZWN0IFxyXG4vLyAgd2l0aCB0aGUgdmFsdWVzIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXMuXHJcblxyXG52YXIgR2V0U2l6ZSA9IGZ1bmN0aW9uIChyZWN0LCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIG91dC54ID0gcmVjdC53aWR0aDtcclxuICAgIG91dC55ID0gcmVjdC5oZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0U2l6ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvR2V0U2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBJbmNyZWFzZXMgdGhlIHNpemUgb2YgdGhlIFJlY3RhbmdsZSBvYmplY3QgYnkgdGhlIHNwZWNpZmllZCBhbW91bnRzLlxyXG4vLyAgVGhlIGNlbnRlciBwb2ludCBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCBzdGF5cyB0aGUgc2FtZSwgYW5kIGl0cyBzaXplIGluY3JlYXNlcyBcclxuLy8gIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBieSB0aGUgeCB2YWx1ZSwgYW5kIHRvIHRoZSB0b3AgYW5kIHRoZSBib3R0b20gYnkgdGhlIHkgdmFsdWUuXHJcblxyXG52YXIgSW5mbGF0ZSA9IGZ1bmN0aW9uIChyZWN0LCB4LCB5KVxyXG57XHJcbiAgICAvLyAgR2V0IHRoZSBjdXJyZW50IGNlbnRlclxyXG4gICAgdmFyIGN4ID0gcmVjdC54ICsgKHJlY3Qud2lkdGggLyAyKTtcclxuICAgIHZhciBjeSA9IHJlY3QueSArIChyZWN0LmhlaWdodCAvIDIpO1xyXG5cclxuICAgIC8vICBJbmZsYXRlXHJcbiAgICByZWN0LndpZHRoID0gMiAqIHg7XHJcbiAgICByZWN0LmhlaWdodCA9IDIgKiB5O1xyXG5cclxuICAgIHJlY3QueCA9IHggLSAocmVjdC53aWR0aCAvIDIpO1xyXG4gICAgcmVjdC55ID0geSAtIChyZWN0LmhlaWdodCAvIDIpO1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmZsYXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9JbmZsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIE1lcmdlcyB0aGUgdGFyZ2V0IFJlY3RhbmdsZSB3aXRoIGEgbGlzdCBvZiBwb2ludHMuXHJcbi8vICBUaGUgcG9pbnRzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXMuXHJcblxyXG52YXIgTWVyZ2VQb2ludHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBwb2ludHMpXHJcbntcclxuICAgIHZhciBtaW5YID0gdGFyZ2V0Lng7XHJcbiAgICB2YXIgbWF4WCA9IHRhcmdldC5yaWdodDtcclxuICAgIHZhciBtaW5ZID0gdGFyZ2V0Lnk7XHJcbiAgICB2YXIgbWF4WSA9IHRhcmdldC5ib3R0b207XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHBvaW50c1tpXS54KTtcclxuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcG9pbnRzW2ldLngpO1xyXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwb2ludHNbaV0ueSk7XHJcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHBvaW50c1tpXS55KTtcclxuICAgIH1cclxuXHJcbiAgICB0YXJnZXQueCA9IG1pblg7XHJcbiAgICB0YXJnZXQueSA9IG1pblk7XHJcbiAgICB0YXJnZXQud2lkdGggPSBtYXhYIC0gbWluWDtcclxuICAgIHRhcmdldC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVBvaW50cztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VQb2ludHMuanNcbi8vIG1vZHVsZSBpZCA9IDIxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgTWVyZ2VzIHNvdXJjZSByZWN0YW5nbGUgaW50byB0YXJnZXQgcmVjdGFuZ2xlIGFuZCByZXR1cm5zIHRhcmdldFxyXG4vLyAgTmVpdGhlciByZWN0IHNob3VsZCBoYXZlIG5lZ2F0aXZlIHdpZHRocyBvciBoZWlnaHRzXHJcblxyXG52YXIgTWVyZ2VSZWN0ID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKVxyXG57XHJcbiAgICB2YXIgbWluWCA9IE1hdGgubWluKHRhcmdldC54LCBzb3VyY2UueCk7XHJcbiAgICB2YXIgbWF4WCA9IE1hdGgubWF4KHRhcmdldC5yaWdodCwgc291cmNlLnJpZ2h0KTtcclxuXHJcbiAgICB0YXJnZXQueCA9IG1pblg7XHJcbiAgICB0YXJnZXQud2lkdGggPSBtYXhYIC0gbWluWDtcclxuXHJcbiAgICB2YXIgbWluWSA9IE1hdGgubWluKHRhcmdldC55LCBzb3VyY2UueSk7XHJcbiAgICB2YXIgbWF4WSA9IE1hdGgubWF4KHRhcmdldC5ib3R0b20sIHNvdXJjZS5ib3R0b20pO1xyXG5cclxuICAgIHRhcmdldC55ID0gbWluWTtcclxuICAgIHRhcmdldC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVJlY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL01lcmdlUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgTWVyZ2VYWSA9IGZ1bmN0aW9uICh0YXJnZXQsIHgsIHkpXHJcbntcclxuICAgIHZhciBtaW5YID0gTWF0aC5taW4odGFyZ2V0LngsIHgpO1xyXG4gICAgdmFyIG1heFggPSBNYXRoLm1heCh0YXJnZXQucmlnaHQsIHgpO1xyXG5cclxuICAgIHRhcmdldC54ID0gbWluWDtcclxuICAgIHRhcmdldC53aWR0aCA9IG1heFggLSBtaW5YO1xyXG5cclxuICAgIHZhciBtaW5ZID0gTWF0aC5taW4odGFyZ2V0LnksIHkpO1xyXG4gICAgdmFyIG1heFkgPSBNYXRoLm1heCh0YXJnZXQuYm90dG9tLCB5KTtcclxuXHJcbiAgICB0YXJnZXQueSA9IG1pblk7XHJcbiAgICB0YXJnZXQuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVyZ2VYWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VYWS5qc1xuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXQgPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcclxue1xyXG4gICAgcmVjdC54ICs9IHg7XHJcbiAgICByZWN0LnkgKz0geTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9PZmZzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0UG9pbnQgPSBmdW5jdGlvbiAocmVjdCwgcG9pbnQpXHJcbntcclxuICAgIHJlY3QueCArPSBwb2ludC54O1xyXG4gICAgcmVjdC55ICs9IHBvaW50Lnk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9PZmZzZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMjE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPdmVybGFwcyA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgcmVjdEEueCA8IHJlY3RCLnJpZ2h0ICYmIFxyXG4gICAgICAgIHJlY3RBLnJpZ2h0ID4gcmVjdEIueCAmJiBcclxuICAgICAgICByZWN0QS55IDwgcmVjdEIuYm90dG9tICYmIFxyXG4gICAgICAgIHJlY3RBLmJvdHRvbSA+IHJlY3RCLnlcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9PdmVybGFwcy5qc1xuLy8gbW9kdWxlIGlkID0gMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJpbWV0ZXIgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmV0dXJuIDIgKiAocmVjdC53aWR0aCArIHJlY3QuaGVpZ2h0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGVyaW1ldGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9QZXJpbWV0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xyXG5cclxudmFyIFJhbmRvbSA9IGZ1bmN0aW9uIChyZWN0LCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIG91dC54ID0gcmVjdC54ICsgKE1hdGgucmFuZG9tKCkgKiByZWN0LndpZHRoKTtcclxuICAgIG91dC55ID0gcmVjdC55ICsgKE1hdGgucmFuZG9tKCkgKiByZWN0LmhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9SYW5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDIyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3JlY3RhbmdsZS9SYW5kb20uanMiLCIvKipcclxuKiBTY2FsZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhpcyBSZWN0YW5nbGUgYnkgdGhlIGdpdmVuIGFtb3VudHMuXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuUmVjdGFuZ2xlI3NjYWxlXHJcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgYW1vdW50IHRvIHNjYWxlIHRoZSB3aWR0aCBvZiB0aGUgUmVjdGFuZ2xlIGJ5LiBBIHZhbHVlIG9mIDAuNSB3b3VsZCByZWR1Y2UgYnkgaGFsZiwgYSB2YWx1ZSBvZiAyIHdvdWxkIGRvdWJsZSB0aGUgd2lkdGgsIGV0Yy5cclxuKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gVGhlIGFtb3VudCB0byBzY2FsZSB0aGUgaGVpZ2h0IG9mIHRoZSBSZWN0YW5nbGUgYnkuIEEgdmFsdWUgb2YgMC41IHdvdWxkIHJlZHVjZSBieSBoYWxmLCBhIHZhbHVlIG9mIDIgd291bGQgZG91YmxlIHRoZSBoZWlnaHQsIGV0Yy5cclxuKiBAcmV0dXJuIHtQaGFzZXIuUmVjdGFuZ2xlfSBUaGlzIFJlY3RhbmdsZSBvYmplY3RcclxuKi9cclxudmFyIFNjYWxlID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICByZWN0LndpZHRoICo9IHg7XHJcbiAgICByZWN0LmhlaWdodCAqPSB5O1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTY2FsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvU2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKTtcclxuXHJcbnZhciBVbmlvbiA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIG91dHB1dClcclxue1xyXG4gICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7IG91dHB1dCA9IFJlY3RhbmdsZSgpOyB9XHJcblxyXG4gICAgdmFyIHggPSBNYXRoLm1pbihyZWN0QS54LCByZWN0Qi54KTtcclxuICAgIHZhciB5ID0gTWF0aC5taW4ocmVjdEEueSwgcmVjdEIueSk7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dC5zZXQoXHJcbiAgICAgICAgeCxcclxuICAgICAgICB5LFxyXG4gICAgICAgIE1hdGgubWF4KHJlY3RBLnJpZ2h0LCByZWN0Qi5yaWdodCkgLSB4LFxyXG4gICAgICAgIE1hdGgubWF4KHJlY3RBLmJvdHRvbSwgcmVjdEIuYm90dG9tKSAtIHlcclxuICAgICk7XHJcbiAgICBcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVW5pb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL1VuaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvVW5pb24uanMiLCIvLyAgUGhhc2VyLkdlb20uUmVjdGFuZ2xlXHJcblxyXG52YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKTtcclxuXHJcblJlY3RhbmdsZS5BcmVhID0gcmVxdWlyZSgnLi9BcmVhJyk7XHJcblJlY3RhbmdsZS5DZWlsID0gcmVxdWlyZSgnLi9DZWlsJyk7XHJcblJlY3RhbmdsZS5DZWlsQWxsID0gcmVxdWlyZSgnLi9DZWlsQWxsJyk7XHJcblJlY3RhbmdsZS5DZW50ZXJPbiA9IHJlcXVpcmUoJy4vQ2VudGVyT24nKTtcclxuUmVjdGFuZ2xlLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5SZWN0YW5nbGUuQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblJlY3RhbmdsZS5Db250YWluc1BvaW50ID0gcmVxdWlyZSgnLi9Db250YWluc1BvaW50Jyk7XHJcblJlY3RhbmdsZS5Db250YWluc1JlY3QgPSByZXF1aXJlKCcuL0NvbnRhaW5zUmVjdCcpO1xyXG5SZWN0YW5nbGUuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcblJlY3RhbmdsZS5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5SZWN0YW5nbGUuRml0SW5zaWRlID0gcmVxdWlyZSgnLi9GaXRJbnNpZGUnKTtcclxuUmVjdGFuZ2xlLkZpdE91dHNpZGUgPSByZXF1aXJlKCcuL0ZpdE91dHNpZGUnKTtcclxuUmVjdGFuZ2xlLkZsb29yID0gcmVxdWlyZSgnLi9GbG9vcicpO1xyXG5SZWN0YW5nbGUuRmxvb3JBbGwgPSByZXF1aXJlKCcuL0Zsb29yQWxsJyk7XHJcblJlY3RhbmdsZS5HZXRBc3BlY3RSYXRpbyA9IHJlcXVpcmUoJy4vR2V0QXNwZWN0UmF0aW8nKTtcclxuUmVjdGFuZ2xlLkdldENlbnRlciA9IHJlcXVpcmUoJy4vR2V0Q2VudGVyJyk7XHJcblJlY3RhbmdsZS5HZXRTaXplID0gcmVxdWlyZSgnLi9HZXRTaXplJyk7XHJcblJlY3RhbmdsZS5JbmZsYXRlID0gcmVxdWlyZSgnLi9JbmZsYXRlJyk7XHJcblJlY3RhbmdsZS5NZXJnZVBvaW50cyA9IHJlcXVpcmUoJy4vTWVyZ2VQb2ludHMnKTtcclxuUmVjdGFuZ2xlLk1lcmdlUmVjdCA9IHJlcXVpcmUoJy4vTWVyZ2VSZWN0Jyk7XHJcblJlY3RhbmdsZS5NZXJnZVhZID0gcmVxdWlyZSgnLi9NZXJnZVhZJyk7XHJcblJlY3RhbmdsZS5PZmZzZXQgPSByZXF1aXJlKCcuL09mZnNldCcpO1xyXG5SZWN0YW5nbGUuT2Zmc2V0UG9pbnQgPSByZXF1aXJlKCcuL09mZnNldFBvaW50Jyk7XHJcblJlY3RhbmdsZS5PdmVybGFwcyA9IHJlcXVpcmUoJy4vT3ZlcmxhcHMnKTtcclxuUmVjdGFuZ2xlLlBlcmltZXRlciA9IHJlcXVpcmUoJy4vUGVyaW1ldGVyJyk7XHJcblJlY3RhbmdsZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xyXG5SZWN0YW5nbGUuU2NhbGUgPSByZXF1aXJlKCcuL1NjYWxlJyk7XHJcblJlY3RhbmdsZS5VbmlvbiA9IHJlcXVpcmUoJy4vVW5pb24nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL2luZGV4LmpzIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIFNldCA9IHJlcXVpcmUoJy4uL3N0cnVjdHMvU2V0Jyk7XHJcbnZhciBYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vWEhSU2V0dGluZ3MnKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudHMvJyk7XHJcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyJyk7XHJcblxyXG52YXIgQmFzZUxvYWRlciA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIC8vICBUbyBmaW5pc2ggdGhlIGxvYWRlciAuLi5cclxuICAgIC8vICBcclxuICAgIC8vICAzKSBQcm9ncmVzcyB1cGRhdGVcclxuICAgIC8vICA0KSBKU09OIGxvYWRlclxyXG4gICAgLy8gIDUpIFhNTCBMb2FkZXJcclxuICAgIC8vICA2KSBNdWx0aSBGaWxlIHN1cHBvcnQgKGF0bGFzICsgZGF0YSlcclxuICAgIC8vICA3KSBBdGxhcyBMb2FkZXJcclxuXHJcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICAvLyAgTW92ZSB0byBhICdzZXRVUkwnIG1ldGhvZD9cclxuICAgIHRoaXMuYmFzZVVSTCA9ICcnO1xyXG4gICAgdGhpcy5wYXRoID0gJyc7XHJcblxyXG4gICAgLy8gIFJlYWQgZnJvbSBHYW1lIC8gU3RhdGUgQ29uZmlnXHJcbiAgICB0aGlzLmVuYWJsZVBhcmFsbGVsID0gdHJ1ZTtcclxuICAgIHRoaXMubWF4UGFyYWxsZWxEb3dubG9hZHMgPSA0O1xyXG5cclxuICAgIC8vICB4aHIgc3BlY2lmaWMgZ2xvYmFsIHNldHRpbmdzIChjYW4gYmUgb3ZlcnJpZGRlbiBvbiBhIHBlci1maWxlIGJhc2lzKVxyXG4gICAgdGhpcy54aHIgPSBYSFJTZXR0aW5ncygpO1xyXG5cclxuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdGhpcy5saXN0ID0gbmV3IFNldCgpO1xyXG4gICAgdGhpcy5pbmZsaWdodCA9IG5ldyBTZXQoKTtcclxuICAgIHRoaXMuZmFpbGVkID0gbmV3IFNldCgpO1xyXG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBTZXQoKTtcclxuICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9JRExFO1xyXG59O1xyXG5cclxuQmFzZUxvYWRlci5wcm90b3R5cGUuY29udHJ1Y3RvciA9IEJhc2VMb2FkZXI7XHJcblxyXG5CYXNlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBhZGRGaWxlOiBmdW5jdGlvbiAoZmlsZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNSZWFkeSgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmlsZS5wYXRoID0gdGhpcy5wYXRoO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3Quc2V0KGZpbGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIElzIHRoZSBMb2FkZXIgYWN0aXZlbHkgbG9hZGluZyAob3IgcHJvY2Vzc2luZyBsb2FkZWQgZmlsZXMpXHJcbiAgICBpc0xvYWRpbmc6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX0xPQURJTkcgfHwgdGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9QUk9DRVNTSU5HKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIElzIHRoZSBMb2FkZXIgcmVhZHkgdG8gc3RhcnQgYSBuZXcgbG9hZD9cclxuICAgIGlzUmVhZHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX0lETEUgfHwgdGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9DT01QTEVURSB8fCB0aGlzLl9zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX0ZBSUxFRCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdCYXNlTG9hZGVyIHN0YXJ0LiBGaWxlcyB0byBsb2FkOicsIHRoaXMubGlzdC5zaXplKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVhZHkoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5MT0FERVJfU1RBUlRfRVZFTlQodGhpcykpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5saXN0LnNpemUgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkTG9hZGluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9MT0FESU5HO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mYWlsZWQuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5pbmZsaWdodC5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmRlYnVnID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xvYWRRdWV1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwcm9jZXNzTG9hZFF1ZXVlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCc9PT09PT09PSBCYXNlTG9hZGVyIHByb2Nlc3NMb2FkUXVldWUnKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnTGlzdCBzaXplJywgdGhpcy5saXN0LnNpemUpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuaW5mbGlnaHQuc2l6ZSwgJ2l0ZW1zIHN0aWxsIGluIGZsaWdodC4gQ2FuIGxvYWQgYW5vdGhlcicsICh0aGlzLm1heFBhcmFsbGVsRG93bmxvYWRzIC0gdGhpcy5pbmZsaWdodC5zaXplKSk7XHJcblxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdC5lYWNoKGZ1bmN0aW9uIChmaWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfUEVORElORyAmJiBfdGhpcy5pbmZsaWdodC5zaXplIDwgX3RoaXMubWF4UGFyYWxsZWxEb3dubG9hZHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmluZmxpZ2h0LnNldChmaWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5saXN0LmRlbGV0ZShmaWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkRmlsZShmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF90aGlzLmluZmxpZ2h0LnNpemUgPT09IF90aGlzLm1heFBhcmFsbGVsRG93bmxvYWRzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgVGVsbHMgdGhlIFNldCBpdGVyYXRvciB0byBhYm9ydFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgcHJpdmF0ZVxyXG4gICAgbG9hZEZpbGU6IGZ1bmN0aW9uIChmaWxlKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMT0FESU5HJywgZmlsZS5rZXkpO1xyXG5cclxuICAgICAgICAvLyAgSWYgdGhlIGZpbGUgZG9lc24ndCBoYXZlIGl0cyBvd24gY3Jvc3NPcmlnaW4gc2V0LFxyXG4gICAgICAgIC8vICB3ZSdsbCB1c2UgdGhlIExvYWRlcnMgKHdoaWNoIGlzIHVuZGVmaW5lZCBieSBkZWZhdWx0KVxyXG4gICAgICAgIGlmICghZmlsZS5jcm9zc09yaWdpbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmlsZS5sb2FkKHRoaXMubmV4dEZpbGUuYmluZCh0aGlzKSwgdGhpcy5iYXNlVVJMKTtcclxuICAgIH0sXHJcblxyXG4gICAgbmV4dEZpbGU6IGZ1bmN0aW9uIChwcmV2aW91c0ZpbGUsIHN1Y2Nlc3MpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xPQURFRDonLCBwcmV2aW91c0ZpbGUuc3JjLCBzdWNjZXNzKTtcclxuXHJcbiAgICAgICAgLy8gIE1vdmUgdGhlIGZpbGUgdGhhdCBqdXN0IGxvYWRlZCBmcm9tIHRoZSBpbmZsaWdodCBsaXN0IHRvIHRoZSBxdWV1ZSBvciBmYWlsZWQgU2V0XHJcblxyXG4gICAgICAgIGlmIChzdWNjZXNzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5zZXQocHJldmlvdXNGaWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5mYWlsZWQuc2V0KHByZXZpb3VzRmlsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmluZmxpZ2h0LmRlbGV0ZShwcmV2aW91c0ZpbGUpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5saXN0LnNpemUgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ25leHRGaWxlIC0gc3RpbGwgc29tZXRoaW5nIGluIHRoZSBsaXN0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xvYWRRdWV1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmluZmxpZ2h0LnNpemUgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbmV4dEZpbGUgY2FsbGluZyBmaW5pc2hlZExvYWRpbmcnKTtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZExvYWRpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmlzaGVkTG9hZGluZzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tPiBCYXNlTG9hZGVyLmZpbmlzaGVkTG9hZGluZyBQUk9DRVNTSU5HJywgdGhpcy5xdWV1ZS5zaXplLCAnZmlsZXMnKTtcclxuXHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfUFJPQ0VTU0lORztcclxuXHJcbiAgICAgICAgdGhpcy5zdG9yYWdlLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRoaXMucXVldWUuZWFjaChmdW5jdGlvbiAoZmlsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCclYyBDYWxsaW5nIHByb2Nlc3Mgb24gJyArIGZpbGUua2V5LCAnY29sb3I6ICMwMDAwMDA7IGJhY2tncm91bmQ6ICNmZmZmMDA7Jyk7XHJcblxyXG4gICAgICAgICAgICBmaWxlLm9uUHJvY2VzcyhfdGhpcy5wcm9jZXNzVXBkYXRlLmJpbmQoX3RoaXMpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBGaWxlIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmdcclxuICAgIHByb2Nlc3NVcGRhdGU6IGZ1bmN0aW9uIChmaWxlKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctPiBwcm9jZXNzVXBkYXRlJywgZmlsZS5rZXksIGZpbGUuc3RhdGUpO1xyXG5cclxuICAgICAgICAvLyAgVGhpcyBmaWxlIGhhcyBmYWlsZWQgdG8gbG9hZCwgc28gbW92ZSBpdCB0byB0aGUgZmFpbGVkIFNldFxyXG4gICAgICAgIGlmIChmaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX0VSUk9SRUQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZC5zZXQoZmlsZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZmlsZS5saW5rRmlsZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kZWxldGUoZmlsZS5saW5rRmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUZyb21RdWV1ZShmaWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBJZiB3ZSBnb3QgaGVyZSwgdGhlbiB0aGUgZmlsZSBsb2FkZWRcclxuXHJcbiAgICAgICAgLy8gIFNwZWNpYWwgaGFuZGxpbmcgZm9yIG11bHRpLXBhcnQgZmlsZXNcclxuXHJcbiAgICAgICAgaWYgKGZpbGUubGlua0ZpbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9DT01QTEVURSAmJiBmaWxlLmxpbmtGaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX0NPTVBMRVRFKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgUGFydG5lciBoYXMgbG9hZGVkLCBzbyBhZGQgdGhlbSBib3RoIHRvIFN0b3JhZ2VcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KHsgdHlwZTogZmlsZS5saW5rVHlwZSwgZmlsZUE6IGZpbGUsIGZpbGVCOiBmaWxlLmxpbmtGaWxlIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZGVsZXRlKGZpbGUubGlua0ZpbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVF1ZXVlKGZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoZmlsZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21RdWV1ZShmaWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUZyb21RdWV1ZTogZnVuY3Rpb24gKGZpbGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5xdWV1ZS5kZWxldGUoZmlsZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlLnNpemUgPT09IDAgJiYgdGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9QUk9DRVNTSU5HKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFdlJ3ZlIHByb2Nlc3NlZCBhbGwgdGhlIGZpbGVzIHdlIGxvYWRlZFxyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NDb21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcHJvY2Vzc0NvbXBsZXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkZXIgQ29tcGxldGUuIExvYWRlZDonLCB0aGlzLnN0b3JhZ2Uuc2l6ZSwgJ0ZhaWxlZDonLCB0aGlzLmZhaWxlZC5zaXplKTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5pbmZsaWdodC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMucXVldWUuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0NhbGxiYWNrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gQ09OU1QuTE9BREVSX0NPTVBMRVRFO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuTE9BREVSX0NPTVBMRVRFX0VWRU5UKHRoaXMpKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5saXN0LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5pbmZsaWdodC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuZmFpbGVkLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLnRhZyA9ICcnO1xyXG4gICAgICAgIHRoaXMucGF0aCA9ICcnO1xyXG4gICAgICAgIHRoaXMuYmFzZVVSTCA9ICcnO1xyXG5cclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9JRExFO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9ERVNUUk9ZRUQ7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlTG9hZGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvQmFzZUxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9CYXNlTG9hZGVyLmpzIiwidmFyIEdldFVSTCA9IGZ1bmN0aW9uIChmaWxlLCBiYXNlVVJMKVxyXG57XHJcbiAgICBpZiAoIWZpbGUudXJsKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmlsZS51cmwubWF0Y2goL14oPzpibG9iOnxkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98XFwvXFwvKS8pKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmaWxlLnVybDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYmFzZVVSTCArIGZpbGUudXJsO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRVUkw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9HZXRVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDIyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWVyZ2VYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vTWVyZ2VYSFJTZXR0aW5ncycpO1xyXG5cclxudmFyIFhIUkxvYWRlciA9IGZ1bmN0aW9uIChmaWxlLCBnbG9iYWxYSFJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGNvbmZpZyA9IE1lcmdlWEhSU2V0dGluZ3MoZ2xvYmFsWEhSU2V0dGluZ3MsIGZpbGUueGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbiAgICB4aHIub3BlbignR0VUJywgZmlsZS5zcmMsIGNvbmZpZy5hc3luYywgY29uZmlnLnVzZXIsIGNvbmZpZy5wYXNzd29yZCk7XHJcblxyXG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGZpbGUueGhyU2V0dGluZ3MucmVzcG9uc2VUeXBlO1xyXG4gICAgeGhyLnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcclxuXHJcbiAgICBpZiAoY29uZmlnLmhlYWRlciAmJiBjb25maWcuaGVhZGVyVmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoY29uZmlnLmhlYWRlciwgY29uZmlnLmhlYWRlclZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0LCB0aGUgeGhyLnJlc3BvbnNlIHByb3BlcnR5IHdpbGwgY29udGFpbiB0aGUgcmVxdWVzdGVkIGRhdGEgYXMgYSBET01TdHJpbmcsIEFycmF5QnVmZmVyLCBCbG9iLCBvciBEb2N1bWVudCAoZGVwZW5kaW5nIG9uIHdoYXQgd2FzIHNldCBmb3IgcmVzcG9uc2VUeXBlLilcclxuXHJcbiAgICB4aHIub25sb2FkID0gZmlsZS5vbkxvYWQuYmluZChmaWxlKTtcclxuICAgIHhoci5vbmVycm9yID0gZmlsZS5vbkVycm9yLmJpbmQoZmlsZSk7XHJcbiAgICB4aHIub25wcm9ncmVzcyA9IGZpbGUub25Qcm9ncmVzcy5iaW5kKGZpbGUpO1xyXG5cclxuICAgIC8vICBUaGlzIGlzIHRoZSBvbmx5IHN0YW5kYXJkIG1ldGhvZCwgdGhlIG9uZXMgYWJvdmUgYXJlIGJyb3dzZXIgYWRkaXRpb25zIChtYXliZSBub3QgdW5pdmVyc2FsPylcclxuICAgIC8vIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2VcclxuXHJcbiAgICB4aHIuc2VuZCgpO1xyXG5cclxuICAgIHJldHVybiB4aHI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL1hIUkxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9YSFJMb2FkZXIuanMiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBMb2FkZXJDb21wbGV0ZUV2ZW50ID0gZnVuY3Rpb24gKGxvYWRlcilcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnTE9BREVSX0NPTVBMRVRFX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XHJcbn07XHJcblxyXG5Mb2FkZXJDb21wbGV0ZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuTG9hZGVyQ29tcGxldGVFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXJDb21wbGV0ZUV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXJDb21wbGV0ZUV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanMiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBMb2FkZXJTdGFydEV2ZW50ID0gZnVuY3Rpb24gKGxvYWRlcilcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnTE9BREVSX1NUQVJUX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XHJcbn07XHJcblxyXG5Mb2FkZXJTdGFydEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuTG9hZGVyU3RhcnRFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXJTdGFydEV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXJTdGFydEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZXZlbnRzL0xvYWRlclN0YXJ0RXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZXZlbnRzL0xvYWRlclN0YXJ0RXZlbnQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBMT0FERVJfU1RBUlRfRVZFTlQ6IHJlcXVpcmUoJy4vTG9hZGVyU3RhcnRFdmVudCcpLFxyXG4gICAgTE9BREVSX0NPTVBMRVRFX0VWRU5UOiByZXF1aXJlKCcuL0xvYWRlckNvbXBsZXRlRXZlbnQnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2V2ZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9ldmVudHMvaW5kZXguanMiLCJ2YXIgSW1hZ2VGaWxlID0gcmVxdWlyZSgnLi9JbWFnZUZpbGUuanMnKTtcclxudmFyIEpTT05GaWxlID0gcmVxdWlyZSgnLi9KU09ORmlsZS5qcycpO1xyXG5cclxudmFyIEF0bGFzSlNPTkZpbGUgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMLCBhdGxhc1VSTCwgcGF0aCwgdGV4dHVyZVhoclNldHRpbmdzLCBhdGxhc1hoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2VGaWxlKGtleSwgdGV4dHVyZVVSTCwgcGF0aCwgdGV4dHVyZVhoclNldHRpbmdzKTtcclxuICAgIHZhciBkYXRhID0gbmV3IEpTT05GaWxlKGtleSwgYXRsYXNVUkwsIHBhdGgsIGF0bGFzWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIC8vICBMaW5rIHRoZW0gdG9nZXRoZXJcclxuICAgIGltYWdlLmxpbmtGaWxlID0gZGF0YTtcclxuICAgIGRhdGEubGlua0ZpbGUgPSBpbWFnZTtcclxuXHJcbiAgICAvLyAgU2V0IHRoZSB0eXBlXHJcbiAgICBpbWFnZS5saW5rVHlwZSA9ICdhdGxhc2pzb24nO1xyXG4gICAgZGF0YS5saW5rVHlwZSA9ICdhdGxhc2pzb24nO1xyXG5cclxuICAgIHJldHVybiB7IHRleHR1cmU6IGltYWdlLCBkYXRhOiBkYXRhIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF0bGFzSlNPTkZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qcyIsIlxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxuXHJcbnZhciBCaW5hcnlGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLmJpbmFyeVxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5iaW4nO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmlsZS5jYWxsKHRoaXMsICdiaW5hcnknLCBrZXksIHVybCwgJ2FycmF5YnVmZmVyJywgeGhyU2V0dGluZ3MpO1xyXG59O1xyXG5cclxuQmluYXJ5RmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcclxuQmluYXJ5RmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaW5hcnlGaWxlO1xyXG5cclxuQmluYXJ5RmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlO1xyXG5cclxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgIGNhbGxiYWNrKHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaW5hcnlGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUuanMiLCJcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcblxyXG52YXIgR0xTTEZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxyXG5cclxuICAgIGlmICgha2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIudGV4dFxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5nbHNsJztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIEZpbGUuY2FsbCh0aGlzLCAnZ2xzbCcsIGtleSwgdXJsLCAndGV4dCcsIHhoclNldHRpbmdzKTtcclxufTtcclxuXHJcbkdMU0xGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5HTFNMRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHTFNMRmlsZTtcclxuXHJcbkdMU0xGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gdGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0O1xyXG5cclxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgIGNhbGxiYWNrKHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHTFNMRmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9HTFNMRmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanMiLCJcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcblxyXG52YXIgVGV4dEZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxyXG5cclxuICAgIGlmICgha2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIudGV4dFxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy50ZXh0JztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIEZpbGUuY2FsbCh0aGlzLCAndGV4dCcsIGtleSwgdXJsLCAndGV4dCcsIHhoclNldHRpbmdzKTtcclxufTtcclxuXHJcblRleHRGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5UZXh0RmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0RmlsZTtcclxuXHJcblRleHRGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gdGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0O1xyXG5cclxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgIGNhbGxiYWNrKHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0RmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvVGV4dEZpbGUuanMiLCJcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcbnZhciBQYXJzZVhNTCA9IHJlcXVpcmUoJy4uLy4uL2RvbS9QYXJzZVhNTCcpO1xyXG5cclxudmFyIFhNTEZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxyXG5cclxuICAgIGlmICgha2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIueG1sXFwnIGludmFsaWQga2V5IHByb3ZpZGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdXJsKVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLnhtbCc7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBGaWxlLmNhbGwodGhpcywgJ3htbCcsIGtleSwgdXJsLCAndGV4dCcsIHhoclNldHRpbmdzKTtcclxufTtcclxuXHJcblhNTEZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XHJcblhNTEZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWE1MRmlsZTtcclxuXHJcblhNTEZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcclxue1xyXG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICB0aGlzLmRhdGEgPSBQYXJzZVhNTCh0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQpO1xyXG5cclxuICAgIGlmICh0aGlzLmRhdGEgPT09IG51bGwpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYTUxGaWxlOiBJbnZhbGlkIFhNTCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgIGNhbGxiYWNrKHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYTUxGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZmlsZXR5cGVzL1hNTEZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL1hNTEZpbGUuanMiLCJ2YXIgQXZlcmFnZSA9IGZ1bmN0aW9uICh2YWx1ZXMpXHJcbntcclxuICAgIHZhciBzdW0gPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHN1bSArPSAoK3ZhbHVlc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN1bSAvIHZhbHVlcy5sZW5ndGg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF2ZXJhZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQXZlcmFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZWlsVG8gPSBmdW5jdGlvbiAodmFsdWUsIHBsYWNlLCBiYXNlKVxyXG57XHJcbiAgICBpZiAocGxhY2UgPT09IHVuZGVmaW5lZCkgeyBwbGFjZSA9IDA7IH1cclxuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHsgYmFzZSA9IDEwOyB9XHJcblxyXG4gICAgdmFyIHAgPSBNYXRoLnBvdyhiYXNlLCAtcGxhY2UpO1xyXG5cclxuICAgIHJldHVybiBNYXRoLmNlaWwodmFsdWUgKiBwKSAvIHA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlaWxUbztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9DZWlsVG8uanNcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBGb3JjZSBhIHZhbHVlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBieSBjbGFtcGluZyBpdCB0byB0aGUgcmFuZ2UgYG1pbmAsIGBtYXhgLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuTWF0aCNjbGFtcFxyXG4qIEBwYXJhbSB7ZmxvYXR9IHYgLSBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZC5cclxuKiBAcGFyYW0ge2Zsb2F0fSBtaW4gLSBUaGUgbWluaW11bSBib3VuZHMuXHJcbiogQHBhcmFtIHtmbG9hdH0gbWF4IC0gVGhlIG1heGltdW0gYm91bmRzLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGNsYW1wZWQgdmFsdWUuXHJcbiovXHJcbnZhciBDbGFtcCA9IGZ1bmN0aW9uICh2LCBtaW4sIG1heClcclxue1xyXG4gICAgaWYgKHYgPCBtaW4pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG1pbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1heCA8IHYpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG1heDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xhbXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQ2xhbXAuanNcbi8vIG1vZHVsZSBpZCA9IDIzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgRGVnVG9SYWQgPSBmdW5jdGlvbiAoZGVncmVlcylcclxue1xyXG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBDT05TVC5ERUdfVE9fUkFEO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWdUb1JhZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9EZWdUb1JhZC5qc1xuLy8gbW9kdWxlIGlkID0gMjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvRGVnVG9SYWQuanMiLCJ2YXIgRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaWZmZXJlbmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0RpZmZlcmVuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvYXRCZXR3ZWVuID0gZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmxvYXRCZXR3ZWVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0Zsb2F0QmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9vclRvID0gZnVuY3Rpb24gKHZhbHVlLCBwbGFjZSwgYmFzZSlcclxue1xyXG4gICAgaWYgKHBsYWNlID09PSB1bmRlZmluZWQpIHsgcGxhY2UgPSAwOyB9XHJcbiAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7IGJhc2UgPSAxMDsgfVxyXG5cclxuICAgIHZhciBwID0gTWF0aC5wb3coYmFzZSwgLXBsYWNlKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSAqIHApIC8gcDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmxvb3JUbztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9GbG9vclRvLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBNYXhBZGQgPSBmdW5jdGlvbiAodmFsdWUsIGFtb3VudCwgbWF4KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5taW4odmFsdWUgKyBhbW91bnQsIG1heCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1heEFkZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9NYXhBZGQuanNcbi8vIG1vZHVsZSBpZCA9IDI0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWluU3ViID0gZnVuY3Rpb24gKHZhbHVlLCBhbW91bnQsIG1pbilcclxue1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlIC0gYW1vdW50LCBtaW4pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNaW5TdWI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvTWluU3ViLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBlcmNlbnQgPSBmdW5jdGlvbiAoYSwgYiwgYmFzZSlcclxue1xyXG4gICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkgeyBiYXNlID0gMDsgfVxyXG5cclxuICAgIGlmIChhID4gYiB8fCBiYXNlID4gYilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEgPCBiYXNlIHx8IGJhc2UgPiBhKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoYSAtIGJhc2UpIC8gYjtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGVyY2VudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9QZXJjZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIFJhZFRvRGVnID0gZnVuY3Rpb24gKHJhZGlhbnMpXHJcbntcclxuICAgIHJldHVybiByYWRpYW5zICogQ09OU1QuUkFEX1RPX0RFRztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFkVG9EZWc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvUmFkVG9EZWcuanNcbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL1JhZFRvRGVnLmpzIiwiLy8gIHAgPSBQb2ludCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXHJcblxyXG52YXIgUm90YXRlID0gZnVuY3Rpb24gKHBvaW50LCBhbmdsZSlcclxue1xyXG4gICAgdmFyIHggPSBwb2ludC54O1xyXG4gICAgdmFyIHkgPSBwb2ludC55O1xyXG5cclxuICAgIHBvaW50LnggPSAoeCAqIE1hdGguY29zKGFuZ2xlKSkgLSAoeSAqIE1hdGguc2luKGFuZ2xlKSk7XHJcbiAgICBwb2ludC55ID0gKHggKiBNYXRoLnNpbihhbmdsZSkpICsgKHkgKiBNYXRoLmNvcyhhbmdsZSkpO1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBwID0gUG9pbnQgb3IgYW55IG9iamVjdCB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllc1xyXG5cclxudmFyIFJvdGF0ZUFyb3VuZCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSwgYW5nbGUpXHJcbntcclxuICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgdmFyIHR4ID0gcG9pbnQueCAtIHg7XHJcbiAgICB2YXIgdHkgPSBwb2ludC55IC0geTtcclxuXHJcbiAgICBwb2ludC54ID0gdHggKiBjIC0gdHkgKiBzICsgeDtcclxuICAgIHBvaW50LnkgPSB0eCAqIHMgKyB0eSAqIGMgKyB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdGF0ZUFyb3VuZC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBwID0gUG9pbnQgb3IgYW55IG9iamVjdCB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllc1xyXG5cclxudmFyIFJvdGF0ZUFyb3VuZERpc3RhbmNlID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5LCBhbmdsZSwgZGlzdGFuY2UpXHJcbntcclxuICAgIHZhciB0ID0gYW5nbGUgKyBNYXRoLmF0YW4yKHBvaW50LnkgLSB5LCBwb2ludC54IC0geCk7XHJcblxyXG4gICAgcG9pbnQueCA9IHggKyAoZGlzdGFuY2UgKiBNYXRoLmNvcyh0KSk7XHJcbiAgICBwb2ludC55ID0geSArIChkaXN0YW5jZSAqIE1hdGguc2luKHQpKTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZERpc3RhbmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdGF0ZUFyb3VuZERpc3RhbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJvdW5kVG8gPSBmdW5jdGlvbiAodmFsdWUsIHBsYWNlLCBiYXNlKVxyXG57XHJcbiAgICBpZiAocGxhY2UgPT09IHVuZGVmaW5lZCkgeyBwbGFjZSA9IDA7IH1cclxuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHsgYmFzZSA9IDEwOyB9XHJcblxyXG4gICAgdmFyIHAgPSBNYXRoLnBvdyhiYXNlLCAtcGxhY2UpO1xyXG5cclxuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogcCkgLyBwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3VuZFRvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdW5kVG8uanNcbi8vIG1vZHVsZSBpZCA9IDI1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFNpbkNvc1RhYmxlR2VuZXJhdG9yID0gZnVuY3Rpb24gKGxlbmd0aCwgc2luQW1wLCBjb3NBbXAsIGZyZXF1ZW5jeSlcclxue1xyXG4gICAgaWYgKHNpbkFtcCA9PT0gdW5kZWZpbmVkKSB7IHNpbkFtcCA9IDE7IH1cclxuICAgIGlmIChjb3NBbXAgPT09IHVuZGVmaW5lZCkgeyBjb3NBbXAgPSAxOyB9XHJcbiAgICBpZiAoZnJlcXVlbmN5ID09PSB1bmRlZmluZWQpIHsgZnJlcXVlbmN5ID0gMTsgfVxyXG5cclxuICAgIGZyZXF1ZW5jeSAqPSBNYXRoLlBJIC8gbGVuZ3RoO1xyXG5cclxuICAgIHZhciBjb3MgPSBbXTtcclxuICAgIHZhciBzaW4gPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGxlbmd0aDsgYysrKVxyXG4gICAge1xyXG4gICAgICAgIGNvc0FtcCAtPSBzaW5BbXAgKiBmcmVxdWVuY3k7XHJcbiAgICAgICAgc2luQW1wICs9IGNvc0FtcCAqIGZyZXF1ZW5jeTtcclxuXHJcbiAgICAgICAgY29zW2NdID0gY29zQW1wO1xyXG4gICAgICAgIHNpbltjXSA9IHNpbkFtcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNpbjogc2luLFxyXG4gICAgICAgIGNvczogY29zLFxyXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaW5Db3NUYWJsZUdlbmVyYXRvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9TaW5Db3NUYWJsZUdlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbW9vdGhTdGVwID0gZnVuY3Rpb24gKHgsIG1pbiwgbWF4KVxyXG57XHJcbiAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHggLSBtaW4pIC8gKG1heCAtIG1pbikpKTtcclxuXHJcbiAgICByZXR1cm4geCAqIHggKiAoMyAtIDIgKiB4KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU21vb3RoU3RlcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9TbW9vdGhTdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNtb290aGVyU3RlcCA9IGZ1bmN0aW9uICh4LCBtaW4sIG1heClcclxue1xyXG4gICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gbWluKSAvIChtYXggLSBtaW4pKSk7XHJcblxyXG4gICAgcmV0dXJuIHggKiB4ICogeCAqICh4ICogKHggKiA2IC0gMTUpICsgMTApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbW9vdGhlclN0ZXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvU21vb3RoZXJTdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ2hlY2tzIGlmIHR3byB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZ2l2ZW4gdG9sZXJhbmNlIG9mIGVhY2ggb3RoZXIuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI3dpdGhpblxyXG4qIEBwYXJhbSB7bnVtYmVyfSBhIC0gVGhlIGZpcnN0IG51bWJlciB0byBjaGVja1xyXG4qIEBwYXJhbSB7bnVtYmVyfSBiIC0gVGhlIHNlY29uZCBudW1iZXIgdG8gY2hlY2tcclxuKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIC0gVGhlIHRvbGVyYW5jZS4gQW55dGhpbmcgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIHRoaXMgaXMgY29uc2lkZXJlZCB3aXRoaW4gdGhlIHJhbmdlLlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBpcyA8PSB0b2xlcmFuY2Ugb2YgYi5cclxuKiBAc2VlIHtAbGluayBQaGFzZXIuTWF0aC5mdXp6eUVxdWFsfVxyXG4qL1xyXG52YXIgV2l0aGluID0gZnVuY3Rpb24gKGEsIGIsIHRvbGVyYW5jZSlcclxue1xyXG4gICAgcmV0dXJuIChNYXRoLmFicyhhIC0gYikgPD0gdG9sZXJhbmNlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2l0aGluO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1dpdGhpbi5qc1xuLy8gbW9kdWxlIGlkID0gMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZXR3ZWVuID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9CZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW5Qb2ludHMgPSBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50Mi55IC0gcG9pbnQxLnksIHBvaW50Mi54IC0gcG9pbnQxLngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCZXR3ZWVuUG9pbnRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL0JldHdlZW5Qb2ludHMuanNcbi8vIG1vZHVsZSBpZCA9IDI1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlblBvaW50c1kgPSBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50Mi54IC0gcG9pbnQxLngsIHBvaW50Mi55IC0gcG9pbnQxLnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCZXR3ZWVuUG9pbnRzWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9CZXR3ZWVuUG9pbnRzWS5qc1xuLy8gbW9kdWxlIGlkID0gMjU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZXR3ZWVuWSA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Milcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeDIgLSB4MSwgeTIgLSB5MSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW5ZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL0JldHdlZW5ZLmpzXG4vLyBtb2R1bGUgaWQgPSAyNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vTm9ybWFsaXplJyk7XHJcblxyXG52YXIgUmV2ZXJzZSA9IGZ1bmN0aW9uIChhbmdsZSlcclxue1xyXG4gICAgcmV0dXJuIE5vcm1hbGl6ZShhbmdsZSArIE1hdGguUEkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXZlcnNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL1JldmVyc2UuanNcbi8vIG1vZHVsZSBpZCA9IDI1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL1JldmVyc2UuanMiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcblxyXG4vKipcclxuKiBSb3RhdGVzIGN1cnJlbnRBbmdsZSB0b3dhcmRzIHRhcmdldEFuZ2xlLCB0YWtpbmcgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGRpc3RhbmNlLlxyXG4qIFRoZSBsZXJwIGFyZ3VtZW50IGlzIHRoZSBhbW91bnQgdG8gcm90YXRlIGJ5IGluIHRoaXMgY2FsbC5cclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI3JvdGF0ZVRvQW5nbGVcclxuKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEFuZ2xlIC0gVGhlIGN1cnJlbnQgYW5nbGUsIGluIHJhZGlhbnMuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHRhcmdldEFuZ2xlIC0gVGhlIHRhcmdldCBhbmdsZSB0byByb3RhdGUgdG8sIGluIHJhZGlhbnMuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtsZXJwPTAuMDVdIC0gVGhlIGxlcnAgdmFsdWUgdG8gYWRkIHRvIHRoZSBjdXJyZW50IGFuZ2xlLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGFkanVzdGVkIGFuZ2xlLlxyXG4qL1xyXG52YXIgUm90YXRlVG8gPSBmdW5jdGlvbiAoY3VycmVudEFuZ2xlLCB0YXJnZXRBbmdsZSwgbGVycClcclxue1xyXG4gICAgaWYgKGxlcnAgPT09IHVuZGVmaW5lZCkgeyBsZXJwID0gMC4wNTsgfVxyXG5cclxuICAgIGlmIChjdXJyZW50QW5nbGUgPT09IHRhcmdldEFuZ2xlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50QW5nbGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKHRhcmdldEFuZ2xlIC0gY3VycmVudEFuZ2xlKSA8PSBsZXJwIHx8IE1hdGguYWJzKHRhcmdldEFuZ2xlIC0gY3VycmVudEFuZ2xlKSA+PSAoTUFUSF9DT05TVC5QSTIgLSBsZXJwKSlcclxuICAgIHtcclxuICAgICAgICBjdXJyZW50QW5nbGUgPSB0YXJnZXRBbmdsZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZiAoTWF0aC5hYnModGFyZ2V0QW5nbGUgLSBjdXJyZW50QW5nbGUpID4gTWF0aC5QSSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRBbmdsZSA8IGN1cnJlbnRBbmdsZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0QW5nbGUgKz0gTUFUSF9DT05TVC5QSTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRBbmdsZSAtPSBNQVRIX0NPTlNULlBJMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRhcmdldEFuZ2xlID4gY3VycmVudEFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3VycmVudEFuZ2xlICs9IGxlcnA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhcmdldEFuZ2xlIDwgY3VycmVudEFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3VycmVudEFuZ2xlIC09IGxlcnA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjdXJyZW50QW5nbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZVRvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL1JvdGF0ZVRvLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9hbmdsZS9Sb3RhdGVUby5qcyIsIi8qKlxyXG4qIEdldHMgdGhlIHNob3J0ZXN0IGFuZ2xlIGJldHdlZW4gYGFuZ2xlMWAgYW5kIGBhbmdsZTJgLlxyXG4qIEJvdGggYW5nbGVzIG11c3QgYmUgaW4gdGhlIHJhbmdlIC0xODAgdG8gMTgwLCB3aGljaCBpcyB0aGUgc2FtZSBjbGFtcGVkXHJcbiogcmFuZ2UgdGhhdCBgc3ByaXRlLmFuZ2xlYCB1c2VzLCBzbyB5b3UgY2FuIHBhc3MgaW4gdHdvIHNwcml0ZSBhbmdsZXMgdG9cclxuKiB0aGlzIG1ldGhvZCwgYW5kIGdldCB0aGUgc2hvcnRlc3QgYW5nbGUgYmFjayBiZXR3ZWVuIHRoZSB0d28gb2YgdGhlbS5cclxuKlxyXG4qIFRoZSBhbmdsZSByZXR1cm5lZCB3aWxsIGJlIGluIHRoZSBzYW1lIHJhbmdlLiBJZiB0aGUgcmV0dXJuZWQgYW5nbGUgaXNcclxuKiBncmVhdGVyIHRoYW4gMCB0aGVuIGl0J3MgYSBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbiwgaWYgPCAwIHRoZW4gaXQnc1xyXG4qIGEgY2xvY2t3aXNlIHJvdGF0aW9uLlxyXG4qIFxyXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjZ2V0U2hvcnRlc3RBbmdsZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBhbmdsZTEgLSBUaGUgZmlyc3QgYW5nbGUuIEluIHRoZSByYW5nZSAtMTgwIHRvIDE4MC5cclxuKiBAcGFyYW0ge251bWJlcn0gYW5nbGUyIC0gVGhlIHNlY29uZCBhbmdsZS4gSW4gdGhlIHJhbmdlIC0xODAgdG8gMTgwLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIHNob3J0ZXN0IGFuZ2xlLCBpbiBkZWdyZWVzLiBJZiBncmVhdGVyIHRoYW4gemVybyBpdCdzIGEgY291bnRlci1jbG9ja3dpc2Ugcm90YXRpb24uXHJcbiovXHJcbnZhciBTaG9ydGVzdEJldHdlZW4gPSBmdW5jdGlvbiAoYW5nbGUxLCBhbmdsZTIpXHJcbntcclxuICAgIHZhciBkaWZmZXJlbmNlID0gYW5nbGUyIC0gYW5nbGUxO1xyXG5cclxuICAgIGlmIChkaWZmZXJlbmNlID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0aW1lcyA9IE1hdGguZmxvb3IoKGRpZmZlcmVuY2UgLSAoLTE4MCkpIC8gMzYwKTtcclxuXHJcbiAgICByZXR1cm4gZGlmZmVyZW5jZSAtICh0aW1lcyAqIDM2MCk7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaG9ydGVzdEJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvU2hvcnRlc3RCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdyYXAgPSByZXF1aXJlKCcuLi9XcmFwJyk7XHJcblxyXG52YXIgV3JhcERlZ3JlZXMgPSBmdW5jdGlvbiAoYW5nbGUpXHJcbntcclxuICAgIHJldHVybiBXcmFwKGFuZ2xlLCAtMTgwLCAxODApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXcmFwRGVncmVlcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9XcmFwRGVncmVlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBCZXR3ZWVuOiByZXF1aXJlKCcuL0JldHdlZW4nKSxcclxuICAgIEJldHdlZW5ZOiByZXF1aXJlKCcuL0JldHdlZW5ZJyksXHJcbiAgICBCZXR3ZWVuUG9pbnRzOiByZXF1aXJlKCcuL0JldHdlZW5Qb2ludHMnKSxcclxuICAgIEJldHdlZW5Qb2ludHNZOiByZXF1aXJlKCcuL0JldHdlZW5Qb2ludHNZJyksXHJcbiAgICBSZXZlcnNlOiByZXF1aXJlKCcuL1JldmVyc2UnKSxcclxuICAgIFJvdGF0ZVRvOiByZXF1aXJlKCcuL1JvdGF0ZVRvJyksXHJcbiAgICBTaG9ydGVzdEJldHdlZW46IHJlcXVpcmUoJy4vU2hvcnRlc3RCZXR3ZWVuJyksXHJcbiAgICBOb3JtYWxpemU6IHJlcXVpcmUoJy4vTm9ybWFsaXplJyksXHJcbiAgICBXcmFwOiByZXF1aXJlKCcuL1dyYXAnKSxcclxuICAgIFdyYXBEZWdyZWVzOiByZXF1aXJlKCcuL1dyYXBEZWdyZWVzJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL2luZGV4LmpzIiwidmFyIERpc3RhbmNlUG93ZXIgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHBvdylcclxue1xyXG4gICAgaWYgKHBvdyA9PT0gdW5kZWZpbmVkKSB7IHBvdyA9IDI7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIHBvdykgKyBNYXRoLnBvdyh5MiAtIHkxLCBwb3cpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VQb3dlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZVBvd2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Milcclxue1xyXG4gICAgdmFyIGR4ID0geDEgLSB4MjtcclxuICAgIHZhciBkeSA9IHkxIC0geTI7XHJcblxyXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZVNxdWFyZWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VTcXVhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQmV0d2VlbjogcmVxdWlyZSgnLi9EaXN0YW5jZUJldHdlZW4nKSxcclxuICAgIFBvd2VyOiByZXF1aXJlKCcuL0Rpc3RhbmNlUG93ZXInKSxcclxuICAgIFNxdWFyZWQ6IHJlcXVpcmUoJy4vRGlzdGFuY2VTcXVhcmVkJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2Rpc3RhbmNlL2luZGV4LmpzIiwiZnVuY3Rpb24gSW4gKHYsIG92ZXJzaG9vdClcclxue1xyXG4gICAgaWYgKG92ZXJzaG9vdCA9PT0gdW5kZWZpbmVkKSB7IG92ZXJzaG9vdCA9IDEuNzAxNTg7IH1cclxuXHJcbiAgICByZXR1cm4gdiAqIHYgKiAoKG92ZXJzaG9vdCArIDEpICogdiAtIG92ZXJzaG9vdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodiwgb3ZlcnNob290KVxyXG57XHJcbiAgICBpZiAob3ZlcnNob290ID09PSB1bmRlZmluZWQpIHsgb3ZlcnNob290ID0gMS43MDE1ODsgfVxyXG5cclxuICAgIHJldHVybiAtLXYgKiB2ICogKChvdmVyc2hvb3QgKyAxKSAqIHYgKyBvdmVyc2hvb3QpICsgMTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYsIG92ZXJzaG9vdClcclxue1xyXG4gICAgaWYgKG92ZXJzaG9vdCA9PT0gdW5kZWZpbmVkKSB7IG92ZXJzaG9vdCA9IDEuNzAxNTg7IH1cclxuXHJcbiAgICB2YXIgcyA9IG92ZXJzaG9vdCAqIDEuNTI1O1xyXG5cclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICh2ICogdiAqICgocyArIDEpICogdiAtIHMpKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogKCh2IC09IDIpICogdiAqICgocyArIDEpICogdiArIHMpICsgMik7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9CYWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHYgPSAxIC0gdjtcclxuXHJcbiAgICBpZiAodiA8IDEgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gKDcuNTYyNSAqIHYgKiB2KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPCAyIC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiAodiAtPSAxLjUgLyAyLjc1KSAqIHYgKyAwLjc1KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPCAyLjUgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gKDcuNTYyNSAqICh2IC09IDIuMjUgLyAyLjc1KSAqIHYgKyAwLjkzNzUpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gKDcuNTYyNSAqICh2IC09IDIuNjI1IC8gMi43NSkgKiB2ICsgMC45ODQzNzUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIGlmICh2IDwgMSAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqIHYgKiB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA8IDIgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiA3LjU2MjUgKiAodiAtPSAxLjUgLyAyLjc1KSAqIHYgKyAwLjc1O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA8IDIuNSAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqICh2IC09IDIuMjUgLyAyLjc1KSAqIHYgKyAwLjkzNzU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqICh2IC09IDIuNjI1IC8gMi43NSkgKiB2ICsgMC45ODQzNzU7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICB2YXIgcmV2ZXJzZSA9IGZhbHNlO1xyXG5cclxuICAgIGlmICh2IDwgMC41KVxyXG4gICAge1xyXG4gICAgICAgIHYgPSAxIC0gKHYgKiAyKTtcclxuICAgICAgICByZXZlcnNlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2ID0gKHYgKiAyKSAtIDE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHYgPCAxIC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICB2ID0gNy41NjI1ICogdiAqIHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2IDwgMiAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgdiA9IDcuNTYyNSAqICh2IC09IDEuNSAvIDIuNzUpICogdiArIDAuNzU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2IDwgMi41IC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICB2ID0gNy41NjI1ICogKHYgLT0gMi4yNSAvIDIuNzUpICogdiArIDAuOTM3NTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2ID0gNy41NjI1ICogKHYgLT0gMi42MjUgLyAyLjc1KSAqIHYgKyAwLjk4NDM3NTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmV2ZXJzZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKDEgLSB2KSAqIDAuNTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdiAqIDAuNSArIDAuNTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0JvdW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdiAqIHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLXYgKiB2KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdiAqIHYpIC0gMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh2IC09IDIpICogdikgKyAxKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0NpcmN1bGFyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHJldHVybiB2ICogdiAqIHY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIC0tdiAqIHYgKiB2ICsgMTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogKCh2IC09IDIpICogdiAqIHYgKyAyKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0N1YmljLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYsIGFtcGxpdHVkZSwgcGVyaW9kKVxyXG57XHJcbiAgICBpZiAoYW1wbGl0dWRlID09PSB1bmRlZmluZWQpIHsgYW1wbGl0dWRlID0gMC4xOyB9XHJcbiAgICBpZiAocGVyaW9kID09PSB1bmRlZmluZWQpIHsgcGVyaW9kID0gMC4xOyB9XHJcblxyXG4gICAgaWYgKHYgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzID0gcGVyaW9kIC8gNDtcclxuXHJcbiAgICAgICAgaWYgKGFtcGxpdHVkZSA8IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbXBsaXR1ZGUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzID0gcGVyaW9kICogTWF0aC5hc2luKDEgLyBhbXBsaXR1ZGUpIC8gKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIDEwICogKHYgLT0gMSkpICogTWF0aC5zaW4oKHYgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwZXJpb2QpKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2LCBhbXBsaXR1ZGUsIHBlcmlvZClcclxue1xyXG4gICAgaWYgKGFtcGxpdHVkZSA9PT0gdW5kZWZpbmVkKSB7IGFtcGxpdHVkZSA9IDAuMTsgfVxyXG4gICAgaWYgKHBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7IHBlcmlvZCA9IDAuMTsgfVxyXG5cclxuICAgIGlmICh2ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgcyA9IHBlcmlvZCAvIDQ7XHJcblxyXG4gICAgICAgIGlmIChhbXBsaXR1ZGUgPCAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYW1wbGl0dWRlID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcyA9IHBlcmlvZCAqIE1hdGguYXNpbigxIC8gYW1wbGl0dWRlKSAvICgyICogTWF0aC5QSSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIC0xMCAqIHYpICogTWF0aC5zaW4oKHYgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwZXJpb2QpICsgMSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2LCBhbXBsaXR1ZGUsIHBlcmlvZClcclxue1xyXG4gICAgaWYgKGFtcGxpdHVkZSA9PT0gdW5kZWZpbmVkKSB7IGFtcGxpdHVkZSA9IDAuMTsgfVxyXG4gICAgaWYgKHBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7IHBlcmlvZCA9IDAuMTsgfVxyXG5cclxuICAgIGlmICh2ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgcyA9IHBlcmlvZCAvIDQ7XHJcblxyXG4gICAgICAgIGlmIChhbXBsaXR1ZGUgPCAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYW1wbGl0dWRlID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcyA9IHBlcmlvZCAqIE1hdGguYXNpbigxIC8gYW1wbGl0dWRlKSAvICgyICogTWF0aC5QSSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoYW1wbGl0dWRlICogTWF0aC5wb3coMiwgMTAgKiAodiAtPSAxKSkgKiBNYXRoLnNpbigodiAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHBlcmlvZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1wbGl0dWRlICogTWF0aC5wb3coMiwgLTEwICogKHYgLT0gMSkpICogTWF0aC5zaW4oKHYgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwZXJpb2QpICogMC41ICsgMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9FbGFzdGljLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqICh2IC0gMSkpIC0gMC4wMDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiB2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIDEwICogKHYgLSAxKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHYgLSAxKSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvRXhwby5qc1xuLy8gbW9kdWxlIGlkID0gMjcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIExpbmVhciBFYXNpbmcgKG5vIHZhcmlhdGlvbikuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkVhc2luZy5MaW5lYXIjTm9uZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSB2IC0gVGhlIHZhbHVlIHRvIGJlIHR3ZWVuZWQuXHJcbiogQHJldHVybnMge251bWJlcn0gdi5cclxuKi9cclxudmFyIExpbmVhciA9IGZ1bmN0aW9uICh2KVxyXG57XHJcbiAgICByZXR1cm4gdjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZWFyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9MaW5lYXIuanNcbi8vIG1vZHVsZSBpZCA9IDI3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgcmV0dXJuIHYgKiB2O1xyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIHJldHVybiB2ICogKDIgLSB2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAtMC41ICogKC0tdiAqICh2IC0gMikgLSAxKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL1F1YWRyYXRpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gdiAqIHYgKiB2ICogdjtcclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICByZXR1cm4gMSAtICgtLXYgKiB2ICogdiAqIHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogdiAqIHYgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gLTAuNSAqICgodiAtPSAyKSAqIHYgKiB2ICogdiAtIDIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvUXVhcnRpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gdiAqIHYgKiB2ICogdiAqIHY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIC0tdiAqIHYgKiB2ICogdiAqIHYgKyAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogdiAqIHYgKiB2ICogdiAqIHY7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgodiAtPSAyKSAqIHYgKiB2ICogdiAqIHYgKyAyKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL1F1aW50aWMuanNcbi8vIG1vZHVsZSBpZCA9IDI3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgaWYgKHYgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3ModiAqIE1hdGguUEkgLyAyKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICBpZiAodiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKHYgKiBNYXRoLlBJIC8gMik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAodiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIHYpKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL1NpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDI3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBCYWNrOiByZXF1aXJlKCcuL0JhY2snKSxcclxuICAgIEJvdW5jZTogcmVxdWlyZSgnLi9Cb3VuY2UnKSxcclxuICAgIENpcmN1bGFyOiByZXF1aXJlKCcuL0NpcmN1bGFyJyksXHJcbiAgICBDdWJpYzogcmVxdWlyZSgnLi9DdWJpYycpLFxyXG4gICAgRWxhc3RpYzogcmVxdWlyZSgnLi9FbGFzdGljJyksXHJcbiAgICBFeHBvOiByZXF1aXJlKCcuL0V4cG8nKSxcclxuICAgIExpbmVhcjogcmVxdWlyZSgnLi9MaW5lYXInKSxcclxuICAgIFF1YWRyYXRpYzogcmVxdWlyZSgnLi9RdWFkcmF0aWMnKSxcclxuICAgIFF1YXJ0aWM6IHJlcXVpcmUoJy4vUXVhcnRpYycpLFxyXG4gICAgUXVpbnRpYzogcmVxdWlyZSgnLi9RdWludGljJyksXHJcbiAgICBTaW5lOiByZXF1aXJlKCcuL1NpbmUnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2Vhc2luZy9pbmRleC5qcyIsInZhciBDZWlsID0gZnVuY3Rpb24gKHZhbHVlLCBlcHNpbG9uKVxyXG57XHJcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKHZhbHVlIC0gZXBzaWxvbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlaWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvQ2VpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbCA9IGZ1bmN0aW9uIChhLCBiLCBlcHNpbG9uKVxyXG57XHJcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgZXBzaWxvbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvRXF1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDI4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvb3IgPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUgKyBlcHNpbG9uKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmxvb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvRmxvb3IuanNcbi8vIG1vZHVsZSBpZCA9IDI4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR3JlYXRlclRoYW4gPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIGEgPiBiIC0gZXBzaWxvbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JlYXRlclRoYW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvR3JlYXRlclRoYW4uanNcbi8vIG1vZHVsZSBpZCA9IDI4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGVzc1RoYW4gPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIGEgPCBiICsgZXBzaWxvbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGVzc1RoYW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvTGVzc1RoYW4uanNcbi8vIG1vZHVsZSBpZCA9IDI4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBDZWlsOiByZXF1aXJlKCcuL0NlaWwnKSxcclxuICAgIEVxdWFsOiByZXF1aXJlKCcuL0VxdWFsJyksXHJcbiAgICBGbG9vcjogcmVxdWlyZSgnLi9GbG9vcicpLFxyXG4gICAgR3JlYXRlclRoYW46IHJlcXVpcmUoJy4vR3JlYXRlclRoYW4nKSxcclxuICAgIExlc3NUaGFuOiByZXF1aXJlKCcuL0xlc3NUaGFuJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2Z1enp5L2luZGV4LmpzIiwidmFyIEJlcm5zdGVpbiA9IHJlcXVpcmUoJy4uL0Jlcm5zdGVpbicpO1xyXG5cclxudmFyIEJlemllckludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodiwgaylcclxue1xyXG4gICAgdmFyIGIgPSAwO1xyXG4gICAgdmFyIG4gPSB2Lmxlbmd0aCAtIDE7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGIgKz0gTWF0aC5wb3coMSAtIGssIG4gLSBpKSAqIE1hdGgucG93KGssIGkpICogdltpXSAqIEJlcm5zdGVpbihuLCBpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV6aWVySW50ZXJwb2xhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0JlemllckludGVycG9sYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2ludGVycG9sYXRpb24vQmV6aWVySW50ZXJwb2xhdGlvbi5qcyIsInZhciBDYXRtdWxsUm9tID0gcmVxdWlyZSgnLi4vQ2F0bXVsbFJvbScpO1xyXG5cclxudmFyIENhdG11bGxSb21JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHYsIGspXHJcbntcclxuICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xyXG4gICAgdmFyIGYgPSBtICogaztcclxuICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcclxuXHJcbiAgICBpZiAodlswXSA9PT0gdlttXSlcclxuICAgIHtcclxuICAgICAgICBpZiAoayA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpID0gTWF0aC5mbG9vcihmID0gbSAqICgxICsgaykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIENhdG11bGxSb20odlsoaSAtIDEgKyBtKSAlIG1dLCB2W2ldLCB2WyhpICsgMSkgJSBtXSwgdlsoaSArIDIpICUgbV0sIGYgLSBpKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZiAoayA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdlswXSAtIChDYXRtdWxsUm9tKHZbMF0sIHZbMF0sIHZbMV0sIHZbMV0sIC1mKSAtIHZbMF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGsgPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZbbV0gLSAoQ2F0bXVsbFJvbSh2W21dLCB2W21dLCB2W20gLSAxXSwgdlttIC0gMV0sIGYgLSBtKSAtIHZbbV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIENhdG11bGxSb20odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2F0bXVsbFJvbUludGVycG9sYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW50ZXJwb2xhdGlvbi9DYXRtdWxsUm9tSW50ZXJwb2xhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9DYXRtdWxsUm9tSW50ZXJwb2xhdGlvbi5qcyIsInZhciBMaW5lYXIgPSByZXF1aXJlKCcuLi9MaW5lYXInKTtcclxuXHJcbnZhciBMaW5lYXJJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHYsIGspXHJcbntcclxuICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xyXG4gICAgdmFyIGYgPSBtICogaztcclxuICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcclxuXHJcbiAgICBpZiAoayA8IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIExpbmVhcih2WzBdLCB2WzFdLCBmKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoayA+IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIExpbmVhcih2W21dLCB2W20gLSAxXSwgbSAtIGYpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBMaW5lYXIodltpXSwgdlsoaSArIDEgPiBtKSA/IG0gOiBpICsgMV0sIGYgLSBpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZWFySW50ZXJwb2xhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0xpbmVhckludGVycG9sYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2ludGVycG9sYXRpb24vTGluZWFySW50ZXJwb2xhdGlvbi5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEJlemllcjogcmVxdWlyZSgnLi9CZXppZXJJbnRlcnBvbGF0aW9uJyksXHJcbiAgICBDYXRtdWxsUm9tOiByZXF1aXJlKCcuL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uJyksXHJcbiAgICBMaW5lYXI6IHJlcXVpcmUoJy4vTGluZWFySW50ZXJwb2xhdGlvbicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2ludGVycG9sYXRpb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2ludGVycG9sYXRpb24vaW5kZXguanMiLCIvLyAgVGFrZXMgdmFsdWUgYW5kIHJldHVybnMgdGhlIG5lYXJlc3QgcG93ZXIgb2YgMlxyXG5cclxudmFyIEdldFBvd2VyT2ZUd28gPSBmdW5jdGlvbiAodmFsdWUpXHJcbntcclxuICAgIC8vICBNYXRoLmxvZygyKVxyXG4gICAgdmFyIGluZGV4ID0gTWF0aC5sb2codmFsdWUpIC8gMC42OTMxNDcxODA1NTk5NDUzO1xyXG5cclxuICAgIHJldHVybiAoMSA8PCBNYXRoLmNlaWwoaW5kZXgpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UG93ZXJPZlR3bztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9wb3cyL0dldFBvd2VyT2ZUd28uanNcbi8vIG1vZHVsZSBpZCA9IDI4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgSXMgdmFsdWUgYSBwb3dlciBvZiAyP1xyXG5cclxudmFyIElzVmFsdWVQb3dlck9mVHdvID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICByZXR1cm4gKHZhbHVlID4gMCAmJiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJc1ZhbHVlUG93ZXJPZlR3bztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9wb3cyL0lzVmFsdWVQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9wb3cyL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydCA9IHtcclxuXHJcbiAgICBHZXROZXh0OiByZXF1aXJlKCcuL0dldFBvd2VyT2ZUd28nKSxcclxuICAgIElzU2l6ZTogcmVxdWlyZSgnLi9Jc1NpemVQb3dlck9mVHdvJyksXHJcbiAgICBJc1ZhbHVlOiByZXF1aXJlKCcuL0lzVmFsdWVQb3dlck9mVHdvJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcG93Mi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBjIC0gSW50ZXJuYWwgdmFyLlxyXG4qIEBwcml2YXRlXHJcbiovXHJcbnZhciBjID0gMTtcclxuXHJcbi8qKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBzMCAtIEludGVybmFsIHZhci5cclxuKiBAcHJpdmF0ZVxyXG4qL1xyXG52YXIgczAgPSAwO1xyXG5cclxuLyoqXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IHMxIC0gSW50ZXJuYWwgdmFyLlxyXG4qIEBwcml2YXRlXHJcbiovXHJcbnZhciBzMSA9IDA7XHJcblxyXG4vKipcclxuKiBAcHJvcGVydHkge251bWJlcn0gczIgLSBJbnRlcm5hbCB2YXIuXHJcbiogQHByaXZhdGVcclxuKi9cclxudmFyIHMyID0gMDtcclxuXHJcbi8qKlxyXG4qIEBwcm9wZXJ0eSB7QXJyYXl9IHNpZ24gLSBJbnRlcm5hbCB2YXIuXHJcbiogQHByaXZhdGVcclxuKi9cclxudmFyIHNpZ24gPSBbIC0xLCAxIF07XHJcblxyXG4vKipcclxuKiBQcml2YXRlIHJhbmRvbSBoZWxwZXIuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3JuZFxyXG4qIEBwcml2YXRlXHJcbiogQHJldHVybiB7bnVtYmVyfVxyXG4qL1xyXG52YXIgcm5kID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIHQgPSAyMDkxNjM5ICogczAgKyBjICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcclxuXHJcbiAgICBjID0gdCB8IDA7XHJcbiAgICBzMCA9IHMxO1xyXG4gICAgczEgPSBzMjtcclxuICAgIHMyID0gdCAtIGM7XHJcblxyXG4gICAgcmV0dXJuIHMyO1xyXG59O1xyXG5cclxuLyoqXHJcbiogSW50ZXJuYWwgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHNlZWQgaGFzaC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjaGFzaFxyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtIHthbnl9IGRhdGFcclxuKiBAcmV0dXJuIHtudW1iZXJ9IGhhc2hlZCB2YWx1ZS5cclxuKi9cclxudmFyIGhhc2ggPSBmdW5jdGlvbiAoZGF0YSlcclxue1xyXG4gICAgdmFyIGgsIGksIG47XHJcbiAgICBuID0gMHhlZmM4MjQ5ZDtcclxuICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xyXG4gICAgICAgIG4gPSBoID4+PiAwO1xyXG4gICAgICAgIGggLT0gbjtcclxuICAgICAgICBoICo9IG47XHJcbiAgICAgICAgbiA9IGggPj4+IDA7XHJcbiAgICAgICAgaCAtPSBuO1xyXG4gICAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOy8vIDJeMzJcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsvLyAyXi0zMlxyXG59O1xyXG5cclxuXHJcbnZhciBSYW5kb21EYXRhR2VuZXJhdG9yID0gZnVuY3Rpb24gKHNlZWRzKVxyXG57XHJcbiAgICBpZiAodHlwZW9mIHNlZWRzID09PSAnc3RyaW5nJylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXRlKHNlZWRzKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNvdyhzZWVkcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5SYW5kb21EYXRhR2VuZXJhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhbmRvbURhdGFHZW5lcmF0b3I7XHJcblxyXG5SYW5kb21EYXRhR2VuZXJhdG9yLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogUmVzZXQgdGhlIHNlZWQgb2YgdGhlIHJhbmRvbSBkYXRhIGdlbmVyYXRvci5cclxuICAgICpcclxuICAgICogX05vdGVfOiB0aGUgc2VlZCBhcnJheSBpcyBvbmx5IHByb2Nlc3NlZCB1cCB0byB0aGUgZmlyc3QgYHVuZGVmaW5lZGAgKG9yIGBudWxsYCkgdmFsdWUsIHNob3VsZCBzdWNoIGJlIHByZXNlbnQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijc293XHJcbiAgICAqIEBwYXJhbSB7YW55W119IHNlZWRzIC0gVGhlIGFycmF5IG9mIHNlZWRzOiB0aGUgYHRvU3RyaW5nKClgIG9mIGVhY2ggdmFsdWUgaXMgdXNlZC5cclxuICAgICovXHJcbiAgICBzb3c6IGZ1bmN0aW9uIChzZWVkcylcclxuICAgIHtcclxuICAgICAgICAvLyBBbHdheXMgcmVzZXQgdG8gZGVmYXVsdCBzZWVkXHJcbiAgICAgICAgczAgPSBoYXNoKCcgJyk7XHJcbiAgICAgICAgczEgPSBoYXNoKHMwKTtcclxuICAgICAgICBzMiA9IGhhc2goczEpO1xyXG4gICAgICAgIGMgPSAxO1xyXG5cclxuICAgICAgICBpZiAoIXNlZWRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgYW55IHNlZWRzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWVkcy5sZW5ndGggJiYgKHNlZWRzW2ldICE9IG51bGwpOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc2VlZCA9IHNlZWRzW2ldO1xyXG5cclxuICAgICAgICAgICAgczAgLT0gaGFzaChzZWVkKTtcclxuICAgICAgICAgICAgczAgKz0gfn4oczAgPCAwKTtcclxuICAgICAgICAgICAgczEgLT0gaGFzaChzZWVkKTtcclxuICAgICAgICAgICAgczEgKz0gfn4oczEgPCAwKTtcclxuICAgICAgICAgICAgczIgLT0gaGFzaChzZWVkKTtcclxuICAgICAgICAgICAgczIgKz0gfn4oczIgPCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMl4zMi5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNpbnRlZ2VyXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDJeMzIuXHJcbiAgICAqL1xyXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAyXjMyXHJcbiAgICAgICAgcmV0dXJuIHJuZCgpICogMHgxMDAwMDAwMDA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNmcmFjXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgKi9cclxuICAgIGZyYWM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gMl4tNTNcclxuICAgICAgICByZXR1cm4gcm5kKCkgKyAocm5kKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAwIGFuZCAyXjMyLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3JlYWxcclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIDAgYW5kIDJeMzIuXHJcbiAgICAqL1xyXG4gICAgcmVhbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKCkgKyB0aGlzLmZyYWMoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIGFuZCBpbmNsdWRpbmcgbWluIGFuZCBtYXguXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjaW50ZWdlckluUmFuZ2VcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICAgICovXHJcbiAgICBpbnRlZ2VySW5SYW5nZTogZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMucmVhbEluUmFuZ2UoMCwgbWF4IC0gbWluICsgMSkgKyBtaW4pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gYW5kIGluY2x1ZGluZyBtaW4gYW5kIG1heC5cclxuICAgICogVGhpcyBtZXRob2QgaXMgYW4gYWxpYXMgZm9yIFJhbmRvbURhdGFHZW5lcmF0b3IuaW50ZWdlckluUmFuZ2UuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjYmV0d2VlblxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxyXG4gICAgKi9cclxuICAgIGJldHdlZW46IGZ1bmN0aW9uIChtaW4sIG1heClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VySW5SYW5nZShtaW4sIG1heCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXguXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjcmVhbEluUmFuZ2VcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICAgICovXHJcbiAgICByZWFsSW5SYW5nZTogZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyYWMoKSAqIChtYXggLSBtaW4pICsgbWluO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIC0xIGFuZCAxLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI25vcm1hbFxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gLTEgYW5kIDEuXHJcbiAgICAqL1xyXG4gICAgbm9ybWFsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gKDIgKiB0aGlzLmZyYWMoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgdmFsaWQgUkZDNDEyMiB2ZXJzaW9uNCBJRCBoZXggc3RyaW5nIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTMwODM2OFxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3V1aWRcclxuICAgICogQHJldHVybiB7c3RyaW5nfSBBIHZhbGlkIFJGQzQxMjIgdmVyc2lvbjQgSUQgaGV4IHN0cmluZ1xyXG4gICAgKi9cclxuICAgIHV1aWQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSAnJztcclxuICAgICAgICB2YXIgYiA9ICcnO1xyXG5cclxuICAgICAgICBmb3IgKGIgPSBhID0gJyc7IGErKyA8IDM2OyBiICs9fmEgJSA1IHwgYSAqIDMmNCA/IChhXjE1ID8gOF50aGlzLmZyYWMoKSAqIChhXjIwID8gMTYgOiA0KSA6IDQpLnRvU3RyaW5nKDE2KSA6ICctJylcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gbWVtYmVyIG9mIGBhcnJheWAuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjcGlja1xyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEFuIEFycmF5IHRvIHBpY2sgYSByYW5kb20gbWVtYmVyIG9mLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IEEgcmFuZG9tIG1lbWJlciBvZiB0aGUgYXJyYXkuXHJcbiAgICAqL1xyXG4gICAgcGljazogZnVuY3Rpb24gKGFycmF5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBhcnJheVt0aGlzLmludGVnZXJJblJhbmdlKDAsIGFycmF5Lmxlbmd0aCAtIDEpXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSBzaWduIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsaWNhdGlvbiBvcGVyYXRvci5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNzaWduXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gLTEgb3IgKzEuXHJcbiAgICAqL1xyXG4gICAgc2lnbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5waWNrKHNpZ24pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBtZW1iZXIgb2YgYGFycmF5YCwgZmF2b3JpbmcgdGhlIGVhcmxpZXIgZW50cmllcy5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciN3ZWlnaHRlZFBpY2tcclxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBBbiBBcnJheSB0byBwaWNrIGEgcmFuZG9tIG1lbWJlciBvZi5cclxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBtZW1iZXIgb2YgdGhlIGFycmF5LlxyXG4gICAgKi9cclxuICAgIHdlaWdodGVkUGljazogZnVuY3Rpb24gKGFycmF5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBhcnJheVt+fihNYXRoLnBvdyh0aGlzLmZyYWMoKSwgMikgKiAoYXJyYXkubGVuZ3RoIC0gMSkgKyAwLjUpXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gdGltZXN0YW1wIGJldHdlZW4gbWluIGFuZCBtYXgsIG9yIGJldHdlZW4gdGhlIGJlZ2lubmluZyBvZiAyMDAwIGFuZCB0aGUgZW5kIG9mIDIwMjAgaWYgbWluIGFuZCBtYXggYXJlbid0IHNwZWNpZmllZC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciN0aW1lc3RhbXBcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSB0aW1lc3RhbXAgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICAgICovXHJcbiAgICB0aW1lc3RhbXA6IGZ1bmN0aW9uIChtaW4sIG1heClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFsSW5SYW5nZShtaW4gfHwgOTQ2Njg0ODAwMDAwLCBtYXggfHwgMTU3Nzg2MjAwMDAwMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGFuZ2xlIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2FuZ2xlXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxyXG4gICAgKi9cclxuICAgIGFuZ2xlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXJJblJhbmdlKC0xODAsIDE4MCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJvdGF0aW9uIGluIHJhZGlhbnMsIGJldHdlZW4gLTMuMTQxIGFuZCAzLjE0MVxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3JvdGF0aW9uXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gLTMuMTQxIGFuZCAzLjE0MVxyXG4gICAgKi9cclxuICAgIHJvdGF0aW9uOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWxJblJhbmdlKC0zLjE0MTU5MjY1MzU4OTc5MywgMy4xNDE1OTI2NTM1ODk3OTMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogR2V0cyBvciBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgZ2VuZXJhdG9yLiBUaGlzIGFsbG93cyB5b3UgdG8gcmV0YWluIHRoZSB2YWx1ZXNcclxuICAgICogdGhhdCB0aGUgZ2VuZXJhdG9yIGlzIHVzaW5nIGJldHdlZW4gZ2FtZXMsIGkuZS4gaW4gYSBnYW1lIHNhdmUgZmlsZS5cclxuICAgICpcclxuICAgICogVG8gc2VlZCB0aGlzIGdlbmVyYXRvciB3aXRoIGEgcHJldmlvdXNseSBzYXZlZCBzdGF0ZSB5b3UgY2FuIHBhc3MgaXQgYXMgdGhlXHJcbiAgICAqIGBzZWVkYCB2YWx1ZSBpbiB5b3VyIGdhbWUgY29uZmlnLCBvciBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5IGFmdGVyIFBoYXNlciBoYXMgYm9vdGVkLlxyXG4gICAgKlxyXG4gICAgKiBDYWxsIHRoaXMgbWV0aG9kIHdpdGggbm8gcGFyYW1ldGVycyB0byByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAgICAqXHJcbiAgICAqIElmIHByb3ZpZGluZyBhIHN0YXRlIGl0IHNob3VsZCBtYXRjaCB0aGUgc2FtZSBmb3JtYXQgdGhhdCB0aGlzIG1ldGhvZFxyXG4gICAgKiByZXR1cm5zLCB3aGljaCBpcyBhIHN0cmluZyB3aXRoIGEgaGVhZGVyIGAhcm5kYCBmb2xsb3dlZCBieSB0aGUgYGNgLFxyXG4gICAgKiBgczBgLCBgczFgIGFuZCBgczJgIHZhbHVlcyByZXNwZWN0aXZlbHksIGVhY2ggY29tbWEtZGVsaW1pdGVkLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3N0YXRlXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RhdGVdIC0gR2VuZXJhdG9yIHN0YXRlIHRvIGJlIHNldC5cclxuICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2VuZXJhdG9yLlxyXG4gICAgKi9cclxuICAgIHN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3N0cmluZycgJiYgc3RhdGUubWF0Y2goL14hcm5kLykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnNwbGl0KCcsJyk7XHJcblxyXG4gICAgICAgICAgICBjID0gcGFyc2VGbG9hdChzdGF0ZVsxXSk7XHJcbiAgICAgICAgICAgIHMwID0gcGFyc2VGbG9hdChzdGF0ZVsyXSk7XHJcbiAgICAgICAgICAgIHMxID0gcGFyc2VGbG9hdChzdGF0ZVszXSk7XHJcbiAgICAgICAgICAgIHMyID0gcGFyc2VGbG9hdChzdGF0ZVs0XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gWyAnIXJuZCcsIGMsIHMwLCBzMSwgczIgXS5qb2luKCcsJyk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21EYXRhR2VuZXJhdG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3JhbmRvbS1kYXRhLWdlbmVyYXRvci9SYW5kb21EYXRhR2VuZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNuYXBDZWlsID0gZnVuY3Rpb24gKHZhbHVlLCBnYXAsIHN0YXJ0KVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuXHJcbiAgICBpZiAoZ2FwID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZSAtPSBzdGFydDtcclxuICAgIHZhbHVlID0gZ2FwICogTWF0aC5jZWlsKHZhbHVlIC8gZ2FwKTtcclxuXHJcbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU25hcENlaWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvc25hcC9TbmFwQ2VpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwRmxvb3IgPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXHJcbntcclxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxyXG5cclxuICAgIGlmIChnYXAgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlIC09IHN0YXJ0O1xyXG4gICAgdmFsdWUgPSBnYXAgKiBNYXRoLmZsb29yKHZhbHVlIC8gZ2FwKTtcclxuXHJcbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU25hcEZsb29yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3NuYXAvU25hcEZsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNuYXBUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgZ2FwLCBzdGFydClcclxue1xyXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XHJcblxyXG4gICAgaWYgKGdhcCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFsdWUgLT0gc3RhcnQ7XHJcbiAgICB2YWx1ZSA9IGdhcCAqIE1hdGgucm91bmQodmFsdWUgLyBnYXApO1xyXG5cclxuICAgIHJldHVybiBzdGFydCArIHZhbHVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbmFwVG87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvc25hcC9TbmFwVG8uanNcbi8vIG1vZHVsZSBpZCA9IDI5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBDZWlsOiByZXF1aXJlKCcuL1NuYXBDZWlsJyksXHJcbiAgICBGbG9vcjogcmVxdWlyZSgnLi9TbmFwRmxvb3InKSxcclxuICAgIFRvOiByZXF1aXJlKCcuL1NuYXBUbycpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3NuYXAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL3NuYXAvaW5kZXguanMiLCIvKipcclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogQSBwb2x5ZmlsbCBmb3IgQXJyYXkuZm9yRWFjaFxyXG4qIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2hcclxuKi9cclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaClcclxue1xyXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZnVuIC8qLCB0aGlzQXJnICovKVxyXG4gICAge1xyXG4gICAgICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XHJcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZ1biAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGkgaW4gdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9BcnJheS5mb3JFYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIEEgcG9seWZpbGwgZm9yIEFycmF5LmlzQXJyYXlcclxuKi9cclxuaWYgKCFBcnJheS5pc0FycmF5KVxyXG57XHJcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKGFyZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9BcnJheS5pc0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogQ29weXJpZ2h0IDIwMTMgQ2hyaXMgV2lsc29uXG5cbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLypcblxuVGhpcyBtb25rZXlwYXRjaCBsaWJyYXJ5IGlzIGludGVuZGVkIHRvIGJlIGluY2x1ZGVkIGluIHByb2plY3RzIHRoYXQgYXJlXG53cml0dGVuIHRvIHRoZSBwcm9wZXIgQXVkaW9Db250ZXh0IHNwZWMgKGluc3RlYWQgb2Ygd2Via2l0QXVkaW9Db250ZXh0KSxcbmFuZCB0aGF0IHVzZSB0aGUgbmV3IG5hbWluZyBhbmQgcHJvcGVyIGJpdHMgb2YgdGhlIFdlYiBBdWRpbyBBUEkgKGUuZy5cbnVzaW5nIEJ1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKSBpbnN0ZWFkIG9mIEJ1ZmZlclNvdXJjZU5vZGUubm90ZU9uKCkpLCBidXQgbWF5XG5oYXZlIHRvIHJ1biBvbiBzeXN0ZW1zIHRoYXQgb25seSBzdXBwb3J0IHRoZSBkZXByZWNhdGVkIGJpdHMuXG5cblRoaXMgbGlicmFyeSBzaG91bGQgYmUgaGFybWxlc3MgdG8gaW5jbHVkZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0c1xudW5wcmVmaXhlZCBcIkF1ZGlvQ29udGV4dFwiLCBhbmQvb3IgaWYgaXQgc3VwcG9ydHMgdGhlIG5ldyBuYW1lcy5cblxuVGhlIHBhdGNoZXMgdGhpcyBsaWJyYXJ5IGhhbmRsZXM6XG5pZiB3aW5kb3cuQXVkaW9Db250ZXh0IGlzIHVuc3VwcG9ydGVkLCBpdCB3aWxsIGJlIGFsaWFzZWQgdG8gd2Via2l0QXVkaW9Db250ZXh0KCkuXG5pZiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKSBpcyB1bmltcGxlbWVudGVkLCBpdCB3aWxsIGJlIHJvdXRlZCB0byBub3RlT24oKSBvclxubm90ZUdyYWluT24oKSwgZGVwZW5kaW5nIG9uIHBhcmFtZXRlcnMuXG5cblRoZSBmb2xsb3dpbmcgYWxpYXNlcyBvbmx5IHRha2UgZWZmZWN0IGlmIHRoZSBuZXcgbmFtZXMgYXJlIG5vdCBhbHJlYWR5IGluIHBsYWNlOlxuXG5BdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RvcCgpIGlzIGFsaWFzZWQgdG8gbm90ZU9mZigpXG5BdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpIGlzIGFsaWFzZWQgdG8gY3JlYXRlR2Fpbk5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZURlbGF5KCkgaXMgYWxpYXNlZCB0byBjcmVhdGVEZWxheU5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcigpIGlzIGFsaWFzZWQgdG8gY3JlYXRlSmF2YVNjcmlwdE5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZVBlcmlvZGljV2F2ZSgpIGlzIGFsaWFzZWQgdG8gY3JlYXRlV2F2ZVRhYmxlKClcbk9zY2lsbGF0b3JOb2RlLnN0YXJ0KCkgaXMgYWxpYXNlZCB0byBub3RlT24oKVxuT3NjaWxsYXRvck5vZGUuc3RvcCgpIGlzIGFsaWFzZWQgdG8gbm90ZU9mZigpXG5Pc2NpbGxhdG9yTm9kZS5zZXRQZXJpb2RpY1dhdmUoKSBpcyBhbGlhc2VkIHRvIHNldFdhdmVUYWJsZSgpXG5BdWRpb1BhcmFtLnNldFRhcmdldEF0VGltZSgpIGlzIGFsaWFzZWQgdG8gc2V0VGFyZ2V0VmFsdWVBdFRpbWUoKVxuXG5UaGlzIGxpYnJhcnkgZG9lcyBOT1QgcGF0Y2ggdGhlIGVudW1lcmF0ZWQgdHlwZSBjaGFuZ2VzLCBhcyBpdCBpc1xucmVjb21tZW5kZWQgaW4gdGhlIHNwZWNpZmljYXRpb24gdGhhdCBpbXBsZW1lbnRhdGlvbnMgc3VwcG9ydCBib3RoIGludGVnZXJcbmFuZCBzdHJpbmcgdHlwZXMgZm9yIEF1ZGlvUGFubmVyTm9kZS5wYW5uaW5nTW9kZWwsIEF1ZGlvUGFubmVyTm9kZS5kaXN0YW5jZU1vZGVsXG5CaXF1YWRGaWx0ZXJOb2RlLnR5cGUgYW5kIE9zY2lsbGF0b3JOb2RlLnR5cGUuXG5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZXhwb3J0cywgcGVyZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gZml4U2V0VGFyZ2V0KHBhcmFtKSB7XG4gICAgaWYgKCFwYXJhbSlcdC8vIGlmIE5ZSSwganVzdCByZXR1cm5cbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXBhcmFtLnNldFRhcmdldEF0VGltZSlcbiAgICAgIHBhcmFtLnNldFRhcmdldEF0VGltZSA9IHBhcmFtLnNldFRhcmdldFZhbHVlQXRUaW1lO1xuICB9XG5cbiAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0QXVkaW9Db250ZXh0JykgJiZcbiAgICAgICF3aW5kb3cuaGFzT3duUHJvcGVydHkoJ0F1ZGlvQ29udGV4dCcpKSB7XG4gICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdlYmtpdEF1ZGlvQ29udGV4dDtcblxuICAgIGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlR2FpbicpKVxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluTm9kZTtcbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZURlbGF5JykpXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5ID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheU5vZGU7XG4gICAgaWYgKCFBdWRpb0NvbnRleHQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjcmVhdGVTY3JpcHRQcm9jZXNzb3InKSlcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlU2NyaXB0UHJvY2Vzc29yID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVKYXZhU2NyaXB0Tm9kZTtcbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZVBlcmlvZGljV2F2ZScpKVxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVQZXJpb2RpY1dhdmUgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVdhdmVUYWJsZTtcblxuXG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZUdhaW4oKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmdhaW4pO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlRGVsYXkgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5O1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXkgPSBmdW5jdGlvbihtYXhEZWxheVRpbWUpIHtcbiAgICAgIHZhciBub2RlID0gbWF4RGVsYXlUaW1lID8gdGhpcy5pbnRlcm5hbF9jcmVhdGVEZWxheShtYXhEZWxheVRpbWUpIDogdGhpcy5pbnRlcm5hbF9jcmVhdGVEZWxheSgpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGVsYXlUaW1lKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUJ1ZmZlclNvdXJjZSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyU291cmNlO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyU291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcbiAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICggd2hlbiwgb2Zmc2V0LCBkdXJhdGlvbiApIHtcbiAgICAgICAgICBpZiAoIG9mZnNldCB8fCBkdXJhdGlvbiApXG4gICAgICAgICAgICB0aGlzLm5vdGVHcmFpbk9uKCB3aGVuIHx8IDAsIG9mZnNldCwgZHVyYXRpb24gKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm5vdGVPbiggd2hlbiB8fCAwICk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0ID0gbm9kZS5zdGFydDtcbiAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uKCB3aGVuLCBvZmZzZXQsIGR1cmF0aW9uICkge1xuICAgICAgICAgIGlmKCB0eXBlb2YgZHVyYXRpb24gIT09ICd1bmRlZmluZWQnIClcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCwgb2Zmc2V0LCBkdXJhdGlvbiApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCwgb2Zmc2V0IHx8IDAgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZS5zdG9wKSB7XG4gICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICB0aGlzLm5vdGVPZmYoIHdoZW4gfHwgMCApO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wID0gbm9kZS5zdG9wO1xuICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiggd2hlbiApIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AoIHdoZW4gfHwgMCApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUucGxheWJhY2tSYXRlKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS50aHJlc2hvbGQpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUua25lZSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5yYXRpbyk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5yZWR1Y3Rpb24pO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuYXR0YWNrKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLnJlbGVhc2UpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlQmlxdWFkRmlsdGVyID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCaXF1YWRGaWx0ZXI7XG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCaXF1YWRGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmZyZXF1ZW5jeSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5kZXR1bmUpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuUSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5nYWluKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBpZiAoQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSggJ2NyZWF0ZU9zY2lsbGF0b3InICkpIHtcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlT3NjaWxsYXRvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvcjtcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcbiAgICAgICAgICBub2RlLnN0YXJ0ID0gZnVuY3Rpb24gKCB3aGVuICkge1xuICAgICAgICAgICAgdGhpcy5ub3RlT24oIHdoZW4gfHwgMCApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdGFydCA9IG5vZGUuc3RhcnQ7XG4gICAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUuc3RvcCkge1xuICAgICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICAgIHRoaXMubm90ZU9mZiggd2hlbiB8fCAwICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AgPSBub2RlLnN0b3A7XG4gICAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24oIHdoZW4gKSB7XG4gICAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AoIHdoZW4gfHwgMCApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLnNldFBlcmlvZGljV2F2ZSlcbiAgICAgICAgICBub2RlLnNldFBlcmlvZGljV2F2ZSA9IG5vZGUuc2V0V2F2ZVRhYmxlO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5mcmVxdWVuY3kpO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5kZXR1bmUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCcpICYmXG4gICAgICAhd2luZG93Lmhhc093blByb3BlcnR5KCdPZmZsaW5lQXVkaW9Db250ZXh0JykpIHtcbiAgICB3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dCA9IHdlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gIH1cblxufSh3aW5kb3cpKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL0F1ZGlvQ29udGV4dE1vbmtleVBhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8vIEVTNiBNYXRoLnRydW5jIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90cnVuY1xyXG5pZiAoIU1hdGgudHJ1bmMpIHtcclxuICAgIE1hdGgudHJ1bmMgPSBmdW5jdGlvbiB0cnVuYyh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwID8gTWF0aC5jZWlsKHgpIDogTWF0aC5mbG9vcih4KTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4qIEEgcG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXHJcbiovXHJcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcclxuXHJcbiAgICAvKiBqc2hpbnQgZnJlZXplOiBmYWxzZSAqL1xyXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gdGhpcyA6IHRoaXNBcmcsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSAoZnVuY3Rpb24gRihwcm90bykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3RvKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEYucHJvdG90eXBlID0gcHJvdG87XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEYpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCBzdXBlcm5ldzogdHJ1ZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkodGFyZ2V0LnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYm91bmQ7XHJcbiAgICAgICAgfTtcclxuICAgIH0pKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEEgcG9seWZpbGwgZm9yIEFycmF5LmlzQXJyYXlcclxuKi9cclxuaWYgKCFBcnJheS5pc0FycmF5KVxyXG57XHJcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKGFyZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuKiBBIHBvbHlmaWxsIGZvciBBcnJheS5mb3JFYWNoXHJcbiogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaFxyXG4qL1xyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKVxyXG57XHJcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZ1biAvKiwgdGhpc0FyZyAqLylcclxuICAgIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XHJcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiB0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4qIExvdy1idWRnZXQgRmxvYXQzMkFycmF5IGtub2NrLW9mZiwgc3VpdGFibGUgZm9yIHVzZSB3aXRoIFAyLmpzIGluIElFOVxyXG4qIFNvdXJjZTogaHR0cDovL3d3dy5odG1sNWdhbWVkZXZzLmNvbS90b3BpYy81OTg4LXBoYXNlci0xMi1pZTkvXHJcbiogQ2FtZXJvbiBGb2FsZSAoaHR0cDovL3d3dy5raWJpYnUuY29tKVxyXG4qL1xyXG5pZiAodHlwZW9mIHdpbmRvdy5VaW50MzJBcnJheSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB3aW5kb3cuVWludDMyQXJyYXkgIT09IFwib2JqZWN0XCIpXHJcbntcclxuICAgIHZhciBDaGVhcEFycmF5ID0gZnVuY3Rpb24odHlwZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgcHJvdG8gPSBuZXcgQXJyYXkoKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG4gICAgICAgIHdpbmRvd1t0eXBlXSA9IGZ1bmN0aW9uKGFyZykge1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZihhcmcpID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5jYWxsKHRoaXMsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGFyZztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5jYWxsKHRoaXMsIGFyZy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gYXJnLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IGFyZ1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHdpbmRvd1t0eXBlXS5wcm90b3R5cGUgPSBwcm90bztcclxuICAgICAgICB3aW5kb3dbdHlwZV0uY29uc3RydWN0b3IgPSB3aW5kb3dbdHlwZV07XHJcbiAgICB9O1xyXG5cclxuICAgIENoZWFwQXJyYXkoJ0Zsb2F0MzJBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ1VpbnQzMkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnVWludDE2QXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdJbnQxNkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnQXJyYXlCdWZmZXInKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbHNvIGZpeCBmb3IgdGhlIGFic2VudCBjb25zb2xlIGluIElFOVxyXG4gKi9cclxuaWYgKCF3aW5kb3cuY29uc29sZSlcclxue1xyXG4gICAgd2luZG93LmNvbnNvbGUgPSB7fTtcclxuICAgIHdpbmRvdy5jb25zb2xlLmxvZyA9IHdpbmRvdy5jb25zb2xlLmFzc2VydCA9IGZ1bmN0aW9uKCl7fTtcclxuICAgIHdpbmRvdy5jb25zb2xlLndhcm4gPSB3aW5kb3cuY29uc29sZS5hc3NlcnQgPSBmdW5jdGlvbigpe307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBwZXJmb3JtYW5jZS5ub3dcclxuICovXHJcbihmdW5jdGlvbigpe1xyXG5cclxuICBpZiAoXCJwZXJmb3JtYW5jZVwiIGluIHdpbmRvdyA9PSBmYWxzZSkge1xyXG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7fTtcclxuICB9XHJcbiAgXHJcbiAgRGF0ZS5ub3cgPSAoRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkgeyAgLy8gdGhhbmtzIElFOFxyXG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChcIm5vd1wiIGluIHdpbmRvdy5wZXJmb3JtYW5jZSA9PSBmYWxzZSlcclxuICB7XHJcbiAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcclxuICAgIFxyXG4gICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KXtcclxuICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydFxyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiBub3coKXtcclxuICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL0Z1bmN0aW9uLmJpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDMwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLy8gRVM2IE1hdGgudHJ1bmMgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jXHJcbmlmICghTWF0aC50cnVuYykge1xyXG4gICAgTWF0aC50cnVuYyA9IGZ1bmN0aW9uIHRydW5jKHgpIHtcclxuICAgICAgICByZXR1cm4geCA8IDAgPyBNYXRoLmNlaWwoeCkgOiBNYXRoLmZsb29yKHgpO1xyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvTWF0aC50cnVuYy5qc1xuLy8gbW9kdWxlIGlkID0gMzAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG5cclxuLyoqXHJcbiogTG93LWJ1ZGdldCBGbG9hdDMyQXJyYXkga25vY2stb2ZmLCBzdWl0YWJsZSBmb3IgdXNlIHdpdGggUDIuanMgaW4gSUU5XHJcbiogU291cmNlOiBodHRwOi8vd3d3Lmh0bWw1Z2FtZWRldnMuY29tL3RvcGljLzU5ODgtcGhhc2VyLTEyLWllOS9cclxuKiBDYW1lcm9uIEZvYWxlIChodHRwOi8vd3d3LmtpYmlidS5jb20pXHJcbiovXHJcbmlmICh0eXBlb2Ygd2luZG93LlVpbnQzMkFycmF5ICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHdpbmRvdy5VaW50MzJBcnJheSAhPT0gXCJvYmplY3RcIilcclxue1xyXG4gICAgdmFyIENoZWFwQXJyYXkgPSBmdW5jdGlvbih0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwcm90byA9IG5ldyBBcnJheSgpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuXHJcbiAgICAgICAgd2luZG93W3R5cGVdID0gZnVuY3Rpb24oYXJnKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mKGFyZykgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LmNhbGwodGhpcywgYXJnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gYXJnO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LmNhbGwodGhpcywgYXJnLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBhcmcubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gYXJnW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgd2luZG93W3R5cGVdLnByb3RvdHlwZSA9IHByb3RvO1xyXG4gICAgICAgIHdpbmRvd1t0eXBlXS5jb25zdHJ1Y3RvciA9IHdpbmRvd1t0eXBlXTtcclxuICAgIH07XHJcblxyXG4gICAgQ2hlYXBBcnJheSgnRmxvYXQzMkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnVWludDMyQXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdVaW50MTZBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ0ludDE2QXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdBcnJheUJ1ZmZlcicpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvVWludDMyQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEFsc28gZml4IGZvciB0aGUgYWJzZW50IGNvbnNvbGUgaW4gSUU5XHJcbiAqL1xyXG5pZiAoIXdpbmRvdy5jb25zb2xlKVxyXG57XHJcbiAgICB3aW5kb3cuY29uc29sZSA9IHt9O1xyXG4gICAgd2luZG93LmNvbnNvbGUubG9nID0gd2luZG93LmNvbnNvbGUuYXNzZXJ0ID0gZnVuY3Rpb24oKXt9O1xyXG4gICAgd2luZG93LmNvbnNvbGUud2FybiA9IHdpbmRvdy5jb25zb2xlLmFzc2VydCA9IGZ1bmN0aW9uKCl7fTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvY29uc29sZS5qc1xuLy8gbW9kdWxlIGlkID0gMzAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuICogcGVyZm9ybWFuY2Uubm93XHJcbiAqL1xyXG4oZnVuY3Rpb24oKXtcclxuXHJcbiAgaWYgKFwicGVyZm9ybWFuY2VcIiBpbiB3aW5kb3cgPT0gZmFsc2UpIHtcclxuICAgICAgd2luZG93LnBlcmZvcm1hbmNlID0ge307XHJcbiAgfVxyXG4gIFxyXG4gIERhdGUubm93ID0gKERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHsgIC8vIHRoYW5rcyBJRThcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoXCJub3dcIiBpbiB3aW5kb3cucGVyZm9ybWFuY2UgPT0gZmFsc2UpXHJcbiAge1xyXG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XHJcbiAgICBcclxuICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCl7XHJcbiAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnRcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XHJcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9wZXJmb3JtYW5jZS5ub3cuanNcbi8vIG1vZHVsZSBpZCA9IDMwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwiLy8gUmVmZXJlbmNlczpcclxuLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTU3OTY3MVxyXG4vLyBodHRwOi8vdXBkYXRlcy5odG1sNXJvY2tzLmNvbS8yMDEyLzA1L3JlcXVlc3RBbmltYXRpb25GcmFtZS1BUEktbm93LXdpdGgtc3ViLW1pbGxpc2Vjb25kLXByZWNpc2lvblxyXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90aW1oYWxsLzQwNzg2MTRcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0ZpbmFuY2lhbC1UaW1lcy9wb2x5ZmlsbC1zZXJ2aWNlL3RyZWUvbWFzdGVyL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuXHJcbi8vIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCBCcm93c2VyZml5XHJcbi8vIEJyb3dzZXJpZnkgYXV0b21hdGljYWxseSBkZXRlY3RzIHRoZSB1c2Ugb2YgYGdsb2JhbGAgYW5kIHBhc3NlcyB0aGVcclxuLy8gY29ycmVjdCByZWZlcmVuY2Ugb2YgYGdsb2JhbGAsIGBzZWxmYCwgYW5kIGZpbmFsbHkgYHdpbmRvd2BcclxuXHJcbi8vIERhdGUubm93XHJcbmlmICghKERhdGUubm93ICYmIERhdGUucHJvdG90eXBlLmdldFRpbWUpKSB7XHJcbiAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBwZXJmb3JtYW5jZS5ub3dcclxuaWYgKCEoZ2xvYmFsLnBlcmZvcm1hbmNlICYmIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cpKSB7XHJcbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIGlmICghZ2xvYmFsLnBlcmZvcm1hbmNlKSB7XHJcbiAgICAgICAgZ2xvYmFsLnBlcmZvcm1hbmNlID0ge307XHJcbiAgICB9XHJcbiAgICBnbG9iYWwucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xyXG4gICAgfTtcclxufVxyXG5cclxuLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbnZhciBsYXN0VGltZSA9IERhdGUubm93KCk7XHJcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcclxuXHJcbmZvcih2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XHJcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XHJcbiAgICAgICAgZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcbn1cclxuXHJcbmlmICghZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xyXG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICdpcyBub3QgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgZGVsYXkgPSAxNiArIGxhc3RUaW1lIC0gY3VycmVudFRpbWU7XHJcblxyXG4gICAgICAgIGlmIChkZWxheSA8IDApIHtcclxuICAgICAgICAgICAgZGVsYXkgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyZW50VGltZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsYXN0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcclxuICAgICAgICB9LCBkZWxheSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5pZiAoIWdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xyXG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcclxudmFyIERyYXdJbWFnZSA9IHJlcXVpcmUoJy4vdXRpbHMvRHJhd0ltYWdlJyk7XHJcbnZhciBHZXRCbGVuZE1vZGVzID0gcmVxdWlyZSgnLi91dGlscy9HZXRCbGVuZE1vZGVzJyk7XHJcblxyXG52YXIgQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAoZ2FtZSlcclxue1xyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgR2FtZS5cclxuICAgICovXHJcbiAgICAvLyAgTmVlZGVkP1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICAvLyAgTmVlZGVkP1xyXG4gICAgdGhpcy50eXBlID0gQ09OU1QuQ0FOVkFTO1xyXG5cclxuICAgIC8vICBSZWFkIGFsbCB0aGUgZm9sbG93aW5nIGZyb20gZ2FtZSBjb25maWcgKG9yIFN0YXRlIGNvbmZpZz8pXHJcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5hdXRvUmVzaXplID0gZmFsc2U7XHJcblxyXG4gICAgLy8gdGhpcy5zbW9vdGhQcm9wZXJ0eSA9IFBoYXNlci5DYW52YXMuZ2V0U21vb3RoaW5nUHJlZml4KHRoaXMuY29udGV4dCk7XHJcblxyXG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcblxyXG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG5cclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcblxyXG4gICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FudmFzIDJkIGNvbnRleHQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHdpdGhcclxuICAgICAqIEBwcm9wZXJ0eSBjb250ZXh0XHJcbiAgICAgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy52aWV3LmdldENvbnRleHQoJzJkJywgeyBhbHBoYTogdHJ1ZSB9KTtcclxuXHJcbiAgICAvLyAgTWFwIHRvIHRoZSByZXF1aXJlZCBmdW5jdGlvblxyXG4gICAgdGhpcy5kcmF3SW1hZ2UgPSBEcmF3SW1hZ2U7XHJcblxyXG4gICAgdGhpcy5ibGVuZE1vZGVzID0gR2V0QmxlbmRNb2RlcygpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudEFscGhhID0gMTtcclxuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDA7XHJcbiAgICB0aGlzLmN1cnJlbnRTY2FsZU1vZGUgPSAwO1xyXG5cclxuICAgIC8vIHRoaXMudGludE1ldGhvZCA9IHRoaXMudGludFdpdGhQZXJQaXhlbDtcclxuXHJcbiAgICB0aGlzLmluaXQoKTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1JlbmRlcmVyO1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlcztcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlcztcclxuXHJcbiAgICAgICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmF1dG9SZXNpemUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUud2lkdGggPSAodGhpcy53aWR0aCAvIHJlcykgKyAncHgnO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0IC8gcmVzKSArICdweCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiAodGhpcy5zbW9vdGhQcm9wZXJ0eSlcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuY29udGV4dFt0aGlzLnNtb290aFByb3BlcnR5XSA9ICh0aGlzLnNjYWxlTW9kZSA9PT0gU2NhbGVNb2Rlcy5MSU5FQVIpO1xyXG4gICAgICAgIC8vIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBTdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtQaGFzZXIuU3RhdGV9IHN0YXRlIC0gVGhlIFN0YXRlIHRvIGJlIHJlbmRlcmVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVycG9sYXRpb25QZXJjZW50YWdlIC0gVGhlIGN1bXVsYXRpdmUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXNuJ3QgYmVlbiBzaW11bGF0ZWQgeWV0LCBkaXZpZGVkXHJcbiAgICAgKiAgIGJ5IHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IHdpbGwgYmUgc2ltdWxhdGVkIHRoZSBuZXh0IHRpbWUgdXBkYXRlKClcclxuICAgICAqICAgcnVucy4gVXNlZnVsIGZvciBpbnRlcnBvbGF0aW5nIGZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoc3RhdGUsIGludGVycG9sYXRpb25QZXJjZW50YWdlKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCclYyByZW5kZXIgc3RhcnQgJywgJ2NvbG9yOiAjZmZmZmZmOyBiYWNrZ3JvdW5kOiAjMDBmZjAwOycpO1xyXG5cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuICAgICAgICAvLyAgQWRkIFByZS1yZW5kZXIgaG9va1xyXG5cclxuICAgICAgICAvLyAgVE9ETzogQSBTdGF0ZSBzaG91bGQgaGF2ZSB0aGUgb3B0aW9uIG9mIGhhdmluZyBpdHMgb3duIGNhbnZhcyB0byBkcmF3IHRvXHJcblxyXG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcblxyXG4gICAgICAgIC8vICBJZiB0aGUgYWxwaGEgb3IgYmxlbmQgbW9kZSBkaWRuJ3QgY2hhbmdlIHNpbmNlIHRoZSBsYXN0IHJlbmRlciwgdGhlbiBkb24ndCBzZXQgdGhlbSBhZ2FpbiAoc2F2ZXMgMiBvcHMpXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbHBoYSAhPT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFscGhhID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCbGVuZE1vZGUgIT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudFNjYWxlTW9kZSA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNsZWFyQmVmb3JlUmVuZGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0Lmxlbmd0aDsgYysrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3RbY107XHJcblxyXG4gICAgICAgICAgICBjaGlsZC5yZW5kZXJDYW52YXModGhpcywgY2hpbGQsIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCclYyByZW5kZXIgZW5kICcsICdjb2xvcjogI2ZmZmZmZjsgYmFja2dyb3VuZDogI2ZmMDAwMDsnKTtcclxuXHJcbiAgICAgICAgLy8gIEFkZCBQb3N0LXJlbmRlciBob29rXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIENhbnZhcyBET00gZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcclxuICAgICAqIEBwYXJhbSBbcmVtb3ZlVmlldz10cnVlXSB7Ym9vbGVhbn0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBDYW52YXNQb29sXHJcblxyXG4gICAgICAgIHRoaXMudmlldyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJcclxudmFyIERyYXdJbWFnZSA9IGZ1bmN0aW9uIChmcmFtZSwgYmxlbmRNb2RlLCB0cmFuc2Zvcm0sIGFscGhhLCB0aW50LCBiZylcclxue1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuICAgIHZhciBjZCA9IGZyYW1lLmNhbnZhc0RhdGE7XHJcblxyXG4gICAgLy8gIEJsZW5kIE1vZGVcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50QmxlbmRNb2RlICE9PSBibGVuZE1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gYmxlbmRNb2RlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmJsZW5kTW9kZXNbYmxlbmRNb2RlXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQWxwaGFcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50QWxwaGEgIT09IGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEFscGhhID0gYWxwaGE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNtb290aGluZyAoc2hvdWxkIHRoaXMgYmUgYSBHYW1lIE9iamVjdCwgb3IgRnJhbWUgLyBUZXh0dXJlIGxldmVsIHByb3BlcnR5PylcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50U2NhbGVNb2RlICE9PSBmcmFtZS5zb3VyY2Uuc2NhbGVNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIC8vIHRoaXMuY3VycmVudFNjYWxlTW9kZSA9IHNvdXJjZS5zY2FsZU1vZGU7XHJcbiAgICAgICAgLy8gY3R4W3RoaXMuc21vb3RoUHJvcGVydHldID0gKHNvdXJjZS5zY2FsZU1vZGUgPT09IFNjYWxlTW9kZXMuTElORUFSKTtcclxuICAgIH1cclxuXHJcbiAgICBjdHguc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hLCB0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmMsIHRyYW5zZm9ybS5kLCB0cmFuc2Zvcm0udHgsIHRyYW5zZm9ybS50eSk7XHJcbiAgICBjdHguZHJhd0ltYWdlKGZyYW1lLnNvdXJjZS5pbWFnZSwgY2Quc3gsIGNkLnN5LCBjZC5zV2lkdGgsIGNkLnNIZWlnaHQsIHRyYW5zZm9ybS5keCwgdHJhbnNmb3JtLmR5LCBjZC5kV2lkdGgsIGNkLmRIZWlnaHQpO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHJhd0ltYWdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci9jYW52YXMvdXRpbHMvRHJhd0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1vZGVzID0gcmVxdWlyZSgnLi4vLi4vQmxlbmRNb2RlcycpO1xyXG52YXIgQ2FudmFzRmVhdHVyZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9kZXZpY2UvQ2FudmFzRmVhdHVyZXMnKTtcclxuXHJcbnZhciBHZXRCbGVuZE1vZGVzID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIG91dHB1dCA9IFtdO1xyXG4gICAgdmFyIHVzZU5ldyA9IENhbnZhc0ZlYXR1cmVzLnN1cHBvcnROZXdCbGVuZE1vZGVzO1xyXG5cclxuICAgIG91dHB1dFttb2Rlcy5OT1JNQUxdID0gJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5BRERdID0gJ2xpZ2h0ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLk1VTFRJUExZXSA9ICh1c2VOZXcpID8gJ211bHRpcGx5JyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuU0NSRUVOXSA9ICh1c2VOZXcpID8gJ3NjcmVlbicgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLk9WRVJMQVldID0gKHVzZU5ldykgPyAnb3ZlcmxheScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLkRBUktFTl0gPSAodXNlTmV3KSA/ICdkYXJrZW4nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5MSUdIVEVOXSA9ICh1c2VOZXcpID8gJ2xpZ2h0ZW4nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5DT0xPUl9ET0RHRV0gPSAodXNlTmV3KSA/ICdjb2xvci1kb2RnZScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLkNPTE9SX0JVUk5dID0gKHVzZU5ldykgPyAnY29sb3ItYnVybicgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLkhBUkRfTElHSFRdID0gKHVzZU5ldykgPyAnaGFyZC1saWdodCcgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLlNPRlRfTElHSFRdID0gKHVzZU5ldykgPyAnc29mdC1saWdodCcgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLkRJRkZFUkVOQ0VdID0gKHVzZU5ldykgPyAnZGlmZmVyZW5jZScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLkVYQ0xVU0lPTl0gPSAodXNlTmV3KSA/ICdleGNsdXNpb24nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5IVUVdID0gKHVzZU5ldykgPyAnaHVlJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuU0FUVVJBVElPTl0gPSAodXNlTmV3KSA/ICdzYXR1cmF0aW9uJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuQ09MT1JdID0gKHVzZU5ldykgPyAnY29sb3InIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5MVU1JTk9TSVRZXSA9ICh1c2VOZXcpID8gJ2x1bWlub3NpdHknIDogJ3NvdXJjZS1vdmVyJztcclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRCbGVuZE1vZGVzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci9jYW52YXMvdXRpbHMvR2V0QmxlbmRNb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL2NhbnZhcy91dGlscy9HZXRCbGVuZE1vZGVzLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAYXV0aG9yICAgICAgIE1hdCBHcm92ZXMgKEBEb29ybWF0MjMpXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBDcmVhdGVFbXB0eVRleHR1cmUgPSByZXF1aXJlKCcuL3V0aWxzL0NyZWF0ZUVtcHR5VGV4dHVyZScpO1xyXG52YXIgQ3JlYXRlVGV4dHVyZTJESW1hZ2UgPSByZXF1aXJlKCcuL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJESW1hZ2UnKTtcclxudmFyIEJsaXR0ZXJCYXRjaCA9IHJlcXVpcmUoJy4vYmF0Y2hlcy9ibGl0dGVyL0JsaXR0ZXJCYXRjaCcpO1xyXG52YXIgU3ByaXRlQmF0Y2ggPSByZXF1aXJlKCcuL2JhdGNoZXMvc3ByaXRlL1Nwcml0ZUJhdGNoJyk7XHJcbnZhciBTcHJpdGVCYXRjaDMyID0gcmVxdWlyZSgnLi9iYXRjaGVzL3Nwcml0ZS9TcHJpdGVCYXRjaDMyJyk7XHJcbnZhciBCbGVuZE1vZGVzID0gcmVxdWlyZSgnLi4vQmxlbmRNb2RlcycpO1xyXG5cclxudmFyIFdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAoZ2FtZSlcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSBDT05TVC5XRUJHTDtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuXHJcbiAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXHJcbiAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogdHJ1ZSxcclxuICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXHJcbiAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcclxuXHJcbiAgICAgICAgV2ViR0xDb250ZXh0T3B0aW9uczoge1xyXG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXHJcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY29udGV4dExvc3QgPSBmYWxzZTtcclxuICAgIHRoaXMubWF4VGV4dHVyZXMgPSAxO1xyXG4gICAgdGhpcy5tdWx0aVRleHR1cmUgPSBmYWxzZTtcclxuICAgIHRoaXMuYmxlbmRNb2RlcyA9IFtdO1xyXG5cclxuICAgIHRoaXMuZ2wgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuaW5pdCgpO1xyXG5cclxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHRoaXMuZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpO1xyXG5cclxuICAgIHRoaXMuYmxpdHRlckJhdGNoID0gbmV3IEJsaXR0ZXJCYXRjaChnYW1lLCB0aGlzLmdsLCB0aGlzKTtcclxuICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSBudWxsO1xyXG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9ucy5pbmRleE9mKCdPRVNfZWxlbWVudF9pbmRleF91aW50JykgPj0gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNwcml0ZUJhdGNoID0gbmV3IFNwcml0ZUJhdGNoMzIoZ2FtZSwgdGhpcy5nbCwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVCYXRjaCA9IG5ldyBTcHJpdGVCYXRjaChnYW1lLCB0aGlzLmdsLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmJhdGNoID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudFRleHR1cmUyRCA9IG51bGw7XHJcbn07XHJcblxyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYkdMUmVuZGVyZXI7XHJcblxyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2wgPSB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnd2ViZ2wnLCB0aGlzLmNvbmZpZy5XZWJHTENvbnRleHRPcHRpb25zKSB8fCB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgdGhpcy5jb25maWcuV2ViR0xDb250ZXh0T3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5nbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dExvc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLiBUcnkgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlci4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgLy8gIFdpbGwgbmVlZCBzdXBwb3J0aW5nXHJcblxyXG4gICAgICAgIHRoaXMubWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5tYXhUZXh0dXJlcyA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMubXVsdGlUZXh0dXJlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlTXVsdGlFbXB0eVRleHR1cmVzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmVtcHR5VGV4dHVyZSA9IENyZWF0ZUVtcHR5VGV4dHVyZSh0aGlzLmdsLCAxLCAxLCAwLCAwKTtcclxuICAgICAgICAqL1xyXG5cclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG5cclxuICAgICAgICBnbC5jbGVhckNvbG9yKDEsIDAsIDAsIDEpO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgLy8gIFdpbGwgbmVlZCBzdXBwb3J0aW5nXHJcblxyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5jb21wcmVzc2lvbiA9IHt9O1xyXG5cclxuICAgICAgICB2YXIgZXRjMSA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScpO1xyXG4gICAgICAgIHZhciBwdnJ0YyA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJykgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyk7XHJcbiAgICAgICAgdmFyIHMzdGMgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJykgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnKTtcclxuXHJcbiAgICAgICAgaWYgKGV0YzEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMuY29tcHJlc3Npb24uRVRDMSA9IGV0YzE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHZydGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMuY29tcHJlc3Npb24uUFZSVEMgPSBwdnJ0YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzM3RjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLmNvbXByZXNzaW9uLlMzVEMgPSBzM3RjO1xyXG4gICAgICAgIH1cclxuICAgICAgICAqL1xyXG5cclxuICAgICAgICAvLyAgTWFwIEJsZW5kIE1vZGVzXHJcblxyXG4gICAgICAgIHZhciBhZGQgPSBbIGdsLlNSQ19BTFBIQSwgZ2wuRFNUX0FMUEhBIF07XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IFsgZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXTtcclxuICAgICAgICB2YXIgbXVsdGlwbHkgPSBbIGdsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSBdO1xyXG4gICAgICAgIHZhciBzY3JlZW4gPSBbIGdsLlNSQ19BTFBIQSwgZ2wuT05FIF07XHJcblxyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlcyA9IFtcclxuICAgICAgICAgICAgbm9ybWFsLCBhZGQsIG11bHRpcGx5LCBzY3JlZW4sIG5vcm1hbCxcclxuICAgICAgICAgICAgbm9ybWFsLCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsLFxyXG4gICAgICAgICAgICBub3JtYWwsIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwsXHJcbiAgICAgICAgICAgIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwsIG5vcm1hbFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gLTE7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVRleHR1cmUyRDogZnVuY3Rpb24gKHNvdXJjZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgICBpZiAoIXNvdXJjZS5nbFRleHR1cmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzb3VyY2UuZ2xUZXh0dXJlID0gQ3JlYXRlVGV4dHVyZTJESW1hZ2UoZ2wsIHNvdXJjZS5pbWFnZSwgZ2wuTkVBUkVTVCwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBzb3VyY2UuZ2xUZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUZXh0dXJlMkQ6IGZ1bmN0aW9uICh0ZXh0dXJlMkQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFRleHR1cmUyRCAhPT0gdGV4dHVyZTJEKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2guZmx1c2goKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlMkQpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gdGV4dHVyZTJEO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0QmF0Y2g6IGZ1bmN0aW9uIChiYXRjaCwgdGV4dHVyZTJEKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZTJEKHRleHR1cmUyRCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmJhdGNoICE9PSBiYXRjaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJhdGNoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJhdGNoLmJpbmQoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2ggPSBiYXRjaDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzO1xyXG5cclxuICAgICAgICB0aGlzLnZpZXcud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIHRoaXMudmlldy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCA9ICh0aGlzLndpZHRoIC8gcmVzKSArICdweCc7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgLyByZXMpICsgJ3B4JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICAvLyAgTmVlZGVkP1xyXG4gICAgICAgIC8vIHRoaXMuY2xpcFVuaXRYID0gMiAvIHRoaXMud2lkdGg7XHJcbiAgICAgICAgLy8gdGhpcy5jbGlwVW5pdFkgPSAyIC8gdGhpcy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vICBOZWVkZWQ/XHJcbiAgICAgICAgLy8gdGhpcy5wcm9qZWN0aW9uLnggPSAodGhpcy53aWR0aCAvIDIpIC8gcmVzO1xyXG4gICAgICAgIC8vIHRoaXMucHJvamVjdGlvbi55ID0gLSh0aGlzLmhlaWdodCAvIDIpIC8gcmVzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIFN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5TdGF0ZX0gc3RhdGUgLSBUaGUgU3RhdGUgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UgLSBUaGUgY3VtdWxhdGl2ZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhc24ndCBiZWVuIHNpbXVsYXRlZCB5ZXQsIGRpdmlkZWRcclxuICAgICAqICAgYnkgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgd2lsbCBiZSBzaW11bGF0ZWQgdGhlIG5leHQgdGltZSB1cGRhdGUoKVxyXG4gICAgICogICBydW5zLiBVc2VmdWwgZm9yIGludGVycG9sYXRpbmcgZnJhbWVzLlxyXG4gICAgICovXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChzdGF0ZSwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJyVjIHJlbmRlciBzdGFydCAnLCAnY29sb3I6ICNmZmZmZmY7IGJhY2tncm91bmQ6ICMwMGZmMDA7Jyk7XHJcblxyXG4gICAgICAgIC8vICBObyBwb2ludCByZW5kZXJpbmcgaWYgb3VyIGNvbnRleHQgaGFzIGJlZW4gYmxvd24gdXAhXHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dExvc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQWRkIFByZS1yZW5kZXIgaG9va1xyXG5cclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy8gIFRoaXMgaXMgdGhlIG9sZCByZW5kZXIgbG9vcCAtIGFkZCB3aGF0IHlvdSBuZWVkIGhlcmUgdG8gcmVwbGFjZSBpdCxcclxuICAgICAgICAvLyAgYnV0IHBsZWFzZSBhbGxvdyBlYWNoIFN0YXRlIHRvIHJlbmRlciB0byBpdHMgb3duIFF1YWQgRkJPXHJcblxyXG4gICAgICAgIC8vdmFyIGZibyA9IHN0YXRlLnN5cy5mYm87XHJcblxyXG4gICAgICAgIC8vZmJvLmFjdGl2YXRlKCk7XHJcblxyXG4gICAgICAgIC8vICBjbGVhciBpcyBuZWVkZWQgZm9yIHRoZSBGQk8sIG90aGVyd2lzZSBjb3JydXB0aW9uIC4uLlxyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG5cclxuICAgICAgICB0aGlzLnNldEJsZW5kTW9kZShCbGVuZE1vZGVzLk5PUk1BTCk7XHJcblxyXG4gICAgICAgIC8vICBDb3VsZCBtb3ZlIHRvIHRoZSBTdGF0ZSBTeXN0ZW1zIG9yIE1haW5Mb29wXHJcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGMrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdO1xyXG4gICAgICAgICAgICBjaGlsZC5yZW5kZXJXZWJHTCh0aGlzLCBjaGlsZCwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICB2YXIgYmF0Y2ggPSB0aGlzLmJhdGNoO1xyXG4gICAgICAgICAgICBpZiAoYmF0Y2ggJiYgYmF0Y2guaXNGdWxsKCkpXHJcbiAgICAgICAgICAgICAgICBiYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmF0Y2ggPSB0aGlzLmJhdGNoO1xyXG4gICAgICAgIGlmIChiYXRjaClcclxuICAgICAgICAgICAgYmF0Y2guZmx1c2goKTtcclxuXHJcbiAgICAgICAgLy90aGlzLmJhdGNoLnN0b3AoKTtcclxuXHJcbiAgICAgICAgLy8gIENhbGwgc3RhdGUucmVuZGVyIGhlcmUsIHNvIHdlIGNhbiBkbyBzb21lIGV4dHJhIHNoaXp6bGUgb24gdGhlIHRvcFxyXG4gICAgICAgIC8vICBNYXliZSBwYXNzIGluIHRoZSBGQk8gdGV4dHVyZSB0b28/XHJcblxyXG4gICAgICAgIC8vZmJvLnJlbmRlcihudWxsKTtcclxuXHJcbiAgICAgICAgLy8gIFVuYmluZCB0aGUgZmJvIHRleHR1cmUgYW5kIHJlcGxhY2UgaXQgd2l0aCBhbiBlbXB0eSB0ZXh0dXJlLlxyXG4gICAgICAgIC8vICBJZiB3ZSBmb3JnZXQgdGhpcyB3ZSBjb3JydXB0IHRoZSBtYWluIGNvbnRleHQgdGV4dHVyZSFcclxuICAgICAgICAvLyAgb3IgZ2V0IGBSRU5ERVIgV0FSTklORzogdGhlcmUgaXMgbm8gdGV4dHVyZSBib3VuZCB0byB0aGUgdW5pdCAwYCBzcGFtIGluIHRoZSBjb25zb2xlXHJcbiAgICAgICAgLy9nbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmVtcHR5VGV4dHVyZSk7XHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnJWMgcmVuZGVyIGVuZCAnLCAnY29sb3I6ICNmZmZmZmY7IGJhY2tncm91bmQ6ICNmZjAwMDA7Jyk7XHJcblxyXG4gICAgICAgIC8vICBBZGQgUG9zdC1yZW5kZXIgaG9va1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVGQk86IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24gKG5ld0JsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2g7XHJcbiAgICAgICAgdmFyIGJsZW5kID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYmxlbmRNb2RlICE9PSBuZXdCbGVuZE1vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoYmF0Y2gpXHJcbiAgICAgICAgICAgICAgICBiYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgICAgICBibGVuZCA9IHRoaXMuYmxlbmRNb2Rlc1tuZXdCbGVuZE1vZGVdO1xyXG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgICAgICBpZiAoYmxlbmQubGVuZ3RoID4gMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoYmxlbmRbMF0sIGJsZW5kWzFdLCBibGVuZFsyXSwgYmxlbmRbM10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGJsZW5kWzBdLCBibGVuZFsxXSk7ICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IG5ld0JsZW5kTW9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyLmpzIiwiLy8gIENvdWxkIHlvdSBtb3ZlIHRoZXNlIGludG8gc3ViLWZvbGRlcnMgcGxlYXNlLCBpLmUuICd2YW8nLCAnc2hhZGVyJyBldGM/XHJcblxyXG52YXIgQmluZFZlcnRleEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL0JpbmRWZXJ0ZXhBcnJheScpO1xyXG52YXIgQ3JlYXRlUHJvZ3JhbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtJyk7XHJcbnZhciBDcmVhdGVTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9zaGFkZXIvQ3JlYXRlU2hhZGVyJyk7XHJcbnZhciBDcmVhdGVCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9idWZmZXIvQ3JlYXRlQnVmZmVyJyk7XHJcbnZhciBDcmVhdGVBdHRyaWJEZXNjID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MnKTtcclxudmFyIFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9WZXJ0ZXhCdWZmZXInKTtcclxudmFyIEluZGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL0luZGV4QnVmZmVyJyk7XHJcbnZhciBWZXJ0ZXhBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3Zhby9WZXJ0ZXhBcnJheScpO1xyXG5cclxudmFyIFBIQVNFUl9DT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBCbGl0dGVyQmF0Y2ggPSBmdW5jdGlvbiAoZ2FtZSwgZ2wsIG1hbmFnZXIpXHJcbntcclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICB0aGlzLnR5cGUgPSBQSEFTRVJfQ09OU1QuV0VCR0w7XHJcblxyXG4gICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICB0aGlzLmdsQ29udGV4dCA9IGdsO1xyXG5cclxuICAgIHRoaXMubWF4UGFydGljbGVzID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnZlcnRTaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy5mcmFnU2hhZGVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xyXG5cclxuICAgIHRoaXMudmVydGV4QXJyYXkgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBudWxsO1xyXG4gICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSBudWxsO1xyXG5cclxuICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcclxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xyXG59O1xyXG5cclxuQmxpdHRlckJhdGNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsaXR0ZXJCYXRjaDtcclxuXHJcbkJsaXR0ZXJCYXRjaC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGdsKVxyXG4gICAge1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBWZXJ0ZXhCdWZmZXIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5QQVJUSUNMRV9WRVJURVhfQ09VTlQgKiBDT05TVC5NQVhfUEFSVElDTEVTKTtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4RGF0YUJ1ZmZlciA9IG5ldyBJbmRleEJ1ZmZlcihDT05TVC5JTkRFWF9TSVpFICogQ09OU1QuUEFSVElDTEVfSU5ERVhfQ09VTlQgKiBDT05TVC5NQVhfUEFSVElDTEVTKTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRTaGFkZXIgPSBDcmVhdGVTaGFkZXIoZ2wsIENPTlNULlZFUlRFWF9TSEFERVJfU09VUkNFLCBnbC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgICB2YXIgZnJhZ1NoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgQ09OU1QuRlJBR01FTlRfU0hBREVSX1NPVVJDRSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IENyZWF0ZVByb2dyYW0oZ2wsIHZlcnRTaGFkZXIsIGZyYWdTaGFkZXIpO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXJPYmplY3QgPSBDcmVhdGVCdWZmZXIoZ2wsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnbC5TVEFUSUNfRFJBVywgbnVsbCwgaW5kZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcclxuXHJcbiAgICAgICAgdmFyIGF0dHJpYkFycmF5ID0gW1xyXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV9wb3NpdGlvbicsIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDApLFxyXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV90ZXhfY29vcmQnLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCA4KSxcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfYWxwaGEnLCAxLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAxNilcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4QXJyYXkgPSBuZXcgVmVydGV4QXJyYXkoQ3JlYXRlQnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGdsLlNUUkVBTV9EUkFXLCBudWxsLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKSwgYXR0cmliQXJyYXkpO1xyXG5cclxuICAgICAgICB2YXIgdmlld01hdHJpeExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3ZpZXdfbWF0cml4Jyk7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBpbmRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIHRoaXMudmVydFNoYWRlciA9IHZlcnRTaGFkZXI7XHJcbiAgICAgICAgdGhpcy5mcmFnU2hhZGVyID0gZnJhZ1NoYWRlcjtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG5cclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gaW5kZXhCdWZmZXJPYmplY3Q7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheSA9IHZlcnRleEFycmF5O1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSB2aWV3TWF0cml4TG9jYXRpb247XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBpbmRleERhdGFCdWZmZXIud29yZFZpZXc7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9QQVJUSUNMRVMgKiBDT05TVC5QQVJUSUNMRV9JTkRFWF9DT1VOVDtcclxuXHJcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIHRoZSBpbmRleCBidWZmZXIgb25seSBvbmNlXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXhBID0gMCwgaW5kZXhCID0gMDsgaW5kZXhBIDwgbWF4OyBpbmRleEEgKz0gQ09OU1QuUEFSVElDTEVfSU5ERVhfQ09VTlQsIGluZGV4QiArPSBDT05TVC5QQVJUSUNMRV9WRVJURVhfQ09VTlQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAwXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMl0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAzXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNV0gPSBpbmRleEIgKyAzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCAwLCBpbmRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzV29yZCgpKTtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kKCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy51bmJpbmQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgaXNGdWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVMZW5ndGgoKSA+PSB0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCBmcmFtZSwgYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNldEJhdGNoKHRoaXMsIGZyYW1lLnRleHR1cmUuc291cmNlW2ZyYW1lLnNvdXJjZUluZGV4XS5nbFRleHR1cmUpO1xyXG5cclxuICAgICAgICAvLyBUaGUgdXNlciBtdXN0IGNoZWNrIGlmIHRoZSBidWZmZXJzIGFyZSBmdWxsIGJlZm9yZSBmbHVzaGluZ1xyXG4gICAgICAgIC8vIHRoaXMgaXMgdG8gZ2l2ZSBmcmVlZG9tIG9mIHdoZW4gc2hvdWxkIHRoZSByZW5kZXJlciBmbHVzaC4gdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKENPTlNULlBBUlRJQ0xFX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQgKiBDT05TVC5QQVJUSUNMRV9WRVJURVhfQ09VTlQpO1xyXG4gICAgICAgIHZhciB1dnMgPSBmcmFtZS51dnM7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGZyYW1lLmhlaWdodDtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHggKyB3aWR0aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geCArIHdpZHRoO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB5O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IENPTlNULlBBUlRJQ0xFX0lOREVYX0NPVU5UO1xyXG4gICAgfSxcclxuXHJcbiAgICBiaW5kOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG5cclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcblxyXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMSk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICBCaW5kVmVydGV4QXJyYXkoZ2wsIHRoaXMudmVydGV4QXJyYXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0obnVsbCk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmx1c2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldFVzZWRCdWZmZXJBc0Zsb2F0KCkpO1xyXG5cclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmVsZW1lbnRDb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhEYXRhQnVmZmVyLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlcztcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlcztcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnZpZXcud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIHRoaXMudmlldy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodGhpcy5hdXRvUmVzaXplKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLndpZHRoID0gKHRoaXMud2lkdGggLyByZXMpICsgJ3B4JztcclxuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLmhlaWdodCA9ICh0aGlzLmhlaWdodCAvIHJlcykgKyAncHgnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbixcclxuICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMudmlldy53aWR0aCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy52aWV3LmhlaWdodCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIDAsIDEsIDEsXHJcbiAgICAgICAgICAgICAgICAtMSwgMSwgMCwgMFxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcblxyXG4gICAgICAgIGlmIChnbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRTaGFkZXIpO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVTaGFkZXIodGhpcy5mcmFnU2hhZGVyKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEFycmF5LmJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxpdHRlckJhdGNoO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvQmxpdHRlckJhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL0JsaXR0ZXJCYXRjaC5qcyIsIm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXHJcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9zYW1wbGVyMkQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICd2YXJ5aW5nIGZsb2F0IHZfYWxwaGE7JyxcclxuICAgICd2b2lkIG1haW4oKSB7JyxcclxuICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9zYW1wbGVyMkQsIHZfdGV4X2Nvb3JkKSAqIHZlYzQoMS4wLCAxLjAsIDEuMCwgdl9hbHBoYSk7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvRnJhZ21lbnRTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFtcclxuICAgICd1bmlmb3JtIG1hdDQgdV92aWV3X21hdHJpeDsnLFxyXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcclxuICAgICdhdHRyaWJ1dGUgdmVjMiBhX3RleF9jb29yZDsnLFxyXG4gICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2FscGhhOycsXHJcbiAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXHJcbiAgICAndmFyeWluZyBmbG9hdCB2X2FscGhhOycsXHJcbiAgICAndm9pZCBtYWluICgpIHsnLFxyXG4gICAgJyAgIGdsX1Bvc2l0aW9uID0gdV92aWV3X21hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wLCAxLjApOycsXHJcbiAgICAnICAgdl90ZXhfY29vcmQgPSBhX3RleF9jb29yZDsnLFxyXG4gICAgJ1x0dl9hbHBoYSA9IGFfYWxwaGE7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvVmVydGV4U2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZyYWdtZW50U2hhZGVyID0gcmVxdWlyZSgnLi9GcmFnbWVudFNoYWRlcicpO1xyXG52YXIgVmVydGV4U2hhZGVyID0gcmVxdWlyZSgnLi9WZXJ0ZXhTaGFkZXInKTtcclxuXHJcbnZhciBDT05TVCA9IHtcclxuXHJcbiAgICAvLyBWRVJURVhfU0laRSA9IHNpemVvZih2ZWMyKSArIHNpemVvZih2ZWMyKSArIHNpemVvZihmbG9hdClcclxuICAgIFZFUlRFWF9TSVpFOiAyMCxcclxuICAgIElOREVYX1NJWkU6IDIsXHJcbiAgICBQQVJUSUNMRV9WRVJURVhfQ09VTlQ6IDQsXHJcbiAgICBQQVJUSUNMRV9JTkRFWF9DT1VOVDogNixcclxuXHJcbiAgICAvLyBIb3cgbWFueSAzMi1iaXQgY29tcG9uZW50cyBkb2VzIHRoZSB2ZXJ0ZXggaGF2ZS5cclxuICAgIFBBUlRJQ0xFX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDUsXHJcblxyXG4gICAgLy8gQ2FuJ3QgYmUgYmlnZ2VyIHNpbmNlIGluZGV4IGFyZSAxNi1iaXRcclxuICAgIE1BWF9QQVJUSUNMRVM6IDEwMDAwLFxyXG5cclxuICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWZXJ0ZXhTaGFkZXIsXHJcbiAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGcmFnbWVudFNoYWRlclxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gMzEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9jb25zdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXHJcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9zYW1wbGVyMkQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzMgdl9jb2xvcjsnLFxyXG4gICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3NhbXBsZXIyRCwgdl90ZXhfY29vcmQpICogdmVjNCh2X2NvbG9yLCAxLjApOycsXHJcbiAgICAnfSdcclxuXS5qb2luKCdcXG4nKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvRnJhZ21lbnRTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmluZFZlcnRleEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL0JpbmRWZXJ0ZXhBcnJheScpO1xyXG52YXIgQ3JlYXRlUHJvZ3JhbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtJyk7XHJcbnZhciBDcmVhdGVTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9zaGFkZXIvQ3JlYXRlU2hhZGVyJyk7XHJcbnZhciBDcmVhdGVCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9idWZmZXIvQ3JlYXRlQnVmZmVyJyk7XHJcbnZhciBDcmVhdGVBdHRyaWJEZXNjID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MnKTtcclxudmFyIFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9WZXJ0ZXhCdWZmZXInKTtcclxudmFyIEluZGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL0luZGV4QnVmZmVyJyk7XHJcbnZhciBWZXJ0ZXhBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3Zhby9WZXJ0ZXhBcnJheScpO1xyXG5cclxudmFyIFBIQVNFUl9DT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBTcHJpdGVCYXRjaCA9IGZ1bmN0aW9uIChnYW1lLCBnbCwgbWFuYWdlcilcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuXHJcbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG5cclxuICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcblxyXG4gICAgdGhpcy5tYXhTcHJpdGVzID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnZlcnRTaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy5mcmFnU2hhZGVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xyXG5cclxuICAgIHRoaXMudmVydGV4QXJyYXkgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBudWxsO1xyXG4gICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSBudWxsO1xyXG5cclxuICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcclxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xyXG59O1xyXG5cclxuU3ByaXRlQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByaXRlQmF0Y2g7XHJcblxyXG5TcHJpdGVCYXRjaC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGdsKVxyXG4gICAge1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBWZXJ0ZXhCdWZmZXIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5TUFJJVEVfVkVSVEVYX0NPVU5UICogQ09OU1QuTUFYX1NQUklURVMpO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IEluZGV4QnVmZmVyKENPTlNULklOREVYX1NJWkUgKiBDT05TVC5TUFJJVEVfSU5ERVhfQ09VTlQgKiBDT05TVC5NQVhfU1BSSVRFUyk7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0U2hhZGVyID0gQ3JlYXRlU2hhZGVyKGdsLCBDT05TVC5WRVJURVhfU0hBREVSX1NPVVJDRSwgZ2wuVkVSVEVYX1NIQURFUik7XHJcbiAgICAgICAgdmFyIGZyYWdTaGFkZXIgPSBDcmVhdGVTaGFkZXIoZ2wsIENPTlNULkZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsIGdsLkZSQUdNRU5UX1NIQURFUik7XHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBDcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0U2hhZGVyLCBmcmFnU2hhZGVyKTtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0ID0gQ3JlYXRlQnVmZmVyKGdsLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG51bGwsIGluZGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJBcnJheSA9IFtcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfcG9zaXRpb24nLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAwKSxcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfdGV4X2Nvb3JkJywgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgOCksXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3RyYW5zbGF0ZScsIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDE2KSxcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2Ffc2NhbGUnLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAyNCksXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3JvdGF0aW9uJywgMSwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMzIpLFxyXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV9jb2xvcicsIDMsIDUxMjEsIHRydWUsIENPTlNULlZFUlRFWF9TSVpFLCAzNilcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4QXJyYXkgPSBuZXcgVmVydGV4QXJyYXkoQ3JlYXRlQnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGdsLlNUUkVBTV9EUkFXLCBudWxsLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKSwgYXR0cmliQXJyYXkpO1xyXG5cclxuICAgICAgICB2YXIgdmlld01hdHJpeExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3ZpZXdfbWF0cml4Jyk7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBpbmRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIHRoaXMudmVydFNoYWRlciA9IHZlcnRTaGFkZXI7XHJcbiAgICAgICAgdGhpcy5mcmFnU2hhZGVyID0gZnJhZ1NoYWRlcjtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG5cclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gaW5kZXhCdWZmZXJPYmplY3Q7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheSA9IHZlcnRleEFycmF5O1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSB2aWV3TWF0cml4TG9jYXRpb247XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBpbmRleERhdGFCdWZmZXIud29yZFZpZXc7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9TUFJJVEVTICogQ09OU1QuU1BSSVRFX0lOREVYX0NPVU5UO1xyXG5cclxuICAgICAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGluZGV4IGJ1ZmZlciBvbmx5IG9uY2VcclxuICAgICAgICBmb3IgKHZhciBpbmRleEEgPSAwLCBpbmRleEIgPSAwOyBpbmRleEEgPCBtYXg7IGluZGV4QSArPSBDT05TVC5TUFJJVEVfSU5ERVhfQ09VTlQsIGluZGV4QiArPSBDT05TVC5TUFJJVEVfVkVSVEVYX0NPVU5UKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMF0gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAxXSA9IGluZGV4QiArIDE7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDJdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgM10gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA0XSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDVdID0gaW5kZXhCICsgMztcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgMCwgaW5kZXhCdWZmZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmJpbmQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLnVuYmluZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGZyYW1lLCBhbmNob3JYLCBhbmNob3JZLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHZlcnRleENvbG9yKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRCYXRjaCh0aGlzLCBmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBjaGVjayBpZiB0aGUgYnVmZmVycyBhcmUgZnVsbCBiZWZvcmUgZmx1c2hpbmdcclxuICAgICAgICAvLyB0aGlzIGlzIHRvIGdpdmUgZnJlZWRvbSBvZiB3aGVuIHNob3VsZCB0aGUgcmVuZGVyZXIgZmx1c2guIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZShDT05TVC5TUFJJVEVfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVCAqIENPTlNULlNQUklURV9WRVJURVhfQ09VTlQpO1xyXG4gICAgICAgIHZhciB1dnMgPSBmcmFtZS51dnM7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGZyYW1lLmhlaWdodDtcclxuICAgICAgICB2YXIgeCA9IHdpZHRoICogLWFuY2hvclg7XHJcbiAgICAgICAgdmFyIHkgPSBoZWlnaHQgKiAtYW5jaG9yWTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0cmFuc2xhdGVYO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0cmFuc2xhdGVZO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBzY2FsZVg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHNjYWxlWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gcm90YXRpb247XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IHZlcnRleENvbG9yLnRvcExlZnQ7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHJhbnNsYXRlWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHJhbnNsYXRlWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gc2NhbGVYO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBzY2FsZVk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHJvdGF0aW9uO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB2ZXJ0ZXhDb2xvci5ib3R0b21MZWZ0O1xyXG4gICAgXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHggKyB3aWR0aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHRyYW5zbGF0ZVg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHRyYW5zbGF0ZVk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHNjYWxlWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gc2NhbGVZO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSByb3RhdGlvbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gdmVydGV4Q29sb3IuYm90dG9tUmlnaHQ7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0cmFuc2xhdGVYO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0cmFuc2xhdGVZO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBzY2FsZVg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHNjYWxlWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gcm90YXRpb247XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IHZlcnRleENvbG9yLnRvcFJpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCArPSBDT05TVC5TUFJJVEVfSU5ERVhfQ09VTlQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuXHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxKTtcclxuXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XHJcblxyXG4gICAgICAgIEJpbmRWZXJ0ZXhBcnJheShnbCwgdGhpcy52ZXJ0ZXhBcnJheSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVuYmluZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShudWxsKTtcclxuXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmbHVzaDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuXHJcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuZWxlbWVudENvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcblxyXG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aGlzLmF1dG9SZXNpemUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUud2lkdGggPSAodGhpcy53aWR0aCAvIHJlcykgKyAncHgnO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0IC8gcmVzKSArICdweCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoXHJcbiAgICAgICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy52aWV3LndpZHRoLCAwLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgLTIgLyB0aGlzLnZpZXcuaGVpZ2h0LCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgaWYgKGdsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMudmVydFNoYWRlcik7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdTaGFkZXIpO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QXJyYXkuYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVCYXRjaDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvU3ByaXRlQmF0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDMxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9TcHJpdGVCYXRjaC5qcyIsInZhciBCaW5kVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQmluZFZlcnRleEFycmF5Jyk7XHJcbnZhciBDcmVhdGVQcm9ncmFtID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc2hhZGVyL0NyZWF0ZVByb2dyYW0nKTtcclxudmFyIENyZWF0ZVNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3NoYWRlci9DcmVhdGVTaGFkZXInKTtcclxudmFyIENyZWF0ZUJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9DcmVhdGVCdWZmZXInKTtcclxudmFyIENyZWF0ZUF0dHJpYkRlc2MgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYycpO1xyXG52YXIgVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL1ZlcnRleEJ1ZmZlcicpO1xyXG52YXIgSW5kZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9idWZmZXIvSW5kZXhCdWZmZXInKTtcclxudmFyIFZlcnRleEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL1ZlcnRleEFycmF5Jyk7XHJcblxyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIFNwcml0ZUJhdGNoMzIgPSBmdW5jdGlvbiAoZ2FtZSwgZ2wsIG1hbmFnZXIpXHJcbntcclxuICAgIGdsLmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpO1xyXG4gICAgQ09OU1QuSU5ERVhfU0laRSA9IDQ7XHJcbiAgICBDT05TVC5NQVhfU1BSSVRFUyA9IDEwMDAwMDtcclxuXHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgdGhpcy50eXBlID0gUEhBU0VSX0NPTlNULldFQkdMO1xyXG5cclxuICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcblxyXG4gICAgdGhpcy5nbENvbnRleHQgPSBnbDtcclxuXHJcbiAgICB0aGlzLm1heFNwcml0ZXMgPSBudWxsO1xyXG5cclxuICAgIHRoaXMudmVydFNoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLmZyYWdTaGFkZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhBcnJheSA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG5cclxuICAgIHRoaXMuY3VycmVudFRleHR1cmUyRCA9IG51bGw7XHJcbiAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgIFdlYkdMQ29udGV4dE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuaW5pdCh0aGlzLmdsQ29udGV4dCk7XHJcbn07XHJcblxyXG5TcHJpdGVCYXRjaDMyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwcml0ZUJhdGNoMzI7XHJcblxyXG5TcHJpdGVCYXRjaDMyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZ2wpXHJcbiAgICB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gbmV3IFZlcnRleEJ1ZmZlcihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULlNQUklURV9WRVJURVhfQ09VTlQgKiBDT05TVC5NQVhfU1BSSVRFUyk7XHJcblxyXG4gICAgICAgIHZhciBpbmRleERhdGFCdWZmZXIgPSBuZXcgVmVydGV4QnVmZmVyKENPTlNULklOREVYX1NJWkUgKiBDT05TVC5TUFJJVEVfSU5ERVhfQ09VTlQgKiBDT05TVC5NQVhfU1BSSVRFUyk7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0U2hhZGVyID0gQ3JlYXRlU2hhZGVyKGdsLCBDT05TVC5WRVJURVhfU0hBREVSX1NPVVJDRSwgZ2wuVkVSVEVYX1NIQURFUik7XHJcbiAgICAgICAgdmFyIGZyYWdTaGFkZXIgPSBDcmVhdGVTaGFkZXIoZ2wsIENPTlNULkZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsIGdsLkZSQUdNRU5UX1NIQURFUik7XHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBDcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0U2hhZGVyLCBmcmFnU2hhZGVyKTtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0ID0gQ3JlYXRlQnVmZmVyKGdsLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG51bGwsIGluZGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJBcnJheSA9IFtcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfcG9zaXRpb24nLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAwKSxcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfdGV4X2Nvb3JkJywgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgOCksXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3RyYW5zbGF0ZScsIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDE2KSxcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2Ffc2NhbGUnLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAyNCksXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3JvdGF0aW9uJywgMSwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMzIpLFxyXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV9jb2xvcicsIDMsIDUxMjEsIHRydWUsIENPTlNULlZFUlRFWF9TSVpFLCAzNilcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4QXJyYXkgPSBuZXcgVmVydGV4QXJyYXkoQ3JlYXRlQnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGdsLlNUUkVBTV9EUkFXLCBudWxsLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKSwgYXR0cmliQXJyYXkpO1xyXG5cclxuICAgICAgICB2YXIgdmlld01hdHJpeExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3ZpZXdfbWF0cml4Jyk7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBpbmRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIHRoaXMudmVydFNoYWRlciA9IHZlcnRTaGFkZXI7XHJcbiAgICAgICAgdGhpcy5mcmFnU2hhZGVyID0gZnJhZ1NoYWRlcjtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG5cclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gaW5kZXhCdWZmZXJPYmplY3Q7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheSA9IHZlcnRleEFycmF5O1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSB2aWV3TWF0cml4TG9jYXRpb247XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBpbmRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9TUFJJVEVTICogQ09OU1QuU1BSSVRFX0lOREVYX0NPVU5UO1xyXG5cclxuICAgICAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGluZGV4IGJ1ZmZlciBvbmx5IG9uY2VcclxuICAgICAgICBmb3IgKHZhciBpbmRleEEgPSAwLCBpbmRleEIgPSAwOyBpbmRleEEgPCBtYXg7IGluZGV4QSArPSBDT05TVC5TUFJJVEVfSU5ERVhfQ09VTlQsIGluZGV4QiArPSBDT05TVC5TUFJJVEVfVkVSVEVYX0NPVU5UKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMF0gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAxXSA9IGluZGV4QiArIDE7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDJdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgM10gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA0XSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDVdID0gaW5kZXhCICsgMztcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgMCwgaW5kZXhCdWZmZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmJpbmQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLnVuYmluZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGZyYW1lLCBhbmNob3JYLCBhbmNob3JZLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHZlcnRleENvbG9yKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRCYXRjaCh0aGlzLCBmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBjaGVjayBpZiB0aGUgYnVmZmVycyBhcmUgZnVsbCBiZWZvcmUgZmx1c2hpbmdcclxuICAgICAgICAvLyB0aGlzIGlzIHRvIGdpdmUgZnJlZWRvbSBvZiB3aGVuIHNob3VsZCB0aGUgcmVuZGVyZXIgZmx1c2guIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZShDT05TVC5TUFJJVEVfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVCAqIENPTlNULlNQUklURV9WRVJURVhfQ09VTlQpO1xyXG4gICAgICAgIHZhciB1dnMgPSBmcmFtZS51dnM7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGZyYW1lLmhlaWdodDtcclxuICAgICAgICB2YXIgeCA9IHdpZHRoICogLWFuY2hvclg7XHJcbiAgICAgICAgdmFyIHkgPSBoZWlnaHQgKiAtYW5jaG9yWTtcclxuICAgICAgICBcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHRyYW5zbGF0ZVg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHRyYW5zbGF0ZVk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHNjYWxlWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gc2NhbGVZO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSByb3RhdGlvbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gdmVydGV4Q29sb3IudG9wTGVmdDtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0cmFuc2xhdGVYO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0cmFuc2xhdGVZO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBzY2FsZVg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHNjYWxlWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gcm90YXRpb247XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IHZlcnRleENvbG9yLmJvdHRvbUxlZnQ7XHJcbiAgICBcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geCArIHdpZHRoO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHJhbnNsYXRlWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHJhbnNsYXRlWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gc2NhbGVYO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBzY2FsZVk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHJvdGF0aW9uO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB2ZXJ0ZXhDb2xvci5ib3R0b21SaWdodDtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHggKyB3aWR0aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHRyYW5zbGF0ZVg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHRyYW5zbGF0ZVk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHNjYWxlWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gc2NhbGVZO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSByb3RhdGlvbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gdmVydGV4Q29sb3IudG9wUmlnaHQ7XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IENPTlNULlNQUklURV9JTkRFWF9DT1VOVDtcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG5cclxuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEpO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcclxuXHJcbiAgICAgICAgQmluZFZlcnRleEFycmF5KGdsLCB0aGlzLnZlcnRleEFycmF5KTtcclxuICAgIH0sXHJcblxyXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG5cclxuICAgICAgICBnbC51c2VQcm9ncmFtKG51bGwpO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmVydGV4RGF0YUJ1ZmZlci5nZXRVc2VkQnVmZmVyQXNGbG9hdCgpKTtcclxuXHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5lbGVtZW50Q291bnQsIGdsLlVOU0lHTkVEX0lOVCwgMCk7XHJcblxyXG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aGlzLmF1dG9SZXNpemUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUud2lkdGggPSAodGhpcy53aWR0aCAvIHJlcykgKyAncHgnO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0IC8gcmVzKSArICdweCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoXHJcbiAgICAgICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy52aWV3LndpZHRoLCAwLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgLTIgLyB0aGlzLnZpZXcuaGVpZ2h0LCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgaWYgKGdsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMudmVydFNoYWRlcik7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdTaGFkZXIpO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QXJyYXkuYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVCYXRjaDMyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9TcHJpdGVCYXRjaDMyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvU3ByaXRlQmF0Y2gzMi5qcyIsIm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICAgJ3VuaWZvcm0gbWF0NCB1X3ZpZXdfbWF0cml4OycsXHJcbiAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxyXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfdGV4X2Nvb3JkOycsXHJcbiAgICAnYXR0cmlidXRlIHZlYzIgYV90cmFuc2xhdGU7JyxcclxuICAgICdhdHRyaWJ1dGUgdmVjMiBhX3NjYWxlOycsXHJcbiAgICAnYXR0cmlidXRlIHZlYzMgYV9jb2xvcjsnLFxyXG4gICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3JvdGF0aW9uOycsXHJcbiAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXHJcbiAgICAndmFyeWluZyB2ZWMzIHZfY29sb3I7JyxcclxuICAgICd2b2lkIG1haW4gKCkgeycsXHJcbiAgICAnICAgZmxvYXQgdF9jb3MgPSBjb3MoYV9yb3RhdGlvbik7JyxcclxuICAgICcgICBmbG9hdCB0X3NpbiA9IHNpbihhX3JvdGF0aW9uKTsnLFxyXG4gICAgJyAgIHZlYzIgdF9wb3NpdGlvbiA9IChhX3Bvc2l0aW9uICk7JyxcclxuICAgICcgICB0X3Bvc2l0aW9uID0gdmVjMih0X3Bvc2l0aW9uLnggKiB0X2NvcyAtIHRfcG9zaXRpb24ueSAqIHRfc2luLCB0X3Bvc2l0aW9uLnggKiB0X3NpbiArIHRfcG9zaXRpb24ueSAqIHRfY29zKTsnLFxyXG4gICAgJyAgIGdsX1Bvc2l0aW9uID0gdV92aWV3X21hdHJpeCAqIHZlYzQoKHRfcG9zaXRpb24gKiBhX3NjYWxlKSArIGFfdHJhbnNsYXRlLCAxLjAsIDEuMCk7JyxcclxuICAgICcgICB2X3RleF9jb29yZCA9IGFfdGV4X2Nvb3JkOycsXHJcbiAgICAnICAgdl9jb2xvciA9IGFfY29sb3I7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9WZXJ0ZXhTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2NhbGVNb2RlcyA9IHJlcXVpcmUoJy4uLy4uL1NjYWxlTW9kZXMnKTtcclxuXHJcbnZhciBDcmVhdGVFbXB0eVRleHR1cmUgPSBmdW5jdGlvbiAoZ2wsIHdpZHRoLCBoZWlnaHQsIHNjYWxlTW9kZSwgdGV4dHVyZUluZGV4KVxyXG57XHJcbiAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgIHZhciBnbFNjYWxlTW9kZSA9IChzY2FsZU1vZGUgPT09IFNjYWxlTW9kZXMuTElORUFSKSA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XHJcblxyXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVJbmRleCk7XHJcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuXHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG5cclxuICAgIC8vICBXZSdsbCByZWFkIGZyb20gdGhpcyB0ZXh0dXJlLCBidXQgaXQgd29uJ3QgaGF2ZSBtaXBtYXBzLCBzbyB0dXJuIHRoZW0gb2ZmOlxyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsU2NhbGVNb2RlKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbFNjYWxlTW9kZSk7XHJcblxyXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlRW1wdHlUZXh0dXJlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy9DcmVhdGVFbXB0eVRleHR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDMxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC91dGlscy9DcmVhdGVFbXB0eVRleHR1cmUuanMiLCJ2YXIgU2NhbGVNb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL1NjYWxlTW9kZXMnKTtcclxudmFyIENyZWF0ZVRleHR1cmUyREltYWdlID0gcmVxdWlyZSgnLi9DcmVhdGVUZXh0dXJlMkRJbWFnZScpO1xyXG5cclxudmFyIENyZWF0ZVRleHR1cmUyREZyb21Tb3VyY2UgPSBmdW5jdGlvbiAoZ2wsIHNvdXJjZSlcclxue1xyXG4gICAgdmFyIGZpbHRlcjtcclxuXHJcbiAgICBpZiAoc291cmNlLnNjYWxlTW9kZSA9PT0gU2NhbGVNb2Rlcy5MSU5FQVIpXHJcbiAgICB7XHJcbiAgICAgICAgZmlsdGVyID0gZ2wuTElORUFSO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc291cmNlLnNjYWxlTW9kZSA9PT0gU2NhbGVNb2Rlcy5ORUFSRVNUKVxyXG4gICAge1xyXG4gICAgICAgIGZpbHRlciA9IGdsLk5FQVJFU1Q7XHJcbiAgICB9XHJcblxyXG4gICAgc291cmNlLmdsVGV4dHVyZSA9IENyZWF0ZVRleHR1cmUyREltYWdlKGdsLCBzb3VyY2UuaW1hZ2UsIGZpbHRlciwgc291cmNlLm1pcG1hcExldmVsKVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy90ZXh0dXJlL0NyZWF0ZVRleHR1cmUyREZyb21Tb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDMxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC91dGlscy90ZXh0dXJlL0NyZWF0ZVRleHR1cmUyREZyb21Tb3VyY2UuanMiLCJ2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldClcclxue1xyXG4gICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xyXG4gICAgdGhpcy5zdHJpZGUgPSBzdHJpZGU7XHJcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXR0cmlidXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQXR0cmlidXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBCZXR3ZWVuID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9CZXR3ZWVuJyk7XHJcbnZhciBHZXRPYmplY3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0dldE9iamVjdFZhbHVlJyk7XHJcblxyXG4vLyAgUGhhc2VyLlNvdW5kLkR5bmFtaWMuRlhcclxuXHJcbi8vICBCYXNlZCBvbiBTb3VuZC5qcyBieSBLaXR0eUthdEF0dGFja1xyXG4vLyAgaHR0cHM6Ly9naXRodWIuY29tL2tpdHR5a2F0YXR0YWNrL3NvdW5kLmpzXHJcblxyXG4vLyBmcmVxdWVuY3ksICAgICAgLy9UaGUgc291bmQncyBmZXF1ZW5jeSBwaXRjaCBpbiBIZXJ0elxyXG4vLyBhdHRhY2ssICAgICAgICAgICAgICAvL1RoZSB0aW1lLCBpbiBzZWNvbmRzLCB0byBmYWRlIHRoZSBzb3VuZCBpblxyXG4vLyBkZWNheSwgICAgICAgICAgICAgICAvL1RoZSB0aW1lLCBpbiBzZWNvbmRzLCB0byBmYWRlIHRoZSBzb3VuZCBvdXRcclxuLy8gdHlwZSwgICAgICAgICAgICAgICAgLy93YXZlZm9ybSB0eXBlOiBcInNpbmVcIiwgXCJ0cmlhbmdsZVwiLCBcInNxdWFyZVwiLCBcInNhd3Rvb3RoXCJcclxuLy8gdm9sdW1lLCAgICAgICAgIC8vVGhlIHNvdW5kJ3MgbWF4aW11bSB2b2x1bWVcclxuLy8gcGFuVmFsdWUsICAgICAgICAgICAgLy9UaGUgc3BlYWtlciBwYW4uIGxlZnQ6IC0xLCBtaWRkbGU6IDAsIHJpZ2h0OiAxXHJcbi8vIHdhaXQsICAgICAgICAgICAgICAgIC8vVGhlIHRpbWUsIGluIHNlY29uZHMsIHRvIHdhaXQgYmVmb3JlIHBsYXlpbmcgdGhlIHNvdW5kXHJcbi8vIHBpdGNoQmVuZCwgICAgIC8vVGhlIG51bWJlciBvZiBIeiBpbiB3aGljaCB0byBiZW5kIHRoZSBzb3VuZCdzIHBpdGNoIGRvd25cclxuLy8gcmV2ZXJzZSwgICAgICAgICAgICAgLy9JZiBgcmV2ZXJzZWAgaXMgdHJ1ZSB0aGUgcGl0Y2ggd2lsbCBiZW5kIHVwXHJcbi8vIHJhbmRvbSwgICAgICAgICAvL0EgcmFuZ2UsIGluIEh6LCB3aXRoaW4gd2hpY2ggdG8gcmFuZG9taXplIHRoZSBwaXRjaFxyXG4vLyBkaXNzb25hbmNlLCAgICAgICAgICAvL0EgdmFsdWUgaW4gSHouIEl0IGNyZWF0ZXMgMiBkaXNzb25hbnQgZnJlcXVlbmNpZXMgYWJvdmUgYW5kIGJlbG93IHRoZSB0YXJnZXQgcGl0Y2hcclxuLy8gZWNobywgICAgICAgICAgICAgICAgLy9BbiBhcnJheTogW2RlbGF5VGltZUluU2Vjb25kcywgZmVlZGJhY2tUaW1lSW5TZWNvbmRzLCBmaWx0ZXJWYWx1ZUluSHpdXHJcbi8vIHJldmVyYiwgICAgICAgICAgICAgIC8vQW4gYXJyYXk6IFtkdXJhdGlvbkluU2Vjb25kcywgZGVjYXlSYXRlSW5TZWNvbmRzLCByZXZlcnNlXVxyXG4vLyB0aW1lb3V0ICAgICAgICAgICAgICAvL0EgbnVtYmVyLCBpbiBzZWNvbmRzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBkdXJhdGlvbiBmb3Igc291bmQgZWZmZWN0c1xyXG5cclxudmFyIEZYID0gZnVuY3Rpb24gKGN0eCwgY29uZmlnKVxyXG57XHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGN0eDtcclxuXHJcbiAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZnJlcXVlbmN5JywgMjAwKTtcclxuICAgIHRoaXMuYXR0YWNrID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnYXR0YWNrJywgMCk7XHJcbiAgICB0aGlzLmRlY2F5ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZGVjYXknLCAxKTtcclxuICAgIHRoaXMudHlwZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3R5cGUnLCAnc2luZScpO1xyXG4gICAgdGhpcy52b2x1bWVWYWx1ZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3ZvbHVtZScsIDEpO1xyXG4gICAgdGhpcy5wYW5WYWx1ZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3BhbicsIDApO1xyXG4gICAgdGhpcy53YWl0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnd2FpdCcsIDApO1xyXG4gICAgdGhpcy5waXRjaEJlbmRBbW91bnQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdwaXRjaEJlbmQnLCAwKTtcclxuICAgIHRoaXMucmV2ZXJzZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyc2UnLCBmYWxzZSk7XHJcbiAgICB0aGlzLnJhbmRvbVZhbHVlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmFuZG9tJywgMCk7XHJcbiAgICB0aGlzLmRpc3NvbmFuY2UgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdkaXNzb25hbmNlJywgMCk7XHJcbiAgICB0aGlzLmVjaG8gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdlY2hvJywgZmFsc2UpO1xyXG4gICAgdGhpcy5lY2hvRGVsYXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdlY2hvLmRlbGF5JywgMCk7XHJcbiAgICB0aGlzLmVjaG9GZWVkYmFjayA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2VjaG8uZmVlZGJhY2snLCAwKTtcclxuICAgIHRoaXMuZWNob0ZpbHRlciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2VjaG8uZmlsdGVyJywgMCk7XHJcbiAgICB0aGlzLnJldmVyYiA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyYicsIGZhbHNlKTtcclxuICAgIHRoaXMucmV2ZXJiRHVyYXRpb24gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXZlcmIuZHVyYXRpb24nLCAwKTtcclxuICAgIHRoaXMucmV2ZXJiRGVjYXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXZlcmIuZGVjYXknLCAwKTtcclxuICAgIHRoaXMucmV2ZXJiUmV2ZXJzZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyYi5yZXZlcnNlJywgZmFsc2UpO1xyXG4gICAgdGhpcy50aW1lb3V0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndGltZW91dCcsIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLnZvbHVtZSA9IGN0eC5jcmVhdGVHYWluKCk7XHJcbiAgICB0aGlzLnBhbiA9ICghY3R4LmNyZWF0ZVN0ZXJlb1Bhbm5lcikgPyBjdHguY3JlYXRlUGFubmVyKCkgOiBjdHguY3JlYXRlU3RlcmVvUGFubmVyKCk7XHJcblxyXG4gICAgdGhpcy52b2x1bWUuY29ubmVjdCh0aGlzLnBhbik7XHJcbiAgICB0aGlzLnBhbi5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcblxyXG4gICAgLy8gIFNldCB0aGUgdmFsdWVzXHJcblxyXG4gICAgdGhpcy52b2x1bWUuZ2Fpbi52YWx1ZSA9IHRoaXMudm9sdW1lVmFsdWU7XHJcblxyXG4gICAgaWYgKCFjdHguY3JlYXRlU3RlcmVvUGFubmVyKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGFuLnNldFBvc2l0aW9uKHRoaXMucGFuVmFsdWUsIDAsIDEgLSBNYXRoLmFicyh0aGlzLnBhblZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYW4ucGFuLnZhbHVlID0gdGhpcy5wYW5WYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQ3JlYXRlIGFuIG9zY2lsbGF0b3IsIGdhaW4gYW5kIHBhbiBub2RlcywgYW5kIGNvbm5lY3QgdGhlbSB0b2dldGhlciB0byB0aGUgZGVzdGluYXRpb25cclxuXHJcbiAgICB2YXIgb3NjaWxsYXRvciA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcblxyXG4gICAgb3NjaWxsYXRvci5jb25uZWN0KHRoaXMudm9sdW1lKTtcclxuICAgIG9zY2lsbGF0b3IudHlwZSA9IHRoaXMudHlwZTtcclxuXHJcbiAgICAvLyAgT3B0aW9uYWxseSByYW5kb21pemUgdGhlIHBpdGNoIGlmIGByYW5kb21WYWx1ZWAgPiAwLlxyXG4gICAgLy8gIEEgcmFuZG9tIHBpdGNoIGlzIHNlbGVjdGVkIHRoYXQncyB3aXRoaW4gdGhlIHJhbmdlIHNwZWNpZmllZCBieSBgZnJlcXVlbmN5VmFsdWVgLlxyXG4gICAgLy8gIFRoZSByYW5kb20gcGl0Y2ggd2lsbCBiZSBlaXRoZXIgYWJvdmUgb3IgYmVsb3cgdGhlIHRhcmdldCBmcmVxdWVuY3kuXHJcblxyXG4gICAgaWYgKHRoaXMucmFuZG9tVmFsdWUgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gQmV0d2VlbihcclxuICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3lWYWx1ZSAtIHRoaXMucmFuZG9tVmFsdWUgLyAyLFxyXG4gICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlICsgdGhpcy5yYW5kb21WYWx1ZSAvIDJcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5mcmVxdWVuY3lWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQXBwbHkgZWZmZWN0c1xyXG5cclxuICAgIGlmICh0aGlzLmF0dGFjayA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mYWRlSW4odGhpcy52b2x1bWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZmFkZU91dCh0aGlzLnZvbHVtZSk7XHJcblxyXG4gICAgaWYgKHRoaXMucGl0Y2hCZW5kQW1vdW50ID4gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBpdGNoQmVuZChvc2NpbGxhdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5lY2hvKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWRkRWNobyh0aGlzLnZvbHVtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucmV2ZXJiKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWRkUmV2ZXJiKHRoaXMudm9sdW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kaXNzb25hbmNlID4gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFkZERpc3NvbmFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBsYXkob3NjaWxsYXRvcik7XHJcblxyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICBvc2NpbGxhdG9yLm9uZW5kZWQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdvbmVuZGVkJyk7XHJcbiAgICAgICAgX3RoaXMucGFuLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICBfdGhpcy52b2x1bWUuZGlzY29ubmVjdCgpO1xyXG4gICAgfTtcclxufTtcclxuXHJcbkZYLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZYO1xyXG5cclxuRlgucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHBsYXk6IGZ1bmN0aW9uIChvc2NpbGxhdG9yKVxyXG4gICAge1xyXG4gICAgICAgIG9zY2lsbGF0b3Iuc3RhcnQodGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQpO1xyXG5cclxuICAgICAgICAvL09zY2lsbGF0b3JzIGhhdmUgdG8gYmUgc3RvcHBlZCBvdGhlcndpc2UgdGhleSBhY2N1bXVsYXRlIGluIFxyXG4gICAgICAgIC8vbWVtb3J5IGFuZCB0YXggdGhlIENQVS4gVGhleSdsbCBiZSBzdG9wcGVkIGFmdGVyIGEgZGVmYXVsdFxyXG4gICAgICAgIC8vdGltZW91dCBvZiAyIHNlY29uZHMsIHdoaWNoIHNob3VsZCBiZSBlbm91Z2ggZm9yIG1vc3Qgc291bmQgXHJcbiAgICAgICAgLy9lZmZlY3RzLiBPdmVycmlkZSB0aGlzIGluIHRoZSBgc291bmRFZmZlY3RgIHBhcmFtZXRlcnMgaWYgeW91XHJcbiAgICAgICAgLy9uZWVkIGEgbG9uZ2VyIHNvdW5kXHJcblxyXG4gICAgICAgIG9zY2lsbGF0b3Iuc3RvcCh0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIDIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmYWRlSW46IGZ1bmN0aW9uICh2b2x1bWUpXHJcbiAgICB7XHJcbiAgICAgICAgdm9sdW1lLmdhaW4udmFsdWUgPSAwO1xyXG5cclxuICAgICAgICB2b2x1bWUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCk7XHJcblxyXG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMudm9sdW1lVmFsdWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2spO1xyXG4gICAgfSxcclxuXHJcbiAgICBmYWRlT3V0OiBmdW5jdGlvbiAodm9sdW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMudm9sdW1lVmFsdWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2spO1xyXG5cclxuICAgICAgICB2b2x1bWUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrICsgdGhpcy5kZWNheSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFJldmVyYjogZnVuY3Rpb24gKHZvbHVtZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgY29udm9sdmVyID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQ29udm9sdmVyKCk7XHJcblxyXG4gICAgICAgIGNvbnZvbHZlci5idWZmZXIgPSB0aGlzLmltcHVsc2VSZXNwb25zZSh0aGlzLnJldmVyYkR1cmF0aW9uLCB0aGlzLnJldmVyYkRlY2F5LCB0aGlzLnJldmVyYlJldmVyc2UsIHRoaXMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICAgICAgdm9sdW1lLmNvbm5lY3QoY29udm9sdmVyKTtcclxuXHJcbiAgICAgICAgY29udm9sdmVyLmNvbm5lY3QodGhpcy5wYW4pO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRFY2hvOiBmdW5jdGlvbiAodm9sdW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmZWVkYmFjayA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVEZWxheSgpO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcclxuXHJcbiAgICAgICAgLy8gIFNldCB0aGUgbm9kZSB2YWx1ZXNcclxuXHJcbiAgICAgICAgZmVlZGJhY2suZ2Fpbi52YWx1ZSA9IHRoaXMuZWNob0ZlZWRiYWNrO1xyXG4gICAgICAgIGRlbGF5LmRlbGF5VGltZS52YWx1ZSA9IHRoaXMuZWNob0RlbGF5O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lY2hvRmlsdGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmlsdGVyLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuZWNob0ZpbHRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBDcmVhdGUgdGhlIGRlbGF5IGZlZWRiYWNrIGxvb3AgKHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nKVxyXG5cclxuICAgICAgICBkZWxheS5jb25uZWN0KGZlZWRiYWNrKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWNob0ZpbHRlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZlZWRiYWNrLmNvbm5lY3QoZmlsdGVyKTtcclxuICAgICAgICAgICAgZmlsdGVyLmNvbm5lY3QoZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmZWVkYmFjay5jb25uZWN0KGRlbGF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBDb25uZWN0IHRoZSBkZWxheSBub2RlIHRvIHRoZSBvc2NpbGxhdG9yIHZvbHVtZSBub2RlXHJcblxyXG4gICAgICAgIHZvbHVtZS5jb25uZWN0KGRlbGF5KTtcclxuXHJcbiAgICAgICAgLy8gIENvbm5lY3QgdGhlIGRlbGF5IG5vZGUgdG8gdGhlIG1haW4gc291bmQgY2hhaW5zIHBhbiBub2RlLFxyXG4gICAgICAgIC8vICBzbyB0aGF0IHRoZSBlY2hvIGVmZmVjdCBpcyBkaXJlY3RlZCB0byB0aGUgY29ycmVjdCBzcGVha2VyXHJcblxyXG4gICAgICAgIGRlbGF5LmNvbm5lY3QodGhpcy5wYW4pO1xyXG4gICAgfSxcclxuXHJcbiAgICBwaXRjaEJlbmQ6IGZ1bmN0aW9uIChvc2NpbGxhdG9yKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmcmVxdWVuY3kgPSBvc2NpbGxhdG9yLmZyZXF1ZW5jeS52YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnJldmVyc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSWYgcmV2ZXJzZSBpcyBmYWxzZSwgbWFrZSB0aGUgc291bmQgZHJvcCBpbiBwaXRjaFxyXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3ksIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0KTtcclxuICAgICAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZnJlcXVlbmN5IC0gdGhpcy5waXRjaEJlbmRBbW91bnQsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2sgKyB0aGlzLmRlY2F5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIElmIHJldmVyc2UgaXMgdHJ1ZSwgbWFrZSB0aGUgc291bmQgcmlzZSBpbiBwaXRjaFxyXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3ksIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0KTtcclxuICAgICAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZnJlcXVlbmN5ICsgdGhpcy5waXRjaEJlbmRBbW91bnQsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2sgKyB0aGlzLmRlY2F5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGREaXNzb25hbmNlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBDcmVhdGUgdHdvIG1vcmUgb3NjaWxsYXRvcnMgYW5kIGdhaW4gbm9kZXNcclxuXHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG5cclxuICAgICAgICB2YXIgZDEgPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xyXG4gICAgICAgIHZhciBkMiA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcbiAgICAgICAgdmFyIGQxVm9sdW1lID0gY3R4LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB2YXIgZDJWb2x1bWUgPSBjdHguY3JlYXRlR2FpbigpO1xyXG5cclxuICAgICAgICAvLyAgU2V0IHRoZSB2b2x1bWUgdG8gdGhlIGB2b2x1bWVWYWx1ZWBcclxuICAgICAgICBkMVZvbHVtZS5nYWluLnZhbHVlID0gdGhpcy52b2x1bWVWYWx1ZTtcclxuICAgICAgICBkMlZvbHVtZS5nYWluLnZhbHVlID0gdGhpcy52b2x1bWVWYWx1ZTtcclxuXHJcbiAgICAgICAgLy8gIENvbm5lY3QgdGhlIG9zY2lsbGF0b3JzIHRvIHRoZSBnYWluIGFuZCBkZXN0aW5hdGlvbiBub2Rlc1xyXG4gICAgICAgIGQxLmNvbm5lY3QoZDFWb2x1bWUpO1xyXG4gICAgICAgIGQyLmNvbm5lY3QoZDJWb2x1bWUpO1xyXG5cclxuICAgICAgICBkMVZvbHVtZS5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgZDJWb2x1bWUuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xyXG5cclxuICAgICAgICAvLyAgU2V0IHRoZSB3YXZlZm9ybSB0byBcInNhd3Rvb3RoXCIgZm9yIGEgaGFyc2ggZWZmZWN0XHJcbiAgICAgICAgZDEudHlwZSA9ICdzYXd0b290aCc7XHJcbiAgICAgICAgZDIudHlwZSA9ICdzYXd0b290aCc7XHJcblxyXG4gICAgICAgIC8vICBNYWtlIHRoZSB0d28gb3NjaWxsYXRvcnMgcGxheSBhdCBmcmVxdWVuY2llcyBhYm92ZSBhbmQgYmVsb3cgdGhlIG1haW4gc291bmQncyBmcmVxdWVuY3kuXHJcbiAgICAgICAgLy8gIFVzZSB3aGF0ZXZlciB2YWx1ZSB3YXMgc3VwcGxpZWQgYnkgdGhlIGBkaXNzb25hbmNlYCBhcmd1bWVudFxyXG4gICAgICAgIGQxLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuZnJlcXVlbmN5VmFsdWUgKyB0aGlzLmRpc3NvbmFuY2U7XHJcbiAgICAgICAgZDIuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5mcmVxdWVuY3lWYWx1ZSAtIHRoaXMuZGlzc29uYW5jZTtcclxuXHJcbiAgICAgICAgLy8gIEZhZGUgaW4gLyBvdXQsIHBpdGNoIGJlbmQgYW5kIHBsYXkgdGhlIG9zY2lsbGF0b3JzIHRvIG1hdGNoIHRoZSBtYWluIHNvdW5kXHJcbiAgICAgICAgaWYgKHRoaXMuYXR0YWNrID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmFkZUluKGQxVm9sdW1lKTtcclxuICAgICAgICAgICAgdGhpcy5mYWRlSW4oZDJWb2x1bWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGVjYXkgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5mYWRlT3V0KGQxVm9sdW1lKTtcclxuICAgICAgICAgICAgdGhpcy5mYWRlT3V0KGQyVm9sdW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBpdGNoQmVuZEFtb3VudCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBpdGNoQmVuZChkMSk7XHJcbiAgICAgICAgICAgIHRoaXMucGl0Y2hCZW5kKGQyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVjaG8pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVjaG8oZDFWb2x1bWUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVjaG8oZDJWb2x1bWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucmV2ZXJiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRSZXZlcmIoZDFWb2x1bWUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFJldmVyYihkMlZvbHVtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBsYXkoZDEpO1xyXG4gICAgICAgIHRoaXMucGxheShkMik7XHJcbiAgICB9LFxyXG5cclxuICAgIGltcHVsc2VSZXNwb25zZTogZnVuY3Rpb24gKGR1cmF0aW9uLCBkZWNheSwgcmV2ZXJzZSlcclxuICAgIHtcclxuICAgICAgICAvLyAgVGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlICogZHVyYXRpb247XHJcblxyXG4gICAgICAgIC8vICBDcmVhdGUgYW4gYXVkaW8gYnVmZmVyIChhbiBlbXB0eSBzb3VuZCBjb250YWluZXIpIHRvIHN0b3JlIHRoZSByZXZlcmIgZWZmZWN0LlxyXG4gICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDIsIGxlbmd0aCwgdGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XHJcblxyXG4gICAgICAgIC8vICBVc2UgYGdldENoYW5uZWxEYXRhYCB0byBpbml0aWFsaXplIGVtcHR5IGFycmF5cyB0byBzdG9yZSBzb3VuZCBkYXRhIGZvciB0aGUgbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHMuXHJcbiAgICAgICAgdmFyIGxlZnQgPSBpbXB1bHNlLmdldENoYW5uZWxEYXRhKDApO1xyXG4gICAgICAgIHZhciByaWdodCA9IGltcHVsc2UuZ2V0Q2hhbm5lbERhdGEoMSk7XHJcblxyXG4gICAgICAgIC8vICBMb29wIHRocm91Z2ggZWFjaCBzYW1wbGUtZnJhbWUgYW5kIGZpbGwgdGhlIGNoYW5uZWwgZGF0YSB3aXRoIHJhbmRvbSBub2lzZS5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEFwcGx5IHRoZSByZXZlcnNlIGVmZmVjdCwgaWYgYHJldmVyc2VgIGlzIGB0cnVlYC5cclxuICAgICAgICAgICAgdmFyIG4gPSAocmV2ZXJzZSkgPyBsZW5ndGggLSBpIDogaTtcclxuXHJcbiAgICAgICAgICAgIC8vICBGaWxsIHRoZSBsZWZ0IGFuZCByaWdodCBjaGFubmVscyB3aXRoIHJhbmRvbSB3aGl0ZSBub2lzZSB3aGljaCBkZWNheXMgZXhwb25lbnRpYWxseS5cclxuICAgICAgICAgICAgbGVmdFtpXSA9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogTWF0aC5wb3coMSAtIG4gLyBsZW5ndGgsIGRlY2F5KTtcclxuICAgICAgICAgICAgcmlnaHRbaV0gPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIE1hdGgucG93KDEgLSBuIC8gbGVuZ3RoLCBkZWNheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgUmV0dXJuIHRoZSBgaW1wdWxzZWAuXHJcbiAgICAgICAgcmV0dXJuIGltcHVsc2U7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGWDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc291bmQvZHluYW1pYy9GWC5qc1xuLy8gbW9kdWxlIGlkID0gMzIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NvdW5kL2R5bmFtaWMvRlguanMiLCIvLyAgUGhhc2VyLlNvdW5kLkR5bmFtaWNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEZYOiByZXF1aXJlKCcuL0ZYJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NvdW5kL2R5bmFtaWMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zb3VuZC9keW5hbWljL2luZGV4LmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIFNldHRpbmdzID0gcmVxdWlyZSgnLi9TZXR0aW5ncycpO1xyXG52YXIgU3lzdGVtcyA9IHJlcXVpcmUoJy4vU3lzdGVtcycpO1xyXG5cclxuLyoqXHJcbiogQSBCYXNlIFN0YXRlIENsYXNzLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5TdGF0ZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qL1xyXG52YXIgU3RhdGUgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICAvLyAgVGhlIHByb3BlcnRpZXMgYSBTdGF0ZSAqbXVzdCogaGF2ZSwgdGhhdCBjYW5ub3QgYmUgY2hhbmdlZCB3aXRob3V0IGJyZWFraW5nIGl0OlxyXG5cclxuICAgIHRoaXMuZ2FtZSA9IG51bGw7XHJcblxyXG4gICAgLy8gIE1heWJlIGp1c3QgYW4gb2JqZWN0PyBEb2Vzbid0IGhhdmUgdG8gaW5zdGFudGlhdGUgSSBkb24ndCB0aGluayAuLi5cclxuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3ModGhpcywgY29uZmlnKTtcclxuXHJcbiAgICB0aGlzLnN5cyA9IG5ldyBTeXN0ZW1zKHRoaXMsIGNvbmZpZyk7XHJcblxyXG4gICAgLy8gIFJlZmVyZW5jZSB0byBzeXMuY2hpbGRyZW4sIHNldCBkdXJpbmcgc3lzLmluaXQgb25seVxyXG4gICAgdGhpcy5jaGlsZHJlbjtcclxufTtcclxuXHJcblN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YXRlO1xyXG5cclxuU3RhdGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8vICBDYW4gYmUgb3ZlcnJpZGRlbiBieSB5b3VyIG93biBTdGF0ZXNcclxuICAgIHByZVVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbiBiZSBvdmVycmlkZGVuIGJ5IHlvdXIgb3duIFN0YXRlc1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FuIGJlIG92ZXJyaWRkZW4gYnkgeW91ciBvd24gU3RhdGVzXHJcbiAgICBwb3N0VXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FuIGJlIG92ZXJyaWRkZW4gYnkgeW91ciBvd24gU3RhdGVzXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvU3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9TdGF0ZS5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBOT09QID0gcmVxdWlyZSgnLi4vdXRpbHMvTk9PUCcpO1xyXG52YXIgU3RhdGUgPSByZXF1aXJlKCcuL1N0YXRlJyk7XHJcbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoJy4vU2V0dGluZ3MnKTtcclxudmFyIFN5c3RlbXMgPSByZXF1aXJlKCcuL1N5c3RlbXMnKTtcclxudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvR2V0T2JqZWN0VmFsdWUnKTtcclxuLy8gdmFyIExvYWRlckV2ZW50ID0gcmVxdWlyZSgnLi4vbG9hZGVyL2V2ZW50cy8nKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBTdGF0ZSBNYW5hZ2VyIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nLCBzZXR0aW5nIHVwIGFuZCBzd2l0Y2hpbmcgZ2FtZSBzdGF0ZXMuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlN0YXRlTWFuYWdlclxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cclxuKi9cclxudmFyIFN0YXRlTWFuYWdlciA9IGZ1bmN0aW9uIChnYW1lLCBzdGF0ZUNvbmZpZylcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICAvLyAgRXZlcnl0aGluZyBrZXB0IGluIGhlcmVcclxuICAgIHRoaXMua2V5cyA9IHt9O1xyXG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcclxuXHJcbiAgICAvLyAgT25seSBhY3RpdmUgc3RhdGVzIGFyZSBrZXB0IGluIGhlcmVcclxuICAgIHRoaXMuYWN0aXZlID0gW107XHJcblxyXG4gICAgdGhpcy5fcGVuZGluZyA9IFtdO1xyXG5cclxuICAgIGlmIChzdGF0ZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZUNvbmZpZykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlQ29uZmlnLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgVGhlIGkgPT09IDAgcGFydCBqdXN0IHN0YXJ0cyB0aGUgZmlyc3QgU3RhdGUgZ2l2ZW5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnZGVmYXVsdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlQ29uZmlnW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9TdGFydDogKGkgPT09IDApXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IDAsXHJcbiAgICAgICAgICAgICAgICBrZXk6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZUNvbmZpZyxcclxuICAgICAgICAgICAgICAgIGF1dG9TdGFydDogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TdGF0ZU1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhdGVNYW5hZ2VyO1xyXG5cclxuU3RhdGVNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIEJvb3QgaGFuZGxlciBpcyBjYWxsZWQgYnkgUGhhc2VyLkdhbWUgd2hlbiBpdCBmaXJzdCBzdGFydHMgdXAuXHJcbiAgICAqIFRoZSByZW5kZXJlciBpcyBhdmFpbGFibGUgYnkgbm93LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5TdGF0ZU1hbmFnZXIjYm9vdFxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIGJvb3Q6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gdGhpcy5nYW1lLm9uUGF1c2UuYWRkKHRoaXMucGF1c2UsIHRoaXMpO1xyXG4gICAgICAgIC8vIHRoaXMuZ2FtZS5vblJlc3VtZS5hZGQodGhpcy5yZXN1bWUsIHRoaXMpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BlbmRpbmcubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9wZW5kaW5nW2ldO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGQoZW50cnkua2V5LCBlbnRyeS5zdGF0ZSwgZW50cnkuYXV0b1N0YXJ0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBDbGVhciB0aGUgcGVuZGluZyBsaXN0XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZyA9IFtdO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRLZXk6IGZ1bmN0aW9uIChrZXksIHN0YXRlQ29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIGlmICgha2V5KSB7IGtleSA9ICdkZWZhdWx0JzsgfVxyXG5cclxuICAgICAgICBpZiAoc3RhdGVDb25maWcgaW5zdGFuY2VvZiBTdGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleSA9IHN0YXRlQ29uZmlnLnNldHRpbmdzLmtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXRlQ29uZmlnID09PSAnb2JqZWN0JyAmJiBzdGF0ZUNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXkgPSBzdGF0ZUNvbmZpZy5rZXk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQnkgdGhpcyBwb2ludCBpdCdzIGVpdGhlciAnZGVmYXVsdCcgb3IgZXh0cmFjdGVkIGZyb20gdGhlIFN0YXRlXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmtleXMuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBhIFN0YXRlIHdpdGggZHVwbGljYXRlIGtleTogJyArIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQWRkcyBhIG5ldyBTdGF0ZSBpbnRvIHRoZSBTdGF0ZU1hbmFnZXIuIFlvdSBtdXN0IGdpdmUgZWFjaCBTdGF0ZSBhIHVuaXF1ZSBrZXkgYnkgd2hpY2ggeW91J2xsIGlkZW50aWZ5IGl0LlxyXG4gICAgKiBUaGUgU3RhdGUgY2FuIGJlIGVpdGhlciBhIFBoYXNlci5TdGF0ZSBvYmplY3QgKG9yIGFuIG9iamVjdCB0aGF0IGV4dGVuZHMgaXQpLCBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IG9yIGEgZnVuY3Rpb24uXHJcbiAgICAqIElmIGEgZnVuY3Rpb24gaXMgZ2l2ZW4gYSBuZXcgc3RhdGUgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZCBieSBjYWxsaW5nIGl0LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5TdGF0ZU1hbmFnZXIjYWRkXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBBIHVuaXF1ZSBrZXkgeW91IHVzZSB0byByZWZlcmVuY2UgdGhpcyBzdGF0ZSwgaS5lLiBcIk1haW5NZW51XCIsIFwiTGV2ZWwxXCIuXHJcbiAgICAqIEBwYXJhbSB7UGhhc2VyLlN0YXRlfG9iamVjdHxmdW5jdGlvbn0gc3RhdGUgIC0gVGhlIHN0YXRlIHlvdSB3YW50IHRvIHN3aXRjaCB0by5cclxuICAgICogQHBhcmFtIHtib29sZWFufSBbYXV0b1N0YXJ0PWZhbHNlXSAgLSBJZiB0cnVlIHRoZSBTdGF0ZSB3aWxsIGJlIHN0YXJ0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYWRkaW5nIGl0LlxyXG4gICAgKi9cclxuICAgIGFkZDogZnVuY3Rpb24gKGtleSwgc3RhdGVDb25maWcsIGF1dG9TdGFydClcclxuICAgIHtcclxuICAgICAgICBpZiAoYXV0b1N0YXJ0ID09PSB1bmRlZmluZWQpIHsgYXV0b1N0YXJ0ID0gZmFsc2U7IH1cclxuXHJcbiAgICAgICAgLy8gIGlmIG5vdCBib290ZWQsIHRoZW4gcHV0IHN0YXRlIGludG8gYSBob2xkaW5nIHBhdHRlcm5cclxuICAgICAgICBpZiAoIXRoaXMuZ2FtZS5pc0Jvb3RlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5fcGVuZGluZy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZUNvbmZpZyxcclxuICAgICAgICAgICAgICAgIGF1dG9TdGFydDogYXV0b1N0YXJ0XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1N0YXRlTWFuYWdlciBub3QgeWV0IGJvb3RlZCwgYWRkaW5nIHRvIGxpc3QnLCB0aGlzLl9wZW5kaW5nLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrZXkgPSB0aGlzLmdldEtleShrZXksIHN0YXRlQ29uZmlnKTtcclxuXHJcbiAgICAgICAgdmFyIG5ld1N0YXRlO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGVDb25maWcgaW5zdGFuY2VvZiBTdGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTdGF0ZU1hbmFnZXIuYWRkIGZyb20gaW5zdGFuY2UnLCBrZXkpO1xyXG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXMuY3JlYXRlU3RhdGVGcm9tSW5zdGFuY2Uoa2V5LCBzdGF0ZUNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGF0ZUNvbmZpZyA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU3RhdGVNYW5hZ2VyLmFkZCBmcm9tIG9iamVjdCcsIGtleSk7XHJcblxyXG4gICAgICAgICAgICBzdGF0ZUNvbmZpZy5rZXkgPSBrZXk7XHJcblxyXG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXMuY3JlYXRlU3RhdGVGcm9tT2JqZWN0KGtleSwgc3RhdGVDb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhdGVDb25maWcgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU3RhdGVNYW5hZ2VyLmFkZCBmcm9tIGZ1bmN0aW9uJywga2V5KTtcclxuXHJcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5jcmVhdGVTdGF0ZUZyb21GdW5jdGlvbihrZXksIHN0YXRlQ29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMua2V5c1trZXldID0gbmV3U3RhdGU7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2gobmV3U3RhdGUpO1xyXG5cclxuICAgICAgICBpZiAoYXV0b1N0YXJ0IHx8IG5ld1N0YXRlLnNldHRpbmdzLmFjdGl2ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdhbWUuaXNCb290ZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0LnB1c2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVTdGF0ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGtleSwgbmV3U3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgbmV3U3RhdGUuZ2FtZSA9IHRoaXMuZ2FtZTtcclxuXHJcbiAgICAgICAgbmV3U3RhdGUuc2V0dGluZ3Mua2V5ID0ga2V5O1xyXG5cclxuICAgICAgICBuZXdTdGF0ZS5zeXMuaW5pdCgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5nYW1lLmNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5XRUJHTClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3RhdGVGcmFtZUJ1ZmZlcihuZXdTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVN0YXRlRnJvbU9iamVjdDogZnVuY3Rpb24gKGtleSwgc3RhdGVDb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gbmV3IFN0YXRlKHN0YXRlQ29uZmlnKTtcclxuXHJcbiAgICAgICAgbmV3U3RhdGUuZ2FtZSA9IHRoaXMuZ2FtZTtcclxuXHJcbiAgICAgICAgbmV3U3RhdGUuc3lzLmluaXQoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZ2FtZS5jb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuV0VCR0wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVN0YXRlRnJhbWVCdWZmZXIobmV3U3RhdGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXBDYWxsYmFja3MobmV3U3RhdGUsIHN0YXRlQ29uZmlnKTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlU3RhdGVGcm9tRnVuY3Rpb246IGZ1bmN0aW9uIChrZXksIHN0YXRlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IG5ldyBzdGF0ZSgpO1xyXG5cclxuICAgICAgICBpZiAobmV3U3RhdGUgaW5zdGFuY2VvZiBTdGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0YXRlRnJvbUluc3RhbmNlKGtleSwgbmV3U3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuZXdTdGF0ZS5nYW1lID0gdGhpcy5nYW1lO1xyXG5cclxuICAgICAgICAgICAgbmV3U3RhdGUuc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MobmV3U3RhdGUsIGtleSk7XHJcbiAgICAgICAgICAgIG5ld1N0YXRlLnN5cyA9IG5ldyBTeXN0ZW1zKG5ld1N0YXRlKTtcclxuXHJcbiAgICAgICAgICAgIG5ld1N0YXRlLnN5cy5pbml0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5nYW1lLmNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5XRUJHTClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTdGF0ZUZyYW1lQnVmZmVyKG5ld1N0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIERlZmF1bHQgcmVxdWlyZWQgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHVwQ2FsbGJhY2tzKG5ld1N0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldHVwQ2FsbGJhY2tzOiBmdW5jdGlvbiAobmV3U3RhdGUsIHN0YXRlQ29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChzdGF0ZUNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7IHN0YXRlQ29uZmlnID0gbmV3U3RhdGU7IH1cclxuXHJcbiAgICAgICAgLy8gIEV4dHJhY3QgY2FsbGJhY2tzIG9yIHNldCBOT09QXHJcblxyXG4gICAgICAgIG5ld1N0YXRlLmluaXQgPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ2luaXQnLCBOT09QKTtcclxuICAgICAgICBuZXdTdGF0ZS5wcmVsb2FkID0gR2V0T2JqZWN0VmFsdWUoc3RhdGVDb25maWcsICdwcmVsb2FkJywgTk9PUCk7XHJcbiAgICAgICAgbmV3U3RhdGUuY3JlYXRlID0gR2V0T2JqZWN0VmFsdWUoc3RhdGVDb25maWcsICdjcmVhdGUnLCBOT09QKTtcclxuICAgICAgICBuZXdTdGF0ZS5zaHV0ZG93biA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAnc2h1dGRvd24nLCBOT09QKTtcclxuXHJcbiAgICAgICAgbmV3U3RhdGUucHJlVXBkYXRlID0gR2V0T2JqZWN0VmFsdWUoc3RhdGVDb25maWcsICdwcmVVcGRhdGUnLCBOT09QKTtcclxuICAgICAgICBuZXdTdGF0ZS51cGRhdGUgPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ3VwZGF0ZScsIE5PT1ApO1xyXG4gICAgICAgIG5ld1N0YXRlLnBvc3RVcGRhdGUgPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ3Bvc3RVcGRhdGUnLCBOT09QKTtcclxuICAgICAgICBuZXdTdGF0ZS5yZW5kZXIgPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ3JlbmRlcicsIE5PT1ApO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVN0YXRlRnJhbWVCdWZmZXI6IGZ1bmN0aW9uIChuZXdTdGF0ZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IG5ld1N0YXRlLnNldHRpbmdzLng7XHJcbiAgICAgICAgdmFyIHkgPSBuZXdTdGF0ZS5zZXR0aW5ncy55O1xyXG5cclxuICAgICAgICBpZiAobmV3U3RhdGUuc2V0dGluZ3Mud2lkdGggPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3U3RhdGUuc2V0dGluZ3Mud2lkdGggPSB0aGlzLmdhbWUuY29uZmlnLndpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5ld1N0YXRlLnNldHRpbmdzLmhlaWdodCA9PT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuZXdTdGF0ZS5zZXR0aW5ncy5oZWlnaHQgPSB0aGlzLmdhbWUuY29uZmlnLmhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB3aWR0aCA9IG5ld1N0YXRlLnNldHRpbmdzLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBuZXdTdGF0ZS5zZXR0aW5ncy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIG5ld1N0YXRlLnN5cy5mYm8gPSB0aGlzLmdhbWUucmVuZGVyZXIuY3JlYXRlRkJPKG5ld1N0YXRlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c1trZXldO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTdGF0ZUluZGV4OiBmdW5jdGlvbiAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzLmluZGV4T2Yoc3RhdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBY3RpdmVTdGF0ZUluZGV4OiBmdW5jdGlvbiAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5zdGF0ZSA9PT0gc3RhdGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVtpXS5pbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGtleSk7XHJcblxyXG4gICAgICAgIHJldHVybiAoc3RhdGUgJiYgc3RhdGUuc2V0dGluZ3MuYWN0aXZlICYmIHRoaXMuYWN0aXZlLmluZGV4T2Yoc3RhdGUpICE9PSAtMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBpZiBub3QgYm9vdGVkLCB0aGVuIHB1dCBzdGF0ZSBpbnRvIGEgaG9sZGluZyBwYXR0ZXJuXHJcbiAgICAgICAgaWYgKCF0aGlzLmdhbWUuaXNCb290ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU3RhdGVNYW5hZ2VyIG5vdCB5ZXQgYm9vdGVkLCBzZXR0aW5nIGF1dG9TdGFydCBvbiBwZW5kaW5nIGxpc3QnKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGVuZGluZy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fcGVuZGluZ1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkua2V5ID09PSBrZXkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuYXV0b1N0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZShrZXkpO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQWxyZWFkeSBzdGFydGVkPyBOb3RoaW5nIG1vcmUgdG8gZG8gaGVyZSAuLi5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoa2V5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5zZXR0aW5ncy5hY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gICsgYXJndW1lbnRzXHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pbml0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5pbml0LmNhbGwoc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RhdGUucHJlbG9hZCAmJiBzdGF0ZS5zeXMubG9hZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuc3lzLmxvYWQucmVzZXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcmVsb2FkLmNhbGwoc3RhdGUsIHRoaXMuZ2FtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIElzIHRoZSBsb2FkZXIgZW1wdHk/XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3lzLmxvYWQubGlzdC5zaXplID09PSAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDcmVhdGUoc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICBTdGFydCB0aGUgbG9hZGVyIGdvaW5nIGFzIHdlIGhhdmUgc29tZXRoaW5nIGluIHRoZSBxdWV1ZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zeXMubG9hZC5ldmVudHMub25jZSgnTE9BREVSX0NPTVBMRVRFX0VWRU5UJywgdGhpcy5sb2FkQ29tcGxldGUuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5sb2FkLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgTm8gcHJlbG9hZD8gVGhlbiB0aGVyZSB3YXMgbm90aGluZyB0byBsb2FkIGVpdGhlclxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydENyZWF0ZShzdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkQ29tcGxldGU6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBldmVudC5sb2FkZXIuc3RhdGU7XHJcblxyXG4gICAgICAgIC8vICBNYWtlIHN1cmUgdG8gZG8gbG9hZC11cGRhdGUgb25lIGxhc3QgdGltZSBiZWZvcmUgc3RhdGUgaXMgc2V0IHRvIF9jcmVhdGVkXHJcblxyXG4gICAgICAgIC8vICBTdG9wIGRvaW5nIHRoaXMgLi4uXHJcbiAgICAgICAgaWYgKHN0YXRlLmhhc093blByb3BlcnR5KCdsb2FkVXBkYXRlJykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdGF0ZS5sb2FkVXBkYXRlLmNhbGwoc3RhdGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGFydENyZWF0ZShzdGF0ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0Q3JlYXRlOiBmdW5jdGlvbiAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHN0YXRlLmNyZWF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0YXRlLmNyZWF0ZS5jYWxsKHN0YXRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBJbnNlcnQgYXQgdGhlIGNvcnJlY3QgaW5kZXgsIG9yIGl0IGp1c3QgYWxsIGdvZXMgd3JvbmcgOilcclxuXHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmdldFN0YXRlSW5kZXgoc3RhdGUpO1xyXG5cclxuICAgICAgICB0aGlzLmFjdGl2ZS5wdXNoKHsgaW5kZXg6IGksIHN0YXRlOiBzdGF0ZSB9KTtcclxuXHJcbiAgICAgICAgLy8gIFNvcnQgdGhlICdhY3RpdmUnIGFycmF5IGJhc2VkIG9uIHRoZSBpbmRleCBwcm9wZXJ0eVxyXG4gICAgICAgIHRoaXMuYWN0aXZlLnNvcnQodGhpcy5zb3J0U3RhdGVzLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICBzdGF0ZS5zeXMudXBkYXRlcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgc3RhdGUuc3lzLm1haW5sb29wLnN0YXJ0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhdXNlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0QWN0aXZlU3RhdGVJbmRleChrZXkpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPiAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoa2V5KTtcclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnNldHRpbmdzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNvcnQodGhpcy5zb3J0U3RhdGVzLmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc29ydFN0YXRlczogZnVuY3Rpb24gKHN0YXRlQSwgc3RhdGVCKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBTb3J0IGRlc2NlbmRpbmdcclxuICAgICAgICBpZiAoc3RhdGVBLmluZGV4IDwgc3RhdGVCLmluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdGF0ZUEuaW5kZXggPiBzdGF0ZUIuaW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU2VlIGlmIHdlIGNhbiByZWR1Y2UgdGhpcyBkb3duIHRvIGp1c3QgdXBkYXRlIGFuZCByZW5kZXJcclxuXHJcbiAgICBzdGVwOiBmdW5jdGlvbiAodGltZXN0YW1wKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmFjdGl2ZVtpXS5zdGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zeXMubWFpbmxvb3AucnVubmluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuc3lzLm1haW5sb29wLnN0ZXAodGltZXN0YW1wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLypcclxuICAgIHByZVVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5hY3RpdmVbaV0uc3RhdGU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0Lmxlbmd0aDsgYysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdFtjXS5wcmVVcGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RhdGUucHJlVXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuYWN0aXZlW2ldLnN0YXRlO1xyXG5cclxuICAgICAgICAgICAgLy8gIEludm9rZSBTdGF0ZSBNYWluIExvb3AgaGVyZSAtIHVwZGF0aW5nIGFsbCBvZiBpdHMgc3lzdGVtcyAodHdlZW5zLCBwaHlzaWNzLCBldGMpXHJcblxyXG4gICAgICAgICAgICAvLyAgVGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGlmIHRoZSBTdGF0ZSBpcyBzdGlsbCBsb2FkaW5nXHJcbiAgICAgICAgICAgIC8vICBIYXZlIGEgU3RhdGUuU1RBVFVTIGNvbnN0IGluIHRoZSBTZXR0aW5ncywgZGljdGF0aW5nIHdoYXQgaXMgZ29pbmcgb25cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBjKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5leGlzdHMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcG9zdFVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5hY3RpdmVbaV0uc3RhdGU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0Lmxlbmd0aDsgYysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdFtjXS5wb3N0VXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnBvc3RVcGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5hY3RpdmVbaV0uc3RhdGU7XHJcblxyXG4gICAgICAgICAgICAvLyAgQ2FuIHB1dCBhbGwga2luZHMgb2Ygb3RoZXIgY2hlY2tzIGluIGhlcmUsIGxpa2UgTWFpbkxvb3AsIEZQUywgZXRjLlxyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLnNldHRpbmdzLnZpc2libGUgfHwgc3RhdGUuc3lzLmNvbG9yLmFscGhhID09PSAwIHx8IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0Lmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5yZW5kZXJlci5yZW5kZXIoc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAqL1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RhdGVNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zdGF0ZS9TdGF0ZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9TdGF0ZU1hbmFnZXIuanMiLCJcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgUEVORElORzogMCxcclxuICAgIElOU1RBTExFRDogMSxcclxuXHJcbiAgICBCT09UOiAwLFxyXG4gICAgSU5JVDogMSxcclxuICAgIFBSRUxPQUQ6IDIsXHJcbiAgICBDUkVBVEU6IDMsXHJcbiAgICBVUERBVEU6IDQsXHJcbiAgICBSRU5ERVI6IDUsXHJcbiAgICBTSFVURE9XTjogNlxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDMyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBHYW1lT2JqZWN0IEZhY3RvcnkgaXMgYSBxdWljayB3YXkgdG8gY3JlYXRlIG1hbnkgY29tbW9uIGdhbWUgb2JqZWN0cy4gVGhlIEZhY3RvcnkgaXMgb3duZWQgYnkgdGhlIFN0YXRlLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5HYW1lT2JqZWN0LkZhY3RvcnlcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXHJcbiovXHJcblxyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlN0YXRlfSBzdGF0ZSAtIFRoZSBTdGF0ZSB0aGF0IG93bnMgdGhpcyBGYWN0b3J5XHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICovXHJcbiAgICBzdGF0ZTogbnVsbFxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXQgKHN0YXRlKVxyXG57XHJcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgR2FtZU9iamVjdEZhY3RvcnkgaW5zdGFuY2UgZm9yIFN0YXRlJyk7XHJcblxyXG4gICAgR2FtZU9iamVjdEZhY3Rvcnkuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICAvLyAgIExvYWQgdGhlIGZhY3RvcmllcyBpbnRvIHRoaXMgT2JqZWN0XHJcblxyXG4gICAgcmV0dXJuIEZhY3RvcnlDb250YWluZXIubG9hZChHYW1lT2JqZWN0RmFjdG9yeSwgdHJ1ZSk7XHJcblxyXG4gICAgLy8gcmV0dXJuIEdhbWVPYmplY3RGYWN0b3J5O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDMyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RGYWN0b3J5LmpzIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2NvbnN0Jyk7XHJcbnZhciBCYXNlTG9hZGVyID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL0Jhc2VMb2FkZXInKTtcclxudmFyIE51bWJlckFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXknKTtcclxuXHJcbnZhciBJbWFnZUZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZScpO1xyXG52YXIgSlNPTkZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0pTT05GaWxlJyk7XHJcbnZhciBYTUxGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlJyk7XHJcbnZhciBCaW5hcnlGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlJyk7XHJcbnZhciBHTFNMRmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUnKTtcclxudmFyIFRleHRGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZScpO1xyXG52YXIgQXRsYXNKU09ORmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZScpO1xyXG5cclxudmFyIExvYWRlciA9IGZ1bmN0aW9uIChzdGF0ZSlcclxue1xyXG4gICAgQmFzZUxvYWRlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5TdGF0ZX0gc3RhdGUgLSBUaGUgU3RhdGUgdGhhdCBvd25zIHRoaXMgRmFjdG9yeVxyXG4gICAgKiBAcHJvdGVjdGVkXHJcbiAgICAqL1xyXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgIHRoaXMuX211bHRpbGlzdCA9IHt9O1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUxvYWRlci5wcm90b3R5cGUpO1xyXG5Mb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9hZGVyO1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBmaWxlID0gbmV3IEltYWdlRmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcclxufTtcclxuXHJcbkxvYWRlci5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBmaWxlID0gbmV3IEpTT05GaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS54bWwgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBYTUxGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS5iaW5hcnkgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBCaW5hcnlGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGZpbGUgPSBuZXcgVGV4dEZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmdsc2wgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBHTFNMRmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcclxufTtcclxuXHJcbkxvYWRlci5wcm90b3R5cGUuYXRsYXMgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMLCBhdGxhc1VSTCwgdGV4dHVyZVhoclNldHRpbmdzLCBhdGxhc1hoclNldHRpbmdzKVxyXG57XHJcbiAgICAvLyAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczogJ3RleHR1cmUnIGFuZCAnZGF0YSdcclxuICAgIHZhciBmaWxlcyA9IG5ldyBBdGxhc0pTT05GaWxlKGtleSwgdGV4dHVyZVVSTCwgYXRsYXNVUkwsIHRoaXMucGF0aCwgdGV4dHVyZVhoclNldHRpbmdzLCBhdGxhc1hoclNldHRpbmdzKTtcclxuXHJcbiAgICB0aGlzLmFkZEZpbGUoZmlsZXMudGV4dHVyZSk7XHJcbiAgICB0aGlzLmFkZEZpbGUoZmlsZXMuZGF0YSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLm11bHRpYXRsYXMgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMcywgYXRsYXNVUkxzLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIGF0bGFzWGhyU2V0dGluZ3MpXHJcbntcclxuICAgIGlmICh0eXBlb2YgdGV4dHVyZVVSTHMgPT09ICdudW1iZXInKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0b3RhbCA9IHRleHR1cmVVUkxzO1xyXG5cclxuICAgICAgICB0ZXh0dXJlVVJMcyA9IE51bWJlckFycmF5KDAsIHRvdGFsLCBrZXkgKyAnLScsICcucG5nJyk7XHJcbiAgICAgICAgYXRsYXNVUkxzID0gTnVtYmVyQXJyYXkoMCwgdG90YWwsIGtleSArICctJywgJy5qc29uJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRleHR1cmVVUkxzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRleHR1cmVVUkxzID0gWyB0ZXh0dXJlVVJMcyBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGF0bGFzVVJMcykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhdGxhc1VSTHMgPSBbIGF0bGFzVVJMcyBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmlsZTtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBtdWx0aUtleTtcclxuXHJcbiAgICB0aGlzLl9tdWx0aWxpc3Rba2V5XSA9IFtdO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0ZXh0dXJlVVJMcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBtdWx0aUtleSA9ICdfTUFfSU1HXycgKyBrZXkgKyAnXycgKyBpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIGZpbGUgPSBuZXcgSW1hZ2VGaWxlKG11bHRpS2V5LCB0ZXh0dXJlVVJMc1tpXSwgdGhpcy5wYXRoLCB0ZXh0dXJlWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX211bHRpbGlzdFtrZXldLnB1c2gobXVsdGlLZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBhdGxhc1VSTHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgbXVsdGlLZXkgPSAnX01BX0pTT05fJyArIGtleSArICdfJyArIGkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgZmlsZSA9IG5ldyBKU09ORmlsZShtdWx0aUtleSwgYXRsYXNVUkxzW2ldLCB0aGlzLnBhdGgsIGF0bGFzWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX211bHRpbGlzdFtrZXldLnB1c2gobXVsdGlLZXkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gIFRoZSBMb2FkZXIgaGFzIGZpbmlzaGVkXHJcbkxvYWRlci5wcm90b3R5cGUucHJvY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKHRoaXMuc3RvcmFnZS5zaXplID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgVGhlIGdsb2JhbCBUZXh0dXJlIE1hbmFnZXJcclxuICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMuc3RhdGUuc3lzLnRleHR1cmVzO1xyXG5cclxuICAgIC8vICBQcm9jZXNzIG11bHRpYXRsYXMgZ3JvdXBzIGZpcnN0XHJcblxyXG4gICAgdmFyIGZpbGU7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuX211bHRpbGlzdClcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IFtdO1xyXG4gICAgICAgIHZhciBpbWFnZXMgPSBbXTtcclxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuX211bHRpbGlzdFtrZXldO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmaWxlID0gdGhpcy5zdG9yYWdlLmdldCgna2V5Jywga2V5c1tpXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZmlsZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGUudHlwZSA9PT0gJ2ltYWdlJylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZXMucHVzaChmaWxlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlsZS50eXBlID09PSAnanNvbicpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKGZpbGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbGV0ZShmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIERvIHdlIGhhdmUgZXZlcnl0aGluZyBuZWVkZWQ/XHJcbiAgICAgICAgaWYgKGltYWdlcy5sZW5ndGggKyBkYXRhLmxlbmd0aCA9PT0ga2V5cy5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgWXVwLCBhZGQgdGhlbSB0byB0aGUgVGV4dHVyZSBNYW5hZ2VyXHJcblxyXG4gICAgICAgICAgICAvLyAgSXMgdGhlIGRhdGEgSlNPTiBIYXNoIG9yIEpTT04gQXJyYXk/XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbMF0uZnJhbWVzKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkQXRsYXNKU09OQXJyYXkoa2V5LCBpbWFnZXMsIGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkQXRsYXNKU09OSGFzaChrZXksIGltYWdlcywgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdG9yYWdlLmVhY2goZnVuY3Rpb24gKGZpbGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGZpbGUudHlwZSA9PT0gJ2ltYWdlJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRleHR1cmVzLmFkZEltYWdlKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmaWxlLnR5cGUgPT09ICdhdGxhc2pzb24nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGZpbGVBID0gZmlsZS5maWxlQTtcclxuICAgICAgICAgICAgdmFyIGZpbGVCID0gZmlsZS5maWxlQjtcclxuXHJcbiAgICAgICAgICAgIGlmIChmaWxlQS50eXBlID09PSAnaW1hZ2UnKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhcyhmaWxlQS5rZXksIGZpbGVBLmRhdGEsIGZpbGVCLmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkQXRsYXMoZmlsZUIua2V5LCBmaWxlQi5kYXRhLCBmaWxlQS5kYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmaWxlLnR5cGUgPT09ICdqc29uJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZGlyKGZpbGUuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zdG9yYWdlLmNsZWFyKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9Mb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8vIE15IHRoYW5rcyB0byBJc2FhYyBTdWtpbiBmb3IgY3JlYXRpbmcgTWFpbkxvb3AuanMsIG9uIHdoaWNoIGxvdHMgb2YgdGhpcyBpcyBiYXNlZC5cclxuXHJcbnZhciBNYWluTG9vcCA9IGZ1bmN0aW9uIChzdGF0ZSwgZnJhbWVyYXRlKVxyXG57XHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuU3RhdGV9IHN0YXRlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIEdhbWUuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5nYW1lID0gc3RhdGUuZ2FtZTtcclxuXHJcbiAgICAvLyBUaGUgYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdG8gc2ltdWxhdGUgZWFjaCB0aW1lIHVwZGF0ZSgpIHJ1bnMuXHJcbiAgICB0aGlzLnRpbWVzdGVwID0gMTAwMCAvIGZyYW1lcmF0ZTtcclxuXHJcbiAgICB0aGlzLnBoeXNpY3NTdGVwID0gMSAvIGZyYW1lcmF0ZTtcclxuXHJcbiAgICAvLyBUaGUgY3VtdWxhdGl2ZSBhbW91bnQgb2YgaW4tYXBwIHRpbWUgdGhhdCBoYXNuJ3QgYmVlbiBzaW11bGF0ZWQgeWV0LlxyXG4gICAgLy8gU2VlIHRoZSBjb21tZW50cyBpbnNpZGUgYW5pbWF0ZSgpIGZvciBkZXRhaWxzLlxyXG4gICAgdGhpcy5mcmFtZURlbHRhID0gMDtcclxuXHJcbiAgICAvLyBUaGUgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcyBvZiB0aGUgbGFzdCB0aW1lIHRoZSBtYWluIGxvb3Agd2FzIHJ1bi5cclxuICAgIC8vIFVzZWQgdG8gY29tcHV0ZSB0aGUgdGltZSBlbGFwc2VkIGJldHdlZW4gZnJhbWVzLlxyXG4gICAgdGhpcy5sYXN0RnJhbWVUaW1lTXMgPSAwO1xyXG5cclxuICAgIC8vIEFuIGV4cG9uZW50aWFsIG1vdmluZyBhdmVyYWdlIG9mIHRoZSBmcmFtZXMgcGVyIHNlY29uZC5cclxuICAgIHRoaXMuZnBzID0gNjA7XHJcblxyXG4gICAgLy8gVGhlIHRpbWVzdGFtcCAoaW4gbWlsbGlzZWNvbmRzKSBvZiB0aGUgbGFzdCB0aW1lIHRoZSBgZnBzYCBtb3ZpbmdcclxuICAgIC8vIGF2ZXJhZ2Ugd2FzIHVwZGF0ZWQuXHJcbiAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSAwO1xyXG5cclxuICAgIC8vIFRoZSBudW1iZXIgb2YgZnJhbWVzIGRlbGl2ZXJlZCBpbiB0aGUgY3VycmVudCBzZWNvbmQuXHJcbiAgICB0aGlzLmZyYW1lc1RoaXNTZWNvbmQgPSAwO1xyXG5cclxuICAgIC8vIFRoZSBudW1iZXIgb2YgdGltZXMgdXBkYXRlKCkgaXMgY2FsbGVkIGluIGEgZ2l2ZW4gZnJhbWUuIFRoaXMgaXMgb25seVxyXG4gICAgLy8gcmVsZXZhbnQgaW5zaWRlIG9mIGFuaW1hdGUoKSwgYnV0IGEgcmVmZXJlbmNlIGlzIGhlbGQgZXh0ZXJuYWxseSBzbyB0aGF0XHJcbiAgICAvLyB0aGlzIHZhcmlhYmxlIGlzIG5vdCBtYXJrZWQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBldmVyeSB0aW1lIHRoZSBtYWluXHJcbiAgICAvLyBsb29wIHJ1bnMuXHJcbiAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcclxuXHJcbiAgICAvLyBUaGUgbWluaW11bSBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBtdXN0IHBhc3Mgc2luY2UgdGhlIGxhc3RcclxuICAgIC8vIGZyYW1lIHdhcyBleGVjdXRlZCBiZWZvcmUgYW5vdGhlciBmcmFtZSBjYW4gYmUgZXhlY3V0ZWQuIFRoZVxyXG4gICAgLy8gbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBjYXBzIHRoZSBGUFMgKHRoZSBkZWZhdWx0IG9mIHplcm8gbWVhbnMgdGhlcmUgaXNcclxuICAgIC8vIG5vIGNhcCkuXHJcbiAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAwO1xyXG5cclxuICAgIC8vIFdoZXRoZXIgdGhlIG1haW4gbG9vcCBpcyBydW5uaW5nLlxyXG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLy8gYHRydWVgIGlmIGBNYWluTG9vcC5zdGFydCgpYCBoYXMgYmVlbiBjYWxsZWQgYW5kIHRoZSBtb3N0IHJlY2VudCB0aW1lIGl0XHJcbiAgICAvLyB3YXMgY2FsbGVkIGhhcyBub3QgYmVlbiBmb2xsb3dlZCBieSBhIGNhbGwgdG8gYE1haW5Mb29wLnN0b3AoKWAuIFRoaXMgaXNcclxuICAgIC8vIGRpZmZlcmVudCB0aGFuIGBydW5uaW5nYCBiZWNhdXNlIHRoZXJlIGlzIGEgZGVsYXkgb2YgYSBmZXcgbWlsbGlzZWNvbmRzXHJcbiAgICAvLyBhZnRlciBgTWFpbkxvb3Auc3RhcnQoKWAgaXMgY2FsbGVkIGJlZm9yZSB0aGUgYXBwbGljYXRpb24gaXMgY29uc2lkZXJlZFxyXG4gICAgLy8gXCJydW5uaW5nLlwiIFRoaXMgZGVsYXkgaXMgZHVlIHRvIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGZyYW1lLlxyXG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gV2hldGhlciB0aGUgc2ltdWxhdGlvbiBoYXMgZmFsbGVuIHRvbyBmYXIgYmVoaW5kIHJlYWwgdGltZS5cclxuICAgIC8vIFNwZWNpZmljYWxseSwgYHBhbmljYCB3aWxsIGJlIHNldCB0byBgdHJ1ZWAgaWYgdG9vIG1hbnkgdXBkYXRlcyBvY2N1ciBpblxyXG4gICAgLy8gb25lIGZyYW1lLiBUaGlzIGlzIG9ubHkgcmVsZXZhbnQgaW5zaWRlIG9mIGFuaW1hdGUoKSwgYnV0IGEgcmVmZXJlbmNlIGlzXHJcbiAgICAvLyBoZWxkIGV4dGVybmFsbHkgc28gdGhhdCB0aGlzIHZhcmlhYmxlIGlzIG5vdCBtYXJrZWQgZm9yIGdhcmJhZ2VcclxuICAgIC8vIGNvbGxlY3Rpb24gZXZlcnkgdGltZSB0aGUgbWFpbiBsb29wIHJ1bnMuXHJcbiAgICB0aGlzLnBhbmljID0gZmFsc2U7XHJcbn07XHJcblxyXG5NYWluTG9vcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYWluTG9vcDtcclxuXHJcbk1haW5Mb29wLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRNYXhGUFM6IGZ1bmN0aW9uIChmcHMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGZwcyA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAxMDAwIC8gZnBzO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TWF4RlBTOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxMDAwIC8gdGhpcy5taW5GcmFtZURlbGF5O1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldEZyYW1lRGVsdGE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG9sZEZyYW1lRGVsdGEgPSB0aGlzLmZyYW1lRGVsdGE7XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiBvbGRGcmFtZURlbHRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5zdGFydGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZU1zID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICB0aGlzLmZyYW1lc1RoaXNTZWNvbmQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgdGltZXN0YW1wID0gRE9NSGlnaFJlc1RpbWVTdGFtcFxyXG4gICAgc3RlcDogZnVuY3Rpb24gKHRpbWVzdGFtcClcclxuICAgIHtcclxuICAgICAgICAvLyBUaHJvdHRsZSB0aGUgZnJhbWUgcmF0ZSAoaWYgbWluRnJhbWVEZWxheSBpcyBzZXQgdG8gYSBub24temVybyB2YWx1ZSBieVxyXG4gICAgICAgIC8vIGBNYWluTG9vcC5zZXRNYXhBbGxvd2VkRlBTKClgKS5cclxuICAgICAgICBpZiAodGltZXN0YW1wIDwgdGhpcy5sYXN0RnJhbWVUaW1lTXMgKyB0aGlzLm1pbkZyYW1lRGVsYXkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmcmFtZURlbHRhIGlzIHRoZSBjdW11bGF0aXZlIGFtb3VudCBvZiBpbi1hcHAgdGltZSB0aGF0IGhhc24ndCBiZWVuXHJcbiAgICAgICAgLy8gc2ltdWxhdGVkIHlldC4gQWRkIHRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGZyYW1lLiBXZSBuZWVkIHRvIHRyYWNrIHRvdGFsXHJcbiAgICAgICAgLy8gbm90LXlldC1zaW11bGF0ZWQgdGltZSAoYXMgb3Bwb3NlZCB0byBqdXN0IHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlXHJcbiAgICAgICAgLy8gbGFzdCBmcmFtZSkgYmVjYXVzZSBub3QgYWxsIGFjdHVhbGx5IGVsYXBzZWQgdGltZSBpcyBndWFyYW50ZWVkIHRvIGJlXHJcbiAgICAgICAgLy8gc2ltdWxhdGVkIGVhY2ggZnJhbWUuIFNlZSB0aGUgY29tbWVudHMgYmVsb3cgZm9yIGRldGFpbHMuXHJcbiAgICAgICAgdGhpcy5mcmFtZURlbHRhICs9IHRpbWVzdGFtcCAtIHRoaXMubGFzdEZyYW1lVGltZU1zO1xyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZU1zID0gdGltZXN0YW1wO1xyXG5cclxuICAgICAgICAvLyBSdW4gYW55IHVwZGF0ZXMgdGhhdCBhcmUgbm90IGRlcGVuZGVudCBvbiB0aW1lIGluIHRoZSBzaW11bGF0aW9uLlxyXG5cclxuICAgICAgICAvLyAgSGVyZSB3ZSdsbCBuZWVkIHRvIHJ1biB0aGluZ3MgbGlrZSB0d2Vlbi51cGRhdGUsIGlucHV0LnVwZGF0ZSwgZXRjLlxyXG4gICAgICAgIHRoaXMuc3RhdGUuc3lzLmJlZ2luKHRpbWVzdGFtcCwgdGhpcy5mcmFtZURlbHRhKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBlc3RpbWF0ZSBvZiB0aGUgZnJhbWUgcmF0ZSwgYGZwc2AuIEV2ZXJ5IHNlY29uZCwgdGhlIG51bWJlclxyXG4gICAgICAgIC8vIG9mIGZyYW1lcyB0aGF0IG9jY3VycmVkIGluIHRoYXQgc2Vjb25kIGFyZSBpbmNsdWRlZCBpbiBhbiBleHBvbmVudGlhbFxyXG4gICAgICAgIC8vIG1vdmluZyBhdmVyYWdlIG9mIGFsbCBmcmFtZXMgcGVyIHNlY29uZCwgd2l0aCBhbiBhbHBoYSBvZiAwLjI1LiBUaGlzXHJcbiAgICAgICAgLy8gbWVhbnMgdGhhdCBtb3JlIHJlY2VudCBzZWNvbmRzIGFmZmVjdCB0aGUgZXN0aW1hdGVkIGZyYW1lIHJhdGUgbW9yZSB0aGFuXHJcbiAgICAgICAgLy8gb2xkZXIgc2Vjb25kcy5cclxuICAgICAgICBpZiAodGltZXN0YW1wID4gdGhpcy5sYXN0RnBzVXBkYXRlICsgMTAwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIG5ldyBleHBvbmVudGlhbCBtb3ZpbmcgYXZlcmFnZSB3aXRoIGFuIGFscGhhIG9mIDAuMjUuXHJcbiAgICAgICAgICAgIC8vIFVzaW5nIGNvbnN0YW50cyBpbmxpbmUgaXMgb2theSBoZXJlLlxyXG4gICAgICAgICAgICB0aGlzLmZwcyA9IDAuMjUgKiB0aGlzLmZyYW1lc1RoaXNTZWNvbmQgKyAwLjc1ICogdGhpcy5mcHM7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZyYW1lc1RoaXNTZWNvbmQrKztcclxuXHJcbiAgICAgICAgdGhpcy5udW1VcGRhdGVTdGVwcyA9IDA7XHJcblxyXG4gICAgICAgIHZhciBzdGVwID0gdGhpcy50aW1lc3RlcDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhbWVEZWx0YSA+PSBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gdGhpcy51cGRhdGUodGhpcy50aW1lc3RlcCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN5cy51cGRhdGUoc3RlcCwgdGhpcy5waHlzaWNzU3RlcCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoaXMuc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBjKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3RbY107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmV4aXN0cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC51cGRhdGUoc3RlcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vICBEZXYgbGV2ZWwgY2FsbGJhY2tcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGUoc3RlcCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZyYW1lRGVsdGEgLT0gdGhpcy50aW1lc3RlcDtcclxuXHJcbiAgICAgICAgICAgIGlmICgrK3RoaXMubnVtVXBkYXRlU3RlcHMgPj0gMjQwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhbmljID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLnN5cy5wcmVSZW5kZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zeXMudXBkYXRlcy5zdGFydCgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZXR0aW5ncy52aXNpYmxlICYmIHRoaXMuc3RhdGUuc3lzLmNvbG9yLmFscGhhICE9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lLnJlbmRlcmVyLnJlbmRlcih0aGlzLnN0YXRlLCB0aGlzLmZyYW1lRGVsdGEgLyB0aGlzLnRpbWVzdGVwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUuc3lzLnVwZGF0ZXMuc3RvcCgpO1xyXG5cclxuICAgICAgICAvLyBSdW4gYW55IHVwZGF0ZXMgdGhhdCBhcmUgbm90IGRlcGVuZGVudCBvbiB0aW1lIGluIHRoZSBzaW11bGF0aW9uLlxyXG4gICAgICAgIHRoaXMuc3RhdGUuc3lzLmVuZCh0aGlzLmZwcywgdGhpcy5wYW5pYyk7XHJcblxyXG4gICAgICAgIHRoaXMucGFuaWMgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgLypcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUuc3lzLnVwZGF0ZSh0aW1lc3RlcCk7XHJcblxyXG4gICAgICAgIHZhciBjO1xyXG4gICAgICAgIHZhciBjaGlsZDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGlzLnN0YXRlLnN5cy5jaGlsZHJlbi5saXN0Lmxlbmd0aDsgYysrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5zdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdFtjXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5leGlzdHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZSh0aW1lc3RlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBEZXYgbGV2ZWwgY2FsbGJhY2tcclxuICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZSh0aW1lc3RlcCk7XHJcblxyXG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCB0aGlzLnN0YXRlLnN5cy5jaGlsZHJlbi5saXN0Lmxlbmd0aDsgYysrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5zdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdFtjXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5leGlzdHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZSh0aW1lc3RlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgKi9cclxuXHJcbiAgICBzdG9wOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1haW5Mb29wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zdGF0ZS9zeXN0ZW1zL01haW5Mb29wLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogRGlydHkhIE1hbmFnZXJcclxuKlxyXG4qIEBjbGFzc1xyXG4qL1xyXG52YXIgVXBkYXRlTWFuYWdlciA9IGZ1bmN0aW9uIChzdGF0ZSlcclxue1xyXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgIHRoaXMuZ2FtZSA9IHN0YXRlLmdhbWU7XHJcblxyXG4gICAgdGhpcy5saXN0ID0gW107XHJcblxyXG4gICAgLy8gdGhpcy5pID0gMTtcclxuXHJcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgdGhpcy5wcm9jZXNzZWQgPSAwO1xyXG59O1xyXG5cclxuVXBkYXRlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVcGRhdGVNYW5hZ2VyO1xyXG5cclxuVXBkYXRlTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc3RvcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMucnVubmluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuaSwgJ1VwZGF0ZU1hbmFnZXIuc3RvcCcsIHRoaXMucHJvY2Vzc2VkKTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0Lmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIC8vIHRoaXMuaSsrO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMucnVubmluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxpc3QubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAobGVuID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5pLCAnVXBkYXRlTWFuYWdlci5zdGFydCcsIGxlbik7XHJcblxyXG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBCZWNhdXNlIGl0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQgKGFzIGEgY2hpbGQgb2YgYW5vdGhlciBUcmFuc2Zvcm0gdGhhdCB3YXMgdXBkYXRlZClcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdFtpXSAmJiB0aGlzLmxpc3RbaV0uX2RpcnR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2ldLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh0cmFuc2Zvcm0pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5saXN0LnB1c2godHJhbnNmb3JtKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVwZGF0ZU1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL3N5c3RlbXMvVXBkYXRlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMzI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEEgU2V0IGlzIGEgY29sbGVjdGlvbiBvZiB1bmlxdWUgZWxlbWVudHMuXHJcblxyXG52YXIgU2V0ID0gZnVuY3Rpb24gKGVsZW1lbnRzKVxyXG57XHJcbiAgICB0aGlzLmVudHJpZXMgPSBbXTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50cykpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKGVsZW1lbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2V0O1xyXG5cclxuU2V0LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5lbnRyaWVzLmluZGV4T2YodmFsdWUpID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoZW50cnlbcHJvcGVydHldID09PSB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkZWxldGU6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmVudHJpZXMuaW5kZXhPZih2YWx1ZSk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZHVtcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmdyb3VwKCdTZXQnKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVudHJ5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8vICBGb3Igd2hlbiB5b3Uga25vdyB0aGlzIFNldCB3aWxsIGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgaXRlcmF0aW9uXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmVudHJpZXMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHRlbXBbaV0pID09PSBmYWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgRm9yIHdoZW4geW91IGFic29sdXRlbHkga25vdyB0aGlzIFNldCB3b24ndCBiZSBtb2RpZmllZCBkdXJpbmcgdGhlIGl0ZXJhdGlvblxyXG4gICAgaXRlcmF0ZTogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRyaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHRoaXMuZW50cmllc1tpXSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZW50cmllcy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZW50cmllcy5pbmRleE9mKHZhbHVlKSA+IC0xKTtcclxuICAgIH0sXHJcblxyXG4gICAgdW5pb246IGZ1bmN0aW9uIChzZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgc2V0LnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuZXdTZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1NldDtcclxuICAgIH0sXHJcblxyXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoc2V0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuZXdTZXQgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzZXQuY29udGFpbnModmFsdWUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3U2V0O1xyXG4gICAgfSxcclxuXHJcbiAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbiAoc2V0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuZXdTZXQgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghc2V0LmNvbnRhaW5zKHZhbHVlKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbmV3U2V0LmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1NldDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhTZXQucHJvdG90eXBlLCB7XHJcblxyXG4gICAgc2l6ZToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzLmxlbmd0aDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMubGVuZ3RoID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0cnVjdHMvU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEV4dGVuZCA9IHJlcXVpcmUoJy4uL3V0aWxzL29iamVjdC9FeHRlbmQnKTtcclxuXHJcbi8qKlxyXG4qIEEgRnJhbWUgaXMgYSBzZWN0aW9uIG9mIGEgVGV4dHVyZS5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuRnJhbWVcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIFRleHR1cmUgdGhpcyBGcmFtZSBiZWxvbmdzIHRvLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIHVuaXF1ZSAod2l0aGluIHRoZSBUZXh0dXJlKSBuYW1lIG9mIHRoaXMgRnJhbWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBYIHBvc2l0aW9uIG9mIHRoZSBmcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIHBvc2l0aW9uIG9mIHRoZSBmcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIGZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZS5cclxuKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSBmcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUuXHJcbiovXHJcbnZhciBGcmFtZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBuYW1lLCBzb3VyY2VJbmRleCwgeCwgeSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgVGV4dHVyZSB0aGlzIGZyYW1lIGJlbG9uZ3MgdG8uXHJcbiAgICAqL1xyXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGlzIGZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZS5cclxuICAgICovXHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgIHRoaXMuc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xyXG5cclxuICAgIHRoaXMuc291cmNlSW5kZXggPSBzb3VyY2VJbmRleDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGN1dFggLSBYIHBvc2l0aW9uIHdpdGhpbiB0aGUgc291cmNlIGltYWdlIHRvIGN1dCBmcm9tLlxyXG4gICAgKi9cclxuICAgIHRoaXMuY3V0WCA9IHg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRZIC0gWSBwb3NpdGlvbiB3aXRoaW4gdGhlIHNvdXJjZSBpbWFnZSB0byBjdXQgZnJvbS5cclxuICAgICovXHJcbiAgICB0aGlzLmN1dFkgPSB5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gY3V0V2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGFyZWEgaW4gdGhlIHNvdXJjZSBpbWFnZSB0byBjdXQuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5jdXRXaWR0aCA9IHdpZHRoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gY3V0SGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgYXJlYSBpbiB0aGUgc291cmNlIGltYWdlIHRvIGN1dC5cclxuICAgICovXHJcbiAgICB0aGlzLmN1dEhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBUaGUgWCByZW5kZXJpbmcgb2Zmc2V0IG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cclxuICAgICovXHJcbiAgICB0aGlzLnggPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0geSAtIFRoZSBZIHJlbmRlcmluZyBvZmZzZXQgb2YgdGhpcyBGcmFtZSwgdGFraW5nIHRyaW0gaW50byBhY2NvdW50LlxyXG4gICAgKi9cclxuICAgIHRoaXMueSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFRoZSByZW5kZXJpbmcgd2lkdGggb2YgdGhpcyBGcmFtZSwgdGFraW5nIHRyaW0gaW50byBhY2NvdW50LlxyXG4gICAgKi9cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIFRoZSByZW5kZXJpbmcgaGVpZ2h0IG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cclxuICAgICovXHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAvKipcclxuICAgICogSXMgdGhpcyBmcmFtZSBpcyByb3RhdGVkIG9yIG5vdCBpbiB0aGUgVGV4dHVyZT9cclxuICAgICogUm90YXRpb24gYWxsb3dzIHlvdSB0byB1c2Ugcm90YXRlZCBmcmFtZXMgaW4gdGV4dHVyZSBhdGxhcyBwYWNraW5nLlxyXG4gICAgKiBJdCBoYXMgbm90aGluZyB0byBkbyB3aXRoIFNwcml0ZSByb3RhdGlvbi5cclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSByb3RhdGVkXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5yb3RhdGVkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIElzIHRoaXMgYSB0aWxpbmcgdGV4dHVyZT8gQXMgdXNlZCBieSB0aGUgbGlrZXMgb2YgYSBUaWxpbmdTcHJpdGUuXHJcbiAgICAqIFRPRE86IFRyeSBhbmQgcmVtb3ZlIHRoaXMsIGl0IHNob3VsZG4ndCBiZSBoZXJlXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNUaWxpbmdcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLmlzVGlsaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoaXMgd2lsbCBsZXQgYSByZW5kZXJlciBrbm93IHRoYXQgYSB0aW50ZWQgcGFyZW50IGhhcyB1cGRhdGVkIGl0cyB0ZXh0dXJlLlxyXG4gICAgKiBUT0RPOiBUcnkgYW5kIHJlbW92ZSB0aGlzLCBpdCBzaG91bGRuJ3QgYmUgaGVyZVxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlcXVpcmVzUmVUaW50XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5yZXF1aXJlc1JlVGludCA9IGZhbHNlO1xyXG5cclxuICAgIC8vICBPdmVyLXJpZGVzIHRoZSBSZW5kZXJlciBzZXR0aW5nPyAtMSA9IHVzZSBSZW5kZXJlciBTZXR0aW5nLCAwID0gTm8gcm91bmRpbmcsIDEgPSBSb3VuZFxyXG4gICAgdGhpcy5hdXRvUm91bmQgPSAtMTtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIHVuLW1vZGlmaWVkIHNvdXJjZSBmcmFtZSwgdHJpbSBhbmQgVVYgZGF0YS5cclxuICAgICpcclxuICAgICogQHByaXZhdGVcclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGFcclxuICAgICovXHJcbiAgICB0aGlzLmRhdGEgPSB7XHJcbiAgICAgICAgY3V0OiB7XHJcbiAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgIHc6IHdpZHRoLFxyXG4gICAgICAgICAgICBoOiBoZWlnaHQsXHJcbiAgICAgICAgICAgIHI6IHggKyB3aWR0aCxcclxuICAgICAgICAgICAgYjogeSArIGhlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJpbTogZmFsc2UsXHJcbiAgICAgICAgc291cmNlU2l6ZToge1xyXG4gICAgICAgICAgICB3OiB3aWR0aCxcclxuICAgICAgICAgICAgaDogaGVpZ2h0XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcHJpdGVTb3VyY2VTaXplOiB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHc6IHdpZHRoLFxyXG4gICAgICAgICAgICBoOiBoZWlnaHRcclxuICAgICAgICB9LFxyXG4gICAgICAgIHV2czoge1xyXG4gICAgICAgICAgICB4MDogMCxcclxuICAgICAgICAgICAgeTA6IDAsXHJcbiAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICB5MTogMCxcclxuICAgICAgICAgICAgeDI6IDAsXHJcbiAgICAgICAgICAgIHkyOiAwLFxyXG4gICAgICAgICAgICB4MzogMCxcclxuICAgICAgICAgICAgeTM6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYXdJbWFnZToge1xyXG4gICAgICAgICAgICBzeDogeCxcclxuICAgICAgICAgICAgc3k6IHksXHJcbiAgICAgICAgICAgIHNXaWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIHNIZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgZFdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgZEhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZVVWcygpO1xyXG59O1xyXG5cclxuRnJhbWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJhbWU7XHJcblxyXG5GcmFtZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIElmIHRoZSBmcmFtZSB3YXMgdHJpbW1lZCB3aGVuIGFkZGVkIHRvIHRoZSBUZXh0dXJlIEF0bGFzLCB0aGlzIHJlY29yZHMgdGhlIHRyaW0gYW5kIHNvdXJjZSBkYXRhLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5UZXh0dXJlRnJhbWUjc2V0VHJpbVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYWN0dWFsV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGZyYW1lIGJlZm9yZSBiZWluZyB0cmltbWVkLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYWN0dWFsSGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgZnJhbWUgYmVmb3JlIGJlaW5nIHRyaW1tZWQuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0WCAtIFRoZSBkZXN0aW5hdGlvbiBYIHBvc2l0aW9uIG9mIHRoZSB0cmltbWVkIGZyYW1lIGZvciBkaXNwbGF5LlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdFkgLSBUaGUgZGVzdGluYXRpb24gWSBwb3NpdGlvbiBvZiB0aGUgdHJpbW1lZCBmcmFtZSBmb3IgZGlzcGxheS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc3RXaWR0aCAtIFRoZSBkZXN0aW5hdGlvbiB3aWR0aCBvZiB0aGUgdHJpbW1lZCBmcmFtZSBmb3IgZGlzcGxheS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc3RIZWlnaHQgLSBUaGUgZGVzdGluYXRpb24gaGVpZ2h0IG9mIHRoZSB0cmltbWVkIGZyYW1lIGZvciBkaXNwbGF5LlxyXG4gICAgKi9cclxuICAgIHNldFRyaW06IGZ1bmN0aW9uIChhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0LCBkZXN0WCwgZGVzdFksIGRlc3RXaWR0aCwgZGVzdEhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgICAgICB2YXIgc3MgPSBkYXRhLnNwcml0ZVNvdXJjZVNpemU7XHJcbiAgICAgICAgdmFyIGRpID0gZGF0YS5kcmF3SW1hZ2U7XHJcblxyXG4gICAgICAgIC8vICBTdG9yZSBhY3R1YWwgdmFsdWVzXHJcblxyXG4gICAgICAgIGRhdGEudHJpbSA9IHRydWU7XHJcblxyXG4gICAgICAgIGRhdGEuc291cmNlU2l6ZS53ID0gYWN0dWFsV2lkdGg7XHJcbiAgICAgICAgZGF0YS5zb3VyY2VTaXplLmggPSBhY3R1YWxIZWlnaHQ7XHJcblxyXG4gICAgICAgIHNzLnggPSBkZXN0WDtcclxuICAgICAgICBzcy55ID0gZGVzdFk7XHJcbiAgICAgICAgc3MudyA9IGRlc3RXaWR0aDtcclxuICAgICAgICBzcy5oID0gZGVzdEhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gIEFkanVzdCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgdGhpcy54ID0gZGVzdFg7XHJcbiAgICAgICAgdGhpcy55ID0gZGVzdFk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IGRlc3RXaWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGRlc3RIZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vICBkcmF3SW1hZ2UgZGF0YVxyXG4gICAgICAgIC8vIGRpLnN4ID0gZGVzdFg7XHJcbiAgICAgICAgLy8gZGkuc3kgPSBkZXN0WTtcclxuICAgICAgICAvLyBkaS5zV2lkdGggPSBkZXN0V2lkdGg7XHJcbiAgICAgICAgLy8gZGkuc0hlaWdodCA9IGRlc3RIZWlnaHQ7XHJcbiAgICAgICAgLy8gZGkuZFdpZHRoID0gZGVzdFdpZHRoO1xyXG4gICAgICAgIC8vIGRpLmRIZWlnaHQgPSBkZXN0SGVpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVVWcygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIHVwZGF0ZVVWc1xyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHVwZGF0ZVVWczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgdHcgPSB0aGlzLnNvdXJjZS53aWR0aDtcclxuICAgICAgICB2YXIgdGggPSB0aGlzLnNvdXJjZS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHV2cyA9IHRoaXMuZGF0YS51dnM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdXZzLngwID0gdGhpcy5jdXRYIC8gdHc7XHJcbiAgICAgICAgdXZzLnkwID0gdGhpcy5jdXRZIC8gdGg7XHJcblxyXG4gICAgICAgIHV2cy54MSA9IHRoaXMuY3V0WCAvIHR3O1xyXG4gICAgICAgIHV2cy55MSA9ICh0aGlzLmN1dFkgKyB0aGlzLmN1dEhlaWdodCkgLyB0aDtcclxuXHJcbiAgICAgICAgdXZzLngyID0gKHRoaXMuY3V0WCArIHRoaXMuY3V0V2lkdGgpIC8gdHc7XHJcbiAgICAgICAgdXZzLnkyID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0SGVpZ2h0KSAvIHRoO1xyXG5cclxuICAgICAgICB1dnMueDMgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRXaWR0aCkgLyB0dztcclxuICAgICAgICB1dnMueTMgPSB0aGlzLmN1dFkgLyB0aDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCB1cGRhdGVVVnNJbnZlcnRlZFxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHVwZGF0ZVVWc0ludmVydGVkOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0dyA9IHRoaXMuc291cmNlLndpZHRoO1xyXG4gICAgICAgIHZhciB0aCA9IHRoaXMuc291cmNlLmhlaWdodDtcclxuICAgICAgICB2YXIgdXZzID0gdGhpcy5kYXRhLnV2cztcclxuICAgICAgICBcclxuICAgICAgICB1dnMueDMgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRIZWlnaHQpIC8gdHc7XHJcbiAgICAgICAgdXZzLnkzID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0V2lkdGgpIC8gdGg7XHJcblxyXG4gICAgICAgIHV2cy54MiA9IHRoaXMuY3V0WCAvIHR3OyAgICAgICAgXHJcbiAgICAgICAgdXZzLnkyID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0V2lkdGgpIC8gdGg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdXZzLngxID0gdGhpcy5jdXRYIC8gdHc7XHJcbiAgICAgICAgdXZzLnkxID0gdGhpcy5jdXRZIC8gdGg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdXZzLngwID0gKHRoaXMuY3V0WCArIHRoaXMuY3V0SGVpZ2h0KSAvIHR3O1xyXG4gICAgICAgIHV2cy55MCA9IHRoaXMuY3V0WSAvIHRoO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNsb25lID0gbmV3IEZyYW1lKHRoaXMudGV4dHVyZSwgdGhpcy5uYW1lLCB0aGlzLnNvdXJjZUluZGV4KTtcclxuXHJcbiAgICAgICAgY2xvbmUuY3V0WCA9IHRoaXMuY3V0WDtcclxuICAgICAgICBjbG9uZS5jdXRZID0gdGhpcy5jdXRZO1xyXG4gICAgICAgIGNsb25lLmN1dFdpZHRoID0gdGhpcy5jdXRXaWR0aDtcclxuICAgICAgICBjbG9uZS5jdXRIZWlnaHQgPSB0aGlzLmN1dEhlaWdodDtcclxuXHJcbiAgICAgICAgY2xvbmUueCA9IHRoaXMueDtcclxuICAgICAgICBjbG9uZS55ID0gdGhpcy55O1xyXG4gICAgICAgIGNsb25lLndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICBjbG9uZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICAgICAgY2xvbmUucm90YXRlZCA9IHRoaXMucm90YXRlZDtcclxuXHJcbiAgICAgICAgY2xvbmUuZGF0YSA9IEV4dGVuZCh0cnVlLCBjbG9uZS5kYXRhLCB0aGlzLmRhdGEpO1xyXG5cclxuICAgICAgICBjbG9uZS51cGRhdGVVVnMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZyYW1lLnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgd2lkdGggb2YgdGhlIEZyYW1lIGluIGl0cyB1bi10cmltbWVkLCB1bi1wYWRkZWQgc3RhdGUsIGFzIHByZXBhcmVkIGluIHRoZSBhcnQgcGFja2FnZSxcclxuICAgICogYmVmb3JlIGJlaW5nIHBhY2tlZC5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSNyZWFsV2lkdGhcclxuICAgICogQHByb3BlcnR5IHthbnl9IHJlYWxXaWR0aFxyXG4gICAgKi9cclxuICAgIHJlYWxXaWR0aDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZVNpemUudztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGhlaWdodCBvZiB0aGUgRnJhbWUgaW4gaXRzIHVuLXRyaW1tZWQsIHVuLXBhZGRlZCBzdGF0ZSwgYXMgcHJlcGFyZWQgaW4gdGhlIGFydCBwYWNrYWdlLFxyXG4gICAgKiBiZWZvcmUgYmVpbmcgcGFja2VkLlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI3JlYWxIZWlnaHRcclxuICAgICogQHByb3BlcnR5IHthbnl9IHJlYWxIZWlnaHRcclxuICAgICovXHJcbiAgICByZWFsSGVpZ2h0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlU2l6ZS5oO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBVVnNcclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSN1dnNcclxuICAgICogQHByb3BlcnR5IHtPYmplY3R9IHV2c1xyXG4gICAgKi9cclxuICAgIHV2czoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnV2cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQ2FudmFzIERyYXcgSW1hZ2UgZGF0YVxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI2NhbnZhc0RhdGFcclxuICAgICogQHByb3BlcnR5IHtPYmplY3R9IGNhbnZhc0RhdGFcclxuICAgICovXHJcbiAgICBjYW52YXNEYXRhOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuZHJhd0ltYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL0ZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvRnJhbWUuanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgRnJhbWUgPSByZXF1aXJlKCcuL0ZyYW1lJyk7XHJcbnZhciBUZXh0dXJlU291cmNlID0gcmVxdWlyZSgnLi9UZXh0dXJlU291cmNlJyk7XHJcblxyXG4vKipcclxuKiBBIFRleHR1cmUgY29uc2lzdHMgb2YgYSBzb3VyY2UsIHVzdWFsbHkgYW4gSW1hZ2UgZnJvbSB0aGUgQ2FjaGUsIG9yIGEgQ2FudmFzLCBhbmQgYSBjb2xsZWN0aW9uXHJcbiogb2YgRnJhbWVzLiBUaGUgRnJhbWVzIHJlcHJlc2VudCB0aGUgZGlmZmVyZW50IGFyZWFzIG9mIHRoZSBUZXh0dXJlLiBGb3IgZXhhbXBsZSBhIHRleHR1cmUgYXRsYXNcclxuKiBtYXkgaGF2ZSBtYW55IEZyYW1lcywgb25lIGZvciBlYWNoIGVsZW1lbnQgd2l0aGluIHRoZSBhdGxhcy4gV2hlcmUtYXMgYSBzaW5nbGUgaW1hZ2Ugd291bGQgaGF2ZVxyXG4qIGp1c3Qgb25lIGZyYW1lLCB0aGF0IGVuY29tcGFzc2VzIHRoZSB3aG9sZSBpbWFnZS5cclxuKlxyXG4qIFRleHR1cmVzIGFyZSBtYW5hZ2VkIGJ5IHRoZSBnbG9iYWwgVGV4dHVyZU1hbmFnZXIuIFRoaXMgaXMgYSBzaW5nbGV0b24gY2xhc3MgdGhhdCBpc1xyXG4qIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgZGVsaXZlcmluZyBUZXh0dXJlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBGcmFtZXMgdG8gR2FtZSBPYmplY3RzLlxyXG4qXHJcbiogU3ByaXRlcyBhbmQgb3RoZXIgR2FtZSBPYmplY3RzIGdldCB0aGUgdGV4dHVyZSBkYXRhIHRoZXkgbmVlZCBmcm9tIHRoZSBUZXh0dXJlTWFuYWdlci5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcclxuKiBAcGFyYW0ge251bWJlcn0gc2NhbGVNb2RlXHJcbiovXHJcbnZhciBUZXh0dXJlID0gZnVuY3Rpb24gKG1hbmFnZXIsIGtleSwgc291cmNlKVxyXG57XHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2UpKVxyXG4gICAge1xyXG4gICAgICAgIHNvdXJjZSA9IFsgc291cmNlIF07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5rZXkgPSBrZXk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBzb3VyY2UgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZS5cclxuICAgICogVXN1YWxseSBhbiBJbWFnZSwgYnV0IGNhbiBhbHNvIGJlIGEgQ2FudmFzLlxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkgc291cmNlXHJcbiAgICAqIEB0eXBlIGFycmF5XHJcbiAgICAqL1xyXG4gICAgdGhpcy5zb3VyY2UgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IGZyYW1lcyAtIEZyYW1lc1xyXG4gICAgKi9cclxuICAgIHRoaXMuZnJhbWVzID0ge307XHJcblxyXG4gICAgdGhpcy5mcmFtZVRvdGFsID0gMDtcclxuXHJcbiAgICAvLyAgTG9hZCB0aGUgU291cmNlc1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UucHVzaChuZXcgVGV4dHVyZVNvdXJjZSh0aGlzLCBzb3VyY2VbaV0pKTtcclxuICAgIH1cclxufTtcclxuXHJcblRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dHVyZTtcclxuXHJcblRleHR1cmUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKG5hbWUsIHNvdXJjZUluZGV4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmcmFtZSA9IG5ldyBGcmFtZSh0aGlzLCBuYW1lLCBzb3VyY2VJbmRleCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVzW25hbWVdID0gZnJhbWU7XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVUb3RhbCsrO1xyXG5cclxuICAgICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKG5hbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCBuYW1lID09PSBudWxsIHx8IHRoaXMuZnJhbWVUb3RhbCA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWUgPSAnX19CQVNFJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVzW25hbWVdO1xyXG5cclxuICAgICAgICBpZiAoIWZyYW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyBUZXh0dXJlLmZyYW1lIGZvdW5kIHdpdGggbmFtZSAnICsgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXNbJ19fQkFTRSddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUZXh0dXJlSW5kZXg6IGZ1bmN0aW9uIChpbmRleClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc291cmNlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VbaV0uZ2xUZXh0dXJlSW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc291cmNlW2ldLmltYWdlLmN1cnJlbnRTcmMsICdpbmRleCA9ICcsIGluZGV4KTtcclxuXHJcbiAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBEZXN0cm95cyB0aGlzIGJhc2UgdGV4dHVyZVxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIGRlc3Ryb3lcclxuICAgICovXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBOZWVkIHRvIGl0ZXJhdGUgdGhvdWdoIHRoZSBUZXh0dXJlU291cmNlcywgYW5kIHVubG9hZCBlYWNoIG9uZVxyXG4gICAgICAgIC8vICB0aGVuIGNsZWFyIG91dCB0aGUgZnJhbWVzXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUGhhc2VyLkNhbnZhc1Bvb2wucmVtb3ZlQnlDYW52YXModGhpcy5zb3VyY2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBudWxsO1xyXG4gICAgICAgICovXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGJhc2UgdGV4dHVyZSBmcm9tIHRoZSBnaXZlbiBjYW52YXMgZWxlbWVudC5cclxuKlxyXG4qIEBzdGF0aWNcclxuKiBAbWV0aG9kIGZyb21DYW52YXNcclxuKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCBzb3VyY2Ugb2YgdGhlIHRleHR1cmVcclxuKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNlZSB7eyNjcm9zc0xpbmsgXCJQSVhJL3NjYWxlTW9kZXM6cHJvcGVydHlcIn19UGhhc2VyLnNjYWxlTW9kZXN7ey9jcm9zc0xpbmt9fSBmb3IgcG9zc2libGUgdmFsdWVzXHJcbiogQHJldHVybiB7QmFzZVRleHR1cmV9XHJcblBoYXNlci5UZXh0dXJlLmZyb21DYW52YXMgPSBmdW5jdGlvbiAoY2FudmFzLCBzY2FsZU1vZGUpXHJcbntcclxuICAgIGlmIChjYW52YXMud2lkdGggPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FudmFzLmhlaWdodCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFBoYXNlci5UZXh0dXJlKGNhbnZhcywgc2NhbGVNb2RlKTtcclxufTtcclxuKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvVGV4dHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gMzMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RleHR1cmVzL1RleHR1cmUuanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXJzJyk7XHJcbnZhciBUZXh0dXJlID0gcmVxdWlyZSgnLi9UZXh0dXJlJyk7XHJcblxyXG4vKipcclxuKiBUZXh0dXJlcyBhcmUgbWFuYWdlZCBieSB0aGUgZ2xvYmFsIFRleHR1cmVNYW5hZ2VyLiBUaGlzIGlzIGEgc2luZ2xldG9uIGNsYXNzIHRoYXQgaXNcclxuKiByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIGRlbGl2ZXJpbmcgVGV4dHVyZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgRnJhbWVzIHRvIEdhbWUgT2JqZWN0cy5cclxuKlxyXG4qIFNwcml0ZXMgYW5kIG90aGVyIEdhbWUgT2JqZWN0cyBnZXQgdGhlIHRleHR1cmUgZGF0YSB0aGV5IG5lZWQgZnJvbSB0aGUgVGV4dHVyZU1hbmFnZXIuXHJcbipcclxuKiBBY2Nlc3MgaXQgdmlhIGBzdGF0ZS50ZXh0dXJlc2AuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVNYW5hZ2VyXHJcbiogQGNvbnN0cnVjdG9yXHJcbiovXHJcbnZhciBUZXh0dXJlTWFuYWdlciA9IGZ1bmN0aW9uIChnYW1lKVxyXG57XHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG5cclxuICAgIHRoaXMubGlzdCA9IHt9O1xyXG59O1xyXG5cclxuVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dHVyZU1hbmFnZXI7XHJcblxyXG5UZXh0dXJlTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkSW1hZ2U6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuICAgICAgICBcclxuICAgICAgICBQYXJzZXIuSW1hZ2UodGV4dHVyZSwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRDYW52YXM6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuICAgICAgICBcclxuICAgICAgICBQYXJzZXIuQ2FudmFzKHRleHR1cmUsIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXRsYXM6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICAvLyAgSXMgaXQgYSBIYXNoIG9yIGFuIEFycmF5P1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmZyYW1lcykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBdGxhc0pTT05BcnJheShrZXksIHNvdXJjZSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEF0bGFzSlNPTkhhc2goa2V5LCBzb3VyY2UsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXRsYXNKU09OQXJyYXk6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5KU09OQXJyYXkodGV4dHVyZSwgaSwgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUGFyc2VyLkpTT05BcnJheSh0ZXh0dXJlLCAwLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRBdGxhc0pTT05IYXNoOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQYXJzZXIuSlNPTkhhc2godGV4dHVyZSwgaSwgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUGFyc2VyLkpTT05IYXNoKHRleHR1cmUsIDAsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFNwcml0ZVNoZWV0OiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgbWFyZ2luLCBzcGFjaW5nKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xyXG5cclxuICAgICAgICB2YXIgd2lkdGggPSB0ZXh0dXJlLnNvdXJjZVswXS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGV4dHVyZS5zb3VyY2VbMF0uaGVpZ2h0O1xyXG5cclxuICAgICAgICBQYXJzZXIuU3ByaXRlU2hlZXQodGV4dHVyZSwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBtYXJnaW4sIHNwYWNpbmcpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkU3ByaXRlU2hlZXRGcm9tQXRsYXM6IGZ1bmN0aW9uIChrZXksIGF0bGFzS2V5LCBhdGxhc0ZyYW1lLCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIG1hcmdpbiwgc3BhY2luZylcclxuICAgIHtcclxuICAgICAgICB2YXIgYXRsYXMgPSB0aGlzLmdldChhdGxhc0tleSk7XHJcbiAgICAgICAgdmFyIHNoZWV0ID0gYXRsYXMuZ2V0KGF0bGFzRnJhbWUpO1xyXG5cclxuICAgICAgICBpZiAoc2hlZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc2hlZXQuc291cmNlLmltYWdlKTtcclxuXHJcbiAgICAgICAgICAgIFBhcnNlci5TcHJpdGVTaGVldCh0ZXh0dXJlLCAwLCBzaGVldC5jdXRYLCBzaGVldC5jdXRZLCBzaGVldC5jdXRXaWR0aCwgc2hlZXQuY3V0SGVpZ2h0LCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIG1hcmdpbiwgc3BhY2luZyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEF0bGFzU3RhcmxpbmdYTUw6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5TdGFybGluZ1hNTCh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQYXJzZXIuU3RhcmxpbmdYTUwodGV4dHVyZSwgMCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXRsYXNQeXhlbDogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUGFyc2VyLlB5eGVsKHRleHR1cmUsIGksIGRhdGFbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBhcnNlci5QeXhlbCh0ZXh0dXJlLCAwLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMsIGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0W2tleV0gPSB0ZXh0dXJlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgZXhpc3RzOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5saXN0Lmhhc093blByb3BlcnR5KGtleSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7IGtleSA9ICdfX0RFRkFVTFQnOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFsnX19NSVNTSU5HJ107XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZUZyYW1lOiBmdW5jdGlvbiAoa2V5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0W2tleV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W2tleV0uZ2V0KGZyYW1lKS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RnJhbWU6IGZ1bmN0aW9uIChrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XS5nZXQoZnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dHVyZTogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2FtZU9iamVjdC50ZXh0dXJlID0gdGhpcy5saXN0W2tleV07XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QuZnJhbWUgPSBnYW1lT2JqZWN0LnRleHR1cmUuZ2V0KGZyYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUGFzc2VzIGFsbCBUZXh0dXJlcyB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgZWFjaFxyXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgICogQHBhcmFtIHsuLi4qfSBbYXJndW1lbnRzXSAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBhZnRlciB0aGUgY2hpbGQuXHJcbiAgICAqL1xyXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhcmdzID0gWyBudWxsIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciB0ZXh0dXJlIGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB0aGlzLmxpc3RbdGV4dHVyZV07XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvVGV4dHVyZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlci5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvU2NhbGVNb2RlcycpO1xyXG52YXIgSXNTaXplUG93ZXJPZlR3byA9IHJlcXVpcmUoJy4uL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvJyk7XHJcbnZhciBDcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdGV4dHVyZS9DcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlJyk7XHJcblxyXG4vKipcclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVNvdXJjZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcclxuKiBAcGFyYW0ge251bWJlcn0gc2NhbGVNb2RlXHJcbiovXHJcbnZhciBUZXh0dXJlU291cmNlID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZSlcclxue1xyXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuXHJcbiAgICB0aGlzLmltYWdlID0gc291cmNlO1xyXG5cclxuICAgIHRoaXMuY29tcHJlc3Npb25BbGdvcml0aG0gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgUmVzb2x1dGlvbiBvZiB0aGUgdGV4dHVyZS5cclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHJlc29sdXRpb25cclxuICAgICogQHR5cGUgTnVtYmVyXHJcbiAgICAqL1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZS5cclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHdpZHRoXHJcbiAgICAqIEB0eXBlIE51bWJlclxyXG4gICAgKiBAcmVhZE9ubHlcclxuICAgICovXHJcbiAgICB0aGlzLndpZHRoID0gc291cmNlLm5hdHVyYWxXaWR0aCB8fCBzb3VyY2Uud2lkdGggfHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGV4dHVyZS5cclxuICAgICpcclxuICAgICogQHByb3BlcnR5IGhlaWdodFxyXG4gICAgKiBAdHlwZSBOdW1iZXJcclxuICAgICogQHJlYWRPbmx5XHJcbiAgICAqL1xyXG4gICAgdGhpcy5oZWlnaHQgPSBzb3VyY2UubmF0dXJhbEhlaWdodCB8fCBzb3VyY2UuaGVpZ2h0IHx8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBzY2FsZSBtb2RlIHRvIGFwcGx5IHdoZW4gc2NhbGluZyB0aGlzIHRleHR1cmUuXHJcbiAgICAqIE5FQVJFU1Qgb3IgREVGQVVMVFxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkgc2NhbGVNb2RlXHJcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAqIEBkZWZhdWx0IFBoYXNlci5zY2FsZU1vZGVzLkRFRkFVTFQ7XHJcbiAgICAqL1xyXG4gICAgdGhpcy5zY2FsZU1vZGUgPSBTY2FsZU1vZGVzLkRFRkFVTFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENvbnRyb2xzIGlmIFJHQiBjaGFubmVscyBzaG91bGQgYmUgcHJlLW11bHRpcGxpZWQgYnkgQWxwaGEgIChXZWJHTCBvbmx5KVxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkgcHJlbXVsdGlwbGllZEFscGhhXHJcbiAgICAqIEB0eXBlIEJvb2xlYW5cclxuICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgKi9cclxuICAgIHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiBhIG1pcG1hcCBvZiB0aGlzIHRleHR1cmUgbmVlZHMgdG8gYmUgZ2VuZXJhdGVkLiBUaGlzIHZhbHVlIG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgdGhlIHRleHR1cmUgaXMgdXNlZFxyXG4gICAgKiBBbHNvIHRoZSB0ZXh0dXJlIG11c3QgYmUgYSBwb3dlciBvZiB0d28gc2l6ZSB0byB3b3JrXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSBtaXBtYXBMZXZlbFxyXG4gICAgKiBAdHlwZSB7aW50ZWdlcn1cclxuICAgICovXHJcbiAgICB0aGlzLm1pcG1hcExldmVsID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQSBCYXNlVGV4dHVyZSBjYW4gYmUgc2V0IHRvIHNraXAgdGhlIHJlbmRlcmluZyBwaGFzZSBpbiB0aGUgV2ViR0wgU3ByaXRlIEJhdGNoLlxyXG4gICAgKlxyXG4gICAgKiBZb3UgbWF5IHdhbnQgdG8gZG8gdGhpcyBpZiB5b3UgaGF2ZSBhIHBhcmVudCBTcHJpdGUgd2l0aCBubyB2aXNpYmxlIHRleHR1cmUgKGkuZS4gdXNlcyB0aGUgaW50ZXJuYWwgYF9fZGVmYXVsdGAgdGV4dHVyZSlcclxuICAgICogdGhhdCBoYXMgY2hpbGRyZW4gdGhhdCB5b3UgZG8gd2FudCB0byByZW5kZXIsIHdpdGhvdXQgY2F1c2luZyBhIGJhdGNoIGZsdXNoIGluIHRoZSBwcm9jZXNzLlxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkgcmVuZGVyYWJsZVxyXG4gICAgKiBAdHlwZSBCb29sZWFuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IGlzUG93ZXJPZjJcclxuICAgICogQHR5cGUgYm9vbGVhblxyXG4gICAgKi9cclxuICAgIHRoaXMuaXNQb3dlck9mMiA9IElzU2l6ZVBvd2VyT2ZUd28odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkgZ2xUZXh0dXJlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5nbFRleHR1cmUgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgbXVsdGkgdGV4dHVyZSBiYXRjaGluZyBpbmRleCBudW1iZXIuXHJcbiAgICAqIEBwcm9wZXJ0eSBnbFRleHR1cmVJbmRleFxyXG4gICAgKiBAdHlwZSBOdW1iZXJcclxuICAgICovXHJcbiAgICB0aGlzLmdsVGV4dHVyZUluZGV4ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIHRpbWVzdGFtcCB3aGVuIHRoaXMgdGV4dHVyZSB3YXMgbGFzdCB1c2VkIGJ5IHRoZSBXZWJHTCByZW5kZXJlci5cclxuICAgICogQ2FuIGJlIHVzZWQgdG8gcHVyZ2Ugb3V0ICdkZWFkJyB0ZXh0dXJlcyBmcm9tIEdQVSBtZW1vcnkuXHJcbiAgICAqIEBwcm9wZXJ0eSBnbExhc3RVc2VkXHJcbiAgICAqIEB0eXBlIE51bWJlclxyXG4gICAgKi9cclxuICAgIHRoaXMuZ2xMYXN0VXNlZCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSBnbERpcnR5XHJcbiAgICAqL1xyXG4gICAgdGhpcy5nbERpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgZ2FtZSA9IHRleHR1cmUubWFuYWdlci5nYW1lO1xyXG5cclxuICAgIGlmIChnYW1lLmNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5XRUJHTClcclxuICAgIHtcclxuICAgICAgICBDcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlKGdhbWUucmVuZGVyZXIuZ2wsIHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlU291cmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9UZXh0dXJlU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvVGV4dHVyZVNvdXJjZS5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlIGEgU3ByaXRlIFNoZWV0IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkltYWdlXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIEZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZSB0aGF0IHRoZSBTcHJpdGUgU2hlZXQgaXMgc3RvcmVkIGluLlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgQ2FudmFzVGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2VJbmRleClcclxue1xyXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuXHJcbiAgICB0ZXh0dXJlLmFkZCgnX19CQVNFJywgc291cmNlSW5kZXgsIDAsIDAsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1RleHR1cmVQYXJzZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvQ2FudmFzVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMzM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlIGEgU3ByaXRlIFNoZWV0IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkltYWdlXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIEZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZSB0aGF0IHRoZSBTcHJpdGUgU2hlZXQgaXMgc3RvcmVkIGluLlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgSW1hZ2VUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4KVxyXG57XHJcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xyXG5cclxuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VUZXh0dXJlUGFyc2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL0ltYWdlVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMzM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlcyBhIEpTT04gQXJyYXkgYW5kIGV4dHJhY3RzIHRoZSBmcmFtZSBkYXRhIGZyb20gaXQuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVQYXJzZXIuSlNPTkFycmF5XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUgSlNPTiBkYXRhIGZyb20gdGhlIFRleHR1cmUgQXRsYXMuIE11c3QgYmUgaW4gQXJyYXkgZm9ybWF0LlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgSlNPTkFycmF5VGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2VJbmRleCwganNvbilcclxue1xyXG4gICAgLy8gIE1hbGZvcm1lZD9cclxuICAgIGlmICghanNvblsnZnJhbWVzJ10pXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIFRleHR1cmUgQXRsYXMgSlNPTiBBcnJheSBnaXZlbiwgbWlzc2luZyBcXCdmcmFtZXNcXCcgYXJyYXknKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFkZCBpbiBhIF9fQkFTRSBlbnRyeSAoZm9yIHRoZSBlbnRpcmUgYXRsYXMpXHJcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xyXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG5cclxuICAgIC8vICBCeSB0aGlzIHN0YWdlIGZyYW1lcyBpcyBhIGZ1bGx5IHBhcnNlZCBhcnJheVxyXG4gICAgdmFyIGZyYW1lcyA9IGpzb25bJ2ZyYW1lcyddO1xyXG4gICAgdmFyIG5ld0ZyYW1lO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzcmMgPSBmcmFtZXNbaV07XHJcblxyXG4gICAgICAgIC8vICBUaGUgZnJhbWUgdmFsdWVzIGFyZSB0aGUgZXhhY3QgY29vcmRpbmF0ZXMgdG8gY3V0IHRoZSBmcmFtZSBvdXQgb2YgdGhlIGF0bGFzIGZyb21cclxuICAgICAgICBuZXdGcmFtZSA9IHRleHR1cmUuYWRkKHNyYy5maWxlbmFtZSwgc291cmNlSW5kZXgsIHNyYy5mcmFtZS54LCBzcmMuZnJhbWUueSwgc3JjLmZyYW1lLncsIHNyYy5mcmFtZS5oKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZXNlIGFyZSB0aGUgb3JpZ2luYWwgKG5vbi10cmltbWVkKSBzcHJpdGUgdmFsdWVzXHJcbiAgICAgICAgaWYgKHNyYy50cmltbWVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUuc2V0VHJpbShcclxuICAgICAgICAgICAgICAgIHNyYy5zb3VyY2VTaXplLncsXHJcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS5oLFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueCxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLnksXHJcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS53LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUuaFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNyYy5yb3RhdGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUucm90YXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnVwZGF0ZVVWc0ludmVydGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKU09OQXJyYXlUZXh0dXJlUGFyc2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL0pTT05BcnJheVRleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBQYXJzZXMgYSBKU09OIEFycmF5IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkpTT05BcnJheVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIEpTT04gZGF0YSBmcm9tIHRoZSBUZXh0dXJlIEF0bGFzLiBNdXN0IGJlIGluIEpTT04gSGFzaCBmb3JtYXQuXHJcbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXHJcbiovXHJcbnZhciBKU09OSGFzaFRleHR1cmVQYXJzZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIGpzb24pXHJcbntcclxuICAgIC8vICBNYWxmb3JtZWQ/XHJcbiAgICBpZiAoIWpzb25bJ2ZyYW1lcyddKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBUZXh0dXJlIEF0bGFzIEpTT04gSGFzaCBnaXZlbiwgbWlzc2luZyBcXCdmcmFtZXNcXCcgT2JqZWN0Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBZGQgaW4gYSBfX0JBU0UgZW50cnkgKGZvciB0aGUgZW50aXJlIGF0bGFzKVxyXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuXHJcbiAgICAvLyAgQnkgdGhpcyBzdGFnZSBmcmFtZXMgaXMgYSBmdWxseSBwYXJzZWQgT2JqZWN0XHJcbiAgICB2YXIgZnJhbWVzID0ganNvblsnZnJhbWVzJ107XHJcbiAgICB2YXIgbmV3RnJhbWU7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIGZyYW1lcylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3JjID0gZnJhbWVzW2tleV07XHJcblxyXG4gICAgICAgIC8vICBUaGUgZnJhbWUgdmFsdWVzIGFyZSB0aGUgZXhhY3QgY29vcmRpbmF0ZXMgdG8gY3V0IHRoZSBmcmFtZSBvdXQgb2YgdGhlIGF0bGFzIGZyb21cclxuICAgICAgICBuZXdGcmFtZSA9IHRleHR1cmUuYWRkKGtleSwgc291cmNlSW5kZXgsIHNyYy5mcmFtZS54LCBzcmMuZnJhbWUueSwgc3JjLmZyYW1lLncsIHNyYy5mcmFtZS5oKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZXNlIGFyZSB0aGUgb3JpZ2luYWwgKG5vbi10cmltbWVkKSBzcHJpdGUgdmFsdWVzXHJcbiAgICAgICAgaWYgKHNyYy50cmltbWVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUuc2V0VHJpbShcclxuICAgICAgICAgICAgICAgIHNyYy5zb3VyY2VTaXplLncsXHJcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS5oLFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueCxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLnksXHJcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS53LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUuaFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNyYy5yb3RhdGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUucm90YXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnVwZGF0ZVVWc0ludmVydGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKU09OSGFzaFRleHR1cmVQYXJzZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvSlNPTkhhc2hUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogUGFyc2VzIGEgUHl4ZWwgSlNPTiBGaWxlIGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkpTT05BcnJheVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIEpTT04gZGF0YSBmcm9tIHRoZSBUZXh0dXJlIEF0bGFzLiBNdXN0IGJlIGluIFB5eGVsIEpTT04gZm9ybWF0LlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgUHl4ZWxUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIGpzb24pXHJcbntcclxuICAgIC8vICBNYWxmb3JtZWQ/IFRoZXJlIGFyZSBhIGZldyBrZXlzIHRvIGNoZWNrIGhlcmUuXHJcbiAgICB2YXIgc2lnbmF0dXJlID0gWyAnbGF5ZXJzJywgJ3RpbGV3aWR0aCcsICd0aWxlaGVpZ2h0JywgJ3RpbGVzd2lkZScsICd0aWxlc2hpZ2gnIF07XHJcblxyXG4gICAgc2lnbmF0dXJlLmZvckVhY2goZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIWpzb25ba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignUGhhc2VyLkFuaW1hdGlvblBhcnNlci5KU09ORGF0YVB5eGVsOiBJbnZhbGlkIFB5eGVsIFRpbGVtYXAgSlNPTiBnaXZlbiwgbWlzc2luZyBcIicgKyBrZXkgKyAnXCIga2V5LicpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhqc29uKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEZvciB0aGlzIHB1cnBvc2UsIEkgb25seSBjYXJlIGFib3V0IHBhcnNpbmcgdGlsZW1hcHMgd2l0aCBhIHNpbmdsZSBsYXllci5cclxuICAgIGlmIChqc29uWydsYXllcnMnXS5sZW5ndGggIT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdQaGFzZXIuQW5pbWF0aW9uUGFyc2VyLkpTT05EYXRhUHl4ZWw6IFRvbyBtYW55IGxheWVycywgdGhpcyBwYXJzZXIgb25seSBzdXBwb3J0cyBmbGF0IFRpbGVtYXBzLicpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGpzb24pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IG5ldyBQaGFzZXIuRnJhbWVEYXRhKCk7XHJcblxyXG4gICAgdmFyIHRpbGVoZWlnaHQgPSBqc29uWyd0aWxlaGVpZ2h0J107XHJcbiAgICB2YXIgdGlsZXdpZHRoID0ganNvblsndGlsZXdpZHRoJ107XHJcblxyXG4gICAgdmFyIGZyYW1lcyA9IGpzb25bJ2xheWVycyddWzBdWyd0aWxlcyddO1xyXG4gICAgdmFyIG5ld0ZyYW1lO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG5ld0ZyYW1lID0gZGF0YS5hZGRGcmFtZShuZXcgUGhhc2VyLkZyYW1lKFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBmcmFtZXNbaV0ueCxcclxuICAgICAgICAgICAgZnJhbWVzW2ldLnksXHJcbiAgICAgICAgICAgIHRpbGV3aWR0aCxcclxuICAgICAgICAgICAgdGlsZWhlaWdodCxcclxuICAgICAgICAgICAgXCJmcmFtZV9cIiArIGkgIC8vIE5vIG5hbWVzIGFyZSBpbmNsdWRlZCBpbiBweXhlbCB0aWxlbWFwIGRhdGEuXHJcbiAgICAgICAgKSk7XHJcblxyXG4gICAgICAgIC8vIE5vIHRyaW0gZGF0YSBpcyBpbmNsdWRlZC5cclxuICAgICAgICBuZXdGcmFtZS5zZXRUcmltKGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHl4ZWxUZXh0dXJlUGFyc2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL1B5eGVsVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMzM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlIGEgU3ByaXRlIFNoZWV0IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLlNwcml0ZVNoZWV0XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIEZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZSB0aGF0IHRoZSBTcHJpdGUgU2hlZXQgaXMgc3RvcmVkIGluLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBmcmFtZVdpZHRoIC0gVGhlIGZpeGVkIHdpZHRoIG9mIGVhY2ggZnJhbWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IGZyYW1lSGVpZ2h0IC0gVGhlIGZpeGVkIGhlaWdodCBvZiBlYWNoIGZyYW1lLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRGcmFtZT0wXSAtIFNraXAgYSBudW1iZXIgb2YgZnJhbWVzLiBVc2VmdWwgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgc3ByaXRlIHNoZWV0cyBpbiBvbmUgVGV4dHVyZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW2VuZEZyYW1lPS0xXSAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIHRvIGV4dHJhY3QgZnJvbSB0aGUgU3ByaXRlIFNoZWV0LiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiAtMSBtZWFucyBcImV4dHJhY3QgYWxsIGZyYW1lc1wiLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbbWFyZ2luPTBdIC0gSWYgdGhlIGZyYW1lcyBoYXZlIGJlZW4gZHJhd24gd2l0aCBhIG1hcmdpbiwgc3BlY2lmeSB0aGUgYW1vdW50IGhlcmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtzcGFjaW5nPTBdIC0gSWYgdGhlIGZyYW1lcyBoYXZlIGJlZW4gZHJhd24gd2l0aCBzcGFjaW5nIGJldHdlZW4gdGhlbSwgc3BlY2lmeSB0aGUgYW1vdW50IGhlcmUuXHJcbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXHJcbiovXHJcbnZhciBTcHJpdGVTaGVldFRleHR1cmVQYXJzZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgbWFyZ2luLCBzcGFjaW5nKVxyXG57XHJcbiAgICBpZiAoc3RhcnRGcmFtZSA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0RnJhbWUgPSAwOyB9XHJcbiAgICBpZiAoZW5kRnJhbWUgPT09IHVuZGVmaW5lZCkgeyBlbmRGcmFtZSA9IC0xOyB9XHJcbiAgICBpZiAobWFyZ2luID09PSB1bmRlZmluZWQpIHsgbWFyZ2luID0gMDsgfVxyXG4gICAgaWYgKHNwYWNpbmcgPT09IHVuZGVmaW5lZCkgeyBzcGFjaW5nID0gMDsgfVxyXG5cclxuICAgIHZhciByb3cgPSBNYXRoLmZsb29yKCh3aWR0aCAtIG1hcmdpbikgLyAoZnJhbWVXaWR0aCArIHNwYWNpbmcpKTtcclxuICAgIHZhciBjb2x1bW4gPSBNYXRoLmZsb29yKChoZWlnaHQgLSBtYXJnaW4pIC8gKGZyYW1lSGVpZ2h0ICsgc3BhY2luZykpO1xyXG4gICAgdmFyIHRvdGFsID0gcm93ICogY29sdW1uO1xyXG5cclxuICAgIGlmIChzdGFydEZyYW1lID4gdG90YWwgfHwgc3RhcnRGcmFtZSA8IC10b3RhbClcclxuICAgIHtcclxuICAgICAgICBzdGFydEZyYW1lID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhcnRGcmFtZSA8IDApXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEFsbG93IG5lZ2F0aXZlIHNraXBmcmFtZXMuXHJcbiAgICAgICAgc3RhcnRGcmFtZSA9IHRvdGFsICsgc3RhcnRGcmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZW5kRnJhbWUgIT09IC0xKVxyXG4gICAge1xyXG4gICAgICAgIHRvdGFsID0gc3RhcnRGcmFtZSArIChlbmRGcmFtZSArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmeCA9IG1hcmdpbjtcclxuICAgIHZhciBmeSA9IG1hcmdpbjtcclxuICAgIHZhciBheCA9IDA7XHJcbiAgICB2YXIgYXkgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcclxuICAgIHtcclxuICAgICAgICBheCA9IDA7XHJcbiAgICAgICAgYXkgPSAwO1xyXG5cclxuICAgICAgICB2YXIgdyA9IGZ4ICsgZnJhbWVXaWR0aDtcclxuICAgICAgICB2YXIgaCA9IGZ5ICsgZnJhbWVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh3ID4gd2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBheCA9IHcgLSB3aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoID4gaGVpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXkgPSBoIC0gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGV4dHVyZS5hZGQoaSwgc291cmNlSW5kZXgsIHggKyBmeCwgeSArIGZ5LCBmcmFtZVdpZHRoIC0gYXgsIGZyYW1lSGVpZ2h0IC0gYXkpO1xyXG5cclxuICAgICAgICBmeCArPSBmcmFtZVdpZHRoICsgc3BhY2luZztcclxuXHJcbiAgICAgICAgaWYgKGZ4ICsgZnJhbWVXaWR0aCA+IHdpZHRoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZnggPSBtYXJnaW47XHJcbiAgICAgICAgICAgIGZ5ICs9IGZyYW1lSGVpZ2h0ICsgc3BhY2luZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZVNoZWV0VGV4dHVyZVBhcnNlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9TcHJpdGVTaGVldFRleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBQYXJzZXMgdGhlIFhNTCBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5TdGFybGluZ1hNTFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7b2JqZWN0fSB4bWwgLSBUaGUgWE1MIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBTdGFybGluZyBYTUwgZm9ybWF0LlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgU3RhcmxpbmdYTUxUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHhtbClcclxue1xyXG4gICAgLy8gIE1hbGZvcm1lZD9cclxuICAgIGlmICgheG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdUZXh0dXJlQXRsYXMnKSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJQaGFzZXIuQW5pbWF0aW9uUGFyc2VyLlhNTERhdGE6IEludmFsaWQgVGV4dHVyZSBBdGxhcyBYTUwgZ2l2ZW4sIG1pc3NpbmcgPFRleHR1cmVBdGxhcz4gdGFnXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgTGV0J3MgY3JlYXRlIHNvbWUgZnJhbWVzIHRoZW5cclxuICAgIHZhciBkYXRhID0gbmV3IFBoYXNlci5GcmFtZURhdGEoKTtcclxuICAgIHZhciBmcmFtZXMgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1N1YlRleHR1cmUnKTtcclxuICAgIHZhciBuZXdGcmFtZTtcclxuXHJcbiAgICB2YXIgbmFtZTtcclxuICAgIHZhciBmcmFtZTtcclxuICAgIHZhciB4O1xyXG4gICAgdmFyIHk7XHJcbiAgICB2YXIgd2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0O1xyXG4gICAgdmFyIGZyYW1lWDtcclxuICAgIHZhciBmcmFtZVk7XHJcbiAgICB2YXIgZnJhbWVXaWR0aDtcclxuICAgIHZhciBmcmFtZUhlaWdodDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBmcmFtZSA9IGZyYW1lc1tpXS5hdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICBuYW1lID0gZnJhbWUubmFtZS52YWx1ZTtcclxuICAgICAgICB4ID0gcGFyc2VJbnQoZnJhbWUueC52YWx1ZSwgMTApO1xyXG4gICAgICAgIHkgPSBwYXJzZUludChmcmFtZS55LnZhbHVlLCAxMCk7XHJcbiAgICAgICAgd2lkdGggPSBwYXJzZUludChmcmFtZS53aWR0aC52YWx1ZSwgMTApO1xyXG4gICAgICAgIGhlaWdodCA9IHBhcnNlSW50KGZyYW1lLmhlaWdodC52YWx1ZSwgMTApO1xyXG5cclxuICAgICAgICBmcmFtZVggPSBudWxsO1xyXG4gICAgICAgIGZyYW1lWSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChmcmFtZS5mcmFtZVgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmcmFtZVggPSBNYXRoLmFicyhwYXJzZUludChmcmFtZS5mcmFtZVgudmFsdWUsIDEwKSk7XHJcbiAgICAgICAgICAgIGZyYW1lWSA9IE1hdGguYWJzKHBhcnNlSW50KGZyYW1lLmZyYW1lWS52YWx1ZSwgMTApKTtcclxuICAgICAgICAgICAgZnJhbWVXaWR0aCA9IHBhcnNlSW50KGZyYW1lLmZyYW1lV2lkdGgudmFsdWUsIDEwKTtcclxuICAgICAgICAgICAgZnJhbWVIZWlnaHQgPSBwYXJzZUludChmcmFtZS5mcmFtZUhlaWdodC52YWx1ZSwgMTApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmV3RnJhbWUgPSBkYXRhLmFkZEZyYW1lKG5ldyBQaGFzZXIuRnJhbWUoaSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgbmFtZSkpO1xyXG5cclxuICAgICAgICAvLyAgVHJpbW1lZD9cclxuICAgICAgICBpZiAoZnJhbWVYICE9PSBudWxsIHx8IGZyYW1lWSAhPT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnNldFRyaW0odHJ1ZSwgd2lkdGgsIGhlaWdodCwgZnJhbWVYLCBmcmFtZVksIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGFybGluZ1hNTFRleHR1cmVQYXJzZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvU3RhcmxpbmdYTUxUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQ2FudmFzOiByZXF1aXJlKCcuL0NhbnZhc1RleHR1cmVQYXJzZXInKSxcclxuICAgIEltYWdlOiByZXF1aXJlKCcuL0ltYWdlVGV4dHVyZVBhcnNlcicpLFxyXG4gICAgU3ByaXRlU2hlZXQ6IHJlcXVpcmUoJy4vU3ByaXRlU2hlZXRUZXh0dXJlUGFyc2VyJyksXHJcbiAgICBKU09OQXJyYXk6IHJlcXVpcmUoJy4vSlNPTkFycmF5VGV4dHVyZVBhcnNlcicpLFxyXG4gICAgSlNPTkhhc2g6IHJlcXVpcmUoJy4vSlNPTkhhc2hUZXh0dXJlUGFyc2VyJyksXHJcbiAgICBTdGFybGluZ1hNTDogcmVxdWlyZSgnLi9TdGFybGluZ1hNTFRleHR1cmVQYXJzZXInKSxcclxuICAgIFB5eGVsOiByZXF1aXJlKCcuL1B5eGVsVGV4dHVyZVBhcnNlcicpXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90ZXh0dXJlcy9wYXJzZXJzL2luZGV4LmpzIiwiLyoqXHJcbiogU25hcHMgYSB2YWx1ZSB0byB0aGUgbmVhcmVzdCB2YWx1ZSBpbiBhbiBhcnJheS5cclxuKiBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGluIHRoZSByYW5nZSBgW2ZpcnN0X3ZhbHVlLCBsYXN0X3ZhbHVlXWAuXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHNlYXJjaCB2YWx1ZVxyXG4qIEBwYXJhbSB7bnVtYmVyW119IGFyciAtIFRoZSBpbnB1dCBhcnJheSB3aGljaCBfbXVzdF8gYmUgc29ydGVkLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIG5lYXJlc3QgdmFsdWUgZm91bmQuXHJcbiovXHJcbnZhciBGaW5kQ2xvc2VzdEluU29ydGVkID0gZnVuY3Rpb24gKHZhbHVlLCBhcnJheSlcclxue1xyXG4gICAgaWYgKCFhcnJheS5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMSB8fCB2YWx1ZSA8IGFycmF5WzBdKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBhcnJheVswXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaSA9IDE7XHJcblxyXG4gICAgd2hpbGUgKGFycmF5W2ldIDwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsb3cgPSBhcnJheVtpIC0gMV07XHJcbiAgICB2YXIgaGlnaCA9IChpIDwgYXJyYXkubGVuZ3RoKSA/IGFycmF5W2ldIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cclxuICAgIHJldHVybiAoKGhpZ2ggLSB2YWx1ZSkgPD0gKHZhbHVlIC0gbG93KSkgPyBoaWdoIDogbG93O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaW5kQ2xvc2VzdEluU29ydGVkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9GaW5kQ2xvc2VzdEluU29ydGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogRmV0Y2ggYSByYW5kb20gZW50cnkgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkuXHJcbipcclxuKiBXaWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGFyZSBubyBhcnJheSBpdGVtcyB0aGF0IGZhbGwgd2l0aGluIHRoZSBzcGVjaWZpZWQgcmFuZ2VcclxuKiBvciBpZiB0aGVyZSBpcyBubyBpdGVtIGZvciB0aGUgcmFuZG9tbHkgY2hvc2VuIGluZGV4LlxyXG4qXHJcbiogQG1ldGhvZFxyXG4qIEBwYXJhbSB7YW55W119IG9iamVjdHMgLSBBbiBhcnJheSBvZiBvYmplY3RzLlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gc3RhcnRJbmRleCAtIE9wdGlvbmFsIG9mZnNldCBvZmYgdGhlIGZyb250IG9mIHRoZSBhcnJheS4gRGVmYXVsdCB2YWx1ZSBpcyAwLCBvciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCAtIE9wdGlvbmFsIHJlc3RyaWN0aW9uIG9uIHRoZSBudW1iZXIgb2YgdmFsdWVzIHlvdSB3YW50IHRvIHJhbmRvbWx5IHNlbGVjdCBmcm9tLlxyXG4qIEByZXR1cm4ge29iamVjdH0gVGhlIHJhbmRvbSBvYmplY3QgdGhhdCB3YXMgc2VsZWN0ZWQuXHJcbiovXHJcblxyXG52YXIgR2V0UmFuZG9tRWxlbWVudCA9IGZ1bmN0aW9uIChhcnJheSwgc3RhcnQsIGxlbmd0aClcclxue1xyXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XHJcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyB9XHJcblxyXG4gICAgdmFyIHJhbmRvbUluZGV4ID0gc3RhcnQgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW5ndGgpO1xyXG5cclxuICAgIHJldHVybiAoYXJyYXlbcmFuZG9tSW5kZXhdID09PSB1bmRlZmluZWQpID8gbnVsbCA6IGFycmF5W3JhbmRvbUluZGV4XTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UmFuZG9tRWxlbWVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvR2V0UmFuZG9tRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3VuZEF3YXlGcm9tWmVybyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvUm91bmRBd2F5RnJvbVplcm8nKTtcclxuXHJcbi8qKlxyXG4qIENyZWF0ZSBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb20gYHN0YXJ0YFxyXG4qIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGBlbmRgIGJ5IGFkdmFuY2luZyBieSBgc3RlcGAuXHJcbipcclxuKiBJZiBgc3RhcnRgIGlzIGxlc3MgdGhhbiBgZW5kYCBhIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cclxuKlxyXG4qIENlcnRhaW4gdmFsdWVzIGZvciBgc3RhcnRgIGFuZCBgZW5kYCAoZWcuIE5hTi91bmRlZmluZWQvbnVsbCkgYXJlIGN1cnJlbnRseSBjb2VyY2VkIHRvIDA7XHJcbiogZm9yIGZvcndhcmQgY29tcGF0aWJpbGl0eSBtYWtlIHN1cmUgdG8gcGFzcyBpbiBhY3R1YWwgbnVtYmVycy5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkFycmF5VXRpbHMjbnVtYmVyQXJyYXlTdGVwXHJcbiogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gLSBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gLSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cclxuKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBudW1iZXJzLlxyXG4qIEBleGFtcGxlXHJcbiogTnVtYmVyQXJyYXlTdGVwKDQpO1xyXG4qIC8vID0+IFswLCAxLCAyLCAzXVxyXG4qXHJcbiogTnVtYmVyQXJyYXlTdGVwKDEsIDUpO1xyXG4qIC8vID0+IFsxLCAyLCAzLCA0XVxyXG4qXHJcbiogTnVtYmVyQXJyYXlTdGVwKDAsIDIwLCA1KTtcclxuKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxyXG4qXHJcbiogTnVtYmVyQXJyYXlTdGVwKDAsIC00LCAtMSk7XHJcbiogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXHJcbipcclxuKiBOdW1iZXJBcnJheVN0ZXAoMSwgNCwgMCk7XHJcbiogLy8gPT4gWzEsIDEsIDFdXHJcbipcclxuKiBOdW1iZXJBcnJheVN0ZXAoMCk7XHJcbiogLy8gPT4gW11cclxuKi9cclxudmFyIE51bWJlckFycmF5U3RlcCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwKVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgeyBlbmQgPSBudWxsOyB9XHJcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXAgPSAxOyB9XHJcblxyXG4gICAgaWYgKGVuZCA9PT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICBlbmQgPSBzdGFydDtcclxuICAgICAgICBzdGFydCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIHZhciB0b3RhbCA9IE1hdGgubWF4KFJvdW5kQXdheUZyb21aZXJvKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcclxuICAgIHtcclxuICAgICAgICByZXN1bHQucHVzaChzdGFydCk7XHJcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJBcnJheVN0ZXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L051bWJlckFycmF5U3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMzQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FycmF5L051bWJlckFycmF5U3RlcC5qcyIsInZhciBTcGxpY2VPbmUgPSByZXF1aXJlKCcuL1NwbGljZU9uZScpO1xyXG5cclxuLyoqXHJcbiogUmVtb3ZlcyBhIHJhbmRvbSBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgYW5kIHJldHVybnMgaXQuXHJcbipcclxuKiBXaWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGFyZSBubyBhcnJheSBpdGVtcyB0aGF0IGZhbGwgd2l0aGluIHRoZSBzcGVjaWZpZWQgcmFuZ2VcclxuKiBvciBpZiB0aGVyZSBpcyBubyBpdGVtIGZvciB0aGUgcmFuZG9tbHkgY2hvc2VuIGluZGV4LlxyXG4qXHJcbiogQG1ldGhvZFxyXG4qIEBwYXJhbSB7YW55W119IG9iamVjdHMgLSBBbiBhcnJheSBvZiBvYmplY3RzLlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gc3RhcnRJbmRleCAtIE9wdGlvbmFsIG9mZnNldCBvZmYgdGhlIGZyb250IG9mIHRoZSBhcnJheS4gRGVmYXVsdCB2YWx1ZSBpcyAwLCBvciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCAtIE9wdGlvbmFsIHJlc3RyaWN0aW9uIG9uIHRoZSBudW1iZXIgb2YgdmFsdWVzIHlvdSB3YW50IHRvIHJhbmRvbWx5IHNlbGVjdCBmcm9tLlxyXG4qIEByZXR1cm4ge29iamVjdH0gVGhlIHJhbmRvbSBvYmplY3QgdGhhdCB3YXMgcmVtb3ZlZC5cclxuKi9cclxuXHJcbnZhciBSZW1vdmVSYW5kb21FbGVtZW50ID0gZnVuY3Rpb24gKGFycmF5LCBzdGFydCwgbGVuZ3RoKVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSBhcnJheS5sZW5ndGg7IH1cclxuXHJcbiAgICB2YXIgcmFuZG9tSW5kZXggPSBzdGFydCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCk7XHJcblxyXG4gICAgcmV0dXJuIFNwbGljZU9uZShhcnJheSwgcmFuZG9tSW5kZXgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVSYW5kb21FbGVtZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9SZW1vdmVSYW5kb21FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYXJyYXkvUmVtb3ZlUmFuZG9tRWxlbWVudC5qcyIsIi8qKlxyXG4qIE1vdmVzIHRoZSBlbGVtZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgYXJyYXkgdG8gdGhlIGVuZCwgc2hpZnRpbmcgYWxsIGl0ZW1zIGluIHRoZSBwcm9jZXNzLlxyXG4qIFRoZSBcInJvdGF0aW9uXCIgaGFwcGVucyB0byB0aGUgbGVmdC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkFycmF5VXRpbHMucm90YXRlXHJcbiogQHBhcmFtIHthbnlbXX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2hpZnQvcm90YXRlLiBUaGUgYXJyYXkgaXMgbW9kaWZpZWQuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWw9MV0gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHNoaWZ0IHRoZSBhcnJheS4gT25seSB0aGUgbW9zdCByZWNlbnRseSBzaGlmdGVkIGVsZW1lbnQgaXMgcmV0dXJuZWQuXHJcbiogQHJldHVybiB7YW55fSBUaGUgc2hpZnRlZCB2YWx1ZS5cclxuKi9cclxudmFyIFJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAoYXJyYXksIHRvdGFsKVxyXG57XHJcbiAgICBpZiAodG90YWwgPT09IHVuZGVmaW5lZCkgeyB0b3RhbCA9IDE7IH1cclxuXHJcbiAgICB2YXIgZWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGVsZW1lbnQgPSBhcnJheS5zaGlmdCgpO1xyXG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUxlZnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L1JvdGF0ZUxlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDM0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBNb3ZlcyB0aGUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byB0aGUgc3RhcnQsIHNoaWZ0aW5nIGFsbCBpdGVtcyBpbiB0aGUgcHJvY2Vzcy5cclxuKiBUaGUgXCJyb3RhdGlvblwiIGhhcHBlbnMgdG8gdGhlIHJpZ2h0LlxyXG4qXHJcbiogQHBhcmFtIHthbnlbXX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2hpZnQvcm90YXRlLiBUaGUgYXJyYXkgaXMgbW9kaWZpZWQuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWw9MV0gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHNoaWZ0IHRoZSBhcnJheS4gT25seSB0aGUgbW9zdCByZWNlbnRseSBzaGlmdGVkIGVsZW1lbnQgaXMgcmV0dXJuZWQuXHJcbiogQHJldHVybiB7YW55fSBUaGUgc2hpZnRlZCB2YWx1ZS5cclxuKi9cclxudmFyIFJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gKGFycmF5LCB0b3RhbClcclxue1xyXG4gICAgaWYgKHRvdGFsID09PSB1bmRlZmluZWQpIHsgdG90YWwgPSAxOyB9XHJcblxyXG4gICAgdmFyIGVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcclxuICAgIHtcclxuICAgICAgICBlbGVtZW50ID0gYXJyYXkucG9wKCk7XHJcbiAgICAgICAgYXJyYXkudW5zaGlmdChlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlUmlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L1JvdGF0ZVJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQSBzdGFuZGFyZCBGaXNoZXItWWF0ZXMgQXJyYXkgc2h1ZmZsZSBpbXBsZW1lbnRhdGlvbiB3aGljaCBtb2RpZmllcyB0aGUgYXJyYXkgaW4gcGxhY2UuXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHthbnlbXX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cclxuKiBAcmV0dXJuIHthbnlbXX0gVGhlIG9yaWdpbmFsIGFycmF5LCBub3cgc2h1ZmZsZWQuXHJcbiovXHJcbnZhciBTaHVmZmxlID0gZnVuY3Rpb24gKGFycmF5KVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xyXG4gICAgICAgIHZhciB0ZW1wID0gYXJyYXlbaV07XHJcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcclxuICAgICAgICBhcnJheVtqXSA9IHRlbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaHVmZmxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9TaHVmZmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGQ6L3dhbXAvd3d3L3BoYXNlci92My9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMzUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoYXNlci5qcyIsInJlcXVpcmUoJy4vcG9seWZpbGxzJyk7XHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBFeHRlbmQgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdC9FeHRlbmQnKTtcclxuXHJcbi8vICBUaGlzIG9iamVjdCBpcyBleHBvcnRlZCBnbG9iYWxseVxyXG5cclxudmFyIFBoYXNlciA9IHtcclxuXHJcbiAgICBHYW1lOiByZXF1aXJlKCcuL2Jvb3QvR2FtZScpLFxyXG5cclxuICAgIEV2ZW50OiByZXF1aXJlKCcuL2V2ZW50cy9FdmVudCcpLFxyXG4gICAgRXZlbnREaXNwYXRjaGVyOiByZXF1aXJlKCcuL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKSxcclxuXHJcbiAgICBNYXRoOiByZXF1aXJlKCcuL21hdGgnKSxcclxuXHJcbiAgICBHZW9tOiByZXF1aXJlKCcuL2dlb20nKSxcclxuXHJcbiAgICBHYW1lT2JqZWN0czoge1xyXG5cclxuICAgICAgICBGYWN0b3J5OiByZXF1aXJlKCcuL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgTG9hZGVyOiB7XHJcblxyXG4gICAgICAgIEltYWdlRmlsZTogcmVxdWlyZSgnLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZScpXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBTb3VuZDogcmVxdWlyZSgnLi9zb3VuZCcpLFxyXG5cclxuICAgIFV0aWxzOiB7XHJcblxyXG4gICAgICAgIEFycmF5OiByZXF1aXJlKCcuL3V0aWxzL2FycmF5LycpLFxyXG4gICAgICAgIE9iamVjdHM6IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0LycpXHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vICBSZXF1aXJlZCwgYnV0IGRvbid0IG5lZWQgUGhhc2VyIGxldmVsIGV4cG9ydHNcclxuXHJcbnJlcXVpcmUoJy4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyRmFjdG9yeScpO1xyXG5yZXF1aXJlKCcuL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlRmFjdG9yeScpO1xyXG5yZXF1aXJlKCcuL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJGYWN0b3J5Jyk7XHJcblxyXG4vLyAgIE1lcmdlIGluIHRoZSBjb25zdHNcclxuXHJcblBoYXNlciA9IEV4dGVuZChmYWxzZSwgUGhhc2VyLCBDT05TVCk7XHJcblxyXG4vLyAgRXhwb3J0IGl0XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBoYXNlcjtcclxuXHJcbmdsb2JhbC5QaGFzZXIgPSBQaGFzZXI7XHJcblxyXG4vKlxyXG4gKiDigJxTb21ldGltZXMsIHRoZSBlbGVnYW50IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgYSBmdW5jdGlvbi5cclxuICogTm90IGEgbWV0aG9kLiBOb3QgYSBjbGFzcy4gTm90IGEgZnJhbWV3b3JrLiBKdXN0IGEgZnVuY3Rpb24u4oCdXHJcbiAqIC0gSm9obiBDYXJtYWNrXHJcbiAqL1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waGFzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9