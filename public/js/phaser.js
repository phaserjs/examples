(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Phaser", [], factory);
	else if(typeof exports === 'object')
		exports["Phaser"] = factory();
	else
		root["Phaser"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 562);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

/**
* The `Matter.Common` module contains utility functions that are common to all modules.
*
* @class Common
*/

var Common = {};

module.exports = Common;

(function() {

    Common._nextId = 0;
    Common._seed = 0;

    /**
     * Extends the object in the first argument using the object in the second argument.
     * @method extend
     * @param {} obj
     * @param {boolean} deep
     * @return {} obj extended
     */
    Common.extend = function(obj, deep) {
        var argsStart,
            args,
            deepClone;

        if (typeof deep === 'boolean') {
            argsStart = 2;
            deepClone = deep;
        } else {
            argsStart = 1;
            deepClone = true;
        }

        for (var i = argsStart; i < arguments.length; i++) {
            var source = arguments[i];

            if (source) {
                for (var prop in source) {
                    if (deepClone && source[prop] && source[prop].constructor === Object) {
                        if (!obj[prop] || obj[prop].constructor === Object) {
                            obj[prop] = obj[prop] || {};
                            Common.extend(obj[prop], deepClone, source[prop]);
                        } else {
                            obj[prop] = source[prop];
                        }
                    } else {
                        obj[prop] = source[prop];
                    }
                }
            }
        }
        
        return obj;
    };

    /**
     * Creates a new clone of the object, if deep is true references will also be cloned.
     * @method clone
     * @param {} obj
     * @param {bool} deep
     * @return {} obj cloned
     */
    Common.clone = function(obj, deep) {
        return Common.extend({}, deep, obj);
    };

    /**
     * Returns the list of keys for the given object.
     * @method keys
     * @param {} obj
     * @return {string[]} keys
     */
    Common.keys = function(obj) {
        if (Object.keys)
            return Object.keys(obj);

        // avoid hasOwnProperty for performance
        var keys = [];
        for (var key in obj)
            keys.push(key);
        return keys;
    };

    /**
     * Returns the list of values for the given object.
     * @method values
     * @param {} obj
     * @return {array} Array of the objects property values
     */
    Common.values = function(obj) {
        var values = [];
        
        if (Object.keys) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                values.push(obj[keys[i]]);
            }
            return values;
        }
        
        // avoid hasOwnProperty for performance
        for (var key in obj)
            values.push(obj[key]);
        return values;
    };

    /**
     * Gets a value from `base` relative to the `path` string.
     * @method get
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} The object at the given path
     */
    Common.get = function(obj, path, begin, end) {
        path = path.split('.').slice(begin, end);

        for (var i = 0; i < path.length; i += 1) {
            obj = obj[path[i]];
        }

        return obj;
    };

    /**
     * Sets a value on `base` relative to the given `path` string.
     * @method set
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {} val The value to set
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} Pass through `val` for chaining
     */
    Common.set = function(obj, path, val, begin, end) {
        var parts = path.split('.').slice(begin, end);
        Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
        return val;
    };

    /**
     * Returns a hex colour string made by lightening or darkening color by percent.
     * @method shadeColor
     * @param {string} color
     * @param {number} percent
     * @return {string} A hex colour
     */
    Common.shadeColor = function(color, percent) {   
        // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color
        var colorInteger = parseInt(color.slice(1),16), 
            amount = Math.round(2.55 * percent), 
            R = (colorInteger >> 16) + amount, 
            B = (colorInteger >> 8 & 0x00FF) + amount, 
            G = (colorInteger & 0x0000FF) + amount;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R :255) * 0x10000 
                + (B < 255 ? B < 1 ? 0 : B : 255) * 0x100 
                + (G < 255 ? G < 1 ? 0 : G : 255)).toString(16).slice(1);
    };

    /**
     * Shuffles the given array in-place.
     * The function uses a seeded random generator.
     * @method shuffle
     * @param {array} array
     * @return {array} array shuffled randomly
     */
    Common.shuffle = function(array) {
        for (var i = array.length - 1; i > 0; i--) {
            var j = Math.floor(Common.random() * (i + 1));
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
        return array;
    };

    /**
     * Randomly chooses a value from a list with equal probability.
     * The function uses a seeded random generator.
     * @method choose
     * @param {array} choices
     * @return {object} A random choice object from the array
     */
    Common.choose = function(choices) {
        return choices[Math.floor(Common.random() * choices.length)];
    };

    /**
     * Returns true if the object is a HTMLElement, otherwise false.
     * @method isElement
     * @param {object} obj
     * @return {boolean} True if the object is a HTMLElement, otherwise false
     */
    Common.isElement = function(obj) {
        // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
        try {
            return obj instanceof HTMLElement;
        }
        catch(e){
            return (typeof obj==="object") &&
              (obj.nodeType===1) && (typeof obj.style === "object") &&
              (typeof obj.ownerDocument ==="object");
        }
    };

    /**
     * Returns true if the object is an array.
     * @method isArray
     * @param {object} obj
     * @return {boolean} True if the object is an array, otherwise false
     */
    Common.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };

    /**
     * Returns true if the object is a function.
     * @method isFunction
     * @param {object} obj
     * @return {boolean} True if the object is a function, otherwise false
     */
    Common.isFunction = function(obj) {
        return typeof obj === "function";
    };

    /**
     * Returns true if the object is a plain object.
     * @method isPlainObject
     * @param {object} obj
     * @return {boolean} True if the object is a plain object, otherwise false
     */
    Common.isPlainObject = function(obj) {
        return typeof obj === 'object' && obj.constructor === Object;
    };

    /**
     * Returns true if the object is a string.
     * @method isString
     * @param {object} obj
     * @return {boolean} True if the object is a string, otherwise false
     */
    Common.isString = function(obj) {
        return toString.call(obj) === '[object String]';
    };
    
    /**
     * Returns the given value clamped between a minimum and maximum value.
     * @method clamp
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @return {number} The value clamped between min and max inclusive
     */
    Common.clamp = function(value, min, max) {
        if (value < min)
            return min;
        if (value > max)
            return max;
        return value;
    };
    
    /**
     * Returns the sign of the given value.
     * @method sign
     * @param {number} value
     * @return {number} -1 if negative, +1 if 0 or positive
     */
    Common.sign = function(value) {
        return value < 0 ? -1 : 1;
    };
    
    /**
     * Returns the current timestamp (high-res if available).
     * @method now
     * @return {number} the current timestamp (high-res if available)
     */
    Common.now = function() {
        // http://stackoverflow.com/questions/221294/how-do-you-get-a-timestamp-in-javascript
        // https://gist.github.com/davidwaterston/2982531

        var performance = window.performance || {};

        performance.now = (function() {
            return performance.now    ||
            performance.webkitNow     ||
            performance.msNow         ||
            performance.oNow          ||
            performance.mozNow        ||
            function() { return +(new Date()); };
        })();
              
        return performance.now();
    };
    
    /**
     * Returns a random value between a minimum and a maximum value inclusive.
     * The function uses a seeded random generator.
     * @method random
     * @param {number} min
     * @param {number} max
     * @return {number} A random number between min and max inclusive
     */
    Common.random = function(min, max) {
        min = (typeof min !== "undefined") ? min : 0;
        max = (typeof max !== "undefined") ? max : 1;
        return min + _seededRandom() * (max - min);
    };

    var _seededRandom = function() {
        // https://gist.github.com/ngryman/3830489
        Common._seed = (Common._seed * 9301 + 49297) % 233280;
        return Common._seed / 233280;
    };

    /**
     * Converts a CSS hex colour string into an integer.
     * @method colorToNumber
     * @param {string} colorString
     * @return {number} An integer representing the CSS hex string
     */
    Common.colorToNumber = function(colorString) {
        colorString = colorString.replace('#','');

        if (colorString.length == 3) {
            colorString = colorString.charAt(0) + colorString.charAt(0)
                        + colorString.charAt(1) + colorString.charAt(1)
                        + colorString.charAt(2) + colorString.charAt(2);
        }

        return parseInt(colorString, 16);
    };

    /**
     * The console logging level to use, where each level includes all levels above and excludes the levels below.
     * The default level is 'debug' which shows all console messages.  
     *
     * Possible level values are:
     * - 0 = None
     * - 1 = Debug
     * - 2 = Info
     * - 3 = Warn
     * - 4 = Error
     * @property Common.logLevel
     * @type {Number}
     * @default 1
     */
    Common.logLevel = 1;

    /**
     * Shows a `console.log` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method log
     * @param ...objs {} The objects to log.
     */
    Common.log = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
            console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Shows a `console.info` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method info
     * @param ...objs {} The objects to log.
     */
    Common.info = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
            console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method warn
     * @param ...objs {} The objects to log.
     */
    Common.warn = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
            console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Returns the next unique sequential ID.
     * @method nextId
     * @return {Number} Unique sequential ID
     */
    Common.nextId = function() {
        return Common._nextId++;
    };

    /**
     * A cross browser compatible indexOf implementation.
     * @method indexOf
     * @param {array} haystack
     * @param {object} needle
     * @return {number} The position of needle in haystack, otherwise -1.
     */
    Common.indexOf = function(haystack, needle) {
        if (haystack.indexOf)
            return haystack.indexOf(needle);

        for (var i = 0; i < haystack.length; i++) {
            if (haystack[i] === needle)
                return i;
        }

        return -1;
    };

    /**
     * A cross browser compatible array map implementation.
     * @method map
     * @param {array} list
     * @param {function} func
     * @return {array} Values from list transformed by func.
     */
    Common.map = function(list, func) {
        if (list.map) {
            return list.map(func);
        }

        var mapped = [];

        for (var i = 0; i < list.length; i += 1) {
            mapped.push(func(list[i]));
        }

        return mapped;
    };

    /**
     * Takes a directed graph and returns the partially ordered set of vertices in topological order.
     * Circular dependencies are allowed.
     * @method topologicalSort
     * @param {object} graph
     * @return {array} Partially ordered set of vertices in topological order.
     */
    Common.topologicalSort = function(graph) {
        // https://mgechev.github.io/javascript-algorithms/graphs_others_topological-sort.js.html
        var result = [],
            visited = [],
            temp = [];

        for (var node in graph) {
            if (!visited[node] && !temp[node]) {
                _topologicalSort(node, visited, temp, graph, result);
            }
        }

        return result;
    };

    var _topologicalSort = function(node, visited, temp, graph, result) {
        var neighbors = graph[node] || [];
        temp[node] = true;

        for (var i = 0; i < neighbors.length; i += 1) {
            var neighbor = neighbors[i];

            if (temp[neighbor]) {
                // skip circular dependencies
                continue;
            }

            if (!visited[neighbor]) {
                _topologicalSort(neighbor, visited, temp, graph, result);
            }
        }

        temp[node] = false;
        visited[node] = true;

        result.push(node);
    };

    /**
     * Takes _n_ functions as arguments and returns a new function that calls them in order.
     * The arguments applied when calling the new function will also be applied to every function passed.
     * The value of `this` refers to the last value returned in the chain that was not `undefined`.
     * Therefore if a passed function does not return a value, the previously returned value is maintained.
     * After all passed functions have been called the new function returns the last returned value (if any).
     * If any of the passed functions are a chain, then the chain will be flattened.
     * @method chain
     * @param ...funcs {function} The functions to chain.
     * @return {function} A new function that calls the passed functions in order.
     */
    Common.chain = function() {
        var funcs = [];

        for (var i = 0; i < arguments.length; i += 1) {
            var func = arguments[i];

            if (func._chained) {
                // flatten already chained functions
                funcs.push.apply(funcs, func._chained);
            } else {
                funcs.push(func);
            }
        }

        var chain = function() {
            // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358
            var lastResult,
                args = new Array(arguments.length);

            for (var i = 0, l = arguments.length; i < l; i++) {
                args[i] = arguments[i];
            }

            for (i = 0; i < funcs.length; i += 1) {
                var result = funcs[i].apply(lastResult, args);

                if (typeof result !== 'undefined') {
                    lastResult = result;
                }
            }

            return lastResult;
        };

        chain._chained = funcs;

        return chain;
    };

    /**
     * Chains a function to excute before the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathBefore
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */
    Common.chainPathBefore = function(base, path, func) {
        return Common.set(base, path, Common.chain(
            func,
            Common.get(base, path)
        ));
    };

    /**
     * Chains a function to excute after the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathAfter
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */
    Common.chainPathAfter = function(base, path, func) {
        return Common.set(base, path, Common.chain(
            Common.get(base, path),
            func
        ));
    };

})();


/***/ },
/* 1 */
/***/ function(module, exports) {

var Point = function (x, y)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = x; }

    this.x = x;

    this.y = y;
};

Point.prototype.constructor = Point;

Point.prototype = {

    setTo: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    }

};

module.exports = Point;


/***/ },
/* 2 */
/***/ function(module, exports) {

var CONST = {

    VERSION: '3.0.0',

    AUTO: 0,
    CANVAS: 1,
    WEBGL: 2

};

module.exports = CONST;


/***/ },
/* 3 */
/***/ function(module, exports) {

/**
* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
*
* @class Bounds
*/

var Bounds = {};

module.exports = Bounds;

(function() {

    /**
     * Creates a new axis-aligned bounding box (AABB) for the given vertices.
     * @method create
     * @param {vertices} vertices
     * @return {bounds} A new bounds object
     */
    Bounds.create = function(vertices) {
        var bounds = { 
            min: { x: 0, y: 0 }, 
            max: { x: 0, y: 0 }
        };

        if (vertices)
            Bounds.update(bounds, vertices);
        
        return bounds;
    };

    /**
     * Updates bounds using the given vertices and extends the bounds given a velocity.
     * @method update
     * @param {bounds} bounds
     * @param {vertices} vertices
     * @param {vector} velocity
     */
    Bounds.update = function(bounds, vertices, velocity) {
        bounds.min.x = Infinity;
        bounds.max.x = -Infinity;
        bounds.min.y = Infinity;
        bounds.max.y = -Infinity;

        for (var i = 0; i < vertices.length; i++) {
            var vertex = vertices[i];
            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;
            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;
            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;
            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;
        }
        
        if (velocity) {
            if (velocity.x > 0) {
                bounds.max.x += velocity.x;
            } else {
                bounds.min.x += velocity.x;
            }
            
            if (velocity.y > 0) {
                bounds.max.y += velocity.y;
            } else {
                bounds.min.y += velocity.y;
            }
        }
    };

    /**
     * Returns true if the bounds contains the given point.
     * @method contains
     * @param {bounds} bounds
     * @param {vector} point
     * @return {boolean} True if the bounds contain the point, otherwise false
     */
    Bounds.contains = function(bounds, point) {
        return point.x >= bounds.min.x && point.x <= bounds.max.x 
               && point.y >= bounds.min.y && point.y <= bounds.max.y;
    };

    /**
     * Returns true if the two bounds intersect.
     * @method overlaps
     * @param {bounds} boundsA
     * @param {bounds} boundsB
     * @return {boolean} True if the bounds overlap, otherwise false
     */
    Bounds.overlaps = function(boundsA, boundsB) {
        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x
                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);
    };

    /**
     * Translates the bounds by the given vector.
     * @method translate
     * @param {bounds} bounds
     * @param {vector} vector
     */
    Bounds.translate = function(bounds, vector) {
        bounds.min.x += vector.x;
        bounds.max.x += vector.x;
        bounds.min.y += vector.y;
        bounds.max.y += vector.y;
    };

    /**
     * Shifts the bounds to the given position.
     * @method shift
     * @param {bounds} bounds
     * @param {vector} position
     */
    Bounds.shift = function(bounds, position) {
        var deltaX = bounds.max.x - bounds.min.x,
            deltaY = bounds.max.y - bounds.min.y;
            
        bounds.min.x = position.x;
        bounds.max.x = position.x + deltaX;
        bounds.min.y = position.y;
        bounds.max.y = position.y + deltaY;
    };
    
})();


/***/ },
/* 4 */
/***/ function(module, exports) {

/**
* The `Matter.Vector` module contains methods for creating and manipulating vectors.
* Vectors are the basis of all the geometry related operations in the engine.
* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vector
*/

// TODO: consider params for reusing vector objects

var Vector = {};

module.exports = Vector;

(function() {

    /**
     * Creates a new vector.
     * @method create
     * @param {number} x
     * @param {number} y
     * @return {vector} A new vector
     */
    Vector.create = function(x, y) {
        return { x: x || 0, y: y || 0 };
    };

    /**
     * Returns a new vector with `x` and `y` copied from the given `vector`.
     * @method clone
     * @param {vector} vector
     * @return {vector} A new cloned vector
     */
    Vector.clone = function(vector) {
        return { x: vector.x, y: vector.y };
    };

    /**
     * Returns the magnitude (length) of a vector.
     * @method magnitude
     * @param {vector} vector
     * @return {number} The magnitude of the vector
     */
    Vector.magnitude = function(vector) {
        return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));
    };

    /**
     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
     * @method magnitudeSquared
     * @param {vector} vector
     * @return {number} The squared magnitude of the vector
     */
    Vector.magnitudeSquared = function(vector) {
        return (vector.x * vector.x) + (vector.y * vector.y);
    };

    /**
     * Rotates the vector about (0, 0) by specified angle.
     * @method rotate
     * @param {vector} vector
     * @param {number} angle
     * @return {vector} A new vector rotated about (0, 0)
     */
    Vector.rotate = function(vector, angle) {
        var cos = Math.cos(angle), sin = Math.sin(angle);
        return {
            x: vector.x * cos - vector.y * sin,
            y: vector.x * sin + vector.y * cos
        };
    };

    /**
     * Rotates the vector about a specified point by specified angle.
     * @method rotateAbout
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} point
     * @param {vector} [output]
     * @return {vector} A new vector rotated about the point
     */
    Vector.rotateAbout = function(vector, angle, point, output) {
        var cos = Math.cos(angle), sin = Math.sin(angle);
        if (!output) output = {};
        var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
        output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
        output.x = x;
        return output;
    };

    /**
     * Normalises a vector (such that its magnitude is `1`).
     * @method normalise
     * @param {vector} vector
     * @return {vector} A new vector normalised
     */
    Vector.normalise = function(vector) {
        var magnitude = Vector.magnitude(vector);
        if (magnitude === 0)
            return { x: 0, y: 0 };
        return { x: vector.x / magnitude, y: vector.y / magnitude };
    };

    /**
     * Returns the dot-product of two vectors.
     * @method dot
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The dot product of the two vectors
     */
    Vector.dot = function(vectorA, vectorB) {
        return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);
    };

    /**
     * Returns the cross-product of two vectors.
     * @method cross
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The cross product of the two vectors
     */
    Vector.cross = function(vectorA, vectorB) {
        return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);
    };

    /**
     * Returns the cross-product of three vectors.
     * @method cross3
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} vectorC
     * @return {number} The cross product of the three vectors
     */
    Vector.cross3 = function(vectorA, vectorB, vectorC) {
        return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
    };

    /**
     * Adds the two vectors.
     * @method add
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB added
     */
    Vector.add = function(vectorA, vectorB, output) {
        if (!output) output = {};
        output.x = vectorA.x + vectorB.x;
        output.y = vectorA.y + vectorB.y;
        return output;
    };

    /**
     * Subtracts the two vectors.
     * @method sub
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB subtracted
     */
    Vector.sub = function(vectorA, vectorB, output) {
        if (!output) output = {};
        output.x = vectorA.x - vectorB.x;
        output.y = vectorA.y - vectorB.y;
        return output;
    };

    /**
     * Multiplies a vector and a scalar.
     * @method mult
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector multiplied by scalar
     */
    Vector.mult = function(vector, scalar) {
        return { x: vector.x * scalar, y: vector.y * scalar };
    };

    /**
     * Divides a vector and a scalar.
     * @method div
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector divided by scalar
     */
    Vector.div = function(vector, scalar) {
        return { x: vector.x / scalar, y: vector.y / scalar };
    };

    /**
     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
     * @method perp
     * @param {vector} vector
     * @param {bool} [negate=false]
     * @return {vector} The perpendicular vector
     */
    Vector.perp = function(vector, negate) {
        negate = negate === true ? -1 : 1;
        return { x: negate * -vector.y, y: negate * vector.x };
    };

    /**
     * Negates both components of a vector such that it points in the opposite direction.
     * @method neg
     * @param {vector} vector
     * @return {vector} The negated vector
     */
    Vector.neg = function(vector) {
        return { x: -vector.x, y: -vector.y };
    };

    /**
     * Returns the angle in radians between the two vectors relative to the x-axis.
     * @method angle
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The angle in radians
     */
    Vector.angle = function(vectorA, vectorB) {
        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
    };

    /**
     * Temporary vector pool (not thread-safe).
     * @property _temp
     * @type {vector[]}
     * @private
     */
    Vector._temp = [
        Vector.create(), Vector.create(), 
        Vector.create(), Vector.create(), 
        Vector.create(), Vector.create()
    ];

})();

/***/ },
/* 5 */
/***/ function(module, exports) {

var Event = function (type)
{
    this.type = type;

    //  The element that initiated the event.
    this.target;

    this._propagate = true;
};

Event.prototype.constructor = Event;

Event.prototype = {

    reset: function (target)
    {
        this.target = target;

        this._propagate = true;
    },

    stopPropagation: function ()
    {
        this._propagate = false;
    }

};

module.exports = Event;


/***/ },
/* 6 */
/***/ function(module, exports) {


/**
* The GameObject Factory is a global level container of Factory instances.
* Factories register themselves with this container (when required)
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/

var factories = {};

var FactoryContainer = function ()
{
    // console.log('FactoryContainer is alive');

    this.register = function (factory)
    {
        if (factories.hasOwnProperty(factory.KEY))
        {
            // console.log('Already registered', factory.KEY);

            return this.getType(factory.KEY);
        }
        else
        {
            // console.log('registering', factory.KEY);

            factories[factory.KEY] = {
                add: factory.add,
                make: factory.make
            };

            return factory;
        }
    };

    this.getType = function (key)
    {
        return factories[key];
    };

    this.load = function (dest, isFactory)
    {
        for (var factory in factories)
        {
            if (factories.hasOwnProperty(factory))
            {
                // console.log('Loading', factory);

                dest[factory] = (isFactory) ? factories[factory].add : factories[factory].make;
            }
        }

        return dest;
    };

    return this;
};

module.exports = FactoryContainer();


/***/ },
/* 7 */
/***/ function(module, exports) {

var MATH_CONST = {

    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI

};

module.exports = MATH_CONST;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Alpha: __webpack_require__(190),
    BlendMode: __webpack_require__(191),
    Children: __webpack_require__(192),
    Color: __webpack_require__(193),
    Data: __webpack_require__(80),
    GetBounds: __webpack_require__(194),
    Origin: __webpack_require__(195),
    ScaleMode: __webpack_require__(196),
    Size: __webpack_require__(197),
    Texture: __webpack_require__(198),
    Transform: __webpack_require__(199),
    TransformMatrix: __webpack_require__(26),
    Visible: __webpack_require__(200)

};


/***/ },
/* 9 */
/***/ function(module, exports) {

//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse

function hasGetterOrSetter (def)
{
    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');
}

function getProperty (definition, k, isClassDescriptor)
{
    //  This may be a lightweight object, OR it might be a property that was defined previously.
    
    //  For simple class descriptors we can just assume its NOT previously defined.
    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);

    if (!isClassDescriptor && def.value && typeof def.value === 'object')
    {
        def = def.value;
    }

    //  This might be a regular property, or it may be a getter/setter the user defined in a class.
    if (def && hasGetterOrSetter(def))
    {
        if (typeof def.enumerable === 'undefined')
        {
            def.enumerable = true;
        }

        if (typeof def.configurable === 'undefined')
        {
            def.configurable = true;
        }

        return def;
    }
    else
    {
        return false;
    }
}

function hasNonConfigurable (obj, k)
{
    var prop = Object.getOwnPropertyDescriptor(obj, k);

    if (!prop)
    {
        return false;
    }

    if (prop.value && typeof prop.value === 'object')
    {
        prop = prop.value;
    }

    if (prop.configurable === false)
    {
        return true;
    }

    return false;
}

function extend (ctor, definition, isClassDescriptor, extend)
{
    for (var k in definition)
    {
        if (!definition.hasOwnProperty(k))
        {
            continue;
        }

        var def = getProperty(definition, k, isClassDescriptor);

        if (def !== false)
        {
            //  If Extends is used, we will check its prototype to see if the final variable exists.
            
            var parent = extend || ctor;

            if (hasNonConfigurable(parent.prototype, k))
            {
                //  Just skip the final property
                if (Class.ignoreFinals)
                {
                    continue;
                }

                //  We cannot re-define a property that is configurable=false.
                //  So we will consider them final and throw an error. This is by
                //  default so it is clear to the developer what is happening.
                //  You can set ignoreFinals to true if you need to extend a class
                //  which has configurable=false; it will simply not re-define final properties.
                throw new Error('cannot override final property \'' + k + '\', set Class.ignoreFinals = true to skip');
            }

            Object.defineProperty(ctor.prototype, k, def);
        }
        else
        {
            ctor.prototype[k] = definition[k];
        }
    }
}

function mixin (myClass, mixins)
{
    if (!mixins)
    {
        return;
    }

    if (!Array.isArray(mixins))
    {
        mixins = [ mixins ];
    }

    for (var i = 0; i < mixins.length; i++)
    {
        extend(myClass, mixins[i].prototype || mixins[i]);
    }
}

/**
 * Creates a new class with the given descriptor.
 * The constructor, defined by the name `initialize`,
 * is an optional function. If unspecified, an anonymous
 * function will be used which calls the parent class (if
 * one exists).
 *
 * You can also use `Extends` and `Mixins` to provide subclassing
 * and inheritance.
 *
 * @class  Class
 * @constructor
 * @param {Object} definition a dictionary of functions for the class
 * @example
 *
 *      var MyClass = new Phaser.Class({
 *      
 *          initialize: function() {
 *              this.foo = 2.0;
 *          },
 *
 *          bar: function() {
 *              return this.foo + 5;
 *          }
 *      });
 */
function Class (definition)
{
    if (!definition)
    {
        definition = {};
    }

    //  The variable name here dictates what we see in Chrome debugger
    var initialize;
    var Extends;

    if (definition.initialize)
    {
        if (typeof definition.initialize !== 'function')
        {
            throw new Error('initialize must be a function');
        }

        initialize = definition.initialize;

        //  Usually we should avoid 'delete' in V8 at all costs.
        //  However, its unlikely to make any performance difference
        //  here since we only call this on class creation (i.e. not object creation).
        delete definition.initialize;
    }
    else
    {
        if (definition.Extends)
        {
            var base = definition.Extends;

            initialize = function ()
            {
                base.apply(this, arguments);
            };
        }
        else
        {
            initialize = function () {};
        }
    }

    if (definition.Extends)
    {
        initialize.prototype = Object.create(definition.Extends.prototype);
        initialize.prototype.constructor = initialize;

        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)

        Extends = definition.Extends;

        delete definition.Extends;
    }
    else
    {
        initialize.prototype.constructor = initialize;
    }

    //  Grab the mixins, if they are specified...
    var mixins = null;

    if (definition.Mixins)
    {
        mixins = definition.Mixins;
        delete definition.Mixins;
    }

    //  First, mixin if we can.
    mixin(initialize, mixins);

    //  Now we grab the actual definition which defines the overrides.
    extend(initialize, definition, true, Extends);

    return initialize;
}

Class.extend = extend;
Class.mixin = mixin;
Class.ignoreFinals = false;

module.exports = Class;


/***/ },
/* 10 */
/***/ function(module, exports) {

var FILE_CONST = {

    LOADER_IDLE: 0,
    LOADER_LOADING: 1,
    LOADER_PROCESSING: 2,
    LOADER_COMPLETE: 3,
    LOADER_DESTROYED: 4,

    FILE_PENDING: 5,      // file is in the load queue but not yet started
    FILE_LOADING: 6,      // file has been started to load by the loader (onLoad called)
    FILE_LOADED: 7,       // file has loaded successfully, awaiting processing
    FILE_FAILED: 8,       // file failed to load
    FILE_PROCESSING: 9,   // file is being processed (onProcess callback)
    FILE_WAITING_LINKFILE: 10,   // file is being processed (onProcess callback)
    FILE_ERRORED: 11,   // file is being processed (onProcess callback)
    FILE_COMPLETE: 12,     // file has finished processing
    FILE_DESTROYED: 13,     // file has been destroyed

    TEXTURE_ATLAS_JSON_ARRAY: 20,
    TEXTURE_ATLAS_JSON_HASH: 21

};

module.exports = FILE_CONST;


/***/ },
/* 11 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetBottom = function (gameObject)
{
    return (gameObject.y + gameObject.height) - (gameObject.height * gameObject.anchorY);
};

module.exports = GetBottom;


/***/ },
/* 12 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetLeft = function (gameObject)
{
    return gameObject.x - (gameObject.width * gameObject.anchorX);
};

module.exports = GetLeft;


/***/ },
/* 13 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetRight = function (gameObject)
{
    return (gameObject.x + gameObject.width) - (gameObject.width * gameObject.anchorX);
};

module.exports = GetRight;


/***/ },
/* 14 */
/***/ function(module, exports) {

/**
* The y coordinate of the Game Object.
* This is the same as `y - offsetY`.
*
* @property {number} top
*/

var GetTop = function (gameObject)
{
    return gameObject.y - (gameObject.height * gameObject.anchorY);
};

module.exports = GetTop;


/***/ },
/* 15 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetBottom = function (gameObject, value)
{
    gameObject.y = (value - gameObject.height) + (gameObject.height * gameObject.anchorY);

    return gameObject;
};

module.exports = SetBottom;


/***/ },
/* 16 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetLeft = function (gameObject, value)
{
    gameObject.x = value + (gameObject.width * gameObject.anchorX);

    return gameObject;
};

module.exports = SetLeft;


/***/ },
/* 17 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetRight = function (gameObject, value)
{
    gameObject.x = (value - gameObject.width) + (gameObject.width * gameObject.anchorX);

    return gameObject;
};

module.exports = SetRight;


/***/ },
/* 18 */
/***/ function(module, exports) {

/**
* The y coordinate of the Game Object.
* This is the same as `y - offsetY`.
*
* @property {number} top
*/

var SetTop = function (gameObject, value)
{
    gameObject.y = value + (gameObject.height * gameObject.anchorY);

    return gameObject;
};

module.exports = SetTop;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var OS = {

    /**
    * @property {boolean} desktop - Is running on a desktop?
    * @default
    */
    desktop: false,

    /**
    * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView
    * @default
    */
    webApp: false,

    /**
    * @property {boolean} iOS - Is running on iOS?
    * @default
    */
    iOS: false,

    /**
    * @property {number} iOSVersion - If running in iOS this will contain the major version number.
    * @default
    */
    iOSVersion: 0,

    /**
    * @property {boolean} iPhone - Is running on iPhone?
    * @default
    */
    iPhone: false,

    /**
    * @property {boolean} iPad - Is running on iPad?
    * @default
    */
    iPad: false,

    /**
    * @property {boolean} cocoonJS - Is the game running under CocoonJS?
    * @default
    */
    cocoonJS: false,
    
    /**
    * @property {boolean} cocoonJSApp - Is this game running with CocoonJS.App?
    * @default
    */
    cocoonJSApp: false,
    
    /**
    * @property {boolean} cordova - Is the game running under Apache Cordova?
    * @default
    */
    cordova: false,
    
    /**
    * @property {boolean} node - Is the game running under Node.js?
    * @default
    */
    node: false,
    
    /**
    * @property {boolean} nodeWebkit - Is the game running under Node-Webkit?
    * @default
    */
    nodeWebkit: false,
    
    /**
    * @property {boolean} electron - Is the game running under GitHub Electron?
    * @default
    */
    electron: false,
    
    /**
    * @property {boolean} ejecta - Is the game running under Ejecta?
    * @default
    */
    ejecta: false,

    /**
    * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?
    * @default
    */
    crosswalk: false,

    /**
    * @property {boolean} android - Is running on android?
    * @default
    */
    android: false,

    /**
    * @property {boolean} chromeOS - Is running on chromeOS?
    * @default
    */
    chromeOS: false,

    /**
    * @property {boolean} linux - Is running on linux?
    * @default
    */
    linux: false,

    /**
    * @property {boolean} macOS - Is running on macOS?
    * @default
    */
    macOS: false,

    /**
    * @property {boolean} windows - Is running on windows?
    * @default
    */
    windows: false,

    /**
    * @property {boolean} windowsPhone - Is running on a Windows Phone?
    * @default
    */
    windowsPhone: false,

    /**
    * @property {boolean} vita - Is running on a PlayStation Vita?
    * @default
    */
    vita: false,

    /**
    * @property {boolean} kindle - Is running on an Amazon Kindle?
    * @default
    */
    kindle: false,

    /**
    * @property {number} pixelRatio - PixelRatio of the host device?
    * @default
    */
    pixelRatio: 1

};

function init ()
{
    var ua = navigator.userAgent;

    if (/Windows/.test(ua))
    {
        OS.windows = true;
    }
    else if (/Mac OS/.test(ua))
    {
        OS.macOS = true;
    }
    else if (/Linux/.test(ua))
    {
        OS.linux = true;
    }
    else if (/Android/.test(ua))
    {
        OS.android = true;
    }
    else if (/iP[ao]d|iPhone/i.test(ua))
    {
        OS.iOS = true;
        (navigator.appVersion).match(/OS (\d+)/);
        OS.iOSVersion = parseInt(RegExp.$1, 10);
    }
    else if (/Kindle/.test(ua) || (/\bKF[A-Z][A-Z]+/).test(ua) || (/Silk.*Mobile Safari/).test(ua))
    {
        OS.kindle = true;

        // This will NOT detect early generations of Kindle Fire, I think there is no reliable way...
        // E.g. "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-us; Silk/1.1.0-80) AppleWebKit/533.16 (KHTML, like Gecko) Version/5.0 Safari/533.16 Silk-Accelerated=true"
    }
    else if (/CrOS/.test(ua))
    {
        OS.chromeOS = true;
    }
    else if ((/Playstation Vita/).test(ua))
    {
        OS.vita = true;
    }

    if (/Windows Phone/i.test(ua) || (/IEMobile/i).test(ua))
    {
        OS.android = false;
        OS.iOS = false;
        OS.macOS = false;
        OS.windows = true;
        OS.windowsPhone = true;
    }

    var silk = (/Silk/).test(ua);

    if (OS.windows || OS.macOS || (OS.linux && !silk) || OS.chromeOS)
    {
        OS.desktop = true;
    }

    //  Windows Phone / Table reset
    if (OS.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua))))
    {
        OS.desktop = false;
    }

    //  WebApp mode in iOS
    if (navigator.standalone)
    {
        OS.webApp = true;
    }
    
    if (window.cordova !== undefined)
    {
        OS.cordova = true;
    }
    
    if ((typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined'))
    {
        OS.node = true;
    }
    
    if (OS.node && typeof process.versions === 'object')
    {
        OS.nodeWebkit = !!process.versions['node-webkit'];
        
        OS.electron = !!process.versions.electron;
    }
    
    if (navigator.isCocoonJS)
    {
        OS.cocoonJS = true;

        try
        {
            OS.cocoonJSApp = (typeof CocoonJS !== 'undefined');
        }
        catch (error)
        {
            OS.cocoonJSApp = false;
        }
    }

    if (window.ejecta !== undefined)
    {
        OS.ejecta = true;
    }

    if ((/Crosswalk/).test(ua))
    {
        OS.crosswalk = true;
    }

    OS.iPhone = ua.toLowerCase().indexOf('iphone') !== -1;
    OS.iPad = ua.toLowerCase().indexOf('ipad') !== -1;

    OS.pixelRatio = window['devicePixelRatio'] || 1;

    return OS;
}

module.exports = init();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(561)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composite
*/

var Composite = {};

module.exports = Composite;

var Events = __webpack_require__(21);
var Common = __webpack_require__(0);
var Body = __webpack_require__(38);

(function() {

    /**
     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properites section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} [options]
     * @return {composite} A new composite
     */
    Composite.create = function(options) {
        return Common.extend({ 
            id: Common.nextId(),
            type: 'composite',
            parent: null,
            isModified: false,
            bodies: [], 
            constraints: [], 
            composites: [],
            label: 'Composite',
            plugin: {}
        }, options);
    };

    /**
     * Sets the composite's `isModified` flag. 
     * If `updateParents` is true, all parents will be set (default: false).
     * If `updateChildren` is true, all children will be set (default: false).
     * @method setModified
     * @param {composite} composite
     * @param {boolean} isModified
     * @param {boolean} [updateParents=false]
     * @param {boolean} [updateChildren=false]
     */
    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {
        composite.isModified = isModified;

        if (updateParents && composite.parent) {
            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
        }

        if (updateChildren) {
            for(var i = 0; i < composite.composites.length; i++) {
                var childComposite = composite.composites[i];
                Composite.setModified(childComposite, isModified, updateParents, updateChildren);
            }
        }
    };

    /**
     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
     * @method add
     * @param {composite} composite
     * @param {} object
     * @return {composite} The original composite with the objects added
     */
    Composite.add = function(composite, object) {
        var objects = [].concat(object);

        Events.trigger(composite, 'beforeAdd', { object: object });

        for (var i = 0; i < objects.length; i++) {
            var obj = objects[i];

            switch (obj.type) {

            case 'body':
                // skip adding compound parts
                if (obj.parent !== obj) {
                    Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');
                    break;
                }

                Composite.addBody(composite, obj);
                break;
            case 'constraint':
                Composite.addConstraint(composite, obj);
                break;
            case 'composite':
                Composite.addComposite(composite, obj);
                break;
            case 'mouseConstraint':
                Composite.addConstraint(composite, obj.constraint);
                break;

            }
        }

        Events.trigger(composite, 'afterAdd', { object: object });

        return composite;
    };

    /**
     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Optionally searching its children recursively.
     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.
     * @method remove
     * @param {composite} composite
     * @param {} object
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the objects removed
     */
    Composite.remove = function(composite, object, deep) {
        var objects = [].concat(object);

        Events.trigger(composite, 'beforeRemove', { object: object });

        for (var i = 0; i < objects.length; i++) {
            var obj = objects[i];

            switch (obj.type) {

            case 'body':
                Composite.removeBody(composite, obj, deep);
                break;
            case 'constraint':
                Composite.removeConstraint(composite, obj, deep);
                break;
            case 'composite':
                Composite.removeComposite(composite, obj, deep);
                break;
            case 'mouseConstraint':
                Composite.removeConstraint(composite, obj.constraint);
                break;

            }
        }

        Events.trigger(composite, 'afterRemove', { object: object });

        return composite;
    };

    /**
     * Adds a composite to the given composite.
     * @private
     * @method addComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @return {composite} The original compositeA with the objects from compositeB added
     */
    Composite.addComposite = function(compositeA, compositeB) {
        compositeA.composites.push(compositeB);
        compositeB.parent = compositeA;
        Composite.setModified(compositeA, true, true, false);
        return compositeA;
    };

    /**
     * Removes a composite from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @param {boolean} [deep=false]
     * @return {composite} The original compositeA with the composite removed
     */
    Composite.removeComposite = function(compositeA, compositeB, deep) {
        var position = Common.indexOf(compositeA.composites, compositeB);
        if (position !== -1) {
            Composite.removeCompositeAt(compositeA, position);
            Composite.setModified(compositeA, true, true, false);
        }

        if (deep) {
            for (var i = 0; i < compositeA.composites.length; i++){
                Composite.removeComposite(compositeA.composites[i], compositeB, true);
            }
        }

        return compositeA;
    };

    /**
     * Removes a composite from the given composite.
     * @private
     * @method removeCompositeAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the composite removed
     */
    Composite.removeCompositeAt = function(composite, position) {
        composite.composites.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Adds a body to the given composite.
     * @private
     * @method addBody
     * @param {composite} composite
     * @param {body} body
     * @return {composite} The original composite with the body added
     */
    Composite.addBody = function(composite, body) {
        composite.bodies.push(body);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes a body from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeBody
     * @param {composite} composite
     * @param {body} body
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the body removed
     */
    Composite.removeBody = function(composite, body, deep) {
        var position = Common.indexOf(composite.bodies, body);
        if (position !== -1) {
            Composite.removeBodyAt(composite, position);
            Composite.setModified(composite, true, true, false);
        }

        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.removeBody(composite.composites[i], body, true);
            }
        }

        return composite;
    };

    /**
     * Removes a body from the given composite.
     * @private
     * @method removeBodyAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the body removed
     */
    Composite.removeBodyAt = function(composite, position) {
        composite.bodies.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Adds a constraint to the given composite.
     * @private
     * @method addConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @return {composite} The original composite with the constraint added
     */
    Composite.addConstraint = function(composite, constraint) {
        composite.constraints.push(constraint);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes a constraint from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the constraint removed
     */
    Composite.removeConstraint = function(composite, constraint, deep) {
        var position = Common.indexOf(composite.constraints, constraint);
        if (position !== -1) {
            Composite.removeConstraintAt(composite, position);
        }

        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.removeConstraint(composite.composites[i], constraint, true);
            }
        }

        return composite;
    };

    /**
     * Removes a body from the given composite.
     * @private
     * @method removeConstraintAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the constraint removed
     */
    Composite.removeConstraintAt = function(composite, position) {
        composite.constraints.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes all bodies, constraints and composites from the given composite.
     * Optionally clearing its children recursively.
     * @method clear
     * @param {composite} composite
     * @param {boolean} keepStatic
     * @param {boolean} [deep=false]
     */
    Composite.clear = function(composite, keepStatic, deep) {
        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.clear(composite.composites[i], keepStatic, true);
            }
        }
        
        if (keepStatic) {
            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });
        } else {
            composite.bodies.length = 0;
        }

        composite.constraints.length = 0;
        composite.composites.length = 0;
        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Returns all bodies in the given composite, including all bodies in its children, recursively.
     * @method allBodies
     * @param {composite} composite
     * @return {body[]} All the bodies
     */
    Composite.allBodies = function(composite) {
        var bodies = [].concat(composite.bodies);

        for (var i = 0; i < composite.composites.length; i++)
            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));

        return bodies;
    };

    /**
     * Returns all constraints in the given composite, including all constraints in its children, recursively.
     * @method allConstraints
     * @param {composite} composite
     * @return {constraint[]} All the constraints
     */
    Composite.allConstraints = function(composite) {
        var constraints = [].concat(composite.constraints);

        for (var i = 0; i < composite.composites.length; i++)
            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));

        return constraints;
    };

    /**
     * Returns all composites in the given composite, including all composites in its children, recursively.
     * @method allComposites
     * @param {composite} composite
     * @return {composite[]} All the composites
     */
    Composite.allComposites = function(composite) {
        var composites = [].concat(composite.composites);

        for (var i = 0; i < composite.composites.length; i++)
            composites = composites.concat(Composite.allComposites(composite.composites[i]));

        return composites;
    };

    /**
     * Searches the composite recursively for an object matching the type and id supplied, null if not found.
     * @method get
     * @param {composite} composite
     * @param {number} id
     * @param {string} type
     * @return {object} The requested object, if found
     */
    Composite.get = function(composite, id, type) {
        var objects,
            object;

        switch (type) {
        case 'body':
            objects = Composite.allBodies(composite);
            break;
        case 'constraint':
            objects = Composite.allConstraints(composite);
            break;
        case 'composite':
            objects = Composite.allComposites(composite).concat(composite);
            break;
        }

        if (!objects)
            return null;

        object = objects.filter(function(object) { 
            return object.id.toString() === id.toString(); 
        });

        return object.length === 0 ? null : object[0];
    };

    /**
     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
     * @method move
     * @param {compositeA} compositeA
     * @param {object[]} objects
     * @param {compositeB} compositeB
     * @return {composite} Returns compositeA
     */
    Composite.move = function(compositeA, objects, compositeB) {
        Composite.remove(compositeA, objects);
        Composite.add(compositeB, objects);
        return compositeA;
    };

    /**
     * Assigns new ids for all objects in the composite, recursively.
     * @method rebase
     * @param {composite} composite
     * @return {composite} Returns composite
     */
    Composite.rebase = function(composite) {
        var objects = Composite.allBodies(composite)
                        .concat(Composite.allConstraints(composite))
                        .concat(Composite.allComposites(composite));

        for (var i = 0; i < objects.length; i++) {
            objects[i].id = Common.nextId();
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Translates all children in the composite by a given vector relative to their current positions, 
     * without imparting any velocity.
     * @method translate
     * @param {composite} composite
     * @param {vector} translation
     * @param {bool} [recursive=true]
     */
    Composite.translate = function(composite, translation, recursive) {
        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            Body.translate(bodies[i], translation);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
     * @method rotate
     * @param {composite} composite
     * @param {number} rotation
     * @param {vector} point
     * @param {bool} [recursive=true]
     */
    Composite.rotate = function(composite, rotation, point, recursive) {
        var cos = Math.cos(rotation),
            sin = Math.sin(rotation),
            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                dx = body.position.x - point.x,
                dy = body.position.y - point.y;
                
            Body.setPosition(body, {
                x: point.x + (dx * cos - dy * sin),
                y: point.y + (dx * sin + dy * cos)
            });

            Body.rotate(body, rotation);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
     * @method scale
     * @param {composite} composite
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     * @param {bool} [recursive=true]
     */
    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {
        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                dx = body.position.x - point.x,
                dy = body.position.y - point.y;
                
            Body.setPosition(body, {
                x: point.x + dx * scaleX,
                y: point.y + dy * scaleY
            });

            Body.scale(body, scaleX, scaleY);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when a call to `Composite.add` is made, before objects have been added.
    *
    * @event beforeAdd
    * @param {} event An event object
    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.add` is made, after objects have been added.
    *
    * @event afterAdd
    * @param {} event An event object
    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.remove` is made, before objects have been removed.
    *
    * @event beforeRemove
    * @param {} event An event object
    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.remove` is made, after objects have been removed.
    *
    * @event afterRemove
    * @param {} event An event object
    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "composite"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage composites.
     *
     * @property label
     * @type string
     * @default "Composite"
     */

    /**
     * A flag that specifies whether the composite has been modified during the current step.
     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.
     * If you need to change it manually, you should use the `Composite.setModified` method.
     *
     * @property isModified
     * @type boolean
     * @default false
     */

    /**
     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.
     *
     * @property parent
     * @type composite
     * @default null
     */

    /**
     * An array of `Body` that are _direct_ children of this composite.
     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.
     *
     * @property bodies
     * @type body[]
     * @default []
     */

    /**
     * An array of `Constraint` that are _direct_ children of this composite.
     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.
     *
     * @property constraints
     * @type constraint[]
     * @default []
     */

    /**
     * An array of `Composite` that are _direct_ children of this composite.
     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.
     *
     * @property composites
     * @type composite[]
     * @default []
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Events` module contains methods to fire and listen to events on other objects.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Events
*/

var Events = {};

module.exports = Events;

var Common = __webpack_require__(0);

(function() {

    /**
     * Subscribes a callback function to the given object's `eventName`.
     * @method on
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */
    Events.on = function(object, eventNames, callback) {
        var names = eventNames.split(' '),
            name;

        for (var i = 0; i < names.length; i++) {
            name = names[i];
            object.events = object.events || {};
            object.events[name] = object.events[name] || [];
            object.events[name].push(callback);
        }

        return callback;
    };

    /**
     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.
     * @method off
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */
    Events.off = function(object, eventNames, callback) {
        if (!eventNames) {
            object.events = {};
            return;
        }

        // handle Events.off(object, callback)
        if (typeof eventNames === 'function') {
            callback = eventNames;
            eventNames = Common.keys(object.events).join(' ');
        }

        var names = eventNames.split(' ');

        for (var i = 0; i < names.length; i++) {
            var callbacks = object.events[names[i]],
                newCallbacks = [];

            if (callback && callbacks) {
                for (var j = 0; j < callbacks.length; j++) {
                    if (callbacks[j] !== callback)
                        newCallbacks.push(callbacks[j]);
                }
            }

            object.events[names[i]] = newCallbacks;
        }
    };

    /**
     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.
     * @method trigger
     * @param {} object
     * @param {string} eventNames
     * @param {} event
     */
    Events.trigger = function(object, eventNames, event) {
        var names,
            name,
            callbacks,
            eventClone;

        if (object.events) {
            if (!event)
                event = {};

            names = eventNames.split(' ');

            for (var i = 0; i < names.length; i++) {
                name = names[i];
                callbacks = object.events[name];

                if (callbacks) {
                    eventClone = Common.clone(event, false);
                    eventClone.name = name;
                    eventClone.source = object;

                    for (var j = 0; j < callbacks.length; j++) {
                        callbacks[j].apply(object, [eventClone]);
                    }
                }
            }
        }
    };

})();


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vertices
*/

var Vertices = {};

module.exports = Vertices;

var Vector = __webpack_require__(4);
var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a new set of `Matter.Body` compatible vertices.
     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
     * but with some additional references required for efficient collision detection routines.
     *
     * Vertices must be specified in clockwise order.
     *
     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
     *
     * @method create
     * @param {vector[]} points
     * @param {body} body
     */
    Vertices.create = function(points, body) {
        var vertices = [];

        for (var i = 0; i < points.length; i++) {
            var point = points[i],
                vertex = {
                    x: point.x,
                    y: point.y,
                    index: i,
                    body: body,
                    isInternal: false
                };

            vertices.push(vertex);
        }

        return vertices;
    };

    /**
     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), 
     * into a `Matter.Vertices` object for the given `Matter.Body`.
     * For parsing SVG paths, see `Svg.pathToVertices`.
     * @method fromPath
     * @param {string} path
     * @param {body} body
     * @return {vertices} vertices
     */
    Vertices.fromPath = function(path, body) {
        var pathPattern = /L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/ig,
            points = [];

        path.replace(pathPattern, function(match, x, y) {
            points.push({ x: parseFloat(x), y: parseFloat(y) });
        });

        return Vertices.create(points, body);
    };

    /**
     * Returns the centre (centroid) of the set of vertices.
     * @method centre
     * @param {vertices} vertices
     * @return {vector} The centre point
     */
    Vertices.centre = function(vertices) {
        var area = Vertices.area(vertices, true),
            centre = { x: 0, y: 0 },
            cross,
            temp,
            j;

        for (var i = 0; i < vertices.length; i++) {
            j = (i + 1) % vertices.length;
            cross = Vector.cross(vertices[i], vertices[j]);
            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);
            centre = Vector.add(centre, temp);
        }

        return Vector.div(centre, 6 * area);
    };

    /**
     * Returns the average (mean) of the set of vertices.
     * @method mean
     * @param {vertices} vertices
     * @return {vector} The average point
     */
    Vertices.mean = function(vertices) {
        var average = { x: 0, y: 0 };

        for (var i = 0; i < vertices.length; i++) {
            average.x += vertices[i].x;
            average.y += vertices[i].y;
        }

        return Vector.div(average, vertices.length);
    };

    /**
     * Returns the area of the set of vertices.
     * @method area
     * @param {vertices} vertices
     * @param {bool} signed
     * @return {number} The area
     */
    Vertices.area = function(vertices, signed) {
        var area = 0,
            j = vertices.length - 1;

        for (var i = 0; i < vertices.length; i++) {
            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);
            j = i;
        }

        if (signed)
            return area / 2;

        return Math.abs(area) / 2;
    };

    /**
     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
     * @method inertia
     * @param {vertices} vertices
     * @param {number} mass
     * @return {number} The polygon's moment of inertia
     */
    Vertices.inertia = function(vertices, mass) {
        var numerator = 0,
            denominator = 0,
            v = vertices,
            cross,
            j;

        // find the polygon's moment of inertia, using second moment of area
        // http://www.physicsforums.com/showthread.php?t=25293
        for (var n = 0; n < v.length; n++) {
            j = (n + 1) % v.length;
            cross = Math.abs(Vector.cross(v[j], v[n]));
            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));
            denominator += cross;
        }

        return (mass / 6) * (numerator / denominator);
    };

    /**
     * Translates the set of vertices in-place.
     * @method translate
     * @param {vertices} vertices
     * @param {vector} vector
     * @param {number} scalar
     */
    Vertices.translate = function(vertices, vector, scalar) {
        var i;
        if (scalar) {
            for (i = 0; i < vertices.length; i++) {
                vertices[i].x += vector.x * scalar;
                vertices[i].y += vector.y * scalar;
            }
        } else {
            for (i = 0; i < vertices.length; i++) {
                vertices[i].x += vector.x;
                vertices[i].y += vector.y;
            }
        }

        return vertices;
    };

    /**
     * Rotates the set of vertices in-place.
     * @method rotate
     * @param {vertices} vertices
     * @param {number} angle
     * @param {vector} point
     */
    Vertices.rotate = function(vertices, angle, point) {
        if (angle === 0)
            return;

        var cos = Math.cos(angle),
            sin = Math.sin(angle);

        for (var i = 0; i < vertices.length; i++) {
            var vertice = vertices[i],
                dx = vertice.x - point.x,
                dy = vertice.y - point.y;
                
            vertice.x = point.x + (dx * cos - dy * sin);
            vertice.y = point.y + (dx * sin + dy * cos);
        }

        return vertices;
    };

    /**
     * Returns `true` if the `point` is inside the set of `vertices`.
     * @method contains
     * @param {vertices} vertices
     * @param {vector} point
     * @return {boolean} True if the vertices contains point, otherwise false
     */
    Vertices.contains = function(vertices, point) {
        for (var i = 0; i < vertices.length; i++) {
            var vertice = vertices[i],
                nextVertice = vertices[(i + 1) % vertices.length];
            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {
                return false;
            }
        }

        return true;
    };

    /**
     * Scales the vertices from a point (default is centre) in-place.
     * @method scale
     * @param {vertices} vertices
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     */
    Vertices.scale = function(vertices, scaleX, scaleY, point) {
        if (scaleX === 1 && scaleY === 1)
            return vertices;

        point = point || Vertices.centre(vertices);

        var vertex,
            delta;

        for (var i = 0; i < vertices.length; i++) {
            vertex = vertices[i];
            delta = Vector.sub(vertex, point);
            vertices[i].x = point.x + delta.x * scaleX;
            vertices[i].y = point.y + delta.y * scaleY;
        }

        return vertices;
    };

    /**
     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
     * The radius parameter is a single number or an array to specify the radius for each vertex.
     * @method chamfer
     * @param {vertices} vertices
     * @param {number[]} radius
     * @param {number} quality
     * @param {number} qualityMin
     * @param {number} qualityMax
     */
    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {
        radius = radius || [8];

        if (!radius.length)
            radius = [radius];

        // quality defaults to -1, which is auto
        quality = (typeof quality !== 'undefined') ? quality : -1;
        qualityMin = qualityMin || 2;
        qualityMax = qualityMax || 14;

        var newVertices = [];

        for (var i = 0; i < vertices.length; i++) {
            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],
                vertex = vertices[i],
                nextVertex = vertices[(i + 1) % vertices.length],
                currentRadius = radius[i < radius.length ? i : radius.length - 1];

            if (currentRadius === 0) {
                newVertices.push(vertex);
                continue;
            }

            var prevNormal = Vector.normalise({ 
                x: vertex.y - prevVertex.y, 
                y: prevVertex.x - vertex.x
            });

            var nextNormal = Vector.normalise({ 
                x: nextVertex.y - vertex.y, 
                y: vertex.x - nextVertex.x
            });

            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),
                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),
                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),
                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));

            var precision = quality;

            if (quality === -1) {
                // automatically decide precision
                precision = Math.pow(currentRadius, 0.32) * 1.75;
            }

            precision = Common.clamp(precision, qualityMin, qualityMax);

            // use an even value for precision, more likely to reduce axes by using symmetry
            if (precision % 2 === 1)
                precision += 1;

            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),
                theta = alpha / precision;

            for (var j = 0; j < precision; j++) {
                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
            }
        }

        return newVertices;
    };

    /**
     * Sorts the input vertices into clockwise order in place.
     * @method clockwiseSort
     * @param {vertices} vertices
     * @return {vertices} vertices
     */
    Vertices.clockwiseSort = function(vertices) {
        var centre = Vertices.mean(vertices);

        vertices.sort(function(vertexA, vertexB) {
            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
        });

        return vertices;
    };

    /**
     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
     * @method isConvex
     * @param {vertices} vertices
     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
     */
    Vertices.isConvex = function(vertices) {
        // http://paulbourke.net/geometry/polygonmesh/

        var flag = 0,
            n = vertices.length,
            i,
            j,
            k,
            z;

        if (n < 3)
            return null;

        for (i = 0; i < n; i++) {
            j = (i + 1) % n;
            k = (i + 2) % n;
            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);

            if (z < 0) {
                flag |= 1;
            } else if (z > 0) {
                flag |= 2;
            }

            if (flag === 3) {
                return false;
            }
        }

        if (flag !== 0){
            return true;
        } else {
            return null;
        }
    };

    /**
     * Returns the convex hull of the input vertices as a new array of points.
     * @method hull
     * @param {vertices} vertices
     * @return [vertex] vertices
     */
    Vertices.hull = function(vertices) {
        // http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain

        var upper = [],
            lower = [], 
            vertex,
            i;

        // sort vertices on x-axis (y-axis for ties)
        vertices = vertices.slice(0);
        vertices.sort(function(vertexA, vertexB) {
            var dx = vertexA.x - vertexB.x;
            return dx !== 0 ? dx : vertexA.y - vertexB.y;
        });

        // build lower hull
        for (i = 0; i < vertices.length; i++) {
            vertex = vertices[i];

            while (lower.length >= 2 
                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {
                lower.pop();
            }

            lower.push(vertex);
        }

        // build upper hull
        for (i = vertices.length - 1; i >= 0; i--) {
            vertex = vertices[i];

            while (upper.length >= 2 
                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {
                upper.pop();
            }

            upper.push(vertex);
        }

        // concatenation of the lower and upper hulls gives the convex hull
        // omit last points because they are repeated at the beginning of the other list
        upper.pop();
        lower.pop();

        return upper.concat(lower);
    };

})();


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

var EventBinding = __webpack_require__(211);

var EventDispatcher = function ()
{
    this.bindings = {};
    this.filters = [];
    this.hasFilters = false;
};

EventDispatcher.prototype.constructor = EventDispatcher;

EventDispatcher.prototype = {

    getBinding: function (type)
    {
        if (this.bindings.hasOwnProperty(type))
        {
            return this.bindings[type];
        }
    },

    createBinding: function (type)
    {
        if (!this.getBinding(type))
        {
            this.bindings[type] = new EventBinding(this, type);
        }

        return this.bindings[type];
    },

    on: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, false);
        }

        return this;
    },

    once: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, true);
        }

        return this;
    },

    //  Add a callback that is notified every time this EventDispatcher dispatches an event
    //  no matter what the event type is. Filters are invoked first, before any bindings,
    //  and can stop events if they wish (in which case they'll never reach the bindings)
    filter: function (callback)
    {
        var i = this.filters.indexOf(callback);

        if (i === -1)
        {
            //  Add the filter
            this.filters.push(callback);
        }
        else
        {
            //  Remove the filter
            this.filters.splice(i, 1);
        }
        
        this.hasFilters = (this.filters.length > 0);

        return this;
    },

    has: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.has(listener);
        }
        else
        {
            return false;
        }
    },

    total: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.total();
        }
    },

    //  Removes an event listener.
    //  If there is no matching listener registered with the EventDispatcher, a call to this method has no effect.
    off: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.remove(listener);
        }

        return this;
    },

    _dispatchHandler: function (event)
    {
        event.reset(this);

        //  Pass the event through the filters first

        if (this.hasFilters)
        {
            for (var i = 0; i < this.filters.length; i++)
            {
                this.filters[i].call(this, event);

                //  Did the filter kill the event? If so, we can abort now
                if (!event._propagate)
                {
                    return;
                }
            }
        }

        var binding = this.getBinding(event.type);

        if (binding)
        {
            binding.dispatch(event);
        }
    },

    dispatch: function (event)
    {
        if (Array.isArray(event))
        {
            for (var i = 0; i < event.length; i++)
            {
                this._dispatchHandler(event[i]);
            }
        }
        else
        {
            this._dispatchHandler(event);
        }
    },

    //  Removes all listeners, but retains the event type entries
    removeAll: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.removeAll();
        }

        return this;
    },

    removeAllFilters: function ()
    {
        this.filters.length = 0;

        this.hasFilters = false;

        return this;
    },

    delete: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.destroy();

            delete this.bindings[type];
        }

        return this;
    },

    deleteAll: function ()
    {
        for (var binding in this.bindings)
        {
            binding.destroy();
        }

        this.bindings = {};
    },

    destroy: function ()
    {
        this.deleteAll();
        this.removeAllFilters();
    }

};

module.exports = EventDispatcher;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Class = __webpack_require__(9);

/**
* This is the base Game Object class that you can use when creating your own extended Game Objects.
*
* @class
*/

var GameObject = new Class({

    initialize:

    function GameObject (state)
    {
        this.state = state;

        this.id = 0;
        this.name = '';

        this.parent;

        //  0001 | 0010 | 0100 | 1000
        //  Will Render bitmask flags for the components Visible, Alpha, Transform and Texture respectively
        this.renderMask = 15;
        this.renderFlags = 15;
    },

    destroy: function ()
    {
        this.state = undefined;
        this.parent = undefined;
    }

});

module.exports = GameObject;


/***/ },
/* 25 */
/***/ function(module, exports) {


//  Encapsulates a 2D rectangle defined by its corner point in the top-left
//  and its extends in x (width) and y (height)

var Rectangle = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Rectangle.prototype.constructor = Rectangle;

Rectangle.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    }

};

Object.defineProperties(Rectangle.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Rectangle;


/***/ },
/* 26 */
/***/ function(module, exports) {

var mathCos = Math.cos;
var mathSin = Math.sin;
var mathSqrt = Math.sqrt;
var mathAcos = Math.acos;
var mathAtan = Math.atan;

var TransformMatrix = function (a, b, c, d, tx, ty) 
{
    a = typeof a === 'number' ? a : 1;
    b = typeof b === 'number' ? b : 0;
    c = typeof c === 'number' ? c : 0;
    d = typeof d === 'number' ? d : 1;
    tx = typeof tx === 'number' ? tx : 0;
    ty = typeof ty === 'number' ? ty : 0;

    this.matrix = new Float32Array([a, b, c, d, tx, ty, 0, 0, 1]);
    this.decomposedMatrix = {
        translateX: 0,
        translateY: 0,
        scaleX: 1,
        scaleY: 1,
        rotation: 0
    };
};

TransformMatrix.prototype.loadIdentity = function ()
{
    var matrix = this.matrix;
    
    matrix[0] = 1;
    matrix[1] = 0;
    matrix[2] = 0;
    matrix[3] = 1;
    matrix[4] = 0;
    matrix[5] = 0;

    return this;
};

TransformMatrix.prototype.translate = function (x, y)
{
    var matrix = this.matrix;

    matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];
    matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];

    return this;
};

TransformMatrix.prototype.scale = function (x, y)
{
    var matrix = this.matrix;

    matrix[0] = matrix[0] * x;
    matrix[1] = matrix[1] * x;
    matrix[2] = matrix[2] * y;
    matrix[3] = matrix[3] * y;

    return this;
};

TransformMatrix.prototype.rotate = function (radian)
{
    var radianSin = mathSin(radian);
    var radianCos = mathCos(radian);

    return this.transform(radianCos, -radianSin, radianSin, radianCos, 0, 0);
};

TransformMatrix.prototype.multiply = function (otherMatrix)
{
    var matrix = this.matrix;
    var a0 = matrix[0];
    var b0 = matrix[1];
    var c0 = matrix[2];
    var d0 = matrix[3];
    var tx0 = matrix[4];
    var ty0 = matrix[5];
    var a1 = otherMatrix[0];
    var b1 = otherMatrix[1];
    var c1 = otherMatrix[2];
    var d1 = otherMatrix[3];
    var tx1 = otherMatrix[4];
    var ty1 = otherMatrix[5];

    matrix[0] = a1 * a0 + b1 * c0;
    matrix[1] = a1 * b0 + b1 * d0;
    matrix[2] = c1 * a0 + d1 * c0;
    matrix[3] = c1 * b0 + d1 * d0;
    matrix[4] = tx1 * a0 + ty1 * c0 + tx0;
    matrix[5] = tx1 * b0 + ty1 * d0 + ty0;

    return this;
};

TransformMatrix.prototype.transform = function (a, b, c, d, tx, ty)
{
    var matrix = this.matrix;
    var a0 = matrix[0];
    var b0 = matrix[1];
    var c0 = matrix[2];
    var d0 = matrix[3];
    var tx0 = matrix[4];
    var ty0 = matrix[5];

    matrix[0] = a * a0 + b * c0;
    matrix[1] = a * b0 + b * d0;
    matrix[2] = c * a0 + d * c0;
    matrix[3] = c * b0 + d * d0;
    matrix[4] = tx * a0 + ty * c0 + tx0;
    matrix[5] = tx * b0 + ty * d0 + ty0;

    return this;
};

TransformMatrix.prototype.setTransform = function (a, b, c, d, tx, ty)
{
    var matrix = this.matrix;

    matrix[0] = a;
    matrix[1] = b;
    matrix[2] = c;
    matrix[3] = d;
    matrix[4] = tx;
    matrix[5] = ty;

    return this;
};

TransformMatrix.prototype.decomposeMatrix = function ()
{
    var decomposedMatrix = this.decomposedMatrix;
    var matrix = this.matrix;
    var a = matrix[0];
    var b = matrix[1];
    var c = matrix[2];
    var d = matrix[3];
    var a2 = a * a;
    var b2 = b * b;
    var c2 = c * c;
    var d2 = d * d;
    var sx = mathSqrt(a2 + c2);
    var sy = mathSqrt(b2 + d2);

    decomposedMatrix.translateX = matrix[4];
    decomposedMatrix.translateY = matrix[5];
    decomposedMatrix.scaleX = sx;
    decomposedMatrix.scaleY = sy;
    decomposedMatrix.rotation = mathAcos(a / sx) * (mathAtan(-c / a) < 0 ? -1 : 1);

    return decomposedMatrix;
};

/* identity + translate + rotate + scale */
TransformMatrix.prototype.applyITRS = function (x, y, rotation, scaleX, scaleY) 
{
    var matrix = this.matrix;
    var a = 1;
    var b = 0;
    var c = 0;
    var d = 1;
    var e = 0;
    var f = 0;
    var sr = mathSin(rotation);
    var cr = mathCos(rotation);

    // Translate
    matrix[4] = a * x + c * y + e;
    matrix[5] = b * x + d * y + f;

    // Rotate
    matrix[0] = cr * a + -sr * c;
    matrix[1] = cr * b + -sr * d;
    matrix[2] = sr * a + cr * c;
    matrix[3] = sr * b + cr * d;

    // Scale
    matrix[0] = matrix[0] * scaleX;
    matrix[1] = matrix[1] * scaleX;
    matrix[2] = matrix[2] * scaleY;
    matrix[3] = matrix[3] * scaleY;

    return this;
};

module.exports = TransformMatrix;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(19);

var Browser = {

    /**
    * @property {boolean} arora - Set to true if running in Arora.
    * @default
    */
    arora: false,

    /**
    * @property {boolean} chrome - Set to true if running in Chrome.
    * @default
    */
    chrome: false,

    /**
    * @property {number} chromeVersion - If running in Chrome this will contain the major version number.
    * @default
    */
    chromeVersion: 0,

    /**
    * @property {boolean} epiphany - Set to true if running in Epiphany.
    * @default
    */
    epiphany: false,

    /**
    * @property {boolean} firefox - Set to true if running in Firefox.
    * @default
    */
    firefox: false,

    /**
    * @property {number} firefoxVersion - If running in Firefox this will contain the major version number.
    * @default
    */
    firefoxVersion: 0,

    /**
    * @property {boolean} mobileSafari - Set to true if running in Mobile Safari.
    * @default
    */
    mobileSafari: false,

    /**
    * @property {boolean} ie - Set to true if running in Internet Explorer.
    * @default
    */
    ie: false,

    /**
    * @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.
    * @default
    */
    ieVersion: 0,

    /**
    * @property {boolean} midori - Set to true if running in Midori.
    * @default
    */
    midori: false,

    /**
    * @property {boolean} opera - Set to true if running in Opera.
    * @default
    */
    opera: false,

    /**
    * @property {boolean} safari - Set to true if running in Safari.
    * @default
    */
    safari: false,

    /**
    * @property {number} safariVersion - If running in Safari this will contain the major version number.
    * @default
    */
    safariVersion: 0,

    /**
    * @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)
    * @default
    */
    trident: false,

    /**
    * @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}
    * @default
    */
    tridentVersion: 0,

    /**
    * @property {boolean} edge - Set to true if running in Microsoft Edge browser.
    * @default
    */
    edge: false,

    /**
    * @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)
    * @default
    */
    silk: false

};

function init ()
{
    var ua = navigator.userAgent;

    if ((/Arora/).test(ua))
    {
        Browser.arora = true;
    }
    else if (/Edge\/\d+/.test(ua))
    {
        Browser.edge = true;
    }
    else if ((/Chrome\/(\d+)/).test(ua) && !OS.windowsPhone)
    {
        Browser.chrome = true;
        Browser.chromeVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Epiphany/).test(ua))
    {
        Browser.epiphany = true;
    }
    else if ((/Firefox\D+(\d+)/).test(ua))
    {
        Browser.firefox = true;
        Browser.firefoxVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/AppleWebKit/).test(ua) && OS.iOS)
    {
        Browser.mobileSafari = true;
    }
    else if ((/MSIE (\d+\.\d+);/).test(ua))
    {
        Browser.ie = true;
        Browser.ieVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Midori/).test(ua))
    {
        Browser.midori = true;
    }
    else if ((/Opera/).test(ua))
    {
        Browser.opera = true;
    }
    else if ((/Safari/).test(ua) && !OS.windowsPhone)
    {
        Browser.safari = true;
    }
    else if ((/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/).test(ua))
    {
        Browser.ie = true;
        Browser.trident = true;
        Browser.tridentVersion = parseInt(RegExp.$1, 10);
        Browser.ieVersion = parseInt(RegExp.$3, 10);
    }

    //  Silk gets its own if clause because its ua also contains 'Safari'
    if ((/Silk/).test(ua))
    {
        Browser.silk = true;
    }

    return Browser;
}

module.exports = init();


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);

/**
 * The pool into which the canvas elements are placed.
 *
 * @property pool
 * @type Array
 */
var pool = [];

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games on the same page
//  can share the one single pool

/**
* The CanvasPool is a global static object, that allows Phaser to recycle and pool Canvas DOM elements.
*
* @class Phaser.CanvasPool
* @static
*/
var CanvasPool = function ()
{
    /**
    * Creates a new Canvas DOM element, or pulls one from the pool if free.
    *
    * @method Phaser.CanvasPool.create
    * @static
    * @param {any} parent - The parent of the canvas element.
    * @param {number} width - The width of the canvas element.
    * @param {number} height - The height of the canvas element.
    * @return {HTMLCanvasElement} The canvas element.
    */
    var create = function (parent, width, height, type)
    {
        if (width === undefined) { width = 1; }
        if (height === undefined) { height = 1; }
        if (type === undefined) { type = CONST.CANVAS; }

        var canvas;
        var container = first(type);

        if (container === null)
        {
            // console.log('CanvasPool.create new');

            container = {
                parent: parent,
                canvas: document.createElement('canvas'),
                type: type
            };

            pool.push(container);

            canvas = container.canvas;
        }
        else
        {
            // console.log('CanvasPool.create existing');

            container.parent = parent;

            canvas = container.canvas;
        }

        canvas.width = width;
        canvas.height = height;
        
        return canvas;
    };

    var create2D = function (parent, width, height)
    {
        return create(parent, width, height, CONST.CANVAS);
    };

    var createWebGL = function (parent, width, height)
    {
        return create(parent, width, height, CONST.WEBGL);
    };

    /**
    * Gets the first free canvas index from the pool.
    *
    * @static
    * @method Phaser.CanvasPool.getFirst
    * @return {number}
    */
    var first = function (type)
    {
        if (type === undefined) { type = CONST.CANVAS; }

        pool.forEach(function (container)
        {
            if (!container.parent && container.type === type)
            {
                return container;
            }
        });

        return null;
    };

    /**
    * Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.
    * The canvas has its width and height set to 1, and its parent attribute nulled.
    * 
    * @static
    * @method Phaser.CanvasPool.remove
    * @param {any|HTMLCanvasElement} parent - The parent of the canvas element.
    */
    var remove = function (parent)
    {
        //  Check to see if the parent is a canvas object
        var isCanvas = parent instanceof HTMLCanvasElement;

        pool.forEach(function (container)
        {
            if ((isCanvas && container.canvas === parent) || (!isCanvas && container.parent === parent))
            {
                // console.log('CanvasPool.remove found and removed');
                container.parent = null;
                container.canvas.width = 1;
                container.canvas.height = 1;
            }
        });
    };

    /**
    * Gets the total number of used canvas elements in the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getTotal
    * @return {number} The number of in-use (parented) canvas elements in the pool.
    */
    var total = function ()
    {
        var c = 0;

        pool.forEach(function (container)
        {
            if (container.parent)
            {
                c++;
            }
        });

        return c;
    };

    /**
    * Gets the total number of free canvas elements in the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getFree
    * @return {number} The number of free (un-parented) canvas elements in the pool.
    */
    var free = function ()
    {
        return pool.length - total();
    };

    return {
        create: create,
        create2D: create2D,
        createWebGL: createWebGL,
        first: first,
        remove: remove,
        total: total,
        free: free,
        pool: pool
    };
};

//  If we export the called function here, it'll only be invoked once (not every time it's required).
module.exports = CanvasPool();


/***/ },
/* 29 */
/***/ function(module, exports) {

var Angle = function (line)
{
    return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
};

module.exports = Angle;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

var GetColor = __webpack_require__(61);
var GetColor32 = __webpack_require__(122);

var Color = function (red, green, blue, alpha)
{
    if (red === undefined) { red = 0; }
    if (green === undefined) { green = 0; }
    if (blue === undefined) { blue = 0; }
    if (alpha === undefined) { alpha = 255; }

    //  All private
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 255;

    this.gl = [ 0.0, 0.0, 0.0, 1.0 ];

    this._color = 0;
    this._color32 = 0;
    this._rgba = '';

    this.dirty = true;

    this.setTo(red, green, blue, alpha);
};

Color.prototype.contrusctor = Color;

Color.prototype = {

    transparent: function ()
    {
        this.red = 0;
        this.green = 0;
        this.blue = 0;
        this.alpha = 0;

        this.dirty = true;

        return this.update();
    },

    //  Values are in the range 0 to 255
    setTo: function (red, green, blue, alpha)
    {
        if (alpha === undefined) { alpha = 255; }

        this.red = red;
        this.green = green;
        this.blue = blue;
        this.alpha = alpha;

        this.dirty = true;

        return this.update();
    },

    //  Values are in the range 0 to 1
    setGLTo: function (red, green, blue, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.redGL = red;
        this.greenGL = green;
        this.blueGL = blue;
        this.alphaGL = alpha;

        this.dirty = true;

        return this.update();
    },

    setFromRGB: function (color)
    {
        this.red = color.r;
        this.green = color.g;
        this.blue = color.b;

        if (color.hasOwnProperty('a'))
        {
            this.alpha = color.a;
        }

        this.dirty = true;

        return this.update();
    },

    update: function ()
    {
        if (!this.dirty)
        {
            return this;
        }

        this._color = GetColor(this.r, this.g, this.b);
        this._color32 = GetColor32(this.r, this.g, this.b, this.a);
        this._rgba = 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + (255 / this.a) + ')';

        this.dirty = false;

        return this;
    },

    //  Same as setRGB but performs safety checks on all the values given
    clone: function ()
    {
        return new Color(this.r, this.g, this.b, this.a);
    }

};

Object.defineProperties(Color.prototype, {

    color: {

        enumerable: true,

        get: function ()
        {
            if (this.dirty)
            {
                this.update();
            }

            return this._color;
        }

    },

    color32: {

        enumerable: true,

        get: function ()
        {
            if (this.dirty)
            {
                this.update();
            }

            return this._color32;
        }

    },

    rgba: {

        enumerable: true,

        get: function ()
        {
            if (this.dirty)
            {
                this.update();
            }

            return this._rgba;
        }

    },

    //  Gets and sets the red value, normalized to the 0 to 1 range
    redGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[0];
        },

        set: function (value)
        {
            this.gl[0] = Math.min(Math.abs(value), 1);

            this.r = Math.floor(this.gl[0] * 255);

            this.dirty = true;
        }

    },

    greenGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[1];
        },

        set: function (value)
        {
            this.gl[1] = Math.min(Math.abs(value), 1);

            this.g = Math.floor(this.gl[1] * 255);

            this.dirty = true;
        }

    },

    blueGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[2];
        },

        set: function (value)
        {
            this.gl[2] = Math.min(Math.abs(value), 1);

            this.b = Math.floor(this.gl[2] * 255);

            this.dirty = true;
        }

    },

    alphaGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[3];
        },

        set: function (value)
        {
            this.gl[3] = Math.min(Math.abs(value), 1);

            this.a = Math.floor(this.gl[3] * 255);

            this.dirty = true;
        }

    },

    //  Gets and sets the red value, normalized to the 0 to 255 range
    red: {

        enumerable: true,

        get: function ()
        {
            return this.r;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.r = Math.min(value, 255);

            this.gl[0] = value / 255;

            this.dirty = true;
        }

    },

    green: {

        enumerable: true,

        get: function ()
        {
            return this.g;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.g = Math.min(value, 255);

            this.gl[1] = value / 255;

            this.dirty = true;
        }

    },

    blue: {

        enumerable: true,

        get: function ()
        {
            return this.b;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.b = Math.min(value, 255);

            this.gl[2] = value / 255;

            this.dirty = true;
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this.a;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.a = Math.min(value, 255);

            this.gl[3] = value / 255;

            this.dirty = true;
        }

    },

});


module.exports = Color;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

var GetURL = __webpack_require__(393);
var CONST = __webpack_require__(10);
var XHRLoader = __webpack_require__(394);
var XHRSettings = __webpack_require__(63);
var MergeXHRSettings = __webpack_require__(134);

var File = function (type, key, url, responseType, xhrSettings, config)
{
    //  file type (image, json, etc) for sorting within the Loader
    this.type = type;

    //  unique cache key (unique within its file type)
    this.key = key;

    //  The URL of the file, not including baseURL
    this.url = url;

    //  Set when the Loader calls 'load' on this file
    this.src = '';

    this.xhrSettings = XHRSettings(responseType);

    if (xhrSettings)
    {
        this.xhrSettings = MergeXHRSettings(this.xhrSettings, xhrSettings);
    }

    this.xhrLoader = null;

    this.state = CONST.FILE_PENDING;

    //  Set by onProgress (only if loading via XHR)
    this.bytesTotal = 0;
    this.bytesLoaded = -1;
    this.percentComplete = -1;

    //  For CORs based loading.
    //  If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)
    this.crossOrigin = undefined;

    //  The actual processed file data
    this.data = undefined;

    //  A config object that can be used by file types to store transitional data
    this.config = config || {};

    //  Multipart file? (i.e. an atlas and its json together)
    this.linkFile = undefined;
    this.linkType = '';

    this.callback = null;
};

File.prototype.constructor = File;

File.prototype = {

    resetXHR: function ()
    {
        this.xhrLoader.onload = undefined;
        this.xhrLoader.onerror = undefined;
        this.xhrLoader.onprogress = undefined;
    },

    //  Called when the Image loads
    //  ProgressEvent
    onLoad: function (event)
    {
        this.resetXHR();

        this.callback(this, true);
    },

    onError: function (event)
    {
        this.resetXHR();

        this.callback(this, false);
    },

    onProgress: function (event)
    {
        if (event.lengthComputable)
        {
            this.bytesLoaded = event.loaded;
            this.bytesTotal = event.total;

            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);
        }

        // console.log(this.percentComplete + '% (' + this.bytesLoaded + ' bytes)');
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.onComplete();

        callback(this);
    },

    onComplete: function ()
    {
        if (this.linkFile)
        {
            if (this.linkFile.state === CONST.FILE_WAITING_LINKFILE)
            {
                //  The linkfile has finished processing, and is waiting for this file, so let's do them both
                this.state = CONST.FILE_COMPLETE;
                this.linkFile.state = CONST.FILE_COMPLETE;
            }
            else
            {
                //  The linkfile still hasn't finished loading and/or processing yet
                this.state = CONST.FILE_WAITING_LINKFILE;
            }
        }
        else
        {
            this.state = CONST.FILE_COMPLETE;
        }
    },

    //  Called by the Loader, starts the actual file downloading
    load: function (callback, baseURL, globalXHR)
    {
        if (baseURL === undefined) { baseURL = ''; }

        this.callback = callback;

        this.src = GetURL(this, baseURL);

        if (this.src.indexOf('data:') === 0)
        {
            console.log('Local data URI');
        }
        else
        {
            this.xhrLoader = XHRLoader(this, globalXHR);
        }
    }
};

module.exports = File;


/***/ },
/* 32 */
/***/ function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var GetCenterX = function (gameObject)
{
    return gameObject.x - (gameObject.width * gameObject.anchorX) + (gameObject.width * 0.5);
};

module.exports = GetCenterX;


/***/ },
/* 33 */
/***/ function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var GetCenterY = function (gameObject)
{
    return gameObject.y - (gameObject.height * gameObject.anchorY) + (gameObject.height * 0.5);
};

module.exports = GetCenterY;


/***/ },
/* 34 */
/***/ function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

//  Phaser.Utils.Bounds.GetCenterX(bob)
//  Phaser.Utils.Bounds.CenterOn(bob, x, y)
//  Phaser.Utils.Bounds.CenterX(bob, x)
//  Phaser.Utils.Bounds.CenterY(bob, x)

var SetCenterX = function (gameObject, x)
{
    var offsetX = gameObject.width * gameObject.anchorX;

    gameObject.x = (x + offsetX) - (gameObject.width * 0.5);

    return gameObject;
};

module.exports = SetCenterX;


/***/ },
/* 35 */
/***/ function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

//  Phaser.Utils.Bounds.GetCenterX(bob)
//  Phaser.Utils.Bounds.CenterOn(bob, x, y)
//  Phaser.Utils.Bounds.CenterX(bob, x)
//  Phaser.Utils.Bounds.CenterY(bob, x)

var SetCenterY = function (gameObject, y)
{
    var offsetY = gameObject.height * gameObject.anchorY;

    gameObject.y = (y + offsetY) - (gameObject.height * 0.5);

    return gameObject;
};

module.exports = SetCenterY;


/***/ },
/* 36 */
/***/ function(module, exports) {

//  Source object
//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
//  The default value to use if the key doesn't exist

var GetObjectValue = function (source, key, defaultValue)
{
    if (key.indexOf('.'))
    {
        var keys = key.split('.');
        var parent = source;
        var value = defaultValue;

        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++)
        {
            if (parent.hasOwnProperty(keys[i]))
            {
                //  Yes it has a key property, let's carry on down
                value = parent[keys[i]];

                parent = parent[keys[i]];
            }
            else
            {
                break;
            }
        }

        return value;
    }
    else
    {
        return (source.hasOwnProperty(key)) ? source[key] : defaultValue;
    }
};

module.exports = GetObjectValue;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(31);

var ImageFile = function (key, url, path, xhrSettings, options)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.image\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.png';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'image', key, url, 'blob', xhrSettings, options);
};

ImageFile.prototype = Object.create(File.prototype);
ImageFile.prototype.constructor = ImageFile;

ImageFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = new Image();

    this.data.crossOrigin = this.crossOrigin;

    var _this = this;

    this.data.onload = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.onComplete();

        callback(_this);
    };

    this.data.onerror = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.state = CONST.FILE_ERRORED;

        callback(_this);
    };

    this.data.src = URL.createObjectURL(this.xhrLoader.response);
};

module.exports = ImageFile;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Body` module contains methods for creating and manipulating body models.
* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).

* @class Body
*/

var Body = {};

module.exports = Body;

var Vertices = __webpack_require__(22);
var Vector = __webpack_require__(4);
var Sleeping = __webpack_require__(40);
var Render = __webpack_require__(71);
var Common = __webpack_require__(0);
var Bounds = __webpack_require__(3);
var Axes = __webpack_require__(70);

(function() {

    Body._inertiaScale = 4;
    Body._nextCollidingGroupId = 1;
    Body._nextNonCollidingGroupId = -1;
    Body._nextCategory = 0x0001;

    /**
     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * Vertices must be specified in clockwise order.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {body} body
     */
    Body.create = function(options) {
        var defaults = {
            id: Common.nextId(),
            type: 'body',
            label: 'Body',
            parts: [],
            plugin: {},
            angle: 0,
            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),
            position: { x: 0, y: 0 },
            force: { x: 0, y: 0 },
            torque: 0,
            positionImpulse: { x: 0, y: 0 },
            constraintImpulse: { x: 0, y: 0, angle: 0 },
            totalContacts: 0,
            speed: 0,
            angularSpeed: 0,
            velocity: { x: 0, y: 0 },
            angularVelocity: 0,
            isSensor: false,
            isStatic: false,
            isSleeping: false,
            motion: 0,
            sleepThreshold: 60,
            density: 0.001,
            restitution: 0,
            friction: 0.1,
            frictionStatic: 0.5,
            frictionAir: 0.01,
            collisionFilter: {
                category: 0x0001,
                mask: 0xFFFFFFFF,
                group: 0
            },
            slop: 0.05,
            timeScale: 1,
            render: {
                visible: true,
                opacity: 1,
                sprite: {
                    xScale: 1,
                    yScale: 1,
                    xOffset: 0,
                    yOffset: 0
                },
                lineWidth: 0
            }
        };

        var body = Common.extend(defaults, options);

        _initProperties(body, options);

        return body;
    };

    /**
     * Returns the next unique group index for which bodies will collide.
     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
     * See `body.collisionFilter` for more information.
     * @method nextGroup
     * @param {bool} [isNonColliding=false]
     * @return {Number} Unique group index
     */
    Body.nextGroup = function(isNonColliding) {
        if (isNonColliding)
            return Body._nextNonCollidingGroupId--;

        return Body._nextCollidingGroupId++;
    };

    /**
     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).
     * There are 32 available. See `body.collisionFilter` for more information.
     * @method nextCategory
     * @return {Number} Unique category bitfield
     */
    Body.nextCategory = function() {
        Body._nextCategory = Body._nextCategory << 1;
        return Body._nextCategory;
    };

    /**
     * Initialises body properties.
     * @method _initProperties
     * @private
     * @param {body} body
     * @param {} [options]
     */
    var _initProperties = function(body, options) {
        options = options || {};

        // init required properties (order is important)
        Body.set(body, {
            bounds: body.bounds || Bounds.create(body.vertices),
            positionPrev: body.positionPrev || Vector.clone(body.position),
            anglePrev: body.anglePrev || body.angle,
            vertices: body.vertices,
            parts: body.parts || [body],
            isStatic: body.isStatic,
            isSleeping: body.isSleeping,
            parent: body.parent || body
        });

        Vertices.rotate(body.vertices, body.angle, body.position);
        Axes.rotate(body.axes, body.angle);
        Bounds.update(body.bounds, body.vertices, body.velocity);

        // allow options to override the automatically calculated properties
        Body.set(body, {
            axes: options.axes || body.axes,
            area: options.area || body.area,
            mass: options.mass || body.mass,
            inertia: options.inertia || body.inertia
        });

        // render properties
        var defaultFillStyle = (body.isStatic ? '#2e2b44' : Common.choose(['#006BA6', '#0496FF', '#FFBC42', '#D81159', '#8F2D56'])),
            defaultStrokeStyle = Common.shadeColor(defaultFillStyle, -20);
        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;
        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;
        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);
        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);
    };

    /**
     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
     * Prefer to use the actual setter functions in performance critical situations.
     * @method set
     * @param {body} body
     * @param {} settings A property name (or map of properties and values) to set on the body.
     * @param {} value The value to set if `settings` is a single property name.
     */
    Body.set = function(body, settings, value) {
        var property;

        if (typeof settings === 'string') {
            property = settings;
            settings = {};
            settings[property] = value;
        }

        for (property in settings) {
            value = settings[property];

            if (!settings.hasOwnProperty(property))
                continue;

            switch (property) {

            case 'isStatic':
                Body.setStatic(body, value);
                break;
            case 'isSleeping':
                Sleeping.set(body, value);
                break;
            case 'mass':
                Body.setMass(body, value);
                break;
            case 'density':
                Body.setDensity(body, value);
                break;
            case 'inertia':
                Body.setInertia(body, value);
                break;
            case 'vertices':
                Body.setVertices(body, value);
                break;
            case 'position':
                Body.setPosition(body, value);
                break;
            case 'angle':
                Body.setAngle(body, value);
                break;
            case 'velocity':
                Body.setVelocity(body, value);
                break;
            case 'angularVelocity':
                Body.setAngularVelocity(body, value);
                break;
            case 'parts':
                Body.setParts(body, value);
                break;
            default:
                body[property] = value;

            }
        }
    };

    /**
     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
     * @method setStatic
     * @param {body} body
     * @param {bool} isStatic
     */
    Body.setStatic = function(body, isStatic) {
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.isStatic = isStatic;

            if (isStatic) {
                part._original = {
                    restitution: part.restitution,
                    friction: part.friction,
                    mass: part.mass,
                    inertia: part.inertia,
                    density: part.density,
                    inverseMass: part.inverseMass,
                    inverseInertia: part.inverseInertia
                };

                part.restitution = 0;
                part.friction = 1;
                part.mass = part.inertia = part.density = Infinity;
                part.inverseMass = part.inverseInertia = 0;

                part.positionPrev.x = part.position.x;
                part.positionPrev.y = part.position.y;
                part.anglePrev = part.angle;
                part.angularVelocity = 0;
                part.speed = 0;
                part.angularSpeed = 0;
                part.motion = 0;
            } else if (part._original) {
                part.restitution = part._original.restitution;
                part.friction = part._original.friction;
                part.mass = part._original.mass;
                part.inertia = part._original.inertia;
                part.density = part._original.density;
                part.inverseMass = part._original.inverseMass;
                part.inverseInertia = part._original.inverseInertia;

                delete part._original;
            }
        }
    };

    /**
     * Sets the mass of the body. Inverse mass and density are automatically updated to reflect the change.
     * @method setMass
     * @param {body} body
     * @param {number} mass
     */
    Body.setMass = function(body, mass) {
        body.mass = mass;
        body.inverseMass = 1 / body.mass;
        body.density = body.mass / body.area;
    };

    /**
     * Sets the density of the body. Mass is automatically updated to reflect the change.
     * @method setDensity
     * @param {body} body
     * @param {number} density
     */
    Body.setDensity = function(body, density) {
        Body.setMass(body, density * body.area);
        body.density = density;
    };

    /**
     * Sets the moment of inertia (i.e. second moment of area) of the body of the body. 
     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
     * @method setInertia
     * @param {body} body
     * @param {number} inertia
     */
    Body.setInertia = function(body, inertia) {
        body.inertia = inertia;
        body.inverseInertia = 1 / body.inertia;
    };

    /**
     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
     * They are then automatically translated to world space based on `body.position`.
     *
     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
     * Vertices must form a convex hull, concave hulls are not supported.
     *
     * @method setVertices
     * @param {body} body
     * @param {vector[]} vertices
     */
    Body.setVertices = function(body, vertices) {
        // change vertices
        if (vertices[0].body === body) {
            body.vertices = vertices;
        } else {
            body.vertices = Vertices.create(vertices, body);
        }

        // update properties
        body.axes = Axes.fromVertices(body.vertices);
        body.area = Vertices.area(body.vertices);
        Body.setMass(body, body.density * body.area);

        // orient vertices around the centre of mass at origin (0, 0)
        var centre = Vertices.centre(body.vertices);
        Vertices.translate(body.vertices, centre, -1);

        // update inertia while vertices are at origin (0, 0)
        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));

        // update geometry
        Vertices.translate(body.vertices, body.position);
        Bounds.update(body.bounds, body.vertices, body.velocity);
    };

    /**
     * Sets the parts of the `body` and updates mass, inertia and centroid.
     * Each part will have its parent set to `body`.
     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
     * @method setParts
     * @param {body} body
     * @param [body] parts
     * @param {bool} [autoHull=true]
     */
    Body.setParts = function(body, parts, autoHull) {
        var i;

        // add all the parts, ensuring that the first part is always the parent body
        parts = parts.slice(0);
        body.parts.length = 0;
        body.parts.push(body);
        body.parent = body;

        for (i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part !== body) {
                part.parent = body;
                body.parts.push(part);
            }
        }

        if (body.parts.length === 1)
            return;

        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;

        // find the convex hull of all parts to set on the parent body
        if (autoHull) {
            var vertices = [];
            for (i = 0; i < parts.length; i++) {
                vertices = vertices.concat(parts[i].vertices);
            }

            Vertices.clockwiseSort(vertices);

            var hull = Vertices.hull(vertices),
                hullCentre = Vertices.centre(hull);

            Body.setVertices(body, hull);
            Vertices.translate(body.vertices, hullCentre);
        }

        // sum the properties of all compound parts of the parent body
        var total = _totalProperties(body);

        body.area = total.area;
        body.parent = body;
        body.position.x = total.centre.x;
        body.position.y = total.centre.y;
        body.positionPrev.x = total.centre.x;
        body.positionPrev.y = total.centre.y;

        Body.setMass(body, total.mass);
        Body.setInertia(body, total.inertia);
        Body.setPosition(body, total.centre);
    };

    /**
     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
     * @method setPosition
     * @param {body} body
     * @param {vector} position
     */
    Body.setPosition = function(body, position) {
        var delta = Vector.sub(position, body.position);
        body.positionPrev.x += delta.x;
        body.positionPrev.y += delta.y;

        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.position.x += delta.x;
            part.position.y += delta.y;
            Vertices.translate(part.vertices, delta);
            Bounds.update(part.bounds, part.vertices, body.velocity);
        }
    };

    /**
     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
     * @method setAngle
     * @param {body} body
     * @param {number} angle
     */
    Body.setAngle = function(body, angle) {
        var delta = angle - body.angle;
        body.anglePrev += delta;

        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.angle += delta;
            Vertices.rotate(part.vertices, delta, body.position);
            Axes.rotate(part.axes, delta);
            Bounds.update(part.bounds, part.vertices, body.velocity);
            if (i > 0) {
                Vector.rotateAbout(part.position, delta, body.position, part.position);
            }
        }
    };

    /**
     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setVelocity
     * @param {body} body
     * @param {vector} velocity
     */
    Body.setVelocity = function(body, velocity) {
        body.positionPrev.x = body.position.x - velocity.x;
        body.positionPrev.y = body.position.y - velocity.y;
        body.velocity.x = velocity.x;
        body.velocity.y = velocity.y;
        body.speed = Vector.magnitude(body.velocity);
    };

    /**
     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setAngularVelocity
     * @param {body} body
     * @param {number} velocity
     */
    Body.setAngularVelocity = function(body, velocity) {
        body.anglePrev = body.angle - velocity;
        body.angularVelocity = velocity;
        body.angularSpeed = Math.abs(body.angularVelocity);
    };

    /**
     * Moves a body by a given vector relative to its current position, without imparting any velocity.
     * @method translate
     * @param {body} body
     * @param {vector} translation
     */
    Body.translate = function(body, translation) {
        Body.setPosition(body, Vector.add(body.position, translation));
    };

    /**
     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
     * @method rotate
     * @param {body} body
     * @param {number} rotation
     */
    Body.rotate = function(body, rotation) {
        Body.setAngle(body, body.angle + rotation);
    };

    /**
     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
     * @method scale
     * @param {body} body
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} [point]
     */
    Body.scale = function(body, scaleX, scaleY, point) {
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];

            // scale vertices
            Vertices.scale(part.vertices, scaleX, scaleY, body.position);

            // update properties
            part.axes = Axes.fromVertices(part.vertices);

            if (!body.isStatic) {
                part.area = Vertices.area(part.vertices);
                Body.setMass(part, body.density * part.area);

                // update inertia (requires vertices to be at origin)
                Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });
                Body.setInertia(part, Vertices.inertia(part.vertices, part.mass));
                Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });
            }

            // update bounds
            Bounds.update(part.bounds, part.vertices, body.velocity);
        }

        // handle circles
        if (body.circleRadius) { 
            if (scaleX === scaleY) {
                body.circleRadius *= scaleX;
            } else {
                // body is no longer a circle
                body.circleRadius = null;
            }
        }

        if (!body.isStatic) {
            var total = _totalProperties(body);
            body.area = total.area;
            Body.setMass(body, total.mass);
            Body.setInertia(body, total.inertia);
        }
    };

    /**
     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
     * @method update
     * @param {body} body
     * @param {number} deltaTime
     * @param {number} timeScale
     * @param {number} correction
     */
    Body.update = function(body, deltaTime, timeScale, correction) {
        var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);

        // from the previous step
        var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,
            velocityPrevX = body.position.x - body.positionPrev.x,
            velocityPrevY = body.position.y - body.positionPrev.y;

        // update velocity with Verlet integration
        body.velocity.x = (velocityPrevX * frictionAir * correction) + (body.force.x / body.mass) * deltaTimeSquared;
        body.velocity.y = (velocityPrevY * frictionAir * correction) + (body.force.y / body.mass) * deltaTimeSquared;

        body.positionPrev.x = body.position.x;
        body.positionPrev.y = body.position.y;
        body.position.x += body.velocity.x;
        body.position.y += body.velocity.y;

        // update angular velocity with Verlet integration
        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;
        body.anglePrev = body.angle;
        body.angle += body.angularVelocity;

        // track speed and acceleration
        body.speed = Vector.magnitude(body.velocity);
        body.angularSpeed = Math.abs(body.angularVelocity);

        // transform the body geometry
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];

            Vertices.translate(part.vertices, body.velocity);
            
            if (i > 0) {
                part.position.x += body.velocity.x;
                part.position.y += body.velocity.y;
            }

            if (body.angularVelocity !== 0) {
                Vertices.rotate(part.vertices, body.angularVelocity, body.position);
                Axes.rotate(part.axes, body.angularVelocity);
                if (i > 0) {
                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                }
            }

            Bounds.update(part.bounds, part.vertices, body.velocity);
        }
    };

    /**
     * Applies a force to a body from a given world-space position, including resulting torque.
     * @method applyForce
     * @param {body} body
     * @param {vector} position
     * @param {vector} force
     */
    Body.applyForce = function(body, position, force) {
        body.force.x += force.x;
        body.force.y += force.y;
        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };
        body.torque += offset.x * force.y - offset.y * force.x;
    };

    /**
     * Returns the sums of the properties of all compound parts of the parent body.
     * @method _totalProperties
     * @private
     * @param {body} body
     * @return {}
     */
    var _totalProperties = function(body) {
        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory
        // http://output.to/sideway/default.asp?qno=121100087

        var properties = {
            mass: 0,
            area: 0,
            inertia: 0,
            centre: { x: 0, y: 0 }
        };

        // sum the properties of all compound parts of the parent body
        for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {
            var part = body.parts[i];
            properties.mass += part.mass;
            properties.area += part.area;
            properties.inertia += part.inertia;
            properties.centre = Vector.add(properties.centre, 
                                           Vector.mult(part.position, part.mass !== Infinity ? part.mass : 1));
        }

        properties.centre = Vector.div(properties.centre, 
                                       properties.mass !== Infinity ? properties.mass : body.parts.length);

        return properties;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when a body starts sleeping (where `this` is the body).
    *
    * @event sleepStart
    * @this {body} The body that has started sleeping
    * @param {} event An event object
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a body ends sleeping (where `this` is the body).
    *
    * @event sleepEnd
    * @this {body} The body that has ended sleeping
    * @param {} event An event object
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "body"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     *
     * @property label
     * @type string
     * @default "Body"
     */

    /**
     * An array of bodies that make up this body. 
     * The first body in the array must always be a self reference to the current body instance.
     * All bodies in the `parts` array together form a single rigid compound body.
     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.
     * Parts themselves should never be added to a `World`, only the parent body should be.
     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.
     *
     * @property parts
     * @type body[]
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

    /**
     * A self reference if the body is _not_ a part of another body.
     * Otherwise this is a reference to the body that this is a part of.
     * See `body.parts`.
     *
     * @property parent
     * @type body
     */

    /**
     * A `Number` specifying the angle of the body, in radians.
     *
     * @property angle
     * @type number
     * @default 0
     */

    /**
     * An array of `Vector` objects that specify the convex hull of the rigid body.
     * These should be provided about the origin `(0, 0)`. E.g.
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).
     * The `Vector` objects are also augmented with additional properties required for efficient collision detection. 
     *
     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).
     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.
     *
     * @property vertices
     * @type vector[]
     */

    /**
     * A `Vector` that specifies the current world-space position of the body.
     *
     * @property position
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.
     *
     * @property force
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.
     *
     * @property torque
     * @type number
     * @default 0
     */

    /**
     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).
     *
     * @readOnly
     * @property speed
     * @type number
     * @default 0
     */

    /**
     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).
     *
     * @readOnly
     * @property angularSpeed
     * @type number
     * @default 0
     */

    /**
     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. 
     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).
     *
     * @readOnly
     * @property velocity
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. 
     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).
     *
     * @readOnly
     * @property angularVelocity
     * @type number
     * @default 0
     */

    /**
     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.
     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.
     *
     * @property isStatic
     * @type boolean
     * @default false
     */

    /**
     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.
     *
     * @property isSensor
     * @type boolean
     * @default false
     */

    /**
     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.
     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.
     *
     * @property isSleeping
     * @type boolean
     * @default false
     */

    /**
     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.
     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.
     *
     * @readOnly
     * @property motion
     * @type number
     * @default 0
     */

    /**
     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).
     *
     * @property sleepThreshold
     * @type number
     * @default 60
     */

    /**
     * A `Number` that defines the density of the body, that is its mass per unit area.
     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.
     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).
     *
     * @property density
     * @type number
     * @default 0.001
     */

    /**
     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.
     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).
     *
     * @property mass
     * @type number
     */

    /**
     * A `Number` that defines the inverse mass of the body (`1 / mass`).
     * If you modify this value, you must also modify the `body.mass` property.
     *
     * @property inverseMass
     * @type number
     */

    /**
     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.
     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.
     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).
     *
     * @property inertia
     * @type number
     */

    /**
     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).
     * If you modify this value, you must also modify the `body.inertia` property.
     *
     * @property inverseInertia
     * @type number
     */

    /**
     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. 
     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.
     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:
     *
     *     Math.max(bodyA.restitution, bodyB.restitution)
     *
     * @property restitution
     * @type number
     * @default 0
     */

    /**
     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means that the body may slide indefinitely.
     * A value of `1` means the body may come to a stop almost instantly after a force is applied.
     *
     * The effects of the value may be non-linear. 
     * High values may be unstable depending on the body.
     * The engine uses a Coulomb friction model including static and kinetic friction.
     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:
     *
     *     Math.min(bodyA.friction, bodyB.friction)
     *
     * @property friction
     * @type number
     * @default 0.1
     */

    /**
     * A `Number` that defines the static friction of the body (in the Coulomb friction model). 
     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.
     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.
     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.
     *
     * @property frictionStatic
     * @type number
     * @default 0.5
     */

    /**
     * A `Number` that defines the air friction of the body (air resistance). 
     * A value of `0` means the body will never slow as it moves through space.
     * The higher the value, the faster a body slows when moving through space.
     * The effects of the value are non-linear. 
     *
     * @property frictionAir
     * @type number
     * @default 0.01
     */

    /**
     * An `Object` that specifies the collision filtering properties of this body.
     *
     * Collisions between two bodies will obey the following rules:
     * - If the two bodies have the same non-zero value of `collisionFilter.group`,
     *   they will always collide if the value is positive, and they will never collide
     *   if the value is negative.
     * - If the two bodies have different values of `collisionFilter.group` or if one
     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:
     *
     * Each body belongs to a collision category, given by `collisionFilter.category`. This
     * value is used as a bit field and the category should have only one bit set, meaning that
     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32
     * different collision categories available.
     *
     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies
     * the categories it collides with (the value is the bitwise AND value of all these categories).
     *
     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's
     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`
     * are both true.
     *
     * @property collisionFilter
     * @type object
     */

    /**
     * An Integer `Number`, that specifies the collision group this body belongs to.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.group
     * @type object
     * @default 0
     */

    /**
     * A bit field that specifies the collision category this body belongs to.
     * The category value should have only one bit set, for example `0x0001`.
     * This means there are up to 32 unique collision categories available.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.category
     * @type object
     * @default 1
     */

    /**
     * A bit mask that specifies the collision categories this body may collide with.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.mask
     * @type object
     * @default -1
     */

    /**
     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.
     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.
     * The default should generally suffice, although very large bodies may require larger values for stable stacking.
     *
     * @property slop
     * @type number
     * @default 0.05
     */

    /**
     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.
     *
     * @property timeScale
     * @type number
     * @default 1
     */

    /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     *
     * @property render
     * @type object
     */

    /**
     * A flag that indicates if the body should be rendered.
     *
     * @property render.visible
     * @type boolean
     * @default true
     */

    /**
     * Sets the opacity to use when rendering.
     *
     * @property render.opacity
     * @type number
     * @default 1
    */

    /**
     * An `Object` that defines the sprite properties to use when rendering, if any.
     *
     * @property render.sprite
     * @type object
     */

    /**
     * An `String` that defines the path to the image to use as the sprite texture, if any.
     *
     * @property render.sprite.texture
     * @type string
     */
     
    /**
     * A `Number` that defines the scaling in the x-axis for the sprite, if any.
     *
     * @property render.sprite.xScale
     * @type number
     * @default 1
     */

    /**
     * A `Number` that defines the scaling in the y-axis for the sprite, if any.
     *
     * @property render.sprite.yScale
     * @type number
     * @default 1
     */

     /**
      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).
      *
      * @property render.sprite.xOffset
      * @type number
      * @default 0
      */

     /**
      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).
      *
      * @property render.sprite.yOffset
      * @type number
      * @default 0
      */

    /**
     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).
     * A value of `0` means no outline will be rendered.
     *
     * @property render.lineWidth
     * @type number
     * @default 1.5
     */

    /**
     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.fillStyle
     * @type string
     * @default a random colour
     */

    /**
     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.strokeStyle
     * @type string
     * @default a random colour
     */

    /**
     * An array of unique axis vectors (edge normals) used for collision detection.
     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.
     * They are constantly updated by `Body.update` during the simulation.
     *
     * @property axes
     * @type vector[]
     */
     
    /**
     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.
     *
     * @property area
     * @type string
     * @default 
     */

    /**
     * A `Bounds` object that defines the AABB region for the body.
     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.
     *
     * @property bounds
     * @type bounds
     */

})();


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Constraint` module contains methods for creating and manipulating constraints.
* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
* The stiffness of constraints can be modified to create springs or elastic.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Constraint
*/

// TODO: fix instability issues with torque
// TODO: linked constraints
// TODO: breakable constraints
// TODO: collision constraints
// TODO: allow constrained bodies to sleep
// TODO: handle 0 length constraints properly
// TODO: impulse caching and warming

var Constraint = {};

module.exports = Constraint;

var Vertices = __webpack_require__(22);
var Vector = __webpack_require__(4);
var Sleeping = __webpack_require__(40);
var Bounds = __webpack_require__(3);
var Axes = __webpack_require__(70);
var Common = __webpack_require__(0);

(function() {

    var _minLength = 0.000001,
        _minDifference = 0.001;

    /**
     * Creates a new constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {constraint} constraint
     */
    Constraint.create = function(options) {
        var constraint = options;

        // if bodies defined but no points, use body centre
        if (constraint.bodyA && !constraint.pointA)
            constraint.pointA = { x: 0, y: 0 };
        if (constraint.bodyB && !constraint.pointB)
            constraint.pointB = { x: 0, y: 0 };

        // calculate static length using initial world space points
        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,
            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,
            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
    
        constraint.length = constraint.length || length || _minLength;

        // render
        var render = {
            visible: true,
            lineWidth: 2,
            strokeStyle: '#ffffff'
        };
        
        constraint.render = Common.extend(render, constraint.render);

        // option defaults
        constraint.id = constraint.id || Common.nextId();
        constraint.label = constraint.label || 'Constraint';
        constraint.type = 'constraint';
        constraint.stiffness = constraint.stiffness || 1;
        constraint.angularStiffness = constraint.angularStiffness || 0;
        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
        constraint.plugin = {};

        return constraint;
    };

    /**
     * Solves all constraints in a list of collisions.
     * @private
     * @method solveAll
     * @param {constraint[]} constraints
     * @param {number} timeScale
     */
    Constraint.solveAll = function(constraints, timeScale) {
        for (var i = 0; i < constraints.length; i++) {
            Constraint.solve(constraints[i], timeScale);
        }
    };

    /**
     * Solves a distance constraint with Gauss-Siedel method.
     * @private
     * @method solve
     * @param {constraint} constraint
     * @param {number} timeScale
     */
    Constraint.solve = function(constraint, timeScale) {
        var bodyA = constraint.bodyA,
            bodyB = constraint.bodyB,
            pointA = constraint.pointA,
            pointB = constraint.pointB;

        // update reference angle
        if (bodyA && !bodyA.isStatic) {
            constraint.pointA = Vector.rotate(pointA, bodyA.angle - constraint.angleA);
            constraint.angleA = bodyA.angle;
        }
        
        // update reference angle
        if (bodyB && !bodyB.isStatic) {
            constraint.pointB = Vector.rotate(pointB, bodyB.angle - constraint.angleB);
            constraint.angleB = bodyB.angle;
        }

        var pointAWorld = pointA,
            pointBWorld = pointB;

        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);
        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);

        if (!pointAWorld || !pointBWorld)
            return;

        var delta = Vector.sub(pointAWorld, pointBWorld),
            currentLength = Vector.magnitude(delta);

        // prevent singularity
        if (currentLength === 0)
            currentLength = _minLength;

        // solve distance constraint with Gauss-Siedel method
        var difference = (currentLength - constraint.length) / currentLength,
            normal = Vector.div(delta, currentLength),
            force = Vector.mult(delta, difference * 0.5 * constraint.stiffness * timeScale * timeScale);
        
        // if difference is very small, we can skip
        if (Math.abs(1 - (currentLength / constraint.length)) < _minDifference * timeScale)
            return;

        var velocityPointA,
            velocityPointB,
            offsetA,
            offsetB,
            oAn,
            oBn,
            bodyADenom,
            bodyBDenom;
    
        if (bodyA && !bodyA.isStatic) {
            // point body offset
            offsetA = { 
                x: pointAWorld.x - bodyA.position.x + force.x, 
                y: pointAWorld.y - bodyA.position.y + force.y
            };
            
            // update velocity
            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
            
            // find point velocity and body mass
            velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity));
            oAn = Vector.dot(offsetA, normal);
            bodyADenom = bodyA.inverseMass + bodyA.inverseInertia * oAn * oAn;
        } else {
            velocityPointA = { x: 0, y: 0 };
            bodyADenom = bodyA ? bodyA.inverseMass : 0;
        }
            
        if (bodyB && !bodyB.isStatic) {
            // point body offset
            offsetB = { 
                x: pointBWorld.x - bodyB.position.x - force.x, 
                y: pointBWorld.y - bodyB.position.y - force.y 
            };
            
            // update velocity
            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;

            // find point velocity and body mass
            velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity));
            oBn = Vector.dot(offsetB, normal);
            bodyBDenom = bodyB.inverseMass + bodyB.inverseInertia * oBn * oBn;
        } else {
            velocityPointB = { x: 0, y: 0 };
            bodyBDenom = bodyB ? bodyB.inverseMass : 0;
        }
        
        var relativeVelocity = Vector.sub(velocityPointB, velocityPointA),
            normalImpulse = Vector.dot(normal, relativeVelocity) / (bodyADenom + bodyBDenom);
    
        if (normalImpulse > 0) normalImpulse = 0;
    
        var normalVelocity = {
            x: normal.x * normalImpulse, 
            y: normal.y * normalImpulse
        };

        var torque;
 
        if (bodyA && !bodyA.isStatic) {
            torque = Vector.cross(offsetA, normalVelocity) * bodyA.inverseInertia * (1 - constraint.angularStiffness);

            // keep track of applied impulses for post solving
            bodyA.constraintImpulse.x -= force.x;
            bodyA.constraintImpulse.y -= force.y;
            bodyA.constraintImpulse.angle += torque;

            // apply forces
            bodyA.position.x -= force.x;
            bodyA.position.y -= force.y;
            bodyA.angle += torque;
        }

        if (bodyB && !bodyB.isStatic) {
            torque = Vector.cross(offsetB, normalVelocity) * bodyB.inverseInertia * (1 - constraint.angularStiffness);

            // keep track of applied impulses for post solving
            bodyB.constraintImpulse.x += force.x;
            bodyB.constraintImpulse.y += force.y;
            bodyB.constraintImpulse.angle -= torque;
            
            // apply forces
            bodyB.position.x += force.x;
            bodyB.position.y += force.y;
            bodyB.angle -= torque;
        }

    };

    /**
     * Performs body updates required after solving constraints.
     * @private
     * @method postSolveAll
     * @param {body[]} bodies
     */
    Constraint.postSolveAll = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                impulse = body.constraintImpulse;

            if (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                continue;
            }

            Sleeping.set(body, false);

            // update geometry and reset
            for (var j = 0; j < body.parts.length; j++) {
                var part = body.parts[j];
                
                Vertices.translate(part.vertices, impulse);

                if (j > 0) {
                    part.position.x += impulse.x;
                    part.position.y += impulse.y;
                }

                if (impulse.angle !== 0) {
                    Vertices.rotate(part.vertices, impulse.angle, body.position);
                    Axes.rotate(part.axes, impulse.angle);
                    if (j > 0) {
                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
                    }
                }

                Bounds.update(part.bounds, part.vertices, body.velocity);
            }

            impulse.angle = 0;
            impulse.x = 0;
            impulse.y = 0;
        }
    };

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "constraint"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     *
     * @property label
     * @type string
     * @default "Constraint"
     */

    /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     *
     * @property render
     * @type object
     */

    /**
     * A flag that indicates if the constraint should be rendered.
     *
     * @property render.visible
     * @type boolean
     * @default true
     */

    /**
     * A `Number` that defines the line width to use when rendering the constraint outline.
     * A value of `0` means no outline will be rendered.
     *
     * @property render.lineWidth
     * @type number
     * @default 2
     */

    /**
     * A `String` that defines the stroke style to use when rendering the constraint outline.
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.strokeStyle
     * @type string
     * @default a random colour
     */

    /**
     * The first possible `Body` that this constraint is attached to.
     *
     * @property bodyA
     * @type body
     * @default null
     */

    /**
     * The second possible `Body` that this constraint is attached to.
     *
     * @property bodyB
     * @type body
     * @default null
     */

    /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
     *
     * @property pointA
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
     *
     * @property pointB
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.
     * A value of `1` means the constraint should be very stiff.
     * A value of `0.2` means the constraint acts like a soft spring.
     *
     * @property stiffness
     * @type number
     * @default 1
     */

    /**
     * A `Number` that specifies the target resting length of the constraint. 
     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
     *
     * @property length
     * @type number
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.
*
* @class Sleeping
*/

var Sleeping = {};

module.exports = Sleeping;

var Events = __webpack_require__(21);

(function() {

    Sleeping._motionWakeThreshold = 0.18;
    Sleeping._motionSleepThreshold = 0.08;
    Sleeping._minBias = 0.9;

    /**
     * Puts bodies to sleep or wakes them up depending on their motion.
     * @method update
     * @param {body[]} bodies
     * @param {number} timeScale
     */
    Sleeping.update = function(bodies, timeScale) {
        var timeFactor = timeScale * timeScale * timeScale;

        // update bodies sleeping status
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;

            // wake up bodies if they have a force applied
            if (body.force.x !== 0 || body.force.y !== 0) {
                Sleeping.set(body, false);
                continue;
            }

            var minMotion = Math.min(body.motion, motion),
                maxMotion = Math.max(body.motion, motion);
        
            // biased average motion estimation between frames
            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
            
            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {
                body.sleepCounter += 1;
                
                if (body.sleepCounter >= body.sleepThreshold)
                    Sleeping.set(body, true);
            } else if (body.sleepCounter > 0) {
                body.sleepCounter -= 1;
            }
        }
    };

    /**
     * Given a set of colliding pairs, wakes the sleeping bodies involved.
     * @method afterCollisions
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Sleeping.afterCollisions = function(pairs, timeScale) {
        var timeFactor = timeScale * timeScale * timeScale;

        // wake up bodies involved in collisions
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            
            // don't wake inactive pairs
            if (!pair.isActive)
                continue;

            var collision = pair.collision,
                bodyA = collision.bodyA.parent, 
                bodyB = collision.bodyB.parent;
        
            // don't wake if at least one body is static
            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)
                continue;
        
            if (bodyA.isSleeping || bodyB.isSleeping) {
                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,
                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;

                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {
                    Sleeping.set(sleepingBody, false);
                }
            }
        }
    };
  
    /**
     * Set a body as sleeping or awake.
     * @method set
     * @param {body} body
     * @param {boolean} isSleeping
     */
    Sleeping.set = function(body, isSleeping) {
        var wasSleeping = body.isSleeping;

        if (isSleeping) {
            body.isSleeping = true;
            body.sleepCounter = body.sleepThreshold;

            body.positionImpulse.x = 0;
            body.positionImpulse.y = 0;

            body.positionPrev.x = body.position.x;
            body.positionPrev.y = body.position.y;

            body.anglePrev = body.angle;
            body.speed = 0;
            body.angularSpeed = 0;
            body.motion = 0;

            if (!wasSleeping) {
                Events.trigger(body, 'sleepStart');
            }
        } else {
            body.isSleeping = false;
            body.sleepCounter = 0;

            if (wasSleeping) {
                Events.trigger(body, 'sleepEnd');
            }
        }
    };

})();


/***/ },
/* 41 */
/***/ function(module, exports) {

module.exports = {

    DEFAULT: 0,
    LINEAR: 0,
    NEAREST: 1

};


/***/ },
/* 42 */
/***/ function(module, exports) {

var Wrap = function (value, min, max)
{
    var range = max - min;

    if (range <= 0)
    {
        return 0;
    }

    if (value >= min && value <= max)
    {
        return value;
    }

    var result = (value - min) % range;

    if (result < 0)
    {
        result += range;
    }

    return result + min;
};

module.exports = Wrap;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.
*
* @class Pair
*/

var Pair = {};

module.exports = Pair;

var Contact = __webpack_require__(150);

(function() {
    
    /**
     * Creates a pair.
     * @method create
     * @param {collision} collision
     * @param {number} timestamp
     * @return {pair} A new pair
     */
    Pair.create = function(collision, timestamp) {
        var bodyA = collision.bodyA,
            bodyB = collision.bodyB,
            parentA = collision.parentA,
            parentB = collision.parentB;

        var pair = {
            id: Pair.id(bodyA, bodyB),
            bodyA: bodyA,
            bodyB: bodyB,
            contacts: {},
            activeContacts: [],
            separation: 0,
            isActive: true,
            isSensor: bodyA.isSensor || bodyB.isSensor,
            timeCreated: timestamp,
            timeUpdated: timestamp,
            inverseMass: parentA.inverseMass + parentB.inverseMass,
            friction: Math.min(parentA.friction, parentB.friction),
            frictionStatic: Math.max(parentA.frictionStatic, parentB.frictionStatic),
            restitution: Math.max(parentA.restitution, parentB.restitution),
            slop: Math.max(parentA.slop, parentB.slop)
        };

        Pair.update(pair, collision, timestamp);

        return pair;
    };

    /**
     * Updates a pair given a collision.
     * @method update
     * @param {pair} pair
     * @param {collision} collision
     * @param {number} timestamp
     */
    Pair.update = function(pair, collision, timestamp) {
        var contacts = pair.contacts,
            supports = collision.supports,
            activeContacts = pair.activeContacts,
            parentA = collision.parentA,
            parentB = collision.parentB;
        
        pair.collision = collision;
        pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
        pair.friction = Math.min(parentA.friction, parentB.friction);
        pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);
        pair.restitution = Math.max(parentA.restitution, parentB.restitution);
        pair.slop = Math.max(parentA.slop, parentB.slop);
        activeContacts.length = 0;
        
        if (collision.collided) {
            for (var i = 0; i < supports.length; i++) {
                var support = supports[i],
                    contactId = Contact.id(support),
                    contact = contacts[contactId];

                if (contact) {
                    activeContacts.push(contact);
                } else {
                    activeContacts.push(contacts[contactId] = Contact.create(support));
                }
            }

            pair.separation = collision.depth;
            Pair.setActive(pair, true, timestamp);
        } else {
            if (pair.isActive === true)
                Pair.setActive(pair, false, timestamp);
        }
    };
    
    /**
     * Set a pair as active or inactive.
     * @method setActive
     * @param {pair} pair
     * @param {bool} isActive
     * @param {number} timestamp
     */
    Pair.setActive = function(pair, isActive, timestamp) {
        if (isActive) {
            pair.isActive = true;
            pair.timeUpdated = timestamp;
        } else {
            pair.isActive = false;
            pair.activeContacts.length = 0;
        }
    };

    /**
     * Get the id for the given pair.
     * @method id
     * @param {body} bodyA
     * @param {body} bodyB
     * @return {string} Unique pairId
     */
    Pair.id = function(bodyA, bodyB) {
        if (bodyA.id < bodyB.id) {
            return 'A' + bodyA.id + 'B' + bodyB.id;
        } else {
            return 'A' + bodyB.id + 'B' + bodyA.id;
        }
    };

})();


/***/ },
/* 44 */
/***/ function(module, exports) {

var Buffer32 = function (byteSize)
{
    this.dwordLength = 0;
    this.dwordCapacity = byteSize / 4;
    this.buffer = new ArrayBuffer(byteSize);
    this.floatView = new Float32Array(this.buffer);
    this.intView = new Int32Array(this.buffer);
    this.uintView = new Uint32Array(this.buffer);
};

Buffer32.prototype.clear = function ()
{
    this.dwordLength = 0;
};

Buffer32.prototype.getByteLength = function ()
{
    return this.dwordLength * 4;
};

Buffer32.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

Buffer32.prototype.allocate = function (dwordSize)
{
    var currentLength = this.dwordLength;
    this.dwordLength += dwordSize;
    return currentLength;
};

Buffer32.prototype.getUsedBufferAsFloat = function ()
{
    return this.floatView.subarray(0, this.dwordLength);
};

Buffer32.prototype.getUsedBufferAsInt = function ()
{
    return this.intView.subarray(0, this.dwordLength);
};

Buffer32.prototype.getUsedBufferAsUint = function ()
{
    return this.uintView.subarray(0, this.dwordLength);
};

module.exports = Buffer32;


/***/ },
/* 45 */
/***/ function(module, exports) {

var CreateBuffer = function (gl, bufferType, usage, bufferData, bufferSize)
{
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    if (bufferData && ArrayBuffer.isView(bufferData))
    {
        gl.bufferData(bufferType, bufferData, usage);
    }
    else
    {
        gl.bufferData(bufferType, bufferSize, usage);
    }
    return buffer;
};

module.exports = CreateBuffer;


/***/ },
/* 46 */
/***/ function(module, exports) {

var CreateProgram = function (gl, vertexShader, fragmentShader)
{
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Failed to link program. Error: \n' + gl.getProgramInfoLog(program));
        return null;
    }
    return program;
};

module.exports = CreateProgram;


/***/ },
/* 47 */
/***/ function(module, exports) {

var CreateShader = function (gl, shaderSource, shaderType)
{
    var shader = null;
    shader = gl.createShader(shaderType);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        console.error('Failed ' + (shaderType === gl.VERTEX_SHADER ? 'vertex' : shaderType === gl.FRAGMENT_SHADER ? 'fragment' : 'invalid') + ' shader compilation. Error: \n' + gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
};

module.exports = CreateShader;


/***/ },
/* 48 */
/***/ function(module, exports) {

var BindVertexArray = function (gl, vao)
{
    var attributes = vao.attributes;
    gl.bindBuffer(gl.ARRAY_BUFFER, vao.buffer);
    for (var index = 0, length = attributes.length; index < length; ++index)
    {
        var attrib = attributes[index];
        var location = attrib.location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(
            location,
            attrib.size,
            attrib.type,
            attrib.normalized,
            attrib.stride,
            attrib.offset
        );
    }
};

module.exports = BindVertexArray;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

var Attribute = __webpack_require__(503);

var CreateAttribDesc = function (gl, program, name, size, type, normalized, stride, offset)
{
    return new Attribute(
        gl.getAttribLocation(program, name),
        size,
        type,
        normalized,
        stride,
        offset
    );
};

module.exports = CreateAttribDesc;


/***/ },
/* 50 */
/***/ function(module, exports) {

var VertexArray = function (vbo, attributes)
{
    this.buffer = vbo;
    this.attributes = attributes;
};

module.exports = VertexArray;


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

var IsPlainObject = __webpack_require__(163);

/**
* This is a slightly modified version of http://api.jquery.com/jQuery.extend/
* 
* @method Phaser.Utils.extend
* @param {boolean} deep - Perform a deep copy?
* @param {object} target - The target object to copy to.
* @return {object} The extended object.
*/
var Extend = function ()
{
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean")
    {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // extend Phaser if only one argument is passed
    if (length === i)
    {
        target = this;
        --i;
    }

    for (; i < length; i++)
    {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null)
        {
            // Extend the base object
            for (name in options)
            {
                src = target[name];
                copy = options[name];

                // Prevent never-ending loop
                if (target === copy)
                {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))
                {
                    if (copyIsArray)
                    {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    }
                    else
                    {
                        clone = src && IsPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[name] = Extend(deep, clone, copy);

                // Don't bring in undefined values
                }
                else if (copy !== undefined)
                {
                    target[name] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

module.exports = Extend;


/***/ },
/* 52 */
/***/ function(module, exports) {

var CanvasInterpolation = {

    /**
    * Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).
    * Note that if this doesn't given the desired result then see the setSmoothingEnabled.
    *
    * @method Phaser.Canvas.setImageRenderingCrisp
    * @param {HTMLCanvasElement} canvas - The canvas to set image-rendering crisp on.
    * @return {HTMLCanvasElement} Returns the source canvas.
    */
    setCrisp: function (canvas)
    {
        var types = [ 'optimizeSpeed', 'crisp-edges', '-moz-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'pixelated' ];

        types.forEach(function(type)
        {
            canvas.style['image-rendering'] = type;
        });

        canvas.style.msInterpolationMode = 'nearest-neighbor';

        return canvas;
    },

    /**
    * Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').
    * Note that if this doesn't given the desired result then see the CanvasUtils.setSmoothingEnabled method.
    *
    * @method Phaser.Canvas.setImageRenderingBicubic
    * @param {HTMLCanvasElement} canvas The canvas to set image-rendering bicubic on.
    * @return {HTMLCanvasElement} Returns the source canvas.
    */
    setBicubic: function (canvas)
    {
        canvas.style['image-rendering'] = 'auto';
        canvas.style.msInterpolationMode = 'bicubic';

        return canvas;
    }

};

module.exports = CanvasInterpolation;


/***/ },
/* 53 */
/***/ function(module, exports) {

module.exports = {
    ARC: 0,
    BEGIN_PATH: 1,
    CLOSE_PATH: 2,
    FILL_RECT: 3,
    LINE_TO: 4,
    MOVE_TO: 5,
    LINE_STYLE: 6,
    FILL_STYLE: 7,
    FILL_PATH: 8,
    STROKE_PATH: 9,
    FILL_TRIANGLE: 10,
    STROKE_TRIANGLE: 11
};


/***/ },
/* 54 */
/***/ function(module, exports) {

var Contains = function (circle, x, y)
{
    //  Check if x/y are within the bounds first
    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom)
    {
        var dx = (circle.x - x) * (circle.x - x);
        var dy = (circle.y - y) * (circle.y - y);

        return (dx + dy) <= (circle.radius * circle.radius);
    }
    else
    {
        return false;
    }
};

module.exports = Contains;


/***/ },
/* 55 */
/***/ function(module, exports) {

var Contains = function (ellipse, x, y)
{
    if (ellipse.width <= 0 || ellipse.height <= 0)
    {
        return false;
    }
 
    //  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5
    var normx = ((x - ellipse.x) / ellipse.width) - 0.5;
    var normy = ((y - ellipse.y) / ellipse.height) - 0.5;
 
    normx *= normx;
    normy *= normy;
 
    return (normx + normy < 0.25);
};

module.exports = Contains;


/***/ },
/* 56 */
/***/ function(module, exports) {

/**
* Convert a distance along this curve into a `time` value which will be between 0 and 1.
* 
* For example if this curve has a length of 100 pixels then `findT(50)` would return `0.5`.
*
* @method Phaser.Hermite#findT
* @param {integer} distance - The distance into the curve in pixels. Should be a positive integer.
* @return {number} The time (`t`) value, a float between 0 and 1.
*/
var FindT = function (curve, distance)
{
    if (distance <= 0)
    {
        return 0;
    }

    //  Find the _points which bracket the distance value
    var ti = Math.floor(distance / curve.length * curve._accuracy);

    while (ti > 0 && curve._points[ti] > distance)
    {
        ti--;
    }

    while (ti < curve._accuracy && curve._points[ti] < distance)
    {
        ti++;
    }

    //  Linear interpolation to get a more accurate fix
    var dt = curve._points[ti] - curve._points[ti - 1];
    var d = distance - curve._points[ti - 1];

    return ((ti - 1) / curve._accuracy) + d / (dt * curve._accuracy);
};

module.exports = FindT;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

/**
* Get a point on the curve using the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getPoint
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @param {Phaser.Point|Object} [point] - An optional Phaser.Point, or Object containing public `x` and `y` properties. If given the resulting values will be stored in the Objects `x` and `y` properties. If omitted a new Phaser.Point object is created.
* @return {Phaser.Point} An Object with the x, y coordinate of the curve at the specified `t` value set in its `x` and `y` properties.
*/
var GetPoint = function (curve, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    if (t < 0)
    {
        t = 0;
    }

    if (t > 1)
    {
        t = 1;
    }

    var t2 = t * t;
    var t3 = t * t2;

    out.x = t3 * curve._ax + t2 * curve._bx + t * curve._v1x + curve._p1x;
    out.y = t3 * curve._ay + t2 * curve._by + t * curve._v1y + curve._p1y;

    return out;
};

module.exports = GetPoint;


/***/ },
/* 58 */
/***/ function(module, exports) {


var RotateAroundXY = function (line, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = line.x1 - x;
    var ty = line.y1 - y;

    line.x1 = tx * c - ty * s + x;
    line.y1 = tx * s + ty * c + y;

    tx = line.x2 - x;
    ty = line.y2 - y;

    line.x2 = tx * c - ty * s + x;
    line.y2 = tx * s + ty * c + y;

    return line;
};

module.exports = RotateAroundXY;


/***/ },
/* 59 */
/***/ function(module, exports) {

var Dot = function (pointA, pointB)
{
    return ((pointA.x * pointB.x) + (pointA.y * pointB.y));
};

module.exports = Dot;


/***/ },
/* 60 */
/***/ function(module, exports) {

var GetAspectRatio = function (rect)
{
    return (rect.height === 0) ? NaN : rect.width / rect.height;
};

module.exports = GetAspectRatio;


/***/ },
/* 61 */
/***/ function(module, exports) {

/**
 * Given 3 color values this will return an integer representation of it.
 *
 * @method getColor
 * @param {integer} r - The red color component in the range 0 - 255.
 * @param {integer} g - The green color component in the range 0 - 255.
 * @param {integer} b - The blue color component in the range 0 - 255.
 * @return {integer} A native color value integer (format: 0xRRGGBB).
 */
var GetColor = function (red, green, blue)
{
    return red << 16 | green << 8 | blue;
};

module.exports = GetColor;


/***/ },
/* 62 */
/***/ function(module, exports) {

module.exports = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,

    SHIFT: 16,
    CTRL: 17,
    ALT: 18,

    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,

    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,

    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,

    PRINT_SCREEN: 42,
    INSERT: 45,
    DELETE: 46,

    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,

    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,

    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,

    SEMICOLON: 186,
    PLUS: 187,
    COMMA: 188,
    MINUS: 189,
    PERIOD: 190,
    FORWAD_SLASH: 191,
    BACK_SLASH: 220,
    QUOTES: 222
};


/***/ },
/* 63 */
/***/ function(module, exports) {

//  Creates an XHRSettings Object with default values

var XHRSettings = function (responseType, async, user, password, timeout)
{
    if (responseType === undefined) { responseType = ''; }
    if (async === undefined) { async = true; }
    if (user === undefined) { user = ''; }
    if (password === undefined) { password = ''; }
    if (timeout === undefined) { timeout = 0; }

    // Before sending a request, set the xhr.responseType to "text", 
    // "arraybuffer", "blob", or "document", depending on your data needs. 
    // Note, setting xhr.responseType = '' (or omitting) will default the response to "text".

    return {

        //  Ignored by the Loader, only used by File.
        responseType: responseType,

        async: async,

        //  credentials
        user: user,
        password: password,

        //  timeout in ms (0 = no timeout)
        timeout: timeout,

        //  setRequestHeader
        header: undefined,
        headerValue: undefined,

        //  overrideMimeType
        overrideMimeType: undefined

    };
    
};

module.exports = XHRSettings;


/***/ },
/* 64 */
/***/ function(module, exports) {

var Between = function (min, max)
{
    return Math.floor(Math.random() * (max - min + 1) + min);
};

module.exports = Between;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.
*
* @class Detector
*/

// TODO: speculative contacts

var Detector = {};

module.exports = Detector;

var SAT = __webpack_require__(67);
var Pair = __webpack_require__(43);
var Bounds = __webpack_require__(3);

(function() {

    /**
     * Finds all collisions given a list of pairs.
     * @method collisions
     * @param {pair[]} broadphasePairs
     * @param {engine} engine
     * @return {array} collisions
     */
    Detector.collisions = function(broadphasePairs, engine) {
        var collisions = [],
            pairsTable = engine.pairs.table;

        // @if DEBUG
        var metrics = engine.metrics;
        // @endif
        
        for (var i = 0; i < broadphasePairs.length; i++) {
            var bodyA = broadphasePairs[i][0], 
                bodyB = broadphasePairs[i][1];

            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))
                continue;
            
            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))
                continue;

            // @if DEBUG
            metrics.midphaseTests += 1;
            // @endif

            // mid phase
            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {
                for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {
                    var partA = bodyA.parts[j];

                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {
                        var partB = bodyB.parts[k];

                        if ((partA === bodyA && partB === bodyB) || Bounds.overlaps(partA.bounds, partB.bounds)) {
                            // find a previous collision we could reuse
                            var pairId = Pair.id(partA, partB),
                                pair = pairsTable[pairId],
                                previousCollision;

                            if (pair && pair.isActive) {
                                previousCollision = pair.collision;
                            } else {
                                previousCollision = null;
                            }

                            // narrow phase
                            var collision = SAT.collides(partA, partB, previousCollision);

                            // @if DEBUG
                            metrics.narrowphaseTests += 1;
                            if (collision.reused)
                                metrics.narrowReuseCount += 1;
                            // @endif

                            if (collision.collided) {
                                collisions.push(collision);
                                // @if DEBUG
                                metrics.narrowDetections += 1;
                                // @endif
                            }
                        }
                    }
                }
            }
        }

        return collisions;
    };

    /**
     * Returns `true` if both supplied collision filters will allow a collision to occur.
     * See `body.collisionFilter` for more information.
     * @method canCollide
     * @param {} filterA
     * @param {} filterB
     * @return {bool} `true` if collision can occur
     */
    Detector.canCollide = function(filterA, filterB) {
        if (filterA.group === filterB.group && filterA.group !== 0)
            return filterA.group > 0;

        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
    };

})();


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
*
* @class Grid
*/

var Grid = {};

module.exports = Grid;

var Pair = __webpack_require__(43);
var Detector = __webpack_require__(65);
var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a new grid.
     * @method create
     * @param {} options
     * @return {grid} A new grid
     */
    Grid.create = function(options) {
        var defaults = {
            controller: Grid,
            detector: Detector.collisions,
            buckets: {},
            pairs: {},
            pairsList: [],
            bucketWidth: 48,
            bucketHeight: 48
        };

        return Common.extend(defaults, options);
    };

    /**
     * The width of a single grid bucket.
     *
     * @property bucketWidth
     * @type number
     * @default 48
     */

    /**
     * The height of a single grid bucket.
     *
     * @property bucketHeight
     * @type number
     * @default 48
     */

    /**
     * Updates the grid.
     * @method update
     * @param {grid} grid
     * @param {body[]} bodies
     * @param {engine} engine
     * @param {boolean} forceUpdate
     */
    Grid.update = function(grid, bodies, engine, forceUpdate) {
        var i, col, row,
            world = engine.world,
            buckets = grid.buckets,
            bucket,
            bucketId,
            gridChanged = false;

        // @if DEBUG
        var metrics = engine.metrics;
        metrics.broadphaseTests = 0;
        // @endif

        for (i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isSleeping && !forceUpdate)
                continue;

            // don't update out of world bodies
            if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x
                || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)
                continue;

            var newRegion = _getRegion(grid, body);

            // if the body has changed grid region
            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {

                // @if DEBUG
                metrics.broadphaseTests += 1;
                // @endif

                if (!body.region || forceUpdate)
                    body.region = newRegion;

                var union = _regionUnion(newRegion, body.region);

                // update grid buckets affected by region change
                // iterate over the union of both regions
                for (col = union.startCol; col <= union.endCol; col++) {
                    for (row = union.startRow; row <= union.endRow; row++) {
                        bucketId = _getBucketId(col, row);
                        bucket = buckets[bucketId];

                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol
                                                && row >= newRegion.startRow && row <= newRegion.endRow);

                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol
                                                && row >= body.region.startRow && row <= body.region.endRow);

                        // remove from old region buckets
                        if (!isInsideNewRegion && isInsideOldRegion) {
                            if (isInsideOldRegion) {
                                if (bucket)
                                    _bucketRemoveBody(grid, bucket, body);
                            }
                        }

                        // add to new region buckets
                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {
                            if (!bucket)
                                bucket = _createBucket(buckets, bucketId);
                            _bucketAddBody(grid, bucket, body);
                        }
                    }
                }

                // set the new region
                body.region = newRegion;

                // flag changes so we can update pairs
                gridChanged = true;
            }
        }

        // update pairs list only if pairs changed (i.e. a body changed region)
        if (gridChanged)
            grid.pairsList = _createActivePairsList(grid);
    };

    /**
     * Clears the grid.
     * @method clear
     * @param {grid} grid
     */
    Grid.clear = function(grid) {
        grid.buckets = {};
        grid.pairs = {};
        grid.pairsList = [];
    };

    /**
     * Finds the union of two regions.
     * @method _regionUnion
     * @private
     * @param {} regionA
     * @param {} regionB
     * @return {} region
     */
    var _regionUnion = function(regionA, regionB) {
        var startCol = Math.min(regionA.startCol, regionB.startCol),
            endCol = Math.max(regionA.endCol, regionB.endCol),
            startRow = Math.min(regionA.startRow, regionB.startRow),
            endRow = Math.max(regionA.endRow, regionB.endRow);

        return _createRegion(startCol, endCol, startRow, endRow);
    };

    /**
     * Gets the region a given body falls in for a given grid.
     * @method _getRegion
     * @private
     * @param {} grid
     * @param {} body
     * @return {} region
     */
    var _getRegion = function(grid, body) {
        var bounds = body.bounds,
            startCol = Math.floor(bounds.min.x / grid.bucketWidth),
            endCol = Math.floor(bounds.max.x / grid.bucketWidth),
            startRow = Math.floor(bounds.min.y / grid.bucketHeight),
            endRow = Math.floor(bounds.max.y / grid.bucketHeight);

        return _createRegion(startCol, endCol, startRow, endRow);
    };

    /**
     * Creates a region.
     * @method _createRegion
     * @private
     * @param {} startCol
     * @param {} endCol
     * @param {} startRow
     * @param {} endRow
     * @return {} region
     */
    var _createRegion = function(startCol, endCol, startRow, endRow) {
        return { 
            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,
            startCol: startCol, 
            endCol: endCol, 
            startRow: startRow, 
            endRow: endRow 
        };
    };

    /**
     * Gets the bucket id at the given position.
     * @method _getBucketId
     * @private
     * @param {} column
     * @param {} row
     * @return {string} bucket id
     */
    var _getBucketId = function(column, row) {
        return 'C' + column + 'R' + row;
    };

    /**
     * Creates a bucket.
     * @method _createBucket
     * @private
     * @param {} buckets
     * @param {} bucketId
     * @return {} bucket
     */
    var _createBucket = function(buckets, bucketId) {
        var bucket = buckets[bucketId] = [];
        return bucket;
    };

    /**
     * Adds a body to a bucket.
     * @method _bucketAddBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */
    var _bucketAddBody = function(grid, bucket, body) {
        // add new pairs
        for (var i = 0; i < bucket.length; i++) {
            var bodyB = bucket[i];

            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))
                continue;

            // keep track of the number of buckets the pair exists in
            // important for Grid.update to work
            var pairId = Pair.id(body, bodyB),
                pair = grid.pairs[pairId];

            if (pair) {
                pair[2] += 1;
            } else {
                grid.pairs[pairId] = [body, bodyB, 1];
            }
        }

        // add to bodies (after pairs, otherwise pairs with self)
        bucket.push(body);
    };

    /**
     * Removes a body from a bucket.
     * @method _bucketRemoveBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */
    var _bucketRemoveBody = function(grid, bucket, body) {
        // remove from bucket
        bucket.splice(Common.indexOf(bucket, body), 1);

        // update pair counts
        for (var i = 0; i < bucket.length; i++) {
            // keep track of the number of buckets the pair exists in
            // important for _createActivePairsList to work
            var bodyB = bucket[i],
                pairId = Pair.id(body, bodyB),
                pair = grid.pairs[pairId];

            if (pair)
                pair[2] -= 1;
        }
    };

    /**
     * Generates a list of the active pairs in the grid.
     * @method _createActivePairsList
     * @private
     * @param {} grid
     * @return [] pairs
     */
    var _createActivePairsList = function(grid) {
        var pairKeys,
            pair,
            pairs = [];

        // grid.pairs is used as a hashmap
        pairKeys = Common.keys(grid.pairs);

        // iterate over grid.pairs
        for (var k = 0; k < pairKeys.length; k++) {
            pair = grid.pairs[pairKeys[k]];

            // if pair exists in at least one bucket
            // it is a pair that needs further collision testing so push it
            if (pair[2] > 0) {
                pairs.push(pair);
            } else {
                delete grid.pairs[pairKeys[k]];
            }
        }

        return pairs;
    };
    
})();


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.
*
* @class SAT
*/

// TODO: true circles and curves

var SAT = {};

module.exports = SAT;

var Vertices = __webpack_require__(22);
var Vector = __webpack_require__(4);

(function() {

    /**
     * Detect collision between two bodies using the Separating Axis Theorem.
     * @method collides
     * @param {body} bodyA
     * @param {body} bodyB
     * @param {collision} previousCollision
     * @return {collision} collision
     */
    SAT.collides = function(bodyA, bodyB, previousCollision) {
        var overlapAB,
            overlapBA, 
            minOverlap,
            collision,
            canReusePrevCol = false;

        if (previousCollision) {
            // estimate total motion
            var parentA = bodyA.parent,
                parentB = bodyB.parent,
                motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed
                       + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;

            // we may be able to (partially) reuse collision result 
            // but only safe if collision was resting
            canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;

            // reuse collision object
            collision = previousCollision;
        } else {
            collision = { collided: false, bodyA: bodyA, bodyB: bodyB };
        }

        if (previousCollision && canReusePrevCol) {
            // if we can reuse the collision result
            // we only need to test the previously found axis
            var axisBodyA = collision.axisBody,
                axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,
                axes = [axisBodyA.axes[previousCollision.axisNumber]];

            minOverlap = _overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);
            collision.reused = true;

            if (minOverlap.overlap <= 0) {
                collision.collided = false;
                return collision;
            }
        } else {
            // if we can't reuse a result, perform a full SAT test

            overlapAB = _overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);

            if (overlapAB.overlap <= 0) {
                collision.collided = false;
                return collision;
            }

            overlapBA = _overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);

            if (overlapBA.overlap <= 0) {
                collision.collided = false;
                return collision;
            }

            if (overlapAB.overlap < overlapBA.overlap) {
                minOverlap = overlapAB;
                collision.axisBody = bodyA;
            } else {
                minOverlap = overlapBA;
                collision.axisBody = bodyB;
            }

            // important for reuse later
            collision.axisNumber = minOverlap.axisNumber;
        }

        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
        collision.collided = true;
        collision.depth = minOverlap.overlap;
        collision.parentA = collision.bodyA.parent;
        collision.parentB = collision.bodyB.parent;
        
        bodyA = collision.bodyA;
        bodyB = collision.bodyB;

        // ensure normal is facing away from bodyA
        if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {
            collision.normal = {
                x: minOverlap.axis.x,
                y: minOverlap.axis.y
            };
        } else {
            collision.normal = {
                x: -minOverlap.axis.x,
                y: -minOverlap.axis.y
            };
        }

        collision.tangent = Vector.perp(collision.normal);

        collision.penetration = collision.penetration || {};
        collision.penetration.x = collision.normal.x * collision.depth;
        collision.penetration.y = collision.normal.y * collision.depth; 

        // find support points, there is always either exactly one or two
        var verticesB = _findSupports(bodyA, bodyB, collision.normal),
            supports = [];

        // find the supports from bodyB that are inside bodyA
        if (Vertices.contains(bodyA.vertices, verticesB[0]))
            supports.push(verticesB[0]);

        if (Vertices.contains(bodyA.vertices, verticesB[1]))
            supports.push(verticesB[1]);

        // find the supports from bodyA that are inside bodyB
        if (supports.length < 2) {
            var verticesA = _findSupports(bodyB, bodyA, Vector.neg(collision.normal));
                
            if (Vertices.contains(bodyB.vertices, verticesA[0]))
                supports.push(verticesA[0]);

            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))
                supports.push(verticesA[1]);
        }

        // account for the edge case of overlapping but no vertex containment
        if (supports.length < 1)
            supports = [verticesB[0]];
        
        collision.supports = supports;

        return collision;
    };

    /**
     * Find the overlap between two sets of vertices.
     * @method _overlapAxes
     * @private
     * @param {} verticesA
     * @param {} verticesB
     * @param {} axes
     * @return result
     */
    var _overlapAxes = function(verticesA, verticesB, axes) {
        var projectionA = Vector._temp[0], 
            projectionB = Vector._temp[1],
            result = { overlap: Number.MAX_VALUE },
            overlap,
            axis;

        for (var i = 0; i < axes.length; i++) {
            axis = axes[i];

            _projectToAxis(projectionA, verticesA, axis);
            _projectToAxis(projectionB, verticesB, axis);

            overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);

            if (overlap <= 0) {
                result.overlap = overlap;
                return result;
            }

            if (overlap < result.overlap) {
                result.overlap = overlap;
                result.axis = axis;
                result.axisNumber = i;
            }
        }

        return result;
    };

    /**
     * Projects vertices on an axis and returns an interval.
     * @method _projectToAxis
     * @private
     * @param {} projection
     * @param {} vertices
     * @param {} axis
     */
    var _projectToAxis = function(projection, vertices, axis) {
        var min = Vector.dot(vertices[0], axis),
            max = min;

        for (var i = 1; i < vertices.length; i += 1) {
            var dot = Vector.dot(vertices[i], axis);

            if (dot > max) { 
                max = dot; 
            } else if (dot < min) { 
                min = dot; 
            }
        }

        projection.min = min;
        projection.max = max;
    };
    
    /**
     * Finds supporting vertices given two bodies along a given direction using hill-climbing.
     * @method _findSupports
     * @private
     * @param {} bodyA
     * @param {} bodyB
     * @param {} normal
     * @return [vector]
     */
    var _findSupports = function(bodyA, bodyB, normal) {
        var nearestDistance = Number.MAX_VALUE,
            vertexToBody = Vector._temp[0],
            vertices = bodyB.vertices,
            bodyAPosition = bodyA.position,
            distance,
            vertex,
            vertexA,
            vertexB;

        // find closest vertex on bodyB
        for (var i = 0; i < vertices.length; i++) {
            vertex = vertices[i];
            vertexToBody.x = vertex.x - bodyAPosition.x;
            vertexToBody.y = vertex.y - bodyAPosition.y;
            distance = -Vector.dot(normal, vertexToBody);

            if (distance < nearestDistance) {
                nearestDistance = distance;
                vertexA = vertex;
            }
        }

        // find next closest vertex using the two connected to it
        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;
        vertex = vertices[prevIndex];
        vertexToBody.x = vertex.x - bodyAPosition.x;
        vertexToBody.y = vertex.y - bodyAPosition.y;
        nearestDistance = -Vector.dot(normal, vertexToBody);
        vertexB = vertex;

        var nextIndex = (vertexA.index + 1) % vertices.length;
        vertex = vertices[nextIndex];
        vertexToBody.x = vertex.x - bodyAPosition.x;
        vertexToBody.y = vertex.y - bodyAPosition.y;
        distance = -Vector.dot(normal, vertexToBody);
        if (distance < nearestDistance) {
            vertexB = vertex;
        }

        return [vertexA, vertexB];
    };

})();


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.
*
* @class Mouse
*/

var Mouse = {};

module.exports = Mouse;

var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a mouse input.
     * @method create
     * @param {HTMLElement} element
     * @return {mouse} A new mouse
     */
    Mouse.create = function(element) {
        var mouse = {};

        if (!element) {
            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');
        }
        
        mouse.element = element || document.body;
        mouse.absolute = { x: 0, y: 0 };
        mouse.position = { x: 0, y: 0 };
        mouse.mousedownPosition = { x: 0, y: 0 };
        mouse.mouseupPosition = { x: 0, y: 0 };
        mouse.offset = { x: 0, y: 0 };
        mouse.scale = { x: 1, y: 1 };
        mouse.wheelDelta = 0;
        mouse.button = -1;
        mouse.pixelRatio = mouse.element.getAttribute('data-pixel-ratio') || 1;

        mouse.sourceEvents = {
            mousemove: null,
            mousedown: null,
            mouseup: null,
            mousewheel: null
        };
        
        mouse.mousemove = function(event) { 
            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                mouse.button = 0;
                event.preventDefault();
            }

            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.sourceEvents.mousemove = event;
        };
        
        mouse.mousedown = function(event) {
            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                mouse.button = 0;
                event.preventDefault();
            } else {
                mouse.button = event.button;
            }

            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.mousedownPosition.x = mouse.position.x;
            mouse.mousedownPosition.y = mouse.position.y;
            mouse.sourceEvents.mousedown = event;
        };
        
        mouse.mouseup = function(event) {
            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                event.preventDefault();
            }
            
            mouse.button = -1;
            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.mouseupPosition.x = mouse.position.x;
            mouse.mouseupPosition.y = mouse.position.y;
            mouse.sourceEvents.mouseup = event;
        };

        mouse.mousewheel = function(event) {
            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
            event.preventDefault();
        };

        Mouse.setElement(mouse, mouse.element);

        return mouse;
    };

    /**
     * Sets the element the mouse is bound to (and relative to).
     * @method setElement
     * @param {mouse} mouse
     * @param {HTMLElement} element
     */
    Mouse.setElement = function(mouse, element) {
        mouse.element = element;

        element.addEventListener('mousemove', mouse.mousemove);
        element.addEventListener('mousedown', mouse.mousedown);
        element.addEventListener('mouseup', mouse.mouseup);
        
        element.addEventListener('mousewheel', mouse.mousewheel);
        element.addEventListener('DOMMouseScroll', mouse.mousewheel);

        element.addEventListener('touchmove', mouse.mousemove);
        element.addEventListener('touchstart', mouse.mousedown);
        element.addEventListener('touchend', mouse.mouseup);
    };

    /**
     * Clears all captured source events.
     * @method clearSourceEvents
     * @param {mouse} mouse
     */
    Mouse.clearSourceEvents = function(mouse) {
        mouse.sourceEvents.mousemove = null;
        mouse.sourceEvents.mousedown = null;
        mouse.sourceEvents.mouseup = null;
        mouse.sourceEvents.mousewheel = null;
        mouse.wheelDelta = 0;
    };

    /**
     * Sets the mouse position offset.
     * @method setOffset
     * @param {mouse} mouse
     * @param {vector} offset
     */
    Mouse.setOffset = function(mouse, offset) {
        mouse.offset.x = offset.x;
        mouse.offset.y = offset.y;
        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
    };

    /**
     * Sets the mouse position scale.
     * @method setScale
     * @param {mouse} mouse
     * @param {vector} scale
     */
    Mouse.setScale = function(mouse, scale) {
        mouse.scale.x = scale.x;
        mouse.scale.y = scale.y;
        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
    };
    
    /**
     * Gets the mouse position relative to an element given a screen pixel ratio.
     * @method _getRelativeMousePosition
     * @private
     * @param {} event
     * @param {} element
     * @param {number} pixelRatio
     * @return {}
     */
    var _getRelativeMousePosition = function(event, element, pixelRatio) {
        var elementBounds = element.getBoundingClientRect(),
            rootNode = (document.documentElement || document.body.parentNode || document.body),
            scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : rootNode.scrollLeft,
            scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : rootNode.scrollTop,
            touches = event.changedTouches,
            x, y;
        
        if (touches) {
            x = touches[0].pageX - elementBounds.left - scrollX;
            y = touches[0].pageY - elementBounds.top - scrollY;
        } else {
            x = event.pageX - elementBounds.left - scrollX;
            y = event.pageY - elementBounds.top - scrollY;
        }

        return { 
            x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),
            y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)
        };
    };

})();


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Bodies` module contains factory methods for creating rigid body models 
* with commonly used body configurations (such as rectangles, circles and other polygons).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Bodies
*/

// TODO: true circle bodies

var Bodies = {};

module.exports = Bodies;

var Vertices = __webpack_require__(22);
var Common = __webpack_require__(0);
var Body = __webpack_require__(38);
var Bounds = __webpack_require__(3);
var Vector = __webpack_require__(4);
var decomp = __webpack_require__(156);

(function() {

    /**
     * Creates a new rigid body model with a rectangle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method rectangle
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {object} [options]
     * @return {body} A new rectangle body
     */
    Bodies.rectangle = function(x, y, width, height, options) {
        options = options || {};

        var rectangle = { 
            label: 'Rectangle Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, rectangle, options));
    };
    
    /**
     * Creates a new rigid body model with a trapezoid hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method trapezoid
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} slope
     * @param {object} [options]
     * @return {body} A new trapezoid body
     */
    Bodies.trapezoid = function(x, y, width, height, slope, options) {
        options = options || {};

        slope *= 0.5;
        var roof = (1 - (slope * 2)) * width;
        
        var x1 = width * slope,
            x2 = x1 + roof,
            x3 = x2 + x1,
            verticesPath;

        if (slope < 0.5) {
            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';
        } else {
            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';
        }

        var trapezoid = { 
            label: 'Trapezoid Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath(verticesPath)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, trapezoid, options));
    };

    /**
     * Creates a new rigid body model with a circle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method circle
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {object} [options]
     * @param {number} [maxSides]
     * @return {body} A new circle body
     */
    Bodies.circle = function(x, y, radius, options, maxSides) {
        options = options || {};

        var circle = {
            label: 'Circle Body',
            circleRadius: radius
        };
        
        // approximate circles with polygons until true circles implemented in SAT
        maxSides = maxSides || 25;
        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));

        // optimisation: always use even number of sides (half the number of unique axes)
        if (sides % 2 === 1)
            sides += 1;

        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));
    };

    /**
     * Creates a new rigid body model with a regular polygon hull with the given number of sides. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method polygon
     * @param {number} x
     * @param {number} y
     * @param {number} sides
     * @param {number} radius
     * @param {object} [options]
     * @return {body} A new regular polygon body
     */
    Bodies.polygon = function(x, y, sides, radius, options) {
        options = options || {};

        if (sides < 3)
            return Bodies.circle(x, y, radius, options);

        var theta = 2 * Math.PI / sides,
            path = '',
            offset = theta * 0.5;

        for (var i = 0; i < sides; i += 1) {
            var angle = offset + (i * theta),
                xx = Math.cos(angle) * radius,
                yy = Math.sin(angle) * radius;

            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';
        }

        var polygon = { 
            label: 'Polygon Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath(path)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, polygon, options));
    };

    /**
     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
     * If the vertices are convex, they will pass through as supplied.
     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
     * By default the decomposition will discard collinear edges (to improve performance).
     * It can also optionally discard any parts that have an area less than `minimumArea`.
     * If the vertices can not be decomposed, the result will fall back to using the convex hull.
     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method fromVertices
     * @param {number} x
     * @param {number} y
     * @param [[vector]] vertexSets
     * @param {object} [options]
     * @param {bool} [flagInternal=false]
     * @param {number} [removeCollinear=0.01]
     * @param {number} [minimumArea=10]
     * @return {body}
     */
    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
        var body,
            parts,
            isConvex,
            vertices,
            i,
            j,
            k,
            v,
            z;

        options = options || {};
        parts = [];

        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;
        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;
        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;

        if (!decomp) {
            Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');
        }

        // ensure vertexSets is an array of arrays
        if (!Common.isArray(vertexSets[0])) {
            vertexSets = [vertexSets];
        }

        for (v = 0; v < vertexSets.length; v += 1) {
            vertices = vertexSets[v];
            isConvex = Vertices.isConvex(vertices);

            if (isConvex || !decomp) {
                if (isConvex) {
                    vertices = Vertices.clockwiseSort(vertices);
                } else {
                    // fallback to convex hull when decomposition is not possible
                    vertices = Vertices.hull(vertices);
                }

                parts.push({
                    position: { x: x, y: y },
                    vertices: vertices
                });
            } else {
                // initialise a decomposition
                var concave = vertices.map(function(vertex) {
                    return [vertex.x, vertex.y];
                });

                // vertices are concave and simple, we can decompose into parts
                decomp.makeCCW(concave);
                if (removeCollinear !== false)
                    decomp.removeCollinearPoints(concave, removeCollinear);

                // use the quick decomposition algorithm (Bayazit)
                var decomposed = decomp.quickDecomp(concave);

                // for each decomposed chunk
                for (i = 0; i < decomposed.length; i++) {
                    var chunk = decomposed[i];

                    // convert vertices into the correct structure
                    var chunkVertices = chunk.map(function(vertices) {
                        return {
                            x: vertices[0],
                            y: vertices[1]
                        };
                    });

                    // skip small chunks
                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)
                        continue;

                    // create a compound part
                    parts.push({
                        position: Vertices.centre(chunkVertices),
                        vertices: chunkVertices
                    });
                }
            }
        }

        // create body parts
        for (i = 0; i < parts.length; i++) {
            parts[i] = Body.create(Common.extend(parts[i], options));
        }

        // flag internal edges (coincident part edges)
        if (flagInternal) {
            var coincident_max_dist = 5;

            for (i = 0; i < parts.length; i++) {
                var partA = parts[i];

                for (j = i + 1; j < parts.length; j++) {
                    var partB = parts[j];

                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                        var pav = partA.vertices,
                            pbv = partB.vertices;

                        // iterate vertices of both parts
                        for (k = 0; k < partA.vertices.length; k++) {
                            for (z = 0; z < partB.vertices.length; z++) {
                                // find distances between the vertices
                                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),
                                    db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));

                                // if both vertices are very close, consider the edge concident (internal)
                                if (da < coincident_max_dist && db < coincident_max_dist) {
                                    pav[k].isInternal = true;
                                    pbv[z].isInternal = true;
                                }
                            }
                        }

                    }
                }
            }
        }

        if (parts.length > 1) {
            // create the parent body to be returned, that contains generated compound parts
            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));
            Body.setPosition(body, { x: x, y: y });

            return body;
        } else {
            return parts[0];
        }
    };

})();


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
*
* @class Axes
*/

var Axes = {};

module.exports = Axes;

var Vector = __webpack_require__(4);
var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a new set of axes from the given vertices.
     * @method fromVertices
     * @param {vertices} vertices
     * @return {axes} A new axes from the given vertices
     */
    Axes.fromVertices = function(vertices) {
        var axes = {};

        // find the unique axes, using edge normal gradients
        for (var i = 0; i < vertices.length; i++) {
            var j = (i + 1) % vertices.length, 
                normal = Vector.normalise({ 
                    x: vertices[j].y - vertices[i].y, 
                    y: vertices[i].x - vertices[j].x
                }),
                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);
            
            // limit precision
            gradient = gradient.toFixed(3).toString();
            axes[gradient] = normal;
        }

        return Common.values(axes);
    };

    /**
     * Rotates a set of axes by the given angle.
     * @method rotate
     * @param {axes} axes
     * @param {number} angle
     */
    Axes.rotate = function(axes, angle) {
        if (angle === 0)
            return;
        
        var cos = Math.cos(angle),
            sin = Math.sin(angle);

        for (var i = 0; i < axes.length; i++) {
            var axis = axes[i],
                xx;
            xx = axis.x * cos - axis.y * sin;
            axis.y = axis.x * sin + axis.y * cos;
            axis.x = xx;
        }
    };

})();


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Render` module is a simple HTML5 canvas based renderer for visualising instances of `Matter.Engine`.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.
*
* @class Render
*/

var Render = {};

module.exports = Render;

var Common = __webpack_require__(0);
var Composite = __webpack_require__(20);
var Bounds = __webpack_require__(3);
var Events = __webpack_require__(21);
var Grid = __webpack_require__(66);
var Vector = __webpack_require__(4);
var Mouse = __webpack_require__(68);

(function() {
    
    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame 
                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }

    /**
     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {render} A new renderer
     */
    Render.create = function(options) {
        var defaults = {
            controller: Render,
            engine: null,
            element: null,
            canvas: null,
            mouse: null,
            frameRequestId: null,
            options: {
                width: 800,
                height: 600,
                pixelRatio: 1,
                background: '#18181d',
                wireframeBackground: '#0f0f13',
                hasBounds: !!options.bounds,
                enabled: true,
                wireframes: true,
                showSleeping: true,
                showDebug: false,
                showBroadphase: false,
                showBounds: false,
                showVelocity: false,
                showCollisions: false,
                showSeparations: false,
                showAxes: false,
                showPositions: false,
                showAngleIndicator: false,
                showIds: false,
                showShadows: false,
                showVertexNumbers: false,
                showConvexHulls: false,
                showInternalEdges: false,
                showMousePosition: false
            }
        };

        var render = Common.extend(defaults, options);

        if (render.canvas) {
            render.canvas.width = render.options.width || render.canvas.width;
            render.canvas.height = render.options.height || render.canvas.height;
        }

        render.mouse = options.mouse;
        render.engine = options.engine;
        render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);
        render.context = render.canvas.getContext('2d');
        render.textures = {};

        render.bounds = render.bounds || { 
            min: { 
                x: 0,
                y: 0
            }, 
            max: { 
                x: render.canvas.width,
                y: render.canvas.height
            }
        };

        if (render.options.pixelRatio !== 1) {
            Render.setPixelRatio(render, render.options.pixelRatio);
        }

        if (Common.isElement(render.element)) {
            render.element.appendChild(render.canvas);
        } else {
            Common.log('Render.create: options.element was undefined, render.canvas was created but not appended', 'warn');
        }

        return render;
    };

    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     */
    Render.run = function(render) {
        (function loop(time){
            render.frameRequestId = _requestAnimationFrame(loop);
            Render.world(render);
        })();
    };

    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     */
    Render.stop = function(render) {
        _cancelAnimationFrame(render.frameRequestId);
    };

    /**
     * Sets the pixel ratio of the renderer and updates the canvas.
     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.
     * @method setPixelRatio
     * @param {render} render
     * @param {number} pixelRatio
     */
    Render.setPixelRatio = function(render, pixelRatio) {
        var options = render.options,
            canvas = render.canvas;

        if (pixelRatio === 'auto') {
            pixelRatio = _getPixelRatio(canvas);
        }

        options.pixelRatio = pixelRatio;
        canvas.setAttribute('data-pixel-ratio', pixelRatio);
        canvas.width = options.width * pixelRatio;
        canvas.height = options.height * pixelRatio;
        canvas.style.width = options.width + 'px';
        canvas.style.height = options.height + 'px';
        render.context.scale(pixelRatio, pixelRatio);
    };

    /**
     * Positions and sizes the viewport around the given object bounds.
     * Objects must have at least one of the following properties:
     * - `object.bounds`
     * - `object.position`
     * - `object.min` and `object.max`
     * - `object.x` and `object.y`
     * @method lookAt
     * @param {render} render
     * @param {object[]} objects
     * @param {vector} [padding]
     * @param {bool} [center=true]
     */
    Render.lookAt = function(render, objects, padding, center) {
        center = typeof center !== 'undefined' ? center : true;
        objects = Common.isArray(objects) ? objects : [objects];
        padding = padding || {
            x: 0,
            y: 0
        };

        // find bounds of all objects
        var bounds = {
            min: { x: Infinity, y: Infinity },
            max: { x: -Infinity, y: -Infinity }
        };

        for (var i = 0; i < objects.length; i += 1) {
            var object = objects[i],
                min = object.bounds ? object.bounds.min : (object.min || object.position || object),
                max = object.bounds ? object.bounds.max : (object.max || object.position || object); 

            if (min && max) { 
                if (min.x < bounds.min.x) 
                    bounds.min.x = min.x;
                    
                if (max.x > bounds.max.x) 
                    bounds.max.x = max.x;

                if (min.y < bounds.min.y) 
                    bounds.min.y = min.y;

                if (max.y > bounds.max.y) 
                    bounds.max.y = max.y;
            }
        }

        // find ratios
        var width = (bounds.max.x - bounds.min.x) + 2 * padding.x,
            height = (bounds.max.y - bounds.min.y) + 2 * padding.y,
            viewHeight = render.canvas.height,
            viewWidth = render.canvas.width,
            outerRatio = viewWidth / viewHeight,
            innerRatio = width / height,
            scaleX = 1,
            scaleY = 1;

        // find scale factor
        if (innerRatio > outerRatio) {
            scaleY = innerRatio / outerRatio;
        } else {
            scaleX = outerRatio / innerRatio;
        }

        // enable bounds
        render.options.hasBounds = true;

        // position and size
        render.bounds.min.x = bounds.min.x;
        render.bounds.max.x = bounds.min.x + width * scaleX;
        render.bounds.min.y = bounds.min.y;
        render.bounds.max.y = bounds.min.y + height * scaleY;

        // center
        if (center) {
            render.bounds.min.x += width * 0.5 - (width * scaleX) * 0.5;
            render.bounds.max.x += width * 0.5 - (width * scaleX) * 0.5;
            render.bounds.min.y += height * 0.5 - (height * scaleY) * 0.5;
            render.bounds.max.y += height * 0.5 - (height * scaleY) * 0.5;
        }

        // padding
        render.bounds.min.x -= padding.x;
        render.bounds.max.x -= padding.x;
        render.bounds.min.y -= padding.y;
        render.bounds.max.y -= padding.y;

        // update mouse
        if (render.mouse) {
            Mouse.setScale(render.mouse, {
                x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
            });

            Mouse.setOffset(render.mouse, render.bounds.min);
        }
    };

    /**
     * Applies viewport transforms based on `render.bounds` to a render context.
     * @method startViewTransform
     * @param {render} render
     */
    Render.startViewTransform = function(render) {
        var boundsWidth = render.bounds.max.x - render.bounds.min.x,
            boundsHeight = render.bounds.max.y - render.bounds.min.y,
            boundsScaleX = boundsWidth / render.options.width,
            boundsScaleY = boundsHeight / render.options.height;

        render.context.scale(1 / boundsScaleX, 1 / boundsScaleY);
        render.context.translate(-render.bounds.min.x, -render.bounds.min.y);
    };

    /**
     * Resets all transforms on the render context.
     * @method endViewTransform
     * @param {render} render
     */
    Render.endViewTransform = function(render) {
        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);
    };

    /**
     * Renders the given `engine`'s `Matter.World` object.
     * This is the entry point for all rendering and should be called every time the scene changes.
     * @method world
     * @param {render} render
     */
    Render.world = function(render) {
        var engine = render.engine,
            world = engine.world,
            canvas = render.canvas,
            context = render.context,
            options = render.options,
            allBodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world),
            background = options.wireframes ? options.wireframeBackground : options.background,
            bodies = [],
            constraints = [],
            i;

        var event = {
            timestamp: engine.timing.timestamp
        };

        Events.trigger(render, 'beforeRender', event);

        // apply background if it has changed
        if (render.currentBackground !== background)
            _applyBackground(render, background);

        // clear the canvas with a transparent fill, to allow the canvas background to show
        context.globalCompositeOperation = 'source-in';
        context.fillStyle = "transparent";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.globalCompositeOperation = 'source-over';

        // handle bounds
        if (options.hasBounds) {
            // filter out bodies that are not in view
            for (i = 0; i < allBodies.length; i++) {
                var body = allBodies[i];
                if (Bounds.overlaps(body.bounds, render.bounds))
                    bodies.push(body);
            }

            // filter out constraints that are not in view
            for (i = 0; i < allConstraints.length; i++) {
                var constraint = allConstraints[i],
                    bodyA = constraint.bodyA,
                    bodyB = constraint.bodyB,
                    pointAWorld = constraint.pointA,
                    pointBWorld = constraint.pointB;

                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);

                if (!pointAWorld || !pointBWorld)
                    continue;

                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))
                    constraints.push(constraint);
            }

            // transform the view
            Render.startViewTransform(render);

            // update mouse
            if (render.mouse) {
                Mouse.setScale(render.mouse, {
                    x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                    y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
                });

                Mouse.setOffset(render.mouse, render.bounds.min);
            }
        } else {
            constraints = allConstraints;
            bodies = allBodies;
        }

        if (!options.wireframes || (engine.enableSleeping && options.showSleeping)) {
            // fully featured rendering of bodies
            Render.bodies(render, bodies, context);
        } else {
            if (options.showConvexHulls)
                Render.bodyConvexHulls(render, bodies, context);

            // optimised method for wireframes only
            Render.bodyWireframes(render, bodies, context);
        }

        if (options.showBounds)
            Render.bodyBounds(render, bodies, context);

        if (options.showAxes || options.showAngleIndicator)
            Render.bodyAxes(render, bodies, context);
        
        if (options.showPositions)
            Render.bodyPositions(render, bodies, context);

        if (options.showVelocity)
            Render.bodyVelocity(render, bodies, context);

        if (options.showIds)
            Render.bodyIds(render, bodies, context);

        if (options.showSeparations)
            Render.separations(render, engine.pairs.list, context);

        if (options.showCollisions)
            Render.collisions(render, engine.pairs.list, context);

        if (options.showVertexNumbers)
            Render.vertexNumbers(render, bodies, context);

        if (options.showMousePosition)
            Render.mousePosition(render, render.mouse, context);

        Render.constraints(constraints, context);

        if (options.showBroadphase && engine.broadphase.controller === Grid)
            Render.grid(render, engine.broadphase, context);

        if (options.showDebug)
            Render.debug(render, context);

        if (options.hasBounds) {
            // revert view transforms
            Render.endViewTransform(render);
        }

        Events.trigger(render, 'afterRender', event);
    };

    /**
     * Description
     * @private
     * @method debug
     * @param {render} render
     * @param {RenderingContext} context
     */
    Render.debug = function(render, context) {
        var c = context,
            engine = render.engine,
            world = engine.world,
            metrics = engine.metrics,
            options = render.options,
            bodies = Composite.allBodies(world),
            space = "    ";

        if (engine.timing.timestamp - (render.debugTimestamp || 0) >= 500) {
            var text = "";

            if (metrics.timing) {
                text += "fps: " + Math.round(metrics.timing.fps) + space;
            }

            // @if DEBUG
            if (metrics.extended) {
                if (metrics.timing) {
                    text += "delta: " + metrics.timing.delta.toFixed(3) + space;
                    text += "correction: " + metrics.timing.correction.toFixed(3) + space;
                }

                text += "bodies: " + bodies.length + space;

                if (engine.broadphase.controller === Grid)
                    text += "buckets: " + metrics.buckets + space;

                text += "\n";

                text += "collisions: " + metrics.collisions + space;
                text += "pairs: " + engine.pairs.list.length + space;
                text += "broad: " + metrics.broadEff + space;
                text += "mid: " + metrics.midEff + space;
                text += "narrow: " + metrics.narrowEff + space;
            }
            // @endif            

            render.debugString = text;
            render.debugTimestamp = engine.timing.timestamp;
        }

        if (render.debugString) {
            c.font = "12px Arial";

            if (options.wireframes) {
                c.fillStyle = 'rgba(255,255,255,0.5)';
            } else {
                c.fillStyle = 'rgba(0,0,0,0.5)';
            }

            var split = render.debugString.split('\n');

            for (var i = 0; i < split.length; i++) {
                c.fillText(split[i], 50, 50 + i * 18);
            }
        }
    };

    /**
     * Description
     * @private
     * @method constraints
     * @param {constraint[]} constraints
     * @param {RenderingContext} context
     */
    Render.constraints = function(constraints, context) {
        var c = context;

        for (var i = 0; i < constraints.length; i++) {
            var constraint = constraints[i];

            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)
                continue;

            var bodyA = constraint.bodyA,
                bodyB = constraint.bodyB;

            if (bodyA) {
                c.beginPath();
                c.moveTo(bodyA.position.x + constraint.pointA.x, bodyA.position.y + constraint.pointA.y);
            } else {
                c.beginPath();
                c.moveTo(constraint.pointA.x, constraint.pointA.y);
            }

            if (bodyB) {
                c.lineTo(bodyB.position.x + constraint.pointB.x, bodyB.position.y + constraint.pointB.y);
            } else {
                c.lineTo(constraint.pointB.x, constraint.pointB.y);
            }

            if (constraint.render.lineWidth) {
                c.lineWidth = constraint.render.lineWidth;
                c.strokeStyle = constraint.render.strokeStyle;
                c.stroke();
            }
        }
    };
    
    /**
     * Description
     * @private
     * @method bodyShadows
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyShadows = function(render, bodies, context) {
        var c = context,
            engine = render.engine;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (!body.render.visible)
                continue;

            if (body.circleRadius) {
                c.beginPath();
                c.arc(body.position.x, body.position.y, body.circleRadius, 0, 2 * Math.PI);
                c.closePath();
            } else {
                c.beginPath();
                c.moveTo(body.vertices[0].x, body.vertices[0].y);
                for (var j = 1; j < body.vertices.length; j++) {
                    c.lineTo(body.vertices[j].x, body.vertices[j].y);
                }
                c.closePath();
            }

            var distanceX = body.position.x - render.options.width * 0.5,
                distanceY = body.position.y - render.options.height * 0.2,
                distance = Math.abs(distanceX) + Math.abs(distanceY);

            c.shadowColor = 'rgba(0,0,0,0.15)';
            c.shadowOffsetX = 0.05 * distanceX;
            c.shadowOffsetY = 0.05 * distanceY;
            c.shadowBlur = 1 + 12 * Math.min(1, distance / 1000);

            c.fill();

            c.shadowColor = null;
            c.shadowOffsetX = null;
            c.shadowOffsetY = null;
            c.shadowBlur = null;
        }
    };

    /**
     * Description
     * @private
     * @method bodies
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodies = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            showInternalEdges = options.showInternalEdges || !options.wireframes,
            body,
            part,
            i,
            k;

        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                part = body.parts[k];

                if (!part.render.visible)
                    continue;

                if (options.showSleeping && body.isSleeping) {
                    c.globalAlpha = 0.5 * part.render.opacity;
                } else if (part.render.opacity !== 1) {
                    c.globalAlpha = part.render.opacity;
                }

                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {
                    // part sprite
                    var sprite = part.render.sprite,
                        texture = _getTexture(render, sprite.texture);

                    c.translate(part.position.x, part.position.y); 
                    c.rotate(part.angle);

                    c.drawImage(
                        texture,
                        texture.width * -sprite.xOffset * sprite.xScale, 
                        texture.height * -sprite.yOffset * sprite.yScale, 
                        texture.width * sprite.xScale, 
                        texture.height * sprite.yScale
                    );

                    // revert translation, hopefully faster than save / restore
                    c.rotate(-part.angle);
                    c.translate(-part.position.x, -part.position.y); 
                } else {
                    // part polygon
                    if (part.circleRadius) {
                        c.beginPath();
                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);
                    } else {
                        c.beginPath();
                        c.moveTo(part.vertices[0].x, part.vertices[0].y);

                        for (var j = 1; j < part.vertices.length; j++) {
                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                                c.lineTo(part.vertices[j].x, part.vertices[j].y);
                            } else {
                                c.moveTo(part.vertices[j].x, part.vertices[j].y);
                            }

                            if (part.vertices[j].isInternal && !showInternalEdges) {
                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                            }
                        }
                        
                        c.lineTo(part.vertices[0].x, part.vertices[0].y);
                        c.closePath();
                    }

                    if (!options.wireframes) {
                        c.fillStyle = part.render.fillStyle;

                        if (part.render.lineWidth) {
                            c.lineWidth = part.render.lineWidth;
                            c.strokeStyle = part.render.strokeStyle;
                            c.stroke();
                        }

                        c.fill();
                    } else {
                        c.lineWidth = 1;
                        c.strokeStyle = '#bbb';
                        c.stroke();
                    }
                }

                c.globalAlpha = 1;
            }
        }
    };

    /**
     * Optimised method for drawing body wireframes in one pass
     * @private
     * @method bodyWireframes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyWireframes = function(render, bodies, context) {
        var c = context,
            showInternalEdges = render.options.showInternalEdges,
            body,
            part,
            i,
            j,
            k;

        c.beginPath();

        // render all bodies
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                part = body.parts[k];

                c.moveTo(part.vertices[0].x, part.vertices[0].y);

                for (j = 1; j < part.vertices.length; j++) {
                    if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                        c.lineTo(part.vertices[j].x, part.vertices[j].y);
                    } else {
                        c.moveTo(part.vertices[j].x, part.vertices[j].y);
                    }

                    if (part.vertices[j].isInternal && !showInternalEdges) {
                        c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                    }
                }
                
                c.lineTo(part.vertices[0].x, part.vertices[0].y);
            }
        }

        c.lineWidth = 1;
        c.strokeStyle = '#bbb';
        c.stroke();
    };

    /**
     * Optimised method for drawing body convex hull wireframes in one pass
     * @private
     * @method bodyConvexHulls
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyConvexHulls = function(render, bodies, context) {
        var c = context,
            body,
            part,
            i,
            j,
            k;

        c.beginPath();

        // render convex hulls
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible || body.parts.length === 1)
                continue;

            c.moveTo(body.vertices[0].x, body.vertices[0].y);

            for (j = 1; j < body.vertices.length; j++) {
                c.lineTo(body.vertices[j].x, body.vertices[j].y);
            }
            
            c.lineTo(body.vertices[0].x, body.vertices[0].y);
        }

        c.lineWidth = 1;
        c.strokeStyle = 'rgba(255,255,255,0.2)';
        c.stroke();
    };

    /**
     * Renders body vertex numbers.
     * @private
     * @method vertexNumbers
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.vertexNumbers = function(render, bodies, context) {
        var c = context,
            i,
            j,
            k;

        for (i = 0; i < bodies.length; i++) {
            var parts = bodies[i].parts;
            for (k = parts.length > 1 ? 1 : 0; k < parts.length; k++) {
                var part = parts[k];
                for (j = 0; j < part.vertices.length; j++) {
                    c.fillStyle = 'rgba(255,255,255,0.2)';
                    c.fillText(i + '_' + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);
                }
            }
        }
    };

    /**
     * Renders mouse position.
     * @private
     * @method mousePosition
     * @param {render} render
     * @param {mouse} mouse
     * @param {RenderingContext} context
     */
    Render.mousePosition = function(render, mouse, context) {
        var c = context;
        c.fillStyle = 'rgba(255,255,255,0.8)';
        c.fillText(mouse.position.x + '  ' + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);
    };

    /**
     * Draws body bounds
     * @private
     * @method bodyBounds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyBounds = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options;

        c.beginPath();

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.render.visible) {
                var parts = bodies[i].parts;
                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    var part = parts[j];
                    c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                }
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,255,255,0.08)';
        } else {
            c.strokeStyle = 'rgba(0,0,0,0.1)';
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Draws body angle indicators and axes
     * @private
     * @method bodyAxes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyAxes = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            part,
            i,
            j,
            k;

        c.beginPath();

        for (i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                parts = body.parts;

            if (!body.render.visible)
                continue;

            if (options.showAxes) {
                // render all axes
                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                        var axis = part.axes[k];
                        c.moveTo(part.position.x, part.position.y);
                        c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                    }
                }
            } else {
                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                        // render a single axis indicator
                        c.moveTo(part.position.x, part.position.y);
                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2, 
                                 (part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2);
                    }
                }
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'indianred';
            c.lineWidth = 1;
        } else {
            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            c.globalCompositeOperation = 'overlay';
            c.lineWidth = 2;
        }

        c.stroke();
        c.globalCompositeOperation = 'source-over';
    };

    /**
     * Draws body positions
     * @private
     * @method bodyPositions
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyPositions = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            body,
            part,
            i,
            k;

        c.beginPath();

        // render current positions
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = 0; k < body.parts.length; k++) {
                part = body.parts[k];
                c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);
                c.closePath();
            }
        }

        if (options.wireframes) {
            c.fillStyle = 'indianred';
        } else {
            c.fillStyle = 'rgba(0,0,0,0.5)';
        }
        c.fill();

        c.beginPath();

        // render previous positions
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];
            if (body.render.visible) {
                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);
                c.closePath();
            }
        }

        c.fillStyle = 'rgba(255,165,0,0.8)';
        c.fill();
    };

    /**
     * Draws body velocity
     * @private
     * @method bodyVelocity
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyVelocity = function(render, bodies, context) {
        var c = context;

        c.beginPath();

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (!body.render.visible)
                continue;

            c.moveTo(body.position.x, body.position.y);
            c.lineTo(body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
        }

        c.lineWidth = 3;
        c.strokeStyle = 'cornflowerblue';
        c.stroke();
    };

    /**
     * Draws body ids
     * @private
     * @method bodyIds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyIds = function(render, bodies, context) {
        var c = context,
            i,
            j;

        for (i = 0; i < bodies.length; i++) {
            if (!bodies[i].render.visible)
                continue;

            var parts = bodies[i].parts;
            for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                var part = parts[j];
                c.font = "12px Arial";
                c.fillStyle = 'rgba(255,255,255,0.5)';
                c.fillText(part.id, part.position.x + 10, part.position.y - 10);
            }
        }
    };

    /**
     * Description
     * @private
     * @method collisions
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */
    Render.collisions = function(render, pairs, context) {
        var c = context,
            options = render.options,
            pair,
            collision,
            corrected,
            bodyA,
            bodyB,
            i,
            j;

        c.beginPath();

        // render collision positions
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;
            for (j = 0; j < pair.activeContacts.length; j++) {
                var contact = pair.activeContacts[j],
                    vertex = contact.vertex;
                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);
            }
        }

        if (options.wireframes) {
            c.fillStyle = 'rgba(255,255,255,0.7)';
        } else {
            c.fillStyle = 'orange';
        }
        c.fill();

        c.beginPath();
            
        // render collision normals
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;

            if (pair.activeContacts.length > 0) {
                var normalPosX = pair.activeContacts[0].vertex.x,
                    normalPosY = pair.activeContacts[0].vertex.y;

                if (pair.activeContacts.length === 2) {
                    normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;
                    normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;
                }
                
                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {
                    c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);
                } else {
                    c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);
                }

                c.lineTo(normalPosX, normalPosY);
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,165,0,0.7)';
        } else {
            c.strokeStyle = 'orange';
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method separations
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */
    Render.separations = function(render, pairs, context) {
        var c = context,
            options = render.options,
            pair,
            collision,
            corrected,
            bodyA,
            bodyB,
            i,
            j;

        c.beginPath();

        // render separations
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;
            bodyA = collision.bodyA;
            bodyB = collision.bodyB;

            var k = 1;

            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;
            if (bodyB.isStatic) k = 0;

            c.moveTo(bodyB.position.x, bodyB.position.y);
            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);

            k = 1;

            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;
            if (bodyA.isStatic) k = 0;

            c.moveTo(bodyA.position.x, bodyA.position.y);
            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,165,0,0.5)';
        } else {
            c.strokeStyle = 'orange';
        }
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method grid
     * @param {render} render
     * @param {grid} grid
     * @param {RenderingContext} context
     */
    Render.grid = function(render, grid, context) {
        var c = context,
            options = render.options;

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,180,0,0.1)';
        } else {
            c.strokeStyle = 'rgba(255,180,0,0.5)';
        }

        c.beginPath();

        var bucketKeys = Common.keys(grid.buckets);

        for (var i = 0; i < bucketKeys.length; i++) {
            var bucketId = bucketKeys[i];

            if (grid.buckets[bucketId].length < 2)
                continue;

            var region = bucketId.split(/C|R/);
            c.rect(0.5 + parseInt(region[1], 10) * grid.bucketWidth, 
                    0.5 + parseInt(region[2], 10) * grid.bucketHeight, 
                    grid.bucketWidth, 
                    grid.bucketHeight);
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method inspector
     * @param {inspector} inspector
     * @param {RenderingContext} context
     */
    Render.inspector = function(inspector, context) {
        var engine = inspector.engine,
            selected = inspector.selected,
            render = inspector.render,
            options = render.options,
            bounds;

        if (options.hasBounds) {
            var boundsWidth = render.bounds.max.x - render.bounds.min.x,
                boundsHeight = render.bounds.max.y - render.bounds.min.y,
                boundsScaleX = boundsWidth / render.options.width,
                boundsScaleY = boundsHeight / render.options.height;
            
            context.scale(1 / boundsScaleX, 1 / boundsScaleY);
            context.translate(-render.bounds.min.x, -render.bounds.min.y);
        }

        for (var i = 0; i < selected.length; i++) {
            var item = selected[i].data;

            context.translate(0.5, 0.5);
            context.lineWidth = 1;
            context.strokeStyle = 'rgba(255,165,0,0.9)';
            context.setLineDash([1,2]);

            switch (item.type) {

            case 'body':

                // render body selections
                bounds = item.bounds;
                context.beginPath();
                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3), 
                             Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));
                context.closePath();
                context.stroke();

                break;

            case 'constraint':

                // render constraint selections
                var point = item.pointA;
                if (item.bodyA)
                    point = item.pointB;
                context.beginPath();
                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);
                context.closePath();
                context.stroke();

                break;

            }

            context.setLineDash([]);
            context.translate(-0.5, -0.5);
        }

        // render selection region
        if (inspector.selectStart !== null) {
            context.translate(0.5, 0.5);
            context.lineWidth = 1;
            context.strokeStyle = 'rgba(255,165,0,0.6)';
            context.fillStyle = 'rgba(255,165,0,0.1)';
            bounds = inspector.selectBounds;
            context.beginPath();
            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y), 
                         Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));
            context.closePath();
            context.stroke();
            context.fill();
            context.translate(-0.5, -0.5);
        }

        if (options.hasBounds)
            context.setTransform(1, 0, 0, 1, 0, 0);
    };

    /**
     * Description
     * @method _createCanvas
     * @private
     * @param {} width
     * @param {} height
     * @return canvas
     */
    var _createCanvas = function(width, height) {
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        canvas.oncontextmenu = function() { return false; };
        canvas.onselectstart = function() { return false; };
        return canvas;
    };

    /**
     * Gets the pixel ratio of the canvas.
     * @method _getPixelRatio
     * @private
     * @param {HTMLElement} canvas
     * @return {Number} pixel ratio
     */
    var _getPixelRatio = function(canvas) {
        var context = canvas.getContext('2d'),
            devicePixelRatio = window.devicePixelRatio || 1,
            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio
                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio
                                      || context.backingStorePixelRatio || 1;

        return devicePixelRatio / backingStorePixelRatio;
    };

    /**
     * Gets the requested texture (an Image) via its path
     * @method _getTexture
     * @private
     * @param {render} render
     * @param {string} imagePath
     * @return {Image} texture
     */
    var _getTexture = function(render, imagePath) {
        var image = render.textures[imagePath];

        if (image)
            return image;

        image = render.textures[imagePath] = new Image();
        image.src = imagePath;

        return image;
    };

    /**
     * Applies the background to the canvas using CSS.
     * @method applyBackground
     * @private
     * @param {render} render
     * @param {string} background
     */
    var _applyBackground = function(render, background) {
        var cssBackground = background;

        if (/(jpg|gif|png)$/.test(background))
            cssBackground = 'url(' + background + ')';

        render.canvas.style.background = cssBackground;
        render.canvas.style.backgroundSize = "contain";
        render.currentBackground = background;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A back-reference to the `Matter.Render` module.
     *
     * @property controller
     * @type render
     */

    /**
     * A reference to the `Matter.Engine` instance to be used.
     *
     * @property engine
     * @type engine
     */

    /**
     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)
     *
     * @property element
     * @type HTMLElement
     * @default null
     */

    /**
     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.
     *
     * @property canvas
     * @type HTMLCanvasElement
     * @default null
     */

    /**
     * The configuration options of the renderer.
     *
     * @property options
     * @type {}
     */

    /**
     * The target width in pixels of the `render.canvas` to be created.
     *
     * @property options.width
     * @type number
     * @default 800
     */

    /**
     * The target height in pixels of the `render.canvas` to be created.
     *
     * @property options.height
     * @type number
     * @default 600
     */

    /**
     * A flag that specifies if `render.bounds` should be used when rendering.
     *
     * @property options.hasBounds
     * @type boolean
     * @default false
     */

    /**
     * A `Bounds` object that specifies the drawing view region. 
     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).
     * This allows for creating views that can pan or zoom around the scene.
     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.
     *
     * @property bounds
     * @type bounds
     */

    /**
     * The 2d rendering context from the `render.canvas` element.
     *
     * @property context
     * @type CanvasRenderingContext2D
     */

    /**
     * The sprite texture cache.
     *
     * @property textures
     * @type {}
     */

})();


/***/ },
/* 72 */
/***/ function(module, exports) {

module.exports = {

    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16

};


/***/ },
/* 73 */
/***/ function(module, exports) {

var Buffer16 = function (byteSize)
{
    this.wordLength = 0;
    this.wordCapacity = byteSize / 2;
    this.buffer = new ArrayBuffer(byteSize);
    this.intView = new Int16Array(this.buffer);
    this.uintView = new Uint16Array(this.buffer);
};

Buffer16.prototype.clear = function ()
{
    this.wordLength = 0;
};

Buffer16.prototype.getByteLength = function ()
{
    return this.wordLength * 2;
};

Buffer16.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

Buffer16.prototype.allocate = function (wordSize)
{
    var currentLength = this.wordLength;
    this.wordLength += wordSize;
    return currentLength;
};

Buffer16.prototype.getUsedBufferAsShort = function ()
{
    return this.intView.subarray(0, this.wordLength);
};

Buffer16.prototype.getUsedBufferAsWord = function ()
{
    return this.uintView.subarray(0, this.wordLength);
};

module.exports = Buffer16;


/***/ },
/* 74 */
/***/ function(module, exports) {


var NOOP = function ()
{
    //  NOOP (No Operation) Callback
};

module.exports = NOOP;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

var RND = __webpack_require__(457);

module.exports = {

    //  CONSTs (makes them visible under Phaser.Math)
    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,

    //  Collections of functions
    Angle: __webpack_require__(429),
    Distance: __webpack_require__(432),
    Easing: __webpack_require__(444),
    Fuzzy: __webpack_require__(450),
    Interpolation: __webpack_require__(453),
    Pow2: __webpack_require__(456),
    Snap: __webpack_require__(461),

    //  Random Data Generator
    RND: new RND(),

    //  Single functions
    Average: __webpack_require__(404),
    Bernstein: __webpack_require__(137),
    Between: __webpack_require__(64),
    CatmullRom: __webpack_require__(138),
    CeilTo: __webpack_require__(405),
    Clamp: __webpack_require__(139),
    DegToRad: __webpack_require__(406),
    Difference: __webpack_require__(407),
    Factorial: __webpack_require__(140),
    FloatBetween: __webpack_require__(408),
    FloorTo: __webpack_require__(409),
    Linear: __webpack_require__(141),
    MaxAdd: __webpack_require__(410),
    MinSub: __webpack_require__(411),
    Percent: __webpack_require__(412),
    RadToDeg: __webpack_require__(413),
    Rotate: __webpack_require__(414),
    RotateAround: __webpack_require__(415),
    RotateAroundDistance: __webpack_require__(416),
    RoundAwayFromZero: __webpack_require__(142),
    RoundTo: __webpack_require__(417),
    SinCosTableGenerator: __webpack_require__(418),
    SmootherStep: __webpack_require__(420),
    SmoothStep: __webpack_require__(419),
    Within: __webpack_require__(421),
    Wrap: __webpack_require__(42)

};


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Systems = __webpack_require__(158);

/**
* A Base State Class.
*
* @class Phaser.State
* @constructor
*/
var State = function (config)
{
    //  The State Systems. You must never overwrite this property, or all hell will break lose.
    this.sys = new Systems(this, config);

    this.settings = this.sys.settings;
};

State.prototype.constructor = State;

State.prototype = {

    //  Should be overridden by your own States
    update: function ()
    {
    },

    //  Should be overridden by your own States
    render: function ()
    {
    }

};

module.exports = State;


/***/ },
/* 77 */
/***/ function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ },
/* 78 */
/***/ function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			configurable: false,
			get: function() { return module.l; }
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			configurable: false,
			get: function() { return module.i; }
		});
		module.webpackPolyfill = 1;
	}
	return module;
}


/***/ },
/* 79 */
/***/ function(module, exports) {

var GetContext = function (canvas, options)
{
    return (
        canvas.getContext('2d', options) || 
        null
    );
};

module.exports = GetContext;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Event = __webpack_require__(5);
var EventDispatcher = __webpack_require__(23);

/**
* The Data Component features a means to store pieces of data specific to a Game Object,
* search it, query it, and retrieve it.
*
* @class
*/
var Data = function (parent)
{
    this.parent = parent;

    this.events = new EventDispatcher();

    this.list = {};

    this._beforeCallbacks = {};
    this._afterCallbacks = {};

    this._frozen = false;
};

Data.prototype.constructor = Data;

Data.prototype = {

    //  Retrieves the value for the given key, or undefined if it doesn't exist.
    get: function (key)
    {
        return this.list[key];
    },

    getAll: function ()
    {
        var results = {};

        for (var key in this.list)
        {
            results[key] = this.list[key];
        }

        return results;
    },

    query: function (search)
    {
        var results = {};

        for (var key in this.list)
        {
            if (key.match(search))
            {
                results[key] = this.list[key];
            }
        }

        return results;
    },

    set: function (key, data)
    {
        if (this._frozen)
        {
            return this;
        }

        var listener;
        var result;

        //  If there is a 'before' callback, then check it for a result
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            listener = this._beforeCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                data = result;
            }
        }

        // this.events.dispatch(new Event.LOADER_START_EVENT(this));

        this.list[key] = data;

        //  If there is a 'after' callback, then check it for a result
        if (this._afterCallbacks.hasOwnProperty(key))
        {
            listener = this._afterCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                this.list[key] = result;
            }
        }

        return this;
    },

    before: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._beforeCallbacks[key];
        }
        else
        {
            this._beforeCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    after: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._afterCallbacks[key];
        }
        else
        {
            this._afterCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    /**
    * Passes all data entries to the given callback. Stores the result of the callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [scope] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the game object, key, and data.
    */
    each: function (callback, scope)
    {
        var args = [ this.parent, null, undefined ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var key in this.list)
        {
            args[1] = key;
            args[2] = this.list[key];

            callback.apply(scope, args);
        }
    },

    merge: function (data, overwrite)
    {
        if (overwrite === undefined) { overwrite = true; }

        //  Merge data from another component into this one
        for (var key in data)
        {
            if (overwrite || (!overwrite && !this.has(key)))
            {
                this.list[key] = data;
            }
        }
    },

    remove: function (key)
    {
        if (!this._frozen && this.has(key))
        {
            delete this.list[key];

            this.removeListeners(key);
        }
    },

    removeListeners: function (key)
    {
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            delete this._beforeCallbacks[key];
        }

        if (this._afterCallbacks.hasOwnProperty(key))
        {
            delete this._afterCallbacks[key];
        }
    },

    //  Gets the data associated with the given 'key', deletes it from this Data store, then returns it.
    pop: function (key)
    {
        var data = undefined;

        if (!this._frozen && this.has(key))
        {
            data = this.list[key];

            delete this.list[key];

            this.removeListeners(key);
        }

        return data;
    },

    has: function (key)
    {
        return this.list.hasOwnProperty(key);
    },

    reset: function ()
    {
        for (var key in this.list)
        {
            delete this.list[key];
        }

        for (key in this._beforeCallbacks)
        {
            delete this._beforeCallbacks[key];
        }

        for (key in this._afterCallbacks)
        {
            delete this._afterCallbacks[key];
        }

        this._frozen = false;
    }

};

Object.defineProperties(Data.prototype, {

    /**
    * Freeze this Data component, so no changes can be written to it.
    *
    * @name freeze
    * @property {boolean} freeze
    */
    freeze: {

        enumerable: true,

        get: function ()
        {
            return this._frozen;
        },

        set: function (value)
        {
            this._frozen = (value) ? true : false;
        }

    },

    count: {

        enumerable: true,

        get: function ()
        {
            var i = 0;

            for (var key in this.list)
            {
                if (this.list[key] !== undefined)
                {
                    i++;
                }
            }

            return i;
        }

    }

});

module.exports = Data;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(28);

var CanvasFeatures = {

    supportNewBlendModes: false,

    supportInverseAlpha: false

};

function checkBlendMode ()
{
    var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
    var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';

    var magenta = new Image();
    magenta.src = pngHead + 'AP804Oa6' + pngEnd;

    var yellow = new Image();
    yellow.src = pngHead + '/wCKxvRF' + pngEnd;

    var canvas = CanvasPool.create(this, 6, 1);
    var context = canvas.getContext('2d');

    context.globalCompositeOperation = 'multiply';
    context.drawImage(magenta, 0, 0);
    context.drawImage(yellow, 2, 0);

    if (!context.getImageData(2, 0, 1, 1))
    {
        return false;
    }

    var data = context.getImageData(2, 0, 1, 1).data;

    CanvasPool.remove(this);

    return (data[0] === 255 && data[1] === 0 && data[2] === 0);
}

function checkInverseAlpha ()
{
    var canvas = CanvasPool.create(this, 2, 1);
    var context = canvas.getContext('2d');

    context.fillStyle = 'rgba(10, 20, 30, 0.5)';

    //  Draw a single pixel
    context.fillRect(0, 0, 1, 1);

    //  Get the color values
    var s1 = context.getImageData(0, 0, 1, 1);

    if (s1 === null)
    {
        return false;
    }

    //  Plot them to x2
    context.putImageData(s1, 1, 0);

    //  Get those values
    var s2 = context.getImageData(1, 0, 1, 1);

    //  Compare and return
    return (s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]);
}

function init ()
{
    if (document !== undefined)
    {
        CanvasFeatures.supportNewBlendModes = checkBlendMode();
        CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
    }

    return CanvasFeatures;
}

module.exports = init();


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(19);
var Browser = __webpack_require__(27);
var CanvasPool = __webpack_require__(28);

var Features = {

    /**
    * @property {boolean} canvas - Is canvas available?
    * @default
    */
    canvas: false,

    /**
    * @property {?boolean} canvasBitBltShift - True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.
    * @default
    */
    canvasBitBltShift: null,

    /**
    * @property {boolean} webGL - Is webGL available?
    * @default
    */
    webGL: false,

    /**
    * @property {boolean} file - Is file available?
    * @default
    */
    file: false,

    /**
    * @property {boolean} fileSystem - Is fileSystem available?
    * @default
    */
    fileSystem: false,

    /**
    * @property {boolean} localStorage - Is localStorage available?
    * @default
    */
    localStorage: false,

    /**
    * @property {boolean} worker - Is worker available?
    * @default
    */
    worker: false,

    /**
    * @property {boolean} pointerLock - Is Pointer Lock available?
    * @default
    */
    pointerLock: false,

    /**
    * @property {boolean} vibration - Does the device support the Vibration API?
    * @default
    */
    vibration: false,

    /**
    * @property {boolean} getUserMedia - Does the device support the getUserMedia API?
    * @default
    */
    getUserMedia: true,

    /**
    * @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)
    * @default
    */
    littleEndian: false,

    /**
    * @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?
    * @default
    */
    support32bit: false

};

/**
* Check Little or Big Endian system.
*
* @author Matt DesLauriers (@mattdesl)
*/
function checkIsLittleEndian ()
{
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);

    b[0] = 0xa1;
    b[1] = 0xb2;
    b[2] = 0xc3;
    b[3] = 0xd4;

    if (c[0] === 0xd4c3b2a1)
    {
        return true;
    }

    if (c[0] === 0xa1b2c3d4)
    {
        return false;
    }
    else
    {
        //  Could not determine endianness
        return null;
    }
}

function init ()
{
    Features.canvas = !!window['CanvasRenderingContext2D'] || OS.cocoonJS;

    try
    {
        Features.localStorage = !!localStorage.getItem;
    }
    catch (error)
    {
        Features.localStorage = false;
    }

    Features.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];
    Features.fileSystem = !!window['requestFileSystem'];

    var isUint8 = false;

    var testWebGL = function ()
    {
        if (window['WebGLRenderingContext'])
        {
            try
            {
                var canvas = CanvasPool.createWebGL(this);

                if (OS.cocoonJS)
                {
                    canvas.screencanvas = false;
                }

                var ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                var canvas2D = CanvasPool.create2D(this);

                var ctx2D = canvas2D.getContext('2d');

                //  Can't be done on a webgl context
                var image = ctx2D.createImageData(1, 1);
    
                /**
                * Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.
                *
                * @author Matt DesLauriers (@mattdesl)
                */
                isUint8 = image.data instanceof Uint8ClampedArray;

                CanvasPool.remove(canvas);
                CanvasPool.remove(canvas2D);

                return (ctx !== null);
            }
            catch (e)
            {
                return false;
            }
        }
        
        return false;
    };

    Features.webGL = true;//testWebGL();

    Features.worker = !!window['Worker'];

    Features.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

    window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;

    // Older versions of firefox (< 21) apparently claim support but user media does not actually work
    if (Browser.firefox && Browser.firefoxVersion < 21)
    {
        Features.getUserMedia = false;
    }

    // Excludes iOS versions as they generally wrap UIWebView (eg. Safari WebKit) and it
    // is safer to not try and use the fast copy-over method.
    if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome))
    {
        Features.canvasBitBltShift = true;
    }

    // Known not to work
    if (Browser.safari || Browser.mobileSafari)
    {
        Features.canvasBitBltShift = false;
    }

    navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;

    if (navigator.vibrate)
    {
        Features.vibration = true;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined')
    {
        Features.littleEndian = checkIsLittleEndian();
    }

    Features.support32bit = (
        typeof ArrayBuffer !== 'undefined' &&
        typeof Uint8ClampedArray !== 'undefined' &&
        typeof Int32Array !== 'undefined' &&
        Features.littleEndian !== null &&
        isUint8
    );

    return Features;
}

module.exports = init();


/***/ },
/* 83 */
/***/ function(module, exports) {

var AddToDOM = function (element, parent, overflowHidden)
{
    if (overflowHidden === undefined) { overflowHidden = true; }

    var target;

    if (parent)
    {
        if (typeof parent === 'string')
        {
            //  Hopefully an element ID
            target = document.getElementById(parent);
        }
        else if (typeof parent === 'object' && parent.nodeType === 1)
        {
            //  Quick test for a HTMLelement
            target = parent;
        }
    }

    //  Fallback, covers an invalid ID and a non HTMLelement object
    if (!target)
    {
        target = document.body;
    }

    if (overflowHidden && target.style)
    {
        target.style.overflow = 'hidden';
    }

    target.appendChild(element);

    return element;
};

module.exports = AddToDOM;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var OS = __webpack_require__(19);

var isBooted = false;

var DOMContentLoaded = function (callback)
{
    if (isBooted)
    {
        return;
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive')
    {
        isBooted = true;
        
        callback();

        return;
    }

    var check = function ()
    {
        isBooted = true;

        document.removeEventListener('deviceready', check, true);
        document.removeEventListener('DOMContentLoaded', check, true);
        window.removeEventListener('load', check, true);

        callback();
    };

    if (!document.body)
    {
        window.setTimeout(check, 20);
    }
    else if (OS.cordova && !OS.cocoonJS)
    {
        //  Ref. http://docs.phonegap.com/en/3.5.0/cordova_events_events.md.html#deviceready
        document.addEventListener('deviceready', check, false);
    }
    else
    {
        document.addEventListener('DOMContentLoaded', check, true);
        window.addEventListener('load', check, true);
    }
};

module.exports = DOMContentLoaded;


/***/ },
/* 85 */
/***/ function(module, exports) {

var ParseXML = function (data)
{
    var xml = '';

    try
    {
        if (window['DOMParser'])
        {
            var domparser = new DOMParser();
            xml = domparser.parseFromString(data, 'text/xml');
        }
        else
        {
            xml = new ActiveXObject('Microsoft.XMLDOM');
            xml.loadXML(data);
        }
    }
    catch (e)
    {
        xml = null;
    }

    if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length)
    {
        return null;
    }
    else
    {
        return xml;
    }
};

module.exports = ParseXML;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var NOOP = __webpack_require__(74);

/**
* Abstracts away the use of RAF or setTimeOut for the core game update loop.
*
* @class Phaser.RequestAnimationFrame
* @constructor
* @param {boolean} [forceSetTimeOut=false] - Tell Phaser to use setTimeOut even if raf is available.
*/
var RequestAnimationFrame = function ()
{
    /**
    * @property {boolean} isRunning - true if RequestAnimationFrame is running, otherwise false.
    * @default
    */
    this.isRunning = false;

    this.callback = NOOP;

    this.tick = 0;

    /**
    * @property {boolean} isSetTimeOut  - True if the browser is using setTimeout instead of rAf.
    */
    this.isSetTimeOut = false;

    /**
    * @property {number} timeOutID - The callback setTimeout or rAf callback ID used when calling cancel.
    */
    this.timeOutID = null;

    var _this = this;

    //  timestamp = DOMHighResTimeStamp
    var step = function (timestamp)
    {
        _this.tick = timestamp;

        _this.timeOutID = window.requestAnimationFrame(step);

        _this.callback(timestamp);
    };

    var stepTimeout = function ()
    {
        var d = Date.now();

        _this.tick = d;

        _this.timeOutID = window.setTimeout(stepTimeout, _this.timeToCall);

        _this.callback(d);
    };

    this.step = step;
    this.stepTimeout = stepTimeout;
};

RequestAnimationFrame.prototype.constructor = RequestAnimationFrame;

RequestAnimationFrame.prototype = {

    /**
    * Starts the requestAnimationFrame running or setTimeout if unavailable in browser
    * @method Phaser.RequestAnimationFrame#start
    */
    start: function (callback, forceSetTimeOut)
    {
        this.callback = callback;

        this.isSetTimeOut = forceSetTimeOut;

        this.isRunning = true;

        var _this = this;

        this.timeOutID = (forceSetTimeOut) ? window.setTimeout(_this.stepTimeout, 0) : window.requestAnimationFrame(_this.step);
    },

    /**
    * Stops the requestAnimationFrame from running.
    * @method Phaser.RequestAnimationFrame#stop
    */
    stop: function ()
    {
        this.isRunning = false;

        if (this.isSetTimeOut)
        {
            clearTimeout(this.timeOutID);
        }
        else
        {
            window.cancelAnimationFrame(this.timeOutID);
        }
    },

    destroy: function ()
    {
        this.stop();

        this.callback = NOOP;
    }

};

module.exports = RequestAnimationFrame;


/***/ },
/* 87 */
/***/ function(module, exports) {

var EVENT_CONST = {

    DISPATCHER_IDLE: 0,
    DISPATCHER_DISPATCHING: 1,
    DISPATCHER_REMOVING: 2,
    DISPATCHER_DESTROYED: 3,

    LISTENER_PENDING: 4,
    LISTENER_ACTIVE: 5,
    LISTENER_REMOVING: 6

};

module.exports = EVENT_CONST;


/***/ },
/* 88 */
/***/ function(module, exports) {


var GetBitmapTextSize = function (src)
{
    var text = src.text;
    var textLength = text.length;

    var bx = Number.MAX_VALUE;
    var by = Number.MAX_VALUE;
    var bw = 0;
    var bh = 0;
    
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = indexCount + glyph.xOffset + xAdvance;
        y = glyph.yOffset + yAdvance;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (bx > x)
        {
            bx = x;
        }

        if (by > y)
        {
            by = y;
        }

        var gw = x + glyphW - bx;
        var gh = y + glyphH - by;

        if (bw < gw)
        {
            bw = gw;
        }
        
        if (bh < gh)
        {
            bh = gh;
        }

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    var scale = (src.fontSize / src.fontData.size);
    var sx = scale * src.scaleX;
    var sy = scale * src.scaleY;

    return {
        local: {
            x: bx * scale,
            y: by * scale,
            width: bw * scale,
            height: bh * scale
        },
        global: {
            x: src.x + (bx * sx),
            y: src.y + (by * sy),
            width: bw * sx,
            height: bh * sy
        }
    };
};

module.exports = GetBitmapTextSize;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

var Class = __webpack_require__(9);
var GameObject = __webpack_require__(24);
var Components = __webpack_require__(8);
var Render = __webpack_require__(216);
var GetBitmapTextSize = __webpack_require__(88);

var DynamicBitmapText = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Origin,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Render
    ],

    initialize:

    function DynamicBitmapText (state, x, y, font, text, size, align)
    {
        if (text === undefined) { text = ''; }
        if (size === undefined) { size = 32; }
        if (align === undefined) { align = 'left'; }

        GameObject.call(this, state);

        this.fontData = this.state.sys.cache.bitmapFont.get(font);

        this.text = text;

        this.fontSize = size;

        this.displayCallback;

        this.setTexture(font);
        this.setPosition(x, y);
    },

    setDisplayCallback: function (callback)
    {
        this.displayCallback = callback;

        return this;
    },

    setFontSize: function (size)
    {
        this.fontSize = size;

        return this;
    },

    setText: function (text)
    {
        this.text = text;

        return this;
    },

    // {
    //     local: {
    //         x,
    //         y,
    //         width,
    //         height
    //     },
    //     global: {
    //         x,
    //         y,
    //         width,
    //         height
    //     }
    // }

    getTextBounds: function ()
    {
        //  local = the BitmapText based on fontSize and 0x0 coords
        //  global = the BitmapText, taking into account scale and world position

        return GetBitmapTextSize(this);
    }

});

module.exports = DynamicBitmapText;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

var Class = __webpack_require__(9);
var GameObject = __webpack_require__(24);
var Components = __webpack_require__(8);
var Render = __webpack_require__(220);
var GetBitmapTextSize = __webpack_require__(88);

var BitmapText = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Origin,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Render
    ],

    initialize:

    function BitmapText (state, x, y, font, text, size, align)
    {
        if (text === undefined) { text = ''; }
        if (size === undefined) { size = 32; }
        if (align === undefined) { align = 'left'; }

        GameObject.call(this, state);

        this.fontData = this.state.sys.cache.bitmapFont.get(font);

        this.text = text;

        this.fontSize = size;

        this.setTexture(font);
        this.setPosition(x, y);
    },

    setFontSize: function (size)
    {
        this.fontSize = size;

        return this;
    },

    setText: function (text)
    {
        this.text = text;

        return this;
    },

    // {
    //     local: {
    //         x,
    //         y,
    //         width,
    //         height
    //     },
    //     global: {
    //         x,
    //         y,
    //         width,
    //         height
    //     }
    // }

    getTextBounds: function ()
    {
        //  local = the BitmapText based on fontSize and 0x0 coords
        //  global = the BitmapText, taking into account scale and world position

        return GetBitmapTextSize(this);
    }

});

module.exports = BitmapText;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(9);
var GameObject = __webpack_require__(24);
var Components = __webpack_require__(8);
var BlitterRender = __webpack_require__(224);
var Bob = __webpack_require__(226);

/**
* A Blitter Game Object.
*
* The Blitter Game Object is a special type of Container, that contains Blitter.Bob objects.
* These objects can be thought of as just texture frames with a position and nothing more.
* Bobs don't have any update methods, or the ability to have children, or any kind of special effects.
* They are essentially just super-fast texture frame renderers, and the Blitter object creates and manages them.
*
* @class Blitter
* @extends Phaser.GameObject
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
* @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {string} [key] - The texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
* @param {string|number} [frame] - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
*/

var Blitter = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        BlitterRender
    ],

    initialize:

    function Blitter (state, x, y, texture, frame)
    {
        GameObject.call(this, state);

        this.setTexture(texture, frame);
        this.setPosition(x, y);

        this.children = new Components.Children(this);

        this.renderList = [];

        this.dirty = false;
    },

    //  frame MUST be part of the Blitter texture
    create: function (x, y, frame, visible, index)
    {
        if (frame === undefined) { frame = this.frame; }
        if (visible === undefined) { visible = true; }
        if (index === undefined) { index = this.children.length; }

        if (typeof frame === 'string')
        {
            frame = this.texture.get(frame);
        }

        var bob = new Bob(this, x, y, frame, visible);

        this.children.addAt(bob, index, false);

        this.dirty = true;

        return bob;
    },

    //  frame MUST be part of the Blitter texture
    createFromCallback: function (callback, quantity, frame, visible)
    {
        var bobs = this.createMultiple(quantity, frame, visible);

        for (var i = 0; i < bobs.length; i++)
        {
            var bob = bobs[i];

            callback.call(this, bob, i);
        }

        return bobs;
    },

    //  frame MUST be part of the Blitter texture
    createMultiple: function (quantity, frame, visible)
    {
        if (frame === undefined) { frame = this.frame; }
        if (visible === undefined) { visible = true; }

        if (!Array.isArray(frame))
        {
            frame = [ frame ];
        }

        var bobs = [];
        var _this = this;

        frame.forEach(function (singleFrame)
        {
            for (var i = 0; i < quantity; i++)
            {
                bobs.push(_this.create(0, 0, singleFrame, visible));
            }
        });

        return bobs;
    },

    childCanRender: function (child)
    {
        return (child.visible && child.alpha > 0);
    },

    getRenderList: function ()
    {
        if (this.dirty)
        {
            this.renderList = this.children.list.filter(this.childCanRender, this);
            this.dirty = false;
        }

        return this.renderList;
    },

    clear: function ()
    {
        this.children.removeAll();
        this.dirty = true;
    }

});

module.exports = Blitter;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(9);
var GameObject = __webpack_require__(24);
var Components = __webpack_require__(8);
var ContainerRender = __webpack_require__(229);

var Container = new Class({

    Mixins: [
        Components.Visible,
        ContainerRender
    ],

    initialize:

    function Container (state)
    {
        GameObject.call(this, state);

        this.children = new Components.Children(this);
    }

});

module.exports = Container;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

var Class = __webpack_require__(9);
var GameObject = __webpack_require__(24);
var Components = __webpack_require__(8);
var Render = __webpack_require__(233);
var Commands = __webpack_require__(53);
var MATH_CONST = __webpack_require__(7);

var Graphics = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Transform,
        Components.Visible,
        Render
    ],

    initialize:

    function Graphics (state, x, y)
    {
        GameObject.call(this, state);

        this.setPosition(x, y);

        this.commandBuffer = [];
    },

    arc: function (x, y, radius, startAngle, endAngle, anticlockwise)
    {
        this.commandBuffer.push(
            Commands.ARC,
            x, y, radius, startAngle, endAngle, anticlockwise
        );
    },

    lineStyle: function (lineWidth, color, alpha)
    {
        this.commandBuffer.push(
            Commands.LINE_STYLE,
            lineWidth, color, alpha
        );
    },

    fillStyle: function (color, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.commandBuffer.push(
            Commands.FILL_STYLE,
            color, alpha
        );
    },

    beginPath: function ()
    {
        this.commandBuffer.push(
            Commands.BEGIN_PATH
        );
    },

    closePath: function ()
    {
        this.commandBuffer.push(
            Commands.CLOSE_PATH
        );
    },

    fillPath: function ()
    {
        this.commandBuffer.push(
            Commands.FILL_PATH
        );
    },

    strokePath: function ()
    {
        this.commandBuffer.push(
            Commands.STROKE_PATH
        );
    },

    fillCircle: function (x, y, radius)
    {
        this.beginPath();
        this.arc(x, y, radius, 0, MATH_CONST.PI2);
        this.fillPath();
        this.closePath();
    },

    fillRect: function (x, y, width, height)
    {
        this.commandBuffer.push(
            Commands.FILL_RECT,
            x, y, width, height
        );
    },

    fillTriangle: function (x0, y0, x1, y1, x2, y2)
    {
        this.commandBuffer.push(
            Commands.FILL_TRIANGLE,
            x0, y0, x1, y1, x2, y2
        );
    },

    strokeCircle: function (x, y, radius)
    {
        this.beginPath();
        this.arc(x, y, radius, 0, MATH_CONST.PI2);
        this.closePath();
        this.strokePath();
    },

    strokeRect: function (x, y, width, height)
    {
        this.beginPath();
        this.moveTo(x, y);
        this.lineTo(x + width, y);
        this.lineTo(x + width, y + height);
        this.lineTo(x, y + height);
        this.lineTo(x, y);
        this.strokePath();
        this.closePath();
    },

    strokeTriangle: function (x0, y0, x1, y1, x2, y2)
    {
        this.commandBuffer.push(
            Commands.STROKE_TRIANGLE,
            x0, y0, x1, y1, x2, y2
        );
    },

    lineTo: function (x, y)
    {
        this.commandBuffer.push(
            Commands.LINE_TO,
            x, y
        );
    },

    moveTo: function (x, y)
    {
        this.commandBuffer.push(
            Commands.MOVE_TO,
            x, y
        );
    },

    clear: function ()
    {
        this.commandBuffer.length = 0;
    }

});

module.exports = Graphics;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(9);
var GameObject = __webpack_require__(24);
var Components = __webpack_require__(8);
var ImageRender = __webpack_require__(237);

var Image = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.GetBounds,
        Components.Origin,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        ImageRender
    ],

    initialize:

    function Image (state, x, y, texture, frame)
    {
        GameObject.call(this, state);

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOriginToCenter();
    }

});

module.exports = Image;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(9);
var GameObject = __webpack_require__(24);
var Components = __webpack_require__(8);
var SpriteRender = __webpack_require__(241);

var Sprite = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.GetBounds,
        Components.Origin,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        SpriteRender
    ],

    initialize:

    function Sprite (state, x, y, texture, frame)
    {
        GameObject.call(this, state);

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOriginToCenter();
    }

});

module.exports = Sprite;


/***/ },
/* 96 */
/***/ function(module, exports) {

var Circle = function (x, y, radius)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (radius === undefined) { radius = 0; }

    this.x = x;

    this.y = y;

    this._radius = radius;
    this._diameter = radius * 2;
};

Circle.prototype.constructor = Circle;

Circle.prototype = {

    setTo: function (x, y, radius)
    {
        this.x = x;
        this.y = y;
        this._radius = radius;
        this._diameter = radius * 2;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    isEmpty: function ()
    {
        return (this._radius <= 0);
    }

};

Object.defineProperties(Circle.prototype, {

    radius: {

        enumerable: true,

        get: function ()
        {
            return this._radius;
        },

        set: function (value)
        {
            this._radius = value;
            this._diameter = value * 2;
        }

    },

    diameter: {

        enumerable: true,

        get: function ()
        {
            return this._diameter;
        },

        set: function (value)
        {
            this._diameter = value;
            this._radius = value * 0.5;
        }

    },

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x - this._radius;
        },

        set: function (value)
        {
            this.x = value + this._radius;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this._radius;
        },

        set: function (value)
        {
            this.x = value - this._radius;
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y - this._radius;
        },

        set: function (value)
        {
            this.y = value + this._radius;
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this._radius;
        },

        set: function (value)
        {
            this.y = value - this._radius;
        }

    }

});

module.exports = Circle;


/***/ },
/* 97 */
/***/ function(module, exports) {

var Ellipse = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Ellipse.prototype.constructor = Ellipse;

Ellipse.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    },

    //  AKA Semi Minor Axis
    getMinorRadius: function ()
    {
        return Math.min(this.width, this.height) / 2;
    },

    //  AKA Semi Major Axis
    getMajorRadius: function ()
    {
        return Math.max(this.width, this.height) / 2;
    }

};

Object.defineProperties(Ellipse.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Ellipse;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

var GetPoint = __webpack_require__(57);

/**
* Calculate and return the angle, in radians, of the curves tangent based on time.
*
* @method Phaser.Hermite#getAngle
* @param {number} [t=0] - The `t` (time) value at which to find the angle. Must be between 0 and 1.
* @return {number} The angle of the line at the specified `t` time value along the curve. The value is in radians.
*/
var GetAngle = function (curve, t)
{
    if (t === undefined) { t = 0; }

    GetPoint(curve, t - 0.01, curve._temp1);
    GetPoint(curve, t + 0.01, curve._temp2);

    return Math.atan2(curve._temp2.y - curve._temp1.y, curve._temp2.x - curve._temp1.x);
};

module.exports = GetAngle;


/***/ },
/* 99 */
/***/ function(module, exports) {

var PointToLine = function (point, line)
{
    return ((point.x - line.x1) * (line.y2 - line.y1) === (line.x2 - line.x1) * (point.y - line.y1));
};

module.exports = PointToLine;


/***/ },
/* 100 */
/***/ function(module, exports) {

var RectangleToRectangle = function (rectA, rectB)
{
    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0)
    {
        return false;
    }

    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
};

module.exports = RectangleToRectangle;


/***/ },
/* 101 */
/***/ function(module, exports) {

//  Defines a Line segment, a part of a line between two endpoints

var Line = function (x1, y1, x2, y2)
{
    if (x1 === undefined) { x1 = 0; }
    if (y1 === undefined) { y1 = 0; }
    if (x2 === undefined) { x2 = 0; }
    if (y2 === undefined) { y2 = 0; }

    this.x1 = x1;

    this.y1 = y1;

    this.x2 = x2;

    this.y2 = y2;
};

Line.prototype.constructor = Line;

Line.prototype = {

    setTo: function (x1, y1, x2, y2)
    {
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }

        this.x1 = x1;
        this.y1 = y1;

        this.x2 = x2;
        this.y2 = y2;

        return this;
    }

};

Object.defineProperties(Line.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 <= this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 > this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 <= this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 > this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    }

});

module.exports = Line;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(7);
var Wrap = __webpack_require__(42);
var Angle = __webpack_require__(29);

var NormalAngle = function (line)
{
    var angle = Angle(line) - MATH_CONST.TAU;

    return Wrap(angle, -Math.PI, Math.PI);
};

module.exports = NormalAngle;


/***/ },
/* 103 */
/***/ function(module, exports) {

var GetMagnitude = function (point)
{
    return Math.sqrt((point.x * point.x) + (point.y * point.y));
};

module.exports = GetMagnitude;


/***/ },
/* 104 */
/***/ function(module, exports) {

var GetMagnitudeSq = function (point)
{
    return (point.x * point.x) + (point.y * point.y);
};

module.exports = GetMagnitudeSq;


/***/ },
/* 105 */
/***/ function(module, exports) {

var Multiply = function (point, x, y)
{
    point.x *= x;
    point.y *= y;

    return point;
};

module.exports = Multiply;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

var GetMagnitude = __webpack_require__(103);

var Normalize = function (point)
{
    if (point.x !== 0 && point.y !== 0)
    {
        var m = GetMagnitude(point);

        point.x /= m;
        point.y /= m;
    }

    return point;
};

module.exports = Normalize;


/***/ },
/* 107 */
/***/ function(module, exports) {

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var Contains = function (polygon, x, y)
{
    //  Adapted from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html by Jonas Raoni Soares Silva

    var inside = false;

    for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i)
    {
        var ix = polygon.points[i].x;
        var iy = polygon.points[i].y;

        var jx = polygon.points[j].x;
        var jy = polygon.points[j].y;

        if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))
        {
            inside = !inside;
        }
    }

    return inside;
};

module.exports = Contains;


/***/ },
/* 108 */
/***/ function(module, exports) {

var Polygon = function (points)
{
    /**
    * @property {number} area - The area of this Polygon.
    */
    this.area = 0;

    /**
    * @property {array} points - An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]
    */
    this.points = [];

    if (points)
    {
        this.setTo(points);
    }
};

Polygon.prototype.constructor = Polygon;

Polygon.prototype = {

    /**
     * Sets this Polygon to the given points.
     *
     * The points can be set from a variety of formats:
     *
     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
     *
     * `setTo` may also be called without any arguments to remove all points.
     *
     * @method Phaser.Polygon#setTo
     * @param {Phaser.Point[]|number[]|...Phaser.Point|...number} points - The points to set.
     * @return {Phaser.Polygon} This Polygon object
     */
    setTo: function (points)
    {
        this.area = 0;
        this.points = [];

        if (!Array.isArray(points))
        {
            return this;
        }

        var entry;
        var y0 = Number.MAX_VALUE;
        var p;

        //  The points argument is an array, so iterate through it
        for (var i = 0; i < points.length; i++)
        {
            p = { x: 0, y: 0 };

            if (typeof points[i] === 'number')
            {
                p.x = points[i];
                p.y = points[i + 1];
                i++;
            }
            else if (Array.isArray(entry))
            {
                //  An array of arrays?
                p.x = points[i][0];
                p.y = points[i][1];
            }
            else
            {
                p.x = points[i].x;
                p.y = points[i].y;
            }

            this.points.push(p);

            //  Lowest boundary
            if (p.y < y0)
            {
                y0 = p.y;
            }
        }

        this.calculateArea(y0);

        return this;
    },

    /**
     * Calculates the area of the Polygon. This is available in the property Polygon.area
     *
     * @method Phaser.Polygon#calculateArea
     * @private
     * @param {number} y0 - The lowest boundary
     * @return {number} The area of the Polygon.
     */
    calculateArea: function (y0)
    {
        if (this.points.length < 3)
        {
            this.area = 0;

            return this.area;
        }

        var sum = 0;
        var p1;
        var p2;

        for (var i = 0; i < this.points.length - 1; i++)
        {
            p1 = this.points[i];
            p2 = this.points[i + 1];

            sum += (p2.x - p1.x) * (p1.y + p2.y);
        }

        p1 = this.points[0];
        p2 = this.points[this.points.length - 1];

        sum += (p1.x - p2.x) * (p2.y + p1.y);

        this.area = -sum * 0.5;

        // var p1;
        // var p2;
        // var avgHeight;
        // var width;

        // for (var i = 0, len = this.points.length; i < len; i++)
        // {
        //     p1 = this.points[i];

        //     if (i === len - 1)
        //     {
        //         p2 = this.points[0];
        //     }
        //     else
        //     {
        //         p2 = this.points[i + 1];
        //     }

        //     avgHeight = ((p1.y - y0) + (p2.y - y0)) / 2;
        //     width = p1.x - p2.x;
        //     this.area += avgHeight * width;
        // }

        return this.area;
    }

};

module.exports = Polygon;


/***/ },
/* 109 */
/***/ function(module, exports) {

var Contains = function (rect, x, y)
{
    if (rect.width <= 0 || rect.height <= 0)
    {
        return false;
    }

    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);
};

module.exports = Contains;


/***/ },
/* 110 */
/***/ function(module, exports) {

/**
* Adds the source and backdrop colors together and returns the value, up to a maximum of 255.
*
* @method Lazer.Color.blendAdd
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Add = function (a, b)
{
    return Math.min(255, a + b);
};

module.exports = Add;


/***/ },
/* 111 */
/***/ function(module, exports) {

/**
* Darkens the backdrop color to reflect the source color.
* Painting with white produces no change. 
*
* @method Lazer.Color.blendColorBurn
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var ColorBurn = function (a, b)
{
    return (b === 0) ? b : Math.max(0, (255 - ((255 - a) << 8) / b));
};

module.exports = ColorBurn;


/***/ },
/* 112 */
/***/ function(module, exports) {

/**
* Brightens the backdrop color to reflect the source color. 
* Painting with black produces no change.
*
* @method Lazer.Color.blendColorDodge
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var ColorDodge = function (a, b)
{
    return (b === 255) ? b : Math.min(255, ((a << 8) / (255 - b)));
};

module.exports = ColorDodge;


/***/ },
/* 113 */
/***/ function(module, exports) {

/**
* Selects the darker of the backdrop and source colors.
*
* @method Lazer.Color.blendDarken
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Darken = function (a, b)
{
    return (b > a) ? a : b;
};

module.exports = Darken;


/***/ },
/* 114 */
/***/ function(module, exports) {

/**
* Selects the lighter of the backdrop and source colors.
*
* @method Lazer.Color.blendLighten
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Lighten = function (a, b)
{
    return (b > a) ? b : a;
};

module.exports = Lighten;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

var Subtract = __webpack_require__(119);

/**
* An alias for blendSubtract, it simply sums the values of the two colors and subtracts 255.
*
* @method Lazer.Color.blendLinearBurn
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var LinearBurn = function (a, b)
{
    return Subtract(a, b);
};

module.exports = LinearBurn;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

var Add = __webpack_require__(110);

/**
* An alias for blendAdd, it simply sums the values of the two colors.
*
* @method Lazer.Color.blendLinearDodge
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var LinearDodge = function (a, b)
{
    return Add(a, b);
};

module.exports = LinearDodge;


/***/ },
/* 117 */
/***/ function(module, exports) {

/**
* Multiplies or screens the colors, depending on the backdrop color.
* Source colors overlay the backdrop while preserving its highlights and shadows. 
* The backdrop color is not replaced, but is mixed with the source color to reflect the lightness or darkness of the backdrop.
*
* @method Lazer.Color.blendOverlay
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Overlay = function (a, b)
{
    return (b < 128) ? (2 * a * b / 255) : (255 - 2 * (255 - a) * (255 - b) / 255);
};

module.exports = Overlay;


/***/ },
/* 118 */
/***/ function(module, exports) {

/**
* Reflect blend mode. This mode is useful when adding shining objects or light zones to images. 
*
* @method Lazer.Color.blendReflect
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Reflect = function (a, b)
{
    return (b === 255) ? b : Math.min(255, (a * a / (255 - b)));
};

module.exports = Reflect;


/***/ },
/* 119 */
/***/ function(module, exports) {

/**
* Combines the source and backdrop colors and returns their value minus 255.
*
* @method Lazer.Color.blendSubtract
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Subtract = function (a, b)
{
    return Math.max(0, a + b - 255);
};

module.exports = Subtract;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

var ColorBurn = __webpack_require__(111);
var ColorDodge = __webpack_require__(112);

/**
* This blend mode combines Color Dodge and Color Burn (rescaled so that neutral colors become middle gray).
* Dodge applies when values in the top layer are lighter than middle gray, and burn to darker values.
* The middle gray is the neutral color. When color is lighter than this, this effectively moves the white point of the bottom 
* layer down by twice the difference; when it is darker, the black point is moved up by twice the difference. The perceived contrast increases.
*
* @method Lazer.Color.blendVividLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var VividLight = function (a, b)
{
    return (b < 128) ? ColorBurn(a, 2 * b) : ColorDodge(a, (2 * (b - 128)));
};

module.exports = VividLight;


/***/ },
/* 121 */
/***/ function(module, exports) {

/**
* Return a string containing a hex representation of the given color component.
*
* @param {integer} color - The color channel to get the hex value for, must be a value between 0 and 255.
* @return {string} A string of length 2 characters, i.e. 255 = ff, 100 = 64.
*/
var ComponentToHex = function (color)
{
    var hex = color.toString(16);

    return (hex.length === 1) ? '0' + hex : hex;
};

module.exports = ComponentToHex;


/***/ },
/* 122 */
/***/ function(module, exports) {

/**
 * Given an alpha and 3 color values this will return an integer representation of it.
 *
 * @method getColor32
 * @param {integer} r - The red color component in the range 0 - 255.
 * @param {integer} g - The green color component in the range 0 - 255.
 * @param {integer} b - The blue color component in the range 0 - 255.
 * @return {integer} A native color value integer (format: 0xRRGGBB).
 */
var GetColor32 = function (red, green, blue, alpha)
{
    return alpha << 24 | red << 16 | green << 8 | blue;
};

module.exports = GetColor32;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

var GetColor = __webpack_require__(61);

/**
 * Converts an HSV (hue, saturation and value) color value to RGB.
 * Conversion formula from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes HSV values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].
 * Based on code by Michael Jackson (https://github.com/mjijackson)
 *
 * @method fromHSV
 * @param {number} h - The hue, in the range 0 - 1.
 * @param {number} s - The saturation, in the range 0 - 1.
 * @param {number} v - The value, in the range 0 - 1.
 * @return {BaseColor} This
 */
var HSVToRGB = function (h, s, v)
{
    if (s === undefined) { s = 1; }
    if (v === undefined) { v = 1; }

    var i = Math.floor(h * 6);
    var f = h * 6 - i;

    var p = Math.floor((v * (1 - s)) * 255);
    var q = Math.floor((v * (1 - f * s)) * 255);
    var t = Math.floor((v * (1 - (1 - f) * s)) * 255);

    v = Math.floor(v *= 255);

    var output = { r: v, g: v, b: v, color: 0 };

    var r = i % 6;

    if (r === 0)
    {
        output.g = t;
        output.b = p;
    }
    else if (r === 1)
    {
        output.r = q;
        output.b = p;
    }
    else if (r === 2)
    {
        output.r = p;
        output.b = t;
    }
    else if (r === 3)
    {
        output.r = p;
        output.g = q;
    }
    else if (r === 4)
    {
        output.r = t;
        output.g = p;
    }
    else if (r === 5)
    {
        output.g = p;
        output.b = q;
    }

    output.color = GetColor(output.r, output.g, output.b);

    return output;
};

module.exports = HSVToRGB;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

var Color = __webpack_require__(30);

/**
* Converts a hex string into a Phaser Color object.
*
* The hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional "#" or "0x", or be unprefixed.    
*
* An alpha channel is _not_ supported.
*
* @method Phaser.Color.hexToColor
* @static
* @param {string} hex - The color string in a hex format.
* @param {object} [out] - An object into which 3 properties will be created or set: r, g and b. If not provided a new object will be created.
* @return {object} An object with the red, green and blue values set in the r, g and b properties.
*/
var HexStringToColor = function (hex)
{
    var color = new Color();

    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });

    var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

    if (result)
    {
        var r = parseInt(result[1], 16);
        var g = parseInt(result[2], 16);
        var b = parseInt(result[3], 16);

        color.setTo(r, g, b);
    }

    return color;
};

module.exports = HexStringToColor;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {/**
* Converts a hue to an RGB color.
* Based on code by Michael Jackson (https://github.com/mjijackson)
*
* @method Lazer.Color.hueToColor
* @param {number} p
* @param {number} q
* @param {number} t
* @return {number} The color component value.
*/
var HueToComponent = function (p, q, t)
{
    if (t < 0)
    {
        t += 1;
    }

    if (t > 1)
    {
        t -= 1;
    }

    if (t < 1 / 6)
    {
        return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2)
    {
        return q;
    }

    if (t < 2 / 3)
    {
        return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
};

module.export = HueToComponent;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(78)(module)))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

var Color = __webpack_require__(30);
var IntegerToRGB = __webpack_require__(127);

var IntegerToColor = function (input)
{
    var rgb = IntegerToRGB(input);

    return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
};

module.exports = IntegerToColor;


/***/ },
/* 127 */
/***/ function(module, exports) {

/**
* Return the component parts of a color as an Object with the properties alpha, red, green, blue.
*
* Alpha will only be set if it exist in the given color (0xAARRGGBB)
*
* @method Phaser.Color.getRGB
* @static
* @param {number} color - Color in RGB (0xRRGGBB) or ARGB format (0xAARRGGBB).
* @return {object} An Object with properties: alpha, red, green, blue (also r, g, b and a). Alpha will only be present if a color value > 16777215 was given.
*/
var IntegerToRGB = function (color)
{
    if (color > 16777215)
    {
        //  The color value has an alpha component
        return {
            a: color >>> 24,
            r: color >> 16 & 0xFF,
            g: color >> 8 & 0xFF,
            b: color & 0xFF
        };
    }
    else
    {
        return {
            a: 255,
            r: color >> 16 & 0xFF,
            g: color >> 8 & 0xFF,
            b: color & 0xFF
        };
    }
};

module.exports = IntegerToRGB;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

var Color = __webpack_require__(30);

/**
* Converts a CSS 'web' string into a Phaser Color object.
*
* The web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].
*
* @method Phaser.Color.webToColor
* @static
* @param {string} web - The color string in CSS 'web' format.
* @param {object} [out] - An object into which 4 properties will be created: r, g, b and a. If not provided a new object will be created.
* @return {object} An object with the red, green, blue and alpha values set in the r, g, b and a properties.
*/
var RGBStringToColor = function (rgb)
{
    var color = new Color();

    var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(rgb.toLowerCase());

    if (result)
    {
        var r = parseInt(result[1], 10);
        var g = parseInt(result[2], 10);
        var b = parseInt(result[3], 10);
        var a = (result[4] !== undefined) ? parseFloat(result[4]) : 1;

        color.setTo(r, g, b, a * 255);
    }

    return color;
};

module.exports = RGBStringToColor;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

var RGBStringToColor = __webpack_require__(128);
var HexStringToColor = __webpack_require__(124);
var IntegerToColor = __webpack_require__(126);

var ValueToColor = function (input)
{
    if (typeof input === 'string')
    {
        if (input.substr(0, 3).toLowerCase() === 'rgb')
        {
            return RGBStringToColor(input);
        }
        else
        {
            return HexStringToColor(input);
        }
    }
    else if (typeof input === 'number')
    {
        return IntegerToColor(input);
    }
};

module.exports = ValueToColor;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

var EventDispatcher = __webpack_require__(23);
var Event = __webpack_require__(384);
var KeyCodes = __webpack_require__(62);
var Key = __webpack_require__(133);
var KeyCombo = __webpack_require__(131);
var ProcessKeyCombo = __webpack_require__(132);
var ProcessKeyDown = __webpack_require__(389);
var ProcessKeyUp = __webpack_require__(390);

/**
* The Keyboard class monitors keyboard input and dispatches keyboard events.
*
* _Note_: many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
* See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.
*
* Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.
* For example the Chrome extension vimium is known to disable Phaser from using the D key. And there are others.
* So please check your extensions before opening Phaser issues.
*
* @class Phaser.Keyboard
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var KeyboardManager = function (inputManager)
{
    this.manager = inputManager;

    this.enabled = false;

    this.target;

    this.events = new EventDispatcher();

    this.keys = [];

    this.combos = [];

    this.captures = [];

    //   Standard FIFO queue
    this.queue = [];

    this.keyHandler;
};

KeyboardManager.prototype.constructor = KeyboardManager;

KeyboardManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.Input.KeyboardManager#boot
    * @private
    */
    boot: function ()
    {
        var config = this.manager.gameConfig;

        this.enabled = config.inputKeyboard;
        this.target = config.inputKeyboardEventTarget;

        if (this.enabled)
        {
            this.startListeners();
        }
    },

    startListeners: function ()
    {
        var queue = this.queue;
        var captures = this.captures;

        var keyHandler = function (event)
        {
            if (event.preventDefaulted)
            {
                // Do nothing if event already handled
                return;
            }

            queue.push(event);

            if (captures[event.keyCode])
            {
                event.preventDefault();
            }
        };

        this.keyHandler = keyHandler;

        this.target.addEventListener('keydown', keyHandler, false);
        this.target.addEventListener('keyup', keyHandler, false);
    },

    stopListeners: function ()
    {
        this.target.removeEventListener('keydown', this.keyHandler);
        this.target.removeEventListener('keyup', this.keyHandler);
    },

    /**
    * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right.
    *
    * @method Phaser.Keyboard#createCursorKeys
    * @return {object} An object containing properties: `up`, `down`, `left` and `right` of {@link Phaser.Key} objects.
    */
    createCursorKeys: function ()
    {
        return this.addKeys({
            up: KeyCodes.UP,
            down: KeyCodes.DOWN,
            left: KeyCodes.LEFT,
            right: KeyCodes.RIGHT
        });
    },

    /**
    * A practical way to create an object containing user selected hotkeys.
    *
    * For example,
    *
    *     addKeys( { 'up': Phaser.KeyCode.W, 'down': Phaser.KeyCode.S, 'left': Phaser.KeyCode.A, 'right': Phaser.KeyCode.D } );
    *
    * would return an object containing properties (`up`, `down`, `left` and `right`) referring to {@link Phaser.Key} object.
    *
    * @method Phaser.Keyboard#addKeys
    * @param {object} keys - A key mapping object, i.e. `{ 'up': Phaser.KeyCode.W, 'down': Phaser.KeyCode.S }` or `{ 'up': 52, 'down': 53 }`.
    * @return {object} An object containing the properties mapped to {@link Phaser.Key} values.
    */
    addKeys: function (keys)
    {
        var output = {};

        for (var key in keys)
        {
            output[key] = this.addKey(keys[key]);
        }

        return output;
    },

    /**
    * If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.
    * The Key object can then be polled, have events attached to it, etc.
    *
    * @method Phaser.Keyboard#addKey
    * @param {integer} keycode - The {@link Phaser.KeyCode keycode} of the key.
    * @return {Phaser.Key} The Key object which you can store locally and reference directly.
    */
    addKey: function (keyCode)
    {
        var keys = this.keys;

        if (!keys[keyCode])
        {
            keys[keyCode] = new Key(keyCode);
            this.captures[keyCode] = true;
        }

        return keys[keyCode];
    },

    /**
    * Removes a Key object from the Keyboard manager.
    *
    * @method Phaser.Keyboard#removeKey
    * @param {integer} keycode - The {@link Phaser.KeyCode keycode} of the key to remove.
    */
    removeKey: function (keyCode)
    {
        if (this.keys[keyCode])
        {
            this.keys[keyCode] = undefined;
            this.captures[keyCode] = false;
        }
    },

    addKeyCapture: function (keyCodes)
    {
        if (!Array.isArray(keyCodes))
        {
            keyCodes = [ keyCodes ];
        }

        for (var i = 0; i < keyCodes.length; i++)
        {
            this.captures[keyCodes[i]] = true;
        }
    },

    removeKeyCapture: function (keyCodes)
    {
        if (!Array.isArray(keyCodes))
        {
            keyCodes = [ keyCodes ];
        }

        for (var i = 0; i < keyCodes.length; i++)
        {
            this.captures[keyCodes[i]] = false;
        }
    },

    createCombo: function (keys, config)
    {
        return new KeyCombo(this, keys, config);
    },

    //  https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent
    //  type = 'keydown', 'keyup'
    //  keyCode = integer

    update: function ()
    {
        if (!this.enabled)
        {
            return;
        }

        //  Clears the queue array, and also means we don't work on array data that could potentially
        //  be modified during the processing phase
        var queue = this.queue.splice(0, this.queue.length);

        var keys = this.keys;
        var singleKey;

        //  Process the event queue, dispatching all of the events that have stored up
        for (var i = 0; i < queue.length; i++)
        {
            var event = queue[i];

            if (event.type === 'keydown')
            {
                this.events.dispatch(new Event.KEY_DOWN_EVENT(event));

                singleKey = Event._DOWN[event.keyCode];

                if (singleKey)
                {
                    this.events.dispatch(new singleKey(event));
                }

                if (keys[event.keyCode])
                {
                    ProcessKeyDown(keys[event.keyCode], event);
                }
            }
            else
            {
                this.events.dispatch(new Event.KEY_UP_EVENT(event));

                singleKey = Event._UP[event.keyCode];

                if (singleKey)
                {
                    this.events.dispatch(new singleKey(event));
                }

                if (keys[event.keyCode])
                {
                    ProcessKeyUp(keys[event.keyCode], event);
                }
            }
        }
    }

};

module.exports = KeyboardManager;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

var GetObjectValue = __webpack_require__(36);
var ResetKeyCombo = __webpack_require__(381);
var ProcessKeyCombo = __webpack_require__(132);
var KeyComboMatchEvent = __webpack_require__(380);

//  Keys can be either:
//
//  A string (ATARI)
//  An array of either integers (key codes) or strings, or a mixture of both
//  An array of objects (such as Key objects) with a public 'keyCode' property

var KeyCombo = function (keyboardManager, keys, config)
{
    if (config === undefined) { config = {}; }

    //  Can't have a zero or single length combo (string or array based)
    if (keys.length < 2)
    {
        return false;
    }

    this.manager = keyboardManager;

    this.enabled = true;

    this.keyCodes = [];

    //  if 'keys' is a string we need to get the keycode of each character in it

    for (var i = 0; i < keys.length; i++)
    {
        var char = keys[i];

        if (typeof char === 'string')
        {
            this.keyCodes.push(char.toUpperCase().charCodeAt(0));
        }
        else if (typeof char === 'number')
        {
            this.keyCodes.push(char);
        }
        else if (char.hasOwnProperty('keyCode'))
        {
            this.keyCodes.push(char.keyCode);
        }
    }

    //  The current keyCode the combo is waiting for
    this.current = this.keyCodes[0];

    //  The current index of the key being waited for in the 'keys' string
    this.index = 0;

    //  The length of this combo (in keycodes)
    this.size = this.keyCodes.length;

    //  The time the previous key in the combo was matched
    this.timeLastMatched = 0;

    //  Has this Key Combo been matched yet?
    this.matched = false;

    //  The time the entire combo was matched
    this.timeMatched = 0;

    //  Custom options ...

    //  If they press the wrong key do we reset the combo?
    this.resetOnWrongKey = GetObjectValue(config, 'resetOnWrongKey', true);

    //  The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.
    this.maxKeyDelay = GetObjectValue(config, 'maxKeyDelay', 0);

    //  If previously matched and they press Key 1 again, will it reset?
    this.resetOnMatch = GetObjectValue(config, 'resetOnMatch', false);

    //  If the combo matches, will it delete itself?
    this.deleteOnMatch = GetObjectValue(config, 'deleteOnMatch', false);

    var _this = this;

    var onKeyDownHandler = function (event)
    {
        if (_this.matched || !_this.enabled)
        {
            return;
        }

        var matched = ProcessKeyCombo(event.data, _this);

        if (matched)
        {
            _this.manager.events.dispatch(new KeyComboMatchEvent(_this, event));

            if (_this.resetOnMatch)
            {
                ResetKeyCombo(_this);
            }
            else if (_this.deleteOnMatch)
            {
                _this.destroy();
            }
        }
    };

    this.onKeyDown = onKeyDownHandler;

    this.manager.events.on('KEY_DOWN_EVENT', onKeyDownHandler);
};

KeyCombo.prototype.constructor = KeyCombo;

KeyCombo.prototype = {

    destroy: function ()
    {
        this.enabled = false;
        this.keyCodes = [];

        this.manager.events.off('KEY_DOWN', this.onKeyDown);
        this.manager = undefined;
    }

};

Object.defineProperties(KeyCombo.prototype, {

    progress: {

        enumerable: true,

        //  How far complete is this combo? A value between 0 and 1.
        get: function ()
        {
            return this.index / this.size;
        }

    }

});

module.exports = KeyCombo;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

var AdvanceKeyCombo = __webpack_require__(379);

var ProcessKeyCombo = function (event, combo)
{
    if (combo.matched)
    {
        return true;
    }

    var comboMatched = false;
    var keyMatched = false;

    if (event.keyCode === combo.current)
    {
        //  Key was correct

        if (combo.index > 0 && combo.maxKeyDelay > 0)
        {
            //  We have to check to see if the delay between
            //  the new key and the old one was too long (if enabled)

            var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;

            //  Check if they pressed it in time or not
            if (event.timeStamp <= timeLimit)
            {
                keyMatched = true;
                comboMatched = AdvanceKeyCombo(event, combo);
            }
        }
        else
        {
            keyMatched = true;

            //  We don't check the time for the first key pressed, so just advance it
            comboMatched = AdvanceKeyCombo(event, combo);
        }
    }

    if (!keyMatched && combo.resetOnWrongKey)
    {
        //  Wrong key was pressed
        combo.index = 0;
        combo.current = combo.keyCodes[0];
    }

    if (comboMatched)
    {
        combo.timeLastMatched = event.timeStamp;
        combo.matched = true;
        combo.timeMatched = event.timeStamp;
    }

    return comboMatched;
};

module.exports = ProcessKeyCombo;


/***/ },
/* 133 */
/***/ function(module, exports) {

//  A generic Key object which can be passed to the Process functions (and so on)

//  keycode must be an integer

var Key = function (keyCode)
{
    /**
    * @property {integer} keyCode - The keycode of this key.
    */
    this.keyCode = keyCode;

    /**
    * @property {KeyboardEvent} originalEvent - The original DOM event.
    */
    this.originalEvent = undefined;

    /**
    * @property {boolean} preventDefault - Should this Key prevent event propagation?
    * @default
    */
    this.preventDefault = true;

    /**
    * @property {boolean} enabled - Can this Key be processed?
    * @default
    */
    this.enabled = true;

    /**
    * @property {boolean} isDown - The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
    * @default
    */
    this.isDown = false;

    /**
    * @property {boolean} isUp - The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
    * @default
    */
    this.isUp = true;

    /**
    * @property {boolean} altKey - The down state of the ALT key, if pressed at the same time as this key.
    * @default
    */
    this.altKey = false;

    /**
    * @property {boolean} ctrlKey - The down state of the CTRL key, if pressed at the same time as this key.
    * @default
    */
    this.ctrlKey = false;

    /**
    * @property {boolean} shiftKey - The down state of the SHIFT key, if pressed at the same time as this key.
    * @default
    */
    this.shiftKey = false;

    /**
    * @property {integer} location - The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.
    * @default
    */
    this.location = 0;

    /**
    * @property {number} timeDown - The timestamp when the key was last pressed down. This is based on Game.time.now.
    */
    this.timeDown = 0;

    /**
    * If the key is down this value holds the duration of that key press and is constantly updated.
    * If the key is up it holds the duration of the previous down session.
    * @property {number} duration - The number of milliseconds this key has been held down for.
    * @default
    */
    this.duration = 0;

    /**
    * @property {number} timeUp - The timestamp when the key was last released. This is based on Game.time.now.
    * @default
    */
    this.timeUp = 0;

    /**
    * @property {number} repeats - If a key is held down this holds down the number of times the key has 'repeated'.
    * @default
    */
    this.repeats = 0;

    /**
     * @property {boolean} _justDown - True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
     * @private
     */
    this._justDown = false;

    /**
     * @property {boolean} _justUp - True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
     * @private
     */
    this._justUp = false;
};

Key.prototype.constructor = Key;

module.exports = Key;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

var XHRSettings = __webpack_require__(63);

//  Takes two XHR Objects and creates a new object

//  The new object is based on global initially, but any setting in
//  local overrides the global value.

var MergeXHRSettings = function (global, local)
{
    var output = (global === undefined) ? XHRSettings() : Object.assign(global);

    if (local)
    {
        for (var setting in local)
        {
            if (local[setting] !== undefined)
            {
                output[setting] = local[setting];
            }
        }
    }

    return output;

};

module.exports = MergeXHRSettings;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(31);

var JSONFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.json\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.json';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'json', key, url, 'text', xhrSettings);
};

JSONFile.prototype = Object.create(File.prototype);
JSONFile.prototype.constructor = JSONFile;

JSONFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = JSON.parse(this.xhrLoader.responseText);

    this.onComplete();

    callback(this);
};

module.exports = JSONFile;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(31);
var ParseXML = __webpack_require__(85);

var XMLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.xml\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.xml';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'xml', key, url, 'text', xhrSettings);
};

XMLFile.prototype = Object.create(File.prototype);
XMLFile.prototype.constructor = XMLFile;

XMLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = ParseXML(this.xhrLoader.responseText);

    if (this.data === null)
    {
        throw new Error('XMLFile: Invalid XML');
    }

    this.onComplete();

    callback(this);
};

module.exports = XMLFile;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

var Factorial = __webpack_require__(140);

var Bernstein = function (n, i)
{
    return Factorial(n) / Factorial(i) / Factorial(n - i);
};

module.exports = Bernstein;


/***/ },
/* 138 */
/***/ function(module, exports) {

var CatmullRom = function (p0, p1, p2, p3, t)
{
    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;

    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
};

module.exports = CatmullRom;


/***/ },
/* 139 */
/***/ function(module, exports) {

/**
* Force a value within the boundaries by clamping it to the range `min`, `max`.
*
* @method Phaser.Math#clamp
* @param {float} v - The value to be clamped.
* @param {float} min - The minimum bounds.
* @param {float} max - The maximum bounds.
* @return {number} The clamped value.
*/
var Clamp = function (v, min, max)
{
    if (v < min)
    {
        return min;
    }
    else if (max < v)
    {
        return max;
    }
    else
    {
        return v;
    }
};

module.exports = Clamp;


/***/ },
/* 140 */
/***/ function(module, exports) {

var Factorial = function (value)
{
    if (value === 0)
    {
        return 1;
    }

    var res = value;

    while (--value)
    {
        res *= value;
    }

    return res;
};

module.exports = Factorial;


/***/ },
/* 141 */
/***/ function(module, exports) {

var Linear = function (p0, p1, t)
{
    return (p1 - p0) * t + p0;
};

module.exports = Linear;


/***/ },
/* 142 */
/***/ function(module, exports) {

var RoundAwayFromZero = function (value)
{
    // "Opposite" of truncate.
    return (value > 0) ? Math.ceil(value) : Math.floor(value);
};

module.exports = RoundAwayFromZero;


/***/ },
/* 143 */
/***/ function(module, exports) {

var Normalize = function (angle)
{
    angle = angle % (2 * Math.PI);

    if (angle >= 0)
    {
        return angle;
    }
    else
    {
        return angle + 2 * Math.PI;
    }
};

module.exports = Normalize;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

var MathWrap = __webpack_require__(42);

var Wrap = function (angle)
{
    return MathWrap(angle, -Math.PI, Math.PI);
};

module.exports = Wrap;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

var Wrap = __webpack_require__(42);

var WrapDegrees = function (angle)
{
    return Wrap(angle, -180, 180);
};

module.exports = WrapDegrees;


/***/ },
/* 146 */
/***/ function(module, exports) {

var DistanceBetween = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return Math.sqrt(dx * dx + dy * dy);
};

module.exports = DistanceBetween;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(141);

var LinearInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (k < 0)
    {
        return Linear(v[0], v[1], f);
    }

    if (k > 1)
    {
        return Linear(v[m], v[m - 1], m - f);
    }

    return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);
};

module.exports = LinearInterpolation;


/***/ },
/* 148 */
/***/ function(module, exports) {

/**
* Checks if the given dimensions make a power of two texture.
* 
* @method Phaser.Math#isPowerOfTwo
* @param {number} width - The width to check.
* @param {number} height - The height to check.
* @return {boolean} True if the width and height are a power of two.
*/
var IsSizePowerOfTwo = function (width, height)
{
    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
};

module.exports = IsSizePowerOfTwo;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.World` module contains methods for creating and manipulating the world composite.
* A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
* A `Matter.World` has a few additional properties including `gravity` and `bounds`.
* It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
* There are also a few methods here that alias those in `Matter.Composite` for easier readability.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class World
* @extends Composite
*/

var World = {};

module.exports = World;

var Composite = __webpack_require__(20);
var Constraint = __webpack_require__(39);
var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @constructor
     * @param {} options
     * @return {world} A new world
     */
    World.create = function(options) {
        var composite = Composite.create();

        var defaults = {
            label: 'World',
            gravity: {
                x: 0,
                y: 1,
                scale: 0.001
            },
            bounds: { 
                min: { x: -Infinity, y: -Infinity }, 
                max: { x: Infinity, y: Infinity } 
            }
        };
        
        return Common.extend(composite, defaults, options);
    };

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * The gravity to apply on the world.
     *
     * @property gravity
     * @type object
     */

    /**
     * The gravity x component.
     *
     * @property gravity.x
     * @type object
     * @default 0
     */

    /**
     * The gravity y component.
     *
     * @property gravity.y
     * @type object
     * @default 1
     */

    /**
     * The gravity scale factor.
     *
     * @property gravity.scale
     * @type object
     * @default 0.001
     */

    /**
     * A `Bounds` object that defines the world bounds for collision detection.
     *
     * @property bounds
     * @type bounds
     * @default { min: { x: -Infinity, y: -Infinity }, max: { x: Infinity, y: Infinity } }
     */

    // World is a Composite body
    // see src/module/Outro.js for these aliases:
    
    /**
     * An alias for Composite.clear
     * @method clear
     * @param {world} world
     * @param {boolean} keepStatic
     */

    /**
     * An alias for Composite.add
     * @method addComposite
     * @param {world} world
     * @param {composite} composite
     * @return {world} The original world with the objects from composite added
     */
    
     /**
      * An alias for Composite.addBody
      * @method addBody
      * @param {world} world
      * @param {body} body
      * @return {world} The original world with the body added
      */

     /**
      * An alias for Composite.addConstraint
      * @method addConstraint
      * @param {world} world
      * @param {constraint} constraint
      * @return {world} The original world with the constraint added
      */

})();


/***/ },
/* 150 */
/***/ function(module, exports) {

/**
* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.
*
* @class Contact
*/

var Contact = {};

module.exports = Contact;

(function() {

    /**
     * Creates a new contact.
     * @method create
     * @param {vertex} vertex
     * @return {contact} A new contact
     */
    Contact.create = function(vertex) {
        return {
            id: Contact.id(vertex),
            vertex: vertex,
            normalImpulse: 0,
            tangentImpulse: 0
        };
    };
    
    /**
     * Generates a contact id.
     * @method id
     * @param {vertex} vertex
     * @return {string} Unique contactID
     */
    Contact.id = function(vertex) {
        return vertex.body.id + '_' + vertex.index;
    };

})();


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
*
* @class Pairs
*/

var Pairs = {};

module.exports = Pairs;

var Pair = __webpack_require__(43);
var Common = __webpack_require__(0);

(function() {
    
    var _pairMaxIdleLife = 1000;

    /**
     * Creates a new pairs structure.
     * @method create
     * @param {object} options
     * @return {pairs} A new pairs structure
     */
    Pairs.create = function(options) {
        return Common.extend({ 
            table: {},
            list: [],
            collisionStart: [],
            collisionActive: [],
            collisionEnd: []
        }, options);
    };

    /**
     * Updates pairs given a list of collisions.
     * @method update
     * @param {object} pairs
     * @param {collision[]} collisions
     * @param {number} timestamp
     */
    Pairs.update = function(pairs, collisions, timestamp) {
        var pairsList = pairs.list,
            pairsTable = pairs.table,
            collisionStart = pairs.collisionStart,
            collisionEnd = pairs.collisionEnd,
            collisionActive = pairs.collisionActive,
            activePairIds = [],
            collision,
            pairId,
            pair,
            i;

        // clear collision state arrays, but maintain old reference
        collisionStart.length = 0;
        collisionEnd.length = 0;
        collisionActive.length = 0;

        for (i = 0; i < collisions.length; i++) {
            collision = collisions[i];

            if (collision.collided) {
                pairId = Pair.id(collision.bodyA, collision.bodyB);
                activePairIds.push(pairId);

                pair = pairsTable[pairId];
                
                if (pair) {
                    // pair already exists (but may or may not be active)
                    if (pair.isActive) {
                        // pair exists and is active
                        collisionActive.push(pair);
                    } else {
                        // pair exists but was inactive, so a collision has just started again
                        collisionStart.push(pair);
                    }

                    // update the pair
                    Pair.update(pair, collision, timestamp);
                } else {
                    // pair did not exist, create a new pair
                    pair = Pair.create(collision, timestamp);
                    pairsTable[pairId] = pair;

                    // push the new pair
                    collisionStart.push(pair);
                    pairsList.push(pair);
                }
            }
        }

        // deactivate previously active pairs that are now inactive
        for (i = 0; i < pairsList.length; i++) {
            pair = pairsList[i];
            if (pair.isActive && Common.indexOf(activePairIds, pair.id) === -1) {
                Pair.setActive(pair, false, timestamp);
                collisionEnd.push(pair);
            }
        }
    };
    
    /**
     * Finds and removes pairs that have been inactive for a set amount of time.
     * @method removeOld
     * @param {object} pairs
     * @param {number} timestamp
     */
    Pairs.removeOld = function(pairs, timestamp) {
        var pairsList = pairs.list,
            pairsTable = pairs.table,
            indexesToRemove = [],
            pair,
            collision,
            pairIndex,
            i;

        for (i = 0; i < pairsList.length; i++) {
            pair = pairsList[i];
            collision = pair.collision;
            
            // never remove sleeping pairs
            if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {
                pair.timeUpdated = timestamp;
                continue;
            }

            // if pair is inactive for too long, mark it to be removed
            if (timestamp - pair.timeUpdated > _pairMaxIdleLife) {
                indexesToRemove.push(i);
            }
        }

        // remove marked pairs
        for (i = 0; i < indexesToRemove.length; i++) {
            pairIndex = indexesToRemove[i] - i;
            pair = pairsList[pairIndex];
            delete pairsTable[pair.id];
            pairsList.splice(pairIndex, 1);
        }
    };

    /**
     * Clears the given pairs structure.
     * @method clear
     * @param {pairs} pairs
     * @return {pairs} pairs
     */
    Pairs.clear = function(pairs) {
        pairs.table = {};
        pairs.list.length = 0;
        pairs.collisionStart.length = 0;
        pairs.collisionActive.length = 0;
        pairs.collisionEnd.length = 0;
        return pairs;
    };

})();


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Resolver` module contains methods for resolving collision pairs.
*
* @class Resolver
*/

var Resolver = {};

module.exports = Resolver;

var Vertices = __webpack_require__(22);
var Vector = __webpack_require__(4);
var Common = __webpack_require__(0);
var Bounds = __webpack_require__(3);

(function() {

    Resolver._restingThresh = 4;
    Resolver._restingThreshTangent = 6;
    Resolver._positionDampen = 0.9;
    Resolver._positionWarming = 0.8;
    Resolver._frictionNormalMultiplier = 5;

    /**
     * Prepare pairs for position solving.
     * @method preSolvePosition
     * @param {pair[]} pairs
     */
    Resolver.preSolvePosition = function(pairs) {
        var i,
            pair,
            activeCount;

        // find total contacts on each body
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive)
                continue;
            
            activeCount = pair.activeContacts.length;
            pair.collision.parentA.totalContacts += activeCount;
            pair.collision.parentB.totalContacts += activeCount;
        }
    };

    /**
     * Find a solution for pair positions.
     * @method solvePosition
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Resolver.solvePosition = function(pairs, timeScale) {
        var i,
            pair,
            collision,
            bodyA,
            bodyB,
            normal,
            bodyBtoA,
            contactShare,
            positionImpulse,
            contactCount = {},
            tempA = Vector._temp[0],
            tempB = Vector._temp[1],
            tempC = Vector._temp[2],
            tempD = Vector._temp[3];

        // find impulses required to resolve penetration
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;

            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;

            // get current separation between body edges involved in collision
            bodyBtoA = Vector.sub(Vector.add(bodyB.positionImpulse, bodyB.position, tempA), 
                                    Vector.add(bodyA.positionImpulse, 
                                        Vector.sub(bodyB.position, collision.penetration, tempB), tempC), tempD);

            pair.separation = Vector.dot(normal, bodyBtoA);
        }
        
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive || pair.isSensor || pair.separation < 0)
                continue;
            
            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;
            positionImpulse = (pair.separation - pair.slop) * timeScale;

            if (bodyA.isStatic || bodyB.isStatic)
                positionImpulse *= 2;
            
            if (!(bodyA.isStatic || bodyA.isSleeping)) {
                contactShare = Resolver._positionDampen / bodyA.totalContacts;
                bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;
                bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;
            }

            if (!(bodyB.isStatic || bodyB.isSleeping)) {
                contactShare = Resolver._positionDampen / bodyB.totalContacts;
                bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;
                bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;
            }
        }
    };

    /**
     * Apply position resolution.
     * @method postSolvePosition
     * @param {body[]} bodies
     */
    Resolver.postSolvePosition = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            // reset contact count
            body.totalContacts = 0;

            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {
                // update body geometry
                for (var j = 0; j < body.parts.length; j++) {
                    var part = body.parts[j];
                    Vertices.translate(part.vertices, body.positionImpulse);
                    Bounds.update(part.bounds, part.vertices, body.velocity);
                    part.position.x += body.positionImpulse.x;
                    part.position.y += body.positionImpulse.y;
                }

                // move the body without changing velocity
                body.positionPrev.x += body.positionImpulse.x;
                body.positionPrev.y += body.positionImpulse.y;

                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {
                    // reset cached impulse if the body has velocity along it
                    body.positionImpulse.x = 0;
                    body.positionImpulse.y = 0;
                } else {
                    // warm the next iteration
                    body.positionImpulse.x *= Resolver._positionWarming;
                    body.positionImpulse.y *= Resolver._positionWarming;
                }
            }
        }
    };

    /**
     * Prepare pairs for velocity solving.
     * @method preSolveVelocity
     * @param {pair[]} pairs
     */
    Resolver.preSolveVelocity = function(pairs) {
        var i,
            j,
            pair,
            contacts,
            collision,
            bodyA,
            bodyB,
            normal,
            tangent,
            contact,
            contactVertex,
            normalImpulse,
            tangentImpulse,
            offset,
            impulse = Vector._temp[0],
            tempA = Vector._temp[1];
        
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;
            
            contacts = pair.activeContacts;
            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;
            tangent = collision.tangent;

            // resolve each contact
            for (j = 0; j < contacts.length; j++) {
                contact = contacts[j];
                contactVertex = contact.vertex;
                normalImpulse = contact.normalImpulse;
                tangentImpulse = contact.tangentImpulse;

                if (normalImpulse !== 0 || tangentImpulse !== 0) {
                    // total impulse from contact
                    impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);
                    impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);
                    
                    // apply impulse from contact
                    if (!(bodyA.isStatic || bodyA.isSleeping)) {
                        offset = Vector.sub(contactVertex, bodyA.position, tempA);
                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                        bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;
                    }

                    if (!(bodyB.isStatic || bodyB.isSleeping)) {
                        offset = Vector.sub(contactVertex, bodyB.position, tempA);
                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                        bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;
                    }
                }
            }
        }
    };

    /**
     * Find a solution for pair velocities.
     * @method solveVelocity
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Resolver.solveVelocity = function(pairs, timeScale) {
        var timeScaleSquared = timeScale * timeScale,
            impulse = Vector._temp[0],
            tempA = Vector._temp[1],
            tempB = Vector._temp[2],
            tempC = Vector._temp[3],
            tempD = Vector._temp[4],
            tempE = Vector._temp[5];
        
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;
            
            var collision = pair.collision,
                bodyA = collision.parentA,
                bodyB = collision.parentB,
                normal = collision.normal,
                tangent = collision.tangent,
                contacts = pair.activeContacts,
                contactShare = 1 / contacts.length;

            // update body velocities
            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;

            // resolve each contact
            for (var j = 0; j < contacts.length; j++) {
                var contact = contacts[j],
                    contactVertex = contact.vertex,
                    offsetA = Vector.sub(contactVertex, bodyA.position, tempA),
                    offsetB = Vector.sub(contactVertex, bodyB.position, tempB),
                    velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),
                    velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), 
                    relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),
                    normalVelocity = Vector.dot(normal, relativeVelocity);

                var tangentVelocity = Vector.dot(tangent, relativeVelocity),
                    tangentSpeed = Math.abs(tangentVelocity),
                    tangentVelocityDirection = Common.sign(tangentVelocity);

                // raw impulses
                var normalImpulse = (1 + pair.restitution) * normalVelocity,
                    normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;

                // coulomb friction
                var tangentImpulse = tangentVelocity,
                    maxFriction = Infinity;

                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {
                    maxFriction = tangentSpeed;
                    tangentImpulse = Common.clamp(
                        pair.friction * tangentVelocityDirection * timeScaleSquared,
                        -maxFriction, maxFriction
                    );
                }

                // modify impulses accounting for mass, inertia and offset
                var oAcN = Vector.cross(offsetA, normal),
                    oBcN = Vector.cross(offsetB, normal),
                    share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN  + bodyB.inverseInertia * oBcN * oBcN);

                normalImpulse *= share;
                tangentImpulse *= share;

                // handle high velocity and resting collisions separately
                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {
                    // high normal velocity so clear cached contact normal impulse
                    contact.normalImpulse = 0;
                } else {
                    // solve resting collision constraints using Erin Catto's method (GDC08)
                    // impulse constraint tends to 0
                    var contactNormalImpulse = contact.normalImpulse;
                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);
                    normalImpulse = contact.normalImpulse - contactNormalImpulse;
                }

                // handle high velocity and resting collisions separately
                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {
                    // high tangent velocity so clear cached contact tangent impulse
                    contact.tangentImpulse = 0;
                } else {
                    // solve resting collision constraints using Erin Catto's method (GDC08)
                    // tangent impulse tends to -tangentSpeed or +tangentSpeed
                    var contactTangentImpulse = contact.tangentImpulse;
                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);
                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                }

                // total impulse from contact
                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);
                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);
                
                // apply impulse from contact
                if (!(bodyA.isStatic || bodyA.isSleeping)) {
                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;
                }

                if (!(bodyB.isStatic || bodyB.isSleeping)) {
                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;
                }
            }
        }
    };

})();


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Engine` module contains methods for creating and manipulating engines.
* An engine is a controller that manages updating the simulation of the world.
* See `Matter.Runner` for an optional game loop utility.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Engine
*/

var Engine = {};

module.exports = Engine;

var World = __webpack_require__(149);
var Sleeping = __webpack_require__(40);
var Resolver = __webpack_require__(152);
var Render = __webpack_require__(71);
var Pairs = __webpack_require__(151);
var Metrics = __webpack_require__(154);
var Grid = __webpack_require__(66);
var Events = __webpack_require__(21);
var Composite = __webpack_require__(20);
var Constraint = __webpack_require__(39);
var Common = __webpack_require__(0);
var Body = __webpack_require__(38);

(function() {

    /**
     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {engine} engine
     */
    Engine.create = function(element, options) {
        // options may be passed as the first (and only) argument
        options = Common.isElement(element) ? options : element;
        element = Common.isElement(element) ? element : null;
        options = options || {};

        if (element || options.render) {
            Common.warn('Engine.create: engine.render is deprecated (see docs)');
        }

        var defaults = {
            positionIterations: 6,
            velocityIterations: 4,
            constraintIterations: 2,
            enableSleeping: false,
            events: [],
            plugin: {},
            timing: {
                timestamp: 0,
                timeScale: 1
            },
            broadphase: {
                controller: Grid
            }
        };

        var engine = Common.extend(defaults, options);

        // @deprecated
        if (element || engine.render) {
            var renderDefaults = {
                element: element,
                controller: Render
            };
            
            engine.render = Common.extend(renderDefaults, engine.render);
        }

        // @deprecated
        if (engine.render && engine.render.controller) {
            engine.render = engine.render.controller.create(engine.render);
        }

        // @deprecated
        if (engine.render) {
            engine.render.engine = engine;
        }

        engine.world = options.world || World.create(engine.world);
        engine.pairs = Pairs.create();
        engine.broadphase = engine.broadphase.controller.create(engine.broadphase);
        engine.metrics = engine.metrics || { extended: false };

        // @if DEBUG
        engine.metrics = Metrics.create(engine.metrics);
        // @endif

        return engine;
    };

    /**
     * Moves the simulation forward in time by `delta` ms.
     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
     * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.
     *
     * Triggers `beforeUpdate` and `afterUpdate` events.
     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
     * @method update
     * @param {engine} engine
     * @param {number} [delta=16.666]
     * @param {number} [correction=1]
     */
    Engine.update = function(engine, delta, correction) {
        delta = delta || 1000 / 60;
        correction = correction || 1;

        var world = engine.world,
            timing = engine.timing,
            broadphase = engine.broadphase,
            broadphasePairs = [],
            i;

        // increment timestamp
        timing.timestamp += delta * timing.timeScale;

        // create an event object
        var event = {
            timestamp: timing.timestamp
        };

        Events.trigger(engine, 'beforeUpdate', event);

        // get lists of all bodies and constraints, no matter what composites they are in
        var allBodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world);

        // @if DEBUG
        // reset metrics logging
        Metrics.reset(engine.metrics);
        // @endif

        // if sleeping enabled, call the sleeping controller
        if (engine.enableSleeping)
            Sleeping.update(allBodies, timing.timeScale);

        // applies gravity to all bodies
        _bodiesApplyGravity(allBodies, world.gravity);

        // update all body position and rotation by integration
        _bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);

        // update all constraints
        for (i = 0; i < engine.constraintIterations; i++) {
            Constraint.solveAll(allConstraints, timing.timeScale);
        }
        Constraint.postSolveAll(allBodies);

        // broadphase pass: find potential collision pairs
        if (broadphase.controller) {

            // if world is dirty, we must flush the whole grid
            if (world.isModified)
                broadphase.controller.clear(broadphase);

            // update the grid buckets based on current bodies
            broadphase.controller.update(broadphase, allBodies, engine, world.isModified);
            broadphasePairs = broadphase.pairsList;
        } else {

            // if no broadphase set, we just pass all bodies
            broadphasePairs = allBodies;
        }

        // clear all composite modified flags
        if (world.isModified) {
            Composite.setModified(world, false, false, true);
        }

        // narrowphase pass: find actual collisions, then create or update collision pairs
        var collisions = broadphase.detector(broadphasePairs, engine);

        // update collision pairs
        var pairs = engine.pairs,
            timestamp = timing.timestamp;
        Pairs.update(pairs, collisions, timestamp);
        Pairs.removeOld(pairs, timestamp);

        // wake up bodies involved in collisions
        if (engine.enableSleeping)
            Sleeping.afterCollisions(pairs.list, timing.timeScale);

        // trigger collision events
        if (pairs.collisionStart.length > 0)
            Events.trigger(engine, 'collisionStart', { pairs: pairs.collisionStart });

        // iteratively resolve position between collisions
        Resolver.preSolvePosition(pairs.list);
        for (i = 0; i < engine.positionIterations; i++) {
            Resolver.solvePosition(pairs.list, timing.timeScale);
        }
        Resolver.postSolvePosition(allBodies);

        // iteratively resolve velocity between collisions
        Resolver.preSolveVelocity(pairs.list);
        for (i = 0; i < engine.velocityIterations; i++) {
            Resolver.solveVelocity(pairs.list, timing.timeScale);
        }

        // trigger collision events
        if (pairs.collisionActive.length > 0)
            Events.trigger(engine, 'collisionActive', { pairs: pairs.collisionActive });

        if (pairs.collisionEnd.length > 0)
            Events.trigger(engine, 'collisionEnd', { pairs: pairs.collisionEnd });

        // @if DEBUG
        // update metrics log
        Metrics.update(engine.metrics, engine);
        // @endif

        // clear force buffers
        _bodiesClearForces(allBodies);

        Events.trigger(engine, 'afterUpdate', event);

        return engine;
    };
    
    /**
     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
     * @method merge
     * @param {engine} engineA
     * @param {engine} engineB
     */
    Engine.merge = function(engineA, engineB) {
        Common.extend(engineA, engineB);
        
        if (engineB.world) {
            engineA.world = engineB.world;

            Engine.clear(engineA);

            var bodies = Composite.allBodies(engineA.world);

            for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                Sleeping.set(body, false);
                body.id = Common.nextId();
            }
        }
    };

    /**
     * Clears the engine including the world, pairs and broadphase.
     * @method clear
     * @param {engine} engine
     */
    Engine.clear = function(engine) {
        var world = engine.world;
        
        Pairs.clear(engine.pairs);

        var broadphase = engine.broadphase;
        if (broadphase.controller) {
            var bodies = Composite.allBodies(world);
            broadphase.controller.clear(broadphase);
            broadphase.controller.update(broadphase, bodies, engine, true);
        }
    };

    /**
     * Zeroes the `body.force` and `body.torque` force buffers.
     * @method bodiesClearForces
     * @private
     * @param {body[]} bodies
     */
    var _bodiesClearForces = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            // reset force buffers
            body.force.x = 0;
            body.force.y = 0;
            body.torque = 0;
        }
    };

    /**
     * Applys a mass dependant force to all given bodies.
     * @method bodiesApplyGravity
     * @private
     * @param {body[]} bodies
     * @param {vector} gravity
     */
    var _bodiesApplyGravity = function(bodies, gravity) {
        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;

        if ((gravity.x === 0 && gravity.y === 0) || gravityScale === 0) {
            return;
        }
        
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isStatic || body.isSleeping)
                continue;

            // apply gravity
            body.force.y += body.mass * gravity.y * gravityScale;
            body.force.x += body.mass * gravity.x * gravityScale;
        }
    };

    /**
     * Applys `Body.update` to all given `bodies`.
     * @method updateAll
     * @private
     * @param {body[]} bodies
     * @param {number} deltaTime 
     * The amount of time elapsed between updates
     * @param {number} timeScale
     * @param {number} correction 
     * The Verlet correction factor (deltaTime / lastDeltaTime)
     * @param {bounds} worldBounds
     */
    var _bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isStatic || body.isSleeping)
                continue;

            Body.update(body, deltaTime, timeScale, correction);
        }
    };

    /**
     * An alias for `Runner.run`, see `Matter.Runner` for more information.
     * @method run
     * @param {engine} engine
     */

    /**
    * Fired just before an update
    *
    * @event beforeUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update and all collision events
    *
    * @event afterUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)
    *
    * @event collisionStart
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)
    *
    * @event collisionActive
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)
    *
    * @event collisionEnd
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` that specifies the number of position iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     *
     * @property positionIterations
     * @type number
     * @default 6
     */

    /**
     * An integer `Number` that specifies the number of velocity iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     *
     * @property velocityIterations
     * @type number
     * @default 4
     */

    /**
     * An integer `Number` that specifies the number of constraint iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     * The default value of `2` is usually very adequate.
     *
     * @property constraintIterations
     * @type number
     * @default 2
     */

    /**
     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.
     * Sleeping can improve stability and performance, but often at the expense of accuracy.
     *
     * @property enableSleeping
     * @type boolean
     * @default false
     */

    /**
     * An `Object` containing properties regarding the timing systems of the engine. 
     *
     * @property timing
     * @type object
     */

    /**
     * A `Number` that specifies the global scaling factor of time for all bodies.
     * A value of `0` freezes the simulation.
     * A value of `0.1` gives a slow-motion effect.
     * A value of `1.2` gives a speed-up effect.
     *
     * @property timing.timeScale
     * @type number
     * @default 1
     */

    /**
     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. 
     * It is incremented on every `Engine.update` by the given `delta` argument. 
     *
     * @property timing.timestamp
     * @type number
     * @default 0
     */

    /**
     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.
     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.
     *
     * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).
     * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.
     *
     * @property render
     * @type render
     * @deprecated see Demo.js for an example of creating a renderer
     * @default a Matter.Render instance
     */

    /**
     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.
     *
     * @property broadphase
     * @type grid
     * @default a Matter.Grid instance
     */

    /**
     * A `World` composite object that will contain all simulated bodies and constraints.
     *
     * @property world
     * @type world
     * @default a Matter.World instance
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

// @if DEBUG
/**
* _Internal Class_, not generally used outside of the engine's internals.
*
*/

var Metrics = {};

module.exports = Metrics;

var Composite = __webpack_require__(20);
var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a new metrics.
     * @method create
     * @private
     * @return {metrics} A new metrics
     */
    Metrics.create = function(options) {
        var defaults = {
            extended: false,
            narrowDetections: 0,
            narrowphaseTests: 0,
            narrowReuse: 0,
            narrowReuseCount: 0,
            midphaseTests: 0,
            broadphaseTests: 0,
            narrowEff: 0.0001,
            midEff: 0.0001,
            broadEff: 0.0001,
            collisions: 0,
            buckets: 0,
            bodies: 0,
            pairs: 0
        };

        return Common.extend(defaults, false, options);
    };

    /**
     * Resets metrics.
     * @method reset
     * @private
     * @param {metrics} metrics
     */
    Metrics.reset = function(metrics) {
        if (metrics.extended) {
            metrics.narrowDetections = 0;
            metrics.narrowphaseTests = 0;
            metrics.narrowReuse = 0;
            metrics.narrowReuseCount = 0;
            metrics.midphaseTests = 0;
            metrics.broadphaseTests = 0;
            metrics.narrowEff = 0;
            metrics.midEff = 0;
            metrics.broadEff = 0;
            metrics.collisions = 0;
            metrics.buckets = 0;
            metrics.pairs = 0;
            metrics.bodies = 0;
        }
    };

    /**
     * Updates metrics.
     * @method update
     * @private
     * @param {metrics} metrics
     * @param {engine} engine
     */
    Metrics.update = function(metrics, engine) {
        if (metrics.extended) {
            var world = engine.world,
                bodies = Composite.allBodies(world);

            metrics.collisions = metrics.narrowDetections;
            metrics.pairs = engine.pairs.list.length;
            metrics.bodies = bodies.length;
            metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2);
            metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2);
            metrics.broadEff = (1 - (metrics.broadphaseTests / (bodies.length || 1))).toFixed(2);
            metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2);
            //var broadphase = engine.broadphase[engine.broadphase.current];
            //if (broadphase.instance)
            //    metrics.buckets = Common.keys(broadphase.instance.buckets).length;
        }
    };

})();
// @endif


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.
*
* @class Plugin
*/

var Plugin = {};

module.exports = Plugin;

var Common = __webpack_require__(0);

(function() {

    Plugin._registry = {};

    /**
     * Registers a plugin object so it can be resolved later by name.
     * @method register
     * @param plugin {} The plugin to register.
     * @return {object} The plugin.
     */
    Plugin.register = function(plugin) {
        if (!Plugin.isPlugin(plugin)) {
            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');
        }

        if (plugin.name in Plugin._registry) {
            var registered = Plugin._registry[plugin.name],
                pluginVersion = Plugin.versionParse(plugin.version).number,
                registeredVersion = Plugin.versionParse(registered.version).number;

            if (pluginVersion > registeredVersion) {
                Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));
                Plugin._registry[plugin.name] = plugin;
            } else if (pluginVersion < registeredVersion) {
                Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));
            } else if (plugin !== registered) {
                Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');
            }
        } else {
            Plugin._registry[plugin.name] = plugin;
        }

        return plugin;
    };

    /**
     * Resolves a dependency to a plugin object from the registry if it exists. 
     * The `dependency` may contain a version, but only the name matters when resolving.
     * @method resolve
     * @param dependency {string} The dependency.
     * @return {object} The plugin if resolved, otherwise `undefined`.
     */
    Plugin.resolve = function(dependency) {
        return Plugin._registry[Plugin.dependencyParse(dependency).name];
    };

    /**
     * Returns a pretty printed plugin name and version.
     * @method toString
     * @param plugin {} The plugin.
     * @return {string} Pretty printed plugin name and version.
     */
    Plugin.toString = function(plugin) {
        return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');
    };

    /**
     * Returns `true` if the object meets the minimum standard to be considered a plugin.
     * This means it must define the following properties:
     * - `name`
     * - `version`
     * - `install`
     * @method isPlugin
     * @param obj {} The obj to test.
     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.
     */
    Plugin.isPlugin = function(obj) {
        return obj && obj.name && obj.version && obj.install;
    };

    /**
     * Returns `true` if a plugin with the given `name` been installed on `module`.
     * @method isUsed
     * @param module {} The module.
     * @param name {string} The plugin name.
     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.
     */
    Plugin.isUsed = function(module, name) {
        return module.used.indexOf(name) > -1;
    };

    /**
     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.
     * If `plugin.for` is not specified then it is assumed to be applicable.
     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.
     * @method isFor
     * @param plugin {} The plugin.
     * @param module {} The module.
     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.
     */
    Plugin.isFor = function(plugin, module) {
        var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
        return !plugin.for || (module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range));
    };

    /**
     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.
     * For installing plugins on `Matter` see the convenience function `Matter.use`.
     * Plugins may be specified either by their name or a reference to the plugin object.
     * Plugins themselves may specify further dependencies, but each plugin is installed only once.
     * Order is important, a topological sort is performed to find the best resulting order of installation.
     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.
     * This function logs the resulting status of each dependency in the console, along with any warnings.
     * - A green tick  indicates a dependency was resolved and installed.
     * - An orange diamond  indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.
     * - A red cross  indicates a dependency could not be resolved.
     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.
     * @method use
     * @param module {} The module install plugins on.
     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).
     */
    Plugin.use = function(module, plugins) {
        module.uses = (module.uses || []).concat(plugins || []);

        if (module.uses.length === 0) {
            Common.warn('Plugin.use:', Plugin.toString(module), 'does not specify any dependencies to install.');
            return;
        }

        var dependencies = Plugin.dependencies(module),
            sortedDependencies = Common.topologicalSort(dependencies),
            status = [];

        for (var i = 0; i < sortedDependencies.length; i += 1) {
            if (sortedDependencies[i] === module.name) {
                continue;
            }

            var plugin = Plugin.resolve(sortedDependencies[i]);

            if (!plugin) {
                status.push(' ' + sortedDependencies[i]);
                continue;
            }

            if (Plugin.isUsed(module, plugin.name)) {
                continue;
            }

            if (!Plugin.isFor(plugin, module)) {
                Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module) + '.');
                plugin._warned = true;
            }

            if (plugin.install) {
                plugin.install(module);
            } else {
                Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');
                plugin._warned = true;
            }

            if (plugin._warned) {
                status.push(' ' + Plugin.toString(plugin));
                delete plugin._warned;
            } else {
                status.push(' ' + Plugin.toString(plugin));
            }

            module.used.push(plugin.name);
        }

        if (status.length > 0) {
            Common.info(status.join('  '));
        }
    };

    /**
     * Recursively finds all of a module's dependencies and returns a flat dependency graph.
     * @method dependencies
     * @param module {} The module.
     * @return {object} A dependency graph.
     */
    Plugin.dependencies = function(module, tracked) {
        var parsedBase = Plugin.dependencyParse(module),
            name = parsedBase.name;

        tracked = tracked || {};

        if (name in tracked) {
            return;
        }

        module = Plugin.resolve(module) || module;

        tracked[name] = Common.map(module.uses || [], function(dependency) {
            if (Plugin.isPlugin(dependency)) {
                Plugin.register(dependency);
            }

            var parsed = Plugin.dependencyParse(dependency),
                resolved = Plugin.resolve(dependency);

            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                Common.warn(
                    'Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy',
                    Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.'
                );

                resolved._warned = true;
                module._warned = true;
            } else if (!resolved) {
                Common.warn(
                    'Plugin.dependencies:', Plugin.toString(dependency), 'used by',
                    Plugin.toString(parsedBase), 'could not be resolved.'
                );

                module._warned = true;
            }

            return parsed.name;
        });

        for (var i = 0; i < tracked[name].length; i += 1) {
            Plugin.dependencies(tracked[name][i], tracked);
        }

        return tracked;
    };

    /**
     * Parses a dependency string into its components.
     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * This function can also handle dependencies that are already resolved (e.g. a module object).
     * @method dependencyParse
     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.
     * @return {object} The dependency parsed into its components.
     */
    Plugin.dependencyParse = function(dependency) {
        if (Common.isString(dependency)) {
            var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;

            if (!pattern.test(dependency)) {
                Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');
            }

            return {
                name: dependency.split('@')[0],
                range: dependency.split('@')[1] || '*'
            };
        }

        return {
            name: dependency.name,
            range: dependency.range || dependency.version
        };
    };

    /**
     * Parses a version string into its components.  
     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).
     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.
     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).
     * Only the following range types are supported:
     * - Tilde ranges e.g. `~1.2.3`
     * - Caret ranges e.g. `^1.2.3`
     * - Exact version e.g. `1.2.3`
     * - Any version `*`
     * @method versionParse
     * @param range {string} The version string.
     * @return {object} The version range parsed into its components.
     */
    Plugin.versionParse = function(range) {
        var pattern = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;

        if (!pattern.test(range)) {
            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');
        }

        var identifiers = range.split('-');
        range = identifiers[0];

        var isRange = isNaN(Number(range[0])),
            version = isRange ? range.substr(1) : range,
            parts = Common.map(version.split('.'), function(part) {
                return Number(part);
            });

        return {
            isRange: isRange,
            version: version,
            range: range,
            operator: isRange ? range[0] : '',
            parts: parts,
            prerelease: identifiers[1],
            number: parts[0] * 1e8 + parts[1] * 1e4 + parts[2]
        };
    };

    /**
     * Returns `true` if `version` satisfies the given `range`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.
     * @method versionSatisfies
     * @param version {string} The version string.
     * @param range {string} The range string.
     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.
     */
    Plugin.versionSatisfies = function(version, range) {
        range = range || '*';

        var rangeParsed = Plugin.versionParse(range),
            rangeParts = rangeParsed.parts,
            versionParsed = Plugin.versionParse(version),
            versionParts = versionParsed.parts;

        if (rangeParsed.isRange) {
            if (rangeParsed.operator === '*' || version === '*') {
                return true;
            }

            if (rangeParsed.operator === '~') {
                return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
            }

            if (rangeParsed.operator === '^') {
                if (rangeParts[0] > 0) {
                    return versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number;
                }

                if (rangeParts[1] > 0) {
                    return versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                }

                return versionParts[2] === rangeParts[2];
            }
        }

        return version === range || version === '*';
    };

})();


/***/ },
/* 156 */
/***/ function(module, exports) {

module.exports = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    makeCCW: polygonMakeCCW
};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
function lineInt(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!scalar_eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
}

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
function lineSegmentsIntersect(p1, p2, q1, q2){
	var dx = p2[0] - p1[0];
	var dy = p2[1] - p1[1];
	var da = q2[0] - q1[0];
	var db = q2[1] - q1[1];

	// segments are parallel
	if((da*dy - db*dx) === 0){
		return false;
	}

	var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
	var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);

	return (s>=0 && s<=1 && t>=0 && t<=1);
}

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
function triangleArea(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
}

function isLeft(a,b,c){
    return triangleArea(a,b,c) > 0;
}

function isLeftOn(a,b,c) {
    return triangleArea(a, b, c) >= 0;
}

function isRight(a,b,c) {
    return triangleArea(a, b, c) < 0;
}

function isRightOn(a,b,c) {
    return triangleArea(a, b, c) <= 0;
}

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
function collinear(a,b,c,thresholdAngle) {
    if(!thresholdAngle){
        return triangleArea(a, b, c) === 0;
    } else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
}

function sqdist(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
function polygonAt(polygon, i){
    var s = polygon.length;
    return polygon[i < 0 ? i % s + s : i % s];
}

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
function polygonClear(polygon){
    polygon.length = 0;
}

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
function polygonAppend(polygon, poly, from, to){
    for(var i=from; i<to; i++){
        polygon.push(poly[i]);
    }
}

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
function polygonMakeCCW(polygon){
    var br = 0,
        v = polygon;

    // find bottom right point
    for (var i = 1; i < polygon.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
        polygonReverse(polygon);
    }
}

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
function polygonReverse(polygon){
    var tmp = [];
    var N = polygon.length;
    for(var i=0; i!==N; i++){
        tmp.push(polygon.pop());
    }
    for(var i=0; i!==N; i++){
		polygon[i] = tmp[i];
    }
}

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
function polygonIsReflex(polygon, i){
    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
}

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee(polygon, a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
        return false;
    }
    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
    for (var i = 0; i !== polygon.length; ++i) { // for each edge
        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges
            continue;
        }
        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge
            l1[0] = polygonAt(polygon, a);
            l1[1] = polygonAt(polygon, b);
            l2[0] = polygonAt(polygon, i);
            l2[1] = polygonAt(polygon, i + 1);
            p = lineInt(l1,l2);
            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
}

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
function polygonCopy(polygon, i,j,targetPoly){
    var p = targetPoly || [];
    polygonClear(p);
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++){
            p.push(polygon[k]);
        }

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++){
            p.push(polygon[k]);
        }

        // Insert vertices i to end
        for(var k=i; k<polygon.length; k++){
            p.push(polygon[k]);
        }
    }

    return p;
}

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
function polygonGetCutEdges(polygon) {
    var min=[], tmp1=[], tmp2=[], tmpPoly = [];
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(polygon, i)) {
            for (var j = 0; j < polygon.length; ++j) {
                if (polygonCanSee(polygon, i, j)) {
                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));

                    for(var k=0; k<tmp2.length; k++){
                        tmp1.push(tmp2[k]);
                    }

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
                    }
                }
            }
        }
    }

    return min;
}

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
function polygonDecomp(polygon){
    var edges = polygonGetCutEdges(polygon);
    if(edges.length > 0){
        return polygonSlice(polygon, edges);
    } else {
        return [polygon];
    }
}

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
function polygonSlice(polygon, cutEdges){
    if(cutEdges.length === 0){
		return [polygon];
    }
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){

        var polys = [polygon];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = polygonSlice(poly, cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = polygon.indexOf(cutEdge[0]);
        var j = polygon.indexOf(cutEdge[1]);

        if(i !== -1 && j !== -1){
            return [polygonCopy(polygon, i,j),
                    polygonCopy(polygon, j,i)];
        } else {
            return false;
        }
    }
}

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
function polygonIsSimple(polygon){
    var path = polygon, i;
    // Check
    for(i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(i=1; i<path.length-2; i++){
        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
}

function getIntersectionPoint(p1, p2, q1, q2, delta){
	delta = delta || 0;
	var a1 = p2[1] - p1[1];
	var b1 = p1[0] - p2[0];
	var c1 = (a1 * p1[0]) + (b1 * p1[1]);
	var a2 = q2[1] - q1[1];
	var b2 = q1[0] - q2[0];
	var c2 = (a2 * q1[0]) + (b2 * q1[1]);
	var det = (a1 * b2) - (a2 * b1);

	if(!scalar_eq(det,0,delta)){
		return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];
	} else {
		return [0,0];
    }
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
function polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!=="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=[], upperPoly=[]; // polygons
    var poly = polygon,
        v = polygon;

    if(v.length < 3){
		return result;
    }

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(poly, i)) {
            reflexVertices.push(poly[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < polygon.length; ++j) {
                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection
                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly
                        d = sqdist(poly[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                        d = sqdist(poly[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex === (upperIndex + 1) % polygon.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+polygon.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, i, upperIndex+1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    if (lowerIndex !== 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly,0,i+1);
                } else {
                    if (i !== 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        polygonAppend(lowerPoly, poly,i,poly.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly,0,upperIndex+1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+polygon.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += polygon.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                        if (d < closestDist) {
                            closestDist = d;
                            closestIndex = j % polygon.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    polygonAppend(lowerPoly, poly,i,closestIndex+1);
                    if (closestIndex !== 0){
                        polygonAppend(upperPoly, poly,closestIndex,v.length);
                    }
                    polygonAppend(upperPoly, poly,0,i+1);
                } else {
                    if (i !== 0){
                        polygonAppend(lowerPoly, poly,i,v.length);
                    }
                    polygonAppend(lowerPoly, poly,0,closestIndex+1);
                    polygonAppend(upperPoly, poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.length < upperPoly.length) {
                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(polygon);

    return result;
}

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
function polygonRemoveCollinearPoints(polygon, precision){
    var num = 0;
    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){
        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){
            // Remove the middle point
            polygon.splice(i%polygon.length,1);
            num++;
        }
    }
    return num;
}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function scalar_eq(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) < precision;
}


/***/ },
/* 157 */
/***/ function(module, exports) {

var CreateTexture2DImage = function (gl, pixels, filter, mipLevels)
{
    var texture = gl.createTexture();
    mipLevels = mipLevels || 0;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texImage2D(
        gl.TEXTURE_2D,
        mipLevels,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        pixels
    );
    return texture;
};

module.exports = CreateTexture2DImage;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var EventDispatcher = __webpack_require__(23);
var GameObjectFactory = __webpack_require__(511);
var GameObjectCreator = __webpack_require__(510);
var StateManager = __webpack_require__(513);
var Loader = __webpack_require__(512);
var UpdateManager = __webpack_require__(514);
var Component = __webpack_require__(8);
var Settings = __webpack_require__(507);
var RTree = __webpack_require__(515);
var CameraManager = __webpack_require__(509);

var Systems = function (state, config)
{
    this.state = state;

    this.game = null;

    this.config = config;

    this.settings = Settings.create(config);

    this.x = this.settings.x;
    this.y = this.settings.y;
    this.width = this.settings.width;
    this.height = this.settings.height;

    this.mask = null;
    this.canvas;
    this.context;

    //  CORE SYSTEMS / PROPERTIES

    this.cache;
    this.textures;

    //  Reference to State specific managers (Factory, Tweens, Loader, Physics, etc)
    this.add;
    this.make;
    this.load;
    this.events;
    this.updates;
    this.tree;
    this.stateManager;

    //  State properties
    this.cameras;
    this.children;
    this.color;
    this.data;
    // this.fbo;
    this.time;
    this.transform;
};

Systems.prototype.constructor = Systems;

Systems.prototype = {

    init: function (game)
    {
        // console.log('State.Systems.init');

        this.game = game;

        Settings.init(this.settings, this.game.config);

        this.width = this.settings.width;
        this.height = this.settings.height;

        this.cache = this.game.cache;
        this.textures = this.game.textures;

        //  State specific managers (Factory, Tweens, Loader, Physics, etc)

        this.tree = RTree(16);
        this.events = new EventDispatcher();
        this.add = new GameObjectFactory(this.state);
        this.make = new GameObjectCreator(this.state);
        this.updates = new UpdateManager(this.state);
        this.load = new Loader(this.state);
        this.stateManager = new StateManager(this.state, game);
        this.cameras = new CameraManager(this.state);

        //  State specific properties (transform, data, children, etc)

        this.children = new Component.Children(this.state);
        this.color = new Component.Color(this.state);
        this.data = new Component.Data(this.state);

        this.inject();
    },

    inject: function ()
    {
        //  Defaults properties injected into the State

        this.state.game = this.game;

        this.state.events = this.events;
        this.state.add = this.add;
        this.state.load = this.load;
        this.state.children = this.children;
        this.state.color = this.color;
        this.state.data = this.data;
        this.state.settings = this.settings;
        this.state.state = this.stateManager;

        this.state.cameras = this.cameras;

        this.state.cache = this.game.cache;
        this.state.input = this.game.input;
        this.state.textures = this.game.textures;
    },

    //  Called just once per frame, regardless of speed
    begin: function (timestamp, frameDelta)
    {
    },

    //  Potentially called multiple times per frame (on super-fast systems)
    update: function (timestep, physicsStep)
    {
        this.cameras.update(timestep);

        this.state.update.call(this.state, timestep, physicsStep);
    },

    render: function (interpolation, renderer)
    {
        if (!this.settings.visible)
        {
            return;
        }

        this.cameras.render(renderer, this.children, interpolation);
    }
};

module.exports = Systems;


/***/ },
/* 159 */
/***/ function(module, exports) {

/**
* Create an array representing the range of numbers (usually integers), between, and inclusive of,
* the given `start` and `end` arguments. For example:
*
* `var array = numberArray(2, 4); // array = [2, 3, 4]`
* `var array = numberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
* 
* This is equivalent to `numberArrayStep(start, end, 1)`.
* 
* You can optionally provide a prefix and / or suffix string. If given the array will contain
* strings, not integers. For example:
* 
* `var array = numberArray(1, 4, 'Level '); // array = ["Level 1", "Level 2", "Level 3", "Level 4"]`
* `var array = numberArray(5, 7, 'HD-', '.png'); // array = ["HD-5.png", "HD-6.png", "HD-7.png"]`
*
* @method Phaser.ArrayUtils#numberArray
* @param {number} start - The minimum value the array starts with.
* @param {number} end - The maximum value the array contains.
* @param {string} [prefix] - Optional prefix to place before the number. If provided the array will contain strings, not integers.
* @param {string} [suffix] - Optional suffix to place after the number. If provided the array will contain strings, not integers.
* @return {number[]|string[]} The array of number values, or strings if a prefix or suffix was provided.
*/
var NumberArray = function (start, end, prefix, suffix)
{
    var result = [];

    for (var i = start; i <= end; i++)
    {
        if (prefix || suffix)
        {
            var key = (prefix) ? prefix + i.toString() : i.toString();

            if (suffix)
            {
                key = key.concat(suffix);
            }

            result.push(key);
        }
        else
        {
            result.push(i);
        }
    }

    return result;
};

module.exports = NumberArray;


/***/ },
/* 160 */
/***/ function(module, exports) {

//  This is from the quickselect npm package: https://www.npmjs.com/package/quickselect
//  Coded by https://www.npmjs.com/~mourner (Vladimir Agafonkin)

// https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

var QuickSelect = function (arr, k, left, right, compare)
{
    left = left || 0;
    right = right || (arr.length - 1);
    compare = compare || defaultCompare;

    while (right > left)
    {
        if (right - left > 600)
        {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));

            QuickSelect(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);

        if (compare(arr[right], t) > 0)
        {
            swap(arr, left, right);
        }

        while (i < j)
        {
            swap(arr, i, j);

            i++;
            j--;

            while (compare(arr[i], t) < 0)
            {
                i++;
            }

            while (compare(arr[j], t) > 0)
            {
                j--;
            }
        }

        if (compare(arr[left], t) === 0)
        {
            swap(arr, left, j);
        }
        else
        {
            j++;
            swap(arr, j, right);
        }

        if (j <= k)
        {
            left = j + 1;
        }

        if (k <= j)
        {
            right = j - 1;
        }
    }
};

function swap (arr, i, j)
{
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare (a, b)
{
    return a < b ? -1 : a > b ? 1 : 0;
}

module.exports = QuickSelect;


/***/ },
/* 161 */
/***/ function(module, exports) {

//  Removes a single item from an array and returns it
//  without creating gc (like the native splice does)
//  Based on code by Mike Reinstein

var SpliceOne = function (array, index)
{
    if (index >= array.length)
    {
        return;
    }

    var len = array.length - 1;

    var item = array[index];

    for (var i = index; i < len; i++)
    {
        array[i] = array[i + 1];
    }

    array.length = len;

    return item;
};

module.exports = SpliceOne;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

var SetCenterX = __webpack_require__(34);
var SetCenterY = __webpack_require__(35);

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var CenterOn = function (gameObject, x, y)
{
    SetCenterX(gameObject, x);

    return SetCenterY(gameObject, y);
};

module.exports = CenterOn;


/***/ },
/* 163 */
/***/ function(module, exports) {

/**
* This is a slightly modified version of jQuery.isPlainObject.
* A plain object is an object whose internal class property is [object Object].
* @method Phaser.Utils.isPlainObject
* @param {object} obj - The object to inspect.
* @return {boolean} - true if the object is plain, otherwise false.
*/
var IsPlainObject = function (obj)
{
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (typeof(obj) !== "object" || obj.nodeType || obj === obj.window)
    {
        return false;
    }

    // Support: Firefox <20
    // The try/catch suppresses exceptions thrown when attempting to access
    // the "constructor" property of certain host objects, ie. |window.location|
    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
    try {
        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf"))
        {
            return false;
        }
    } catch (e) {
        return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
};

module.exports = IsPlainObject;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Config = __webpack_require__(178);
var DebugHeader = __webpack_require__(180);
var Device = __webpack_require__(205);

var AddToDOM = __webpack_require__(83);
var DOMContentLoaded = __webpack_require__(84);

var MainLoop = __webpack_require__(181);
var CreateRenderer = __webpack_require__(179);
var GlobalInputManager = __webpack_require__(378);
var GlobalStateManager = __webpack_require__(506);
var TextureManager = __webpack_require__(519);
var Data = __webpack_require__(80);
var Cache = __webpack_require__(183);

var Game = function (config)
{
    this.config = new Config(config);

    this.renderer = null;
    this.canvas = null;
    this.context = null;

    this.isBooted = false;
    this.isRunning = false;

    /**
    * @property {Phaser.TextureManager} textures - Reference to the Phaser Texture Manager.
    */
    this.textures = new TextureManager(this);

    /**
    * @property {Phaser.Cache} cache - Reference to the assets cache.
    */
    this.cache = new Cache();

    /**
    * @property {Phaser.Data} registry - Game wide data store.
    */
    this.registry = new Data(this);

    /**
    * @property {Phaser.Input} input - Reference to the input manager
    */
    this.input = new GlobalInputManager(this, this.config);

    /**
    * @property {Phaser.GlobalStateManager} state - The StateManager. Phaser instance specific.
    */
    this.state = new GlobalStateManager(this, this.config.stateConfig);

    /**
    * @property {Phaser.Device} device - Contains device information and capabilities (singleton)
    */
    this.device = Device;

    /**
    * @property {Phaser.MainLoop} mainloop - Main Loop handler.
    * @protected
    */
    this.mainloop = new MainLoop(this, this.config.fps);

    //  Wait for the DOM Ready event, then call boot.
    DOMContentLoaded(this.boot.bind(this));

    //  For debugging only
    window.game = this;
};

Game.prototype.constructor = Game;

Game.prototype = {

    boot: function ()
    {
        this.isBooted = true;

        this.config.preBoot();

        DebugHeader(this);

        CreateRenderer(this);

        AddToDOM(this.canvas, this.config.parent);

        this.state.boot();

        this.input.boot();

        this.isRunning = true;

        this.config.postBoot();

        this.mainloop.start();
    }

};

module.exports = Game;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    AddEventListener: __webpack_require__(206),
    AddToDOM: __webpack_require__(83),
    CanvasInterpolation: __webpack_require__(52),
    CanvasPool: __webpack_require__(28),
    DOMContentLoaded: __webpack_require__(84),
    ParseXML: __webpack_require__(85),
    RemoveEventListener: __webpack_require__(207),
    RemoveFromDOM: __webpack_require__(208),
    RequestAnimationFrame: __webpack_require__(86),
    TouchAction: __webpack_require__(209),
    UserSelect: __webpack_require__(210)

};


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

//  Required, but don't need Phaser level exports
//  (maybe these should be Phaser export level?)

__webpack_require__(223);
__webpack_require__(228);
__webpack_require__(236);
__webpack_require__(240);
__webpack_require__(219);
__webpack_require__(215);
__webpack_require__(232);

//  Phaser.GameObjects

module.exports = {

    Factory: __webpack_require__(6),

    BitmapText: __webpack_require__(90),
    DynamicBitmapText: __webpack_require__(89),
    Blitter: __webpack_require__(91),
    Container: __webpack_require__(92),
    Image: __webpack_require__(94),
    Sprite: __webpack_require__(95),
    Graphics: __webpack_require__(93)

};


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom

module.exports = {
    
    Circle: __webpack_require__(255),
    Ellipse: __webpack_require__(266),
    Hermite: __webpack_require__(273),
    Intersects: __webpack_require__(281),
    Line: __webpack_require__(301),
    Point: __webpack_require__(321),
    Polygon: __webpack_require__(326),
    Rectangle: __webpack_require__(353)

};


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Graphics

module.exports = {

    BlendModes: __webpack_require__(368),
    Color: __webpack_require__(377)
  
};


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Input

module.exports = {

    Keyboard: __webpack_require__(385)

};


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Physics

module.exports = {
    PolyDecomp: __webpack_require__(156),
    MatterJS: __webpack_require__(468)
};


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(470);
__webpack_require__(471);
__webpack_require__(472);
__webpack_require__(476);
__webpack_require__(473);
__webpack_require__(474);
__webpack_require__(477);
__webpack_require__(478);
__webpack_require__(475);


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Sound

module.exports = {

    Dynamic: __webpack_require__(505)

};


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Utils.Align

module.exports = {

    InBottomCenter: __webpack_require__(529),
    InBottomLeft: __webpack_require__(530),
    InBottomRight: __webpack_require__(531),
    InCenter: __webpack_require__(532),
    InLeftCenter: __webpack_require__(533),
    InRightCenter: __webpack_require__(534),
    InTopCenter: __webpack_require__(535),
    InTopLeft: __webpack_require__(536),
    InTopRight: __webpack_require__(537),
    ToBottomCenter: __webpack_require__(538),
    ToBottomLeft: __webpack_require__(539),
    ToBottomRight: __webpack_require__(540),
    ToLeftBottom: __webpack_require__(541),
    ToLeftCenter: __webpack_require__(542),
    ToLeftTop: __webpack_require__(543),
    ToRightBottom: __webpack_require__(544),
    ToRightCenter: __webpack_require__(545),
    ToRightTop: __webpack_require__(546),
    ToTopCenter: __webpack_require__(547),
    ToTopLeft: __webpack_require__(548),
    ToTopRight: __webpack_require__(549)

};


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    FindClosestInSorted: __webpack_require__(550),
    GetRandomElement: __webpack_require__(551),
    NumberArray: __webpack_require__(159),
    NumberArrayStep: __webpack_require__(552),
    QuickSelect: __webpack_require__(160),
    RemoveRandomElement: __webpack_require__(553),
    RotateLeft: __webpack_require__(554),
    RotateRight: __webpack_require__(555),
    Shuffle: __webpack_require__(556),
    SpliceOne: __webpack_require__(161)

};


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Utils.Bounds

module.exports = {

    CenterOn: __webpack_require__(162),
    GetBottom: __webpack_require__(11),
    GetCenterX: __webpack_require__(32),
    GetCenterY: __webpack_require__(33),
    GetLeft: __webpack_require__(12),
    GetOffsetX: __webpack_require__(557),
    GetOffsetY: __webpack_require__(558),
    GetRight: __webpack_require__(13),
    GetTop: __webpack_require__(14),
    SetBottom: __webpack_require__(15),
    SetCenterX: __webpack_require__(34),
    SetCenterY: __webpack_require__(35),
    SetLeft: __webpack_require__(16),
    SetRight: __webpack_require__(17),
    SetTop: __webpack_require__(18)
    
};


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Extend: __webpack_require__(51),
    IsPlainObject: __webpack_require__(163)

};


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Pad: __webpack_require__(559),
    Reverse: __webpack_require__(560)

};


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var MATH = __webpack_require__(75);
var CONST = __webpack_require__(2);
var NOOP = __webpack_require__(74);
var GetObjectValue = __webpack_require__(36);
var ValueToColor = __webpack_require__(129);

var defaultBannerColor = [
    '#ff0000',
    '#ffff00',
    '#00ff00',
    '#00ffff',
    '#000000'
];

var defaultBannerTextColor = '#ffffff';

var Config = function (config)
{
    if (config === undefined) { config = {}; }

    this.width = GetObjectValue(config, 'width', 1024);
    this.height = GetObjectValue(config, 'height', 768);
    this.zoom = GetObjectValue(config, 'zoom', 1);

    this.resolution = GetObjectValue(config, 'resolution', 1);

    this.renderType = GetObjectValue(config, 'type', CONST.AUTO);

    this.parent = GetObjectValue(config, 'parent', null);
    this.canvas = GetObjectValue(config, 'canvas', null);
    this.canvasStyle = GetObjectValue(config, 'canvasStyle', null);

    this.stateConfig = GetObjectValue(config, 'state', null);

    this.seed = GetObjectValue(config, 'seed', [ (Date.now() * Math.random()).toString() ]);

    MATH.RND.init(this.seed);

    this.gameTitle = GetObjectValue(config, 'title', '');
    this.gameURL = GetObjectValue(config, 'url', 'http://phaser.io');
    this.gameVersion = GetObjectValue(config, 'version', '');

    //  Input
    this.inputKeyboard = GetObjectValue(config, 'input.keyboard', true);
    this.inputKeyboardEventTarget = GetObjectValue(config, 'input.keyboard.target', window);

    //  If you do: { banner: false } it won't display any banner at all
    this.hideBanner = (GetObjectValue(config, 'banner', null) === false);

    this.hidePhaser = GetObjectValue(config, 'banner.hidePhaser', false);
    this.bannerTextColor = GetObjectValue(config, 'banner.text', defaultBannerTextColor);
    this.bannerBackgroundColor = GetObjectValue(config, 'banner.background', defaultBannerColor);
   
    this.fps = GetObjectValue(config, 'fps', 60);
    this.forceSetTimeOut = GetObjectValue(config, 'forceSetTimeOut', false);

    this.pixelArt = GetObjectValue(config, 'pixelArt', false);
    this.transparent = GetObjectValue(config, 'transparent', false);
    this.clearBeforeRender = GetObjectValue(config, 'clearBeforeRender', true);
    this.backgroundColor = ValueToColor(GetObjectValue(config, 'backgroundColor', 0));
    this.preserveDrawingBuffer = ValueToColor(GetObjectValue(config, 'preserveDrawingBuffer', false));

    //  Callbacks
    this.preBoot = GetObjectValue(config, 'callbacks.preBoot', NOOP);
    this.postBoot = GetObjectValue(config, 'callbacks.postBoot', NOOP);

    //  Default / Missing Images
    this.defaultImage = GetObjectValue(config, 'images.default', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==');
    this.missingImage = GetObjectValue(config, 'images.missing', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==');
};

Config.prototype.constructor = Config;

module.exports = Config;


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);
var CanvasPool = __webpack_require__(28);
var Features = __webpack_require__(82);
var CanvasRenderer = __webpack_require__(479);
var WebGLRenderer = __webpack_require__(483);
var CanvasInterpolation = __webpack_require__(52);

/**
* Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.
*
* @method Phaser.Game#setUpRenderer
* @protected
*/
var CreateRenderer = function (game)
{
    var config = game.config;

    //  Game either requested Canvas,
    //  or requested AUTO or WEBGL but the browser doesn't support it, so fall back to Canvas
    if (config.renderType === CONST.CANVAS || (config.renderType !== CONST.CANVAS && !Features.webGL))
    {
        if (Features.canvas)
        {
            //  They requested Canvas and their browser supports it
            config.renderType = CONST.CANVAS;
        }
        else
        {
            throw new Error('Cannot create Canvas or WebGL context, aborting.');
        }
    }
    else
    {
        //  Game requested WebGL and browser says it supports it
        config.renderType = CONST.WEBGL;
    }

    //  Does the game config provide its own canvas element to use?
    if (config.canvas)
    {
        game.canvas = config.canvas;
    }
    else
    {
        game.canvas = CanvasPool.create(game, config.width, config.height, config.renderType);
    }

    //  Does the game config provide some canvas css styles to use?
    if (config.canvasStyle)
    {
        game.canvas.style = config.canvasStyle;
    }

    //  Pixel Art mode?
    if (config.pixelArt)
    {
        CanvasInterpolation.setCrisp(game.canvas);
    }

    //  Zoomed?
    if (config.zoom !== 1)
    {
        game.canvas.style.width = (config.width * config.zoom).toString() + 'px';
        game.canvas.style.height = (config.height * config.zoom).toString() + 'px';
    }

    //  Create the renderer
    if (config.renderType === CONST.WEBGL)
    {
        game.renderer = new WebGLRenderer(game);
        game.context = null;
    }
    else
    {
        game.renderer = new CanvasRenderer(game);
        game.context = game.renderer.gameContext;

        //  debug
        game.canvas.id = 'game';
    }
};

module.exports = CreateRenderer;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);
var CHECKSUM = __webpack_require__(189);

var DebugHeader = function (game)
{
    var config = game.config;

    if (config.hideBanner)
    {
        return;
    }

    var renderType = (config.renderType === CONST.CANVAS) ? 'Canvas' : 'WebGL';

    var ie = false;

    if (!ie)
    {
        var c = '';
        var args = [c];

        if (Array.isArray(config.bannerBackgroundColor))
        {
            var lastColor;

            config.bannerBackgroundColor.forEach(function(color) {

                c = c.concat('%c ');

                args.push('background: ' + color);

                lastColor = color;

            });

            //  inject the text color
            args[args.length - 1] = 'color: ' + config.bannerTextColor + '; background: ' + lastColor;
        }
        else
        {
            c = c.concat('%c ');

            args.push('color: ' + config.bannerTextColor + '; background: ' + config.bannerBackgroundColor);
        }

        //  URL link background color (always white)
        args.push('background: #fff');

        if (config.gameTitle)
        {
            c = c.concat(config.gameTitle);

            if (config.gameVersion)
            {
                c = c.concat(' v' + config.gameVersion);
            }

            if (!config.hidePhaser)
            {
                c = c.concat(' / ');
            }
        }

        if (!config.hidePhaser)
        {
            c = c.concat('Phaser v' + CONST.VERSION + ' (' + renderType + ')');
        }

        c = c.concat(' %c ' + config.gameURL);

        //  Inject the new string back into the args array
        args[0] = c;

        console.log.apply(console, args);
    }
    else if (window['console'])
    {
        console.log('Phaser v' + CONST.VERSION + ' / http://phaser.io');
    }

    // Keep this during dev build only
    console.log(CHECKSUM.build);

};

module.exports = DebugHeader;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

var RequestAnimationFrame = __webpack_require__(86);

// My thanks to Isaac Sukin for creating MainLoop.js, on which lots of this is based.

var MainLoop = function (game, framerate)
{
    this.game = game;

    /**
    * @property {Phaser.RequestAnimationFrame} raf - Automatically handles the core game loop via requestAnimationFrame or setTimeout
    * @protected
    */
    this.raf = new RequestAnimationFrame();

    /**
    * @property {number} timestep - The amount of time (in milliseconds) to simulate each time update() runs.
    */
    this.timestep = 1000 / framerate;

    /**
    * @property {number} physicsStep - 1 / framerate.
    */
    this.physicsStep = 1 / framerate;

    /**
    * @property {number} frameDelta - The cumulative amount of in-app time that hasn't been simulated yet.
    */
    this.frameDelta = 0;

    this.discardedTime = 0;

    /**
    * The timestamp in milliseconds of the last time the main loop was run.
    * Used to compute the time elapsed between frames.
    * @property {number} lastFrameTimeMs
    */
    this.lastFrameTimeMs = 0;

    /**
    * @property {number} fps - An exponential moving average of the frames per second.
    */
    this.fps = 60;

    /**
    * @property {number} lastFpsUpdate - The timestamp (in milliseconds) of the last time the `fps` moving average was updated.
    */
    this.lastFpsUpdate = 0;

    /**
    * @property {number} framesThisSecond - The number of frames delivered in the current second.
    */
    this.framesThisSecond = 0;

    /**
    * @property {number} numUpdateSteps - The number of times update() is called in a given frame.
    */
    this.numUpdateSteps = 0;

    /**
    * The minimum amount of time in milliseconds that must pass since the last frame was executed
    * before another frame can be executed.
    * The multiplicative inverse caps the FPS (the default of zero means there is no cap)
    * @property {number} minFrameDelay
    */
    this.minFrameDelay = 0;

    /**
    * @property {boolean} running - Whether the main loop is running.
    */
    this.running = false;

    /**
     * `true` if `MainLoop.start()` has been called and the most recent time it
     * was called has not been followed by a call to `MainLoop.stop()`. This is
     * different than `running` because there is a delay of a few milliseconds
     * after `MainLoop.start()` is called before the application is considered
     * "running." This delay is due to waiting for the next frame.
    * @property {boolean} started
    */
    this.started = false;

    /**
     * Whether the simulation has fallen too far behind real time.
     * Specifically, `panic` will be set to `true` if too many updates occur in
     * one frame. This is only relevant inside of animate(), but a reference is
     * held externally so that this variable is not marked for garbage
     * collection every time the main loop runs.
    * @property {boolean} panic - Whether the simulation has fallen too far behind real time.
    */
    this.panic = false;
};

MainLoop.prototype.constructor = MainLoop;

MainLoop.prototype = {

    setMaxFPS: function (fps)
    {
        if (fps === 0)
        {
            this.stop();
        }
        else
        {
            this.minFrameDelay = 1000 / fps;
        }
    },

    getMaxFPS: function ()
    {
        return 1000 / this.minFrameDelay;
    },

    resetFrameDelta: function ()
    {
        var oldFrameDelta = this.frameDelta;

        this.frameDelta = 0;

        return oldFrameDelta;
    },

    start: function ()
    {
        if (this.started)
        {
            return this;
        }

        this.started = true;
        this.running = true;

        this.lastFrameTimeMs = window.performance.now();
        this.lastFpsUpdate = window.performance.now();
        this.framesThisSecond = 0;

        this.raf.start(this.step.bind(this), this.game.config.forceSetTimeOut);
    },

    //  timestamp = DOMHighResTimeStamp
    // active = array containing: ({ index: i, state: state })

    step: function (timestamp)
    {
        var active = this.game.state.active;
        var renderer = this.game.renderer;

        var len = active.length;

        // Throttle the frame rate (if minFrameDelay is set to a non-zero value by
        // `MainLoop.setMaxAllowedFPS()`).
        if (len === 0 || timestamp < this.lastFrameTimeMs + this.minFrameDelay)
        {
            return;
        }

        // frameDelta is the cumulative amount of in-app time that hasn't been
        // simulated yet. Add the time since the last frame. We need to track total
        // not-yet-simulated time (as opposed to just the time elapsed since the
        // last frame) because not all actually elapsed time is guaranteed to be
        // simulated each frame. See the comments below for details.
        this.frameDelta += timestamp - this.lastFrameTimeMs;
        this.lastFrameTimeMs = timestamp;

        //  Global Managers (Time, Input, etc)

        this.game.input.update(timestamp, this.frameDelta);

        //  Run any updates that are not dependent on time in the simulation.
        //  Here we'll need to run things like tween.update, input.update, etc.

        for (var i = 0; i < len; i++)
        {
            active[i].state.sys.begin(timestamp, this.frameDelta);
        }

        // Update the estimate of the frame rate, `fps`. Every second, the number
        // of frames that occurred in that second are included in an exponential
        // moving average of all frames per second, with an alpha of 0.25. This
        // means that more recent seconds affect the estimated frame rate more than
        // older seconds.
        if (timestamp > this.lastFpsUpdate + 1000)
        {
            // Compute the new exponential moving average with an alpha of 0.25.
            // Using constants inline is okay here.
            this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;

            this.lastFpsUpdate = timestamp;
            this.framesThisSecond = 0;
        }

        this.framesThisSecond++;

        this.numUpdateSteps = 0;

        while (this.frameDelta >= this.timestep)
        {
            for (i = 0; i < len; i++)
            {
                active[i].state.sys.update(this.timestep, this.physicsStep);
            }

            this.frameDelta -= this.timestep;

            if (++this.numUpdateSteps >= 240)
            {
                this.panic = true;
                break;
            }
        }

        //  Render

        var interpolation = this.frameDelta / this.timestep;

        renderer.preRender();

        //  This uses active.length, in case state.update removed the state from the active list
        for (i = 0; i < active.length; i++)
        {
            active[i].state.sys.render(interpolation, renderer);
        }

        renderer.postRender();

        if (this.panic)
        {
            // This pattern introduces non-deterministic behavior, but in this case
            // it's better than the alternative (the application would look like it
            // was running very quickly until the simulation caught up to real
            // time).
            this.discardedTime = Math.round(this.resetFrameDelta());

            // console.warn('Main loop panicked, tab probably put in the background. Discarding ' + discardedTime + 'ms');
        }

        this.panic = false;
    },

    stop: function ()
    {
        this.running = false;
        this.started = false;

        return this;
    }

};

module.exports = MainLoop;


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

var CacheEntry = __webpack_require__(184);
var Events = __webpack_require__(187);
var EventDispatcher = __webpack_require__(23);

var BaseCache = function ()
{
    this.entries = new Map();

    this.events = new EventDispatcher();
};

BaseCache.prototype.constructor = BaseCache;

BaseCache.prototype = {

    add: function (key, data)
    {
        this.entries.set(key, data);

        this.events.dispatch(new Events.CACHE_ADD_EVENT(this, key, data));
    },

    has: function (key)
    {
        return this.entries.has(key);
    },

    get: function (key)
    {
        return this.entries.get(key);
    },

    remove: function (key)
    {
        var entry = this.get(key);

        if (entry)
        {
            this.entries.delete(key);

            this.events.dispatch(new Events.CACHE_REMOVE_EVENT(this, key, entry.data));
        }
    },

    destroy: function ()
    {
        this.entries.clear();
    }

};

module.exports = BaseCache;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

var BaseCache = __webpack_require__(182);

var Cache = function ()
{
    this.sound = new BaseCache();
    this.video = new BaseCache();
    this.text = new BaseCache();
    this.json = new BaseCache();
    this.xml = new BaseCache();
    this.physics = new BaseCache();
    this.tilemap = new BaseCache();
    this.binary = new BaseCache();
    this.bitmapFont = new BaseCache();
    this.shader = new BaseCache();

    this.custom = {};
};

Cache.prototype.constructor = Cache;

Cache.prototype = {

    //  Add your own custom Cache entry, available under Cache.custom.key
    addCustom: function (key)
    {
        if (!this.custom.hasOwnProperty(key))
        {
            this.custom[key] = new BaseCache();

            return this.custom[key];
        }
    }

};

module.exports = Cache;


/***/ },
/* 184 */
/***/ function(module, exports) {

var CacheEntry = function (key, url, data)
{
    this.key = key;

    this.url = url;

    this.data = data;
};

CacheEntry.prototype.constructor = CacheEntry;

module.exports = CacheEntry;


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var CacheAddEvent = function (cache, key, data)
{
    Event.call(this, 'CACHE_ADD_EVENT');

    this.cache = cache;
    this.key = key;
    this.data = data;
};

CacheAddEvent.prototype = Object.create(Event.prototype);
CacheAddEvent.prototype.constructor = CacheAddEvent;

module.exports = CacheAddEvent;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var CacheRemoveEvent = function (cache, key, data)
{
    Event.call(this, 'CACHE_ADD_EVENT');

    this.cache = cache;
    this.key = key;
    this.data = data;
};

CacheRemoveEvent.prototype = Object.create(Event.prototype);
CacheRemoveEvent.prototype.constructor = CacheRemoveEvent;

module.exports = CacheRemoveEvent;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    CACHE_ADD_EVENT: __webpack_require__(185),
    CACHE_REMOVE_EVENT: __webpack_require__(186)

};


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

var TransformMatrix = __webpack_require__(26);

var Camera = function (x, y, width, height)
{
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    this.scrollX = 0.0;
    this.scrollY = 0.0;
    this.zoom = 1.0;
    this.rotation = 0.0;
    this.matrix = new TransformMatrix(1, 0, 0, 1, 0, 0);

    // shake
    this._shakeDuration = 0.0;
    this._shakeIntensity = 0.0;
    this._shakeOffsetX = 0.0;
    this._shakeOffsetY = 0.0;

    // fade
    this._fadeDuration = 0.0;
    this._fadeRed = 0.0;
    this._fadeGreen = 0.0;
    this._fadeBlue = 0.0;
    this._fadeAlpha = 0.0;

    // flash
    this._flashDuration = 0.0;
    this._flashRed = 1.0;
    this._flashGreen = 1.0;
    this._flashBlue = 1.0;
    this._flashAlpha = 0.0;

    // origin
    this._follow = null;
};

Camera.prototype.constructor = Camera;

Camera.prototype = {

    setViewport: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    },

    setSize: function (width, height)
    {
        this.width = width;
        this.height = height;
    },

    setState: function (state)
    {
        this.state = state;
    },

    update: function (delta)
    {
        if (this._flashAlpha > 0.0)
        {
            this._flashAlpha -= delta / this._flashDuration;

            if (this._flashAlpha < 0.0)
            {
                this._flashAlpha = 0.0;
            }
        }

        if (this._fadeAlpha > 0.0 && this._fadeAlpha < 1.0)
        {
            this._fadeAlpha += delta / this._fadeDuration;

            if (this._fadeAlpha >= 1.0)
            {
                this._fadeAlpha = 1.0;
            }
        }

        if (this._shakeDuration > 0.0)
        {
            var intensity = this._shakeIntensity;

            this._shakeDuration -= delta;

            if (this._shakeDuration <= 0.0)
            {
                this._shakeOffsetX = 0.0;
                this._shakeOffsetY = 0.0;
            }
            else
            {
                this._shakeOffsetX = (Math.random() * intensity * this.width * 2 - intensity * this.width) * this.zoom;
                this._shakeOffsetY = (Math.random() * intensity * this.height * 2 - intensity * this.height) * this.zoom;
            }
        }
    },

    startFollow: function (gameObjectOrPoint)
    {
        if (this._follow !== null)
        {
            this.stopFollow();
        }

        this._follow = gameObjectOrPoint;
    },

    stopFollow: function () 
    {
        /* do unfollow work here */
        this._follow = null;
    },

    flash: function (duration, red, green, blue, force)
    {
        if (!force && this._flashAlpha > 0.0)
        {
            return;
        }

        if (red === undefined) { red = 1.0; }
        if (green === undefined) { green = 1.0; }
        if (blue === undefined) { blue = 1.0; }

        this._flashRed = red;
        this._flashGreen = green;
        this._flashBlue = blue;

        if (duration <= 0)
        {
            duration = Number.MIN_VALUE;
        }

        this._flashDuration = duration;
        this._flashAlpha = 1.0;
    },

    fade: function (duration, red, green, blue, force)
    {
        if (red === undefined) { red = 0.0; }
        if (green === undefined) { green = 0.0; }
        if (blue === undefined) { blue = 0.0; }

        if (!force && this._fadeAlpha > 0.0)
        {
            return;
        }

        this._fadeRed = red;
        this._fadeGreen = green;
        this._fadeBlue = blue;

        if (duration <= 0)
        {
            duration = Number.MIN_VALUE;
        }

        this._fadeDuration = duration;
        this._fadeAlpha = Number.MIN_VALUE;
    },

    shake: function (duration, intensity, force)
    {
        if (intensity === undefined) { intensity = 0.05; }

        if (!force && (this._shakeOffsetX !== 0.0 || this._shakeOffsetY !== 0.0))
        {
            return;
        }

        this._shakeDuration = duration;
        this._shakeIntensity = intensity;
        this._shakeOffsetX = 0;
        this._shakeOffsetY = 0;
    },

    preRender: function ()
    {
        var width = this.width;
        var height = this.height;
        var zoom = this.zoom;
        var matrix = this.matrix;
        var originX = width / 2;
        var originY = height / 2;
        var follow = this._follow;

        if (follow != null)
        {
            originX = follow.x;
            originY = follow.y;
            
            this.scrollX = originX - width * 0.5;
            this.scrollY = originY - height * 0.5;
        }

        matrix.loadIdentity();
        matrix.translate(this.x + originX, this.y + originY);
        matrix.rotate(this.rotation);
        matrix.scale(zoom, zoom);
        matrix.translate(-originX, -originY);
        matrix.translate(this._shakeOffsetX, this._shakeOffsetY);
    },

    destroy: function ()
    {
        this.state = undefined;
    }

};

module.exports = Camera;


/***/ },
/* 189 */
/***/ function(module, exports) {

var CHECKSUM = {
build: 'a1264be0-08d4-11e7-ac0c-8bbee1c3f11c'
};
module.exports = CHECKSUM;

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

var Clamp = __webpack_require__(139);

//  Alpha Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 2; // 0010

var Alpha = {

    _alpha: 1,

    alpha: {

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            this._alpha = Clamp(value, 0, 1);

            if (this._alpha === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    }

};

module.exports = Alpha;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

var BlendModes = __webpack_require__(72);

//  BlendMode Component

var BlendMode = {

    _blendMode: BlendModes.NORMAL,

    blendMode: {

        get: function ()
        {
            return this._blendMode;
        },

        set: function (value)
        {
            value | 0;

            if (value >= 0 && value <= 16)
            {
                this._blendMode = value;
            }
        }

    }

};

module.exports = BlendMode;


/***/ },
/* 192 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Children Component features quick access to Group sorting related methods.
*
* @class
*/
var Children = function (gameObject)
{
    this.gameObject = gameObject;

    //  The objects that belong to this collection.
    //  The equivalent of the old `Sprite.children` array.
    this.list = [];

    this.position = 0;
};

Children.prototype.constructor = Children;

Children.prototype = {

    add: function (child)
    {
        // console.log('--->', this.gameObject, 'adds new child:', child);

        if (child.parent === this)
        {
            // console.log('Children.add 1');
            return child;
        }
        else if (child.parent)
        {
            // console.log('Children.add 2');
            child.parent.children.remove(child);
        }

        child.parent = this.gameObject;

        this.list.push(child);

        // console.log('<--- end');

        return child;
    },

    addAt: function (child, index)
    {
        if (index === undefined) { index = 0; }

        if (this.list.length === 0)
        {
            return this.add(child);
        }

        if (index >= 0 && index <= this.list.length)
        {
            if (child.parent)
            {
                child.parent.children.remove(child);
            }

            child.parent = this;

            this.list.splice(index, 0, child);
        }

        return child;

    },

    addMultiple: function (children)
    {
        if (Array.isArray(children))
        {
            for (var i = 0; i < children.length; i++)
            {
                this.add(children[i]);
            }
        }

        return children;
    },

    getAt: function (index)
    {
        return this.list[index];
    },

    getIndex: function (child)
    {
        //  Return -1 if given child isn't a child of this parent
        return this.list.indexOf(child);
    },

    /**
    * Gets the first item from the set based on the property strictly equaling the value given.
    * Returns null if not found.
    *
    * @method Phaser.ArraySet#getByKey
    * @param {string} property - The property to check against the value.
    * @param {any} value - The value to check if the property strictly equals.
    * @return {any} The item that was found, or null if nothing matched.
    */
    getByKey: function (property, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i][property] === value)
            {
                return this.list[i];
            }
        }

        return null;
    },

    /**
    * Searches the Group for the first instance of a child with the `name`
    * property matching the given argument. Should more than one child have
    * the same name only the first instance is returned.
    *
    * @method Phaser.Group#getByName
    * @param {string} name - The name to search for.
    * @return {any} The first child with a matching name, or null if none were found.
    */
    getByName: function (name)
    {
        return this.getByKey('name', name);
    },

    /**
    * Returns a random child from the group.
    *
    * @method Phaser.Group#getRandom
    * @param {integer} [startIndex=0] - Offset from the front of the group (lowest child).
    * @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.
    * @return {any} A random child of this Group.
    */
    getRandom: function (startIndex, length)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (length === undefined) { length = this.list.length; }

        if (length === 0 || length > this.list.length)
        {
            return null;
        }

        var randomIndex = startIndex + Math.floor(Math.random() * length);

        return this.list[randomIndex];
    },

    getFirst: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (child[property] === value)
            {
                return child;
            }
        }

        return null;
    },

    /**
    * Returns all children in this Group.
    *
    * You can optionally specify a matching criteria using the `property` and `value` arguments.
    *
    * For example: `getAll('exists', true)` would return only children that have their exists property set.
    *
    * Optionally you can specify a start and end index. For example if this Group had 100 children,
    * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
    * the first 50 children in the Group.
    *
    * @method Phaser.Group#getAll
    * @param {string} [property] - An optional property to test against the value argument.
    * @param {any} [value] - If property is set then Child.property must strictly equal this value to be included in the results.
    * @param {integer} [startIndex=0] - The first child index to start the search from.
    * @param {integer} [endIndex] - The last child index to search up until.
    * @return {any} A random existing child of this Group.
    */
    getAll: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var output = [];

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (property)
            {
                if (child[property] === value)
                {
                    output.push(child);
                }
            }
            else
            {
                output.push(child);
            }
        }

        return output;
    },

    swap: function (child1, child2)
    {
        if (child1 === child2)
        {
            return;
        }

        var index1 = this.getIndex(child1);
        var index2 = this.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of the same parent');
        }

        this.list[index1] = child2;
        this.list[index2] = child1;
    },

    //   was setIndex
    moveTo: function (child, index)
    {
        var currentIndex = this.getIndex(child);

        if (currentIndex === -1 || index < 0 || index >= this.list.length)
        {
            throw new Error('Children.moveTo: The supplied index is out of bounds');
        }

        //  Remove
        this.list.splice(currentIndex, 1);

        //  Add in new location
        this.list.splice(index, 0, child);

        return child;
    },

    remove: function (child)
    {
        var index = this.list.indexOf(child);

        if (index !== -1)
        {
            child.parent = undefined;

            this.list.splice(index, 1);
        }
        
        return child;
    },

    removeAt: function (index)
    {
        var child = this.list[index];

        if (child)
        {
            child.parent = undefined;

            this.children.splice(index, 1);
        }

        return child;
    },

    removeBetween: function (beginIndex, endIndex)
    {
        if (beginIndex === undefined) { beginIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var range = endIndex - beginIndex;

        if (range > 0 && range <= endIndex)
        {
            var removed = this.list.splice(beginIndex, range);

            for (var i = 0; i < removed.length; i++)
            {
                removed[i].parent = undefined;
            }

            return removed;
        }
        else if (range === 0 && this.list.length === 0)
        {
            return [];
        }
        else
        {
            throw new Error('Children.removeBetween: Range Error, numeric values are outside the acceptable range');
        }
    },

    /**
    * Removes all the items.
    *
    * @method Phaser.ArraySet#removeAll
    */
    removeAll: function ()
    {
        var i = this.list.length;

        while (i--)
        {
            this.remove(this.list[i]);
        }

        return this;
    },

    //  Check to see if the given child is a child of this object, at any depth (recursively scans up the tree)
    contains: function (child)
    {
        if (!child)
        {
            return false;
        }
        else if (child.parent === this)
        {
            return true;
        }
        else
        {
            return this.contains(child.parent);
        }
    },

    /**
    * Brings the given child to the top of this group so it renders above all other children.
    *
    * @method Phaser.Group#bringToTop
    * @param {any} child - The child to bring to the top of this group.
    * @return {any} The child that was moved.
    */
    bringToTop: function (child)
    {
        if (child.parent === this && this.getIndex(child) < this.list.length)
        {
            this.remove(child);
            this.add(child);
        }

        return child;
    },

    /**
    * Sends the given child to the bottom of this group so it renders below all other children.
    *
    * @method Phaser.Group#sendToBack
    * @param {any} child - The child to send to the bottom of this group.
    * @return {any} The child that was moved.
    */
    sendToBack: function (child)
    {
        if (child.parent === this && this.getIndex(child) > 0)
        {
            this.remove(child);
            this.addAt(child, 0);
        }

        return child;
    },

    /**
    * Moves the given child up one place in this group unless it's already at the top.
    *
    * @method Phaser.Group#moveUp
    * @param {any} child - The child to move up in the group.
    * @return {any} The child that was moved.
    */
    moveUp: function (child)
    {
        var a = this.getIndex(child);

        if (a !== -1 && a < this.list.length - 1)
        {
            var b = this.getAt(a + 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Moves the given child down one place in this group unless it's already at the bottom.
    *
    * @method Phaser.Group#moveDown
    * @param {any} child - The child to move down in the group.
    * @return {any} The child that was moved.
    */
    moveDown: function (child)
    {
        var a = this.getIndex(child);

        if (a > 0)
        {
            var b = this.getAt(a - 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Reverses all children in this group.
    *
    * This operation applies only to immediate children and does not propagate to subgroups.
    *
    * @method Phaser.Group#reverse
    */
    reverse: function ()
    {
        this.list.reverse();

        return this;
    },

    shuffle: function ()
    {
        for (var i = this.list.length - 1; i > 0; i--)
        {
            var j = Math.floor(Math.random() * (i + 1));
            var temp = this.list[i];
            this.list[i] = this.list[j];
            this.list[j] = temp;
        }

        return this;
    },

    /**
    * Replaces a child of this Group with the given newChild. The newChild cannot be a member of this Group.
    *
    * If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
    *
    * If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
    *
    * @method Phaser.Group#replace
    * @param {any} oldChild - The child in this group that will be replaced.
    * @param {any} newChild - The child to be inserted into this group.
    * @return {any} Returns the oldChild that was replaced within this group.
    */
    replace: function (oldChild, newChild)
    {
        var index = this.getIndex(oldChild);

        if (index !== -1)
        {
            if (newChild.parent)
            {
                newChild.parent.remove(newChild);
            }

            this.remove(oldChild);

            this.addAt(newChild, index);

            return oldChild;
        }
    },

    //  Swaps a child from another parent, with one from this parent.
    //  child1 = the child of THIS parent
    //  child2 = the child of the OTHER parent
    exchange: function (child1, child2)
    {
        if (child1 === child2 || child1.parent === child2.parent)
        {
            return;
        }

        var parentChildren = child2.parent.children;

        var index1 = this.getIndex(child1);
        var index2 = parentChildren.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of parents');
        }

        this.remove(child1);

        parentChildren.remove(child2);

        this.addAt(child2, index1);

        parentChildren.addAt(child1, index2);
    },

    /**
    * Checks for the item within this list.
    *
    * @method Phaser.ArraySet#exists
    * @param {any} item - The element to get the list index for.
    * @return {boolean} True if the item is found in the list, otherwise false.
    */
    exists: function (child)
    {
        return (this.list.indexOf(child) > -1);
    },

    /**
    * Sets the property `key` to the given value on all members of this list.
    *
    * @method Phaser.ArraySet#setAll
    * @param {any} key - The property of the item to set.
    * @param {any} value - The value to set the property to.
    */
    setAll: function (key, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i])
            {
                this.list[i][key] = value;
            }
        }
    },

    /**
    * Passes all children to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (i = 0; i < this.list.length; i++)
        {
            args[0] = this.list[i];
            callback.apply(thisArg, args);
        }
    },

    /**
    * Moves all children from this Group to the Group given.
    *
    * @method Phaser.Group#moveAll
    * @param {Phaser.Group} group - The new Group to which the children will be moved to.
    * @param {boolean} [silent=false] - If true the children will not dispatch the `onAddedToGroup` event for the new Group.
    * @return {Phaser.Group} The Group to which all the children were moved.
    */
    reparent: function (newParent)
    {
        if (newParent !== this)
        {
            for (var i = 0; i < this.list.length; i++)
            {
                var child = this.remove(this.list[i]);

                newParent.add(child);
            }
        }

        return newParent;
    }

};

Object.defineProperties(Children.prototype, {

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    length: {

        enumerable: true,

        get: function ()
        {
            return this.list.length;
        }

    },

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    first: {

        enumerable: true,

        get: function ()
        {
            this.position = 0;

            if (this.list.length > 0)
            {
                return this.list[0];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the last item and resets the cursor to the end.
    *
    * @name Phaser.ArraySet#last
    * @property {any} last
    */
    last: {

        enumerable: true,

        get: function ()
        {
            if (this.list.length > 0)
            {
                this.position = this.list.length - 1;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the next item (based on the cursor) and advances the cursor.
    *
    * @name Phaser.ArraySet#next
    * @property {any} next
    */
    next: {

        enumerable: true,

        get: function ()
        {
            if (this.position < this.list.length)
            {
                this.position++;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the previous item (based on the cursor) and retreats the cursor.
    *
    * @name Phaser.ArraySet#previous
    * @property {any} previous
    */
    previous: {

        enumerable: true,

        get: function ()
        {
            if (this.position > 0)
            {
                this.position--;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    }

});

module.exports = Children;


/***/ },
/* 193 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Color Component allows you to control the alpha, blend mode, tint and background color
* of a Game Object.
*
* @class
*/
var Color = function (gameObject)
{
    this.gameObject = gameObject;

    this.state = gameObject.state;

    this._dirty = false;

    this._alpha = 1;
    this._worldAlpha = 1;

    this._blendMode = 0;

    this._tint = { topLeft: 0xffffff, topRight: 0xffffff, bottomLeft: 0xffffff, bottomRight: 0xffffff };
    this._glTint = { topLeft: 16777215, topRight: 16777215, bottomLeft: 16777215, bottomRight: 16777215 };
    this._hasTint = false;

    //  Between 0 and 255
    this._r = 0;
    this._g = 0;
    this._b = 0;

    //  Between 0 and 1
    this._a = 1;

    //  String version of RGBA
    this._rgba = '';

    //  32-bit version of ARGB
    this._glBg = 0;

    this._hasBackground = false;
};

Color.prototype.constructor = Color;

Color.prototype = {

    setBackground: function (red, green, blue, alpha)
    {
        if (red === undefined)
        {
            this._hasBackground = false;
            this._glBg = 0;
        }
        else
        {
            this._hasBackground = true;
            this._r = red;
            this._g = (green) ? green : 0;
            this._b = (blue) ? blue : 0;
            this._a = (alpha) ? alpha : 1;
        }

        this.dirty = true;
    },

    clearTint: function ()
    {
        this.setTint(0xffffff);

        this._hasTint = false;
    },

    setTint: function (topLeft, topRight, bottomLeft, bottomRight)
    {
        if (topRight === undefined)
        {
            topRight = topLeft;
            bottomLeft = topLeft;
            bottomRight = topLeft;
        }

        this.tintTopLeft = topLeft;
        this.tintTopRight = topRight;
        this.tintBottomLeft = bottomLeft;
        this.tintBottomRight = bottomRight;

        this._hasTint = true;

        this.dirty = true;
    },

    //  Called by the Dirty Manager
    update: function ()
    {
        this._dirty = false;

        if (this._hasBackground)
        {
            this._rgba = 'rgba(' + this._r + ',' + this._g + ',' + this._b + ',' + this._a + ')';
            this._glBg = this.getColor32(this._r, this._g, this._b, this._a);
        }

        //  Tint mults?

    },

    getColor: function (value)
    {
        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
    },

    getColor32: function (r, g, b, a)
    {
        a *= 255;

        return ((a << 24) | (b << 16) | (g << 8) | r) >>> 0;
    },

    destroy: function ()
    {
        this.gameObject = null;
        this.state = null;
        this._tint = [];
    }

};

Object.defineProperties(Color.prototype, {

    dirty: {

        enumerable: true,

        get: function ()
        {
            return this._dirty;
        },

        set: function (value)
        {
            if (value)
            {
                if (!this._dirty)
                {
                    this._dirty = true;

                    this.state.sys.updates.add(this);
                }
            }
            else
            {
                this._dirty = false;
            }
        }

    },

    tintTopLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topLeft;
        },

        set: function (value)
        {
            this._tint.topLeft = value;
            this._glTint.topLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintTopRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topRight;
        },

        set: function (value)
        {
            this._tint.topRight = value;
            this._glTint.topRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomLeft;
        },

        set: function (value)
        {
            this._tint.bottomLeft = value;
            this._glTint.bottomLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomRight;
        },

        set: function (value)
        {
            this._tint.bottomRight = value;
            this._glTint.bottomRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tint: {

        enumerable: true,

        get: function ()
        {
            return this._tint;
        },

        set: function (value)
        {
            this.setTint(value, value, value, value);
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            if (value !== this._alpha)
            {
                this._alpha = value;
                this.dirty = true;
            }
        }

    },

    blendMode: {

        enumerable: true,

        get: function ()
        {
            return this._blendMode;
        },

        set: function (value)
        {
            if (value !== this._blendMode && value >= 0 && value <= 16)
            {
                this._blendMode = value;
                this.dirty = true;
            }
        }

    },

    worldAlpha: {

        enumerable: true,

        get: function ()
        {
            if (this.gameObject.parent)
            {
                this._worldAlpha = this._alpha * this.gameObject.parent.color.worldAlpha;
            }

            return this._worldAlpha;
        },

        set: function (value)
        {
            this._worldAlpha = this._alpha * value;
        }

    },

    backgroundAlpha: {

        enumerable: true,

        get: function ()
        {
            return this._a;
        },

        set: function (value)
        {
            if (value !== this._a)
            {
                this._a = value;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    red: {

        enumerable: true,

        get: function ()
        {
            return this._r;
        },

        set: function (value)
        {
            if (value !== this._r)
            {
                this._r = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    green: {

        enumerable: true,

        get: function ()
        {
            return this._g;
        },

        set: function (value)
        {
            if (value !== this._g)
            {
                this._g = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    blue: {

        enumerable: true,

        get: function ()
        {
            return this._b;
        },

        set: function (value)
        {
            if (value !== this._b)
            {
                this._b = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    }

});

module.exports = Color;


/***/ },
/* 194 */
/***/ function(module, exports) {

var GetBounds = {

    getBounds: function (output)
    {
        if (output === undefined) { output = { x: 0, y: 0, width: 0, height: 0 }; }

        var x = this.x;
        var y = this.y;

        var w = this.displayWidth;
        var h = this.displayHeight;

        var r = this.rotation;

        var wct = w * Math.cos(r);
        var hct = h * Math.cos(r);

        var wst = w * Math.sin(r);
        var hst = h * Math.sin(r);

        var xMin = x;
        var xMax = x;
        var yMin = y;
        var yMax = y;

        if (r > 0)
        {
            if (r < 1.5707963267948966)
            {
                // 0 < theta < 90
                yMax = y + hct + wst;
                xMin = x - hst;
                xMax = x + wct;
            }
            else
            {
                // 90 <= theta <= 180
                yMin = y + hct;
                yMax = y + wst;
                xMin = x - hst + wct;
            }
        }
        else if (r > -1.5707963267948966)
        {
            // -90 < theta <= 0
            yMin = y + wst;
            yMax = y + hct;
            xMax = x + wct - hst;
        }
        else
        {
            // -180 <= theta <= -90
            yMin = y + wst + hct;
            xMin = x + wct;
            xMax = x - hst;
        }

        output.x = xMin;
        output.y = yMin;
        output.width = xMax - xMin;
        output.height = yMax - yMin;

        return output;
    }
};

module.exports = GetBounds;


/***/ },
/* 195 */
/***/ function(module, exports) {

//  Origin Component
//  Values are given in pixels, not percent

var Origin = {

    originX: 0,
    originY: 0,

    setOrigin: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.originX = x;
        this.originY = y;

        return this;
    },

    setOriginToCenter: function ()
    {
        this.originX = this.frame.centerX;
        this.originY = this.frame.centerY;
    }

};

module.exports = Origin;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(41);

//  ScaleMode Component

var ScaleMode = {

    _scaleMode: ScaleModes.DEFAULT,

    scaleMode: {

        get: function ()
        {
            return this._scaleMode;
        },

        set: function (value)
        {
            if (value === ScaleModes.LINEAR || value === ScaleModes.NEAREST)
            {
                this._scaleMode = value;
            }
        }

    }

};

module.exports = ScaleMode;


/***/ },
/* 197 */
/***/ function(module, exports) {

var Size = {

    width: 0,
    height: 0,

    displayWidth: {

        get: function ()
        {
            return this.scaleX * this.frame.realWidth;
        },

        set: function (value)
        {
            this.scaleX = value / this.frame.realWidth;
        }

    },

    displayHeight: {

        get: function ()
        {
            return this.scaleY * this.frame.realHeight;
        },

        set: function (value)
        {
            this.scaleY = value / this.frame.realHeight;
        }

    },

    setSizeToFrame: function (frame)
    {
        if (frame === undefined) { frame = this.frame; }

        this.width = frame.realWidth;
        this.height = frame.realHeight;

        return this;
    },

    setSize: function (width, height)
    {
        this.width = width;
        this.height = height;

        return this;
    }

};

module.exports = Size;


/***/ },
/* 198 */
/***/ function(module, exports) {

//  Texture Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 8; // 1000

var Texture = {

    texture: null,
    frame: null,

    setTexture: function (key, frame)
    {
        this.texture = this.state.sys.textures.get(key);

        this.frame = this.texture.get(frame);

        if (!this.frame.cutWidth || !this.frame.cutHeight)
        {
            this.renderFlags &= ~_FLAG;
        }
        else
        {
            this.renderFlags |= _FLAG;

            if (this.hasOwnProperty('originX'))
            {
                //  Default origin to the center
                var w = Math.floor(this.frame.realWidth / 2);
                var h = Math.floor(this.frame.realHeight / 2);

                this.setOrigin(w, h);
            }
        }

        return this;
    }

};

module.exports = Texture;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(7);
var WrapAngle = __webpack_require__(144);
var WrapAngleDegrees = __webpack_require__(145);

//  global bitmask flag for GameObject.renderMask (used by Scale)
var _FLAG = 4; // 0100

//  Transform Component

var Transform = {

    //  "private" properties
    _scaleX: 1,
    _scaleY: 1,
    _rotation: 0,

    x: 0,
    y: 0,
    z: 0,

    scaleX: {

        get: function ()
        {
            return this._scaleX;
        },

        set: function (value)
        {
            this._scaleX = value;

            if (this._scaleX === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    scaleY: {

        get: function ()
        {
            return this._scaleY;
        },

        set: function (value)
        {
            this._scaleY = value;

            if (this._scaleY === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    angle: {

        get: function ()
        {
            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            //  value is in degrees
            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
        }
    },

    rotation: {

        get: function ()
        {
            return this._rotation;
        },

        set: function (value)
        {
            //  value is in radians
            this._rotation = WrapAngle(value);
        }
    },

    setPosition: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setRotation: function (radians)
    {
        if (radians === undefined) { radians = 0; }

        this.rotation = radians;

        return this;
    },

    setScale: function (x, y)
    {
        if (x === undefined) { x = 1; }
        if (y === undefined) { y = x; }

        this.scaleX = (x ? x : 0.0);
        this.scaleY = (y ? y : 0.0);

        return this;
    }

};

module.exports = Transform;


/***/ },
/* 200 */
/***/ function(module, exports) {


//  Visible Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 1; // 0001

var Visible = {

    _visible: true,

    visible: {

        get: function ()
        {
            return this._visible;
        },

        set: function (value)
        {
            if (value)
            {
                this._visible = true;
                this.renderFlags |= _FLAG;
            }
            else
            {
                this._visible = false;
                this.renderFlags &= ~_FLAG;
            }
        }

    }

};

module.exports = Visible;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(19);
var Browser = __webpack_require__(27);

var Audio = {

    /**
    * @property {boolean} audioData - Are Audio tags available?
    * @default
    */
    audioData: false,

    /**
    * @property {boolean} webAudio - Is the WebAudio API available?
    * @default
    */
    webAudio: false,

    /**
    * @property {boolean} ogg - Can this device play ogg files?
    * @default
    */
    ogg: false,

    /**
    * @property {boolean} opus - Can this device play opus files?
    * @default
    */
    opus: false,

    /**
    * @property {boolean} mp3 - Can this device play mp3 files?
    * @default
    */
    mp3: false,

    /**
    * @property {boolean} wav - Can this device play wav files?
    * @default
    */
    wav: false,

    /**
    * Can this device play m4a files?
    * @property {boolean} m4a - True if this device can play m4a files.
    * @default
    */
    m4a: false,

    /**
    * @property {boolean} webm - Can this device play webm files?
    * @default
    */
    webm: false,

    /**
    * @property {boolean} dolby - Can this device play EC-3 Dolby Digital Plus files?
    * @default
    */
    dolby: false

};

function init ()
{
    Audio.audioData = !!(window['Audio']);
    Audio.webAudio = !!(window['AudioContext'] || window['webkitAudioContext']);

    var audioElement = document.createElement('audio');

    var result = !!audioElement.canPlayType;

    try
    {
        if (result)
        {
            if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.ogg = true;
            }

            if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || audioElement.canPlayType('audio/opus;').replace(/^no$/, ''))
            {
                Audio.opus = true;
            }

            if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, ''))
            {
                Audio.mp3 = true;
            }

            //  Mimetypes accepted:
            //  developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
            //  bit.ly/iphoneoscodecs
            if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''))
            {
                Audio.wav = true;
            }

            if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, ''))
            {
                Audio.m4a = true;
            }

            if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.webm = true;
            }

            if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== '')
            {
                if (Browser.edge)
                {
                    Audio.dolby = true;
                }
                else if (Browser.safari && Browser.safariVersion >= 9)
                {
                    if ((/Mac OS X (\d+)_(\d+)/).test(navigator.userAgent))
                    {
                        var major = parseInt(RegExp.$1, 10);
                        var minor = parseInt(RegExp.$2, 10);

                        if ((major === 10 && minor >= 11) || major > 10)
                        {
                            Audio.dolby = true;
                        }
                    }
                }
            }
        }
    }
    catch (e)
    {
        //  Nothing to do here
    }

    return Audio;
}

module.exports = init();


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(19);
var Browser = __webpack_require__(27);

var Fullscreen = {

    /**
    * @property {boolean} available - Does the browser support the Full Screen API?
    * @default
    */
    available: false,

    /**
    * @property {string} request - If the browser supports the Full Screen API this holds the call you need to use to activate it.
    * @default
    */
    request: '',

    /**
    * @property {string} cancel - If the browser supports the Full Screen API this holds the call you need to use to cancel it.
    * @default
    */
    cancel: '',

    /**
    * @property {boolean} keyboard - Does the browser support access to the Keyboard during Full Screen mode?
    * @default
    */
    keyboard: false

};

/**
* Checks for support of the Full Screen API.
*/
function init ()
{
    var fs = [
        'requestFullscreen',
        'requestFullScreen',
        'webkitRequestFullscreen',
        'webkitRequestFullScreen',
        'msRequestFullscreen',
        'msRequestFullScreen',
        'mozRequestFullScreen',
        'mozRequestFullscreen'
    ];

    var element = document.createElement('div');

    for (var i = 0; i < fs.length; i++)
    {
        if (element[fs[i]])
        {
            Fullscreen.available = true;
            Fullscreen.request = fs[i];
            break;
        }
    }

    var cfs = [
        'cancelFullScreen',
        'exitFullscreen',
        'webkitCancelFullScreen',
        'webkitExitFullscreen',
        'msCancelFullScreen',
        'msExitFullscreen',
        'mozCancelFullScreen',
        'mozExitFullscreen'
    ];

    if (Fullscreen.available)
    {
        for (var i = 0; i < cfs.length; i++)
        {
            if (document[cfs[i]])
            {
                Fullscreen.cancel = cfs[i];
                break;
            }
        }
    }

    //  Keyboard Input?
    if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT'])
    {
        Fullscreen.keyboard = true;
    }

    return Fullscreen;
}

module.exports = init();


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(19);
var Browser = __webpack_require__(27);

var Input = {

    /**
    * @property {boolean} touch - Is touch available?
    * @default
    */
    touch: false,

    /**
    * @property {boolean} mspointer - Is mspointer available?
    * @default
    */
    mspointer: false,

    /**
    * @property {?string} wheelType - The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'
    * @default
    * @protected
    */
    wheelEvent: null
    
};

function init ()
{
    if ('ontouchstart' in document.documentElement || (window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1))
    {
        Input.touch = true;
    }

    if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled)
    {
        Input.mspointer = true;
    }

    if (!OS.cocoonJS)
    {
        // See https://developer.mozilla.org/en-US/docs/Web/Events/wheel
        if ('onwheel' in window || (Browser.ie && 'WheelEvent' in window))
        {
            // DOM3 Wheel Event: FF 17+, IE 9+, Chrome 31+, Safari 7+
            Input.wheelEvent = 'wheel';
        }
        else if ('onmousewheel' in window)
        {
            // Non-FF legacy: IE 6-9, Chrome 1-31, Safari 5-7.
            Input.wheelEvent = 'mousewheel';
        }
        else if (Browser.firefox && 'MouseScrollEvent' in window)
        {
            // FF prior to 17. This should probably be scrubbed.
            Input.wheelEvent = 'DOMMouseScroll';
        }
    }

    return Input;
}

module.exports = init();


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(19);
var Browser = __webpack_require__(27);

var Video = {

    /**
    * @property {boolean} oggVideo - Can this device play ogg video files?
    * @default
    */
    oggVideo: false,

    /**
    * @property {boolean} h264Video - Can this device play h264 mp4 video files?
    * @default
    */
    h264Video: false,

    /**
    * @property {boolean} mp4Video - Can this device play h264 mp4 video files?
    * @default
    */
    mp4Video: false,

    /**
    * @property {boolean} webmVideo - Can this device play webm video files?
    * @default
    */
    webmVideo: false,

    /**
    * @property {boolean} vp9Video - Can this device play vp9 video files?
    * @default
    */
    vp9Video: false,

    /**
    * @property {boolean} hlsVideo - Can this device play hls video files?
    * @default
    */
    hlsVideo: false

};

function init ()
{
    var videoElement = document.createElement('video');
    var result = !!videoElement.canPlayType;

    try
    {
        if (result)
        {
            if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ''))
            {
                Video.oggVideo = true;
            }

            if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
                Video.h264Video = true;
                Video.mp4Video = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ''))
            {
                Video.webmVideo = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, ''))
            {
                Video.vp9Video = true;
            }

            if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                Video.hlsVideo = true;
            }
        }
    }
    catch (e)
    {
        //  Nothing to do
    }

    return Video;
}

module.exports = init();


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games can share it,
//  without having to re-poll the device all over again

var OS = __webpack_require__(19);
var Browser = __webpack_require__(27);
var Features = __webpack_require__(82);
var Input = __webpack_require__(203);
var Audio = __webpack_require__(201);
var Video = __webpack_require__(204);
var Fullscreen = __webpack_require__(202);
var CanvasFeatures = __webpack_require__(81);

module.exports = {

    OS: OS,
    Browser: Browser,
    Features: Features,
    Input: Input,
    Audio: Audio,
    Video: Video,
    Fullscreen: Fullscreen,
    CanvasFeatures: CanvasFeatures

};


/***/ },
/* 206 */
/***/ function(module, exports) {

var AddEventListener = function (target, event, listener, useCapture)
{
    if (useCapture === undefined) { useCapture = false; }

    target.addEventListener(event, listener, useCapture);
};

module.exports = AddEventListener;


/***/ },
/* 207 */
/***/ function(module, exports) {

var RemoveEventListener = function (target, event, listener)
{
    target.removeEventListener(event, listener);
};

module.exports = RemoveEventListener;


/***/ },
/* 208 */
/***/ function(module, exports) {

var RemoveFromDOM = function (element)
{
    if (element.parentNode)
    {
        element.parentNode.removeChild(element);
    }
};

module.exports = RemoveFromDOM;


/***/ },
/* 209 */
/***/ function(module, exports) {

/**
* Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.
*
* @method Phaser.Canvas.TouchAction
* @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.
* @param {string} [value] - The touch action to set. Defaults to 'none'.
* @return {HTMLCanvasElement} The source canvas.
*/
var TouchAction = function (canvas, value)
{
    if (value === undefined) { value = 'none'; }

    canvas.style['msTouchAction'] = value;
    canvas.style['ms-touch-action'] = value;
    canvas.style['touch-action'] = value;

    return canvas;
};

module.exports = TouchAction;


/***/ },
/* 210 */
/***/ function(module, exports) {

/**
* Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.
*
* @method Phaser.Canvas.setUserSelect
* @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.
* @param {string} [value] - The touch action to set. Defaults to 'none'.
* @return {HTMLCanvasElement} The source canvas.
*/
var UserSelect = function (canvas, value)
{
    if (value === undefined) { value = 'none'; }

    var vendors = [
        '-webkit-',
        '-khtml-',
        '-moz-',
        '-ms-',
        ''
    ];

    vendors.forEach(function (vendor)
    {
        canvas.style[vendor + 'user-select'] = value;
    });

    canvas.style['-webkit-touch-callout'] = value;
    canvas.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)';

    return canvas;
};

module.exports = UserSelect;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(87);
var EventListener = __webpack_require__(212);

var EventBinding = function (dispatcher, type)
{
    this.dispatcher = dispatcher;
    this.type = type;
    this.state = CONST.DISPATCHER_IDLE;
    this.active = [];
};

EventBinding.prototype.constructor = EventBinding;

EventBinding.prototype = {

    total: function ()
    {
        var total = 0;

        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state !== CONST.LISTENER_REMOVING)
            {
                total++;
            }
        }

        return total;
    },

    get: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return this.active[i];
            }
        }
    },

    getIndex: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return i;
            }
        }

        return null;
    },

    has: function (callback)
    {
        return (this.get(callback));
    },

    add: function (callback, priority, once)
    {
        var listener = this.get(callback);

        if (!listener)
        {
            //  The listener doesn't exist, so create one
            listener = EventListener(this.type, callback, priority, once);
        }
        else
        {
            //  Listener already exists, abort
            return;
        }

        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we don't need a pending state
            listener.state = CONST.LISTENER_ACTIVE;

            this.active.push(listener);

            this.active.sort(this.sortHandler);
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  Add it to the list, but keep the state as pending.
            //  The call to 'tidy' will sort it out at the end of the dispatch.
            this.active.push(listener);
        }
    },

    sortHandler: function (listenerA, listenerB)
    {
        if (listenerB.priority < listenerA.priority)
        {
            return -1;
        }
        else if (listenerB.priority > listenerA.priority)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    },

    remove: function (callback)
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we can remove right away
            var i = this.getIndex(callback);

            if (i !== null)
            {
                this.active.splice(i, 1);
            }
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  The Dispatcher is working, so we flag the listener for removal at the end
            var listener = this.get(callback);

            if (listener)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }
        }
    },

    dispatch: function (event)
    {
        if (this.state !== CONST.DISPATCHER_IDLE)
        {
            throw new Error('Error: Failed to execute \'EventDispatcher.dispatch\' on \'' + this.type + '\': The event is already being dispatched.');
        }
        else if (this.active.length === 0)
        {
            //  This was a valid dispatch call, we just had nothing to do ...
            return;
        }

        this.state = CONST.DISPATCHER_DISPATCHING;

        var listener;

        for (var i = 0; i < this.active.length; i++)
        {
            listener = this.active[i];

            if (listener.state !== CONST.LISTENER_ACTIVE)
            {
                continue;
            }

            listener.callback.call(this.dispatcher, event);

            //  Has the callback changed the state of this binding?
            if (this.state !== CONST.DISPATCHER_DISPATCHING)
            {
                //  Yup! Let's break out
                break;
            }

            //  Was it a 'once' listener?
            if (listener.once)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }

            //  Has the event been halted by the callback?
            if (!event._propagate)
            {
                //  Break out, a listener has called Event.stopPropagation
                break;
            }
        }

        //  Dispatch over, or aborted
        if (this.state === CONST.DISPATCHER_REMOVING)
        {
            this.removeAll();

            //  All done, tidy the list in case there were any pending events added
            this.tidy();
        }
        else if (this.state === CONST.DISPATCHER_DESTROYED)
        {
            this.dispatcher.delete(this.type);
        }
        else
        {
            //  All done, just purge the list
            this.tidy();

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    //  Removes all listeners
    //  If this is currently being dispatched then don't remove 'pending' listeners
    //  (i.e. ones that were added during the dispatch), only active ones
    removeAll: function ()
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            this.active.length = 0;
        }
        else
        {
            for (var i = this.active.length - 1; i >= 0; i--)
            {
                if (this.active[i].state !== CONST.LISTENER_PENDING)
                {
                    this.active.pop();
                }
            }

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    tidy: function ()
    {
        //  Nothing to do ...
        if (this.active.length === 0)
        {
            return;
        }

        var added = 0;

        var i = this.active.length - 1;

        do
        {
            if (this.active[i].state === CONST.LISTENER_REMOVING)
            {
                this.active.splice(i, 1);
            }
            else if (this.active[i].state === CONST.LISTENER_PENDING)
            {
                this.active[i].state === CONST.LISTENER_ACTIVE;
                added++;
            }

            i--;
        }
        while (i >= 0);

        if (added > 0)
        {
            this.active.sort(this.sortHandler);
        }
    },

    destroy: function ()
    {
        this.active.length = 0;
        this.dispatcher = undefined;
        this.type = '';
        this.state = CONST.DISPATCHER_DESTROYED;
    }

};

module.exports = EventBinding;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(87);

var EventListener = function (type, callback, priority, once)
{
    return {
        type: type,
        callback: callback,
        priority: priority,
        once: once,
        state: CONST.LISTENER_PENDING
    };
};

module.exports = EventListener;


/***/ },
/* 213 */
/***/ function(module, exports) {

function getValue (node, attribute)
{
    return parseInt(node.getAttribute(attribute), 10);
}

var ParseXMLBitmapFont = function (xml, xSpacing, ySpacing, frame)
{
    if (xSpacing === undefined) { xSpacing = 0; }
    if (ySpacing === undefined) { ySpacing = 0; }

    var data = {};
    var info = xml.getElementsByTagName('info')[0];
    var common = xml.getElementsByTagName('common')[0];

    data.font = info.getAttribute('face');
    data.size = getValue(info, 'size');
    data.lineHeight = getValue(common, 'lineHeight') + ySpacing;
    data.chars = {};

    var letters = xml.getElementsByTagName('char');

    var x = (frame) ? frame.x : 0;
    var y = (frame) ? frame.y : 0;

    for (var i = 0; i < letters.length; i++)
    {
        var node = letters[i];

        var charCode = getValue(node, 'id');
        var gw = getValue(node, 'width');
        var gh = getValue(node, 'height');

        data.chars[charCode] =
        {
            x: x + getValue(node, 'x'),
            y: y + getValue(node, 'y'),
            width: gw,
            height: gh,
            centerX: Math.floor(gw / 2),
            centerY: Math.floor(gh / 2),
            xOffset: getValue(node, 'xoffset'),
            yOffset: getValue(node, 'yoffset'),
            xAdvance: getValue(node, 'xadvance') + xSpacing,
            kerning: {}
        };
    }

    var kernings = xml.getElementsByTagName('kerning');

    for (i = 0; i < kernings.length; i++)
    {
        var kern = kernings[i];

        var first = getValue(kern, 'first');
        var second = getValue(kern, 'second');
        var amount = getValue(kern, 'amount');

        data.chars[second].kerning[first] = amount;
    }

    return data;
};

module.exports = ParseXMLBitmapFont;


/***/ },
/* 214 */
/***/ function(module, exports) {

var DynamicBitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    var text = src.text;
    var textLength = text.length;

    if (this.renderMask !== this.renderFlags || textLength === 0)
    {
        return;
    }
    
    var textureFrame = src.frame;

    var displayCallback = src.displayCallback;

    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;

    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    var ctx = renderer.currentContext;
    var image = src.frame.source.image;

    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;

    var rotation = 0;
    var scale = (src.fontSize / src.fontData.size);

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(src.x, src.y);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);

    for (var index = 0; index < textLength; ++index)
    {
        //  Reset the scale (in case the callback changed it)
        scale = (src.fontSize / src.fontData.size);
        rotation = 0;

        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = indexCount + glyph.xOffset + xAdvance;
        y = glyph.yOffset + yAdvance;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (displayCallback)
        {
            var output = displayCallback({ index: index, charCode: charCode, x: x, y: y, scale: scale, rotation: 0 });

            x = output.x;
            y = output.y;
            scale = output.scale;
            rotation = output.rotation;
        }

        x *= scale;
        y *= scale;

        x -= cameraScrollX;
        y -= cameraScrollY;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.scale(scale, scale);

        // ctx.fillStyle = 'rgba(0,255,0,0.2)';
        // ctx.fillRect(0, 0, glyphW, glyphH);

        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);

        ctx.restore();
        
        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    ctx.restore();
};

module.exports = DynamicBitmapTextCanvasRenderer;


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

var BitmapText = __webpack_require__(89);
var FactoryContainer = __webpack_require__(6);

var DynamicBitmapTextFactory = {

    KEY: 'dynamicBitmapText',

    add: function (x, y, font, text, size, align)
    {
        return this.state.children.add(new BitmapText(this.state, x, y, font, text, size, align));
    },

    make: function (x, y, font, text, size, align)
    {
        return new BitmapText(this.state, x, y, font, text, size, align);
    }

};

module.exports = FactoryContainer.register(DynamicBitmapTextFactory);


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(214),
    renderWebGL: __webpack_require__(217)

};


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

var TransformMatrix = __webpack_require__(26);
var tempMatrix = new TransformMatrix();
var tempMatrixChar = new TransformMatrix();

var DynamicBitmapTextWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var displayCallback = src.displayCallback;
    var textureFrame = src.frame;
    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;
    var text = src.text;
    var textLength = text.length;
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;
    var blitterBatch = renderer.blitterBatch;
    var alpha = src.alpha;
    var vertexDataBuffer = blitterBatch.vertexDataBuffer;
    var vertexBuffer = vertexDataBuffer.floatView;
    var vertexOffset = 0;
    var srcX = src.x; 
    var srcY = src.y;
    var textureData = src.texture.source[textureFrame.sourceIndex];
    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;
    var textureWidth = textureData.width;
    var textureHeight = textureData.height;
    var texture = textureData.glTexture;
    var xAdvance = 0;
    var yAdvance = 0;
    var indexCount = 0;
    var charCode = 0;
    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;
    var x = 0;
    var y = 0;
    var xw = 0;
    var yh = 0;
    var tx = 0;
    var ty = 0;
    var txw = 0;
    var tyh = 0;
    var umin = 0;
    var umax = 0;
    var vmin = 0;
    var vmax = 0;
    var lastGlyph = null;
    var lastCharCode = 0;
    var tempMatrixMatrix = tempMatrix.matrix;
    var cameraMatrix = camera.matrix.matrix;
    var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var scale = (src.fontSize / src.fontData.size);
    var uta, utb, utc, utd, ute, utf;
    var tempMatrixCharMatrix = tempMatrixChar.matrix;

    tempMatrix.applyITRS(
        src.x - cameraScrollX, src.y - cameraScrollY, 
        -src.rotation, 
        src.scaleX, src.scaleY
    );

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);
        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];
        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;
        glyphW = glyph.width;
        glyphH = glyph.height;
        x = (indexCount + glyph.xOffset + xAdvance) * scale;
        y = (glyph.yOffset + yAdvance) * scale;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (displayCallback)
        {
            var output = displayCallback({ index: index, charCode: charCode, x: x, y: y, scale: scale, rotation: 0 });

            x = output.x;
            y = output.y;
            scale = output.scale;
            rotation = output.rotation;
        }

        tempMatrixChar.applyITRS(
            x, y,
            -rotation,
            scale, scale
        );

        uta = tempMatrixCharMatrix[0];
        utb = tempMatrixCharMatrix[1];
        utc = tempMatrixCharMatrix[2];
        utd = tempMatrixCharMatrix[3];
        ute = tempMatrixCharMatrix[4];
        utf = tempMatrixCharMatrix[5];

        sra = uta * mva + utb * mvc;
        srb = uta * mvb + utb * mvd;
        src = utc * mva + utd * mvc;
        srd = utc * mvb + utd * mvd;
        sre = ute * mva + utf * mvc + mve;
        srf = ute * mvb + utf * mvd + mvf;

        xw = glyphW;
        yh = glyphH;
        tx0 = sre;
        ty0 = srf;
        tx1 = yh * src + sre;
        ty1 = yh * srd + srf;
        tx2 = xw * sra + yh * src + sre;
        ty2 = xw * srb + yh * srd + srf;
        tx3 = xw * sra + sre;
        ty3 = xw * srb + srf;
        umin = glyphX / textureWidth;
        umax = (glyphX + glyphW) / textureWidth;
        vmin = glyphY / textureHeight;
        vmax = (glyphY + glyphH) / textureHeight;

        if (blitterBatch.elementCount >= blitterBatch.maxParticles)
        {
            blitterBatch.flush();
        }

        renderer.setBatch(blitterBatch, texture);
        vertexOffset = vertexDataBuffer.allocate(20);
        blitterBatch.elementCount += 6;

        vertexBuffer[vertexOffset++] = tx0;
        vertexBuffer[vertexOffset++] = ty0;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx1;
        vertexBuffer[vertexOffset++] = ty1;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx2;
        vertexBuffer[vertexOffset++] = ty2;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx3;
        vertexBuffer[vertexOffset++] = ty3;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }
};

module.exports = DynamicBitmapTextWebGLRenderer;


/***/ },
/* 218 */
/***/ function(module, exports) {

var BitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    var text = src.text;
    var textLength = text.length;

    if (this.renderMask !== this.renderFlags || textLength === 0)
    {
        return;
    }
    
    var textureFrame = src.frame;

    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;

    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    var ctx = renderer.currentContext;
    var image = src.frame.source.image;

    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;

    var rotation = 0;
    var scale = (src.fontSize / src.fontData.size);

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(src.x - cameraScrollX, src.y - cameraScrollY);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);

    for (var index = 0; index < textLength; ++index)
    {

        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = indexCount + glyph.xOffset + xAdvance;
        y = glyph.yOffset + yAdvance;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        x *= scale;
        y *= scale;

        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
        ctx.restore();
        
        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    ctx.restore();
};

module.exports = BitmapTextCanvasRenderer;


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

var BitmapText = __webpack_require__(90);
var FactoryContainer = __webpack_require__(6);

var BitmapTextFactory = {

    KEY: 'bitmapText',

    add: function (x, y, font, text, size, align)
    {
        return this.state.children.add(new BitmapText(this.state, x, y, font, text, size, align));
    },

    make: function (x, y, font, text, size, align)
    {
        return new BitmapText(this.state, x, y, font, text, size, align);
    }

};

module.exports = FactoryContainer.register(BitmapTextFactory);


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(218),
    renderWebGL: __webpack_require__(221)

};


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

var TransformMatrix = __webpack_require__(26);
var tempMatrix = new TransformMatrix();

var BitmapTextWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var textureFrame = src.frame;
    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;
    var text = src.text;
    var textLength = text.length;
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;
    var blitterBatch = renderer.blitterBatch;
    var alpha = src.alpha;
    var vertexDataBuffer = blitterBatch.vertexDataBuffer;
    var vertexBuffer = vertexDataBuffer.floatView;
    var vertexOffset = 0;
    var srcX = src.x; 
    var srcY = src.y;
    var textureData = src.texture.source[textureFrame.sourceIndex];
    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;
    var textureWidth = textureData.width;
    var textureHeight = textureData.height;
    var texture = textureData.glTexture;
    var xAdvance = 0;
    var yAdvance = 0;
    var indexCount = 0;
    var charCode = 0;
    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;
    var x = 0;
    var y = 0;
    var xw = 0;
    var yh = 0;
    var tx = 0;
    var ty = 0;
    var txw = 0;
    var tyh = 0;
    var umin = 0;
    var umax = 0;
    var vmin = 0;
    var vmax = 0;
    var lastGlyph = null;
    var lastCharCode = 0;
    var tempMatrixMatrix = tempMatrix.matrix;
    var cameraMatrix = camera.matrix.matrix;
    var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var scale = (src.fontSize / src.fontData.size);

    tempMatrix.applyITRS(
        src.x - cameraScrollX, src.y - cameraScrollY, 
        -src.rotation, 
        src.scaleX, src.scaleY
    );

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);
        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];
        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;
        glyphW = glyph.width;
        glyphH = glyph.height;
        x = (indexCount + glyph.xOffset + xAdvance) * scale;
        y = (glyph.yOffset + yAdvance) * scale;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        xw = x + glyphW * scale;
        yh = y + glyphH * scale;
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;
        umin = glyphX / textureWidth;
        umax = (glyphX + glyphW) / textureWidth;
        vmin = glyphY / textureHeight;
        vmax = (glyphY + glyphH) / textureHeight;

        if (blitterBatch.elementCount >= blitterBatch.maxParticles)
        {
            blitterBatch.flush();
        }

        renderer.setBatch(blitterBatch, texture);
        vertexOffset = vertexDataBuffer.allocate(20);
        blitterBatch.elementCount += 6;

        vertexBuffer[vertexOffset++] = tx0;
        vertexBuffer[vertexOffset++] = ty0;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx1;
        vertexBuffer[vertexOffset++] = ty1;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx2;
        vertexBuffer[vertexOffset++] = ty2;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx3;
        vertexBuffer[vertexOffset++] = ty3;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }
};

module.exports = BitmapTextWebGLRenderer;


/***/ },
/* 222 */
/***/ function(module, exports) {


var BlitterCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var list = src.getRenderList();

    renderer.setBlendMode(src.blendMode);

    var ca = renderer.currentAlpha;

    //  Render bobs
    for (var i = 0; i < list.length; i++)
    {
        var bob = list[i];

        if (ca !== bob.alpha)
        {
            ca = renderer.setAlpha(bob.alpha);
        }

        renderer.blitImage(bob.x, bob.y, bob.frame, camera);
    }
};

module.exports = BlitterCanvasRenderer;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {


var Blitter = __webpack_require__(91);
var FactoryContainer = __webpack_require__(6);

var BlitterFactory = {

    KEY: 'blitter',

    add: function (x, y, key, frame, parent)
    {
        if (parent === undefined) { parent = this.state; }

        return parent.children.add(new Blitter(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        return new Blitter(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(BlitterFactory);


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(222),
    renderWebGL: __webpack_require__(225)

};


/***/ },
/* 225 */
/***/ function(module, exports) {

var BlitterWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var list = src.getRenderList();
    var blitterBatch = renderer.blitterBatch;
    var cameraMatrix = camera.matrix.matrix;
    var a = cameraMatrix[0];
    var b = cameraMatrix[1];
    var c = cameraMatrix[2];
    var d = cameraMatrix[3];
    var e = cameraMatrix[4];
    var f = cameraMatrix[5];
    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;

    //  Render bobs

    for (var i = 0, l = list.length; i < l; i++)
    {
        var bob = list[i];
        var frame = bob.frame;
        var alpha = bob.alpha;
        var vertexDataBuffer = blitterBatch.vertexDataBuffer;
        var vertexBuffer = vertexDataBuffer.floatView;
        var vertexOffset = 0;
        var uvs = frame.uvs;
        var width = frame.width;
        var height = frame.height;
        var x = bob.x + frame.x - cameraScrollX;
        var y = bob.y + frame.y - cameraScrollY;
        var xw = x + width;
        var yh = y + height;
        var tx = x * a + y * c + e;
        var ty = x * b + y * d + f;
        var txw = xw * a + yh * c + e;
        var tyh = xw * b + yh * d + f;

        if (blitterBatch.elementCount >= blitterBatch.maxParticles)
        {
            blitterBatch.flush();
        }

        renderer.setBatch(blitterBatch, frame.texture.source[frame.sourceIndex].glTexture);
        vertexOffset = vertexDataBuffer.allocate(20);
        blitterBatch.elementCount += 6;
        x += frame.x;
        y += frame.y;

        vertexBuffer[vertexOffset++] = tx;
        vertexBuffer[vertexOffset++] = ty;
        vertexBuffer[vertexOffset++] = uvs.x0;
        vertexBuffer[vertexOffset++] = uvs.y0;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = tx;
        vertexBuffer[vertexOffset++] = tyh;
        vertexBuffer[vertexOffset++] = uvs.x1;
        vertexBuffer[vertexOffset++] = uvs.y1;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = txw;
        vertexBuffer[vertexOffset++] = tyh;
        vertexBuffer[vertexOffset++] = uvs.x2;
        vertexBuffer[vertexOffset++] = uvs.y2;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = txw;
        vertexBuffer[vertexOffset++] = ty;
        vertexBuffer[vertexOffset++] = uvs.x3;
        vertexBuffer[vertexOffset++] = uvs.y3;
        vertexBuffer[vertexOffset++] = alpha;
    }
};

module.exports = BlitterWebGLRenderer;


/***/ },
/* 226 */
/***/ function(module, exports) {

var Bob = function (blitter, x, y, frame, visible)
{
    this.parent = blitter;

    this.x = x;
    this.y = y;
    this.frame = frame;
    this.data = {};

    this._visible = visible;
    this._alpha = 1;
};

Bob.prototype.constructor = Bob;

Bob.prototype = {

    reset: function (x, y, frame)
    {
        this.x = x;
        this.y = y;
        this.frame = frame;
    },

    destroy: function ()
    {
        this.parent = undefined;
        this.frame = undefined;
        this.data = undefined;
    }

};

Object.defineProperties(Bob.prototype, {

    visible: {

        enumerable: true,

        get: function ()
        {
            return this._visible;
        },

        set: function (value)
        {
            this._visible = value;
            this.parent.dirty = true;
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            this._alpha = value;
            this.parent.dirty = true;
        }

    }

});

module.exports = Bob;


/***/ },
/* 227 */
/***/ function(module, exports) {


var ContainerCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    //  Render children
    for (var i = 0; i < src.children.list.length; i++)
    {
        var child = src.children.list[i];

        child.renderCanvas(renderer, child, interpolationPercentage, camera);
    }
};

module.exports = ContainerCanvasRenderer;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {


var Container = __webpack_require__(92);
var FactoryContainer = __webpack_require__(6);

var ContainerFactory = {

    KEY: 'container',

    add: function (parent, x, y)
    {
        if (parent === undefined) { parent = this.state; }

        return parent.children.add(new Container(this.state, parent, x, y));
    },

    make: function (parent, x, y)
    {
        return new Container(this.state, parent, x, y);
    }

};

module.exports = FactoryContainer.register(ContainerFactory);


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(227),
    renderWebGL: __webpack_require__(230)

};


/***/ },
/* 230 */
/***/ function(module, exports) {


var ContainerWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    //  Render children
    for (var i = 0; i < src.children.list.length; i++)
    {
        var child = src.children.list[i];

        child.renderWebGL(renderer, child, interpolationPercentage, camera);
    }
};

module.exports = ContainerWebGLRenderer;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

var Commands = __webpack_require__(53);
var MATH_CONST = __webpack_require__(7);

var GraphicsCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;
    var srcX = src.x;
    var srcY = src.y;
    var srcScaleX = src.scaleX;
    var srcScaleY = src.scaleY;
    var srcRotation = src.rotation;
    var commandBuffer = src.commandBuffer;
    var ctx = renderer.currentContext;
    var value;
    var lineAlpha = 1.0;
    var fillAlpha = 1.0;
    var lineColor = 0;
    var fillColor = 0;
    var lineWidth = 1.0;
    var red = 0;
    var green = 0;
    var blue = 0;

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(srcX - cameraScrollX, srcY - cameraScrollY);
    ctx.rotate(srcRotation);
    ctx.scale(srcScaleX, srcScaleY);
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = src.alpha;

    for (var index = 0, length = commandBuffer.length; index < length; ++index)
    {
        var commandID = commandBuffer[index];

        switch (commandID)
        {
            case Commands.ARC:
                ctx.arc(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2],
                    commandBuffer[index + 3],
                    commandBuffer[index + 4],
                    commandBuffer[index + 5],
                    commandBuffer[index + 6]
                );
                index += 6;
                break;

            case Commands.LINE_STYLE:
                lineWidth = commandBuffer[index + 1];
                lineColor = commandBuffer[index + 2];
                lineAlpha = commandBuffer[index + 3];
                red = ((lineColor & 0xFF0000) >>> 16);
                green = ((lineColor & 0xFF00) >>> 8);
                blue = (lineColor & 0xFF);
                ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + lineAlpha + ')';
                ctx.lineWidth = lineWidth;
                index += 3;
                break;

            case Commands.FILL_STYLE:
                fillColor = commandBuffer[index + 1];
                fillAlpha = commandBuffer[index + 2];
                red = ((fillColor & 0xFF0000) >>> 16);
                green = ((fillColor & 0xFF00) >>> 8);
                blue = (fillColor & 0xFF);
                ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
                index += 2;
                break;

            case Commands.BEGIN_PATH:
                ctx.beginPath();
                break;

            case Commands.CLOSE_PATH:
                ctx.closePath();
                break;

            case Commands.FILL_PATH:
                ctx.fill();
                break;

            case Commands.STROKE_PATH:
                ctx.stroke();
                break;

            case Commands.FILL_RECT:
                ctx.fillRect(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2],
                    commandBuffer[index + 3],
                    commandBuffer[index + 4]
                );
                index += 4;
                break;

            case Commands.FILL_TRIANGLE:
                ctx.beginPath();
                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.closePath();
                ctx.fill();
                index += 6;
                break;

            case Commands.STROKE_TRIANGLE:
                ctx.beginPath();
                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.closePath();
                ctx.stroke();
                index += 6;
                break;

            case Commands.LINE_TO:
                ctx.lineTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.MOVE_TO:
                ctx.moveTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            default:
                console.error('Phaser: Invalid Graphics Command ID ' + commandID);
                break;
        }
    }

    ctx.restore();
};

module.exports = GraphicsCanvasRenderer;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

var Graphics = __webpack_require__(93);
var FactoryContainer = __webpack_require__(6);

var GraphicsFactory = {

    KEY: 'graphics',

    add: function (x, y, group)
    {
        if (group === undefined) { group = this.state; }

        return group.children.add(new Graphics(this.state, x, y));
    },

    make: function (x, y)
    {
        return new Graphics(this.state, x, y);
    }

};

module.exports = FactoryContainer.register(GraphicsFactory);


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(231),
    renderWebGL: __webpack_require__(234)

};


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

var Commands = __webpack_require__(53);
var TransformMatrix = __webpack_require__(26);
var pathArray = [];
var cos = Math.cos;
var sin = Math.sin;
var sqrt = Math.sqrt;
var tempMatrix = new TransformMatrix();

var Point = function (x, y)
{
    this.x = x;
    this.y = y;
};

var Path = function (x, y)
{
    this.points = [];
    this.pointsLength = 1;
    this.points[0] = new Point(x, y);
};

var GraphicsWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var shapeBatch = renderer.shapeBatch;
    var vertexDataBuffer = shapeBatch.vertexDataBuffer;
    var vertexBufferF32 = vertexDataBuffer.floatView;
    var vertexBufferU32 = vertexDataBuffer.uintView;
    var vertexOffset = 0;
    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;
    const srcX = src.x - cameraScrollX;
    const srcY = src.y - cameraScrollY;
    const srcScaleX = src.scaleX;
    const srcScaleY = src.scaleY;
    const srcRotation = -src.rotation;
    var commandBuffer = src.commandBuffer;
    var value;
    var lineAlpha = 1.0;
    var fillAlpha = 1.0;
    var lineColor = 0;
    var fillColor = 0;
    var lineWidth = 1.0;
    var cameraMatrix = camera.matrix.matrix;
    var lastPath = null;
    var iteration = 0;
    var iterStep = 0.01;
    var tx = 0;
    var ty = 0;
    var ta = 0;
    var x, y, radius, startAngle, endAngle, anticlockwise;
    var width, height, txw, tyh;
    var vertexCount = shapeBatch.vertexCount;
    var polygon = [];
    var x0, y0, x1, y1, x2, y2;
    var tx0, ty0, tx1, ty1, tx2, ty2;
    var v0, v1, v2;
    var polygonIndex;
    var path;
    var pathLength;
    var point;
    var maxVertices = shapeBatch.maxVertices;
    var translateX, translateY;
    var tempMatrixMatrix = tempMatrix.matrix;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var mva, mvb, mvc, mvd, mve, mvf;

    tempMatrix.applyITRS(srcX, srcY, srcRotation, srcScaleX, srcScaleY);

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    renderer.setBatch(shapeBatch, null);

    for (var cmdIndex = 0, cmdLength = commandBuffer.length; cmdIndex < cmdLength; ++cmdIndex)
    {
        var cmd = commandBuffer[cmdIndex];

        switch(cmd)
        {
            case Commands.ARC:
                x = commandBuffer[cmdIndex + 1];
                y = commandBuffer[cmdIndex + 2];
                radius = commandBuffer[cmdIndex + 3];
                startAngle = commandBuffer[cmdIndex + 4];
                endAngle = commandBuffer[cmdIndex + 5];
                anticlockwise = commandBuffer[cmdIndex + 6];
                
                while (iteration < 1)
                {
                    ta = (endAngle - startAngle) * iteration + startAngle;
                    tx = x + cos(ta) * radius;
                    ty = y + sin(ta) * radius;

                    if (iteration === 0)
                    {
                        lastPath = new Path(tx, ty);
                        pathArray.push(lastPath);
                    }
                    else
                    {
                        lastPath.points.push(new Point(tx, ty));
                    }

                    iteration += iterStep;
                }
                cmdIndex += 6;
                break;

            case Commands.LINE_STYLE:
                lineWidth = commandBuffer[cmdIndex + 1];
                lineColor = commandBuffer[cmdIndex + 2];
                lineAlpha = commandBuffer[cmdIndex + 3];
                cmdIndex += 3;
                break;

            case Commands.FILL_STYLE:
                fillColor = commandBuffer[cmdIndex + 1];
                fillAlpha = commandBuffer[cmdIndex + 2];
                cmdIndex += 2;
                break;

            case Commands.BEGIN_PATH:
                pathArray.length = 0;
                break;

            case Commands.CLOSE_PATH:
                if (lastPath !== null && lastPath.points.length > 0)
                {
                    var firstPoint = lastPath.points[0];
                    lastPath.points.push(firstPoint);
                    lastPath = new Path(x, y);
                    pathArray.push(lastPath);
                }
                break;

            case Commands.FILL_PATH:
                for (var pathArrayIndex = 0, pathArrayLength = pathArray.length;
                    pathArrayIndex < pathArrayLength;
                    ++pathArrayIndex)
                {
                    shapeBatch.addFillPath(
                        /* Graphics Game Object Properties */
                        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                        /* Rectangle properties */ 
                        pathArray[pathArrayIndex].points,
                        fillColor,
                        fillAlpha,
                        /* Transform */
                        mva, mvb, mvc, mvd, mve, mvf
                    );
                }
                break;

            case Commands.STROKE_PATH:
                for (var pathArrayIndex = 0, pathArrayLength = pathArray.length;
                    pathArrayIndex < pathArrayLength;
                    ++pathArrayIndex)
                {
                    var path = pathArray[pathArrayIndex];
                    shapeBatch.addStrokePath(
                        /* Graphics Game Object Properties */
                        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                        /* Rectangle properties */ 
                        path.points,
                        lineWidth,
                        lineColor,
                        lineAlpha,
                        /* Transform */
                        mva, mvb, mvc, mvd, mve, mvf,
                        path === this._lastPath
                    );
                }
                break;
                
            case Commands.FILL_RECT:
                shapeBatch.addFillRect(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Rectangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3],
                    commandBuffer[cmdIndex + 4],
                    fillColor,
                    fillAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf
                );
             
                cmdIndex += 4;
                break;

            case Commands.FILL_TRIANGLE:
                shapeBatch.addFillTriangle(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Triangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3] - cameraScrollX,
                    commandBuffer[cmdIndex + 4] - cameraScrollY,
                    commandBuffer[cmdIndex + 5] - cameraScrollX,
                    commandBuffer[cmdIndex + 6] - cameraScrollY,
                    fillColor,
                    fillAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf
                );
                
                cmdIndex += 6;
                break;

            case Commands.STROKE_TRIANGLE:
                shapeBatch.addStrokeTriangle(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Triangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3] - cameraScrollX,
                    commandBuffer[cmdIndex + 4] - cameraScrollY,
                    commandBuffer[cmdIndex + 5] - cameraScrollX,
                    commandBuffer[cmdIndex + 6] - cameraScrollY,
                    lineWidth,
                    lineColor,
                    lineAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf
                );
                
                cmdIndex += 6;
                break

            case Commands.LINE_TO:
                if (lastPath !== null)
                {
                    lastPath.points.push(new Point(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2]));
                }
                else
                {
                    lastPath = new Path(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2]);
                    pathArray.push(lastPath);
                }
                cmdIndex += 2;
                break;

            case Commands.MOVE_TO:
                lastPath = new Path(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2]);
                pathArray.push(lastPath);
                cmdIndex += 2;
                break;

            default:
                console.error('Phaser: Invalid Graphics Command ID ' + cmd);
                break;
        }
    }

    pathArray.length = 0;
};

module.exports = GraphicsWebGLRenderer;


/***/ },
/* 235 */
/***/ function(module, exports) {


var ImageCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask === this.renderFlags)
    {
        renderer.drawImage(src, camera);
    }
};

module.exports = ImageCanvasRenderer;


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {


var Image = __webpack_require__(94);
var FactoryContainer = __webpack_require__(6);

var ImageFactory = {

    KEY: 'image',

    /**
    * Create a new `Image` object.
    *
    * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
    *
    * It can still rotate, scale, crop and receive input events.
    * This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
    *
    * @method Phaser.GameObject.Factory#image
    * @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.
    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
    * @return {Phaser.Image} The newly created Image object.
    */
    add: function (x, y, key, frame, parent)
    {
        if (parent === undefined) { parent = this.state; }

        return parent.children.add(new Image(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        return new Image(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(ImageFactory);


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(235),
    renderWebGL: __webpack_require__(238)

};


/***/ },
/* 238 */
/***/ function(module, exports) {

var ImageWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    renderer.spriteBatch.addSprite(src, camera);
};

module.exports = ImageWebGLRenderer;


/***/ },
/* 239 */
/***/ function(module, exports) {


var SpriteCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask === this.renderFlags)
    {
        renderer.drawImage(src, camera);
    }
};

module.exports = SpriteCanvasRenderer;


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Sprite = __webpack_require__(95);
var FactoryContainer = __webpack_require__(6);

var SpriteFactory = {

    KEY: 'sprite',

    /**
    * Create a new Sprite with specific position and sprite sheet key.
    *
    * At its most basic a Sprite consists of a set of coordinates and a texture that is used when rendered.
    * They also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),
    * events (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.
    *
    * @method Phaser.GameObject.Factory#sprite
    * @param {number} [x=0] - The x coordinate of the sprite. The coordinate is relative to any parent container this sprite may be in.
    * @param {number} [y=0] - The y coordinate of the sprite. The coordinate is relative to any parent container this sprite may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.
    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
    * @return {Phaser.Sprite} The newly created Sprite object.
    */
    add: function (x, y, key, frame, group)
    {
        if (group === undefined) { group = this.state; }

        // console.log('ImageFactory.add', key, x, y, frame, group);
        // console.log('into State', this.state);

        return group.children.add(new Sprite(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        // console.log('ImageFactory.make', key, x, y, frame);

        return new Sprite(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(SpriteFactory);


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(239),
    renderWebGL: __webpack_require__(242)

};


/***/ },
/* 242 */
/***/ function(module, exports) {

var SpriteWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    renderer.spriteBatch.addSprite(src, camera);
};

module.exports = SpriteWebGLRenderer;


/***/ },
/* 243 */
/***/ function(module, exports) {

var Area = function (circle)
{
    return (circle.radius > 0) ? Math.PI * circle.radius * circle.radius : 0;
};

module.exports = Area;


/***/ },
/* 244 */
/***/ function(module, exports) {

var Circumference = function (circle)
{
    return 2 * (Math.PI * circle.radius);
};

module.exports = Circumference;


/***/ },
/* 245 */
/***/ function(module, exports) {

/**
* Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
* @method Phaser.Circle.circumferencePoint
* @param {Phaser.Circle} a - The first Circle object.
* @param {number} angle - The angle in radians (unless asDegrees is true) to return the point from.
* @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.
* @return {Phaser.Point} The Point object holding the result.
*/
var CircumferencePoint = function (circle, angle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = circle.x + (circle.radius * Math.cos(angle));
    out.y = circle.y + (circle.radius * Math.sin(angle));

    return out;
};

module.exports = CircumferencePoint;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

var Circle = __webpack_require__(96);

var Clone = function (source)
{
    return new Circle(source.x, source.y, source.radius);
};

module.exports = Clone;


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(54);

var ContainsPoint = function (circle, point)
{
    return Contains(circle, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(54);

var ContainsRect = function (circle, rect)
{
    return (
        Contains(circle, rect.x, rect.y) &&
        Contains(circle, rect.right, rect.y) &&
        Contains(circle, rect.x, rect.bottom) &&
        Contains(circle, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 249 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.radius);
};

module.exports = CopyFrom;


/***/ },
/* 250 */
/***/ function(module, exports) {

var Equals = function (circle, toCompare)
{
    return (
        circle.x === toCompare.x &&
        circle.y === toCompare.y &&
        circle.radius === toCompare.radius
    );
};

module.exports = Equals;


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(25);

var GetBounds = function (circle, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = circle.left;
    out.y = circle.top;
    out.width = circle.diameter;
    out.height = circle.diameter;

    return out;
};

module.exports = GetBounds;


/***/ },
/* 252 */
/***/ function(module, exports) {

var Offset = function (circle, x, y)
{
    circle.x += x;
    circle.y += y;

    return circle;
};

module.exports = Offset;


/***/ },
/* 253 */
/***/ function(module, exports) {

var OffsetPoint = function (circle, point)
{
    circle.x += point.x;
    circle.y += point.y;

    return circle;
};

module.exports = OffsetPoint;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

/**
* Returns a uniformly distributed random point from anywhere within this Circle.
* 
* @method Phaser.Circle#random
* @param {Phaser.Point|object} [out] - A Phaser.Point, or any object with public x/y properties, that the values will be set in.
*     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.
* @return {Phaser.Point} An object containing the random point in its `x` and `y` properties.
*/
var Random = function (circle, out)
{
    if (out === undefined) { out = new Point(); }

    var t = 2 * Math.PI * Math.random();
    var u = Math.random() + Math.random();
    var r = (u > 1) ? 2 - u : u;
    var x = r * Math.cos(t);
    var y = r * Math.sin(t);

    out.x = circle.x + (x * circle.radius);
    out.y = circle.y + (y * circle.radius);

    return out;
};

module.exports = Random;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Circle

var Circle = __webpack_require__(96);

Circle.Area = __webpack_require__(243);
Circle.Circumference = __webpack_require__(244);
Circle.CircumferencePoint = __webpack_require__(245);
Circle.Clone = __webpack_require__(246);
Circle.Contains = __webpack_require__(54);
Circle.ContainsPoint = __webpack_require__(247);
Circle.ContainsRect = __webpack_require__(248);
Circle.CopyFrom = __webpack_require__(249);
Circle.Equals = __webpack_require__(250);
Circle.GetBounds = __webpack_require__(251);
Circle.Offset = __webpack_require__(252);
Circle.OffsetPoint = __webpack_require__(253);
Circle.Random = __webpack_require__(254);

module.exports = Circle;


/***/ },
/* 256 */
/***/ function(module, exports) {

var Area = function (ellipse)
{
    if (ellipse.isEmpty())
    {
        return 0;
    }

    //  units squared
    return (ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI);
};

module.exports = Area;


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

var Ellipse = __webpack_require__(97);

var Clone = function (source)
{
    return new Ellipse(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(55);

var ContainsPoint = function (ellipse, point)
{
    return Contains(ellipse, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(55);

var ContainsRect = function (ellipse, rect)
{
    return (
        Contains(ellipse, rect.x, rect.y) &&
        Contains(ellipse, rect.right, rect.y) &&
        Contains(ellipse, rect.x, rect.bottom) &&
        Contains(ellipse, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 260 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Ellipse} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ },
/* 261 */
/***/ function(module, exports) {

var Equals = function (ellipse, toCompare)
{
    return (
        ellipse.x === toCompare.x &&
        ellipse.y === toCompare.y &&
        ellipse.width === toCompare.width &&
        ellipse.height === toCompare.height
    );
};

module.exports = Equals;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(25);

var GetBounds = function (ellipse, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = ellipse.x - ellipse.width;
    out.y = ellipse.y - ellipse.height;
    out.width = ellipse.width;
    out.height = ellipse.height;

    return out;
};

module.exports = GetBounds;


/***/ },
/* 263 */
/***/ function(module, exports) {

var Offset = function (ellipse, x, y)
{
    ellipse.x += x;
    ellipse.y += y;

    return ellipse;
};

module.exports = Offset;


/***/ },
/* 264 */
/***/ function(module, exports) {

var OffsetPoint = function (ellipse, point)
{
    ellipse.x += point.x;
    ellipse.y += point.y;

    return ellipse;
};

module.exports = OffsetPoint;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Random = function (ellipse, out)
{
    if (out === undefined) { out = new Point(); }

    var p = Math.random() * Math.PI * 2;
    var s = Math.sqrt(Math.random());

    out.x = ellipse.x + ((s * Math.cos(p)) * ellipse.width / 2);
    out.y = ellipse.y + ((s * Math.sin(p)) * ellipse.height / 2);

    return out;
};

module.exports = Random;


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Ellipse

var Ellipse = __webpack_require__(97);

Ellipse.Area = __webpack_require__(256);
Ellipse.Clone = __webpack_require__(257);
Ellipse.Contains = __webpack_require__(55);
Ellipse.ContainsPoint = __webpack_require__(258);
Ellipse.ContainsRect = __webpack_require__(259);
Ellipse.CopyFrom = __webpack_require__(260);
Ellipse.Equals = __webpack_require__(261);
Ellipse.GetBounds = __webpack_require__(262);
Ellipse.Offset = __webpack_require__(263);
Ellipse.OffsetPoint = __webpack_require__(264);
Ellipse.Random = __webpack_require__(265);

module.exports = Ellipse;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

var GetAngle = __webpack_require__(98);
var FindT = __webpack_require__(56);

/**
* Calculate and return the angle, in radians, of the curves tangent at the given pixel distance along the curves length.
*
* @method Phaser.Hermite#getAngleWithDistance
* @param {number} [distance=0] - The distance along the curve to get the angle from, in pixels.
* @return {number} The angle of the line at the specified distance along the curve. The value is in radians.
*/
var GetAngleWithDistance = function (curve, distance)
{
    if (distance === undefined) { distance = 0; }

    if (distance <= 0)
    {
        return Math.atan2(this._v1y, this._v1x);
    }
    else
    {
        return GetAngle(curve, FindT(curve, distance));
    }
};

module.exports = GetAngleWithDistance;


/***/ },
/* 268 */
/***/ function(module, exports) {

/**
* Get the angle of the curves entry point.
*
* @method Phaser.Hermite#getEntryTangent
* @param {Phaser.Point|Object} point - The Phaser.Point object, or an Object with public `x` and `y` properties, in which the tangent vector values will be stored.
* @return {Phaser.Point} A Point object containing the tangent vector of this Hermite curve.
*/
var GetEntryTangent = function (curve, point)
{
    point.x = curve._v1x;
    point.y = curve._v1y;

    return point;
};

module.exports = GetEntryTangent;


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);
var GetPoint = __webpack_require__(57);
var FindT = __webpack_require__(56);

/**
* Get a point on the curve using the distance, in pixels, along the curve.
*
* @method Phaser.Hermite#getPointWithDistance
* @param {integer} [distance=0] - The distance along the curve to get the point from, given in pixels.
* @param {Phaser.Point|Object} [point] - An optional Phaser.Point, or Object containing public `x` and `y` properties. If given the resulting values will be stored in the Objects `x` and `y` properties. If omitted a new Phaser.Point object is created.
* @return {Phaser.Point} The point on the line at the specified 'distance' along the curve.
*/
var GetPointWithDistance = function (curve, distance, out)
{
    if (distance === undefined) { distance = 0; }
    if (out === undefined) { out = new Point(); }

    if (distance <= 0)
    {
        out.x = this._p1x;
        out.y = this._p1y;
    }
    else
    {
        GetPoint(curve, FindT(curve, distance), out);
    }
    
    return out;
};

module.exports = GetPointWithDistance;


/***/ },
/* 270 */
/***/ function(module, exports) {

/**
* Get the X component of a point on the curve based on the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getX
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @return {number} The X component of a point on the curve based on the `t` (time) value.
*/
var GetX = function (curve, t)
{
    if (t === undefined)
    {
        t = 0;
    }
    else
    {
        if (t < 0)
        {
            t = 0;
        }

        if (t > 1)
        {
            t = 1;
        }
    }

    var t2 = t * t;
    var t3 = t * t2;

    return (t3 * curve._ax + t2 * curve._bx + t * curve._v1x + curve._p1x);
};

module.exports = GetX;


/***/ },
/* 271 */
/***/ function(module, exports) {

/**
* Get the Y component of a point on the curve based on the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getY
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @return {number} The Y component of a point on the curve based on the `t` (time) value.
*/
var GetY = function (curve, t)
{
    if (t === undefined)
    {
        t = 0;
    }
    else
    {
        if (t < 0)
        {
            t = 0;
        }

        if (t > 1)
        {
            t = 1;
        }
    }

    var t2 = t * t;
    var t3 = t * t2;

    return (t3 * curve._ay + t2 * curve._by + t * curve._v1y + curve._p1y);
};

module.exports = GetY;


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

/**
* @author       Richard Davey <rich@photonstorm.com>
* @author       Pete Baron <pete@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A data representation of a Hermite Curve (see http://en.wikipedia.org/wiki/Cubic_Hermite_spline)
* 
* A Hermite curve has a start and end point and tangent vectors for both of them.
* The curve will always pass through the two control points and the shape of it is controlled
* by the length and direction of the tangent vectors.  At the control points the curve will
* be facing exactly in the vector direction.
* 
* As these curves change speed (speed = distance between points separated by an equal change in
* 't' value - see Hermite.getPoint) this class attempts to reduce the variation by pre-calculating
* the `accuracy` number of points on the curve. The straight-line distances to these points are stored
* in the private 'points' array, and this information is used by Hermite.findT() to convert a pixel
* distance along the curve into a 'time' value.
* 
* Higher `accuracy` values will result in more even movement, but require more memory for the points
* list. 5 works, but 10 seems to be an ideal value for the length of curves found in most games on
* a desktop screen. If you use very long curves (more than 400 pixels) you may need to increase
* this value further.
*
* @class Phaser.Hermite
* @constructor
* @param {number} p1x - The x coordinate of the start of the curve.
* @param {number} p1y - The y coordinate of the start of the curve.
* @param {number} p2x - The x coordinate of the end of the curve.
* @param {number} p2y - The y coordinate of the end of the curve.
* @param {number} v1x - The x component of the tangent vector for the start of the curve.
* @param {number} v1y - The y component of the tangent vector for the start of the curve.
* @param {number} v2x - The x component of the tangent vector for the end of the curve.
* @param {number} v2y - The y component of the tangent vector for the end of the curve.
* @param {number} [accuracy=10] The amount of points to pre-calculate on the curve.
*/
var Hermite = function (p1x, p1y, p2x, p2y, v1x, v1y, v2x, v2y, accuracy)
{
    if (accuracy === undefined) { accuracy = 10; }

    /**
    * @property {number} _accuracy - The amount of points to pre-calculate on the curve.
    * @private
    */
    this._accuracy = accuracy;

    /**
    * @property {number} _p1x - The x coordinate of the start of the curve.
    * @private
    */
    this._p1x = p1x;

    /**
    * @property {number} _p1y - The y coordinate of the start of the curve.
    * @private
    */
    this._p1y = p1y;

    /**
    * @property {number} _p2x - The x coordinate of the end of the curve.
    * @private
    */
    this._p2x = p2x;

    /**
    * @property {number} _p2y - The y coordinate of the end of the curve.
    * @private
    */
    this._p2y = p2y;

    /**
    * @property {number} _v1x - The x component of the tangent vector for the start of the curve.
    * @private
    */
    this._v1x = v1x;

    /**
    * @property {number} _v1y - The y component of the tangent vector for the start of the curve.
    * @private
    */
    this._v1y = v1y;

    /**
    * @property {number} _v2x - The x component of the tangent vector for the end of the curve.
    * @private
    */
    this._v2x = v2x;

    /**
    * @property {number} _v2y - The y component of the tangent vector for the end of the curve.
    * @private
    */
    this._v2y = v2y;
    
    /**
    * @property {array} _points - A local array of cached points.
    * @private
    */
    this._points = [];

    /**
    * @property {Phaser.Point} _temp1 - A local cached Point object.
    * @private
    */
    this._temp1 = new Point();

    /**
    * @property {Phaser.Point} _temp2 - A local cached Point object.
    * @private
    */
    this._temp2 = new Point();

    this.recalculate();
};

Hermite.prototype.constructor = Hermite;

Hermite.prototype = {

    /**
    * Performs the curve calculations.
    *
    * This is called automatically if you change any of the curves public properties, such as `Hermite.p1x` or `Hermite.v2y`.
    *
    * If you adjust any of the internal private values, then call this to update the points.
    *
    * @method Phaser.Hermite#recalculate
    * @return {Phaser.Hermite} This object.
    */
    recalculate: function ()
    {
        this._ax = (2 * this._p1x - 2 * this._p2x + this._v1x + this._v2x);
        this._ay = (2 * this._p1y - 2 * this._p2y + this._v1y + this._v2y);
        this._bx = (-3 * this._p1x + 3 * this._p2x - 2 * this._v1x - this._v2x);
        this._by = (-3 * this._p1y + 3 * this._p2y - 2 * this._v1y - this._v2y);

        this.length = this.calculateEvenPoints();

        return this;
    },

    /**
    * Calculate a number of points along the curve, based on `Hermite.accuracy`, and stores them in the private `_points` array.
    *
    * @method Phaser.Hermite#calculateEvenPoints
    * @return {number} The total length of the curve approximated as straight line distances between the points.
    */
    calculateEvenPoints: function ()
    {
        var totalLength = 0;

        this._temp1.setTo(0, 0);                    //  pnt
        this._temp2.setTo(this._p1x, this._p1y);    //  lastPnt

        this._points[0] = 0;

        for (var i = 1; i <= this._accuracy; i++)
        {
            this.getPoint(i / this._accuracy, this._temp1);

            totalLength += this._temp1.distance(this._temp2);

            this._points[i] = totalLength;
            this._temp2.copyFrom(this._temp1);
        }

        return totalLength;
    }

};

Object.defineProperties(Hermite.prototype, {

    /**
    * @name Phaser.Hermite#accuracy
    * @property {number} accuracy - The amount of points to pre-calculate on the curve.
    */
    accuracy: {

        enumerable: true,

        get: function ()
        {
            return this._accuracy;
        },

        set: function (value)
        {
            if (value !== this._accuracy)
            {
                this._accuracy = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p1x
    * @property {number} p1x - The x coordinate of the start of the curve. Setting this value will recalculate the curve.
    */
    p1x: {

        enumerable: true,

        get: function ()
        {
            return this._p1x;
        },

        set: function (value)
        {
            if (value !== this._p1x)
            {
                this._p1x = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p1y
    * @property {number} p1y - The y coordinate of the start of the curve. Setting this value will recalculate the curve.
    */
    p1y: {

        enumerable: true,

        get: function ()
        {
            return this._p1y;
        },

        set: function (value)
        {
            if (value !== this._p1y)
            {
                this._p1y = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p2x
    * @property {number} p2x - The x coordinate of the end of the curve. Setting this value will recalculate the curve.
    */
    p2x: {

        enumerable: true,

        get: function ()
        {
            return this._p2x;
        },

        set: function (value)
        {
            if (value !== this._p2x)
            {
                this._p2x = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p2y
    * @property {number} p2y - The y coordinate of the end of the curve. Setting this value will recalculate the curve.
    */
    p2y: {

        enumerable: true,

        get: function ()
        {
            return this._p2y;
        },

        set: function (value)
        {
            if (value !== this._p2y)
            {
                this._p2y = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#v1x
    * @property {number} v1x - The x component of the tangent vector for the start of the curve. Setting this value will recalculate the curve.
    */
    v1x: {

        enumerable: true,

        get: function ()
        {
            return this._v1x;
        },

        set: function (value)
        {
            if (value !== this._v1x)
            {
                this._v1x = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#v1y
    * @property {number} v1y - The y component of the tangent vector for the start of the curve. Setting this value will recalculate the curve.
    */
    v1y: {

        enumerable: true,

        get: function ()
        {
            return this._v1y;
        },

        set: function (value)
        {
            if (value !== this._v1y)
            {
                this._v1y = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#v2x
    * @property {number} v2x - The x component of the tangent vector for the end of the curve. Setting this value will recalculate the curve.
    */
    v2x: {

        enumerable: true,

        get: function ()
        {
            return this._v2x;
        },

        set: function (value)
        {
            if (value !== this._v2x)
            {
                this._v2x = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#v2y
    * @property {number} v2y - The y component of the tangent vector for the end of the curve. Setting this value will recalculate the curve.
    */
    v2y: {

        enumerable: true,

        get: function ()
        {
            return this._v2y;
        },

        set: function (value)
        {
            if (value !== this._v2y)
            {
                this._v2y = value;
                this.recalculate();
            }
        }

    }

});

module.exports = Hermite;


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Hermite

var Hermite = __webpack_require__(272);

Hermite.FindT = __webpack_require__(56);
Hermite.GetAngle = __webpack_require__(98);
Hermite.GetAngleWithDistance = __webpack_require__(267);
Hermite.GetEntryTangent = __webpack_require__(268);
Hermite.GetPoint = __webpack_require__(57);
Hermite.GetPointWithDistance = __webpack_require__(269);
Hermite.GetX = __webpack_require__(270);
Hermite.GetY = __webpack_require__(271);

module.exports = Hermite;


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

var DistanceBetween = __webpack_require__(146);

var CircleToCircle = function (circleA, circleB)
{
    return (DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= (circleA.radius + circleB.radius));
};

module.exports = CircleToCircle;


/***/ },
/* 275 */
/***/ function(module, exports) {

var CircleToRectangle = function (circle, rect)
{
    var halfWidth = rect.width / 2;
    var halfHeight = rect.height / 2;

    var cx = Math.abs(circle.x - rect.x - halfWidth);
    var xDist = halfWidth + circle.radius;

    if (cx <= halfWidth || cx > xDist)
    {
        return false;
    }

    var cy = Math.abs(circle.y - rect.y - halfHeight);
    var yDist = halfHeight + circle.radius;

    if (cy <= halfHeight || cy > yDist)
    {
        return false;
    }

    var xCornerDist = cx - halfWidth;
    var yCornerDist = cy - halfHeight;
    var xCornerDistSq = xCornerDist * xCornerDist;
    var yCornerDistSq = yCornerDist * yCornerDist;
    var maxCornerDistSq = circle.radius * circle.radius;

    return (xCornerDistSq + yCornerDistSq <= maxCornerDistSq);
};

module.exports = CircleToRectangle;


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(25);
var RectangleToRectangle = __webpack_require__(100);

var GetRectangleIntersection = function (rectA, rectB, output)
{
    if (output === undefined) { output = new Rectangle(); }

    if (RectangleToRectangle(rectA, rectB))
    {
        output.x = Math.max(rectA.x, rectB.x);
        output.y = Math.max(rectA.y, rectB.y);
        output.width = Math.min(rectA.right, rectB.right) - output.x;
        output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
    }

    return output;
};

module.exports = GetRectangleIntersection;


/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var LineToLine = function (line1, line2, asSegment, out)
{
    if (asSegment === undefined) { asSegment = true; }
    if (out === undefined) { out = new Point(); }

    var a = line1.x1;
    var b = line1.y1;

    var e = line1.x2;
    var f = line1.y2;

    var a1 = b.y - a.y;
    var a2 = f.y - e.y;
    var b1 = a.x - b.x;
    var b2 = e.x - f.x;
    var c1 = (b.x * a.y) - (a.x * b.y);
    var c2 = (f.x * e.y) - (e.x * f.y);
    var denom = (a1 * b2) - (a2 * b1);

    if (denom === 0)
    {
        return null;
    }

    out.x = ((b1 * c2) - (b2 * c1)) / denom;
    out.y = ((a2 * c1) - (a1 * c2)) / denom;

    if (asSegment)
    {
        var uc = ((f.y - e.y) * (b.x - a.x) - (f.x - e.x) * (b.y - a.y));
        var ua = (((f.x - e.x) * (a.y - e.y)) - (f.y - e.y) * (a.x - e.x)) / uc;
        var ub = (((b.x - a.x) * (a.y - e.y)) - ((b.y - a.y) * (a.x - e.x))) / uc;

        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)
        {
            return out;
        }
        else
        {
            return null;
        }
    }

    return out;
};

module.exports = LineToLine;


/***/ },
/* 278 */
/***/ function(module, exports) {

/**
* Checks for intersection between the Line and a Rectangle shape, or a rectangle-like
* object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.
*
* An intersection is considered valid if:
*
* The line starts within, or ends within, the Rectangle.
* The line segment intersects one of the 4 rectangle edges.
*
* The for the purposes of this function rectangles are considered 'solid'.
*
* @method Phaser.Line.intersectsRectangle
* @param {Phaser.Line} line - The line to check for intersection with.
* @param {Phaser.Rectangle|object} rect - The rectangle, or rectangle-like object, to check for intersection with.
* @return {boolean} True if the line intersects with the rectangle edges, or starts or ends within the rectangle.
*/
var LineToRectangle = function (line, rect)
{
    var x1 = line.x1;
    var y1 = line.y2;

    var x2 = line.x2;
    var y2 = line.y2;

    var bx1 = rect.x;
    var by1 = rect.y;
    var bx2 = rect.right;
    var by2 = rect.bottom;

    var t = 0;

    //  If the start or end of the line is inside the rect then we assume
    //  collision, as rects are solid for our use-case.

    if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) ||
        (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2))
    {
        return true;
    }

    if (x1 < bx1 && x2 >= bx1)
    {
        //  Left edge
        t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);

        if (t > by1 && t <= by2)
        {
            return true;
        }
    }
    else if (x1 > bx2 && x2 <= bx2)
    {
        //  Right edge
        t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);

        if (t >= by1 && t <= by2)
        {
            return true;
        }
    }

    if (y1 < by1 && y2 >= by1)
    {
        //  Top edge
        t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }
    else if (y1 > by2 && y2 <= by2)
    {
        //  Bottom edge
        t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }

    return false;
};

module.exports = LineToRectangle;


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

var PointToLine = __webpack_require__(99);

var PointToLineSegment = function (point, line)
{
    if (!PointToLine(point, line))
    {
        return false;
    }

    var xMin = Math.min(line.x1, line.x2);
    var xMax = Math.max(line.x1, line.x2);
    var yMin = Math.min(line.y1, line.y2);
    var yMax = Math.max(line.y1, line.y2);

    return ((point.x >= xMin && point.x <= xMax) && (point.y >= yMin && point.y <= yMax));
};

module.exports = PointToLineSegment;


/***/ },
/* 280 */
/***/ function(module, exports) {

var RectangleToValues = function (rect, left, right, top, bottom, tolerance)
{
    if (tolerance === undefined) { tolerance = 0; }

    return !(
        left > rect.right + tolerance ||
        right < rect.left - tolerance ||
        top > rect.bottom + tolerance ||
        bottom < rect.top - tolerance
    );
};

module.exports = RectangleToValues;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {


module.exports = {

    CircleToCircle: __webpack_require__(274),
    CircleToRectangle: __webpack_require__(275),
    GetRectangleIntersection: __webpack_require__(276),
    LineToLine: __webpack_require__(277),
    LineToRectangle: __webpack_require__(278),
    PointToLine: __webpack_require__(99),
    PointToLineSegment: __webpack_require__(279),
    RectangleToRectangle: __webpack_require__(100),
    RectangleToValues: __webpack_require__(280)

};


/***/ },
/* 282 */
/***/ function(module, exports) {


var CenterOn = function (line, x, y)
{
    var tx = x - ((line.x1 + line.x2) / 2);
    var ty = y - ((line.y1 + line.y2) / 2);

    line.x1 += tx;
    line.y1 += ty;

    line.x2 += tx;
    line.y2 += ty;

    return line;
};

module.exports = CenterOn;


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

var Line = __webpack_require__(101);

var Clone = function (source)
{
    return new Line(source.x1, source.y1, source.x2, source.y2);
};

module.exports = Clone;


/***/ },
/* 284 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x1, source.y1, source.x2, source.y2);
};

module.exports = CopyFrom;


/***/ },
/* 285 */
/***/ function(module, exports) {

var Equals = function (line, toCompare)
{
    return (
        line.x1 === toCompare.x1 &&
        line.y1 === toCompare.y1 &&
        line.x2 === toCompare.x2 &&
        line.y2 === toCompare.y2
    );
};

module.exports = Equals;


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var GetMidPoint = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = (line.x1 + line.x2) / 2;
    out.y = (line.y1 + line.y2) / 2;

    return out;
};

module.exports = GetMidPoint;


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(7);
var Angle = __webpack_require__(29);
var Point = __webpack_require__(1);

var GetNormal = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var a = Angle(line) - MATH_CONST.TAU;

    out.x = Math.cos(a);
    out.y = Math.sin(a);

    return out;
};

module.exports = GetNormal;


/***/ },
/* 288 */
/***/ function(module, exports) {

/**
* Using Bresenham's line algorithm this will return an array of all coordinates on this line.
* The start and end points are rounded before this runs as the algorithm works on integers.
*
* @method Phaser.Line#coordinatesOnLine
* @param {number} [stepRate=1] - How many steps will we return? 1 = every coordinate on the line, 2 = every other coordinate, etc.
* @param {array} [results] - The array to store the results in. If not provided a new one will be generated.
* @return {array} An array of coordinates.
*/
var GetPointsOnLine = function (line, stepRate, results)
{
    if (stepRate === undefined) { stepRate = 1; }
    if (results === undefined) { results = []; }

    var x1 = Math.round(line.x1);
    var y1 = Math.round(line.y1);
    var x2 = Math.round(line.x2);
    var y2 = Math.round(line.y2);

    var dx = Math.abs(x2 - x1);
    var dy = Math.abs(y2 - y1);
    var sx = (x1 < x2) ? 1 : -1;
    var sy = (y1 < y2) ? 1 : -1;
    var err = dx - dy;

    results.push([ x1, y1 ]);

    var i = 1;

    while (!((x1 === x2) && (y1 === y2)))
    {
        var e2 = err << 1;

        if (e2 > -dy)
        {
            err -= dy;
            x1 += sx;
        }

        if (e2 < dx)
        {
            err += dx;
            y1 += sy;
        }

        if (i % stepRate === 0)
        {
            results.push([ x1, y1 ]);
        }

        i++;
    }

    return results;
};

module.exports = GetPointsOnLine;


/***/ },
/* 289 */
/***/ function(module, exports) {

var Height = function (line)
{
    return Math.abs(line.y1 - line.y2);
};

module.exports = Height;


/***/ },
/* 290 */
/***/ function(module, exports) {

var Length = function (line)
{
    return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
};

module.exports = Length;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(7);
var Angle = __webpack_require__(29);

var NormalX = function (line)
{
    return Math.cos(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalX;


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(7);
var Angle = __webpack_require__(29);

var NormalY = function (line)
{
    return Math.sin(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalY;


/***/ },
/* 293 */
/***/ function(module, exports) {

var PerpSlope = function (line)
{
    return -((line.x2 - line.x1) / (line.y2 - line.y1));
};

module.exports = PerpSlope;


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Random = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var t = Math.random();

    out.x = line.x1 + t * (line.x2 - line.x1);
    out.y = line.y1 + t * (line.y2 - line.y1);

    return out;
};

module.exports = Random;


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

var Angle = __webpack_require__(29);
var NormalAngle = __webpack_require__(102);

/**
* Returns the reflected angle between two lines.
* This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.
*
* @method Phaser.Line.reflect
* @param {Phaser.Line} a - The base line.
* @param {Phaser.Line} b - The line to be reflected from the base line.
* @return {number} The reflected angle in radians.
*/
var ReflectAngle = function (lineA, lineB)
{
    return (2 * NormalAngle(lineB) - Math.PI - Angle(lineA));
};

module.exports = ReflectAngle;


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(58);

var Rotate = function (line, angle)
{
    var x = (line.x1 + line.x2) / 2;
    var y = (line.y1 + line.y2) / 2;

    return RotateAroundXY(line, x, y, angle);
};

module.exports = Rotate;


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(58);

var RotateAroundPoint = function (line, point, angle)
{
    return RotateAroundXY(line, point.x, point.y, angle);
};

module.exports = RotateAroundPoint;


/***/ },
/* 298 */
/***/ function(module, exports) {

var SetToAngle = function (line, x, y, angle, length)
{
    line.x1 = x;
    line.y1 = y;

    line.x2 = x + (Math.cos(angle) * length);
    line.y2 = y + (Math.sin(angle) * length);

    return line;
};

module.exports = SetToAngle;


/***/ },
/* 299 */
/***/ function(module, exports) {

var Slope = function (line)
{
    return (line.y2 - line.y1) / (line.x2 - line.x1);
};

module.exports = Slope;


/***/ },
/* 300 */
/***/ function(module, exports) {

var Width = function (line)
{
    return Math.abs(line.x1 - line.x2);
};

module.exports = Width;


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Line

var Line = __webpack_require__(101);

Line.Angle = __webpack_require__(29);
Line.CenterOn = __webpack_require__(282);
Line.Clone = __webpack_require__(283);
Line.CopyFrom = __webpack_require__(284);
Line.Equals = __webpack_require__(285);
Line.GetMidPoint = __webpack_require__(286);
Line.GetNormal = __webpack_require__(287);
Line.GetPointsOnLine = __webpack_require__(288);
Line.Height = __webpack_require__(289);
Line.Length = __webpack_require__(290);
Line.NormalAngle = __webpack_require__(102);
Line.NormalX = __webpack_require__(291);
Line.NormalY = __webpack_require__(292);
Line.PerpSlope = __webpack_require__(293);
Line.Random = __webpack_require__(294);
Line.ReflectAngle = __webpack_require__(295);
Line.Rotate = __webpack_require__(296);
Line.RotateAroundPoint = __webpack_require__(297);
Line.RotateAroundXY = __webpack_require__(58);
Line.SetToAngle = __webpack_require__(298);
Line.Slope = __webpack_require__(299);
Line.Width = __webpack_require__(300);

module.exports = Line;


/***/ },
/* 302 */
/***/ function(module, exports) {

var Add = function (point, x, y)
{
    point.x += x;
    point.y += y;

    return point;
};

module.exports = Add;


/***/ },
/* 303 */
/***/ function(module, exports) {

var Ceil = function (point)
{
    return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
};

module.exports = Ceil;


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Clone = function (source)
{
    return new Point(source.x, source.y);
};

module.exports = Clone;


/***/ },
/* 305 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y);
};

module.exports = CopyFrom;


/***/ },
/* 306 */
/***/ function(module, exports) {

var Cross = function (pointA, pointB)
{
    return ((pointA.x * pointB.y) - (pointA.y * pointB.x));
};

module.exports = Cross;


/***/ },
/* 307 */
/***/ function(module, exports) {

var Divide = function (point, x, y)
{
    point.x /= x;
    point.y /= y;

    return point;
};

module.exports = Divide;


/***/ },
/* 308 */
/***/ function(module, exports) {

var Equals = function (point, toCompare)
{
    return (point.x === toCompare.x && point.y === toCompare.y);
};

module.exports = Equals;


/***/ },
/* 309 */
/***/ function(module, exports) {

var Floor = function (point)
{
    return point.setTo(Math.floor(point.x), Math.floor(point.y));
};

module.exports = Floor;


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var GetCentroid = function (points, out)
{
    if (out === undefined) { out = new Point(); }

    if (!Array.isArray(points))
    {
        throw new Error('GetCentroid points argument must be an array');
    }

    var len = points.length;

    if (len < 1)
    {
        throw new Error('GetCentroid points array must not be empty');
    }
    else if (len === 1)
    {
        out.x = points[0].x;
        out.y = points[0].y;
    }
    else
    {
        for (var i = 0; i < len; i++)
        {
            out.x += points[i].x;
            out.y += points[i].y;
        }

        out.x /= len;
        out.y /= len;
    }

    return out;
};

module.exports = GetCentroid;


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Interpolate = function (pointA, pointB, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    out.x = pointA.x + ((pointB.x - pointA.x) * t);
    out.y = pointA.y + ((pointB.y - pointA.y) * t);

    return out;
};

module.exports = Interpolate;


/***/ },
/* 312 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var Invert = function (point)
{
    return point.setTo(point.y, point.x);
};

module.exports = Invert;


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Negative = function (point, out)
{
    if (out === undefined) { out = new Point(); }

    return out.setTo(-point.x, -point.y);
};

module.exports = Negative;


/***/ },
/* 314 */
/***/ function(module, exports) {

var NormalizeRightHand = function (point)
{
    return point.setTo(point.y * -1, point.x);
};

module.exports = NormalizeRightHand;


/***/ },
/* 315 */
/***/ function(module, exports) {

var Perp = function (point)
{
    return point.setTo(-point.y, point.x);
};

module.exports = Perp;


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(59);
var Point = __webpack_require__(1);
var GetMagnitudeSq = __webpack_require__(104);

var Project = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB) / GetMagnitudeSq(pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = Project;


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(59);
var Point = __webpack_require__(1);

var ProjectUnit = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = ProjectUnit;


/***/ },
/* 318 */
/***/ function(module, exports) {

var RPerp = function (point)
{
    return point.setTo(point.y, -point.x);
};

module.exports = RPerp;


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(106);
var Multiply = __webpack_require__(105);

var SetMagnitude = function (point, magnitude)
{
    Normalize(point);

    return Multiply(point, magnitude, magnitude);
};

module.exports = SetMagnitude;


/***/ },
/* 320 */
/***/ function(module, exports) {

var Subtract = function (point, x, y)
{
    point.x -= x;
    point.y -= y;

    return point;
};

module.exports = Subtract;


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Point

var Point = __webpack_require__(1);

Point.Add = __webpack_require__(302);
Point.Ceil = __webpack_require__(303);
Point.Clone = __webpack_require__(304);
Point.CopyFrom = __webpack_require__(305);
Point.Cross = __webpack_require__(306);
Point.Divide = __webpack_require__(307);
Point.Dot = __webpack_require__(59);
Point.Equals = __webpack_require__(308);
Point.Floor = __webpack_require__(309);
Point.GetCentroid = __webpack_require__(310);
Point.GetMagnitude = __webpack_require__(103);
Point.GetMagnitudeSq = __webpack_require__(104);
Point.Interpolate = __webpack_require__(311);
Point.Invert = __webpack_require__(312);
Point.Multiply = __webpack_require__(105);
Point.Negative = __webpack_require__(313);
Point.Normalize = __webpack_require__(106);
Point.NormalizeRightHand = __webpack_require__(314);
Point.Perp = __webpack_require__(315);
Point.Project = __webpack_require__(316);
Point.ProjectUnit = __webpack_require__(317);
Point.RPerp = __webpack_require__(318);
Point.SetMagnitude = __webpack_require__(319);
Point.Subtract = __webpack_require__(320);

module.exports = Point;


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

var Polygon = __webpack_require__(108);

var Clone = function (polygon)
{
    return new Polygon(polygon.points);
};

module.exports = Clone;


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(107);

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var ContainsPoint = function (polygon, point)
{
    return Contains(polygon, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 324 */
/***/ function(module, exports) {


var GetAABB = function (polygon)
{
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -minX;
    var maxY = -minY;
    var p;

    for (var i = 0; i < polygon.points.length; i++)
    {
        p = polygon.points[i];

        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
    }

    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
};

module.exports = GetAABB;


/***/ },
/* 325 */
/***/ function(module, exports) {

/**
 * Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]
 *
 * @method Phaser.Polygon#toNumberArray
 * @param {array} [output] - The array to append the points to. If not specified a new array will be created.
 * @return {array} The flattened array.
 */
var GetNumberArray = function (polygon, output)
{
    if (output === undefined) { output = []; }

    for (var i = 0; i < polygon.points.length; i++)
    {
        output.push(polygon.points[i].x);
        output.push(polygon.points[i].y);
    }

    return output;
};

module.exports = GetNumberArray;


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Polygon

var Polygon = __webpack_require__(108);

Polygon.Clone = __webpack_require__(322);
Polygon.Contains = __webpack_require__(107);
Polygon.ContainsPoint = __webpack_require__(323);
Polygon.GetAABB = __webpack_require__(324);
Polygon.GetNumberArray = __webpack_require__(325);

module.exports = Polygon;


/***/ },
/* 327 */
/***/ function(module, exports) {

var Area = function (rect)
{
    return rect.width * rect.height;
};

module.exports = Area;


/***/ },
/* 328 */
/***/ function(module, exports) {

var Ceil = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);

    return rect;
};

module.exports = Ceil;


/***/ },
/* 329 */
/***/ function(module, exports) {

var CeilAll = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);
    rect.width = Math.ceil(rect.width);
    rect.height = Math.ceil(rect.height);

    return rect;
};

module.exports = CeilAll;


/***/ },
/* 330 */
/***/ function(module, exports) {

/**
* Centers this Rectangle so that the center coordinates match the given x and y values.
*
* @method Phaser.Rectangle#centerOn
* @param {number} x - The x coordinate to place the center of the Rectangle at.
* @param {number} y - The y coordinate to place the center of the Rectangle at.
* @return {Phaser.Rectangle} This Rectangle object
*/
var CenterOn = function (rect, x, y)
{
    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = CenterOn;


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(25);

var Clone = function (source)
{
    return new Rectangle(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(109);

var ContainsPoint = function (rect, point)
{
    return Contains(rect, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 333 */
/***/ function(module, exports) {

//  Checks if rectB is fully contained within rectA

var ContainsRect = function (rectA, rectB)
{
    //  Volume check (if rectB volume > rectA then rectA cannot contain it)
    if ((rectB.width * rectB.height) > (rectA.width * rectA.height))
    {
        return false;
    }

    return (
        (rectB.x > rectA.x && rectB.x < rectA.right) &&
        (rectB.right > rectA.x && rectB.right < rectA.right) &&
        (rectB.y > rectA.y && rectB.y < rectA.bottom) && 
        (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 334 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ },
/* 335 */
/***/ function(module, exports) {

var Equals = function (rect, toCompare)
{
    return (
        rect.x === toCompare.x &&
        rect.y === toCompare.y &&
        rect.width === toCompare.width &&
        rect.height === toCompare.height
    );
};

module.exports = Equals;


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(60);

//  Fits the target rectangle into the source rectangle.
//  Preserves aspect ratio.
//  Scales and centers the target rectangle to the source rectangle

var FitInside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio < GetAspectRatio(source))
    {
        //  Taller than Wide
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Wider than Tall
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - (target.width / 2),
        (source.bottom / 2) - (target.height / 2)
    );
};

module.exports = FitInside;


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(60);

//  Fits the target rectangle around the source rectangle.
//  Preserves aspect ration.
//  Scales and centers the target rectangle to the source rectangle

var FitOutside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio > GetAspectRatio(source))
    {
        //  Wider than Tall
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Taller than Wide
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - target.width / 2,
        (source.bottom / 2) - target.height / 2
    );
};

module.exports = FitOutside;


/***/ },
/* 338 */
/***/ function(module, exports) {

var Floor = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);

    return rect;
};

module.exports = Floor;


/***/ },
/* 339 */
/***/ function(module, exports) {

var FloorAll = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);
    rect.width = Math.floor(rect.width);
    rect.height = Math.floor(rect.height);

    return rect;
};

module.exports = FloorAll;


/***/ },
/* 340 */
/***/ function(module, exports) {

//  The center of the Rectangle object, expressed as a Point object 

var GetCenter = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.right / 2;
    out.y = rect.bottom / 2;

    return out;
};

module.exports = GetCenter;


/***/ },
/* 341 */
/***/ function(module, exports) {

//  The size of the Rectangle object, expressed as a Point object 
//  with the values of the width and height properties.

var GetSize = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.width;
    out.y = rect.height;

    return out;
};

module.exports = GetSize;


/***/ },
/* 342 */
/***/ function(module, exports) {

//  Increases the size of the Rectangle object by the specified amounts.
//  The center point of the Rectangle object stays the same, and its size increases 
//  to the left and right by the x value, and to the top and the bottom by the y value.

var Inflate = function (rect, x, y)
{
    //  Get the current center
    var cx = rect.x + (rect.width / 2);
    var cy = rect.y + (rect.height / 2);

    //  Inflate
    rect.width = 2 * x;
    rect.height = 2 * y;

    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = Inflate;


/***/ },
/* 343 */
/***/ function(module, exports) {

//  Merges the target Rectangle with a list of points.
//  The points is an array of objects with public x/y properties.

var MergePoints = function (target, points)
{
    var minX = target.x;
    var maxX = target.right;
    var minY = target.y;
    var maxY = target.bottom;

    for (var i = 0; i < points.length; i++)
    {
        minX = Math.min(minX, points[i].x);
        maxX = Math.max(maxX, points[i].x);
        minY = Math.min(minY, points[i].y);
        maxY = Math.max(maxY, points[i].y);
    }

    target.x = minX;
    target.y = minY;
    target.width = maxX - minX;
    target.height = maxY - minY;

    return target;
};

module.exports = MergePoints;


/***/ },
/* 344 */
/***/ function(module, exports) {

//  Merges source rectangle into target rectangle and returns target
//  Neither rect should have negative widths or heights

var MergeRect = function (target, source)
{
    var minX = Math.min(target.x, source.x);
    var maxX = Math.max(target.right, source.right);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, source.y);
    var maxY = Math.max(target.bottom, source.bottom);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeRect;


/***/ },
/* 345 */
/***/ function(module, exports) {


var MergeXY = function (target, x, y)
{
    var minX = Math.min(target.x, x);
    var maxX = Math.max(target.right, x);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, y);
    var maxY = Math.max(target.bottom, y);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeXY;


/***/ },
/* 346 */
/***/ function(module, exports) {

var Offset = function (rect, x, y)
{
    rect.x += x;
    rect.y += y;

    return rect;
};

module.exports = Offset;


/***/ },
/* 347 */
/***/ function(module, exports) {

var OffsetPoint = function (rect, point)
{
    rect.x += point.x;
    rect.y += point.y;

    return rect;
};

module.exports = OffsetPoint;


/***/ },
/* 348 */
/***/ function(module, exports) {

var Overlaps = function (rectA, rectB)
{
    return (
        rectA.x < rectB.right && 
        rectA.right > rectB.x && 
        rectA.y < rectB.bottom && 
        rectA.bottom > rectB.y
    );
};

module.exports = Overlaps;


/***/ },
/* 349 */
/***/ function(module, exports) {

var Perimeter = function (rect)
{
    return 2 * (rect.width + rect.height);
};

module.exports = Perimeter;


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Random = function (rect, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = rect.x + (Math.random() * rect.width);
    out.y = rect.y + (Math.random() * rect.height);

    return out;
};

module.exports = Random;


/***/ },
/* 351 */
/***/ function(module, exports) {

/**
* Scales the width and height of this Rectangle by the given amounts.
* 
* @method Phaser.Rectangle#scale
* @param {number} x - The amount to scale the width of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the width, etc.
* @param {number} [y] - The amount to scale the height of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the height, etc.
* @return {Phaser.Rectangle} This Rectangle object
*/
var Scale = function (rect, x, y)
{
    if (y === undefined) { y = x; }

    rect.width *= x;
    rect.height *= y;

    return rect;
};

module.exports = Scale;


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(25);

var Union = function (rectA, rectB, output)
{
    if (output === undefined) { output = Rectangle(); }

    var x = Math.min(rectA.x, rectB.x);
    var y = Math.min(rectA.y, rectB.y);

    return output.set(
        x,
        y,
        Math.max(rectA.right, rectB.right) - x,
        Math.max(rectA.bottom, rectB.bottom) - y
    );
    
};

module.exports = Union;


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Rectangle

var Rectangle = __webpack_require__(25);

Rectangle.Area = __webpack_require__(327);
Rectangle.Ceil = __webpack_require__(328);
Rectangle.CeilAll = __webpack_require__(329);
Rectangle.CenterOn = __webpack_require__(330);
Rectangle.Clone = __webpack_require__(331);
Rectangle.Contains = __webpack_require__(109);
Rectangle.ContainsPoint = __webpack_require__(332);
Rectangle.ContainsRect = __webpack_require__(333);
Rectangle.CopyFrom = __webpack_require__(334);
Rectangle.Equals = __webpack_require__(335);
Rectangle.FitInside = __webpack_require__(336);
Rectangle.FitOutside = __webpack_require__(337);
Rectangle.Floor = __webpack_require__(338);
Rectangle.FloorAll = __webpack_require__(339);
Rectangle.GetAspectRatio = __webpack_require__(60);
Rectangle.GetCenter = __webpack_require__(340);
Rectangle.GetSize = __webpack_require__(341);
Rectangle.Inflate = __webpack_require__(342);
Rectangle.MergePoints = __webpack_require__(343);
Rectangle.MergeRect = __webpack_require__(344);
Rectangle.MergeXY = __webpack_require__(345);
Rectangle.Offset = __webpack_require__(346);
Rectangle.OffsetPoint = __webpack_require__(347);
Rectangle.Overlaps = __webpack_require__(348);
Rectangle.Perimeter = __webpack_require__(349);
Rectangle.Random = __webpack_require__(350);
Rectangle.Scale = __webpack_require__(351);
Rectangle.Union = __webpack_require__(352);

module.exports = Rectangle;


/***/ },
/* 354 */
/***/ function(module, exports) {

/**
* Takes the average of the source and backdrop colors.
*
* @method Lazer.Color.blendAverage
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Average = function (a, b)
{
    return (a + b) / 2;
};

module.exports = Average;


/***/ },
/* 355 */
/***/ function(module, exports) {

/**
* Subtracts the darker of the two constituent colors from the lighter.
* 
* Painting with white inverts the backdrop color; painting with black produces no change. 
*
* @method Lazer.Color.blendDifference
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ },
/* 356 */
/***/ function(module, exports) {

/**
* Produces an effect similar to that of the Difference mode, but lower in contrast. 
* Painting with white inverts the backdrop color; painting with black produces no change. 
*
* @method Lazer.Color.blendExclusion
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Exclusion =  function (a, b)
{
    return a + b - 2 * a * b / 255;
};

module.exports = Exclusion;


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

var Reflect = __webpack_require__(118);

/**
* Glow blend mode. This mode is a variation of reflect mode with the source and backdrop colors swapped.
*
* @method Lazer.Color.blendGlow
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Glow = function (a, b)
{
    return Reflect(b, a);
};

module.exports = Glow;


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

var Overlay = __webpack_require__(117);

/**
* Multiplies or screens the colors, depending on the source color value. 
* 
* If the source color is lighter than 0.5, the backdrop is lightened, as if it were screened; 
* this is useful for adding highlights to a scene. 
* 
* If the source color is darker than 0.5, the backdrop is darkened, as if it were multiplied; 
* this is useful for adding shadows to a scene. 
* 
* The degree of lightening or darkening is proportional to the difference between the source color and 0.5; 
* if it is equal to 0.5, the backdrop is unchanged.
* 
* Painting with pure black or white produces pure black or white. The effect is similar to shining a harsh spotlight on the backdrop. 
*
* @method Lazer.Color.blendHardLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var HardLight = function (a, b)
{
    return Overlay(b, a);
};

module.exports = HardLight;


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

var VividLight = __webpack_require__(120);

/**
* Runs blendVividLight on the source and backdrop colors.
* If the resulting color is 128 or more, it receives a value of 255; if less than 128, a value of 0.
* Therefore, all blended pixels have red, green, and blue channel values of either 0 or 255.
* This changes all pixels to primary additive colors (red, green, or blue), white, or black.
*
* @method Lazer.Color.blendHardMix
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var HardMix = function (a, b)
{
    return (VividLight(a, b) < 128) ? 0 : 255;
};

module.exports = HardMix;


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

var LinearBurn = __webpack_require__(115);
var LinearDodge = __webpack_require__(116);

/**
* This blend mode combines Linear Dodge and Linear Burn (rescaled so that neutral colors become middle gray).
* Dodge applies to values of top layer lighter than middle gray, and burn to darker values.
* The calculation simplifies to the sum of bottom layer and twice the top layer, subtract 128. The contrast decreases.
*
* @method Lazer.Color.blendLinearLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var LinearLight = function (a, b)
{
    return (b < 128) ? LinearBurn(a, 2 * b) : LinearDodge(a, (2 * (b - 128)));
};

module.exports = LinearLight;


/***/ },
/* 361 */
/***/ function(module, exports) {

/**
* Multiplies the backdrop and source color values.
* The result color is always at least as dark as either of the two constituent
* colors. Multiplying any color with black produces black;
* multiplying with white leaves the original color unchanged.
*
* @method Lazer.Color.blendMultiply
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Multiply = function (a, b)
{
    return (a * b) / 255;
};

module.exports = Multiply;


/***/ },
/* 362 */
/***/ function(module, exports) {

/**
* Negation blend mode.
*
* @method Lazer.Color.blendNegation
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Negation = function (a, b)
{
    return 255 - Math.abs(255 - a - b);
};

module.exports = Negation;


/***/ },
/* 363 */
/***/ function(module, exports) {

/**
* Blends the source color, ignoring the backdrop.
*
* @method Lazer.Color.blendNormal
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Normal = function (a)
{
    return a;
};

module.exports = Normal;


/***/ },
/* 364 */
/***/ function(module, exports) {

/**
* Phoenix blend mode. This subtracts the lighter color from the darker color, and adds 255, giving a bright result.
*
* @method Lazer.Color.blendPhoenix
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Phoenix = function (a, b)
{
    return Math.min(a, b) - Math.max(a, b) + 255;
};

module.exports = Phoenix;


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

var Darken = __webpack_require__(113);
var Lighten = __webpack_require__(114);

/**
* If the backdrop color (light source) is lighter than 50%, the blendDarken mode is used, and colors lighter than the backdrop color do not change.
* If the backdrop color is darker than 50% gray, colors lighter than the blend color are replaced, and colors darker than the blend color do not change.
*
* @method Lazer.Color.blendPinLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var PinLight = function (a, b)
{
    return (b < 128) ? Darken(a, 2 * b) : Lighten(a, (2 * (b - 128)));
};

module.exports = PinLight;


/***/ },
/* 366 */
/***/ function(module, exports) {

/**
* Multiplies the complements of the backdrop and source color values, then complements the result.
* The result color is always at least as light as either of the two constituent colors. 
* Screening any color with white produces white; screening with black leaves the original color unchanged. 
*
* @method Lazer.Color.blendScreen
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Screen = function (a, b)
{
    return 255 - (((255 - a) * (255 - b)) >> 8);
};

module.exports = Screen;


/***/ },
/* 367 */
/***/ function(module, exports) {

/**
* Darkens or lightens the colors, depending on the source color value. 
* 
* If the source color is lighter than 0.5, the backdrop is lightened, as if it were dodged; 
* this is useful for adding highlights to a scene. 
* 
* If the source color is darker than 0.5, the backdrop is darkened, as if it were burned in. 
* The degree of lightening or darkening is proportional to the difference between the source color and 0.5; 
* if it is equal to 0.5, the backdrop is unchanged.
* 
* Painting with pure black or white produces a distinctly darker or lighter area, but does not result in pure black or white. 
* The effect is similar to shining a diffused spotlight on the backdrop. 
*
* @method Lazer.Color.blendSoftLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var SoftLight = function (a, b)
{
    return (b < 128) ? (2 * ((a >> 1) + 64)) * (b / 255) : 255 - (2 * (255 - ((a >> 1) + 64)) * (255 - b) / 255);
};

module.exports = SoftLight;


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Graphics.BlendModes

module.exports = {

    Add: __webpack_require__(110),
    Average: __webpack_require__(354),
    ColorBurn: __webpack_require__(111),
    ColorDodge: __webpack_require__(112),
    Darken: __webpack_require__(113),
    Difference: __webpack_require__(355),
    Exclusion: __webpack_require__(356),
    Glow: __webpack_require__(357),
    HardLight: __webpack_require__(358),
    HardMix: __webpack_require__(359),
    Lighten: __webpack_require__(114),
    LinearBurn: __webpack_require__(115),
    LinearDodge: __webpack_require__(116),
    LinearLight: __webpack_require__(360),
    Multiply: __webpack_require__(361),
    Negation: __webpack_require__(362),
    Normal: __webpack_require__(363),
    Overlay: __webpack_require__(117),
    Phoenix: __webpack_require__(364),
    PinLight: __webpack_require__(365),
    Reflect: __webpack_require__(118),
    Screen: __webpack_require__(366),
    SoftLight: __webpack_require__(367),
    Subtract: __webpack_require__(119),
    VividLight: __webpack_require__(120)
    
};


/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

var Color = __webpack_require__(30);

var CSSMap = {
    aliceblue: [ 240, 248, 245 ],
    antiquewhite: [ 250, 235, 215 ],
    aqua: [ 0, 255, 255 ],
    aquamarine: [ 127, 255, 212 ],
    azure: [ 240, 255, 255 ],
    beige: [ 245, 245, 220 ],
    bisque: [ 255, 228, 196 ],
    black: [ 0, 0, 0 ],
    blanchedalmond: [ 255, 235, 205 ],
    blue: [ 0, 0, 255 ],
    blueviolet: [ 138, 43, 226 ],
    brown: [ 165, 42, 42 ],
    burlywood: [ 222, 184, 35 ],
    cadetblue: [ 95, 158, 160 ],
    chartreuse: [ 127, 255, 0 ],
    chocolate: [ 210, 105, 30 ],
    coral: [ 255, 127, 80 ],
    cornflowerblue: [ 100, 149, 237 ],
    cornsilk: [ 255, 248, 220 ],
    crimson: [ 220, 20, 60 ],
    darkblue: [ 0, 0, 139 ],
    darkcyan: [ 0, 139, 139 ],
    darkgoldenrod: [ 184, 134, 11 ],
    darkgray: [ 169, 169, 169 ],
    darkgreen: [ 0, 100, 0 ],
    darkgrey: [ 169, 169, 169 ],
    darkkhaki: [ 189, 183, 107 ],
    darkmagenta: [ 139, 0, 139 ],
    darkolivegreen: [ 85, 107, 47 ],
    darkorange: [ 255, 140, 0 ],
    darkorchid: [ 153, 50, 204 ],
    darkred: [ 139, 0, 0 ],
    darksalmon: [ 233, 150, 122 ],
    darkseagreen: [ 143, 188, 143 ],
    darkslateblue: [ 72, 61, 139 ],
    darkslategray: [ 47, 79, 79 ],
    darkslategrey: [ 47, 79, 79 ],
    darkturquoise: [ 0, 206, 209 ],
    darkviolet: [ 148, 0, 211 ],
    deeppink: [ 255, 20, 147 ],
    deepskyblue: [ 0, 191, 255 ],
    dimgray: [ 105, 105, 105 ],
    dimgrey: [ 105, 105, 105 ],
    dodgerblue: [ 30, 144, 255 ],
    firebrick: [ 178, 34, 34 ],
    floralwhite: [ 255, 250, 240 ],
    forestgreen: [ 34, 139, 34 ],
    fuchsia: [ 255, 0, 255 ],
    gainsboro: [ 220, 220, 220 ],
    ghostwhite: [ 248, 248, 255 ],
    gold: [ 255, 215, 0 ],
    goldenrod: [ 218, 165, 32 ],
    gray: [ 128, 128, 128 ],
    green: [ 0, 128, 0 ],
    greenyellow: [ 173, 255, 47 ],
    grey: [ 128, 128, 128 ],
    honeydew: [ 240, 255, 240 ],
    hotpink: [ 255, 105, 180 ],
    indianred: [ 205, 92, 92 ],
    indigo: [ 75, 0, 130 ],
    ivory: [ 255, 255, 240 ],
    khaki: [ 240, 230, 140 ],
    lavender: [ 230, 230, 250 ],
    lavenderblush: [ 255, 240, 245 ],
    lawngreen: [ 124, 252, 0 ],
    lemonchiffon: [ 255, 250, 205 ],
    lightblue: [ 173, 216, 230 ],
    lightcoral: [ 240, 128, 128 ],
    lightcyan: [ 224, 255, 255 ],
    lightgoldenrodyellow: [ 250, 250, 210 ],
    lightgray: [ 211, 211, 211 ],
    lightgreen: [ 144, 238, 144 ],
    lightgrey: [ 211, 211, 211 ],
    lightpink: [ 255, 182, 193 ],
    lightsalmon: [ 255, 160, 122 ],
    lightseagreen: [ 32, 178, 170 ],
    lightskyblue: [ 135, 206, 250 ],
    lightslategray: [ 119, 136, 153 ],
    lightslategrey: [ 119, 136, 153 ],
    lightsteelblue: [ 176, 196, 222 ],
    lightyellow: [ 255, 255, 224 ],
    lime: [ 0, 255, 0 ],
    limegreen: [ 50, 205, 50 ],
    linen: [ 250, 240, 230 ],
    maroon: [ 128, 0, 0 ],
    mediumaquamarine: [ 102, 205, 170 ],
    mediumblue: [ 0, 0, 205 ],
    mediumorchid: [ 186, 85, 211 ],
    mediumpurple: [ 147, 112, 219 ],
    mediumseagreen: [ 60, 179, 113 ],
    mediumslateblue: [ 123, 104, 238 ],
    mediumspringgreen: [ 0, 250, 154 ],
    mediumturquoise: [ 72, 209, 204 ],
    mediumvioletred: [ 199, 21, 133 ],
    midnightblue: [ 25, 25, 112 ],
    mintcream: [ 245, 255, 250 ],
    mistyrose: [ 255, 228, 225 ],
    moccasin: [ 255, 228, 181 ],
    navajowhite: [ 255, 222, 173 ],
    navy: [ 0, 0, 128 ],
    oldlace: [ 253, 245, 230 ],
    olive: [ 128, 128, 0 ],
    olivedrab: [ 107, 142, 35 ],
    orange: [ 255, 165, 0 ],
    orangered: [ 255, 69, 0 ],
    orchid: [ 218, 112, 214 ],
    palegoldenrod: [ 238, 232, 170 ],
    palegreen: [ 152, 251, 152 ],
    paleturquoise: [ 175, 238, 238 ],
    palevioletred: [ 219, 112, 147 ],
    papayawhip: [ 255, 239, 213 ],
    peachpuff: [ 255, 218, 185 ],
    peru: [ 205, 133, 63 ],
    pink: [ 255, 192, 203 ],
    plum: [ 221, 160, 221 ],
    powderblue: [ 176, 224, 230 ],
    purple: [ 128, 0, 128 ],
    rebeccapurple: [ 102, 51, 153 ],
    red: [ 255, 0, 0 ],
    rosybrown: [ 188, 143, 143 ],
    royalblue: [ 65, 105, 225 ],
    saddlebrown: [ 139, 69, 19 ],
    salmon: [ 250, 128, 114 ],
    sandybrown: [ 244, 164, 96 ],
    seagreen: [ 46, 139, 87 ],
    seashell: [ 255, 245, 238 ],
    sienna: [ 160, 82, 45 ],
    silver: [ 192, 192, 129 ],
    skyblue: [ 135, 206, 235 ],
    slateblue: [ 106, 90, 205 ],
    slategray: [ 112, 128, 144 ],
    slategrey: [ 112, 128, 144 ],
    snow: [ 255, 250, 250 ],
    springgreen: [ 0, 255, 127 ],
    steelblue: [ 70, 130, 180 ],
    tan: [ 210, 180, 140 ],
    teal: [ 0, 128, 128 ],
    thistle: [ 216, 191, 216 ],
    tomato: [ 255, 99, 71 ],
    turquoise: [ 64, 224, 208 ],
    violet: [ 238, 130, 238 ],
    wheat: [ 245, 222, 179 ],
    white: [ 255, 255, 255 ],
    whitesmoke: [ 245, 245, 245 ],
    yellow: [ 255, 255, 0 ],
    yellowgreen: [ 154, 205, 50 ]
};

var CSSToColor = function (name)
{
    name = name.toLowerCase();

    var color = new Color();
    var entry = CSSMap[name];

    if (entry)
    {
        color.setTo(entry[0], entry[1], entry[2], 255);
    }

    return color;
};

module.exports = CSSToColor;


/***/ },
/* 370 */
/***/ function(module, exports) {

var ColorToRGBA = function (color)
{
    var output = {
        r: color >> 16 & 0xFF,
        g: color >> 8 & 0xFF,
        b: color & 0xFF,
        a: 255
    };

    if (color > 16777215)
    {
        output.a = color >>> 24;
    }

    return output;
};

module.exports = ColorToRGBA;


/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

var Color = __webpack_require__(30);
var HueToComponent = __webpack_require__(125);

var HSLToColor = function (h, s, l)
{
    // achromatic by default
    var r = l;
    var g = l;
    var b = l;

    if (s !== 0)
    {
        var q = (l < 0.5) ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = HueToComponent(p, q, h + 1 / 3);
        g = HueToComponent(p, q, h);
        b = HueToComponent(p, q, h - 1 / 3);
    }

    var color = new Color();

    return color.setGLTo(r, g, b, 1);
};

module.exports = HSLToColor;


/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

var HSVToRGB = __webpack_require__(123);

/**
* Get HSV color wheel values in an array which will be 360 elements in size.
*
* @method Phaser.Color.HSVColorWheel
* @static
* @param {number} [s=1] - The saturation, in the range 0 - 1.
* @param {number} [v=1] - The value, in the range 0 - 1.
* @return {array} An array containing 360 elements corresponding to the HSV color wheel.
*/
var HSVColorWheel = function (s, v)
{
    if (s === undefined) { s = 1; }
    if (v === undefined) { v = 1; }

    var colors = [];

    for (var c = 0; c <= 359; c++)
    {
        colors.push(HSVToRGB(c / 359, s, v));
    }

    return colors;
};

module.exports = HSVColorWheel;


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(147);

var RGBWithRGB = function (r1, g1, b1, r2, g2, b2, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    var t = index / length;

    return {
        r: Linear(r1, r2, t),
        g: Linear(g1, g2, t),
        b: Linear(b1, b2, t)
    };
};

var ColorWithColor = function (color1, color2, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index);
};

var ColorWithRGB = function  (color, r, g, b, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    return RGBWithRGB(color.r, color.g, color.b, r, g, b, length, index);
};


module.exports = {

    RGBWithRGB: RGBWithRGB,
    ColorWithRGB: ColorWithRGB,
    ColorWithColor: ColorWithColor

};


/***/ },
/* 374 */
/***/ function(module, exports) {

/**
* Converts an RGB color value to HSV (hue, saturation and value).
* Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
* Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].
* Based on code by Michael Jackson (https://github.com/mjijackson)
*
* @method Lazer.Color.RGBtoHSV
* @static
* @param {number} r - The red color component, in the range 0 - 255.
* @param {number} g - The green color component, in the range 0 - 255.
* @param {number} b - The blue color component, in the range 0 - 255.
* @return {object} An object with the hue, saturation and value set in the h, s and v properties.
*/
var RGBToHSV = function (r, g, b)
{
    r /= 255;
    g /= 255;
    b /= 255;

    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var d = max - min;

    // achromatic by default
    var h = 0;
    var s = (max === 0) ? 0 : d / max;
    var v = max;

    if (max !== min)
    {
        if (max === r)
        {
            h = (g - b) / d + ((g < b) ? 6 : 0);
        }
        else if (max === g)
        {
            h = (b - r) / d + 2;
        }
        else if (max === b)
        {
            h = (r - g) / d + 4;
        }

        h /= 6;
    }

    return { h: h, s: s, v: v };
};

module.exports = RGBToHSV;


/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

var ComponentToHex = __webpack_require__(121);

var RGBToString = function (r, g, b, a, prefix)
{
    if (a === undefined) { a = 255; }
    if (prefix === undefined) { prefix = '#'; }

    if (prefix === '#')
    {
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    else
    {
        return '0x' + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
    }
};

module.exports = RGBToString;


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

var Between = __webpack_require__(64);

var RandomRGB = function (min, max)
{
    if (min === undefined) { min = 0; }
    if (max === undefined) { max = 255; }

    return {
        r: Between(min, max),
        g: Between(min, max),
        b: Between(min, max)
    };
};

module.exports = RandomRGB;


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Graphics.Color

var Color = __webpack_require__(30);

Color.ColorToRGBA = __webpack_require__(370);
Color.ComponentToHex = __webpack_require__(121);
Color.CSSToColor = __webpack_require__(369);
Color.GetColor = __webpack_require__(61);
Color.GetColor32 = __webpack_require__(122);
Color.HexStringToColor = __webpack_require__(124);
Color.HSLToColor = __webpack_require__(371);
Color.HSVColorWheel = __webpack_require__(372);
Color.HSVToRGB = __webpack_require__(123);
Color.HueToComponent = __webpack_require__(125);
Color.IntegerToColor = __webpack_require__(126);
Color.IntegerToRGB = __webpack_require__(127);
Color.Interpolate = __webpack_require__(373);
Color.RandomRGB = __webpack_require__(376);
Color.RGBStringToColor = __webpack_require__(128);
Color.RGBToHSV = __webpack_require__(374);
Color.RGBToString = __webpack_require__(375);
Color.ValueToColor = __webpack_require__(129);

module.exports = Color;


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

//  GlobalInputManager

var Keyboard = __webpack_require__(130);

var GlobalInputManager = function (game, gameConfig)
{
    this.game = game;

    this.gameConfig = gameConfig;

    this.keyboard = new Keyboard(this);
};

GlobalInputManager.prototype.constructor = GlobalInputManager;

GlobalInputManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.Input.KeyboardManager#boot
    * @private
    */
    boot: function ()
    {
        this.keyboard.boot();
    },

    update: function ()
    {
        this.keyboard.update();
    }

};

module.exports = GlobalInputManager;


/***/ },
/* 379 */
/***/ function(module, exports) {

//  Return boolean (true if it reached the end of the combo, false if not)

var AdvanceKeyCombo = function (event, combo)
{
    combo.timeLastMatched = event.timeStamp;
    combo.index++;

    if (combo.index === combo.size)
    {
        return true;
    }
    else
    {
        combo.current = combo.keyCodes[combo.index];
        return false;
    }
};

module.exports = AdvanceKeyCombo;


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var KeyComboMatchEvent = function (keyCombo, keyboardEvent)
{
    Event.call(this, 'KEY_COMBO_MATCH_EVENT');

    this.target = keyCombo;

    this.data = keyboardEvent;
};

KeyComboMatchEvent.prototype = Object.create(Event.prototype);
KeyComboMatchEvent.prototype.constructor = KeyComboMatchEvent;

module.exports = KeyComboMatchEvent;


/***/ },
/* 381 */
/***/ function(module, exports) {

var ResetKeyCombo = function (combo)
{
    combo.current = combo.keyCodes[0];
    combo.index = 0;
    combo.timeLastMatched = 0;
    combo.matched = false;
    combo.timeMatched = 0;

    return combo;
};

module.exports = ResetKeyCombo;


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var KeyDownEvent = function (keyboardEvent)
{
    Event.call(this, 'KEY_DOWN_EVENT');

    this.data = keyboardEvent;
};

KeyDownEvent.prototype = Object.create(Event.prototype);
KeyDownEvent.prototype.constructor = KeyDownEvent;

module.exports = KeyDownEvent;


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var KeyUpEvent = function (keyboardEvent)
{
    Event.call(this, 'KEY_UP_EVENT');

    this.data = keyboardEvent;
};

KeyUpEvent.prototype = Object.create(Event.prototype);
KeyUpEvent.prototype.constructor = KeyUpEvent;

module.exports = KeyUpEvent;


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);
var KeyCodes = __webpack_require__(62);

var events = {
    KEY_DOWN_EVENT: __webpack_require__(382),
    KEY_UP_EVENT: __webpack_require__(383),
    _UP: [],
    _DOWN: []
};

function createKeyEvent (type)
{
    var KeyEvent = function (keyboardEvent)
    {
        Event.call(this, type);

        this.data = keyboardEvent;
    };

    KeyEvent.prototype = Object.create(Event.prototype);
    KeyEvent.prototype.constructor = KeyEvent;

    return KeyEvent;
}

//  Inject the KeyCode events

for (var code in KeyCodes)
{
    //  The Key Down Event Types

    var downType = 'KEY_DOWN_' + code;
    var upType = 'KEY_UP_' + code;

    events._DOWN[KeyCodes[code]] = createKeyEvent(downType);
    events._UP[KeyCodes[code]] = createKeyEvent(upType);

    //  More friendly aliases to the main events
    events[downType] = events._DOWN[KeyCodes[code]];
    events[upType] = events._UP[KeyCodes[code]];
}

module.exports = events;


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Input.Keyboard

module.exports = {

    KeyboardManager: __webpack_require__(130),

    Key: __webpack_require__(133),
    KeyCodes: __webpack_require__(62),

    KeyCombo: __webpack_require__(131),

    JustDown: __webpack_require__(387),
    JustUp: __webpack_require__(388),
    DownDuration: __webpack_require__(386),
    UpDuration: __webpack_require__(391)
    
};


/***/ },
/* 386 */
/***/ function(module, exports) {

/**
* Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
* or was pressed down longer ago than then given duration.
* 
* @method Phaser.Key#downDuration
* @param {number} [duration=50] - The duration within which the key is considered as being just pressed. Given in ms.
* @return {boolean} True if the key was pressed down within the given duration.
*/
var DownDuration = function (key, duration)
{
    if (duration === undefined) { duration = 50; }

    return (key.isDown && key.duration < duration);
};

module.exports = DownDuration;


/***/ },
/* 387 */
/***/ function(module, exports) {

/**
* The justDown value allows you to test if this Key has just been pressed down or not.
* When you check this value it will return `true` if the Key is down, otherwise `false`.
* You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.
* This allows you to use it in situations where you want to check if this key is down without using a Signal, such as in a core game loop.
* 
* @property {boolean} justDown
* @memberof Phaser.Key
* @default false
*/

var JustDown = function (key)
{
    var current = false;

    if (key.isDown)
    {
        current = key._justDown;
        key._justDown = false;
    }

    return current;
};

module.exports = JustDown;


/***/ },
/* 388 */
/***/ function(module, exports) {

/**
* The justUp value allows you to test if this Key has just been released or not.
* When you check this value it will return `true` if the Key is up, otherwise `false`.
* You can only call justUp once per key release. It will only return `true` once, until the Key is pressed down and released again.
* This allows you to use it in situations where you want to check if this key is up without using a Signal, such as in a core game loop.
* 
* @property {boolean} justUp
* @memberof Phaser.Key
* @default false
*/

var JustUp = function (key)
{
    var current = false;

    if (key.isDown)
    {
        current = key._justUp;
        key._justUp = false;
    }

    return current;
};

module.exports = JustUp;


/***/ },
/* 389 */
/***/ function(module, exports) {


var ProcessKeyDown = function (key, event)
{
    key.originalEvent = event;

    if (key.preventDefault)
    {
        event.preventDefault();
    }

    if (!key.enabled)
    {
        return;
    }

    key.altKey = event.altKey;
    key.ctrlKey = event.ctrlKey;
    key.shiftKey = event.shiftKey;
    key.location = event.location;

    key.isDown = true;
    key.isUp = false;
    key.timeDown = event.timeStamp;
    key.duration = 0;
    key.repeats++;

    key._justDown = true;
    key._justUp = false;

    return key;
};

module.exports = ProcessKeyDown;


/***/ },
/* 390 */
/***/ function(module, exports) {


var ProcessKeyUp = function (key, event)
{
    key.originalEvent = event;

    if (key.preventDefault)
    {
        event.preventDefault();
    }

    if (!key.enabled)
    {
        return;
    }

    key.isDown = false;
    key.isUp = true;
    key.timeUp = event.timeStamp;
    key.duration = key.timeUp - key.timeDown;
    key.repeats = 0;

    key._justDown = false;
    key._justUp = true;

    return key;
};

module.exports = ProcessKeyUp;


/***/ },
/* 391 */
/***/ function(module, exports) {

/**
* Returns `true` if the Key was released within the `duration` value given, or `false` if it either isn't up,
* or was released longer ago than then given duration.
* 
* @method Phaser.Key#upDuration
* @param {number} [duration=50] - The duration within which the key is considered as being just released. Given in ms.
* @return {boolean} True if the key was released within the given duration.
*/
var UpDuration = function (key, duration)
{
    if (duration === undefined) { duration = 50; }

    return (key.isUp && key.duration < duration);
};

module.exports = UpDuration;


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var Set = __webpack_require__(516);
var XHRSettings = __webpack_require__(63);
var Event = __webpack_require__(397);
var EventDispatcher = __webpack_require__(23);

var BaseLoader = function ()
{
    //  To finish the loader ...
    //  
    //  3) Progress update

    this.events = new EventDispatcher();

    //  Move to a 'setURL' method?
    this.baseURL = '';
    this.path = '';

    //  Read from Game / State Config
    this.enableParallel = true;
    this.maxParallelDownloads = 4;

    //  xhr specific global settings (can be overridden on a per-file basis)
    this.xhr = XHRSettings();

    this.crossOrigin = undefined;

    this.list = new Set();
    this.inflight = new Set();
    this.failed = new Set();
    this.queue = new Set();
    this.storage = new Set();

    this._state = CONST.LOADER_IDLE;
};

BaseLoader.prototype.contructor = BaseLoader;

BaseLoader.prototype = {

    addFile: function (file)
    {
        if (!this.isReady())
        {
            return -1;
        }

        file.path = this.path;

        this.list.set(file);

        return this;
    },

    //  Is the Loader actively loading (or processing loaded files)
    isLoading: function ()
    {
        return (this._state === CONST.LOADER_LOADING || this._state === CONST.LOADER_PROCESSING);
    },

    //  Is the Loader ready to start a new load?
    isReady: function ()
    {
        return (this._state === CONST.LOADER_IDLE || this._state === CONST.LOADER_COMPLETE || this._state === CONST.LOADER_FAILED);
    },

    start: function ()
    {
        console.log(this.state.settings.key, '- BaseLoader start. Files to load:', this.list.size);

        if (!this.isReady())
        {
            return;
        }

        this.events.dispatch(new Event.LOADER_START_EVENT(this));

        if (this.list.size === 0)
        {
            this.finishedLoading();
        }
        else
        {
            this._state = CONST.LOADER_LOADING;

            this.failed.clear();
            this.inflight.clear();
            this.queue.clear();

            this.queue.debug = true;

            this.updateProgress();

            this.processLoadQueue();
        }
    },

    updateProgress: function ()
    {

    },

    processLoadQueue: function ()
    {
        // console.log('======== BaseLoader processLoadQueue');
        // console.log('List size', this.list.size);
        // console.log(this.inflight.size, 'items still in flight. Can load another', (this.maxParallelDownloads - this.inflight.size));

        var _this = this;

        this.list.each(function (file)
        {
            if (file.state === CONST.FILE_PENDING && _this.inflight.size < _this.maxParallelDownloads)
            {
                _this.inflight.set(file);

                _this.list.delete(file);

                _this.loadFile(file);
            }

            if (_this.inflight.size === _this.maxParallelDownloads)
            {
                //  Tells the Set iterator to abort
                return false;
            }

        });
    },

    //  private
    loadFile: function (file)
    {
        // console.log('LOADING', file.key);

        //  If the file doesn't have its own crossOrigin set,
        //  we'll use the Loaders (which is undefined by default)
        if (!file.crossOrigin)
        {
            file.crossOrigin = this.crossOrigin;
        }

        file.load(this.nextFile.bind(this), this.baseURL);
    },

    nextFile: function (previousFile, success)
    {
        // console.log('LOADED:', previousFile.src, success);

        //  Move the file that just loaded from the inflight list to the queue or failed Set

        if (success)
        {
            this.queue.set(previousFile);
        }
        else
        {
            this.failed.set(previousFile);
        }

        this.inflight.delete(previousFile);

        if (this.list.size > 0)
        {
            // console.log('nextFile - still something in the list');
            this.processLoadQueue();
        }
        else if (this.inflight.size === 0)
        {
            // console.log('nextFile calling finishedLoading');
            this.finishedLoading();
        }
    },

    finishedLoading: function ()
    {
        // console.log('---> BaseLoader.finishedLoading PROCESSING', this.queue.size, 'files');

        this._state = CONST.LOADER_PROCESSING;

        this.storage.clear();

        var _this = this;

        this.queue.each(function (file)
        {
            // console.log('%c Calling process on ' + file.key, 'color: #000000; background: #ffff00;');

            file.onProcess(_this.processUpdate.bind(_this));
        });
    },

    //  Called automatically by the File when it has finished processing
    processUpdate: function (file)
    {
        // console.log('-> processUpdate', file.key, file.state);

        //  This file has failed to load, so move it to the failed Set
        if (file.state === CONST.FILE_ERRORED)
        {
            this.failed.set(file);

            if (file.linkFile)
            {
                this.queue.delete(file.linkFile);
            }

            return this.removeFromQueue(file);
        }

        //  If we got here, then the file loaded

        //  Special handling for multi-part files

        if (file.linkFile)
        {
            if (file.state === CONST.FILE_COMPLETE && file.linkFile.state === CONST.FILE_COMPLETE)
            {
                //  Partner has loaded, so add them both to Storage

                this.storage.set({ type: file.linkType, fileA: file, fileB: file.linkFile });

                this.queue.delete(file.linkFile);

                this.removeFromQueue(file);
            }
        }
        else
        {
            this.storage.set(file);

            this.removeFromQueue(file);
        }
    },

    removeFromQueue: function (file)
    {
        this.queue.delete(file);

        if (this.queue.size === 0 && this._state === CONST.LOADER_PROCESSING)
        {
            //  We've processed all the files we loaded
            this.processComplete();
        }
    },

    processComplete: function ()
    {
        console.log(this.state.settings.key, '- Loader Complete. Loaded:', this.storage.size, 'Failed:', this.failed.size);

        this.list.clear();
        this.inflight.clear();
        this.queue.clear();

        if (this.processCallback)
        {
            this.processCallback();
        }

        this._state = CONST.LOADER_COMPLETE;

        this.events.dispatch(new Event.LOADER_COMPLETE_EVENT(this));
    },

    reset: function ()
    {
        this.list.clear();
        this.inflight.clear();
        this.failed.clear();
        this.queue.clear();
        this.storage.clear();

        this.events.removeAll('LOADER_START_EVENT');
        this.events.removeAll('LOADER_COMPLETE_EVENT');

        this.tag = '';
        this.path = '';
        this.baseURL = '';

        this._state = CONST.LOADER_IDLE;
    },

    destroy: function ()
    {
        this.reset();
        this._state = CONST.LOADER_DESTROYED;
    }

};

module.exports = BaseLoader;


/***/ },
/* 393 */
/***/ function(module, exports) {

var GetURL = function (file, baseURL)
{
    if (!file.url)
    {
        return false;
    }

    if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/))
    {
        return file.url;
    }
    else
    {
        return baseURL + file.url;
    }
};

module.exports = GetURL;


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

var MergeXHRSettings = __webpack_require__(134);

var XHRLoader = function (file, globalXHRSettings)
{
    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);

    var xhr = new XMLHttpRequest();

    xhr.open('GET', file.src, config.async, config.user, config.password);

    xhr.responseType = file.xhrSettings.responseType;
    xhr.timeout = config.timeout;

    if (config.header && config.headerValue)
    {
        xhr.setRequestHeader(config.header, config.headerValue);
    }

    if (config.overrideMimeType)
    {
        xhr.overrideMimeType(config.overrideMimeType);
    }

    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)

    xhr.onload = file.onLoad.bind(file);
    xhr.onerror = file.onError.bind(file);
    xhr.onprogress = file.onProgress.bind(file);

    //  This is the only standard method, the ones above are browser additions (maybe not universal?)
    // xhr.onreadystatechange

    xhr.send();

    return xhr;
};

module.exports = XHRLoader;


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var LoaderCompleteEvent = function (loader)
{
    Event.call(this, 'LOADER_COMPLETE_EVENT');

    this.loader = loader;
};

LoaderCompleteEvent.prototype = Object.create(Event.prototype);
LoaderCompleteEvent.prototype.constructor = LoaderCompleteEvent;

module.exports = LoaderCompleteEvent;


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var LoaderStartEvent = function (loader)
{
    Event.call(this, 'LOADER_START_EVENT');

    this.loader = loader;
};

LoaderStartEvent.prototype = Object.create(Event.prototype);
LoaderStartEvent.prototype.constructor = LoaderStartEvent;

module.exports = LoaderStartEvent;


/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    LOADER_START_EVENT: __webpack_require__(396),
    LOADER_COMPLETE_EVENT: __webpack_require__(395)

};


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(37);
var JSONFile = __webpack_require__(135);

var AtlasJSONFile = function (key, textureURL, atlasURL, path, textureXhrSettings, atlasXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new JSONFile(key, atlasURL, path, atlasXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'atlasjson';
    data.linkType = 'atlasjson';

    return { texture: image, data: data };
};

module.exports = AtlasJSONFile;


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(31);

var BinaryFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.binary\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.bin';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'binary', key, url, 'arraybuffer', xhrSettings);
};

BinaryFile.prototype = Object.create(File.prototype);
BinaryFile.prototype.constructor = BinaryFile;

BinaryFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.response;

    this.onComplete();

    callback(this);
};

module.exports = BinaryFile;


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(37);
var XMLFile = __webpack_require__(136);

var BitmapFontFile = function (key, textureURL, xmlURL, path, textureXhrSettings, xmlXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new XMLFile(key, xmlURL, path, xmlXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'bitmapfont';
    data.linkType = 'bitmapfont';

    return { texture: image, data: data };
};

module.exports = BitmapFontFile;


/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(31);

var GLSLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.glsl';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'glsl', key, url, 'text', xhrSettings);
};

GLSLFile.prototype = Object.create(File.prototype);
GLSLFile.prototype.constructor = GLSLFile;

GLSLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = GLSLFile;


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(37);

//  config can include: frameWidth, frameHeight, startFrame, endFrame, margin, spacing

var SpriteSheet = function (key, url, config, path, xhrSettings)
{
    var image = new ImageFile(key, url, path, xhrSettings, config);

    //  Override the File type
    image.type = 'spritesheet';

    return image;
};

module.exports = SpriteSheet;


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(31);

var TextFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.text';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'text', key, url, 'text', xhrSettings);
};

TextFile.prototype = Object.create(File.prototype);
TextFile.prototype.constructor = TextFile;

TextFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = TextFile;


/***/ },
/* 404 */
/***/ function(module, exports) {

var Average = function (values)
{
    var sum = 0;

    for (var i = 0; i < values.length; i++)
    {
        sum += (+values[i]);
    }

    return sum / values.length;
};

module.exports = Average;


/***/ },
/* 405 */
/***/ function(module, exports) {

var CeilTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.ceil(value * p) / p;
};

module.exports = CeilTo;


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(7);

var DegToRad = function (degrees)
{
    return degrees * CONST.DEG_TO_RAD;
};

module.exports = DegToRad;


/***/ },
/* 407 */
/***/ function(module, exports) {

var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ },
/* 408 */
/***/ function(module, exports) {

var FloatBetween = function (min, max)
{
    return Math.random() * (max - min + 1) + min;
};

module.exports = FloatBetween;


/***/ },
/* 409 */
/***/ function(module, exports) {

var FloorTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.floor(value * p) / p;
};

module.exports = FloorTo;


/***/ },
/* 410 */
/***/ function(module, exports) {


var MaxAdd = function (value, amount, max)
{
    return Math.min(value + amount, max);
};

module.exports = MaxAdd;


/***/ },
/* 411 */
/***/ function(module, exports) {

var MinSub = function (value, amount, min)
{
    return Math.max(value - amount, min);
};

module.exports = MinSub;


/***/ },
/* 412 */
/***/ function(module, exports) {

var Percent = function (a, b, base)
{
    if (base === undefined) { base = 0; }

    if (a > b || base > b)
    {
        return 1;
    }
    else if (a < base || base > a)
    {
        return 0;
    }
    else
    {
        return (a - base) / b;
    }
};

module.exports = Percent;


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(7);

var RadToDeg = function (radians)
{
    return radians * CONST.RAD_TO_DEG;
};

module.exports = RadToDeg;


/***/ },
/* 414 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var Rotate = function (point, angle)
{
    var x = point.x;
    var y = point.y;

    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));
    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));

    return point;
};

module.exports = Rotate;


/***/ },
/* 415 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAround = function (point, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = point.x - x;
    var ty = point.y - y;

    point.x = tx * c - ty * s + x;
    point.y = tx * s + ty * c + y;

    return point;
};

module.exports = RotateAround;


/***/ },
/* 416 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAroundDistance = function (point, x, y, angle, distance)
{
    var t = angle + Math.atan2(point.y - y, point.x - x);

    point.x = x + (distance * Math.cos(t));
    point.y = y + (distance * Math.sin(t));

    return point;
};

module.exports = RotateAroundDistance;


/***/ },
/* 417 */
/***/ function(module, exports) {

var RoundTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.round(value * p) / p;
};

module.exports = RoundTo;


/***/ },
/* 418 */
/***/ function(module, exports) {


var SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)
{
    if (sinAmp === undefined) { sinAmp = 1; }
    if (cosAmp === undefined) { cosAmp = 1; }
    if (frequency === undefined) { frequency = 1; }

    frequency *= Math.PI / length;

    var cos = [];
    var sin = [];

    for (var c = 0; c < length; c++)
    {
        cosAmp -= sinAmp * frequency;
        sinAmp += cosAmp * frequency;

        cos[c] = cosAmp;
        sin[c] = sinAmp;
    }

    return {
        sin: sin,
        cos: cos,
        length: length
    };
};

module.exports = SinCosTableGenerator;


/***/ },
/* 419 */
/***/ function(module, exports) {

var SmoothStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * (3 - 2 * x);
};

module.exports = SmoothStep;


/***/ },
/* 420 */
/***/ function(module, exports) {

var SmootherStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * x * (x * (x * 6 - 15) + 10);
};

module.exports = SmootherStep;


/***/ },
/* 421 */
/***/ function(module, exports) {

/**
* Checks if two values are within the given tolerance of each other.
*
* @method Phaser.Math#within
* @param {number} a - The first number to check
* @param {number} b - The second number to check
* @param {number} tolerance - The tolerance. Anything equal to or less than this is considered within the range.
* @return {boolean} True if a is <= tolerance of b.
* @see {@link Phaser.Math.fuzzyEqual}
*/
var Within = function (a, b, tolerance)
{
    return (Math.abs(a - b) <= tolerance);
};

module.exports = Within;


/***/ },
/* 422 */
/***/ function(module, exports) {

var Between = function (x1, y1, x2, y2)
{
    return Math.atan2(y2 - y1, x2 - x1);
};

module.exports = Between;


/***/ },
/* 423 */
/***/ function(module, exports) {

var BetweenPoints = function (point1, point2)
{
    return Math.atan2(point2.y - point1.y, point2.x - point1.x);
};

module.exports = BetweenPoints;


/***/ },
/* 424 */
/***/ function(module, exports) {

var BetweenPointsY = function (point1, point2)
{
    return Math.atan2(point2.x - point1.x, point2.y - point1.y);
};

module.exports = BetweenPointsY;


/***/ },
/* 425 */
/***/ function(module, exports) {

var BetweenY = function (x1, y1, x2, y2)
{
    return Math.atan2(x2 - x1, y2 - y1);
};

module.exports = BetweenY;


/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(143);

var Reverse = function (angle)
{
    return Normalize(angle + Math.PI);
};

module.exports = Reverse;


/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(7);

/**
* Rotates currentAngle towards targetAngle, taking the shortest rotation distance.
* The lerp argument is the amount to rotate by in this call.
* 
* @method Phaser.Math#rotateToAngle
* @param {number} currentAngle - The current angle, in radians.
* @param {number} targetAngle - The target angle to rotate to, in radians.
* @param {number} [lerp=0.05] - The lerp value to add to the current angle.
* @return {number} The adjusted angle.
*/
var RotateTo = function (currentAngle, targetAngle, lerp)
{
    if (lerp === undefined) { lerp = 0.05; }

    if (currentAngle === targetAngle)
    {
        return currentAngle;
    }

    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))
    {
        currentAngle = targetAngle;
    }
    else
    {
        if (Math.abs(targetAngle - currentAngle) > Math.PI)
        {
            if (targetAngle < currentAngle)
            {
                targetAngle += MATH_CONST.PI2;
            }
            else
            {
                targetAngle -= MATH_CONST.PI2;
            }
        }

        if (targetAngle > currentAngle)
        {
            currentAngle += lerp;
        }
        else if (targetAngle < currentAngle)
        {
            currentAngle -= lerp;
        }
    }

    return currentAngle;
};

module.exports = RotateTo;


/***/ },
/* 428 */
/***/ function(module, exports) {

/**
* Gets the shortest angle between `angle1` and `angle2`.
* Both angles must be in the range -180 to 180, which is the same clamped
* range that `sprite.angle` uses, so you can pass in two sprite angles to
* this method, and get the shortest angle back between the two of them.
*
* The angle returned will be in the same range. If the returned angle is
* greater than 0 then it's a counter-clockwise rotation, if < 0 then it's
* a clockwise rotation.
* 
* @method Phaser.Math#getShortestAngle
* @param {number} angle1 - The first angle. In the range -180 to 180.
* @param {number} angle2 - The second angle. In the range -180 to 180.
* @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.
*/
var ShortestBetween = function (angle1, angle2)
{
    var difference = angle2 - angle1;

    if (difference === 0)
    {
        return 0;
    }

    var times = Math.floor((difference - (-180)) / 360);

    return difference - (times * 360);

};

module.exports = ShortestBetween;


/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(422),
    BetweenY: __webpack_require__(425),
    BetweenPoints: __webpack_require__(423),
    BetweenPointsY: __webpack_require__(424),
    Reverse: __webpack_require__(426),
    RotateTo: __webpack_require__(427),
    ShortestBetween: __webpack_require__(428),
    Normalize: __webpack_require__(143),
    Wrap: __webpack_require__(144),
    WrapDegrees: __webpack_require__(145)

};


/***/ },
/* 430 */
/***/ function(module, exports) {

var DistancePower = function (x1, y1, x2, y2, pow)
{
    if (pow === undefined) { pow = 2; }

    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
};

module.exports = DistancePower;


/***/ },
/* 431 */
/***/ function(module, exports) {

var DistanceSquared = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return dx * dx + dy * dy;
};

module.exports = DistanceSquared;


/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(146),
    Power: __webpack_require__(430),
    Squared: __webpack_require__(431)

};


/***/ },
/* 433 */
/***/ function(module, exports) {

function In (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return v * v * ((overshoot + 1) * v - overshoot);
}

function Out (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return --v * v * ((overshoot + 1) * v + overshoot) + 1;
}

function InOut (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    var s = overshoot * 1.525;

    if ((v *= 2) < 1)
    {
        return 0.5 * (v * v * ((s + 1) * v - s));
    }
    else
    {
        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 434 */
/***/ function(module, exports) {

function In (v)
{
    v = 1 - v;

    if (v < 1 / 2.75)
    {
        return 1 - (7.5625 * v * v);
    }
    else if (v < 2 / 2.75)
    {
        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
    }
    else if (v < 2.5 / 2.75)
    {
        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
    }
    else
    {
        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
    }
}

function Out (v)
{
    if (v < 1 / 2.75)
    {
        return 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }
}

function InOut (v)
{
    var reverse = false;

    if (v < 0.5)
    {
        v = 1 - (v * 2);
        reverse = true;
    }
    else
    {
        v = (v * 2) - 1;
    }

    if (v < 1 / 2.75)
    {
        v = 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }

    if (reverse)
    {
        return (1 - v) * 0.5;
    }
    else
    {
        return v * 0.5 + 0.5;
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 435 */
/***/ function(module, exports) {

function In (v)
{
    return 1 - Math.sqrt(1 - v * v);
}

function Out (v)
{
    return Math.sqrt(1 - (--v * v));
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return -0.5 * (Math.sqrt(1 - v * v) - 1);
    }
    else
    {
        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 436 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v;
}

function Out (v)
{
    return --v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 437 */
/***/ function(module, exports) {

function In (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
    }
}

function Out (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);
    }
}

function InOut (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        if ((v *= 2) < 1)
        {
            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
        }
        else
        {
            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
        }
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 438 */
/***/ function(module, exports) {

function In (v)
{
    return Math.pow(2, 10 * (v - 1)) - 0.001;
}

function Out (v)
{
    return 1 - Math.pow(2, -10 * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * Math.pow(2, 10 * (v - 1));
    }
    else
    {
        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 439 */
/***/ function(module, exports) {

/**
* Linear Easing (no variation).
*
* @method Lazer.Easing.Linear#None
* @param {number} v - The value to be tweened.
* @returns {number} v.
*/
var Linear = function (v)
{
    return v;
};

module.exports = Linear;


/***/ },
/* 440 */
/***/ function(module, exports) {

function In (v)
{
    return v * v;
}

function Out (v)
{
    return v * (2 - v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v;
    }
    else
    {
        return -0.5 * (--v * (v - 2) - 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 441 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v * v;
}

function Out (v)
{
    return 1 - (--v * v * v * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v;
    }
    else
    {
        return -0.5 * ((v -= 2) * v * v * v - 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 442 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v * v * v;
}

function Out (v)
{
    return --v * v * v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 443 */
/***/ function(module, exports) {

function In (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 1 - Math.cos(v * Math.PI / 2);
    }
}

function Out (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return Math.sin(v * Math.PI / 2);
    }
}

function InOut (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 0.5 * (1 - Math.cos(Math.PI * v));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Back: __webpack_require__(433),
    Bounce: __webpack_require__(434),
    Circular: __webpack_require__(435),
    Cubic: __webpack_require__(436),
    Elastic: __webpack_require__(437),
    Expo: __webpack_require__(438),
    Linear: __webpack_require__(439),
    Quadratic: __webpack_require__(440),
    Quartic: __webpack_require__(441),
    Quintic: __webpack_require__(442),
    Sine: __webpack_require__(443)

};


/***/ },
/* 445 */
/***/ function(module, exports) {

var Ceil = function (value, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.ceil(value - epsilon);
};

module.exports = Ceil;


/***/ },
/* 446 */
/***/ function(module, exports) {

var Equal = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.abs(a - b) < epsilon;
};

module.exports = Equal;


/***/ },
/* 447 */
/***/ function(module, exports) {

var Floor = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.floor(value + epsilon);
};

module.exports = Floor;


/***/ },
/* 448 */
/***/ function(module, exports) {

var GreaterThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a > b - epsilon;
};

module.exports = GreaterThan;


/***/ },
/* 449 */
/***/ function(module, exports) {

var LessThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a < b + epsilon;
};

module.exports = LessThan;


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(445),
    Equal: __webpack_require__(446),
    Floor: __webpack_require__(447),
    GreaterThan: __webpack_require__(448),
    LessThan: __webpack_require__(449)

};


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

var Bernstein = __webpack_require__(137);

var BezierInterpolation = function (v, k)
{
    var b = 0;
    var n = v.length - 1;

    for (var i = 0; i <= n; i++)
    {
        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
    }

    return b;
};

module.exports = BezierInterpolation;


/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

var CatmullRom = __webpack_require__(138);

var CatmullRomInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (v[0] === v[m])
    {
        if (k < 0)
        {
            i = Math.floor(f = m * (1 + k));
        }

        return CatmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
    }
    else
    {
        if (k < 0)
        {
            return v[0] - (CatmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);
        }

        if (k > 1)
        {
            return v[m] - (CatmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
        }

        return CatmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
    }
};

module.exports = CatmullRomInterpolation;


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Bezier: __webpack_require__(451),
    CatmullRom: __webpack_require__(452),
    Linear: __webpack_require__(147)

};


/***/ },
/* 454 */
/***/ function(module, exports) {

//  Takes value and returns the nearest power of 2

var GetPowerOfTwo = function (value)
{
    //  Math.log(2)
    var index = Math.log(value) / 0.6931471805599453;

    return (1 << Math.ceil(index));
};

module.exports = GetPowerOfTwo;


/***/ },
/* 455 */
/***/ function(module, exports) {

//  Is value a power of 2?

var IsValuePowerOfTwo = function (value)
{
    return (value > 0 && (value & (value - 1)) === 0);
};

module.exports = IsValuePowerOfTwo;


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {module.export = {

    GetNext: __webpack_require__(454),
    IsSize: __webpack_require__(148),
    IsValue: __webpack_require__(455)

};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(78)(module)))

/***/ },
/* 457 */
/***/ function(module, exports) {

/**
* @property {number} c - Internal var.
* @private
*/
var c = 1;

/**
* @property {number} s0 - Internal var.
* @private
*/
var s0 = 0;

/**
* @property {number} s1 - Internal var.
* @private
*/
var s1 = 0;

/**
* @property {number} s2 - Internal var.
* @private
*/
var s2 = 0;

/**
* @property {Array} sign - Internal var.
* @private
*/
var sign = [ -1, 1 ];

/**
* Private random helper.
*
* @method Phaser.RandomDataGenerator#rnd
* @private
* @return {number}
*/
var rnd = function ()
{
    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32

    c = t | 0;
    s0 = s1;
    s1 = s2;
    s2 = t - c;

    return s2;
};

/**
* Internal method that creates a seed hash.
*
* @method Phaser.RandomDataGenerator#hash
* @private
* @param {any} data
* @return {number} hashed value.
*/
var hash = function (data)
{
    var h, i, n;
    n = 0xefc8249d;
    data = data.toString();

    for (i = 0; i < data.length; i++)
    {
        n += data.charCodeAt(i);
        h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000;// 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10;// 2^-32
};


var RandomDataGenerator = function (seeds)
{
    if (seeds)
    {
        this.init(seeds);
    }
};

RandomDataGenerator.prototype.constructor = RandomDataGenerator;

RandomDataGenerator.prototype = {

    init: function (seeds)
    {
        if (typeof seeds === 'string')
        {
            this.state(seeds);
        }
        else
        {
            this.sow(seeds);
        }
    },

    /**
    * Reset the seed of the random data generator.
    *
    * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
    *
    * @method Phaser.RandomDataGenerator#sow
    * @param {any[]} seeds - The array of seeds: the `toString()` of each value is used.
    */
    sow: function (seeds)
    {
        // Always reset to default seed
        s0 = hash(' ');
        s1 = hash(s0);
        s2 = hash(s1);
        c = 1;

        if (!seeds)
        {
            return;
        }

        // Apply any seeds
        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)
        {
            var seed = seeds[i];

            s0 -= hash(seed);
            s0 += ~~(s0 < 0);
            s1 -= hash(seed);
            s1 += ~~(s1 < 0);
            s2 -= hash(seed);
            s2 += ~~(s2 < 0);
        }

    },

    /**
    * Returns a random integer between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#integer
    * @return {number} A random integer between 0 and 2^32.
    */
    integer: function ()
    {
        // 2^32
        return rnd() * 0x100000000;
    },

    /**
    * Returns a random real number between 0 and 1.
    *
    * @method Phaser.RandomDataGenerator#frac
    * @return {number} A random real number between 0 and 1.
    */
    frac: function ()
    {
        // 2^-53
        return rnd() + (rnd() * 0x200000 | 0) * 1.1102230246251565e-16;
    },

    /**
    * Returns a random real number between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#real
    * @return {number} A random real number between 0 and 2^32.
    */
    real: function ()
    {
        return this.integer() + this.frac();
    },

    /**
    * Returns a random integer between and including min and max.
    *
    * @method Phaser.RandomDataGenerator#integerInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    integerInRange: function (min, max)
    {
        return Math.floor(this.realInRange(0, max - min + 1) + min);
    },

    /**
    * Returns a random integer between and including min and max.
    * This method is an alias for RandomDataGenerator.integerInRange.
    *
    * @method Phaser.RandomDataGenerator#between
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    between: function (min, max)
    {
        return this.integerInRange(min, max);
    },

    /**
    * Returns a random real number between min and max.
    *
    * @method Phaser.RandomDataGenerator#realInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    realInRange: function (min, max)
    {
        return this.frac() * (max - min) + min;
    },

    /**
    * Returns a random real number between -1 and 1.
    *
    * @method Phaser.RandomDataGenerator#normal
    * @return {number} A random real number between -1 and 1.
    */
    normal: function ()
    {
        return 1 - (2 * this.frac());
    },

    /**
    * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
    *
    * @method Phaser.RandomDataGenerator#uuid
    * @return {string} A valid RFC4122 version4 ID hex string
    */
    uuid: function ()
    {
        var a = '';
        var b = '';

        for (b = a = ''; a++ < 36; b +=~a % 5 | a * 3&4 ? (a^15 ? 8^this.frac() * (a^20 ? 16 : 4) : 4).toString(16) : '-')
        {
        }

        return b;
    },

    /**
    * Returns a random member of `array`.
    *
    * @method Phaser.RandomDataGenerator#pick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    pick: function (array)
    {
        return array[this.integerInRange(0, array.length - 1)];
    },

    /**
    * Returns a sign to be used with multiplication operator.
    *
    * @method Phaser.RandomDataGenerator#sign
    * @return {number} -1 or +1.
    */
    sign: function ()
    {
        return this.pick(sign);
    },

    /**
    * Returns a random member of `array`, favoring the earlier entries.
    *
    * @method Phaser.RandomDataGenerator#weightedPick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    weightedPick: function (array)
    {
        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
    },

    /**
    * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
    *
    * @method Phaser.RandomDataGenerator#timestamp
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random timestamp between min and max.
    */
    timestamp: function (min, max)
    {
        return this.realInRange(min || 946684800000, max || 1577862000000);
    },

    /**
    * Returns a random angle between -180 and 180.
    *
    * @method Phaser.RandomDataGenerator#angle
    * @return {number} A random number between -180 and 180.
    */
    angle: function ()
    {
        return this.integerInRange(-180, 180);
    },

    /**
    * Returns a random rotation in radians, between -3.141 and 3.141
    *
    * @method Phaser.RandomDataGenerator#rotation
    * @return {number} A random number between -3.141 and 3.141
    */
    rotation: function ()
    {
        return this.realInRange(-3.141592653589793, 3.141592653589793);
    },

    /**
    * Gets or Sets the state of the generator. This allows you to retain the values
    * that the generator is using between games, i.e. in a game save file.
    *
    * To seed this generator with a previously saved state you can pass it as the
    * `seed` value in your game config, or call this method directly after Phaser has booted.
    *
    * Call this method with no parameters to return the current state.
    *
    * If providing a state it should match the same format that this method
    * returns, which is a string with a header `!rnd` followed by the `c`,
    * `s0`, `s1` and `s2` values respectively, each comma-delimited.
    *
    * @method Phaser.RandomDataGenerator#state
    * @param {string} [state] - Generator state to be set.
    * @return {string} The current state of the generator.
    */
    state: function (state)
    {
        if (typeof state === 'string' && state.match(/^!rnd/))
        {
            state = state.split(',');

            c = parseFloat(state[1]);
            s0 = parseFloat(state[2]);
            s1 = parseFloat(state[3]);
            s2 = parseFloat(state[4]);
        }

        return [ '!rnd', c, s0, s1, s2 ].join(',');
    }

};

module.exports = RandomDataGenerator;


/***/ },
/* 458 */
/***/ function(module, exports) {

var SnapCeil = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.ceil(value / gap);

    return start + value;
};

module.exports = SnapCeil;


/***/ },
/* 459 */
/***/ function(module, exports) {

var SnapFloor = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.floor(value / gap);

    return start + value;
};

module.exports = SnapFloor;


/***/ },
/* 460 */
/***/ function(module, exports) {

var SnapTo = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.round(value / gap);

    return start + value;
};

module.exports = SnapTo;


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(458),
    Floor: __webpack_require__(459),
    To: __webpack_require__(460)

};


/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Query` module contains methods for performing collision queries.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Query
*/

var Query = {};

module.exports = Query;

var Vector = __webpack_require__(4);
var SAT = __webpack_require__(67);
var Bounds = __webpack_require__(3);
var Bodies = __webpack_require__(69);
var Vertices = __webpack_require__(22);

(function() {

    /**
     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
     * @method ray
     * @param {body[]} bodies
     * @param {vector} startPoint
     * @param {vector} endPoint
     * @param {number} [rayWidth]
     * @return {object[]} Collisions
     */
    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
        rayWidth = rayWidth || 1e-100;

        var rayAngle = Vector.angle(startPoint, endPoint),
            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),
            rayX = (endPoint.x + startPoint.x) * 0.5,
            rayY = (endPoint.y + startPoint.y) * 0.5,
            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),
            collisions = [];

        for (var i = 0; i < bodies.length; i++) {
            var bodyA = bodies[i];
            
            if (Bounds.overlaps(bodyA.bounds, ray.bounds)) {
                for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {
                    var part = bodyA.parts[j];

                    if (Bounds.overlaps(part.bounds, ray.bounds)) {
                        var collision = SAT.collides(part, ray);
                        if (collision.collided) {
                            collision.body = collision.bodyA = collision.bodyB = bodyA;
                            collisions.push(collision);
                            break;
                        }
                    }
                }
            }
        }

        return collisions;
    };

    /**
     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
     * @method region
     * @param {body[]} bodies
     * @param {bounds} bounds
     * @param {bool} [outside=false]
     * @return {body[]} The bodies matching the query
     */
    Query.region = function(bodies, bounds, outside) {
        var result = [];

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                overlaps = Bounds.overlaps(body.bounds, bounds);
            if ((overlaps && !outside) || (!overlaps && outside))
                result.push(body);
        }

        return result;
    };

    /**
     * Returns all bodies whose vertices contain the given point, from the given set of bodies.
     * @method point
     * @param {body[]} bodies
     * @param {vector} point
     * @return {body[]} The bodies matching the query
     */
    Query.point = function(bodies, point) {
        var result = [];

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];
            
            if (Bounds.contains(body.bounds, point)) {
                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {
                    var part = body.parts[j];

                    if (Bounds.contains(part.bounds, point)
                        && Vertices.contains(part.vertices, point)) {
                        result.push(body);
                        break;
                    }
                }
            }
        }

        return result;
    };

})();


/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.
* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class MouseConstraint
*/

var MouseConstraint = {};

module.exports = MouseConstraint;

var Vertices = __webpack_require__(22);
var Sleeping = __webpack_require__(40);
var Mouse = __webpack_require__(68);
var Events = __webpack_require__(21);
var Detector = __webpack_require__(65);
var Constraint = __webpack_require__(39);
var Composite = __webpack_require__(20);
var Common = __webpack_require__(0);
var Bounds = __webpack_require__(3);

(function() {

    /**
     * Creates a new mouse constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {engine} engine
     * @param {} options
     * @return {MouseConstraint} A new MouseConstraint
     */
    MouseConstraint.create = function(engine, options) {
        var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);

        if (!mouse) {
            if (engine && engine.render && engine.render.canvas) {
                mouse = Mouse.create(engine.render.canvas);
            } else if (options && options.element) {
                mouse = Mouse.create(options.element);
            } else {
                mouse = Mouse.create();
                Common.warn('MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected');
            }
        }

        var constraint = Constraint.create({ 
            label: 'Mouse Constraint',
            pointA: mouse.position,
            pointB: { x: 0, y: 0 },
            length: 0.01, 
            stiffness: 0.1,
            angularStiffness: 1,
            render: {
                strokeStyle: '#90EE90',
                lineWidth: 3
            }
        });

        var defaults = {
            type: 'mouseConstraint',
            mouse: mouse,
            element: null,
            body: null,
            constraint: constraint,
            collisionFilter: {
                category: 0x0001,
                mask: 0xFFFFFFFF,
                group: 0
            }
        };

        var mouseConstraint = Common.extend(defaults, options);

        Events.on(engine, 'beforeUpdate', function() {
            var allBodies = Composite.allBodies(engine.world);
            MouseConstraint.update(mouseConstraint, allBodies);
            _triggerEvents(mouseConstraint);
        });

        return mouseConstraint;
    };

    /**
     * Updates the given mouse constraint.
     * @private
     * @method update
     * @param {MouseConstraint} mouseConstraint
     * @param {body[]} bodies
     */
    MouseConstraint.update = function(mouseConstraint, bodies) {
        var mouse = mouseConstraint.mouse,
            constraint = mouseConstraint.constraint,
            body = mouseConstraint.body;

        if (mouse.button === 0) {
            if (!constraint.bodyB) {
                for (var i = 0; i < bodies.length; i++) {
                    body = bodies[i];
                    if (Bounds.contains(body.bounds, mouse.position) 
                            && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {
                        for (var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++) {
                            var part = body.parts[j];
                            if (Vertices.contains(part.vertices, mouse.position)) {
                                constraint.pointA = mouse.position;
                                constraint.bodyB = mouseConstraint.body = body;
                                constraint.pointB = { x: mouse.position.x - body.position.x, y: mouse.position.y - body.position.y };
                                constraint.angleB = body.angle;

                                Sleeping.set(body, false);
                                Events.trigger(mouseConstraint, 'startdrag', { mouse: mouse, body: body });

                                break;
                            }
                        }
                    }
                }
            } else {
                Sleeping.set(constraint.bodyB, false);
                constraint.pointA = mouse.position;
            }
        } else {
            constraint.bodyB = mouseConstraint.body = null;
            constraint.pointB = null;

            if (body)
                Events.trigger(mouseConstraint, 'enddrag', { mouse: mouse, body: body });
        }
    };

    /**
     * Triggers mouse constraint events.
     * @method _triggerEvents
     * @private
     * @param {mouse} mouseConstraint
     */
    var _triggerEvents = function(mouseConstraint) {
        var mouse = mouseConstraint.mouse,
            mouseEvents = mouse.sourceEvents;

        if (mouseEvents.mousemove)
            Events.trigger(mouseConstraint, 'mousemove', { mouse: mouse });

        if (mouseEvents.mousedown)
            Events.trigger(mouseConstraint, 'mousedown', { mouse: mouse });

        if (mouseEvents.mouseup)
            Events.trigger(mouseConstraint, 'mouseup', { mouse: mouse });

        // reset the mouse state ready for the next step
        Mouse.clearSourceEvents(mouse);
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when the mouse has moved (or a touch moves) during the last step
    *
    * @event mousemove
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the mouse is down (or a touch has started) during the last step
    *
    * @event mousedown
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the mouse is up (or a touch has ended) during the last step
    *
    * @event mouseup
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the user starts dragging a body
    *
    * @event startdrag
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {body} event.body The body being dragged
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the user ends dragging a body
    *
    * @event enddrag
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {body} event.body The body that has stopped being dragged
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "constraint"
     * @readOnly
     */

    /**
     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.
     *
     * @property mouse
     * @type mouse
     * @default mouse
     */

    /**
     * The `Body` that is currently being moved by the user, or `null` if no body.
     *
     * @property body
     * @type body
     * @default null
     */

    /**
     * The `Constraint` object that is used to move the body during interaction.
     *
     * @property constraint
     * @type constraint
     */

    /**
     * An `Object` that specifies the collision filter properties.
     * The collision filter allows the user to define which types of body this mouse constraint can interact with.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter
     * @type object
     */

})();


/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.
*
* @class Matter
*/

var Matter = {};

module.exports = Matter;

var Plugin = __webpack_require__(155);
var Common = __webpack_require__(0);

(function() {

    /**
     * The library name.
     * @property name
     * @readOnly
     * @type {String}
     */
    Matter.name = 'matter-js';

    /**
     * The library version.
     * @property version
     * @readOnly
     * @type {String}
     */
    Matter.version = '@@VERSION@@';

    /**
     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.
     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.
     * @property uses
     * @type {Array}
     */
    Matter.uses = [];

    /**
     * The plugins that have been installed through `Matter.Plugin.install`. Read only.
     * @property used
     * @readOnly
     * @type {Array}
     */
    Matter.used = [];

    /**
     * Installs the given plugins on the `Matter` namespace.
     * This is a short-hand for `Plugin.use`, see it for more information.
     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.
     * Avoid calling this function multiple times unless you intend to manually control installation order.
     * @method use
     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).
     */
    Matter.use = function() {
        Plugin.use(Matter, Array.prototype.slice.call(arguments));
    };

    /**
     * Chains a function to excute before the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method before
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */
    Matter.before = function(path, func) {
        path = path.replace(/^Matter./, '');
        return Common.chainPathBefore(Matter, path, func);
    };

    /**
     * Chains a function to excute after the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method after
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */
    Matter.after = function(path, func) {
        path = path.replace(/^Matter./, '');
        return Common.chainPathAfter(Matter, path, func);
    };

})();


/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Runner` module is an optional utility which provides a game loop, 
* that handles continuously updating a `Matter.Engine` for you within a browser.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.
* Instead just call `Engine.update(engine, delta)` in your own loop.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Runner
*/

var Runner = {};

module.exports = Runner;

var Events = __webpack_require__(21);
var Engine = __webpack_require__(153);
var Common = __webpack_require__(0);

(function() {

    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }

    if (!_requestAnimationFrame) {
        var _frameTimeout;

        _requestAnimationFrame = function(callback){ 
            _frameTimeout = setTimeout(function() { 
                callback(Common.now()); 
            }, 1000 / 60);
        };

        _cancelAnimationFrame = function() {
            clearTimeout(_frameTimeout);
        };
    }

    /**
     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
     * @method create
     * @param {} options
     */
    Runner.create = function(options) {
        var defaults = {
            fps: 60,
            correction: 1,
            deltaSampleSize: 60,
            counterTimestamp: 0,
            frameCounter: 0,
            deltaHistory: [],
            timePrev: null,
            timeScalePrev: 1,
            frameRequestId: null,
            isFixed: false,
            enabled: true
        };

        var runner = Common.extend(defaults, options);

        runner.delta = runner.delta || 1000 / runner.fps;
        runner.deltaMin = runner.deltaMin || 1000 / runner.fps;
        runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);
        runner.fps = 1000 / runner.delta;

        return runner;
    };

    /**
     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
     * @method run
     * @param {engine} engine
     */
    Runner.run = function(runner, engine) {
        // create runner if engine is first argument
        if (typeof runner.positionIterations !== 'undefined') {
            engine = runner;
            runner = Runner.create();
        }

        (function render(time){
            runner.frameRequestId = _requestAnimationFrame(render);

            if (time && runner.enabled) {
                Runner.tick(runner, engine, time);
            }
        })();

        return runner;
    };

    /**
     * A game loop utility that updates the engine and renderer by one step (a 'tick').
     * Features delta smoothing, time correction and fixed or dynamic timing.
     * Triggers `beforeTick`, `tick` and `afterTick` events on the engine.
     * Consider just `Engine.update(engine, delta)` if you're using your own loop.
     * @method tick
     * @param {runner} runner
     * @param {engine} engine
     * @param {number} time
     */
    Runner.tick = function(runner, engine, time) {
        var timing = engine.timing,
            correction = 1,
            delta;

        // create an event object
        var event = {
            timestamp: timing.timestamp
        };

        Events.trigger(runner, 'beforeTick', event);
        Events.trigger(engine, 'beforeTick', event); // @deprecated

        if (runner.isFixed) {
            // fixed timestep
            delta = runner.delta;
        } else {
            // dynamic timestep based on wall clock between calls
            delta = (time - runner.timePrev) || runner.delta;
            runner.timePrev = time;

            // optimistically filter delta over a few frames, to improve stability
            runner.deltaHistory.push(delta);
            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
            delta = Math.min.apply(null, runner.deltaHistory);
            
            // limit delta
            delta = delta < runner.deltaMin ? runner.deltaMin : delta;
            delta = delta > runner.deltaMax ? runner.deltaMax : delta;

            // correction for delta
            correction = delta / runner.delta;

            // update engine timing object
            runner.delta = delta;
        }

        // time correction for time scaling
        if (runner.timeScalePrev !== 0)
            correction *= timing.timeScale / runner.timeScalePrev;

        if (timing.timeScale === 0)
            correction = 0;

        runner.timeScalePrev = timing.timeScale;
        runner.correction = correction;

        // fps counter
        runner.frameCounter += 1;
        if (time - runner.counterTimestamp >= 1000) {
            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);
            runner.counterTimestamp = time;
            runner.frameCounter = 0;
        }

        Events.trigger(runner, 'tick', event);
        Events.trigger(engine, 'tick', event); // @deprecated

        // if world has been modified, clear the render scene graph
        if (engine.world.isModified 
            && engine.render
            && engine.render.controller
            && engine.render.controller.clear) {
            engine.render.controller.clear(engine.render); // @deprecated
        }

        // update
        Events.trigger(runner, 'beforeUpdate', event);
        Engine.update(engine, delta, correction);
        Events.trigger(runner, 'afterUpdate', event);

        // render
        // @deprecated
        if (engine.render && engine.render.controller) {
            Events.trigger(runner, 'beforeRender', event);
            Events.trigger(engine, 'beforeRender', event); // @deprecated

            engine.render.controller.world(engine.render);

            Events.trigger(runner, 'afterRender', event);
            Events.trigger(engine, 'afterRender', event); // @deprecated
        }

        Events.trigger(runner, 'afterTick', event);
        Events.trigger(engine, 'afterTick', event); // @deprecated
    };

    /**
     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.
     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.
     * @method stop
     * @param {runner} runner
     */
    Runner.stop = function(runner) {
        _cancelAnimationFrame(runner.frameRequestId);
    };

    /**
     * Alias for `Runner.run`.
     * @method start
     * @param {runner} runner
     * @param {engine} engine
     */
    Runner.start = function(runner, engine) {
        Runner.run(runner, engine);
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired at the start of a tick, before any updates to the engine or timing
    *
    * @event beforeTick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine timing updated, but just before update
    *
    * @event tick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired at the end of a tick, after engine update and after rendering
    *
    * @event afterTick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired before update
    *
    * @event beforeUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after update
    *
    * @event afterUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    * @deprecated
    */

    /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    * @deprecated
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A flag that specifies whether the runner is running or not.
     *
     * @property enabled
     * @type boolean
     * @default true
     */

    /**
     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).
     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).
     * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).
     *
     * @property isFixed
     * @type boolean
     * @default false
     */

    /**
     * A `Number` that specifies the time step between updates in milliseconds.
     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.
     * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.
     *
     * @property delta
     * @type number
     * @default 1000 / 60
     */

})();


/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Composites` module contains factory methods for creating composite bodies
* with commonly used configurations (such as stacks and chains).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composites
*/

var Composites = {};

module.exports = Composites;

var Composite = __webpack_require__(20);
var Constraint = __webpack_require__(39);
var Common = __webpack_require__(0);
var Body = __webpack_require__(38);
var Bodies = __webpack_require__(69);

(function() {

    /**
     * Create a new composite containing bodies created in the callback in a grid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method stack
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */
    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
        var stack = Composite.create({ label: 'Stack' }),
            x = xx,
            y = yy,
            lastBody,
            i = 0;

        for (var row = 0; row < rows; row++) {
            var maxHeight = 0;
            
            for (var column = 0; column < columns; column++) {
                var body = callback(x, y, column, row, lastBody, i);
                    
                if (body) {
                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,
                        bodyWidth = body.bounds.max.x - body.bounds.min.x; 

                    if (bodyHeight > maxHeight)
                        maxHeight = bodyHeight;
                    
                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });

                    x = body.bounds.max.x + columnGap;

                    Composite.addBody(stack, body);
                    
                    lastBody = body;
                    i += 1;
                } else {
                    x += columnGap;
                }
            }
            
            y += maxHeight + rowGap;
            x = xx;
        }

        return stack;
    };
    
    /**
     * Chains all bodies in the given composite together using constraints.
     * @method chain
     * @param {composite} composite
     * @param {number} xOffsetA
     * @param {number} yOffsetA
     * @param {number} xOffsetB
     * @param {number} yOffsetB
     * @param {object} options
     * @return {composite} A new composite containing objects chained together with constraints
     */
    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
        var bodies = composite.bodies;
        
        for (var i = 1; i < bodies.length; i++) {
            var bodyA = bodies[i - 1],
                bodyB = bodies[i],
                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,
                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, 
                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,
                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
        
            var defaults = {
                bodyA: bodyA,
                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },
                bodyB: bodyB,
                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }
            };
            
            var constraint = Common.extend(defaults, options);
        
            Composite.addConstraint(composite, Constraint.create(constraint));
        }

        composite.label += ' Chain';
        
        return composite;
    };

    /**
     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
     * @method mesh
     * @param {composite} composite
     * @param {number} columns
     * @param {number} rows
     * @param {boolean} crossBrace
     * @param {object} options
     * @return {composite} The composite containing objects meshed together with constraints
     */
    Composites.mesh = function(composite, columns, rows, crossBrace, options) {
        var bodies = composite.bodies,
            row,
            col,
            bodyA,
            bodyB,
            bodyC;
        
        for (row = 0; row < rows; row++) {
            for (col = 1; col < columns; col++) {
                bodyA = bodies[(col - 1) + (row * columns)];
                bodyB = bodies[col + (row * columns)];
                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));
            }

            if (row > 0) {
                for (col = 0; col < columns; col++) {
                    bodyA = bodies[col + ((row - 1) * columns)];
                    bodyB = bodies[col + (row * columns)];
                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));

                    if (crossBrace && col > 0) {
                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];
                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));
                    }

                    if (crossBrace && col < columns - 1) {
                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];
                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));
                    }
                }
            }
        }

        composite.label += ' Mesh';
        
        return composite;
    };
    
    /**
     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method pyramid
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */
    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {
            var actualRows = Math.min(rows, Math.ceil(columns / 2)),
                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
            
            if (row > actualRows)
                return;
            
            // reverse row order
            row = actualRows - row;
            
            var start = row,
                end = columns - 1 - row;

            if (column < start || column > end)
                return;
            
            // retroactively fix the first body's position, since width was unknown
            if (i === 1) {
                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });
            }

            var xOffset = lastBody ? column * lastBodyWidth : 0;
            
            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);
        });
    };

    /**
     * Creates a composite with a Newton's Cradle setup of bodies and constraints.
     * @method newtonsCradle
     * @param {number} xx
     * @param {number} yy
     * @param {number} number
     * @param {number} size
     * @param {number} length
     * @return {composite} A new composite newtonsCradle body
     */
    Composites.newtonsCradle = function(xx, yy, number, size, length) {
        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });

        for (var i = 0; i < number; i++) {
            var separation = 1.9,
                circle = Bodies.circle(xx + i * (size * separation), yy + length, size, 
                            { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }),
                constraint = Constraint.create({ pointA: { x: xx + i * (size * separation), y: yy }, bodyB: circle });

            Composite.addBody(newtonsCradle, circle);
            Composite.addConstraint(newtonsCradle, constraint);
        }

        return newtonsCradle;
    };
    
    /**
     * Creates a composite with simple car setup of bodies and constraints.
     * @method car
     * @param {number} xx
     * @param {number} yy
     * @param {number} width
     * @param {number} height
     * @param {number} wheelSize
     * @return {composite} A new composite car body
     */
    Composites.car = function(xx, yy, width, height, wheelSize) {
        var group = Body.nextGroup(true),
            wheelBase = -20,
            wheelAOffset = -width * 0.5 + wheelBase,
            wheelBOffset = width * 0.5 - wheelBase,
            wheelYOffset = 0;
    
        var car = Composite.create({ label: 'Car' }),
            body = Bodies.trapezoid(xx, yy, width, height, 0.3, { 
                collisionFilter: {
                    group: group
                },
                friction: 0.01,
                chamfer: {
                    radius: 10
                }
            });
    
        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, { 
            collisionFilter: {
                group: group
            },
            friction: 0.8,
            density: 0.01
        });
                    
        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, { 
            collisionFilter: {
                group: group
            },
            friction: 0.8,
            density: 0.01
        });
                    
        var axelA = Constraint.create({
            bodyA: body,
            pointA: { x: wheelAOffset, y: wheelYOffset },
            bodyB: wheelA,
            stiffness: 0.2,
            render: {
                lineWidth: 0
            }
        });
                        
        var axelB = Constraint.create({
            bodyA: body,
            pointA: { x: wheelBOffset, y: wheelYOffset },
            bodyB: wheelB,
            stiffness: 0.2,
            render: {
                lineWidth: 0
            }
        });
        
        Composite.addBody(car, body);
        Composite.addBody(car, wheelA);
        Composite.addBody(car, wheelB);
        Composite.addConstraint(car, axelA);
        Composite.addConstraint(car, axelB);

        return car;
    };

    /**
     * Creates a simple soft body like object.
     * @method softBody
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {boolean} crossBrace
     * @param {number} particleRadius
     * @param {} particleOptions
     * @param {} constraintOptions
     * @return {composite} A new composite softBody
     */
    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);
        constraintOptions = Common.extend({ stiffness: 0.4 }, constraintOptions);

        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {
            return Bodies.circle(x, y, particleRadius, particleOptions);
        });

        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);

        softBody.label = 'Soft Body';

        return softBody;
    };

})();


/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
*
* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Svg
*/

var Svg = {};

module.exports = Svg;

var Bounds = __webpack_require__(3);

(function() {

    /**
     * Converts an SVG path into an array of vector points.
     * If the input path forms a concave shape, you must decompose the result into convex parts before use.
     * See `Bodies.fromVertices` which provides support for this.
     * Note that this function is not guaranteed to support complex paths (such as those with holes).
     * @method pathToVertices
     * @param {SVGPathElement} path
     * @param {Number} [sampleLength=15]
     * @return {Vector[]} points
     */
    Svg.pathToVertices = function(path, sampleLength) {
        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js
        var i, il, total, point, segment, segments, 
            segmentsQueue, lastSegment, 
            lastPoint, segmentIndex, points = [],
            lx, ly, length = 0, x = 0, y = 0;

        sampleLength = sampleLength || 15;

        var addPoint = function(px, py, pathSegType) {
            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)
            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;

            // when the last point doesn't equal the current point add the current point
            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
                if (lastPoint && isRelative) {
                    lx = lastPoint.x;
                    ly = lastPoint.y;
                } else {
                    lx = 0;
                    ly = 0;
                }

                var point = {
                    x: lx + px,
                    y: ly + py
                };

                // set last point
                if (isRelative || !lastPoint) {
                    lastPoint = point;
                }

                points.push(point);

                x = lx + px;
                y = ly + py;
            }
        };

        var addSegmentPoint = function(segment) {
            var segType = segment.pathSegTypeAsLetter.toUpperCase();

            // skip path ends
            if (segType === 'Z') 
                return;

            // map segment to x and y
            switch (segType) {

            case 'M':
            case 'L':
            case 'T':
            case 'C':
            case 'S':
            case 'Q':
                x = segment.x;
                y = segment.y;
                break;
            case 'H':
                x = segment.x;
                break;
            case 'V':
                y = segment.y;
                break;
            }

            addPoint(x, y, segment.pathSegType);
        };

        // ensure path is absolute
        _svgPathToAbsolute(path);

        // get total length
        total = path.getTotalLength();

        // queue segments
        segments = [];
        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)
            segments.push(path.pathSegList.getItem(i));

        segmentsQueue = segments.concat();

        // sample through path
        while (length < total) {
            // get segment at position
            segmentIndex = path.getPathSegAtLength(length);
            segment = segments[segmentIndex];

            // new segment
            if (segment != lastSegment) {
                while (segmentsQueue.length && segmentsQueue[0] != segment)
                    addSegmentPoint(segmentsQueue.shift());

                lastSegment = segment;
            }

            // add points in between when curving
            // TODO: adaptive sampling
            switch (segment.pathSegTypeAsLetter.toUpperCase()) {

            case 'C':
            case 'T':
            case 'S':
            case 'Q':
            case 'A':
                point = path.getPointAtLength(length);
                addPoint(point.x, point.y, 0);
                break;

            }

            // increment by sample value
            length += sampleLength;
        }

        // add remaining segments not passed by sampling
        for (i = 0, il = segmentsQueue.length; i < il; ++i)
            addSegmentPoint(segmentsQueue[i]);

        return points;
    };

    var _svgPathToAbsolute = function(path) {
        // http://phrogz.net/convert-svg-path-to-all-absolute-commands
        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,
            x = 0, y = 0, len = segs.numberOfItems;

        for (var i = 0; i < len; ++i) {
            var seg = segs.getItem(i),
                segType = seg.pathSegTypeAsLetter;

            if (/[MLHVCSQTA]/.test(segType)) {
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
            } else {
                if ('x1' in seg) x1 = x + seg.x1;
                if ('x2' in seg) x2 = x + seg.x2;
                if ('y1' in seg) y1 = y + seg.y1;
                if ('y2' in seg) y2 = y + seg.y2;
                if ('x' in seg) x += seg.x;
                if ('y' in seg) y += seg.y;

                switch (segType) {

                case 'm':
                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
                    break;
                case 'l':
                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
                    break;
                case 'h':
                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
                    break;
                case 'v':
                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
                    break;
                case 'c':
                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                    break;
                case 's':
                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                    break;
                case 'q':
                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                    break;
                case 't':
                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                    break;
                case 'a':
                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
                    break;
                case 'z':
                case 'Z':
                    x = x0;
                    y = y0;
                    break;

                }
            }

            if (segType == 'M' || segType == 'm') {
                x0 = x;
                y0 = y;
            }
        }
    };

})();

/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

var Matter = module.exports = __webpack_require__(464);

Matter.Body = __webpack_require__(38);
Matter.Composite = __webpack_require__(20);
Matter.World = __webpack_require__(149);

Matter.Contact = __webpack_require__(150);
Matter.Detector = __webpack_require__(65);
Matter.Grid = __webpack_require__(66);
Matter.Pairs = __webpack_require__(151);
Matter.Pair = __webpack_require__(43);
Matter.Query = __webpack_require__(462);
Matter.Resolver = __webpack_require__(152);
Matter.SAT = __webpack_require__(67);

Matter.Constraint = __webpack_require__(39);
Matter.MouseConstraint = __webpack_require__(463);

Matter.Common = __webpack_require__(0);
Matter.Engine = __webpack_require__(153);
Matter.Events = __webpack_require__(21);
Matter.Mouse = __webpack_require__(68);
Matter.Runner = __webpack_require__(465);
Matter.Sleeping = __webpack_require__(40);
Matter.Plugin = __webpack_require__(155);

// @if DEBUG
Matter.Metrics = __webpack_require__(154);
// @endif

Matter.Bodies = __webpack_require__(69);
Matter.Composites = __webpack_require__(466);

Matter.Axes = __webpack_require__(70);
Matter.Bounds = __webpack_require__(3);
Matter.Svg = __webpack_require__(467);
Matter.Vector = __webpack_require__(4);
Matter.Vertices = __webpack_require__(22);

Matter.Render = __webpack_require__(71);
Matter.RenderPixi = __webpack_require__(469);

// aliases

Matter.World.add = Matter.Composite.add;
Matter.World.remove = Matter.Composite.remove;
Matter.World.addComposite = Matter.Composite.addComposite;
Matter.World.addBody = Matter.Composite.addBody;
Matter.World.addConstraint = Matter.Composite.addConstraint;
Matter.World.clear = Matter.Composite.clear;
Matter.Engine.run = Matter.Runner.run;


/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.RenderPixi` module is an example renderer using pixi.js.
* See also `Matter.Render` for a canvas based renderer.
*
* @class RenderPixi
* @deprecated the Matter.RenderPixi module will soon be removed from the Matter.js core.
* It will likely be moved to its own repository (but maintenance will be limited).
*/

var RenderPixi = {};

module.exports = RenderPixi;

var Bounds = __webpack_require__(3);
var Composite = __webpack_require__(20);
var Common = __webpack_require__(0);
var Events = __webpack_require__(21);
var Vector = __webpack_require__(4);

(function() {

    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame 
                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }
    
    /**
     * Creates a new Pixi.js WebGL renderer
     * @method create
     * @param {object} options
     * @return {RenderPixi} A new renderer
     * @deprecated
     */
    RenderPixi.create = function(options) {
        Common.warn('RenderPixi.create: Matter.RenderPixi is deprecated (see docs)');

        var defaults = {
            controller: RenderPixi,
            engine: null,
            element: null,
            frameRequestId: null,
            canvas: null,
            renderer: null,
            container: null,
            spriteContainer: null,
            pixiOptions: null,
            options: {
                width: 800,
                height: 600,
                background: '#fafafa',
                wireframeBackground: '#222',
                hasBounds: false,
                enabled: true,
                wireframes: true,
                showSleeping: true,
                showDebug: false,
                showBroadphase: false,
                showBounds: false,
                showVelocity: false,
                showCollisions: false,
                showAxes: false,
                showPositions: false,
                showAngleIndicator: false,
                showIds: false,
                showShadows: false
            }
        };

        var render = Common.extend(defaults, options),
            transparent = !render.options.wireframes && render.options.background === 'transparent';

        // init pixi
        render.pixiOptions = render.pixiOptions || {
            view: render.canvas,
            transparent: transparent,
            antialias: true,
            backgroundColor: options.background
        };

        render.mouse = options.mouse;
        render.engine = options.engine;
        render.renderer = render.renderer || new PIXI.WebGLRenderer(render.options.width, render.options.height, render.pixiOptions);
        render.container = render.container || new PIXI.Container();
        render.spriteContainer = render.spriteContainer || new PIXI.Container();
        render.canvas = render.canvas || render.renderer.view;
        render.bounds = render.bounds || { 
            min: {
                x: 0,
                y: 0
            }, 
            max: { 
                x: render.options.width,
                y: render.options.height
            }
        };

        // event listeners
        Events.on(render.engine, 'beforeUpdate', function() {
            RenderPixi.clear(render);
        });

        // caches
        render.textures = {};
        render.sprites = {};
        render.primitives = {};

        // use a sprite batch for performance
        render.container.addChild(render.spriteContainer);

        // insert canvas
        if (Common.isElement(render.element)) {
            render.element.appendChild(render.canvas);
        } else {
            Common.warn('No "render.element" passed, "render.canvas" was not inserted into document.');
        }

        // prevent menus on canvas
        render.canvas.oncontextmenu = function() { return false; };
        render.canvas.onselectstart = function() { return false; };

        return render;
    };

    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     * @deprecated
     */
    RenderPixi.run = function(render) {
        (function loop(time){
            render.frameRequestId = _requestAnimationFrame(loop);
            RenderPixi.world(render);
        })();
    };

    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     * @deprecated
     */
    RenderPixi.stop = function(render) {
        _cancelAnimationFrame(render.frameRequestId);
    };

    /**
     * Clears the scene graph
     * @method clear
     * @param {RenderPixi} render
     * @deprecated
     */
    RenderPixi.clear = function(render) {
        var container = render.container,
            spriteContainer = render.spriteContainer;

        // clear stage container
        while (container.children[0]) { 
            container.removeChild(container.children[0]); 
        }

        // clear sprite batch
        while (spriteContainer.children[0]) { 
            spriteContainer.removeChild(spriteContainer.children[0]); 
        }

        var bgSprite = render.sprites['bg-0'];

        // clear caches
        render.textures = {};
        render.sprites = {};
        render.primitives = {};

        // set background sprite
        render.sprites['bg-0'] = bgSprite;
        if (bgSprite)
            container.addChildAt(bgSprite, 0);

        // add sprite batch back into container
        render.container.addChild(render.spriteContainer);

        // reset background state
        render.currentBackground = null;

        // reset bounds transforms
        container.scale.set(1, 1);
        container.position.set(0, 0);
    };

    /**
     * Sets the background of the canvas 
     * @method setBackground
     * @param {RenderPixi} render
     * @param {string} background
     * @deprecated
     */
    RenderPixi.setBackground = function(render, background) {
        if (render.currentBackground !== background) {
            var isColor = background.indexOf && background.indexOf('#') !== -1,
                bgSprite = render.sprites['bg-0'];

            if (isColor) {
                // if solid background color
                var color = Common.colorToNumber(background);
                render.renderer.backgroundColor = color;

                // remove background sprite if existing
                if (bgSprite)
                    render.container.removeChild(bgSprite); 
            } else {
                // initialise background sprite if needed
                if (!bgSprite) {
                    var texture = _getTexture(render, background);

                    bgSprite = render.sprites['bg-0'] = new PIXI.Sprite(texture);
                    bgSprite.position.x = 0;
                    bgSprite.position.y = 0;
                    render.container.addChildAt(bgSprite, 0);
                }
            }

            render.currentBackground = background;
        }
    };

    /**
     * Description
     * @method world
     * @param {engine} engine
     * @deprecated
     */
    RenderPixi.world = function(render) {
        var engine = render.engine,
            world = engine.world,
            renderer = render.renderer,
            container = render.container,
            options = render.options,
            bodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world),
            constraints = [],
            i;

        if (options.wireframes) {
            RenderPixi.setBackground(render, options.wireframeBackground);
        } else {
            RenderPixi.setBackground(render, options.background);
        }

        // handle bounds
        var boundsWidth = render.bounds.max.x - render.bounds.min.x,
            boundsHeight = render.bounds.max.y - render.bounds.min.y,
            boundsScaleX = boundsWidth / render.options.width,
            boundsScaleY = boundsHeight / render.options.height;

        if (options.hasBounds) {
            // Hide bodies that are not in view
            for (i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                body.render.sprite.visible = Bounds.overlaps(body.bounds, render.bounds);
            }

            // filter out constraints that are not in view
            for (i = 0; i < allConstraints.length; i++) {
                var constraint = allConstraints[i],
                    bodyA = constraint.bodyA,
                    bodyB = constraint.bodyB,
                    pointAWorld = constraint.pointA,
                    pointBWorld = constraint.pointB;

                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);

                if (!pointAWorld || !pointBWorld)
                    continue;

                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))
                    constraints.push(constraint);
            }

            // transform the view
            container.scale.set(1 / boundsScaleX, 1 / boundsScaleY);
            container.position.set(-render.bounds.min.x * (1 / boundsScaleX), -render.bounds.min.y * (1 / boundsScaleY));
        } else {
            constraints = allConstraints;
        }

        for (i = 0; i < bodies.length; i++)
            RenderPixi.body(render, bodies[i]);

        for (i = 0; i < constraints.length; i++)
            RenderPixi.constraint(render, constraints[i]);

        renderer.render(container);
    };


    /**
     * Description
     * @method constraint
     * @param {engine} engine
     * @param {constraint} constraint
     * @deprecated
     */
    RenderPixi.constraint = function(render, constraint) {
        var engine = render.engine,
            bodyA = constraint.bodyA,
            bodyB = constraint.bodyB,
            pointA = constraint.pointA,
            pointB = constraint.pointB,
            container = render.container,
            constraintRender = constraint.render,
            primitiveId = 'c-' + constraint.id,
            primitive = render.primitives[primitiveId];

        // initialise constraint primitive if not existing
        if (!primitive)
            primitive = render.primitives[primitiveId] = new PIXI.Graphics();

        // don't render if constraint does not have two end points
        if (!constraintRender.visible || !constraint.pointA || !constraint.pointB) {
            primitive.clear();
            return;
        }

        // add to scene graph if not already there
        if (Common.indexOf(container.children, primitive) === -1)
            container.addChild(primitive);

        // render the constraint on every update, since they can change dynamically
        primitive.clear();
        primitive.beginFill(0, 0);
        primitive.lineStyle(constraintRender.lineWidth, Common.colorToNumber(constraintRender.strokeStyle), 1);
        
        if (bodyA) {
            primitive.moveTo(bodyA.position.x + pointA.x, bodyA.position.y + pointA.y);
        } else {
            primitive.moveTo(pointA.x, pointA.y);
        }

        if (bodyB) {
            primitive.lineTo(bodyB.position.x + pointB.x, bodyB.position.y + pointB.y);
        } else {
            primitive.lineTo(pointB.x, pointB.y);
        }

        primitive.endFill();
    };
    
    /**
     * Description
     * @method body
     * @param {engine} engine
     * @param {body} body
     * @deprecated
     */
    RenderPixi.body = function(render, body) {
        var engine = render.engine,
            bodyRender = body.render;

        if (!bodyRender.visible)
            return;

        if (bodyRender.sprite && bodyRender.sprite.texture) {
            var spriteId = 'b-' + body.id,
                sprite = render.sprites[spriteId],
                spriteContainer = render.spriteContainer;

            // initialise body sprite if not existing
            if (!sprite)
                sprite = render.sprites[spriteId] = _createBodySprite(render, body);

            // add to scene graph if not already there
            if (Common.indexOf(spriteContainer.children, sprite) === -1)
                spriteContainer.addChild(sprite);

            // update body sprite
            sprite.position.x = body.position.x;
            sprite.position.y = body.position.y;
            sprite.rotation = body.angle;
            sprite.scale.x = bodyRender.sprite.xScale || 1;
            sprite.scale.y = bodyRender.sprite.yScale || 1;
        } else {
            var primitiveId = 'b-' + body.id,
                primitive = render.primitives[primitiveId],
                container = render.container;

            // initialise body primitive if not existing
            if (!primitive) {
                primitive = render.primitives[primitiveId] = _createBodyPrimitive(render, body);
                primitive.initialAngle = body.angle;
            }

            // add to scene graph if not already there
            if (Common.indexOf(container.children, primitive) === -1)
                container.addChild(primitive);

            // update body primitive
            primitive.position.x = body.position.x;
            primitive.position.y = body.position.y;
            primitive.rotation = body.angle - primitive.initialAngle;
        }
    };

    /**
     * Creates a body sprite
     * @method _createBodySprite
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Sprite} sprite
     * @deprecated
     */
    var _createBodySprite = function(render, body) {
        var bodyRender = body.render,
            texturePath = bodyRender.sprite.texture,
            texture = _getTexture(render, texturePath),
            sprite = new PIXI.Sprite(texture);

        sprite.anchor.x = body.render.sprite.xOffset;
        sprite.anchor.y = body.render.sprite.yOffset;

        return sprite;
    };

    /**
     * Creates a body primitive
     * @method _createBodyPrimitive
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Graphics} graphics
     * @deprecated
     */
    var _createBodyPrimitive = function(render, body) {
        var bodyRender = body.render,
            options = render.options,
            primitive = new PIXI.Graphics(),
            fillStyle = Common.colorToNumber(bodyRender.fillStyle),
            strokeStyle = Common.colorToNumber(bodyRender.strokeStyle),
            strokeStyleIndicator = Common.colorToNumber(bodyRender.strokeStyle),
            strokeStyleWireframe = Common.colorToNumber('#bbb'),
            strokeStyleWireframeIndicator = Common.colorToNumber('#CD5C5C'),
            part;

        primitive.clear();

        // handle compound parts
        for (var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
            part = body.parts[k];

            if (!options.wireframes) {
                primitive.beginFill(fillStyle, 1);
                primitive.lineStyle(bodyRender.lineWidth, strokeStyle, 1);
            } else {
                primitive.beginFill(0, 0);
                primitive.lineStyle(1, strokeStyleWireframe, 1);
            }

            primitive.moveTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);

            for (var j = 1; j < part.vertices.length; j++) {
                primitive.lineTo(part.vertices[j].x - body.position.x, part.vertices[j].y - body.position.y);
            }

            primitive.lineTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);

            primitive.endFill();

            // angle indicator
            if (options.showAngleIndicator || options.showAxes) {
                primitive.beginFill(0, 0);

                if (options.wireframes) {
                    primitive.lineStyle(1, strokeStyleWireframeIndicator, 1);
                } else {
                    primitive.lineStyle(1, strokeStyleIndicator);
                }

                primitive.moveTo(part.position.x - body.position.x, part.position.y - body.position.y);
                primitive.lineTo(((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2 - body.position.x), 
                                 ((part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2 - body.position.y));

                primitive.endFill();
            }
        }

        return primitive;
    };

    /**
     * Gets the requested texture (a PIXI.Texture) via its path
     * @method _getTexture
     * @private
     * @param {RenderPixi} render
     * @param {string} imagePath
     * @return {PIXI.Texture} texture
     * @deprecated
     */
    var _getTexture = function(render, imagePath) {
        var texture = render.textures[imagePath];

        if (!texture)
            texture = render.textures[imagePath] = PIXI.Texture.fromImage(imagePath);

        return texture;
    };

})();


/***/ },
/* 470 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function (fun /*, thisArg */)
    {
        'use strict';

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== 'function')
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}


/***/ },
/* 471 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}


/***/ },
/* 472 */
/***/ function(module, exports) {

/* Copyright 2013 Chris Wilson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*

This monkeypatch library is intended to be included in projects that are
written to the proper AudioContext spec (instead of webkitAudioContext),
and that use the new naming and proper bits of the Web Audio API (e.g.
using BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may
have to run on systems that only support the deprecated bits.

This library should be harmless to include if the browser supports
unprefixed "AudioContext", and/or if it supports the new names.

The patches this library handles:
if window.AudioContext is unsupported, it will be aliased to webkitAudioContext().
if AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or
noteGrainOn(), depending on parameters.

The following aliases only take effect if the new names are not already in place:

AudioBufferSourceNode.stop() is aliased to noteOff()
AudioContext.createGain() is aliased to createGainNode()
AudioContext.createDelay() is aliased to createDelayNode()
AudioContext.createScriptProcessor() is aliased to createJavaScriptNode()
AudioContext.createPeriodicWave() is aliased to createWaveTable()
OscillatorNode.start() is aliased to noteOn()
OscillatorNode.stop() is aliased to noteOff()
OscillatorNode.setPeriodicWave() is aliased to setWaveTable()
AudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()

This library does NOT patch the enumerated type changes, as it is
recommended in the specification that implementations support both integer
and string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel
BiquadFilterNode.type and OscillatorNode.type.

*/
(function (global, exports, perf) {
  'use strict';

  function fixSetTarget(param) {
    if (!param)	// if NYI, just return
      return;
    if (!param.setTargetAtTime)
      param.setTargetAtTime = param.setTargetValueAtTime;
  }

  if (window.hasOwnProperty('webkitAudioContext') &&
      !window.hasOwnProperty('AudioContext')) {
    window.AudioContext = webkitAudioContext;

    if (!AudioContext.prototype.hasOwnProperty('createGain'))
      AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
    if (!AudioContext.prototype.hasOwnProperty('createDelay'))
      AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
    if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor'))
      AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;
    if (!AudioContext.prototype.hasOwnProperty('createPeriodicWave'))
      AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;


    AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;
    AudioContext.prototype.createGain = function() {
      var node = this.internal_createGain();
      fixSetTarget(node.gain);
      return node;
    };

    AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;
    AudioContext.prototype.createDelay = function(maxDelayTime) {
      var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();
      fixSetTarget(node.delayTime);
      return node;
    };

    AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;
    AudioContext.prototype.createBufferSource = function() {
      var node = this.internal_createBufferSource();
      if (!node.start) {
        node.start = function ( when, offset, duration ) {
          if ( offset || duration )
            this.noteGrainOn( when || 0, offset, duration );
          else
            this.noteOn( when || 0 );
        };
      } else {
        node.internal_start = node.start;
        node.start = function( when, offset, duration ) {
          if( typeof duration !== 'undefined' )
            node.internal_start( when || 0, offset, duration );
          else
            node.internal_start( when || 0, offset || 0 );
        };
      }
      if (!node.stop) {
        node.stop = function ( when ) {
          this.noteOff( when || 0 );
        };
      } else {
        node.internal_stop = node.stop;
        node.stop = function( when ) {
          node.internal_stop( when || 0 );
        };
      }
      fixSetTarget(node.playbackRate);
      return node;
    };

    AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;
    AudioContext.prototype.createDynamicsCompressor = function() {
      var node = this.internal_createDynamicsCompressor();
      fixSetTarget(node.threshold);
      fixSetTarget(node.knee);
      fixSetTarget(node.ratio);
      fixSetTarget(node.reduction);
      fixSetTarget(node.attack);
      fixSetTarget(node.release);
      return node;
    };

    AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;
    AudioContext.prototype.createBiquadFilter = function() {
      var node = this.internal_createBiquadFilter();
      fixSetTarget(node.frequency);
      fixSetTarget(node.detune);
      fixSetTarget(node.Q);
      fixSetTarget(node.gain);
      return node;
    };

    if (AudioContext.prototype.hasOwnProperty( 'createOscillator' )) {
      AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;
      AudioContext.prototype.createOscillator = function() {
        var node = this.internal_createOscillator();
        if (!node.start) {
          node.start = function ( when ) {
            this.noteOn( when || 0 );
          };
        } else {
          node.internal_start = node.start;
          node.start = function ( when ) {
            node.internal_start( when || 0);
          };
        }
        if (!node.stop) {
          node.stop = function ( when ) {
            this.noteOff( when || 0 );
          };
        } else {
          node.internal_stop = node.stop;
          node.stop = function( when ) {
            node.internal_stop( when || 0 );
          };
        }
        if (!node.setPeriodicWave)
          node.setPeriodicWave = node.setWaveTable;
        fixSetTarget(node.frequency);
        fixSetTarget(node.detune);
        return node;
      };
    }
  }

  if (window.hasOwnProperty('webkitOfflineAudioContext') &&
      !window.hasOwnProperty('OfflineAudioContext')) {
    window.OfflineAudioContext = webkitOfflineAudioContext;
  }

}(window));



/***/ },
/* 473 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}

/**
* A polyfill for Function.prototype.bind
*/
if (!Function.prototype.bind) {

    /* jshint freeze: false */
    Function.prototype.bind = (function () {

        var slice = Array.prototype.slice;

        return function (thisArg) {

            var target = this, boundArgs = slice.call(arguments, 1);

            if (typeof target !== 'function')
            {
                throw new TypeError();
            }

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args);
            }

            bound.prototype = (function F(proto) {
                if (proto)
                {
                    F.prototype = proto;
                }

                if (!(this instanceof F))
                {
                    /* jshint supernew: true */
                    return new F;
                }
            })(target.prototype);

            return bound;
        };
    })();
}

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function(fun /*, thisArg */)
    {
        "use strict";

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== "function")
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}

/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ },
/* 474 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}


/***/ },
/* 475 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/


/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}


/***/ },
/* 476 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}


/***/ },
/* 477 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();
    if (!global.performance) {
        global.performance = {};
    }
    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
        global[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now(),
            delay = 16 + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(77)))

/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(2);
var DrawImage = __webpack_require__(481);
var BlitImage = __webpack_require__(480);
var GetBlendModes = __webpack_require__(482);
var GetContext = __webpack_require__(79);

var CanvasRenderer = function (game)
{
    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    this.game = game;

    //  Needed?
    this.type = CONST.CANVAS;

    this.drawCount = 0;

    //  Read all the following from game config (or State config?)
    // this.clearBeforeRender = true;
    // this.transparent = false;
    // this.autoResize = false;
    // this.smoothProperty = Phaser.Canvas.getSmoothingPrefix(this.context);
    // this.roundPixels = false;

    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.resolution = game.config.resolution;

    this.gameCanvas = game.canvas;

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type CanvasRenderingContext2D
     */
    this.gameContext = GetContext(this.gameCanvas);

    this.gameConfig = game.config;

    this.currentContext = this.gameContext;

    //  Map to the required function
    this.drawImage = DrawImage;
    this.blitImage = BlitImage;

    this.blendModes = GetBlendModes();

    this.currentAlpha = 1;
    this.currentBlendMode = 0;
    this.currentScaleMode = 0;

    // this.tintMethod = this.tintWithPerPixel;

    this.init();
};

CanvasRenderer.prototype.constructor = CanvasRenderer;

CanvasRenderer.prototype = {

    init: function ()
    {
        this.resize(this.width, this.height);
    },

    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.gameCanvas.width = this.width;
        this.gameCanvas.height = this.height;

        if (this.autoResize)
        {
            this.gameCanvas.style.width = (this.width / res) + 'px';
            this.gameCanvas.style.height = (this.height / res) + 'px';
        }

        // if (this.smoothProperty)
        // {
        //     this.gameContext[this.smoothProperty] = (this.scaleMode === ScaleModes.LINEAR);
        // }
    },

    resetTransform: function ()
    {
        this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
    },

    setBlendMode: function (blendMode)
    {
        if (this.currentBlendMode !== blendMode)
        {
            this.currentContext.globalCompositeOperation = blendMode;
            this.currentBlendMode = blendMode;
        }

        return this.currentBlendMode;
    },

    setAlpha: function (alpha)
    {
        if (this.currentAlpha !== alpha)
        {
            this.currentContext.globalAlpha = alpha;
            this.currentAlpha = alpha;
        }

        return this.currentAlpha;
    },

    //  Call at the start of the render loop
    preRender: function ()
    {
        // console.log('%c render start ', 'color: #ffffff; background: #00ff00;');

        var ctx = this.gameContext;
        var config = this.gameConfig;

        var width = this.width;
        var height = this.height;

        if (config.clearBeforeRender)
        {
            ctx.clearRect(0, 0, width, height);
        }

        if (!config.transparent)
        {
            ctx.fillStyle = config.backgroundColor.rgba;
            ctx.fillRect(0, 0, width, height);
        }

        //  Add Pre-render hook

        this.drawCount = 0;
    },

    /**
     * Renders the State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, children, interpolationPercentage, camera)
    {
        var w = state.sys.width;
        var h = state.sys.height;
        var ctx = state.sys.context;
        var settings = state.sys.settings;
        var scissor = (camera.x !== 0 || camera.y !== 0 || camera.width !== ctx.canvas.width || camera.height !== ctx.canvas.height);
        var list = children.list;

        this.currentContext = ctx;

        

        //  If the alpha or blend mode didn't change since the last render, then don't set them again (saves 2 ops)

        if (this.currentAlpha !== 1)
        {
            ctx.globalAlpha = 1;
            this.currentAlpha = 1;
        }

        if (this.currentBlendMode !== 0)
        {
            ctx.globalCompositeOperation = 'source-over';
            this.currentBlendMode = 0;
        }

        this.currentScaleMode = 0;

        if (settings.renderToTexture)
        {
            if (settings.clearBeforeRender)
            {
                ctx.clearRect(0, 0, w, h);
            }

            if (settings.backgroundColor)
            {
                ctx.fillStyle = settings.backgroundColor;
                ctx.fillRect(0, 0, w, h);
            }
        }

        this.drawCount += list.length;

        if (scissor)
        {
            ctx.save();
            ctx.beginPath();
            ctx.rect(camera.x, camera.y, camera.width, camera.height);
            ctx.clip();
            ctx.closePath();
        }

        var matrix = camera.matrix.matrix;
        ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);

        for (var c = 0; c < list.length; c++)
        {
            var child = list[c];

            child.renderCanvas(this, child, interpolationPercentage, camera);
        }
        //  Call the State.render function
        state.render.call(state, ctx, interpolationPercentage);
        
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (camera._fadeAlpha > 0 || camera._flashAlpha > 0)
        {
            // fade rendering
            ctx.fillStyle = 'rgb(' + (camera._fadeRed * 255) + ',' + (camera._fadeGreen * 255) + ',' + (camera._fadeBlue * 255) + ')';
            ctx.globalAlpha = camera._fadeAlpha;
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

            // flash rendering
            ctx.fillStyle = 'rgb(' + (camera._flashRed * 255) + ',' + (camera._flashGreen * 255) + ',' + (camera._flashBlue * 255) + ')';
            ctx.globalAlpha = camera._flashAlpha;
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

            ctx.globalAlpha = 1.0;
        }

        //  Reset the camera scissor
        if (scissor)
        {
            ctx.restore();
        }
        
        //  Blast it to the Game Canvas (if needed)
        if (settings.renderToTexture)
        {
            this.gameContext.drawImage(state.sys.canvas, 0, 0, w, h, settings.x, settings.y, w, h);
        }
    },

    postRender: function ()
    {
        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');

        var ctx = this.gameContext;

        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';

        this.currentAlpha = 1;
        this.currentBlendMode = 0;

        //  Add Post-render hook
    },

    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @method destroy
     * @param [removegameCanvas=true] {boolean} Removes the Canvas element from the DOM.
     */
    destroy: function ()
    {
        //  CanvasPool

        this.gameCanvas = null;
        this.gameContext = null;
    }

};

module.exports = CanvasRenderer;


/***/ },
/* 480 */
/***/ function(module, exports) {


//  No scaling, anchor, rotation or effects, literally draws the frame directly to the canvas
var BlitImage = function (dx, dy, frame, camera)
{
    var ctx = this.currentContext;
    var cd = frame.canvasData;

    ctx.drawImage(
        frame.source.image,
        cd.sx,
        cd.sy,
        cd.sWidth,
        cd.sHeight,
        dx - camera.scrollX,
        dy - camera.scrollY,
        cd.dWidth,
        cd.dHeight
    );
};

module.exports = BlitImage;


/***/ },
/* 481 */
/***/ function(module, exports) {


var DrawImage = function (src, camera)
{
    var ctx = this.currentContext;
    var frame = src.frame;
    var cd = frame.canvasData;

    //  Blend Mode

    if (this.currentBlendMode !== src.blendMode)
    {
        this.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = this.blendModes[src.blendMode];
    }

    //  Alpha

    if (this.currentAlpha !== src.alpha)
    {
        this.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing

    if (this.currentScaleMode !== src.scaleMode)
    {
        this.currentScaleMode = src.scaleMode;
        // ctx[this.smoothProperty] = (source.scaleMode === ScaleModes.LINEAR);
    }

    var dx = frame.x - src.originX - camera.scrollX;
    var dy = frame.y - src.originY - camera.scrollY;

    ctx.save();
    ctx.translate(src.x, src.y);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);
    ctx.drawImage(frame.source.image, cd.sx, cd.sy, cd.sWidth, cd.sHeight, dx, dy, cd.dWidth, cd.dHeight);
    ctx.restore();
};

module.exports = DrawImage;


/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

var modes = __webpack_require__(72);
var CanvasFeatures = __webpack_require__(81);

var GetBlendModes = function ()
{
    var output = [];
    var useNew = CanvasFeatures.supportNewBlendModes;

    output[modes.NORMAL] = 'source-over';
    output[modes.ADD] = 'lighter';
    output[modes.MULTIPLY] = (useNew) ? 'multiply' : 'source-over';
    output[modes.SCREEN] = (useNew) ? 'screen' : 'source-over';
    output[modes.OVERLAY] = (useNew) ? 'overlay' : 'source-over';
    output[modes.DARKEN] = (useNew) ? 'darken' : 'source-over';
    output[modes.LIGHTEN] = (useNew) ? 'lighten' : 'source-over';
    output[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : 'source-over';
    output[modes.COLOR_BURN] = (useNew) ? 'color-burn' : 'source-over';
    output[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : 'source-over';
    output[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : 'source-over';
    output[modes.DIFFERENCE] = (useNew) ? 'difference' : 'source-over';
    output[modes.EXCLUSION] = (useNew) ? 'exclusion' : 'source-over';
    output[modes.HUE] = (useNew) ? 'hue' : 'source-over';
    output[modes.SATURATION] = (useNew) ? 'saturation' : 'source-over';
    output[modes.COLOR] = (useNew) ? 'color' : 'source-over';
    output[modes.LUMINOSITY] = (useNew) ? 'luminosity' : 'source-over';

    return output;
};

module.exports = GetBlendModes;


/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey (@photonstorm)
* @author       Felipe Alfonso (@bitnenfer)
* @copyright    2017 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);
var CreateEmptyTexture = __webpack_require__(501);
var CreateTexture2DImage = __webpack_require__(157);
var BlitterBatch = __webpack_require__(488);
var AAQuadBatch = __webpack_require__(484);
var SpriteBatch = __webpack_require__(498);
var ShapeBatch = __webpack_require__(493);
var BlendModes = __webpack_require__(72);

var WebGLRenderer = function (game)
{
    this.game = game;
    this.type = CONST.WEBGL;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.resolution = game.config.resolution;
    this.view = game.canvas;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.contextLost = false;
    this.maxTextures = 1;
    this.multiTexture = false;
    this.blendModes = [];
    this.gl = null;
    this.extensions = null;
    this.batches = [];
    this.blitterBatch = null;
    this.aaQuadBatch = null;
    this.spriteBatch = null;
    this.shapeBatch = null;
    this.batch = null;
    this.currentTexture2D = null;

    this.init();
};

WebGLRenderer.prototype.constructor = WebGLRenderer;

WebGLRenderer.prototype = {

    init: function ()
    {
        console.log('WebGLRenderer.init');

        this.gl = this.view.getContext('webgl', this.config.WebGLContextOptions) || this.view.getContext('experimental-webgl', this.config.WebGLContextOptions);

        if (!this.gl)
        {
            this.contextLost = true;
            throw new Error('This browser does not support WebGL. Try using the Canvas renderer.');
        }

        var gl = this.gl;
        var color = this.game.config.backgroundColor;
    
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.clearColor(color.redGL, color.greenGL, color.blueGL, color.alphaGL);

        this.resize(this.width, this.height);

        //  Map Blend Modes

        var add = [ gl.SRC_ALPHA, gl.DST_ALPHA ];
        var normal = [ gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
        var multiply = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];
        var screen = [ gl.SRC_ALPHA, gl.ONE ];

        this.blendModes = [
            normal, add, multiply, screen, normal,
            normal, normal, normal, normal,
            normal, normal, normal, normal,
            normal, normal, normal, normal
        ];

        this.blendMode = -1;
        this.extensions = gl.getSupportedExtensions();
        this.blitterBatch = this.addBatch(new BlitterBatch(this.game, gl, this));
        this.aaQuadBatch = this.addBatch(new AAQuadBatch(this.game, gl, this));
        this.spriteBatch = this.addBatch(new SpriteBatch(this.game, gl, this));
        this.shapeBatch = this.addBatch(new ShapeBatch(this.game, gl, this));
    },

    createTexture2D: function (source)
    {
        var gl = this.gl;

        if (!source.glTexture)
        {
            source.glTexture = CreateTexture2DImage(gl, source.image, gl.NEAREST, 0);
        }

        this.currentTexture2D = source.glTexture;
    },

    setTexture2D: function (texture2D)
    {
        if (this.currentTexture2D !== texture2D)
        {
            if (this.batch)
            {
                this.batch.flush();
            }

            var gl = this.gl;

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture2D);

            this.currentTexture2D = texture2D;
        }
    },

    setBatch: function (batch, texture2D, camera)
    {
        var gl = this.gl;
        this.setTexture2D(texture2D);

        if (this.batch !== batch)
        {
            if (this.batch)
            {
                this.batch.flush();
            }

            batch.bind();

            this.batch = batch;
        }
    },

    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.view.width = this.width;
        this.view.height = this.height;

        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        this.gl.viewport(0, 0, this.width, this.height);
        for (var i = 0, l = this.batches.length; i < l; ++i)
        {
            this.batches[i].bind();
            this.batches[i].resize(width, height, resolution);
        }
        if (this.batch) 
        {
            this.batch.bind();
        }
    },

    //  Call at the start of the render loop
    preRender: function ()
    {
        //  No point rendering if our context has been blown up!
        if (this.contextLost)
        {
            return;
        }

        //  Add Pre-render hook

        var gl = this.gl;
        var color = this.game.config.backgroundColor;

        gl.clearColor(color.redGL, color.greenGL, color.blueGL, color.alphaGL);
        // Some drivers require to call glClear
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

        this.setBlendMode(BlendModes.NORMAL);
    },

    /**
     * Renders a single State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, children, interpolationPercentage, camera)
    {
        //  Could move to the State Systems or MainLoop
        var gl = this.gl;
        var scissor = (camera.x !== 0 || camera.y !== 0 || camera.width !== gl.canvas.width || camera.height !== gl.canvas.height);

        if (scissor)
        {
            gl.enable(gl.SCISSOR_TEST);
            gl.scissor(camera.x, (gl.drawingBufferHeight - camera.y - camera.height), camera.width, camera.height);
        }
        // We could either clear color or render a quad
        gl.clear(gl.COLOR_BUFFER_BIT);

        var list = children.list;
        var length = list.length;
        for (var index = 0; index < length; ++index)
        {
            var child = list[index];
            // Setting blend mode if needed            
            var batch = this.batch;
            var newBlendMode = child.blendMode;
            if (this.blendMode !== newBlendMode)
            {
                if (batch) 
                {
                    batch.flush();
                }
                var blend = this.blendModes[newBlendMode];
                gl.enable(gl.BLEND);
                if (blend.length > 2)
                {
                    gl.blendFuncSeparate(blend[0], blend[1], blend[2], blend[3]);
                }
                else
                {
                    gl.blendFunc(blend[0], blend[1]);        
                }
                this.blendMode = newBlendMode;
            }
            // drawing child
            child.renderWebGL(this, child, interpolationPercentage, camera);
            batch = this.batch;
            if (batch && batch.isFull())
            {
                batch.flush();
            }
        }
        if (this.batch)
        {
            this.batch.flush();
        }
        if (camera._fadeAlpha > 0 || camera._flashAlpha > 0)
        {
            var aaQuadBatch = this.aaQuadBatch;
            aaQuadBatch.bind();
            // fade rendering
            aaQuadBatch.add(
                camera.x, camera.y, camera.width, camera.height, 
                camera._fadeRed, 
                camera._fadeGreen, 
                camera._fadeBlue, 
                camera._fadeAlpha
            );
            // flash rendering
            aaQuadBatch.add(
                camera.x, camera.y, camera.width, camera.height, 
                camera._flashRed, 
                camera._flashGreen, 
                camera._flashBlue, 
                camera._flashAlpha
            );
            aaQuadBatch.flush();
            this.batch.bind();
        }
        if (scissor)
        {
            gl.disable(gl.SCISSOR_TEST);
        }
    },

    //  Called at the end of the render loop (tidy things up, etc)
    postRender: function ()
    {
        if (this.batch)
        {
            this.batch.flush();
        }
        //  Add Post-render hook

        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');
    },

    destroy: function ()
    {
        this.gl = null;
    },

    createFBO: function () {},

    setBlendMode: function (newBlendMode)
    {
        var gl = this.gl;
        var batch = this.batch;
        var blend = null;

        if (this.blendMode !== newBlendMode)
        {
            if (batch)
                batch.flush();
            blend = this.blendModes[newBlendMode];
            gl.enable(gl.BLEND);
            if (blend.length > 2)
            {
                gl.blendFuncSeparate(blend[0], blend[1], blend[2], blend[3]);
            }
            else
            {
                gl.blendFunc(blend[0], blend[1]);        
            }
            this.blendMode = newBlendMode;
        }
    },

    addBatch: function (batchInstance)
    {
        var index = this.batches.indexOf(batchInstance);
        if (index < 0) 
        {
            this.batches.push(batchInstance);
            return batchInstance;
        }
        return null;
    }
};

module.exports = WebGLRenderer;


/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

var BindVertexArray = __webpack_require__(48);
var CreateProgram = __webpack_require__(46);
var CreateShader = __webpack_require__(47);
var CreateBuffer = __webpack_require__(45);
var CreateAttribDesc = __webpack_require__(49);
var Buffer32 = __webpack_require__(44);
var Buffer16 = __webpack_require__(73);
var VertexArray = __webpack_require__(50);

var PHASER_CONST = __webpack_require__(2);
var CONST = __webpack_require__(487);

var AAQuadBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxQuads = null;
    this.vertShader = null;
    this.fragShader = null;
    this.program = null;
    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

AAQuadBatch.prototype.constructor = AAQuadBatch;

AAQuadBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new Buffer32(CONST.VERTEX_SIZE * CONST.AAQUAD_VERTEX_COUNT * CONST.MAX_AAQUAD);
        var indexDataBuffer = new Buffer16(CONST.INDEX_SIZE * CONST.AAQUAD_INDEX_COUNT * CONST.MAX_AAQUAD);
        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);
        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());
        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_color', 4, gl.FLOAT, false, CONST.VERTEX_SIZE, 8)
        ];
        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);
        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_AAQUAD * CONST.AAQUAD_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;
        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;
        this.viewMatrixLocation = viewMatrixLocation;

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.AAQUAD_INDEX_COUNT, indexB += CONST.AAQUAD_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexBuffer);

        this.bind();
        this.resize(this.width, this.height, this.game.config.resolution);
        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    add: function (x, y, width, height, red, green, blue, alpha)
    {
        // The user must check if the buffers are full before flushing
        // this is to give freedom of when should the renderer flush. var vertexDataBuffer = this.vertexDataBuffer;
        var vertexDataBuffer = this.vertexDataBuffer;
        var floatBuffer = vertexDataBuffer.floatView;
        var vertexOffset = vertexDataBuffer.allocate(CONST.AAQUAD_VERTEX_COMPONENT_COUNT * CONST.AAQUAD_VERTEX_COUNT);

        floatBuffer[vertexOffset++] = x;
        floatBuffer[vertexOffset++] = y;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x;
        floatBuffer[vertexOffset++] = y + height;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x + width;
        floatBuffer[vertexOffset++] = y + height;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x + width;
        floatBuffer[vertexOffset++] = y;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        this.elementCount += CONST.AAQUAD_INDEX_COUNT;
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);
        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());
        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height, resolution)
    {
        var gl = this.glContext;
        
        this.width = width * resolution;
        this.height = height * resolution;
        
        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    }
};

module.exports = AAQuadBatch;


/***/ },
/* 485 */
/***/ function(module, exports) {

module.exports = [
    'precision lowp float;',
    'varying vec4 v_color;',
    'void main() {',
    '   gl_FragColor = v_color;',
    '}'
].join('\n');


/***/ },
/* 486 */
/***/ function(module, exports) {

module.exports = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec4 a_color;',
    'varying vec4 v_color;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_color = a_color;',
    '}'
].join('\n');

/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(485);
var VertexShader = __webpack_require__(486);

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec4)
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    AAQUAD_VERTEX_COUNT: 4,
    AAQUAD_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    AAQUAD_VERTEX_COMPONENT_COUNT: 6,
    MAX_AAQUAD: 2000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

//  Could you move these into sub-folders please, i.e. 'vao', 'shader' etc?

var BindVertexArray = __webpack_require__(48);
var CreateProgram = __webpack_require__(46);
var CreateShader = __webpack_require__(47);
var CreateBuffer = __webpack_require__(45);
var CreateAttribDesc = __webpack_require__(49);
var Buffer32 = __webpack_require__(44);
var Buffer16 = __webpack_require__(73);
var VertexArray = __webpack_require__(50);

var PHASER_CONST = __webpack_require__(2);
var CONST = __webpack_require__(491);

var BlitterBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxParticles = null;
    this.vertShader = null;
    this.fragShader = null;
    this.program = null;
    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.currentTexture2D = null;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

BlitterBatch.prototype.constructor = BlitterBatch;

BlitterBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new Buffer32(CONST.VERTEX_SIZE * CONST.PARTICLE_VERTEX_COUNT * CONST.MAX_PARTICLES);
        var indexDataBuffer = new Buffer16(CONST.INDEX_SIZE * CONST.PARTICLE_INDEX_COUNT * CONST.MAX_PARTICLES);
        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);
        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());
        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_tex_coord', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8),
            CreateAttribDesc(gl, program, 'a_alpha', 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 16)
        ];
        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);
        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_PARTICLES * CONST.PARTICLE_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;
        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;
        this.viewMatrixLocation = viewMatrixLocation;
        this.maxParticles = max;

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.PARTICLE_INDEX_COUNT, indexB += CONST.PARTICLE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexBuffer);

        this.bind();
        this.resize(this.width, this.height, this.game.config.resolution);
        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);
        gl.clearColor(0, 0, 0, 1);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);
        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());
        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height, resolution)
    {
        var gl = this.glContext;
        
        this.width = width * resolution;
        this.height = height * resolution;
        
        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    }
};

module.exports = BlitterBatch;


/***/ },
/* 489 */
/***/ function(module, exports) {

module.exports = [
    'precision lowp float;',
    'uniform sampler2D u_sampler2D;',
    'varying vec2 v_tex_coord;',
    'varying float v_alpha;',
    'void main() {',
    '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord) * vec4(1.0, 1.0, 1.0, v_alpha);',
    '}'
].join('\n');


/***/ },
/* 490 */
/***/ function(module, exports) {

module.exports = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec2 a_tex_coord;',
    'attribute float a_alpha;',
    'varying vec2 v_tex_coord;',
    'varying float v_alpha;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_tex_coord = a_tex_coord;',
    '	v_alpha = a_alpha;',
    '}'
].join('\n');


/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(489);
var VertexShader = __webpack_require__(490);

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec2) + sizeof(float)
    VERTEX_SIZE: 20,
    INDEX_SIZE: 2,
    PARTICLE_VERTEX_COUNT: 4,
    PARTICLE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    PARTICLE_VERTEX_COMPONENT_COUNT: 5,

    // Can't be bigger than 10,000 since index are 16-bit
    MAX_PARTICLES: 2000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 492 */
/***/ function(module, exports) {

module.exports = [
    'precision mediump float;',
    'varying vec4 v_color;',
    'varying float v_alpha;',
    'void main() {',
    '   gl_FragColor = vec4(v_color.bgr, v_alpha);',
    '}'
].join('\n');


/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

var BindVertexArray = __webpack_require__(48);
var CreateProgram = __webpack_require__(46);
var CreateShader = __webpack_require__(47);
var CreateBuffer = __webpack_require__(45);
var CreateAttribDesc = __webpack_require__(49);
var Buffer32 = __webpack_require__(44);
var VertexArray = __webpack_require__(50);
var Earcut = __webpack_require__(496);

var PHASER_CONST = __webpack_require__(2);
var CONST = __webpack_require__(495);

var ShapeBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxVertices = null;
    this.vertShader = null;
    this.fragShader = null;
    this.program = null;
    this.vertexArray = null;
    this.vertexDataBuffer = null;
    this.vertexCount = 0;
    this.viewMatrixLocation = null;
    this.tempTriangle = [
        {x: 0, y: 0},
        {x: 0, y: 0},
        {x: 0, y: 0},
        {x: 0, y: 0}
    ];

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;
    this.context = null;
    this.init(this.glContext);

};

ShapeBatch.prototype.constructor = ShapeBatch;

ShapeBatch.prototype = {

    init: function (gl)
    {
        var vertexDataBuffer = new Buffer32(CONST.VERTEX_SIZE * CONST.MAX_VERTICES);
        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);
        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_color', 4, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 8),
            CreateAttribDesc(gl, program, 'a_alpha', 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 12)
        ];
        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);
        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');
        var max = CONST.MAX_VERTICES;

        this.vertexDataBuffer = vertexDataBuffer;
        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;
        this.vertexArray = vertexArray;
        this.viewMatrixLocation = viewMatrixLocation;
        this.maxVertices = max;
        this.polygonCache = [];

        this.bind();
        this.resize(this.width, this.height, this.game.config.resolution);
        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);
        gl.clearColor(0, 0, 0, 1);
        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.vertexCount > 0)
        {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());
            gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
            vertexDataBuffer.clear();
            this.vertexCount = 0;
        }
    },

    resize: function (width, height, resolution)
    {
        var gl = this.glContext;
        
        this.width = width * resolution;
        this.height = height * resolution;
        
        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    },

    addLine: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* line properties */
        ax, ay, bx, by, lineWidth, lineColor, lineAlpha,
        /* transform */
        a, b, c, d, e, f
    ) {
        if (this.vertexCount + 6 > this.maxVertices)
        {
            this.flush();
        }

        this.vertexCount += 6;

        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var dx = bx - ax;
        var dy = by - ay;
        var len = Math.sqrt(dx * dx + dy * dy);
        var l0 = lineWidth * (by - ay) / len;
        var l1 = lineWidth * (ax - bx) / len;
        var lx0 = bx - l0;
        var ly0 = by - l1;
        var lx1 = ax - l0;
        var ly1 = ay - l1;
        var lx2 = bx + l0;
        var ly2 = by + l1;
        var lx3 = ax + l0;
        var ly3 = ay + l1;
        var x0 = lx0 * a + ly0 * c + e;
        var y0 = lx0 * b + ly0 * d + f;
        var x1 = lx1 * a + ly1 * c + e;
        var y1 = lx1 * b + ly1 * d + f;
        var x2 = lx2 * a + ly2 * c + e;
        var y2 = lx2 * b + ly2 * d + f;
        var x3 = lx3 * a + ly3 * c + e;
        var y3 = lx3 * b + ly3 * d + f;
        var vertexOffset = vertexDataBuffer.allocate(24);

        vertexBufferF32[vertexOffset++] = x0;
        vertexBufferF32[vertexOffset++] = y0;
        vertexBufferU32[vertexOffset++] = lineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        vertexBufferF32[vertexOffset++] = x1;
        vertexBufferF32[vertexOffset++] = y1;
        vertexBufferU32[vertexOffset++] = lineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        vertexBufferF32[vertexOffset++] = x2;
        vertexBufferF32[vertexOffset++] = y2;
        vertexBufferU32[vertexOffset++] = lineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        vertexBufferF32[vertexOffset++] = x1;
        vertexBufferF32[vertexOffset++] = y1;
        vertexBufferU32[vertexOffset++] = lineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        vertexBufferF32[vertexOffset++] = x3;
        vertexBufferF32[vertexOffset++] = y3;
        vertexBufferU32[vertexOffset++] = lineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        vertexBufferF32[vertexOffset++] = x2;
        vertexBufferF32[vertexOffset++] = y2;
        vertexBufferU32[vertexOffset++] = lineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        return [
            x0, y0,
            x1, y1,
            x2, y2,
            x3, y3
        ];

    },

    addStrokePath: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Path properties */
        path, lineWidth, lineColor, lineAlpha,
        /* transform */
        a, b, c, d, e, f,
        /* is last connection */
        isLastPath
    ) {
        var point0, point1;
        var pathLength = path.length;
        var polylines = this.polygonCache;
        var halfLineWidth = lineWidth * 0.5;
        var last, curr;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset;
        var x0, y0, x1, y1, x2, y2;

        for (var pathIndex = 0; pathIndex + 1 < pathLength; pathIndex += 1)
        {
            point0 = path[pathIndex];
            point1 = path[pathIndex + 1];
            polylines.push(this.addLine(
                srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                point0.x, point0.y, point1.x, point1.y, halfLineWidth, lineColor, lineAlpha,
                a, b, c, d, e, f
            ));
        }

        if (lineWidth < 1.0)
            return;

        if (isLastPath)
        {
            for (var index = 0, polylinesLength = polylines.length;
                index < polylinesLength; ++index)
            {

                if (this.vertexCount + 6 > this.maxVertices)
                {
                    this.flush();
                }

                last = polylines[index - 1];
                curr = polylines[index];
                vertexOffset = vertexDataBuffer.allocate(24)

                x0 = last[2 * 2 + 0];
                y0 = last[2 * 2 + 1];
                x1 = last[2 * 0 + 0];
                y1 = last[2 * 0 + 1];
                x2 = curr[2 * 3 + 0];
                y2 = curr[2 * 3 + 1];

                vertexBufferF32[vertexOffset++] = x0;
                vertexBufferF32[vertexOffset++] = y0;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;
                vertexBufferF32[vertexOffset++] = x1;
                vertexBufferF32[vertexOffset++] = y1;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;
                vertexBufferF32[vertexOffset++] = x2;
                vertexBufferF32[vertexOffset++] = y2;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;

                x0 = last[2 * 0 + 0];
                y0 = last[2 * 0 + 1];
                x1 = last[2 * 2 + 0];
                y1 = last[2 * 2 + 1];
                x2 = curr[2 * 1 + 0];
                y2 = curr[2 * 1 + 1];

                vertexBufferF32[vertexOffset++] = x0;
                vertexBufferF32[vertexOffset++] = y0;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;
                vertexBufferF32[vertexOffset++] = x1;
                vertexBufferF32[vertexOffset++] = y1;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;
                vertexBufferF32[vertexOffset++] = x2;
                vertexBufferF32[vertexOffset++] = y2;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;
            
                this.vertexCount += 6;
            }
        }
        else
        {
            for (var index = 0, polylinesLength = polylines.length;
                index < polylinesLength; ++index)
            {

                if (this.vertexCount + 6 > this.maxVertices)
                {
                    this.flush();
                }

                last = polylines[index - 1] || polylines[polylinesLength - 1];
                curr = polylines[index];
                vertexOffset = vertexDataBuffer.allocate(24)

                x0 = last[2 * 2 + 0];
                y0 = last[2 * 2 + 1];
                x1 = last[2 * 0 + 0];
                y1 = last[2 * 0 + 1];
                x2 = curr[2 * 3 + 0];
                y2 = curr[2 * 3 + 1];

                vertexBufferF32[vertexOffset++] = x0;
                vertexBufferF32[vertexOffset++] = y0;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;
                vertexBufferF32[vertexOffset++] = x1;
                vertexBufferF32[vertexOffset++] = y1;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;
                vertexBufferF32[vertexOffset++] = x2;
                vertexBufferF32[vertexOffset++] = y2;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;

                x0 = last[2 * 0 + 0];
                y0 = last[2 * 0 + 1];
                x1 = last[2 * 2 + 0];
                y1 = last[2 * 2 + 1];
                x2 = curr[2 * 1 + 0];
                y2 = curr[2 * 1 + 1];
                
                vertexBufferF32[vertexOffset++] = x0;
                vertexBufferF32[vertexOffset++] = y0;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;
                vertexBufferF32[vertexOffset++] = x1;
                vertexBufferF32[vertexOffset++] = y1;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;
                vertexBufferF32[vertexOffset++] = x2;
                vertexBufferF32[vertexOffset++] = y2;
                vertexBufferU32[vertexOffset++] = lineColor;
                vertexBufferF32[vertexOffset++] = lineAlpha;

                this.vertexCount += 6;
            }
        }
        polylines.length = 0;
    },

    addFillPath: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Path properties */
        path, fillColor, fillAlpha,
        /* transform */
        a, b, c, d, e, f
    ) {
        var length = path.length;
        var polygonCache = this.polygonCache;
        var polygonIndexArray;
        var point;
        var v0, v1, v2;
        var vertexOffset;
        var vertexCount = this.vertexCount;
        var maxVertices = this.maxVertices;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var x0, y0, x1, y1, x2, y2;
        var tx0, ty0, tx1, ty1, tx2, ty2;

        for (var pathIndex = 0; pathIndex < length; ++pathIndex)
        {
            point = path[pathIndex];
            polygonCache.push(point.x, point.y);
        }
        polygonIndexArray = Earcut(polygonCache);
        length = polygonIndexArray.length;

        for (var index = 0; index < length; index += 3)
        {
            v0 = polygonIndexArray[index + 0] * 2;
            v1 = polygonIndexArray[index + 1] * 2;
            v2 = polygonIndexArray[index + 2] * 2;

            if (vertexCount + 3 > maxVertices)
            {
                this.vertexCount = vertexCount;
                this.flush();
                vertexCount = 0;
            }
            vertexOffset = vertexDataBuffer.allocate(12);
            vertexCount += 3;

            x0 = polygonCache[v0 + 0];
            y0 = polygonCache[v0 + 1];
            x1 = polygonCache[v1 + 0];
            y1 = polygonCache[v1 + 1];
            x2 = polygonCache[v2 + 0];
            y2 = polygonCache[v2 + 1];

            tx0 = x0 * a + y0 * c + e;
            ty0 = x0 * b + y0 * d + f;
            tx1 = x1 * a + y1 * c + e;
            ty1 = x1 * b + y1 * d + f;
            tx2 = x2 * a + y2 * c + e;
            ty2 = x2 * b + y2 * d + f;

            vertexBufferF32[vertexOffset++] = tx0;
            vertexBufferF32[vertexOffset++] = ty0;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

            vertexBufferF32[vertexOffset++] = tx1;
            vertexBufferF32[vertexOffset++] = ty1;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

            vertexBufferF32[vertexOffset++] = tx2;
            vertexBufferF32[vertexOffset++] = ty2;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

        }
        this.vertexCount = vertexCount;
        polygonCache.length = 0;
    },

    addFillRect: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Rectangle properties */
        x, y, width, height, fillColor, fillAlpha,
        /* transform */
        a, b, c, d, e, f
    ) {
        if (this.vertexCount + 6 > this.maxVertices)
        {
            this.flush();
        }
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = vertexDataBuffer.allocate(24);
        var xw = x + width;
        var yh = y + height;
        var tx0 = x * a + y * c + e;
        var ty0 = x * b + y * d + f;
        var tx1 = x * a + yh * c + e;
        var ty1 = x * b + yh * d + f;
        var tx2 = xw * a + yh * c + e;
        var ty2 = xw * b + yh * d + f;
        var tx3 = xw * a + y * c + e;
        var ty3 = xw * b + y * d + f;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx3;
        vertexBufferF32[vertexOffset++] = ty3;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        this.vertexCount += 6;
    },

    addFillTriangle: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Triangle properties */
        x0, y0, x1, y1, x2, y2, fillColor, fillAlpha,
        /* transform */
        a, b, c, d, e, f
    ) {
        if (this.vertexCount + 3 > this.maxVertices)
        {
            this.flush();
        }
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = vertexDataBuffer.allocate(12);
        var tx0 = x0 * a + y0 * c + e;
        var ty0 = x0 * b + y0 * d + f;
        var tx1 = x1 * a + y1 * c + e;
        var ty1 = x1 * b + y1 * d + f;
        var tx2 = x2 * a + y2 * c + e;
        var ty2 = x2 * b + y2 * d + f;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        this.vertexCount += 3;
    },

    addStrokeTriangle: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Triangle properties */
        x0, y0, x1, y1, x2, y2, lineWidth, lineColor, lineAlpha,
        /* transform */
        a, b, c, d, e, f
    ) {
        var tempTriangle = this.tempTriangle;

        tempTriangle[0].x = x0;
        tempTriangle[0].y = y0;
        tempTriangle[1].x = x1;
        tempTriangle[1].y = y1;
        tempTriangle[2].x = x2;
        tempTriangle[2].y = y2;
        tempTriangle[3].x = x0;
        tempTriangle[3].y = y0;

        this.addStrokePath(
            srcX, srcY, srcScaleX, srcScaleY, srcRotation,
            tempTriangle, lineWidth, lineColor, lineAlpha,
            a, b, c, d, e, f
        );
    }
};

module.exports = ShapeBatch;


/***/ },
/* 494 */
/***/ function(module, exports) {

module.exports = [
    'precision mediump float;',
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec4 a_color;',
    'attribute float a_alpha;',
    'varying vec4 v_color;',
    'varying float v_alpha;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_color = a_color;',
    '   v_alpha = a_alpha;',
    '}'
].join('\n');


/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(492);
var VertexShader = __webpack_require__(494);

var CONST = {

    VERTEX_SIZE: 16,

    // How many 32-bit components does the vertex have.
    SHAPE_VERTEX_COMPONENT_COUNT: 4,

    // Can't be bigger than 10,000 since index are 16-bit
    MAX_VERTICES: 16000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

var require;var require;!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var n;n="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,n.earcut=e()}}(function(){return function e(n,t,r){function x(u,f){if(!t[u]){if(!n[u]){var o="function"==typeof require&&require;if(!f&&o)return require(u,!0);if(i)return i(u,!0);var v=new Error("Cannot find module '"+u+"'");throw v.code="MODULE_NOT_FOUND",v}var l=t[u]={exports:{}};n[u][0].call(l.exports,function(e){var t=n[u][1][e];return x(t?t:e)},l,l.exports,e,n,t,r)}return t[u].exports}for(var i="function"==typeof require&&require,u=0;u<r.length;u++)x(r[u]);return x}({1:[function(e,n,t){"use strict";function r(e,n,t){t=t||2;var r=n&&n.length,i=r?n[0]*t:e.length,f=x(e,0,i,t,!0),o=[];if(!f)return o;var v,l,p,a,h,s,c;if(r&&(f=y(e,n,f,t)),e.length>80*t){v=p=e[0],l=a=e[1];for(var d=t;i>d;d+=t)h=e[d],s=e[d+1],v>h&&(v=h),l>s&&(l=s),h>p&&(p=h),s>a&&(a=s);c=Math.max(p-v,a-l)}return u(f,o,t,v,l,c),o}function x(e,n,t,r,x){var i,u;if(x===_(e,n,t,r)>0)for(i=n;t>i;i+=r)u=E(i,e[i],e[i+1],u);else for(i=t-r;i>=n;i-=r)u=E(i,e[i],e[i+1],u);return u&&z(u,u.next)&&(N(u),u=u.next),u}function i(e,n){if(!e)return e;n||(n=e);var t,r=e;do if(t=!1,r.steiner||!z(r,r.next)&&0!==b(r.prev,r,r.next))r=r.next;else{if(N(r),r=n=r.prev,r===r.next)return null;t=!0}while(t||r!==n);return n}function u(e,n,t,r,x,y,p){if(e){!p&&y&&s(e,r,x,y);for(var a,h,c=e;e.prev!==e.next;)if(a=e.prev,h=e.next,y?o(e,r,x,y):f(e))n.push(a.i/t),n.push(e.i/t),n.push(h.i/t),N(e),e=h.next,c=h.next;else if(e=h,e===c){p?1===p?(e=v(e,n,t),u(e,n,t,r,x,y,2)):2===p&&l(e,n,t,r,x,y):u(i(e),n,t,r,x,y,1);break}}}function f(e){var n=e.prev,t=e,r=e.next;if(b(n,t,r)>=0)return!1;for(var x=e.next.next;x!==e.prev;){if(g(n.x,n.y,t.x,t.y,r.x,r.y,x.x,x.y)&&b(x.prev,x,x.next)>=0)return!1;x=x.next}return!0}function o(e,n,t,r){var x=e.prev,i=e,u=e.next;if(b(x,i,u)>=0)return!1;for(var f=x.x<i.x?x.x<u.x?x.x:u.x:i.x<u.x?i.x:u.x,o=x.y<i.y?x.y<u.y?x.y:u.y:i.y<u.y?i.y:u.y,v=x.x>i.x?x.x>u.x?x.x:u.x:i.x>u.x?i.x:u.x,l=x.y>i.y?x.y>u.y?x.y:u.y:i.y>u.y?i.y:u.y,y=d(f,o,n,t,r),p=d(v,l,n,t,r),a=e.nextZ;a&&a.z<=p;){if(a!==e.prev&&a!==e.next&&g(x.x,x.y,i.x,i.y,u.x,u.y,a.x,a.y)&&b(a.prev,a,a.next)>=0)return!1;a=a.nextZ}for(a=e.prevZ;a&&a.z>=y;){if(a!==e.prev&&a!==e.next&&g(x.x,x.y,i.x,i.y,u.x,u.y,a.x,a.y)&&b(a.prev,a,a.next)>=0)return!1;a=a.prevZ}return!0}function v(e,n,t){var r=e;do{var x=r.prev,i=r.next.next;!z(x,i)&&M(x,r,r.next,i)&&q(x,i)&&q(i,x)&&(n.push(x.i/t),n.push(r.i/t),n.push(i.i/t),N(r),N(r.next),r=e=i),r=r.next}while(r!==e);return r}function l(e,n,t,r,x,f){var o=e;do{for(var v=o.next.next;v!==o.prev;){if(o.i!==v.i&&w(o,v)){var l=D(o,v);return o=i(o,o.next),l=i(l,l.next),u(o,n,t,r,x,f),void u(l,n,t,r,x,f)}v=v.next}o=o.next}while(o!==e)}function y(e,n,t,r){var u,f,o,v,l,y=[];for(u=0,f=n.length;f>u;u++)o=n[u]*r,v=f-1>u?n[u+1]*r:e.length,l=x(e,o,v,r,!1),l===l.next&&(l.steiner=!0),y.push(Z(l));for(y.sort(p),u=0;u<y.length;u++)a(y[u],t),t=i(t,t.next);return t}function p(e,n){return e.x-n.x}function a(e,n){if(n=h(e,n)){var t=D(n,e);i(t,t.next)}}function h(e,n){var t,r=n,x=e.x,i=e.y,u=-(1/0);do{if(i<=r.y&&i>=r.next.y){var f=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(x>=f&&f>u){if(u=f,f===x){if(i===r.y)return r;if(i===r.next.y)return r.next}t=r.x<r.next.x?r:r.next}}r=r.next}while(r!==n);if(!t)return null;if(x===u)return t.prev;var o,v=t,l=t.x,y=t.y,p=1/0;for(r=t.next;r!==v;)x>=r.x&&r.x>=l&&g(y>i?x:u,i,l,y,y>i?u:x,i,r.x,r.y)&&(o=Math.abs(i-r.y)/(x-r.x),(p>o||o===p&&r.x>t.x)&&q(r,e)&&(t=r,p=o)),r=r.next;return t}function s(e,n,t,r){var x=e;do null===x.z&&(x.z=d(x.x,x.y,n,t,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next;while(x!==e);x.prevZ.nextZ=null,x.prevZ=null,c(x)}function c(e){var n,t,r,x,i,u,f,o,v=1;do{for(t=e,e=null,i=null,u=0;t;){for(u++,r=t,f=0,n=0;v>n&&(f++,r=r.nextZ,r);n++);for(o=v;f>0||o>0&&r;)0===f?(x=r,r=r.nextZ,o--):0!==o&&r?t.z<=r.z?(x=t,t=t.nextZ,f--):(x=r,r=r.nextZ,o--):(x=t,t=t.nextZ,f--),i?i.nextZ=x:e=x,x.prevZ=i,i=x;t=r}i.nextZ=null,v*=2}while(u>1);return e}function d(e,n,t,r,x){return e=32767*(e-t)/x,n=32767*(n-r)/x,e=16711935&(e|e<<8),e=252645135&(e|e<<4),e=858993459&(e|e<<2),e=1431655765&(e|e<<1),n=16711935&(n|n<<8),n=252645135&(n|n<<4),n=858993459&(n|n<<2),n=1431655765&(n|n<<1),e|n<<1}function Z(e){var n=e,t=e;do n.x<t.x&&(t=n),n=n.next;while(n!==e);return t}function g(e,n,t,r,x,i,u,f){return(x-u)*(n-f)-(e-u)*(i-f)>=0&&(e-u)*(r-f)-(t-u)*(n-f)>=0&&(t-u)*(i-f)-(x-u)*(r-f)>=0}function w(e,n){return e.next.i!==n.i&&e.prev.i!==n.i&&!m(e,n)&&q(e,n)&&q(n,e)&&O(e,n)}function b(e,n,t){return(n.y-e.y)*(t.x-n.x)-(n.x-e.x)*(t.y-n.y)}function z(e,n){return e.x===n.x&&e.y===n.y}function M(e,n,t,r){return z(e,n)&&z(t,r)||z(e,r)&&z(t,n)?!0:b(e,n,t)>0!=b(e,n,r)>0&&b(t,r,e)>0!=b(t,r,n)>0}function m(e,n){var t=e;do{if(t.i!==e.i&&t.next.i!==e.i&&t.i!==n.i&&t.next.i!==n.i&&M(t,t.next,e,n))return!0;t=t.next}while(t!==e);return!1}function q(e,n){return b(e.prev,e,e.next)<0?b(e,n,e.next)>=0&&b(e,e.prev,n)>=0:b(e,n,e.prev)<0||b(e,e.next,n)<0}function O(e,n){var t=e,r=!1,x=(e.x+n.x)/2,i=(e.y+n.y)/2;do t.y>i!=t.next.y>i&&x<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(r=!r),t=t.next;while(t!==e);return r}function D(e,n){var t=new U(e.i,e.x,e.y),r=new U(n.i,n.x,n.y),x=e.next,i=n.prev;return e.next=n,n.prev=e,t.next=x,x.prev=t,r.next=t,t.prev=r,i.next=r,r.prev=i,r}function E(e,n,t,r){var x=new U(e,n,t);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function N(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function U(e,n,t){this.i=e,this.x=n,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function _(e,n,t,r){for(var x=0,i=n,u=t-r;t>i;i+=r)x+=(e[u]-e[i])*(e[i+1]+e[u+1]),u=i;return x}n.exports=r,r.deviation=function(e,n,t,r){var x=n&&n.length,i=x?n[0]*t:e.length,u=Math.abs(_(e,0,i,t));if(x)for(var f=0,o=n.length;o>f;f++){var v=n[f]*t,l=o-1>f?n[f+1]*t:e.length;u-=Math.abs(_(e,v,l,t))}var y=0;for(f=0;f<r.length;f+=3){var p=r[f]*t,a=r[f+1]*t,h=r[f+2]*t;y+=Math.abs((e[p]-e[h])*(e[a+1]-e[p+1])-(e[p]-e[a])*(e[h+1]-e[p+1]))}return 0===u&&0===y?0:Math.abs((y-u)/u)},r.flatten=function(e){for(var n=e[0][0].length,t={vertices:[],holes:[],dimensions:n},r=0,x=0;x<e.length;x++){for(var i=0;i<e[x].length;i++)for(var u=0;n>u;u++)t.vertices.push(e[x][i][u]);x>0&&(r+=e[x-1].length,t.holes.push(r))}return t}},{}]},{},[1])(1)});

/***/ },
/* 497 */
/***/ function(module, exports) {

module.exports = [
    'precision lowp float;',
    'uniform sampler2D u_sampler2D;',
    'varying vec2 v_tex_coord;',
    'varying vec3 v_color;',
    'void main() {',
    '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord) * vec4(v_color, 1.0);',
    '}'
].join('\n');


/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

var BindVertexArray = __webpack_require__(48);
var CreateProgram = __webpack_require__(46);
var CreateShader = __webpack_require__(47);
var CreateBuffer = __webpack_require__(45);
var CreateAttribDesc = __webpack_require__(49);
var Buffer32 = __webpack_require__(44);
var Buffer16 = __webpack_require__(73);
var VertexArray = __webpack_require__(50);
var TransformMatrix = __webpack_require__(26);

var PHASER_CONST = __webpack_require__(2);
var CONST = __webpack_require__(500);

var SpriteBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxSprites = null;
    this.vertShader = null;
    this.fragShader = null;
    this.program = null;
    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.currentTexture2D = null;
    this.viewMatrixLocation = null;
    this.tempMatrix = new TransformMatrix();
    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

SpriteBatch.prototype.constructor = SpriteBatch;

SpriteBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new Buffer32(CONST.VERTEX_SIZE * CONST.SPRITE_VERTEX_COUNT * CONST.MAX_SPRITES);
        var indexDataBuffer = new Buffer16(CONST.INDEX_SIZE * CONST.SPRITE_INDEX_COUNT * CONST.MAX_SPRITES);
        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);
        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());
        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_tex_coord', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8),
            CreateAttribDesc(gl, program, 'a_color', 3, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 16)
        ];
        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);
        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_SPRITES * CONST.SPRITE_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;
        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;
        this.viewMatrixLocation = viewMatrixLocation;

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.SPRITE_INDEX_COUNT, indexB += CONST.SPRITE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexBuffer);

        this.bind();
        this.resize(this.width, this.height, this.game.config.resolution);
        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);
        gl.clearColor(0, 0, 0, 1);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);
        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        if (this.elementCount === 0)
        {
            return;
        }

        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());
        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height, resolution)
    {
        var gl = this.glContext;
        
        this.width = width * resolution;
        this.height = height * resolution;

        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    },

    addSprite: function (src, camera)
    {
        var tempMatrix = this.tempMatrix;
        var frame = src.frame;
        var alpha = 16777216;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var uvs = frame.uvs;
        var width = frame.width;
        var height = frame.height;
        var translateX = src.x - camera.scrollX;
        var translateY = src.y - camera.scrollY;
        var scaleX = src.scaleX;
        var scaleY = src.scaleY;
        var rotation = -src.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var x = -src.originX + frame.x;
        var y = -src.originY + frame.y;
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf; 
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setBatch(this, frame.texture.source[frame.sourceIndex].glTexture, camera);
        vertexOffset = vertexDataBuffer.allocate(20);
        this.elementCount += 6;
        
        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferF32[vertexOffset++] = uvs.x0;
        vertexBufferF32[vertexOffset++] = uvs.y0;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topLeft;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferF32[vertexOffset++] = uvs.x1;
        vertexBufferF32[vertexOffset++] = uvs.y1;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomLeft;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferF32[vertexOffset++] = uvs.x2;
        vertexBufferF32[vertexOffset++] = uvs.y2;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomRight;

        vertexBufferF32[vertexOffset++] = tx3;
        vertexBufferF32[vertexOffset++] = ty3;
        vertexBufferF32[vertexOffset++] = uvs.x3;
        vertexBufferF32[vertexOffset++] = uvs.y3;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topRight;
    }

};

module.exports = SpriteBatch;


/***/ },
/* 499 */
/***/ function(module, exports) {

module.exports = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec2 a_tex_coord;',
    'attribute vec3 a_color;',
    'varying vec2 v_tex_coord;',
    'varying vec3 v_color;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_tex_coord = a_tex_coord;',
    '   v_color = a_color;',
    '}'
].join('\n');


/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(497);
var VertexShader = __webpack_require__(499);

var CONST = {

    // VERTEX_SIZE = (sizeof(vec2) * 4) + (sizeof(float) + sizeof(uint32))
    VERTEX_SIZE: 20,
    INDEX_SIZE: 2,
    SPRITE_VERTEX_COUNT: 4,
    SPRITE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    SPRITE_VERTEX_COMPONENT_COUNT: 5,

    // Can't be bigger since index are 16-bit
    MAX_SPRITES: 2000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(41);

var CreateEmptyTexture = function (gl, width, height, scaleMode, textureIndex)
{
    var texture = gl.createTexture();
    var glScaleMode = (scaleMode === ScaleModes.LINEAR) ? gl.LINEAR : gl.NEAREST;

    gl.activeTexture(gl.TEXTURE0 + textureIndex);
    gl.bindTexture(gl.TEXTURE_2D, texture);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    //  We'll read from this texture, but it won't have mipmaps, so turn them off:
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glScaleMode);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glScaleMode);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    return texture;
};

module.exports = CreateEmptyTexture;


/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(41);
var CreateTexture2DImage = __webpack_require__(157);

var CreateTexture2DFromSource = function (gl, source)
{
    var filter;

    if (source.scaleMode === ScaleModes.LINEAR)
    {
        filter = gl.LINEAR;
    }
    else if (source.scaleMode === ScaleModes.NEAREST)
    {
        filter = gl.NEAREST;
    }

    source.glTexture = CreateTexture2DImage(gl, source.image, filter, source.mipmapLevel)
};

module.exports = CreateTexture2DFromSource;


/***/ },
/* 503 */
/***/ function(module, exports) {

var Attribute = function (location, size, type, normalized, stride, offset)
{
    this.location = location;
    this.size = size;
    this.type = type;
    this.normalized = normalized;
    this.stride = stride;
    this.offset = offset;
};

module.exports = Attribute;


/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {


var Between = __webpack_require__(64);
var GetObjectValue = __webpack_require__(36);

//  Phaser.Sound.Dynamic.FX

//  Based on Sound.js by KittyKatAttack
//  https://github.com/kittykatattack/sound.js

// frequency,      //The sound's fequency pitch in Hertz
// attack,              //The time, in seconds, to fade the sound in
// decay,               //The time, in seconds, to fade the sound out
// type,                //waveform type: "sine", "triangle", "square", "sawtooth"
// volume,         //The sound's maximum volume
// panValue,            //The speaker pan. left: -1, middle: 0, right: 1
// wait,                //The time, in seconds, to wait before playing the sound
// pitchBend,     //The number of Hz in which to bend the sound's pitch down
// reverse,             //If `reverse` is true the pitch will bend up
// random,         //A range, in Hz, within which to randomize the pitch
// dissonance,          //A value in Hz. It creates 2 dissonant frequencies above and below the target pitch
// echo,                //An array: [delayTimeInSeconds, feedbackTimeInSeconds, filterValueInHz]
// reverb,              //An array: [durationInSeconds, decayRateInSeconds, reverse]
// timeout              //A number, in seconds, which is the maximum duration for sound effects

var FX = function (ctx, config)
{
    this.audioContext = ctx;

    this.frequencyValue = GetObjectValue(config, 'frequency', 200);
    this.attack = GetObjectValue(config, 'attack', 0);
    this.decay = GetObjectValue(config, 'decay', 1);
    this.type = GetObjectValue(config, 'type', 'sine');
    this.volumeValue = GetObjectValue(config, 'volume', 1);
    this.panValue = GetObjectValue(config, 'pan', 0);
    this.wait = GetObjectValue(config, 'wait', 0);
    this.pitchBendAmount = GetObjectValue(config, 'pitchBend', 0);
    this.reverse = GetObjectValue(config, 'reverse', false);
    this.randomValue = GetObjectValue(config, 'random', 0);
    this.dissonance = GetObjectValue(config, 'dissonance', 0);
    this.echo = GetObjectValue(config, 'echo', false);
    this.echoDelay = GetObjectValue(config, 'echo.delay', 0);
    this.echoFeedback = GetObjectValue(config, 'echo.feedback', 0);
    this.echoFilter = GetObjectValue(config, 'echo.filter', 0);
    this.reverb = GetObjectValue(config, 'reverb', false);
    this.reverbDuration = GetObjectValue(config, 'reverb.duration', 0);
    this.reverbDecay = GetObjectValue(config, 'reverb.decay', 0);
    this.reverbReverse = GetObjectValue(config, 'reverb.reverse', false);
    this.timeout = GetObjectValue(config, 'timeout', false);

    this.volume = ctx.createGain();
    this.pan = (!ctx.createStereoPanner) ? ctx.createPanner() : ctx.createStereoPanner();

    this.volume.connect(this.pan);
    this.pan.connect(ctx.destination);

    //  Set the values

    this.volume.gain.value = this.volumeValue;

    if (!ctx.createStereoPanner)
    {
        this.pan.setPosition(this.panValue, 0, 1 - Math.abs(this.panValue));
    }
    else
    {
        this.pan.pan.value = this.panValue;
    }

    //  Create an oscillator, gain and pan nodes, and connect them together to the destination

    var oscillator = ctx.createOscillator();

    oscillator.connect(this.volume);
    oscillator.type = this.type;

    //  Optionally randomize the pitch if `randomValue` > 0.
    //  A random pitch is selected that's within the range specified by `frequencyValue`.
    //  The random pitch will be either above or below the target frequency.

    if (this.randomValue > 0)
    {
        oscillator.frequency.value = Between(
            this.frequencyValue - this.randomValue / 2,
            this.frequencyValue + this.randomValue / 2
        );
    }
    else
    {
        oscillator.frequency.value = this.frequencyValue;
    }

    //  Apply effects

    if (this.attack > 0)
    {
        this.fadeIn(this.volume);
    }

    this.fadeOut(this.volume);

    if (this.pitchBendAmount > 0)
    {
        this.pitchBend(oscillator);
    }

    if (this.echo)
    {
        this.addEcho(this.volume);
    }

    if (this.reverb)
    {
        this.addReverb(this.volume);
    }

    if (this.dissonance > 0)
    {
        this.addDissonance();
    }

    this.play(oscillator);

    var _this = this;

    oscillator.onended = function ()
    {
        console.log('onended');
        _this.pan.disconnect();
        _this.volume.disconnect();
    };
};

FX.prototype.constructor = FX;

FX.prototype = {

    play: function (oscillator)
    {
        oscillator.start(this.audioContext.currentTime + this.wait);

        //Oscillators have to be stopped otherwise they accumulate in 
        //memory and tax the CPU. They'll be stopped after a default
        //timeout of 2 seconds, which should be enough for most sound 
        //effects. Override this in the `soundEffect` parameters if you
        //need a longer sound

        oscillator.stop(this.audioContext.currentTime + this.wait + 2);
    },

    fadeIn: function (volume)
    {
        volume.gain.value = 0;

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait);

        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);
    },

    fadeOut: function (volume)
    {
        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait + this.attack + this.decay);
    },

    addReverb: function (volume)
    {
        var convolver = this.audioContext.createConvolver();

        convolver.buffer = this.impulseResponse(this.reverbDuration, this.reverbDecay, this.reverbReverse, this.audioContext);

        volume.connect(convolver);

        convolver.connect(this.pan);
    },

    addEcho: function (volume)
    {
        var feedback = this.audioContext.createGain();
        var delay = this.audioContext.createDelay();
        var filter = this.audioContext.createBiquadFilter();

        //  Set the node values

        feedback.gain.value = this.echoFeedback;
        delay.delayTime.value = this.echoDelay;

        if (this.echoFilter)
        {
            filter.frequency.value = this.echoFilter;
        }

        //  Create the delay feedback loop (with optional filtering)

        delay.connect(feedback);

        if (this.echoFilter)
        {
            feedback.connect(filter);
            filter.connect(delay);
        }
        else
        {
            feedback.connect(delay);
        }

        //  Connect the delay node to the oscillator volume node

        volume.connect(delay);

        //  Connect the delay node to the main sound chains pan node,
        //  so that the echo effect is directed to the correct speaker

        delay.connect(this.pan);
    },

    pitchBend: function (oscillator)
    {
        var frequency = oscillator.frequency.value;

        if (!this.reverse)
        {
            //  If reverse is false, make the sound drop in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency - this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }
        else
        {
            //  If reverse is true, make the sound rise in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency + this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }

    },

    addDissonance: function ()
    {
        //  Create two more oscillators and gain nodes

        var ctx = this.audioContext;

        var d1 = ctx.createOscillator();
        var d2 = ctx.createOscillator();
        var d1Volume = ctx.createGain();
        var d2Volume = ctx.createGain();

        //  Set the volume to the `volumeValue`
        d1Volume.gain.value = this.volumeValue;
        d2Volume.gain.value = this.volumeValue;

        //  Connect the oscillators to the gain and destination nodes
        d1.connect(d1Volume);
        d2.connect(d2Volume);

        d1Volume.connect(ctx.destination);
        d2Volume.connect(ctx.destination);

        //  Set the waveform to "sawtooth" for a harsh effect
        d1.type = 'sawtooth';
        d2.type = 'sawtooth';

        //  Make the two oscillators play at frequencies above and below the main sound's frequency.
        //  Use whatever value was supplied by the `dissonance` argument
        d1.frequency.value = this.frequencyValue + this.dissonance;
        d2.frequency.value = this.frequencyValue - this.dissonance;

        //  Fade in / out, pitch bend and play the oscillators to match the main sound
        if (this.attack > 0)
        {
            this.fadeIn(d1Volume);
            this.fadeIn(d2Volume);
        }

        if (this.decay > 0)
        {
            this.fadeOut(d1Volume);
            this.fadeOut(d2Volume);
        }

        if (this.pitchBendAmount > 0)
        {
            this.pitchBend(d1);
            this.pitchBend(d2);
        }

        if (this.echo)
        {
            this.addEcho(d1Volume);
            this.addEcho(d2Volume);
        }

        if (this.reverb)
        {
            this.addReverb(d1Volume);
            this.addReverb(d2Volume);
        }

        this.play(d1);
        this.play(d2);
    },

    impulseResponse: function (duration, decay, reverse)
    {
        //  The length of the buffer.
        var length = this.audioContext.sampleRate * duration;

        //  Create an audio buffer (an empty sound container) to store the reverb effect.
        var impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);

        //  Use `getChannelData` to initialize empty arrays to store sound data for the left and right channels.
        var left = impulse.getChannelData(0);
        var right = impulse.getChannelData(1);

        //  Loop through each sample-frame and fill the channel data with random noise.
        for (var i = 0; i < length; i++)
        {
            //  Apply the reverse effect, if `reverse` is `true`.
            var n = (reverse) ? length - i : i;

            //  Fill the left and right channels with random white noise which decays exponentially.
            left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
            right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
        }

        //  Return the `impulse`.
        return impulse;
    }

};

module.exports = FX;


/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Sound.Dynamic

module.exports = {

    FX: __webpack_require__(504)

};


/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);
var NOOP = __webpack_require__(74);
var State = __webpack_require__(76);
var Systems = __webpack_require__(158);
var GetObjectValue = __webpack_require__(36);
var EventDispatcher = __webpack_require__(23);
var Rectangle = __webpack_require__(25);
var CanvasPool = __webpack_require__(28);
var CanvasInterpolation = __webpack_require__(52);
var GetContext = __webpack_require__(79);

/**
* The State Manager is responsible for loading, setting up and switching game states.
*
* @class Phaser.GlobalStateManager
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var GlobalStateManager = function (game, stateConfig)
{
    this.game = game;

    //  Everything kept in here
    this.keys = {};
    this.states = [];

    //  Only active states are kept in here
    this.active = [];

    this._pending = [];

    if (stateConfig)
    {
        if (Array.isArray(stateConfig))
        {
            for (var i = 0; i < stateConfig.length; i++)
            {
                //  The i === 0 part just starts the first State given
                this._pending.push({
                    index: i,
                    key: 'default',
                    state: stateConfig[i],
                    autoStart: (i === 0),
                    data: {}
                });
            }
        }
        else
        {
            this._pending.push({
                index: 0,
                key: 'default',
                state: stateConfig,
                autoStart: true,
                data: {}
            });
        }
    }
};

GlobalStateManager.prototype.constructor = GlobalStateManager;

GlobalStateManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.GlobalStateManager#boot
    * @private
    */
    boot: function ()
    {
        for (var i = 0; i < this._pending.length; i++)
        {
            var entry = this._pending[i];

            this.add(entry.key, entry.state, entry.autoStart);
        }

        //  Clear the pending list
        this._pending = [];
    },

    //  private
    getKey: function (key, stateConfig)
    {
        if (!key) { key = 'default'; }

        if (stateConfig instanceof State)
        {
            key = stateConfig.settings.key;
        }
        else if (typeof stateConfig === 'object' && stateConfig.hasOwnProperty('key'))
        {
            key = stateConfig.key;
        }

        //  By this point it's either 'default' or extracted from the State

        if (this.keys.hasOwnProperty(key))
        {
            throw new Error('Cannot add a State with duplicate key: ' + key);
        }
        else
        {
            return key;
        }
    },

    /**
    * Adds a new State into the GlobalStateManager. You must give each State a unique key by which you'll identify it.
    * The State can be either a Phaser.State object (or an object that extends it), a plain JavaScript object or a function.
    * If a function is given a new state object will be created by calling it.
    *
    * @method Phaser.GlobalStateManager#add
    * @param {string} key - A unique key you use to reference this state, i.e. "MainMenu", "Level1".
    * @param {Phaser.State|object|function} state  - The state you want to switch to.
    * @param {boolean} [autoStart=false]  - If true the State will be started immediately after adding it.
    */
    add: function (key, stateConfig, autoStart)
    {
        if (autoStart === undefined) { autoStart = false; }

        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            this._pending.push({
                index: this._pending.length,
                key: key,
                state: stateConfig,
                autoStart: autoStart
            });

            console.log('GlobalStateManager not yet booted, adding to list', this._pending.length);

            return;
        }

        key = this.getKey(key, stateConfig);

        // console.log('GlobalStateManager.add', key, stateConfig, autoStart);

        var newState;

        if (stateConfig instanceof State)
        {
            // console.log('GlobalStateManager.add from instance:', key);
            newState = this.createStateFromInstance(key, stateConfig);
        }
        else if (typeof stateConfig === 'object')
        {
            // console.log('GlobalStateManager.add from object:', key);

            stateConfig.key = key;

            newState = this.createStateFromObject(key, stateConfig);
        }
        else if (typeof stateConfig === 'function')
        {
            // console.log('GlobalStateManager.add from function:', key);

            newState = this.createStateFromFunction(key, stateConfig);
        }

        this.keys[key] = newState;

        this.states.push(newState);

        if (autoStart || newState.settings.active)
        {
            if (this.game.isBooted)
            {
                this.start(key);
            }
            else
            {
                this._start.push(key);
            }
        }

        return newState;
    },

    createStateFromInstance: function (key, newState)
    {
        newState.settings.key = key;

        newState.sys.init(this.game);

        this.createStateDisplay(newState);

        return newState;
    },

    createStateFromObject: function (key, stateConfig)
    {
        var newState = new State(stateConfig);

        newState.sys.init(this.game);

        this.createStateDisplay(newState);

        return this.setupCallbacks(newState, stateConfig);
    },

    createStateFromFunction: function (key, state)
    {
        var newState = new state();

        if (newState instanceof State)
        {
            return this.createStateFromInstance(key, newState);
        }
        else
        {
            newState.sys = new Systems(newState);

            newState.sys.init(this.game);

            this.createStateDisplay(newState);

            //  Default required functions

            if (!newState.init)
            {
                newState.init = NOOP;
            }

            if (!newState.preload)
            {
                newState.preload = NOOP;
            }

            if (!newState.create)
            {
                newState.create = NOOP;
            }

            if (!newState.shutdown)
            {
                newState.shutdown = NOOP;
            }

            if (!newState.update)
            {
                newState.update = NOOP;
            }

            if (!newState.render)
            {
                newState.render = NOOP;
            }

            return newState;
        }
    },

    setupCallbacks: function (state, stateConfig)
    {
        if (stateConfig === undefined) { stateConfig = state; }

        //  Extract callbacks or set NOOP

        state.init = GetObjectValue(stateConfig, 'init', NOOP);
        state.preload = GetObjectValue(stateConfig, 'preload', NOOP);
        state.create = GetObjectValue(stateConfig, 'create', NOOP);
        state.shutdown = GetObjectValue(stateConfig, 'shutdown', NOOP);

        //  Game Loop level callbacks

        state.update = GetObjectValue(stateConfig, 'update', NOOP);
        state.render = GetObjectValue(stateConfig, 'render', NOOP);

        return state;
    },

    createStateDisplay: function (state)
    {
        // console.log('createStateDisplay', state.settings.key);

        var settings = state.sys.settings;

        // var x = settings.x;
        // var y = settings.y;
        var width = settings.width;
        var height = settings.height;

        var config = this.game.config;

        if (config.renderType === CONST.CANVAS)
        {
            if (settings.renderToTexture)
            {
                // console.log('renderToTexture', width, height);
                state.sys.canvas = CanvasPool.create(state, width, height);
                state.sys.context = GetContext(state.sys.canvas);

                //  Pixel Art mode?
                if (config.pixelArt)
                {
                    CanvasInterpolation.setCrisp(state.sys.canvas);
                }
            }
            else
            {
                // console.log('using game canvas');
                state.sys.mask = new Rectangle(0, 0, width, height);
                state.sys.canvas = this.game.canvas;
                state.sys.context = this.game.context;
            }
        }
        else if (config.renderType === CONST.WEBGL)
        {
            // state.sys.fbo = this.game.renderer.createFBO(state, x, y, width, height);
        }
    },

    getState: function (key)
    {
        return this.keys[key];
    },

    getStateIndex: function (state)
    {
        return this.states.indexOf(state);
    },

    getActiveStateIndex: function (state)
    {
        var index = -1;

        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state === state)
            {
                index = this.active[i].index;
            }
        }

        return index;
    },

    isActive: function (key)
    {
        var state = this.getState(key);

        return (state && state.settings.active && this.active.indexOf(state) !== -1);
    },

    start: function (key, data)
    {
        if (data === undefined) { data = {}; }

        // console.log('start:', key);
        // console.dir(data);

        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            // console.log('GlobalStateManager not yet booted, setting autoStart on pending list');

            for (var i = 0; i < this._pending.length; i++)
            {
                var entry = this._pending[i];

                if (entry.key === key)
                {
                    entry.autoStart = true;
                    entry.data = data;
                }
            }

            return;
        }

        var state = this.getState(key);

        if (state)
        {
            //  Already started? Nothing more to do here ...
            if (this.isActive(key))
            {
                return;
            }

            state.settings.active = true;

            state.settings.data = data;

            var loader = state.sys.load;

            //  Files payload?
            if (loader && Array.isArray(state.sys.settings.files))
            {
                loader.reset();

                if (loader.loadArray(state.sys.settings.files))
                {
                    loader.events.once('LOADER_COMPLETE_EVENT', this.payloadComplete.bind(this));

                    loader.start();
                }
                else
                {
                    this.bootState(state);
                }
            }
            else
            {
                this.bootState(state);
            }
        }
    },

    payloadComplete: function (event)
    {
        var state = event.loader.state;

        // console.log('payloadComplete', state.sys.settings.key);

        this.bootState(state);
    },

    bootState: function (state)
    {
        // console.log('bootState', state.sys.settings.key);

        if (state.init)
        {
            state.init.call(state, state.sys.settings.data);
        }

        var loader = state.sys.load;
            
        loader.reset();

        if (state.preload)
        {
            state.preload(this.game);

            //  Is the loader empty?
            if (loader.list.size === 0)
            {
                this.create(state);
            }
            else
            {
                //  Start the loader going as we have something in the queue

                loader.events.once('LOADER_COMPLETE_EVENT', this.loadComplete.bind(this));

                loader.start();
            }
        }
        else
        {
            //  No preload? Then there was nothing to load either
            this.create(state);
        }
    },

    loadComplete: function (event)
    {
        var state = event.loader.state;

        // console.log('loadComplete', state.sys.settings.key);

        this.create(state);
    },

    create: function (state)
    {
        // console.log('create', state.sys.settings.key);

        //  Insert at the correct index, or it just all goes wrong :)

        var i = this.getStateIndex(state);

        // console.log('create.index', state.sys.settings.key, i);

        this.active.push({ index: i, state: state });

        //  Sort the 'active' array based on the index property
        this.active.sort(this.sortStates);

        state.sys.updates.running = true;

        if (state.create)
        {
            state.create(state.sys.settings.data);
        }
    },

    pause: function (key)
    {
        var index = this.getActiveStateIndex(this.getState(key));

        if (index > -1)
        {
            var state = this.getState(key);

            state.settings.active = false;

            this.active.splice(index, 1);

            this.active.sort(this.sortStates);
        }
    },

    sortStates: function (stateA, stateB)
    {
        // console.log('sortStates', stateA.state.sys.settings.key, stateA.index, stateB.state.sys.settings.key, stateB.index);

        //  Sort descending
        if (stateA.index < stateB.index)
        {
            return -1;
        }
        else if (stateA.index > stateB.index)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }

};

module.exports = GlobalStateManager;


/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(508);
var ScaleModes = __webpack_require__(41);
var GetObjectValue = __webpack_require__(36);

var Settings = {

    create: function (config)
    {
        if (typeof config === 'string')
        {
            config = { key: config };
        }
        else if (config === undefined)
        {
            //  Pass the 'hasOwnProperty' checks
            config = {};
        }

        return {

            status: CONST.PENDING,

            op: CONST.BOOT,

            key: GetObjectValue(config, 'key', ''),
            active: GetObjectValue(config, 'active', false),
            visible: GetObjectValue(config, 'visible', true),

            //  Loader payload array

            data: {},

            files: GetObjectValue(config, 'files', false),

            //  -1 means the State Manager will set it to be the Game dimensions

            x: GetObjectValue(config, 'x', 0),
            y: GetObjectValue(config, 'y', 0),
            rotation: GetObjectValue(config, 'rotation', 0),
            width: GetObjectValue(config, 'width', -1),
            height: GetObjectValue(config, 'height', -1),

            //  State Render Settings (applies only to this State)

            scaleMode: GetObjectValue(config, 'scaleMode', ScaleModes.DEFAULT),
            roundPixels: GetObjectValue(config, 'roundPixels', false),

            dirtyRender: GetObjectValue(config, 'dirtyRender', false),
            renderToTexture: GetObjectValue(config, 'renderToTexture', false),

            //  The following only apply if renderToTexture is true

            autoResize: GetObjectValue(config, 'autoResize', false),
            transparent: GetObjectValue(config, 'transparent', false),
            clearBeforeRender: GetObjectValue(config, 'clearBeforeRender', true),
            backgroundColor: GetObjectValue(config, 'backgroundColor', false)

        };
    },

    init: function (config, gameConfig)
    {
        if (config.width === -1)
        {
            config.width = gameConfig.width;
        }

        if (config.height === -1)
        {
            config.height = gameConfig.height;
        }
    }

};

module.exports = Settings;


/***/ },
/* 508 */
/***/ function(module, exports) {


module.exports = {

    PENDING: 0,
    INSTALLED: 1,

    BOOT: 0,
    INIT: 1,
    PRELOAD: 2,
    CREATE: 3,
    UPDATE: 4,
    RENDER: 5,
    SHUTDOWN: 6

};


/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

var Camera = __webpack_require__(188);

var CameraManager = function (state)
{
    this.state = state;

    this.cameras = [];
    this.cameraPool = [];

    this.main = this.add();
};

CameraManager.prototype.constructor = CameraManager;

CameraManager.prototype = {

    add: function (x, y, width, height)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (width === undefined) { width = this.state.sys.width; }
        if (height === undefined) { height = this.state.sys.height; }

        var camera = null;

        if (this.cameraPool.length > 0)
        {
            camera = this.cameraPool.pop();
            camera.setViewport(x, y, width, height);
        }
        else
        {
            camera = new Camera(x, y, width, height);
        }

        camera.setState(this.state);

        this.cameras.push(camera);

        return camera;
    },

    addReference: function (camera)
    {
        var index = this.cameras.indexOf(camera);
        var poolIndex = this.cameraPool.indexOf(camera);

        if (index < 0 && poolIndex >= 0)
        {
            this.cameras.push(camera);
            this.cameraPool.slice(poolIndex, 1);
            return camera;
        }
        
        return null;
    },

    remove: function (camera)
    {
        var cameraIndex = this.cameras.indexOf(camera);

        if (cameraIndex >= 0)
        {
            this.cameraPool.push(this.cameras[cameraIndex]);
            this.cameras.splice(cameraIndex, 1);
        }
    },

    resetAll: function ()
    {
        while (this.cameras.length > 0)
        {
            this.cameraPool.push(this.cameras.pop());
        }

        this.main = this.add();
    },

    update: function (timestep)
    {
        for (var i = 0, l = this.cameras.length; i < l; ++i)
        {
            this.cameras[i].update(timestep);
        }
    },

    render: function (renderer, children, interpolation)
    {
        var cameras = this.cameras;
        for (var i = 0, l = cameras.length; i < l; ++i)
        {
            var camera = cameras[i];

            camera.preRender();

            renderer.render(this.state, children, interpolation, camera);
        }

    },

    destroy: function ()
    {
        this.main = undefined;

        for (var i = 0; i < this.cameras.length; i++)
        {
            this.cameras[i].destroy();
        }

        for (i = 0; i < this.cameraPool.length; i++)
        {
            this.cameraPool[i].destroy();
        }

        this.cameras = [];
        this.cameraPool = [];
        this.state = undefined;
    }

};

module.exports = CameraManager;


/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var FactoryContainer = __webpack_require__(6);

/**
* The GameObject Factory is a quick way to create many common game objects. The Factory is owned by the State.
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var GameObjectCreator = function (state)
{
    this.state = state;

    FactoryContainer.load(this, false);
};

GameObjectCreator.prototype.constructor = GameObjectCreator;

GameObjectCreator.prototype = {

    destroy: function ()
    {
        this.state = undefined;
    }

};

module.exports = GameObjectCreator;


/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var FactoryContainer = __webpack_require__(6);

/**
* The GameObject Factory is a quick way to create many common game objects. The Factory is owned by the State.
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var GameObjectFactory = function (state)
{
    this.state = state;

    FactoryContainer.load(this, true);
};

GameObjectFactory.prototype.constructor = GameObjectFactory;

GameObjectFactory.prototype = {

    destroy: function ()
    {
        this.state = undefined;
    }

};

module.exports = GameObjectFactory;


/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(10);
var BaseLoader = __webpack_require__(392);
var NumberArray = __webpack_require__(159);

var ImageFile = __webpack_require__(37);
var JSONFile = __webpack_require__(135);
var XMLFile = __webpack_require__(136);
var BinaryFile = __webpack_require__(399);
var GLSLFile = __webpack_require__(401);
var TextFile = __webpack_require__(403);
var AtlasJSONFile = __webpack_require__(398);
var BitmapFontFile = __webpack_require__(400);
var SpriteSheet = __webpack_require__(402);

var ParseXMLBitmapFont = __webpack_require__(213);

var Loader = function (state)
{
    BaseLoader.call(this);

    /**
    * @property {Phaser.State} state - The State that owns this Factory
    * @protected
    */
    this.state = state;

    this._multilist = {};
};

Loader.prototype = Object.create(BaseLoader.prototype);
Loader.prototype.constructor = Loader;

Loader.prototype.loadArray = function (files)
{
    if (Array.isArray(files))
    {
        for (var i = 0; i < files.length; i++)
        {
            this.file(files[i]);
        }
    }

    return (this.list.size > 0);
};

Loader.prototype.file = function (file)
{
    var entry;

    switch (file.type)
    {
        case 'image':
        case 'json':
        case 'xml':
        case 'binary':
        case 'text':
        case 'glsl':
            entry = this[file.type](file.key, file.url, file.xhrSettings);
            break;

        case 'spritesheet':
            entry = this.spritesheet(file.key, file.url, file.config, file.xhrSettings);
            break;

        case 'atlas':
            entry = this.atlas(file.key, file.textureURL, file.atlasURL, file.textureXhrSettings, file.atlasXhrSettings);
            break;

        case 'bitmapFont':
            entry = this.bitmapFont(file.key, file.textureURL, file.xmlURL, file.textureXhrSettings, file.xmlXhrSettings);
            break;

        case 'multiatlas':
            entry = this.multiatlas(file.key, file.textureURLs, file.atlasURLs, file.textureXhrSettings, file.atlasXhrSettings);
            break;
    }

    return entry;
};

Loader.prototype.image = function (key, url, xhrSettings)
{
    var file = new ImageFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.json = function (key, url, xhrSettings)
{
    var file = new JSONFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.xml = function (key, url, xhrSettings)
{
    var file = new XMLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.binary = function (key, url, xhrSettings)
{
    var file = new BinaryFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.text = function (key, url, xhrSettings)
{
    var file = new TextFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.glsl = function (key, url, xhrSettings)
{
    var file = new GLSLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

//  config can include: frameWidth, frameHeight, startFrame, endFrame, margin, spacing
Loader.prototype.spritesheet = function (key, url, config, xhrSettings)
{
    var file = new SpriteSheet(key, url, config, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.atlas = function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
{
    //  Returns an object with two properties: 'texture' and 'data'
    var files = new AtlasJSONFile(key, textureURL, atlasURL, this.path, textureXhrSettings, atlasXhrSettings);

    this.addFile(files.texture);
    this.addFile(files.data);

    return this;
};

Loader.prototype.bitmapFont = function (key, textureURL, xmlURL, textureXhrSettings, xmlXhrSettings)
{
    //  Returns an object with two properties: 'texture' and 'data'
    var files = new BitmapFontFile(key, textureURL, xmlURL, this.path, textureXhrSettings, xmlXhrSettings);

    this.addFile(files.texture);
    this.addFile(files.data);

    return this;
};

Loader.prototype.multiatlas = function (key, textureURLs, atlasURLs, textureXhrSettings, atlasXhrSettings)
{
    if (typeof textureURLs === 'number')
    {
        var total = textureURLs;

        textureURLs = NumberArray(0, total, key + '-', '.png');
        atlasURLs = NumberArray(0, total, key + '-', '.json');
    }
    else
    {
        if (!Array.isArray(textureURLs))
        {
            textureURLs = [ textureURLs ];
        }

        if (!Array.isArray(atlasURLs))
        {
            atlasURLs = [ atlasURLs ];
        }
    }

    var file;
    var i = 0;
    var multiKey;

    this._multilist[key] = [];

    for (i = 0; i < textureURLs.length; i++)
    {
        multiKey = '_MA_IMG_' + key + '_' + i.toString();

        file = new ImageFile(multiKey, textureURLs[i], this.path, textureXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }

    for (i = 0; i < atlasURLs.length; i++)
    {
        multiKey = '_MA_JSON_' + key + '_' + i.toString();

        file = new JSONFile(multiKey, atlasURLs[i], this.path, atlasXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }
};

//  The Loader has finished
Loader.prototype.processCallback = function ()
{
    if (this.storage.size === 0)
    {
        return;
    }

    //  The global Texture Manager
    var cache = this.state.sys.cache;
    var textures = this.state.sys.textures;

    //  Process multiatlas groups first

    var file;
    var fileA;
    var fileB;

    for (var key in this._multilist)
    {
        var data = [];
        var images = [];
        var keys = this._multilist[key];

        for (var i = 0; i < keys.length; i++)
        {
            file = this.storage.get('key', keys[i]);

            if (file)
            {
                if (file.type === 'image')
                {
                    images.push(file.data);
                }
                else if (file.type === 'json')
                {
                    data.push(file.data);
                }

                this.storage.delete(file);
            }
        }

        //  Do we have everything needed?
        if (images.length + data.length === keys.length)
        {
            //  Yup, add them to the Texture Manager

            //  Is the data JSON Hash or JSON Array?
            if (Array.isArray(data[0].frames))
            {
                textures.addAtlasJSONArray(key, images, data);
            }
            else
            {
                textures.addAtlasJSONHash(key, images, data);
            }
        }
    }

    this.storage.each(function (file)
    {
        switch (file.type)
        {
            case 'image':
                textures.addImage(file.key, file.data);
                break;

            case 'atlasjson':

                fileA = file.fileA;
                fileB = file.fileB;

                if (fileA.type === 'image')
                {
                    textures.addAtlas(fileA.key, fileA.data, fileB.data);
                }
                else
                {
                    textures.addAtlas(fileB.key, fileB.data, fileA.data);
                }
                break;

            case 'bitmapfont':

                fileA = file.fileA;
                fileB = file.fileB;

                if (fileA.type === 'image')
                {
                    cache.bitmapFont.add(fileB.key, ParseXMLBitmapFont(fileB.data));
                    textures.addImage(fileA.key, fileA.data);
                }
                else
                {
                    cache.bitmapFont.add(fileA.key, ParseXMLBitmapFont(fileA.data));
                    textures.addImage(fileB.key, fileB.data);
                }
                break;

            case 'spritesheet':
                textures.addSpriteSheet(file.key, file.data, file.config);
                break;

            case 'json':
                cache.json.add(file.key, file.data);
                break;

            case 'xml':
                cache.xml.add(file.key, file.data);
                break;

            case 'text':
                cache.text.add(file.key, file.data);
                break;

            case 'binary':
                cache.binary.add(file.key, file.data);
                break;

            case 'sound':
                cache.sound.add(file.key, file.data);
                break;

            case 'glsl':
                cache.shader.add(file.key, file.data);
                break;
        }
    });

    this.storage.clear();
};

module.exports = Loader;


/***/ },
/* 513 */
/***/ function(module, exports) {

//  A proxy class to the Global State Manager

var StateManager = function (state, game)
{
    //  The State that owns this StateManager
    this.state = state;

    this.key = state.sys.settings.key;

    //  GlobalStateManager
    this.manager = game.state;
};

StateManager.prototype.constructor = StateManager;

StateManager.prototype = {

    //  Start this State (or the one given via key)
    start: function (key, data)
    {
        if (key === undefined) { key = this.key; }

        this.manager.start(key, data);
    },

    //  Pause this State (or the one given via key)
    pause: function (key)
    {
        if (key === undefined) { key = this.key; }

        this.manager.pause(key);
    },

    //  Stop this State and start the one given
    swap: function (key)
    {
        this.manager.pause(this.key);

        this.manager.start(key);
    },

    moveUp: function ()
    {

    },

    moveDown: function ()
    {

    },

    bringToTop: function ()
    {

    },

    sendToBack: function ()
    {

    },

    //  TODO
    transitionTo: function (key, duration)
    {
        this.manager.pause(this.key);

        this.manager.start(key);
    },

    isActive: function (key)
    {
        if (key === undefined) { key = this.key; }

        return this.manager.isActive(key);
    }

};

module.exports = StateManager;


/***/ },
/* 514 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Dirty! Manager
*
* @class
*/
var UpdateManager = function (state)
{
    this.state = state;

    this.list = [];

    // this.i = 1;

    this.running = false;
    
    this.processed = 0;
};

UpdateManager.prototype.constructor = UpdateManager;

UpdateManager.prototype = {

    stop: function ()
    {
        if (!this.running)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.stop', this.processed);

        this.list.length = 0;

        // this.i++;
    },

    start: function ()
    {
        if (!this.running)
        {
            return;
        }

        var len = this.list.length;

        if (len === 0)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.start', len);

        this.processed = 0;

        for (var i = 0; i < len; i++)
        {
            //  Because it may have already been processed (as a child of another Transform that was updated)
            if (this.list[i] && this.list[i]._dirty)
            {
                this.processed++;
                this.list[i].update();
            }
        }
    },

    add: function (transform)
    {
        this.list.push(transform);
    }

};

module.exports = UpdateManager;


/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {


var quickselect = __webpack_require__(160);

/**
 * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.
 * It's based on an optimized R-tree data structure with bulk insertion support.
 *
 * Spatial index is a special data structure for points and rectangles that allows you to perform queries like
 * "all items within this bounding box" very efficiently (e.g. hundreds of times faster than looping over all items).
 */

function rbush (maxEntries, format)
{
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format)
    {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function ()
    {
        return this._all(this.data, []);
    },

    search: function (bbox)
    {
        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox)
    {
        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data)
    {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item)
    {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function ()
    {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn)
    {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data)
    {
        this.data = data;
        return this;
    },

    _all: function (node, result)
    {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height)
    {
        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path)
    {
        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode)
    {
        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level)
    {
        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode)
    {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M)
    {
        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M)
    {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare)
    {
        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level)
    {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path)
    {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format)
    {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem (item, items, equalsFn)
{
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox (node, toBBox)
{
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox (node, k, p, toBBox, destNode)
{
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend (a, b)
{
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX (a, b) { return a.minX - b.minX; }
function compareNodeMinY (a, b) { return a.minY - b.minY; }

function bboxArea (a) { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin (a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea (a, b)
{
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea (a, b)
{
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains (a, b)
{
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects (a, b)
{
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode (children)
{
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect (arr, left, right, n, compare)
{
    var stack = [left, right],
        mid;

    while (stack.length)
    {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

module.exports = rbush;


/***/ },
/* 516 */
/***/ function(module, exports) {

// A Set is a collection of unique elements.

var Set = function (elements)
{
    this.entries = [];

    if (Array.isArray(elements))
    {
        for (var i = 0; i < elements.length; i++)
        {
            this.add(elements[i]);
        }
    }
};

Set.prototype.constructor = Set;

Set.prototype = {

    set: function (value)
    {
        if (this.entries.indexOf(value) === -1)
        {
            this.entries.push(value);
        }

        return this;
    },

    get: function (property, value)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];

            if (entry[property] === value)
            {
                return entry;
            }
        }
    },

    delete: function (value)
    {
        var index = this.entries.indexOf(value);

        if (index > -1)
        {
            this.entries.splice(index, 1);
        }

        return this;
    },

    dump: function ()
    {
        console.group('Set');

        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];
            console.log(entry);
        }

        console.groupEnd();
    },


    //  For when you know this Set will be modified during the iteration
    each: function (callback)
    {
        var temp = this.entries.slice();

        for (var i = 0; i < temp.length; i++)
        {
            if (callback(temp[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    //  For when you absolutely know this Set won't be modified during the iteration
    iterate: function (callback)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            if (callback(this.entries[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    clear: function ()
    {
        this.entries.length = 0;

        return this;
    },

    contains: function (value)
    {
        return (this.entries.indexOf(value) > -1);
    },

    union: function (set)
    {
        var newSet = new Set();

        set.values.forEach(function (value)
        {
            newSet.add(value);
        });

        this.entries.forEach(function (value)
        {
            newSet.add(value);
        });

        return newSet;
    },

    intersect: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    },

    difference: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (!set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    }

};

Object.defineProperties(Set.prototype, {

    size: {

        enumerable: true,

        get: function ()
        {
            return this.entries.length;
        },

        set: function (value)
        {
            return this.entries.length = value;
        }

    }

});

module.exports = Set;


/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Extend = __webpack_require__(51);

/**
* A Frame is a section of a Texture.
*
* @class Phaser.Frame
* @constructor
* @param {Phaser.Texture} texture - The Texture this Frame belongs to.
* @param {string} name - The unique (within the Texture) name of this Frame.
* @param {number} x - X position of the frame within the Texture.
* @param {number} y - Y position of the frame within the Texture.
* @param {number} width - Width of the frame within the Texture.
* @param {number} height - Height of the frame within the Texture.
*/
var Frame = function (texture, name, sourceIndex, x, y, width, height)
{
    /**
    * @property {Phaser.Texture} texture - The Texture this frame belongs to.
    */
    this.texture = texture;

    /**
    * @property {string} name - The name of this frame within the Texture.
    */
    this.name = name;

    this.source = texture.source[sourceIndex];

    this.sourceIndex = sourceIndex;

    /**
    * @property {number} cutX - X position within the source image to cut from.
    */
    this.cutX = x;

    /**
    * @property {number} cutY - Y position within the source image to cut from.
    */
    this.cutY = y;

    /**
    * @property {number} cutWidth - The width of the area in the source image to cut.
    */
    this.cutWidth = width;

    /**
    * @property {number} cutHeight - The height of the area in the source image to cut.
    */
    this.cutHeight = height;

    /**
    * @property {number} x - The X rendering offset of this Frame, taking trim into account.
    */
    this.x = 0;

    /**
    * @property {number} y - The Y rendering offset of this Frame, taking trim into account.
    */
    this.y = 0;

    /**
    * @property {number} width - The rendering width of this Frame, taking trim into account.
    */
    this.width = width;

    /**
    * @property {number} height - The rendering height of this Frame, taking trim into account.
    */
    this.height = height;

    /**
    * @property {number} width - The rendering width of this Frame, taking trim into account.
    */
    this.centerX = Math.floor(width / 2);

    /**
    * @property {number} height - The rendering height of this Frame, taking trim into account.
    */
    this.centerY = Math.floor(height / 2);

    /**
    * Is this frame is rotated or not in the Texture?
    * Rotation allows you to use rotated frames in texture atlas packing.
    * It has nothing to do with Sprite rotation.
    *
    * @property {boolean} rotated
    * @default
    */
    this.rotated = false;

    /**
    * Is this a tiling texture? As used by the likes of a TilingSprite.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} isTiling
    * @default
    */
    this.isTiling = false;

    /**
    * This will let a renderer know that a tinted parent has updated its texture.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} requiresReTint
    * @default
    */
    this.requiresReTint = false;

    //  Over-rides the Renderer setting? -1 = use Renderer Setting, 0 = No rounding, 1 = Round
    this.autoRound = -1;

    /**
    * The un-modified source frame, trim and UV data.
    *
    * @private
    * @property {object} data
    */
    this.data = {
        cut: {
            x: x,
            y: y,
            w: width,
            h: height,
            r: x + width,
            b: y + height
        },
        trim: false,
        sourceSize: {
            w: width,
            h: height
        },
        spriteSourceSize: {
            x: 0,
            y: 0,
            w: width,
            h: height
        },
        uvs: {
            x0: 0,
            y0: 0,
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            x3: 0,
            y3: 0
        },
        radius: 0.5 * Math.sqrt(width * width + height * height),
        drawImage: {
            sx: x,
            sy: y,
            sWidth: width,
            sHeight: height,
            dWidth: width,
            dHeight: height
        }
    };

    this.updateUVs();
};

Frame.prototype.constructor = Frame;

Frame.prototype = {

    /**
    * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.
    *
    * @method Phaser.TextureFrame#setTrim
    * @param {number} actualWidth - The width of the frame before being trimmed.
    * @param {number} actualHeight - The height of the frame before being trimmed.
    * @param {number} destX - The destination X position of the trimmed frame for display.
    * @param {number} destY - The destination Y position of the trimmed frame for display.
    * @param {number} destWidth - The destination width of the trimmed frame for display.
    * @param {number} destHeight - The destination height of the trimmed frame for display.
    */
    setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)
    {
        var data = this.data;
        var ss = data.spriteSourceSize;

        //  Store actual values

        data.trim = true;

        data.sourceSize.w = actualWidth;
        data.sourceSize.h = actualHeight;

        ss.x = destX;
        ss.y = destY;
        ss.w = destWidth;
        ss.h = destHeight;

        //  Adjust properties
        this.x = destX;
        this.y = destY;

        this.width = destWidth;
        this.height = destHeight;

        this.centerX = Math.floor(destWidth / 2);
        this.centerY = Math.floor(destHeight / 2);

        this.updateUVs();

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVs
    * @private
    */
    updateUVs: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x0 = this.cutX / tw;
        uvs.y0 = this.cutY / th;

        uvs.x1 = this.cutX / tw;
        uvs.y1 = (this.cutY + this.cutHeight) / th;

        uvs.x2 = (this.cutX + this.cutWidth) / tw;
        uvs.y2 = (this.cutY + this.cutHeight) / th;

        uvs.x3 = (this.cutX + this.cutWidth) / tw;
        uvs.y3 = this.cutY / th;

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVsInverted
    * @private
    */
    updateUVsInverted: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x3 = (this.cutX + this.cutHeight) / tw;
        uvs.y3 = (this.cutY + this.cutWidth) / th;

        uvs.x2 = this.cutX / tw;        
        uvs.y2 = (this.cutY + this.cutWidth) / th;
        
        uvs.x1 = this.cutX / tw;
        uvs.y1 = this.cutY / th;
        
        uvs.x0 = (this.cutX + this.cutHeight) / tw;
        uvs.y0 = this.cutY / th;

        return this;
    },

    clone: function ()
    {
        var clone = new Frame(this.texture, this.name, this.sourceIndex);

        clone.cutX = this.cutX;
        clone.cutY = this.cutY;
        clone.cutWidth = this.cutWidth;
        clone.cutHeight = this.cutHeight;

        clone.x = this.x;
        clone.y = this.y;

        clone.width = this.width;
        clone.height = this.height;

        clone.centerX = this.centerX;
        clone.centerY = this.centerY;

        clone.rotated = this.rotated;

        clone.data = Extend(true, clone.data, this.data);

        clone.updateUVs();

        return clone;
    },

    destroy: function ()
    {
    }

};

Object.defineProperties(Frame.prototype, {

    /**
    * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realWidth
    * @property {any} realWidth
    */
    realWidth: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.w;
        }

    },

    /**
    * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realHeight
    * @property {any} realHeight
    */
    realHeight: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.h;
        }

    },

    /**
    * UVs
    *
    * @name Phaser.TextureFrame#uvs
    * @property {Object} uvs
    */
    uvs: {

        enumerable: true,

        get: function ()
        {
            return this.data.uvs;
        }

    },

    /**
    * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)
    * @name Phaser.TextureFrame#radius
    * @property {number} radius
    */
    radius: {

        enumerable: true,

        get: function ()
        {
            return this.data.radius;
        }

    },

    /**
    * Canvas Draw Image data
    *
    * @name Phaser.TextureFrame#canvasData
    * @property {Object} canvasData
    */
    canvasData: {

        enumerable: true,

        get: function ()
        {
            return this.data.drawImage;
        }

    }

});

module.exports = Frame;


/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Frame = __webpack_require__(517);
var TextureSource = __webpack_require__(520);

/**
* A Texture consists of a source, usually an Image from the Cache, or a Canvas, and a collection
* of Frames. The Frames represent the different areas of the Texture. For example a texture atlas
* may have many Frames, one for each element within the atlas. Where-as a single image would have
* just one frame, that encompasses the whole image.
*
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* @class Phaser.Texture
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var Texture = function (manager, key, source)
{
    this.manager = manager;

    if (!Array.isArray(source))
    {
        source = [ source ];
    }

    this.key = key;

    /**
    * The source that is used to create the texture.
    * Usually an Image, but can also be a Canvas.
    *
    * @property source
    * @type array
    */
    this.source = [];

    /**
    * @property {object} frames - Frames
    */
    this.frames = {};

    this.frameTotal = 0;

    //  Load the Sources
    for (var i = 0; i < source.length; i++)
    {
        this.source.push(new TextureSource(this, source[i]));
    }
};

Texture.prototype.constructor = Texture;

Texture.prototype = {

    add: function (name, sourceIndex, x, y, width, height)
    {
        var frame = new Frame(this, name, sourceIndex, x, y, width, height);

        this.frames[name] = frame;

        this.frameTotal++;

        return frame;
    },

    get: function (name)
    {
        if (name === undefined || name === null || this.frameTotal === 1)
        {
            name = '__BASE';
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'];
        }
        else
        {
            return frame;
        }
    },

    getSourceImage: function (name)
    {
        if (name === undefined || name === null || this.frameTotal === 1)
        {
            name = '__BASE';
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'].source.image;
        }
        else
        {
            return frame.source.image;
        }
    },

    setTextureIndex: function (index)
    {
        for (var i = 0; i < this.source.length; i++)
        {
            this.source[i].glTextureIndex = index;

            console.log(this.source[i].image.currentSrc, 'index = ', index);

            index++;
        }

        return index;
    },

    /**
    * Destroys this base texture
    *
    * @method destroy
    */
    destroy: function ()
    {
        //  Need to iterate though the TextureSources, and unload each one
        //  then clear out the frames

        /*
        if (this.source)
        {
            Phaser.CanvasPool.removeByCanvas(this.source);
        }

        this.source = null;
        */
    }

};

/**
* Helper function that creates a base texture from the given canvas element.
*
* @static
* @method fromCanvas
* @param canvas {Canvas} The canvas element source of the texture
* @param scaleMode {Number} See {{#crossLink "PIXI/scaleModes:property"}}Phaser.scaleModes{{/crossLink}} for possible values
* @return {BaseTexture}
Phaser.Texture.fromCanvas = function (canvas, scaleMode)
{
    if (canvas.width === 0)
    {
        canvas.width = 1;
    }

    if (canvas.height === 0)
    {
        canvas.height = 1;
    }

    return new Phaser.Texture(canvas, scaleMode);
};
*/

module.exports = Texture;


/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Parser = __webpack_require__(528);
var Texture = __webpack_require__(518);
var CanvasPool = __webpack_require__(28);

/**
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* Access it via `state.textures`.
*
* @class Phaser.TextureManager
* @constructor
*/
var TextureManager = function (game)
{
    this.game = game;

    this.list = {};

    this.addBase64('__DEFAULT', game.config.defaultImage);
    this.addBase64('__MISSING', game.config.missingImage);
};

TextureManager.prototype.constructor = TextureManager;

TextureManager.prototype = {

    addBase64: function (key, data)
    {
        var _this = this;
        var image = new Image();

        image.onload = function ()
        {
            var texture = _this.create(key, image);
        
            Parser.Image(texture, 0);
        };

        image.src = data;
    },

    addImage: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Image(texture, 0);

        return texture;
    },

    createCanvas: function (key, width, height)
    {
        if (width === undefined) { width = 256; }
        if (height === undefined) { height = 256; }

        var canvas = CanvasPool.create(this, width, height);

        return this.addCanvas(key, canvas);
    },

    addCanvas: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Canvas(texture, 0);

        return texture;
    },

    addAtlas: function (key, source, data)
    {
        //  Is it a Hash or an Array?

        if (Array.isArray(data.frames))
        {
            return this.addAtlasJSONArray(key, source, data);
        }
        else
        {
            return this.addAtlasJSONHash(key, source, data);
        }
    },

    addAtlasJSONArray: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONArray(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONArray(texture, 0, data);
        }

        return texture;
    },

    addAtlasJSONHash: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONHash(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONHash(texture, 0, data);
        }

        return texture;
    },

    /**
     * [addSpriteSheet description]
     * @param {[type]} key    [description]
     * @param {[type]} source [description]
     * @param {[type]} config [description]
     * @param {number} config.frameWidth - The fixed width of each frame.
     * @param {number} [config.frameHeight] - The fixed height of each frame. If not set it will use the frameWidth as the height.
     * @param {number} [config.startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
     * @param {number} [config.endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
     * @param {number} [config.margin=0] - If the frames have been drawn with a margin, specify the amount here.
     * @param {number} [config.spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
     */
    addSpriteSheet: function (key, source, config)
    {
        var texture = this.create(key, source);

        var width = texture.source[0].width;
        var height = texture.source[0].height;

        Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);

        return texture;
    },

    addSpriteSheetFromAtlas: function (key, atlasKey, atlasFrame, config)
    {
        var atlas = this.get(atlasKey);
        var sheet = atlas.get(atlasFrame);

        if (sheet)
        {
            var texture = this.create(key, sheet.source.image);

            Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);

            return texture;
        }
    },

    addAtlasStarlingXML: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.StarlingXML(texture, i, data[i]);
            }
        }
        else
        {
            Parser.StarlingXML(texture, 0, data);
        }

        return texture;
    },

    addAtlasPyxel: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.Pyxel(texture, i, data[i]);
            }
        }
        else
        {
            Parser.Pyxel(texture, 0, data);
        }

        return texture;
    },

    create: function (key, source)
    {
        var texture = new Texture(this, key, source);

        this.list[key] = texture;

        return texture;
    },

    exists: function (key)
    {
        return (this.list.hasOwnProperty(key));
    },

    get: function (key)
    {
        if (key === undefined) { key = '__DEFAULT'; }

        if (this.list[key])
        {
            return this.list[key];
        }
        else
        {
            return this.list['__MISSING'];
        }
    },

    cloneFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame).clone();
        }
    },

    getFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame);
        }
    },

    setTexture: function (gameObject, key, frame)
    {
        if (this.list[key])
        {
            gameObject.texture = this.list[key];
            gameObject.frame = gameObject.texture.get(frame);
        }

        return gameObject;
    },

    /**
    * Passes all Textures to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var texture in this.list)
        {
            args[0] = this.list[texture];

            callback.apply(thisArg, args);
        }
    }

};

module.exports = TextureManager;


/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);
var ScaleModes = __webpack_require__(41);
var IsSizePowerOfTwo = __webpack_require__(148);
var CreateTexture2DFromSource = __webpack_require__(502);

/**
*
* @class Phaser.TextureSource
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var TextureSource = function (texture, source)
{
    this.texture = texture;

    this.image = source;

    this.compressionAlgorithm = null;

    /**
    * The Resolution of the texture.
    *
    * @property resolution
    * @type Number
    */
    this.resolution = 1;
    
    /**
    * The width of the Texture.
    *
    * @property width
    * @type Number
    * @readOnly
    */
    this.width = source.naturalWidth || source.width || 0;

    /**
    * The height of the Texture.
    *
    * @property height
    * @type Number
    * @readOnly
    */
    this.height = source.naturalHeight || source.height || 0;

    /**
    * The scale mode to apply when scaling this texture.
    * NEAREST or DEFAULT
    *
    * @property scaleMode
    * @type {Number}
    * @default Phaser.scaleModes.DEFAULT;
    */
    this.scaleMode = ScaleModes.DEFAULT;

    /**
    * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
    *
    * @property premultipliedAlpha
    * @type Boolean
    * @default true
    */
    this.premultipliedAlpha = true;

    /**
    * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
    * Also the texture must be a power of two size to work
    *
    * @property mipmapLevel
    * @type {integer}
    */
    this.mipmapLevel = 0;

    /**
    * A BaseTexture can be set to skip the rendering phase in the WebGL Sprite Batch.
    *
    * You may want to do this if you have a parent Sprite with no visible texture (i.e. uses the internal `__default` texture)
    * that has children that you do want to render, without causing a batch flush in the process.
    *
    * @property renderable
    * @type Boolean
    */
    this.renderable = true;

    /**
    * @property isPowerOf2
    * @type boolean
    */
    this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);

    /**
    * @property glTexture
    */
    this.glTexture = null;

    /**
    * The multi texture batching index number.
    * @property glTextureIndex
    * @type Number
    */
    this.glTextureIndex = 0;

    /**
    * The timestamp when this texture was last used by the WebGL renderer.
    * Can be used to purge out 'dead' textures from GPU memory.
    * @property glLastUsed
    * @type Number
    */
    this.glLastUsed = 0;

    /**
    * @property glDirty
    */
    this.glDirty = true;

    var game = texture.manager.game;

    if (game.config.renderType === CONST.WEBGL)
    {
        CreateTexture2DFromSource(game.renderer.gl, this);
    }
};

module.exports = TextureSource;


/***/ },
/* 521 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var CanvasTextureParser = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = CanvasTextureParser;


/***/ },
/* 522 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var ImageTextureParser = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = ImageTextureParser;


/***/ },
/* 523 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Array format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONArrayTextureParser = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Array given, missing \'frames\' array');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed array
    var frames = json['frames'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        var src = frames[i];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
        }
    }

    return texture;
};

module.exports = JSONArrayTextureParser;


/***/ },
/* 524 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in JSON Hash format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONHashTextureParser = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Hash given, missing \'frames\' Object');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed Object
    var frames = json['frames'];
    var newFrame;

    for (var key in frames)
    {
        var src = frames[key];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
        }
    }

    return texture;
};

module.exports = JSONHashTextureParser;


/***/ },
/* 525 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a Pyxel JSON File and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Pyxel JSON format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var PyxelTextureParser = function (texture, json)
{
    //  Malformed? There are a few keys to check here.
    var signature = [ 'layers', 'tilewidth', 'tileheight', 'tileswide', 'tileshigh' ];

    signature.forEach(function (key)
    {
        if (!json[key])
        {
            // console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + key + '" key.');
            // console.log(json);
            return;
        }
    });

    // For this purpose, I only care about parsing tilemaps with a single layer.
    if (json['layers'].length !== 1)
    {
        // console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.');
        // console.log(json);
        return;
    }

    var data = new Phaser.FrameData();

    var tileheight = json['tileheight'];
    var tilewidth = json['tilewidth'];

    var frames = json['layers'][0]['tiles'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        newFrame = data.addFrame(new Phaser.Frame(
            i,
            frames[i].x,
            frames[i].y,
            tilewidth,
            tileheight,
            "frame_" + i  // No names are included in pyxel tilemap data.
        ));

        // No trim data is included.
        newFrame.setTrim(false);
    }

    return data;
};

module.exports = PyxelTextureParser;


/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var GetObjectValue = __webpack_require__(36);

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.SpriteSheet
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @param {number} frameWidth - The fixed width of each frame.
* @param {number} frameHeight - The fixed height of each frame.
* @param {number} [startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
* @param {number} [endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
* @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.
* @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var SpriteSheetTextureParser = function (texture, sourceIndex, x, y, width, height, config)
{
    var frameWidth = GetObjectValue(config, 'frameWidth', null);
    var frameHeight = GetObjectValue(config, 'frameHeight', frameWidth);

    //  If missing we can't proceed
    if (frameWidth === null)
    {
        throw new Error('TextureManager.SpriteSheetTextureParser: Invalid frameWidth given.');
    }

    var startFrame = GetObjectValue(config, 'startFrame', 0);
    var endFrame = GetObjectValue(config, 'endFrame', -1);
    var margin = GetObjectValue(config, 'margin', 0);
    var spacing = GetObjectValue(config, 'spacing', 0);

    var row = Math.floor((width - margin) / (frameWidth + spacing));
    var column = Math.floor((height - margin) / (frameHeight + spacing));
    var total = row * column;

    if (startFrame > total || startFrame < -total)
    {
        startFrame = 0;
    }

    if (startFrame < 0)
    {
        //  Allow negative skipframes.
        startFrame = total + startFrame;
    }

    if (endFrame !== -1)
    {
        total = startFrame + (endFrame + 1);
    }

    var fx = margin;
    var fy = margin;
    var ax = 0;
    var ay = 0;

    for (var i = 0; i < total; i++)
    {
        ax = 0;
        ay = 0;

        var w = fx + frameWidth;
        var h = fy + frameHeight;

        if (w > width)
        {
            ax = w - width;
        }

        if (h > height)
        {
            ay = h - height;
        }

        texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);

        fx += frameWidth + spacing;

        if (fx + frameWidth > width)
        {
            fx = margin;
            fy += frameHeight + spacing;
        }
    }

    return texture;
};

module.exports = SpriteSheetTextureParser;


/***/ },
/* 527 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses the XML and extracts the frame data from it.
*
* @class Phaser.TextureParser.StarlingXML
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} xml - The XML data from the Texture Atlas. Must be in Starling XML format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var StarlingXMLTextureParser = function (texture, xml)
{
    //  Malformed?
    if (!xml.getElementsByTagName('TextureAtlas'))
    {
        // console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
        return;
    }

    //  Let's create some frames then
    var data = new Phaser.FrameData();
    var frames = xml.getElementsByTagName('SubTexture');
    var newFrame;

    var name;
    var frame;
    var x;
    var y;
    var width;
    var height;
    var frameX;
    var frameY;
    var frameWidth;
    var frameHeight;

    for (var i = 0; i < frames.length; i++)
    {
        frame = frames[i].attributes;

        name = frame.name.value;
        x = parseInt(frame.x.value, 10);
        y = parseInt(frame.y.value, 10);
        width = parseInt(frame.width.value, 10);
        height = parseInt(frame.height.value, 10);

        frameX = null;
        frameY = null;

        if (frame.frameX)
        {
            frameX = Math.abs(parseInt(frame.frameX.value, 10));
            frameY = Math.abs(parseInt(frame.frameY.value, 10));
            frameWidth = parseInt(frame.frameWidth.value, 10);
            frameHeight = parseInt(frame.frameHeight.value, 10);
        }

        newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name));

        //  Trimmed?
        if (frameX !== null || frameY !== null)
        {
            newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);
        }
    }

    return data;

};

module.exports = StarlingXMLTextureParser;


/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {


module.exports = {
    Canvas: __webpack_require__(521),
    Image: __webpack_require__(522),
    SpriteSheet: __webpack_require__(526),
    JSONArray: __webpack_require__(523),
    JSONHash: __webpack_require__(524),
    StarlingXML: __webpack_require__(527),
    Pyxel: __webpack_require__(525)
};


/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(32);
var GetBottom = __webpack_require__(11);
var SetCenterX = __webpack_require__(34);
var SetBottom = __webpack_require__(15);

var InBottomCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(container) + offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomCenter;


/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(12);
var GetBottom = __webpack_require__(11);
var SetLeft = __webpack_require__(16);
var SetBottom = __webpack_require__(15);

var InBottomLeft = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomLeft;


/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(13);
var GetBottom = __webpack_require__(11);
var SetRight = __webpack_require__(17);
var SetBottom = __webpack_require__(15);

var InBottomRight = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomRight;


/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(32);
var GetCenterY = __webpack_require__(33);
var CenterOn = __webpack_require__(162);

var InCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    CenterOn(gameObject, GetCenterX(container) + offsetX, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InCenter;


/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(12);
var GetCenterY = __webpack_require__(33);
var SetLeft = __webpack_require__(16);
var SetCenterY = __webpack_require__(35);

var InLeftCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetCenterY(gameObject, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InLeftCenter;


/***/ },
/* 534 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(13);
var GetCenterY = __webpack_require__(33);
var SetRight = __webpack_require__(17);
var SetCenterY = __webpack_require__(35);

var InRightCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetCenterY(gameObject, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InRightCenter;


/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(32);
var GetTop = __webpack_require__(14);
var SetCenterX = __webpack_require__(34);
var SetTop = __webpack_require__(18);

var InTopCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(container) + offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopCenter;


/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(12);
var GetTop = __webpack_require__(14);
var SetLeft = __webpack_require__(16);
var SetTop = __webpack_require__(18);

var InTopLeft = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopLeft;


/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(13);
var GetTop = __webpack_require__(14);
var SetRight = __webpack_require__(17);
var SetTop = __webpack_require__(18);

var InTopRight = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopRight;


/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(32);
var GetBottom = __webpack_require__(11);
var SetCenterX = __webpack_require__(34);
var SetTop = __webpack_require__(18);

var ToBottomCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(parent) + offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomCenter;


/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(12);
var GetBottom = __webpack_require__(11);
var SetLeft = __webpack_require__(16);
var SetTop = __webpack_require__(18);

var ToBottomLeft = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(parent) - offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomLeft;


/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(13);
var GetBottom = __webpack_require__(11);
var SetRight = __webpack_require__(17);
var SetTop = __webpack_require__(18);

var ToBottomRight = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(parent) + offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomRight;


/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(12);
var GetBottom = __webpack_require__(11);
var SetRight = __webpack_require__(17);
var SetBottom = __webpack_require__(15);

var ToLeftBottom = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetBottom(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToLeftBottom;


/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(12);
var GetCenterY = __webpack_require__(33);
var SetRight = __webpack_require__(17);
var SetCenterY = __webpack_require__(35);

var ToLeftCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetCenterY(gameObject, GetCenterY(parent) + offsetY);

    return gameObject;
};

module.exports = ToLeftCenter;


/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(12);
var GetTop = __webpack_require__(14);
var SetRight = __webpack_require__(17);
var SetTop = __webpack_require__(18);

var ToLeftTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetTop(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToLeftTop;


/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(13);
var GetBottom = __webpack_require__(11);
var SetLeft = __webpack_require__(16);
var SetBottom = __webpack_require__(15);

var ToRightBottom = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetBottom(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToRightBottom;


/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(13);
var GetCenterY = __webpack_require__(33);
var SetLeft = __webpack_require__(16);
var SetCenterY = __webpack_require__(35);

var ToRightTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetCenterY(gameObject, GetCenterY(parent) + offsetY);

    return gameObject;
};

module.exports = ToRightTop;


/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(13);
var GetTop = __webpack_require__(14);
var SetLeft = __webpack_require__(16);
var SetTop = __webpack_require__(18);

var ToRightTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetTop(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToRightTop;


/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(32);
var GetTop = __webpack_require__(14);
var SetCenterX = __webpack_require__(34);
var SetBottom = __webpack_require__(15);

var ToTopCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(parent) + offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopCenter;


/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(12);
var GetTop = __webpack_require__(14);
var SetLeft = __webpack_require__(16);
var SetBottom = __webpack_require__(15);

var ToTopLeft = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(parent) - offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopLeft;


/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(13);
var GetTop = __webpack_require__(14);
var SetRight = __webpack_require__(17);
var SetBottom = __webpack_require__(15);

var ToTopRight = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(parent) + offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopRight;


/***/ },
/* 550 */
/***/ function(module, exports) {

/**
* Snaps a value to the nearest value in an array.
* The result will always be in the range `[first_value, last_value]`.
*
* @method
* @param {number} value - The search value
* @param {number[]} arr - The input array which _must_ be sorted.
* @return {number} The nearest value found.
*/
var FindClosestInSorted = function (value, array)
{
    if (!array.length)
    {
        return NaN;
    }
    else if (array.length === 1 || value < array[0])
    {
        return array[0];
    }

    var i = 1;

    while (array[i] < value)
    {
        i++;
    }

    var low = array[i - 1];
    var high = (i < array.length) ? array[i] : Number.POSITIVE_INFINITY;

    return ((high - value) <= (value - low)) ? high : low;
};

module.exports = FindClosestInSorted;


/***/ },
/* 551 */
/***/ function(module, exports) {

/**
* Fetch a random entry from the given array.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was selected.
*/

var GetRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return (array[randomIndex] === undefined) ? null : array[randomIndex];
};

module.exports = GetRandomElement;


/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

var RoundAwayFromZero = __webpack_require__(142);

/**
* Create an array of numbers (positive and/or negative) progressing from `start`
* up to but not including `end` by advancing by `step`.
*
* If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.
*
* Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;
* for forward compatibility make sure to pass in actual numbers.
*
* @method Phaser.ArrayUtils#numberArrayStep
* @param {number} start - The start of the range.
* @param {number} [end] - The end of the range.
* @param {number} [step=1] - The value to increment or decrement by.
* @returns {Array} Returns the new array of numbers.
* @example
* NumberArrayStep(4);
* // => [0, 1, 2, 3]
*
* NumberArrayStep(1, 5);
* // => [1, 2, 3, 4]
*
* NumberArrayStep(0, 20, 5);
* // => [0, 5, 10, 15]
*
* NumberArrayStep(0, -4, -1);
* // => [0, -1, -2, -3]
*
* NumberArrayStep(1, 4, 0);
* // => [1, 1, 1]
*
* NumberArrayStep(0);
* // => []
*/
var NumberArrayStep = function (start, end, step)
{
    if (start === undefined) { start = 0; }
    if (end === undefined) { end = null; }
    if (step === undefined) { step = 1; }

    if (end === null)
    {
        end = start;
        start = 0;
    }

    var result = [];

    var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);

    for (var i = 0; i < total; i++)
    {
        result.push(start);
        start += step;
    }

    return result;
};

module.exports = NumberArrayStep;


/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__) {

var SpliceOne = __webpack_require__(161);

/**
* Removes a random object from the given array and returns it.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was removed.
*/

var RemoveRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return SpliceOne(array, randomIndex);
};

module.exports = RemoveRandomElement;


/***/ },
/* 554 */
/***/ function(module, exports) {

/**
* Moves the element at the start of the array to the end, shifting all items in the process.
* The "rotation" happens to the left.
*
* @method Phaser.ArrayUtils.rotate
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateLeft = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.shift();
        array.push(element);
    }

    return element;
};

module.exports = RotateLeft;


/***/ },
/* 555 */
/***/ function(module, exports) {

/**
* Moves the element at the end of the array to the start, shifting all items in the process.
* The "rotation" happens to the right.
*
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateRight = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.pop();
        array.unshift(element);
    }

    return element;
};

module.exports = RotateRight;


/***/ },
/* 556 */
/***/ function(module, exports) {

/**
* A standard Fisher-Yates Array shuffle implementation which modifies the array in place.
*
* @method
* @param {any[]} array - The array to shuffle.
* @return {any[]} The original array, now shuffled.
*/
var Shuffle = function (array)
{
    for (var i = array.length - 1; i > 0; i--)
    {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    return array;
};

module.exports = Shuffle;


/***/ },
/* 557 */
/***/ function(module, exports) {

/**
* The amount the Game Object is visually offset from its x coordinate.
* This is the same as `width * anchor.x`.
* It will only be > 0 if anchor.x is not equal to zero.
*
* @property {number} offsetX
* @readOnly
*/

var GetOffsetX = function (gameObject)
{
    return gameObject.width * gameObject.anchorX;
};

module.exports = GetOffsetX;


/***/ },
/* 558 */
/***/ function(module, exports) {

/**
* The amount the Game Object is visually offset from its x coordinate.
* This is the same as `width * anchor.x`.
* It will only be > 0 if anchor.x is not equal to zero.
*
* @property {number} offsetX
* @readOnly
*/

var GetOffsetY = function (gameObject)
{
    return gameObject.height * gameObject.anchorY;
};

module.exports = GetOffsetY;


/***/ },
/* 559 */
/***/ function(module, exports) {

/**
* Takes the given string and pads it out, to the length required, using the character
* specified. For example if you need a string to be 6 characters long, you can call:
*
* `pad('bob', 6, '-', 2)`
*
* This would return: `bob---` as it has padded it out to 6 characters, using the `-` on the right.
*
* You can also use it to pad numbers (they are always returned as strings):
* 
* `pad(512, 6, '0', 1)`
*
* Would return: `000512` with the string padded to the left.
*
* If you don't specify a direction it'll pad to both sides:
* 
* `pad('c64', 7, '*')`
*
* Would return: `**c64**`
*
* @method Phaser.Utils.pad
* @param {string} str - The target string. `toString()` will be called on the string, which means you can also pass in common data types like numbers.
* @param {integer} [len=0] - The number of characters to be added.
* @param {string} [pad=" "] - The string to pad it out with (defaults to a space).
* @param {integer} [dir=3] - The direction dir = 1 (left), 2 (right), 3 (both).
* @return {string} The padded string.
*/
var Pad = function (str, len, pad, dir)
{
    if (len === undefined) { var len = 0; }
    if (pad === undefined) { var pad = ' '; }
    if (dir === undefined) { var dir = 3; }

    str = str.toString();

    var padlen = 0;

    if (len + 1 >= str.length)
    {
        switch (dir)
        {
            case 1:
                str = new Array(len + 1 - str.length).join(pad) + str;
                break;

            case 3:
                var right = Math.ceil((padlen = len - str.length) / 2);
                var left = padlen - right;
                str = new Array(left+1).join(pad) + str + new Array(right+1).join(pad);
                break;

            default:
                str = str + new Array(len + 1 - str.length).join(pad);
                break;
        }
    }

    return str;

};

module.exports = Pad;


/***/ },
/* 560 */
/***/ function(module, exports) {

/**
* Takes the given string and reverses it, returning the reversed string.
* For example if given the string `Atari 520ST` it would return `TS025 iratA`.
*
* @method Phaser.Utils.reverseString
* @param {string} string - The string to be reversed.
* @return {string} The reversed string.
*/
var ReverseString = function (string)
{
    return string.split('').reverse().join('');
};

module.exports = ReverseString;


/***/ },
/* 561 */
/***/ function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {__webpack_require__(171);

var CONST = __webpack_require__(2);
var Extend = __webpack_require__(51);

//  This object is exported globally

var Phaser = {

    DOM: __webpack_require__(165),

    Game: __webpack_require__(164),

    Event: __webpack_require__(5),
    EventDispatcher: __webpack_require__(23),

    Math: __webpack_require__(75),

    Components: __webpack_require__(8),

    Geom: __webpack_require__(167),

    Graphics: __webpack_require__(168),

    Input: __webpack_require__(169),

    GameObjects: __webpack_require__(166),

    State: __webpack_require__(76),

    Loader: {

        ImageFile: __webpack_require__(37)

    },

    Sound: __webpack_require__(172),

    Physics: __webpack_require__(170),

    Class: __webpack_require__(9),

    Utils: {

        Align: __webpack_require__(173),
        Array: __webpack_require__(174),
        Bounds: __webpack_require__(175),
        Objects: __webpack_require__(176),
        String: __webpack_require__(177)

    }

};

//   Merge in the consts

Phaser = Extend(false, Phaser, CONST);

//  Export it

module.exports = Phaser;

global.Phaser = Phaser;

/*
 * Sometimes, the elegant implementation is just a function.
 * Not a method. Not a class. Not a framework. Just a function.
 * - John Carmack
 */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(77)))

/***/ }
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBhYjE4MjZjOTdjOWZkZWFkNzQ1ZiIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9Db21tb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbnN0LmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9Cb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1ZlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi4vZXZlbnRzL0V2ZW50LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2NvbnN0LmpzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL0dldEJvdHRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL0dldExlZnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2JvdW5kcy9HZXRSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL0dldFRvcC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL1NldEJvdHRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL1NldExlZnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2JvdW5kcy9TZXRSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL1NldFRvcC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9PUy5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL09TLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9ib2R5L0NvbXBvc2l0ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvQ29tcG9zaXRlLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL0V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvRXZlbnRzLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9WZXJ0aWNlcy5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1ZlcnRpY2VzLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy9zcmMvZXZlbnRzL0V2ZW50RGlzcGF0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvR2FtZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL0dhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9Ccm93c2VyLmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9DYW52YXNQb29sLmpzIiwid2VicGFjazovLy9zcmMvZG9tL0NhbnZhc1Bvb2wuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9BbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9Db2xvci5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL0ZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL0dldENlbnRlclguanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2JvdW5kcy9HZXRDZW50ZXJZLmpzIiwid2VicGFjazovLy8uLi91dGlscy9ib3VuZHMvU2V0Q2VudGVyWC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL1NldENlbnRlclkuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL29iamVjdC9HZXRPYmplY3RWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9JbWFnZUZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Cb2R5LmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Cb2R5LmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb25zdHJhaW50L0NvbnN0cmFpbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb25zdHJhaW50L0NvbnN0cmFpbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvU2xlZXBpbmcuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL1NsZWVwaW5nLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci9TY2FsZU1vZGVzLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1dyYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9QYWlyLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1BhaXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL2J1ZmZlci9CdWZmZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvYnVmZmVyL0NyZWF0ZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvc2hhZGVyL0NyZWF0ZVByb2dyYW0uanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3NoYWRlci9DcmVhdGVTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9CaW5kVmVydGV4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9DcmVhdGVBdHRyaWJEZXNjLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9WZXJ0ZXhBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvb2JqZWN0L0V4dGVuZC5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL29iamVjdC9FeHRlbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9DYW52YXNJbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9Db21tYW5kcy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9Db250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0ZpbmRULmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0UG9pbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2hlcm1pdGUvR2V0UG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Sb3RhdGVBcm91bmRYWS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Eb3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0dldEFzcGVjdFJhdGlvLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9jb2xvci9HZXRDb2xvci5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQva2V5cy9LZXlDb2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL1hIUlNldHRpbmdzLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0JldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9EZXRlY3Rvci5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9EZXRlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL0dyaWQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vR3JpZC5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1NBVC5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9TQVQuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvTW91c2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL01vdXNlLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9mYWN0b3J5L0JvZGllcy5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2ZhY3RvcnkvQm9kaWVzLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9BeGVzLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvQXhlcy5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL3JlbmRlci9SZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL0JsZW5kTW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL2J1ZmZlci9CdWZmZXIxNi5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvTk9PUC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL1N0YXRlLmpzIiwid2VicGFjazovLy9zcmMvc3RhdGUvU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uLi9jYW52YXMvR2V0Q29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9EYXRhLmpzIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9EYXRhLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvQ2FudmFzRmVhdHVyZXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9kZXZpY2UvQ2FudmFzRmVhdHVyZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9GZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9GZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL0FkZFRvRE9NLmpzIiwid2VicGFjazovLy8uLi9kb20vRE9NQ29udGVudExvYWRlZC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RvbS9ET01Db250ZW50TG9hZGVkLmpzIiwid2VicGFjazovLy8uLi9kb20vUGFyc2VYTUwuanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9kb20vUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvR2V0Qml0bWFwVGV4dFNpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3MuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9FbGxpcHNlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2hlcm1pdGUvR2V0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL05vcm1hbEFuZ2xlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL05vcm1hbEFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0dldE1hZ25pdHVkZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9HZXRNYWduaXR1ZGVTcS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9NdWx0aXBseS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Ob3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L05vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvQWRkLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL0NvbG9yQnVybi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9Db2xvckRvZGdlLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL0Rhcmtlbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaWdodGVuLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckJ1cm4uanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckJ1cm4uanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyRG9kZ2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckRvZGdlLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL092ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvUmVmbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9TdWJ0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9WaXZpZExpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9WaXZpZExpZ2h0LmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9jb2xvci9Db21wb25lbnRUb0hleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvR2V0Q29sb3IzMi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvSFNWVG9SR0IuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9IU1ZUb1JHQi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvSGV4U3RyaW5nVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL0hleFN0cmluZ1RvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9IdWVUb0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvSHVlVG9Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb0NvbG9yLmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvY29sb3IvSW50ZWdlclRvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb1JHQi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvUkdCU3RyaW5nVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL1JHQlN0cmluZ1RvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL1ZhbHVlVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL1ZhbHVlVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQvS2V5Ym9hcmRNYW5hZ2VyLmpzIiwid2VicGFjazovLy9zcmMvaW5wdXQva2V5Ym9hcmQvS2V5Ym9hcmRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9jb21iby9LZXlDb21iby5qcyIsIndlYnBhY2s6Ly8vc3JjL2lucHV0L2tleWJvYXJkL2NvbWJvL0tleUNvbWJvLmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9jb21iby9Qcm9jZXNzS2V5Q29tYm8uanMiLCJ3ZWJwYWNrOi8vL3NyYy9pbnB1dC9rZXlib2FyZC9jb21iby9Qcm9jZXNzS2V5Q29tYm8uanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2tleXMvS2V5LmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9NZXJnZVhIUlNldHRpbmdzLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0pTT05GaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0Jlcm5zdGVpbi5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvQmVybnN0ZWluLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0NhdG11bGxSb20uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvQ2xhbXAuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvRmFjdG9yaWFsLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0xpbmVhci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9Sb3VuZEF3YXlGcm9tWmVyby5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9Ob3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvV3JhcC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvYW5nbGUvV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9XcmFwRGVncmVlcy5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2ludGVycG9sYXRpb24vTGluZWFySW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3BvdzIvSXNTaXplUG93ZXJPZlR3by5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Xb3JsZC5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvV29ybGQuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9Db250YWN0LmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUGFpcnMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9SZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9SZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9FbmdpbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL0VuZ2luZS5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9NZXRyaWNzLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvY29yZS9NZXRyaWNzLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL1BsdWdpbi5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvUGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL3BvbHktZGVjb21wL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy90ZXh0dXJlL0NyZWF0ZVRleHR1cmUyREltYWdlLmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9TeXN0ZW1zLmpzIiwid2VicGFjazovLy9zcmMvc3RhdGUvU3lzdGVtcy5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L1F1aWNrU2VsZWN0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9TcGxpY2VPbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2JvdW5kcy9DZW50ZXJPbi5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL2JvdW5kcy9DZW50ZXJPbi5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvb2JqZWN0L0lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2Jvb3QvR2FtZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2Jvb3QvR2FtZS5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZG9tL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9pbnB1dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9wb2x5ZmlsbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vc291bmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9zb3VuZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYm91bmRzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi91dGlscy9vYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9vYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL3N0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL3N0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vYm9vdC9Db25maWcuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ib290L0NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi4vYm9vdC9DcmVhdGVSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2Jvb3QvQ3JlYXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2Jvb3QvRGVidWdIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ib290L0RlYnVnSGVhZGVyLmpzIiwid2VicGFjazovLy8uLi9ib290L01haW5Mb29wLmpzIiwid2VicGFjazovLy9zcmMvYm9vdC9NYWluTG9vcC5qcyIsIndlYnBhY2s6Ly8vLi4vY2FjaGUvQmFzZUNhY2hlLmpzIiwid2VicGFjazovLy9zcmMvY2FjaGUvQmFzZUNhY2hlLmpzIiwid2VicGFjazovLy8uLi9jYWNoZS9DYWNoZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2NhY2hlL0NhY2hlLmpzIiwid2VicGFjazovLy8uLi9jYWNoZS9DYWNoZUVudHJ5LmpzIiwid2VicGFjazovLy8uLi9jYWNoZS9ldmVudHMvQ2FjaGVBZGRFdmVudC5qcyIsIndlYnBhY2s6Ly8vc3JjL2NhY2hlL2V2ZW50cy9DYWNoZUFkZEV2ZW50LmpzIiwid2VicGFjazovLy8uLi9jYWNoZS9ldmVudHMvQ2FjaGVSZW1vdmVFdmVudC5qcyIsIndlYnBhY2s6Ly8vc3JjL2NhY2hlL2V2ZW50cy9DYWNoZVJlbW92ZUV2ZW50LmpzIiwid2VicGFjazovLy8uLi9jYWNoZS9ldmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9jYWNoZS9ldmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2NhbWVyYS9DYW1lcmEuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jYW1lcmEvQ2FtZXJhLmpzIiwid2VicGFjazovLy8uLi9jaGVja3N1bS5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9BbHBoYS5qcyIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvQWxwaGEuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvQmxlbmRNb2RlLmpzIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9CbGVuZE1vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL09yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9TY2FsZU1vZGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1NjYWxlTW9kZS5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9TaXplLmpzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL1RleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvVHJhbnNmb3JtLmpzIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9UcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvVmlzaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL0F1ZGlvLmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL0F1ZGlvLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvRnVsbHNjcmVlbi5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9GdWxsc2NyZWVuLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvSW5wdXQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9kZXZpY2UvSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9WaWRlby5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9WaWRlby5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9kb20vQWRkRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL1JlbW92ZUV2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9SZW1vdmVGcm9tRE9NLmpzIiwid2VicGFjazovLy8uLi9kb20vVG91Y2hBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9Vc2VyU2VsZWN0LmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvRXZlbnRCaW5kaW5nLmpzIiwid2VicGFjazovLy9zcmMvZXZlbnRzL0V2ZW50QmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi4vZXZlbnRzL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ldmVudHMvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9QYXJzZVhNTEJpdG1hcEZvbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0UmVuZGVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0UmVuZGVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0V2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0UmVuZGVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dFJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dFdlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0V2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlcldlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQm9iLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyUmVuZGVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc1JlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUNhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlUmVuZGVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZUNhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlUmVuZGVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZVJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZVdlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NpcmN1bWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NpcmN1bWZlcmVuY2VQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2NpcmNsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vY2lyY2xlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9PZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL09mZnNldFBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2NpcmNsZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9BcmVhLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9Db250YWluc1JlY3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9HZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvT2Zmc2V0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvT2Zmc2V0UG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvUmFuZG9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9HZXRBbmdsZVdpdGhEaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaGVybWl0ZS9HZXRBbmdsZVdpdGhEaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldEVudHJ5VGFuZ2VudC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldFBvaW50V2l0aERpc3RhbmNlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL0dldFBvaW50V2l0aERpc3RhbmNlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0WC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldFkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9IZXJtaXRlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL0hlcm1pdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaGVybWl0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL0NpcmNsZVRvQ2lyY2xlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9pbnRlcnNlY3RzL0NpcmNsZVRvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2ludGVyc2VjdHMvR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvTGluZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9MaW5lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmVTZWdtZW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lU2VnbWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvVmFsdWVzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2ludGVyc2VjdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9DZW50ZXJPbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0Nsb25lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9HZXRNaWRQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9HZXRNaWRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0dldE5vcm1hbC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9HZXROb3JtYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9HZXRQb2ludHNPbkxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9IZWlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9MZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Ob3JtYWxYLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL05vcm1hbFguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Ob3JtYWxZLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL05vcm1hbFkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9QZXJwU2xvcGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvUmFuZG9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvUmVmbGVjdEFuZ2xlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL1JlZmxlY3RBbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Sb3RhdGVBcm91bmRQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9Sb3RhdGVBcm91bmRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1NldFRvQW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9TbG9wZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1dpZHRoLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvQWRkLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0NlaWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0NvcHlGcm9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0Nyb3NzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0RpdmlkZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvR2V0Q2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L0dldENlbnRyb2lkLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0ludGVycG9sYXRlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9JbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9JbnZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvTmVnYXRpdmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L05lZ2F0aXZlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L05vcm1hbGl6ZVJpZ2h0SGFuZC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9QZXJwLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1Byb2plY3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L1Byb2plY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvUHJvamVjdFVuaXQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L1Byb2plY3RVbml0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1JQZXJwLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvU2V0TWFnbml0dWRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1N1YnRyYWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0Nsb25lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2x5Z29uL0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9seWdvbi9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vR2V0QUFCQi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0dldE51bWJlckFycmF5LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvbHlnb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NlaWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NlaWxBbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NlbnRlck9uLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvRXF1YWxzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9GaXRJbnNpZGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9GaXRJbnNpZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0ZpdE91dHNpZGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9GaXRPdXRzaWRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9GbG9vci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvRmxvb3JBbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0dldENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvR2V0U2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvSW5mbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VQb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL01lcmdlUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VYWS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvT2Zmc2V0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9PZmZzZXRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvT3ZlcmxhcHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL1BlcmltZXRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9TY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvVW5pb24uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9Vbmlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9BdmVyYWdlLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL0RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvRXhjbHVzaW9uLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL0dsb3cuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9ibGVuZG1vZGVzL0dsb3cuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvSGFyZExpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9IYXJkTGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvSGFyZE1peC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvSGFyZE1peC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaW5lYXJMaWdodC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyTGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTmVnYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTm9ybWFsLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL1Bob2VuaXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvUGluTGlnaHQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9ibGVuZG1vZGVzL1BpbkxpZ2h0LmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL1NjcmVlbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9Tb2Z0TGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9ibGVuZG1vZGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9jb2xvci9DU1NUb0NvbG9yLmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvY29sb3IvQ1NTVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvQ29sb3JUb1JHQkEuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL0hTTFRvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9IU0xUb0NvbG9yLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9jb2xvci9IU1ZDb2xvcldoZWVsLmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvY29sb3IvSFNWQ29sb3JXaGVlbC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvSW50ZXJwb2xhdGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9JbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvUkdCVG9IU1YuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL1JHQlRvU3RyaW5nLmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvY29sb3IvUkdCVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL1JhbmRvbVJHQi5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL1JhbmRvbVJHQi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQvR2xvYmFsSW5wdXRNYW5hZ2VyLmpzIiwid2VicGFjazovLy9zcmMvaW5wdXQvR2xvYmFsSW5wdXRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9jb21iby9BZHZhbmNlS2V5Q29tYm8uanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2NvbWJvL0tleUNvbWJvTWF0Y2hFdmVudC5qcyIsIndlYnBhY2s6Ly8vc3JjL2lucHV0L2tleWJvYXJkL2NvbWJvL0tleUNvbWJvTWF0Y2hFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQvY29tYm8vUmVzZXRLZXlDb21iby5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQvZXZlbnRzL0tleURvd25FdmVudC5qcyIsIndlYnBhY2s6Ly8vc3JjL2lucHV0L2tleWJvYXJkL2V2ZW50cy9LZXlEb3duRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2V2ZW50cy9LZXlVcEV2ZW50LmpzIiwid2VicGFjazovLy9zcmMvaW5wdXQva2V5Ym9hcmQvZXZlbnRzL0tleVVwRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2lucHV0L2tleWJvYXJkL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9pbnB1dC9rZXlib2FyZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQva2V5cy9Eb3duRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2tleXMvSnVzdERvd24uanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2tleXMvSnVzdFVwLmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9rZXlzL1Byb2Nlc3NLZXlEb3duLmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9rZXlzL1Byb2Nlc3NLZXlVcC5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQva2V5cy9VcER1cmF0aW9uLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvQmFzZUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9CYXNlTG9hZGVyLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvR2V0VVJMLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvWEhSTG9hZGVyLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL1hIUkxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2V2ZW50cy9Mb2FkZXJDb21wbGV0ZUV2ZW50LmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2V2ZW50cy9Mb2FkZXJDb21wbGV0ZUV2ZW50LmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZXZlbnRzL0xvYWRlclN0YXJ0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZXZlbnRzL0xvYWRlclN0YXJ0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9ldmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZXZlbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0F0bGFzSlNPTkZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL0F0bGFzSlNPTkZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvQmluYXJ5RmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvQmluYXJ5RmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaXRtYXBGb250RmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvQml0bWFwRm9udEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL0dMU0xGaWxlLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL1Nwcml0ZVNoZWV0LmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9TcHJpdGVTaGVldC5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvVGV4dEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvQXZlcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9DZWlsVG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvRGVnVG9SYWQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL0RlZ1RvUmFkLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvRmxvYXRCZXR3ZWVuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0Zsb29yVG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvTWF4QWRkLmpzIiwid2VicGFjazovLy8uLi9tYXRoL01pblN1Yi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9QZXJjZW50LmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JhZFRvRGVnLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9SYWRUb0RlZy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvUm90YXRlQXJvdW5kLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JvdGF0ZUFyb3VuZERpc3RhbmNlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JvdW5kVG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvU2luQ29zVGFibGVHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvU21vb3RoU3RlcC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9TbW9vdGhlclN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvV2l0aGluLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL0JldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvQmV0d2VlblBvaW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9CZXR3ZWVuUG9pbnRzWS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9CZXR3ZWVuWS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9SZXZlcnNlLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9hbmdsZS9SZXZlcnNlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL1JvdGF0ZVRvLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9hbmdsZS9Sb3RhdGVUby5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9TaG9ydGVzdEJldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2FuZ2xlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlUG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VTcXVhcmVkLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Rpc3RhbmNlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvQmFjay5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvQm91bmNlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9DaXJjdWxhci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvQ3ViaWMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0VsYXN0aWMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0V4cG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0xpbmVhci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvUXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9RdWFydGljLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9RdWludGljLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9TaW5lLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvZWFzaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L0NlaWwuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvRXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvR3JlYXRlclRoYW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvTGVzc1RoYW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2Z1enp5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL2ludGVycG9sYXRpb24vQmV6aWVySW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9CZXppZXJJbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2ludGVycG9sYXRpb24vQ2F0bXVsbFJvbUludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2ludGVycG9sYXRpb24vQ2F0bXVsbFJvbUludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvaW50ZXJwb2xhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9wb3cyL0dldFBvd2VyT2ZUd28uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvcG93Mi9Jc1ZhbHVlUG93ZXJPZlR3by5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvcG93Mi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9wb3cyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL3JhbmRvbS1kYXRhLWdlbmVyYXRvci9SYW5kb21EYXRhR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3NuYXAvU25hcENlaWwuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvc25hcC9TbmFwRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvc25hcC9TbmFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvc25hcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvc25hcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1F1ZXJ5LmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1F1ZXJ5LmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb25zdHJhaW50L01vdXNlQ29uc3RyYWludC5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbnN0cmFpbnQvTW91c2VDb25zdHJhaW50LmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL01hdHRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvTWF0dGVyLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL1J1bm5lci5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvUnVubmVyLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9mYWN0b3J5L0NvbXBvc2l0ZXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9mYWN0b3J5L0NvbXBvc2l0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1N2Zy5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1N2Zy5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvbW9kdWxlL21haW4uanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9tb2R1bGUvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlclBpeGkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9yZW5kZXIvUmVuZGVyUGl4aS5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL0FycmF5LmZvckVhY2guanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9BcnJheS5pc0FycmF5LmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvQXVkaW9Db250ZXh0TW9ua2V5UGF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9GdW5jdGlvbi5iaW5kLmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvTWF0aC50cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL1VpbnQzMkFycmF5LmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL3BlcmZvcm1hbmNlLm5vdy5qcyIsIndlYnBhY2s6Ly8vc3JjL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL2NhbnZhcy9DYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL2NhbnZhcy9DYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0JsaXRJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0RyYXdJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0dldEJsZW5kTW9kZXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci9jYW52YXMvdXRpbHMvR2V0QmxlbmRNb2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL0FBUXVhZEJhdGNoLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9hYXF1YWQvQUFRdWFkQmF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL0ZyYWdtZW50U2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2FhcXVhZC9WZXJ0ZXhTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL2NvbnN0LmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9hYXF1YWQvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9CbGl0dGVyQmF0Y2guanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvQmxpdHRlckJhdGNoLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvRnJhZ21lbnRTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9WZXJ0ZXhTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9jb25zdC5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9GcmFnbWVudFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9TaGFwZUJhdGNoLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9TaGFwZUJhdGNoLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3NoYXBlL1ZlcnRleFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9jb25zdC5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc2hhcGUvY29uc3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3NoYXBlL2VhcmN1dC5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9lYXJjdXQuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL0ZyYWdtZW50U2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9TcHJpdGVCYXRjaC5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL1Nwcml0ZUJhdGNoLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9WZXJ0ZXhTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL2NvbnN0LmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0NyZWF0ZUVtcHR5VGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0NyZWF0ZUVtcHR5VGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdGV4dHVyZS9DcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdGV4dHVyZS9DcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uLi9zb3VuZC9keW5hbWljL0ZYLmpzIiwid2VicGFjazovLy9zcmMvc291bmQvZHluYW1pYy9GWC5qcyIsIndlYnBhY2s6Ly8vLi4vc291bmQvZHluYW1pYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3NvdW5kL2R5bmFtaWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL0dsb2JhbFN0YXRlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3N0YXRlL0dsb2JhbFN0YXRlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9TZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL3N5c3RlbXMvQ2FtZXJhTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3N0YXRlL3N5c3RlbXMvQ2FtZXJhTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvc3lzdGVtcy9HYW1lT2JqZWN0Q3JlYXRvci5qcyIsIndlYnBhY2s6Ly8vc3JjL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3N0YXRlL3N5c3RlbXMvTG9hZGVyLmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL1N0YXRlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvc3lzdGVtcy9VcGRhdGVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9zdHJ1Y3RzL1JUcmVlLmpzIiwid2VicGFjazovLy9zcmMvc3RydWN0cy9SVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3RydWN0cy9TZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL0ZyYW1lLmpzIiwid2VicGFjazovLy9zcmMvdGV4dHVyZXMvRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL1RleHR1cmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy90ZXh0dXJlcy9UZXh0dXJlLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3RleHR1cmVzL1RleHR1cmVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9UZXh0dXJlU291cmNlLmpzIiwid2VicGFjazovLy9zcmMvdGV4dHVyZXMvVGV4dHVyZVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9DYW52YXNUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL0ltYWdlVGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9KU09OQXJyYXlUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL0pTT05IYXNoVGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9QeXhlbFRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvU3ByaXRlU2hlZXRUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy9zcmMvdGV4dHVyZXMvcGFyc2Vycy9TcHJpdGVTaGVldFRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvU3RhcmxpbmdYTUxUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvdGV4dHVyZXMvcGFyc2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5Cb3R0b21DZW50ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9JbkJvdHRvbUNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5Cb3R0b21MZWZ0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5Cb3R0b21MZWZ0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9JbkJvdHRvbVJpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5Cb3R0b21SaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5DZW50ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9JbkNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5MZWZ0Q2VudGVyLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5MZWZ0Q2VudGVyLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9JblJpZ2h0Q2VudGVyLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5SaWdodENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5Ub3BDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9JblRvcENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5Ub3BMZWZ0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5Ub3BMZWZ0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9JblRvcFJpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5Ub3BSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vVG9Cb3R0b21DZW50ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9Ub0JvdHRvbUNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vVG9Cb3R0b21MZWZ0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vVG9Cb3R0b21MZWZ0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9Ub0JvdHRvbVJpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vVG9Cb3R0b21SaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vVG9MZWZ0Qm90dG9tLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vVG9MZWZ0Qm90dG9tLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9Ub0xlZnRDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9Ub0xlZnRDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FsaWduL1RvTGVmdFRvcC5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL2FsaWduL1RvTGVmdFRvcC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vVG9SaWdodEJvdHRvbS5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL2FsaWduL1RvUmlnaHRCb3R0b20uanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FsaWduL1RvUmlnaHRDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9Ub1JpZ2h0Q2VudGVyLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9Ub1JpZ2h0VG9wLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vVG9SaWdodFRvcC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vVG9Ub3BDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9Ub1RvcENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vVG9Ub3BMZWZ0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vVG9Ub3BMZWZ0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9Ub1RvcFJpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vVG9Ub3BSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvRmluZENsb3Nlc3RJblNvcnRlZC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvR2V0UmFuZG9tRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXlTdGVwLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXlTdGVwLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9SZW1vdmVSYW5kb21FbGVtZW50LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYXJyYXkvUmVtb3ZlUmFuZG9tRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvUm90YXRlTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvUm90YXRlUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L1NodWZmbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2JvdW5kcy9HZXRPZmZzZXRYLmpzIiwid2VicGFjazovLy8uLi91dGlscy9ib3VuZHMvR2V0T2Zmc2V0WS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvc3RyaW5nL1BhZC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvc3RyaW5nL1JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vL2Q6L3dhbXAvd3d3L3BoYXNlci92My9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoYXNlci5qcyIsIndlYnBhY2s6Ly8vLi4vcGhhc2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHNCQUFzQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWUsS0FBSztBQUNwQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JB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QUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsS0FBSztBQUNwQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxJOzs7Ozs7QUM1T0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzVEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUEsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFaEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEEsK0NDQUE7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLEdBQUcsdUJBQXVCLE9BQU87QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDekxBLFNDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVB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QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMLENBQUM7OztBQUdEOzs7Ozs7O0FFaFZBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjOztBQUVsRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRWhKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYSxHQUFHLGVBQWUsR0FBRyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGlC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QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7O0FFNzdDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BLFVDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDBCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMEJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7Ozs7OztBRW5EQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFdENBOztBQUVBO0FBQ0EsaUJBQWlCLGFBQWEsRUFBRTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLE9BQU87QUFDckIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FFalNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUUvRUEsU0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRW5PQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1Qjs7QUFFOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxTQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRXJEQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFdDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVoSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9HQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esd0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1Qyxp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QSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBRXhCQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtDQUFrQyxXQUFXOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtB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OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEEsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxR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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pDQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQ0EsdUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRXZCQSxzQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBRXZWRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7O0FFcmZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFD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QUEsR0RBQTs7QUFFQTs7QUFFQTs7QUFFQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOzs7Ozs7O0FFekJBOztBQUVBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFYkE7O0FBRUE7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVQQTs7QUFFQTs7QUFFQSxjQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRU5BOztBQUVBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQTs7Ozs7OztBRUxBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTs7Ozs7OztBQ1JBOztBQUVBOztBQUVBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTkE7O0FBRUE7O0FBRUEsb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUUxQkE7O0FBRUEseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRWJBOztBQUVBOztBQUVBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7Ozs7OztBRXBCQTs7QUFFQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRUxBOztBQUVBLFNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVMQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTs7QUFFNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGOztBQUVBOztBQUVBOzs7Ozs7O0FFL0VBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMEJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRXhGQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGFBQWE7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QUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFbkRBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFbkNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDWEEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWRBOztBQUVBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRUxBLHNCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLFdBQVc7QUFDM0Msa0NBQWtDLGFBQWE7QUFDL0MsaUNBQWlDLFlBQVk7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0Msa0NBQWtDLGFBQWE7QUFDL0MsaUNBQWlDLFlBQVk7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXhOQTtBQUNBO0FBQ0E7QUFDQSwwQjs7Ozs7O0FDSEEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQSxjQUFjOztBQUVkOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFF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O0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3B0QkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM1WUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxXQUFXLG1DQUFtQzs7QUFFakY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFM0ZBLFNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRTdEQSxTQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFeEZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFekJBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9COztBQUV2RDtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0JBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRTNRQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRWJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQyxpQ0FBaUMsY0FBYzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLDBFQUEwRTs7QUFFcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwSkEsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVuQkE7O0FBRUEsa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTEEsc0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsMEVBQTBFOztBQUVwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRTNNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUhBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFbkJBOztBQUVBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRUxBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FFeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDM0JBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCOztBQUV4RDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUV0QkE7O0FBRUEsa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaEJBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQjs7QUFFeEQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFdEJBOztBQUVBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7Ozs7QUVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakJBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUV6S0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7O0FBRXREO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXJCQTs7QUFFQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVMQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0REFBNEQsc0JBQXNCO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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UkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUUxQkE7O0FBRUEsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUEsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSw0QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVpBO0FBQ0E7QUFDQTtBQUNBLFVB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Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7O0FBRUEsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRTNCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVyQ0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWJBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVUQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEEsVUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFbkJBLFVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWxCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFVkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDJCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUU3QkEsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQSxlQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FFZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhOztBQUU1QyxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkE7O0FBRUEsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esd0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EseUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFVkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBLGdCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBLGVDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2QsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFM0JBLHFCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUUzQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGNBQWM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGNBQWM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzFCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFbEJBOztBQUVBLGdCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwwQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwyQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx3QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx3QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQSxjQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxjQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RjtBQUNBO0FBQ0E7QUFDQSw2RjtBQUNBO0FBQ0E7QUFDQSwyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUUzQkEsaUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVuQkEsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVsQkE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0EsMkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hCQTs7QUFFQTs7QUFFQSxTQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRTlCQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXpCQSxlQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU87O0FBRWpDOztBQUVBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFMUJBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qyw4QkFBOEIsV0FBVzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qyw4QkFBOEIsV0FBVzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsOEJBQThCLFdBQVc7O0FBRXpDO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRXZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTs7Ozs7OztBQ2pEQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DLCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVqQkEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDLDRCQUE0QixXQUFXOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQTs7QUFFQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUV2QkE7O0FBRUEsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFcENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRVpBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVaQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRTFDQTs7QUFFQTs7QUFFQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsU0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxjQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlOztBQUVoRDtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7O0FBRWhEO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDZEEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdGQUFnRixxQkFBcUI7O0FBRXJHO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyx5REFBeUQ7O0FBRTNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXJDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFWkEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRVpBOztBQUVBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDJCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRUxBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBOzs7Ozs7OztBRWxCQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUV2Q0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7Ozs7Ozs7O0FFbEJBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixXQUFXOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXZDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUViQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUV2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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdERBOztBQUVBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCOztBQUVsRDtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7O0FBRWxEO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCOztBQUVsRDtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7O0FBRUEsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxD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QWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7O0FFelVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEs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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxJOzs7Ozs7QUV4TkQsOEJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxvQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUVsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwrQkFBK0Isd0JBQXdCLEVBQUUsYUFBYTs7QUFFbEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsa0RBQWtELGNBQWM7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDO0FBQ0EseUQ7QUFDQTs7QUFFQTtBQUNBLDZDO0FBQ0EscUU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0Qzs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsS0FBSztBQUNwQixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtREFBbUQsdUJBQXVCO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBRWxnQkQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNkQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7OztBQ3BMRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDMUNBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRTdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLHlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDJCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQscUJBQXFCO0FBQzlFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUU1VkEsc0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxtQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFcE5BO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEIsK0JBQStCO0FBQy9CLE1BQU07QUFDTjs7Ozs7OztBQ05BO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLG1CQUFtQjtBQUNuQixpRUFBaUU7QUFDakUsMEJBQTBCO0FBQzFCLE1BQU07QUFDTixhOzs7Ozs7QUNUQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXBCQTs7QUFFQSxzQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBLG1CQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVuTEE7QUFDQSwwQkFBMEI7QUFDMUIsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0Isa0JBQWtCO0FBQ2xCLDBGQUEwRjtBQUMxRixNQUFNO0FBQ047Ozs7Ozs7QUNSQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCLG1CQUFtQjtBQUNuQixpRUFBaUU7QUFDakUsa0NBQWtDO0FBQ2xDLHdCQUF3QjtBQUN4QixNQUFNO0FBQ047Ozs7Ozs7QUNaQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXRCQTtBQUNBLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLGtCQUFrQjtBQUNsQixrREFBa0Q7QUFDbEQsTUFBTTtBQUNOOzs7Ozs7O0FDUEEsc0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQSxtQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7QUFDcEIsU0FBUyxXQUFXO0FBQ3BCLFNBQVMsV0FBVztBQUNwQixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiw0QkFBNEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7O0FBRUE7Ozs7Ozs7QUU5UUE7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixtQkFBbUI7QUFDbkIsaUVBQWlFO0FBQ2pFLGtDQUFrQztBQUNsQywwQkFBMEI7QUFDMUIsTUFBTTtBQUNOOzs7Ozs7O0FDWkEscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUV0QkEsaUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXRCQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSwyQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDVEEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRTFVQTs7QUFFQTs7QUFFQSxRQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRU5BO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLDBCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLDZCQUE2QjtBQUMzQyxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx3Q0FBd0MscUJBQXFCOztBQUU3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVzs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLHlCQUF5Qjs7QUFFbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXpoQkEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0I7O0FBRXBCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUUxRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLDhCQUE4QixPQUFPO0FBQ3JDLGtDQUFrQyw4QkFBOEI7QUFDaEUsbUNBQW1DLGdDQUFnQzs7QUFFbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXpIQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsdUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRWpDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsdUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRWpDQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOzs7Ozs7O0FFaFZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCOztBQUVoRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjs7QUFFaEQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCOztBQUVoRDtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDN0VBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxTQUFTOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsU0FBUzs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFbElBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0E7Ozs7Ozs7QUVUQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWRBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7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TDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7OENDbkx0QyxtQkNBQSxDREFBLEdDQUE7O0FBRUEsWURBQSxtQkNBQSxDREFBLENDQUE7QUFDQSxhREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQTs7QUFFQTs7QUFFQSxTREFBLG1CQ0FBLENEQUEsR0NBQTs7QUFFQSxVREFBLG1CQ0FBLENEQUEsR0NBQTs7QUFFQSxXREFBLG1CQ0FBLENEQUEsQ0NBQTtBQUNBLHFCREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQSxVREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQSxnQkRBQSxtQkNBQSxDREFBLENDQUE7O0FBRUEsVURBQSxtQkNBQSxDREFBLEdDQUE7O0FBRUEsY0RBQSxtQkNBQSxDREFBLEdDQUE7O0FBRUEsV0RBQSxtQkNBQSxDREFBLEdDQUE7O0FBRUEsaUJEQUEsbUJDQUEsQ0RBQSxHQ0FBOztBQUVBLFdEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBOztBQUVBLG1CREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQSxLQUFLOztBQUVMLFdEQUEsbUJDQUEsQ0RBQSxHQ0FBOztBQUVBLGFEQUEsbUJDQUEsQ0RBQSxHQ0FBOztBQUVBLFdEQUEsbUJDQUEsQ0RBQSxDQ0FBOztBQUVBOztBQUVBLGVEQUEsbUJDQUEsQ0RBQSxHQ0FBO0FBQ0EsZURBQSxtQkNBQSxDREFBLEdDQUE7QUFDQSxnQkRBQSxtQkNBQSxDREFBLEdDQUE7QUFDQSxpQkRBQSxtQkNBQSxDREFBLEdDQUE7QUFDQSxnQkRBQSxtQkNBQSxDREFBLEdDQUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJwaGFzZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIlBoYXNlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQaGFzZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUGhhc2VyXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb3J5IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vcnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1NjIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGFiMTgyNmM5N2M5ZmRlYWQ3NDVmIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuQ29tbW9uYCBtb2R1bGUgY29udGFpbnMgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBhcmUgY29tbW9uIHRvIGFsbCBtb2R1bGVzLlxyXG4qXHJcbiogQGNsYXNzIENvbW1vblxyXG4qL1xyXG5cclxudmFyIENvbW1vbiA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb21tb247XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgQ29tbW9uLl9uZXh0SWQgPSAwO1xyXG4gICAgQ29tbW9uLl9zZWVkID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZHMgdGhlIG9iamVjdCBpbiB0aGUgZmlyc3QgYXJndW1lbnQgdXNpbmcgdGhlIG9iamVjdCBpbiB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gICAgICogQG1ldGhvZCBleHRlbmRcclxuICAgICAqIEBwYXJhbSB7fSBvYmpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVlcFxyXG4gICAgICogQHJldHVybiB7fSBvYmogZXh0ZW5kZWRcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaiwgZGVlcCkge1xyXG4gICAgICAgIHZhciBhcmdzU3RhcnQsXHJcbiAgICAgICAgICAgIGFyZ3MsXHJcbiAgICAgICAgICAgIGRlZXBDbG9uZTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBkZWVwID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgYXJnc1N0YXJ0ID0gMjtcclxuICAgICAgICAgICAgZGVlcENsb25lID0gZGVlcDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhcmdzU3RhcnQgPSAxO1xyXG4gICAgICAgICAgICBkZWVwQ2xvbmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3NTdGFydDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcENsb25lICYmIHNvdXJjZVtwcm9wXSAmJiBzb3VyY2VbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ialtwcm9wXSB8fCBvYmpbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gb2JqW3Byb3BdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmV4dGVuZChvYmpbcHJvcF0sIGRlZXBDbG9uZSwgc291cmNlW3Byb3BdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNsb25lIG9mIHRoZSBvYmplY3QsIGlmIGRlZXAgaXMgdHJ1ZSByZWZlcmVuY2VzIHdpbGwgYWxzbyBiZSBjbG9uZWQuXHJcbiAgICAgKiBAbWV0aG9kIGNsb25lXHJcbiAgICAgKiBAcGFyYW0ge30gb2JqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IGRlZXBcclxuICAgICAqIEByZXR1cm4ge30gb2JqIGNsb25lZFxyXG4gICAgICovXHJcbiAgICBDb21tb24uY2xvbmUgPSBmdW5jdGlvbihvYmosIGRlZXApIHtcclxuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZCh7fSwgZGVlcCwgb2JqKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGtleXMgZm9yIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGtleXNcclxuICAgICAqIEBwYXJhbSB7fSBvYmpcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ1tdfSBrZXlzXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKVxyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcclxuXHJcbiAgICAgICAgLy8gYXZvaWQgaGFzT3duUHJvcGVydHkgZm9yIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxyXG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZhbHVlcyBmb3IgdGhlIGdpdmVuIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge30gb2JqXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgdGhlIG9iamVjdHMgcHJvcGVydHkgdmFsdWVzXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChvYmpba2V5c1tpXV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGF2b2lkIGhhc093blByb3BlcnR5IGZvciBwZXJmb3JtYW5jZVxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXldKTtcclxuICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2YWx1ZSBmcm9tIGBiYXNlYCByZWxhdGl2ZSB0byB0aGUgYHBhdGhgIHN0cmluZy5cclxuICAgICAqIEBtZXRob2QgZ2V0XHJcbiAgICAgKiBAcGFyYW0ge30gb2JqIFRoZSBiYXNlIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYGJhc2VgLCBlLmcuICdGb28uQmFyLmJheidcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYmVnaW5dIFBhdGggc2xpY2UgYmVnaW5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXSBQYXRoIHNsaWNlIGVuZFxyXG4gICAgICogQHJldHVybiB7fSBUaGUgb2JqZWN0IGF0IHRoZSBnaXZlbiBwYXRoXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5nZXQgPSBmdW5jdGlvbihvYmosIHBhdGgsIGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpLnNsaWNlKGJlZ2luLCBlbmQpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgb2JqID0gb2JqW3BhdGhbaV1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgdmFsdWUgb24gYGJhc2VgIHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBgcGF0aGAgc3RyaW5nLlxyXG4gICAgICogQG1ldGhvZCBzZXRcclxuICAgICAqIEBwYXJhbSB7fSBvYmogVGhlIGJhc2Ugb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgYmFzZWAsIGUuZy4gJ0Zvby5CYXIuYmF6J1xyXG4gICAgICogQHBhcmFtIHt9IHZhbCBUaGUgdmFsdWUgdG8gc2V0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JlZ2luXSBQYXRoIHNsaWNlIGJlZ2luXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gUGF0aCBzbGljZSBlbmRcclxuICAgICAqIEByZXR1cm4ge30gUGFzcyB0aHJvdWdoIGB2YWxgIGZvciBjaGFpbmluZ1xyXG4gICAgICovXHJcbiAgICBDb21tb24uc2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoLCB2YWwsIGJlZ2luLCBlbmQpIHtcclxuICAgICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcuJykuc2xpY2UoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgQ29tbW9uLmdldChvYmosIHBhdGgsIDAsIC0xKVtwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXV0gPSB2YWw7XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgaGV4IGNvbG91ciBzdHJpbmcgbWFkZSBieSBsaWdodGVuaW5nIG9yIGRhcmtlbmluZyBjb2xvciBieSBwZXJjZW50LlxyXG4gICAgICogQG1ldGhvZCBzaGFkZUNvbG9yXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50XHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgaGV4IGNvbG91clxyXG4gICAgICovXHJcbiAgICBDb21tb24uc2hhZGVDb2xvciA9IGZ1bmN0aW9uKGNvbG9yLCBwZXJjZW50KSB7ICAgXHJcbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NTYwMjQ4L3Byb2dyYW1tYXRpY2FsbHktbGlnaHRlbi1vci1kYXJrZW4tYS1oZXgtY29sb3JcclxuICAgICAgICB2YXIgY29sb3JJbnRlZ2VyID0gcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSksMTYpLCBcclxuICAgICAgICAgICAgYW1vdW50ID0gTWF0aC5yb3VuZCgyLjU1ICogcGVyY2VudCksIFxyXG4gICAgICAgICAgICBSID0gKGNvbG9ySW50ZWdlciA+PiAxNikgKyBhbW91bnQsIFxyXG4gICAgICAgICAgICBCID0gKGNvbG9ySW50ZWdlciA+PiA4ICYgMHgwMEZGKSArIGFtb3VudCwgXHJcbiAgICAgICAgICAgIEcgPSAoY29sb3JJbnRlZ2VyICYgMHgwMDAwRkYpICsgYW1vdW50O1xyXG4gICAgICAgIHJldHVybiBcIiNcIiArICgweDEwMDAwMDAgKyAoUiA8IDI1NSA/IFIgPCAxID8gMCA6IFIgOjI1NSkgKiAweDEwMDAwIFxyXG4gICAgICAgICAgICAgICAgKyAoQiA8IDI1NSA/IEIgPCAxID8gMCA6IEIgOiAyNTUpICogMHgxMDAgXHJcbiAgICAgICAgICAgICAgICArIChHIDwgMjU1ID8gRyA8IDEgPyAwIDogRyA6IDI1NSkpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaHVmZmxlcyB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2UuXHJcbiAgICAgKiBUaGUgZnVuY3Rpb24gdXNlcyBhIHNlZWRlZCByYW5kb20gZ2VuZXJhdG9yLlxyXG4gICAgICogQG1ldGhvZCBzaHVmZmxlXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhcnJheVxyXG4gICAgICogQHJldHVybiB7YXJyYXl9IGFycmF5IHNodWZmbGVkIHJhbmRvbWx5XHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5zaHVmZmxlID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoQ29tbW9uLnJhbmRvbSgpICogKGkgKyAxKSk7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gYXJyYXlbaV07XHJcbiAgICAgICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XHJcbiAgICAgICAgICAgIGFycmF5W2pdID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJhbmRvbWx5IGNob29zZXMgYSB2YWx1ZSBmcm9tIGEgbGlzdCB3aXRoIGVxdWFsIHByb2JhYmlsaXR5LlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIHVzZXMgYSBzZWVkZWQgcmFuZG9tIGdlbmVyYXRvci5cclxuICAgICAqIEBtZXRob2QgY2hvb3NlXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBjaG9pY2VzXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgcmFuZG9tIGNob2ljZSBvYmplY3QgZnJvbSB0aGUgYXJyYXlcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmNob29zZSA9IGZ1bmN0aW9uKGNob2ljZXMpIHtcclxuICAgICAgICByZXR1cm4gY2hvaWNlc1tNYXRoLmZsb29yKENvbW1vbi5yYW5kb20oKSAqIGNob2ljZXMubGVuZ3RoKV07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBIVE1MRWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gICAgICogQG1ldGhvZCBpc0VsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIEhUTUxFbGVtZW50LCBvdGhlcndpc2UgZmFsc2VcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg0Mjg2L2phdmFzY3JpcHQtaXNkb20taG93LWRvLXlvdS1jaGVjay1pZi1hLWphdmFzY3JpcHQtb2JqZWN0LWlzLWEtZG9tLW9iamVjdFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2goZSl7XHJcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIG9iaj09PVwib2JqZWN0XCIpICYmXHJcbiAgICAgICAgICAgICAgKG9iai5ub2RlVHlwZT09PTEpICYmICh0eXBlb2Ygb2JqLnN0eWxlID09PSBcIm9iamVjdFwiKSAmJlxyXG4gICAgICAgICAgICAgICh0eXBlb2Ygb2JqLm93bmVyRG9jdW1lbnQgPT09XCJvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGFycmF5LlxyXG4gICAgICogQG1ldGhvZCBpc0FycmF5XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gYXJyYXksIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBDb21tb24uaXNBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIGZ1bmN0aW9uLlxyXG4gICAgICogQG1ldGhvZCBpc0Z1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBmdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHBsYWluIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgaXNQbGFpbk9iamVjdFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcGxhaW4gb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBzdHJpbmcuXHJcbiAgICAgKiBAbWV0aG9kIGlzU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBzdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBDb21tb24uaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZ2l2ZW4gdmFsdWUgY2xhbXBlZCBiZXR3ZWVuIGEgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS5cclxuICAgICAqIEBtZXRob2QgY2xhbXBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgY2xhbXBlZCBiZXR3ZWVuIG1pbiBhbmQgbWF4IGluY2x1c2l2ZVxyXG4gICAgICovXHJcbiAgICBDb21tb24uY2xhbXAgPSBmdW5jdGlvbih2YWx1ZSwgbWluLCBtYXgpIHtcclxuICAgICAgICBpZiAodmFsdWUgPCBtaW4pXHJcbiAgICAgICAgICAgIHJldHVybiBtaW47XHJcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4KVxyXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2lnbiBvZiB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAgICAgKiBAbWV0aG9kIHNpZ25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtMSBpZiBuZWdhdGl2ZSwgKzEgaWYgMCBvciBwb3NpdGl2ZVxyXG4gICAgICovXHJcbiAgICBDb21tb24uc2lnbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/IC0xIDogMTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aW1lc3RhbXAgKGhpZ2gtcmVzIGlmIGF2YWlsYWJsZSkuXHJcbiAgICAgKiBAbWV0aG9kIG5vd1xyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgY3VycmVudCB0aW1lc3RhbXAgKGhpZ2gtcmVzIGlmIGF2YWlsYWJsZSlcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLm5vdyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjIxMjk0L2hvdy1kby15b3UtZ2V0LWEtdGltZXN0YW1wLWluLWphdmFzY3JpcHRcclxuICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kYXZpZHdhdGVyc3Rvbi8yOTgyNTMxXHJcblxyXG4gICAgICAgIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB7fTtcclxuXHJcbiAgICAgICAgcGVyZm9ybWFuY2Uubm93ID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93ICAgIHx8XHJcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLndlYmtpdE5vdyAgICAgfHxcclxuICAgICAgICAgICAgcGVyZm9ybWFuY2UubXNOb3cgICAgICAgICB8fFxyXG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5vTm93ICAgICAgICAgIHx8XHJcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1vek5vdyAgICAgICAgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiArKG5ldyBEYXRlKCkpOyB9O1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIHZhbHVlIGJldHdlZW4gYSBtaW5pbXVtIGFuZCBhIG1heGltdW0gdmFsdWUgaW5jbHVzaXZlLlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIHVzZXMgYSBzZWVkZWQgcmFuZG9tIGdlbmVyYXRvci5cclxuICAgICAqIEBtZXRob2QgcmFuZG9tXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IGluY2x1c2l2ZVxyXG4gICAgICovXHJcbiAgICBDb21tb24ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcclxuICAgICAgICBtaW4gPSAodHlwZW9mIG1pbiAhPT0gXCJ1bmRlZmluZWRcIikgPyBtaW4gOiAwO1xyXG4gICAgICAgIG1heCA9ICh0eXBlb2YgbWF4ICE9PSBcInVuZGVmaW5lZFwiKSA/IG1heCA6IDE7XHJcbiAgICAgICAgcmV0dXJuIG1pbiArIF9zZWVkZWRSYW5kb20oKSAqIChtYXggLSBtaW4pO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX3NlZWRlZFJhbmRvbSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25ncnltYW4vMzgzMDQ4OVxyXG4gICAgICAgIENvbW1vbi5fc2VlZCA9IChDb21tb24uX3NlZWQgKiA5MzAxICsgNDkyOTcpICUgMjMzMjgwO1xyXG4gICAgICAgIHJldHVybiBDb21tb24uX3NlZWQgLyAyMzMyODA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBDU1MgaGV4IGNvbG91ciBzdHJpbmcgaW50byBhbiBpbnRlZ2VyLlxyXG4gICAgICogQG1ldGhvZCBjb2xvclRvTnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JTdHJpbmdcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIENTUyBoZXggc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5jb2xvclRvTnVtYmVyID0gZnVuY3Rpb24oY29sb3JTdHJpbmcpIHtcclxuICAgICAgICBjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLnJlcGxhY2UoJyMnLCcnKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgICAgIGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuY2hhckF0KDApICsgY29sb3JTdHJpbmcuY2hhckF0KDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgY29sb3JTdHJpbmcuY2hhckF0KDEpICsgY29sb3JTdHJpbmcuY2hhckF0KDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgY29sb3JTdHJpbmcuY2hhckF0KDIpICsgY29sb3JTdHJpbmcuY2hhckF0KDIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnNvbGUgbG9nZ2luZyBsZXZlbCB0byB1c2UsIHdoZXJlIGVhY2ggbGV2ZWwgaW5jbHVkZXMgYWxsIGxldmVscyBhYm92ZSBhbmQgZXhjbHVkZXMgdGhlIGxldmVscyBiZWxvdy5cclxuICAgICAqIFRoZSBkZWZhdWx0IGxldmVsIGlzICdkZWJ1Zycgd2hpY2ggc2hvd3MgYWxsIGNvbnNvbGUgbWVzc2FnZXMuICBcclxuICAgICAqXHJcbiAgICAgKiBQb3NzaWJsZSBsZXZlbCB2YWx1ZXMgYXJlOlxyXG4gICAgICogLSAwID0gTm9uZVxyXG4gICAgICogLSAxID0gRGVidWdcclxuICAgICAqIC0gMiA9IEluZm9cclxuICAgICAqIC0gMyA9IFdhcm5cclxuICAgICAqIC0gNCA9IEVycm9yXHJcbiAgICAgKiBAcHJvcGVydHkgQ29tbW9uLmxvZ0xldmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcbiAgICBDb21tb24ubG9nTGV2ZWwgPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgYSBgY29uc29sZS5sb2dgIG1lc3NhZ2Ugb25seSBpZiB0aGUgY3VycmVudCBgQ29tbW9uLmxvZ0xldmVsYCBhbGxvd3MgaXQuXHJcbiAgICAgKiBUaGUgbWVzc2FnZSB3aWxsIGJlIHByZWZpeGVkIHdpdGggJ21hdHRlci1qcycgdG8gbWFrZSBpdCBlYXNpbHkgaWRlbnRpZmlhYmxlLlxyXG4gICAgICogQG1ldGhvZCBsb2dcclxuICAgICAqIEBwYXJhbSAuLi5vYmpzIHt9IFRoZSBvYmplY3RzIHRvIGxvZy5cclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmxvZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChjb25zb2xlICYmIENvbW1vbi5sb2dMZXZlbCA+IDAgJiYgQ29tbW9uLmxvZ0xldmVsIDw9IDMpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgWydtYXR0ZXItanM6J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgYSBgY29uc29sZS5pbmZvYCBtZXNzYWdlIG9ubHkgaWYgdGhlIGN1cnJlbnQgYENvbW1vbi5sb2dMZXZlbGAgYWxsb3dzIGl0LlxyXG4gICAgICogVGhlIG1lc3NhZ2Ugd2lsbCBiZSBwcmVmaXhlZCB3aXRoICdtYXR0ZXItanMnIHRvIG1ha2UgaXQgZWFzaWx5IGlkZW50aWZpYWJsZS5cclxuICAgICAqIEBtZXRob2QgaW5mb1xyXG4gICAgICogQHBhcmFtIC4uLm9ianMge30gVGhlIG9iamVjdHMgdG8gbG9nLlxyXG4gICAgICovXHJcbiAgICBDb21tb24uaW5mbyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChjb25zb2xlICYmIENvbW1vbi5sb2dMZXZlbCA+IDAgJiYgQ29tbW9uLmxvZ0xldmVsIDw9IDIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUsIFsnbWF0dGVyLWpzOiddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIGEgYGNvbnNvbGUud2FybmAgbWVzc2FnZSBvbmx5IGlmIHRoZSBjdXJyZW50IGBDb21tb24ubG9nTGV2ZWxgIGFsbG93cyBpdC5cclxuICAgICAqIFRoZSBtZXNzYWdlIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCAnbWF0dGVyLWpzJyB0byBtYWtlIGl0IGVhc2lseSBpZGVudGlmaWFibGUuXHJcbiAgICAgKiBAbWV0aG9kIHdhcm5cclxuICAgICAqIEBwYXJhbSAuLi5vYmpzIHt9IFRoZSBvYmplY3RzIHRvIGxvZy5cclxuICAgICAqL1xyXG4gICAgQ29tbW9uLndhcm4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY29uc29sZSAmJiBDb21tb24ubG9nTGV2ZWwgPiAwICYmIENvbW1vbi5sb2dMZXZlbCA8PSAzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBbJ21hdHRlci1qczonXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBzZXF1ZW50aWFsIElELlxyXG4gICAgICogQG1ldGhvZCBuZXh0SWRcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVW5pcXVlIHNlcXVlbnRpYWwgSURcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLm5leHRJZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBDb21tb24uX25leHRJZCsrO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY3Jvc3MgYnJvd3NlciBjb21wYXRpYmxlIGluZGV4T2YgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIGluZGV4T2ZcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGhheXN0YWNrXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmVlZGxlXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBwb3NpdGlvbiBvZiBuZWVkbGUgaW4gaGF5c3RhY2ssIG90aGVyd2lzZSAtMS5cclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmluZGV4T2YgPSBmdW5jdGlvbihoYXlzdGFjaywgbmVlZGxlKSB7XHJcbiAgICAgICAgaWYgKGhheXN0YWNrLmluZGV4T2YpXHJcbiAgICAgICAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGhheXN0YWNrW2ldID09PSBuZWVkbGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNyb3NzIGJyb3dzZXIgY29tcGF0aWJsZSBhcnJheSBtYXAgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIG1hcFxyXG4gICAgICogQHBhcmFtIHthcnJheX0gbGlzdFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xyXG4gICAgICogQHJldHVybiB7YXJyYXl9IFZhbHVlcyBmcm9tIGxpc3QgdHJhbnNmb3JtZWQgYnkgZnVuYy5cclxuICAgICAqL1xyXG4gICAgQ29tbW9uLm1hcCA9IGZ1bmN0aW9uKGxpc3QsIGZ1bmMpIHtcclxuICAgICAgICBpZiAobGlzdC5tYXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpc3QubWFwKGZ1bmMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1hcHBlZCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgbWFwcGVkLnB1c2goZnVuYyhsaXN0W2ldKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWFwcGVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgZGlyZWN0ZWQgZ3JhcGggYW5kIHJldHVybnMgdGhlIHBhcnRpYWxseSBvcmRlcmVkIHNldCBvZiB2ZXJ0aWNlcyBpbiB0b3BvbG9naWNhbCBvcmRlci5cclxuICAgICAqIENpcmN1bGFyIGRlcGVuZGVuY2llcyBhcmUgYWxsb3dlZC5cclxuICAgICAqIEBtZXRob2QgdG9wb2xvZ2ljYWxTb3J0XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcclxuICAgICAqIEByZXR1cm4ge2FycmF5fSBQYXJ0aWFsbHkgb3JkZXJlZCBzZXQgb2YgdmVydGljZXMgaW4gdG9wb2xvZ2ljYWwgb3JkZXIuXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi50b3BvbG9naWNhbFNvcnQgPSBmdW5jdGlvbihncmFwaCkge1xyXG4gICAgICAgIC8vIGh0dHBzOi8vbWdlY2hldi5naXRodWIuaW8vamF2YXNjcmlwdC1hbGdvcml0aG1zL2dyYXBoc19vdGhlcnNfdG9wb2xvZ2ljYWwtc29ydC5qcy5odG1sXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICB2aXNpdGVkID0gW10sXHJcbiAgICAgICAgICAgIHRlbXAgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgbm9kZSBpbiBncmFwaCkge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbbm9kZV0gJiYgIXRlbXBbbm9kZV0pIHtcclxuICAgICAgICAgICAgICAgIF90b3BvbG9naWNhbFNvcnQobm9kZSwgdmlzaXRlZCwgdGVtcCwgZ3JhcGgsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfdG9wb2xvZ2ljYWxTb3J0ID0gZnVuY3Rpb24obm9kZSwgdmlzaXRlZCwgdGVtcCwgZ3JhcGgsIHJlc3VsdCkge1xyXG4gICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaFtub2RlXSB8fCBbXTtcclxuICAgICAgICB0ZW1wW25vZGVdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRlbXBbbmVpZ2hib3JdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBza2lwIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtuZWlnaGJvcl0pIHtcclxuICAgICAgICAgICAgICAgIF90b3BvbG9naWNhbFNvcnQobmVpZ2hib3IsIHZpc2l0ZWQsIHRlbXAsIGdyYXBoLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0ZW1wW25vZGVdID0gZmFsc2U7XHJcbiAgICAgICAgdmlzaXRlZFtub2RlXSA9IHRydWU7XHJcblxyXG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIF9uXyBmdW5jdGlvbnMgYXMgYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlbSBpbiBvcmRlci5cclxuICAgICAqIFRoZSBhcmd1bWVudHMgYXBwbGllZCB3aGVuIGNhbGxpbmcgdGhlIG5ldyBmdW5jdGlvbiB3aWxsIGFsc28gYmUgYXBwbGllZCB0byBldmVyeSBmdW5jdGlvbiBwYXNzZWQuXHJcbiAgICAgKiBUaGUgdmFsdWUgb2YgYHRoaXNgIHJlZmVycyB0byB0aGUgbGFzdCB2YWx1ZSByZXR1cm5lZCBpbiB0aGUgY2hhaW4gdGhhdCB3YXMgbm90IGB1bmRlZmluZWRgLlxyXG4gICAgICogVGhlcmVmb3JlIGlmIGEgcGFzc2VkIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLCB0aGUgcHJldmlvdXNseSByZXR1cm5lZCB2YWx1ZSBpcyBtYWludGFpbmVkLlxyXG4gICAgICogQWZ0ZXIgYWxsIHBhc3NlZCBmdW5jdGlvbnMgaGF2ZSBiZWVuIGNhbGxlZCB0aGUgbmV3IGZ1bmN0aW9uIHJldHVybnMgdGhlIGxhc3QgcmV0dXJuZWQgdmFsdWUgKGlmIGFueSkuXHJcbiAgICAgKiBJZiBhbnkgb2YgdGhlIHBhc3NlZCBmdW5jdGlvbnMgYXJlIGEgY2hhaW4sIHRoZW4gdGhlIGNoYWluIHdpbGwgYmUgZmxhdHRlbmVkLlxyXG4gICAgICogQG1ldGhvZCBjaGFpblxyXG4gICAgICogQHBhcmFtIC4uLmZ1bmNzIHtmdW5jdGlvbn0gVGhlIGZ1bmN0aW9ucyB0byBjaGFpbi5cclxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBwYXNzZWQgZnVuY3Rpb25zIGluIG9yZGVyLlxyXG4gICAgICovXHJcbiAgICBDb21tb24uY2hhaW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZnVuY3MgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdmFyIGZ1bmMgPSBhcmd1bWVudHNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoZnVuYy5fY2hhaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmxhdHRlbiBhbHJlYWR5IGNoYWluZWQgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgICAgICBmdW5jcy5wdXNoLmFwcGx5KGZ1bmNzLCBmdW5jLl9jaGFpbmVkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZ1bmNzLnB1c2goZnVuYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjaGFpbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL2RldnRvb2xzLWRvY3MvaXNzdWVzLzUzI2lzc3VlY29tbWVudC01MTk0MTM1OFxyXG4gICAgICAgICAgICB2YXIgbGFzdFJlc3VsdCxcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmNzW2ldLmFwcGx5KGxhc3RSZXN1bHQsIGFyZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZXN1bHQgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNoYWluLl9jaGFpbmVkID0gZnVuY3M7XHJcblxyXG4gICAgICAgIHJldHVybiBjaGFpbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFpbnMgYSBmdW5jdGlvbiB0byBleGN1dGUgYmVmb3JlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBvbiB0aGUgZ2l2ZW4gYHBhdGhgIHJlbGF0aXZlIHRvIGBiYXNlYC5cclxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxyXG4gICAgICogQG1ldGhvZCBjaGFpblBhdGhCZWZvcmVcclxuICAgICAqIEBwYXJhbSB7fSBiYXNlIFRoZSBiYXNlIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYGJhc2VgXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGFpbiBiZWZvcmUgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGNoYWluZWQgZnVuY3Rpb24gdGhhdCByZXBsYWNlZCB0aGUgb3JpZ2luYWxcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmNoYWluUGF0aEJlZm9yZSA9IGZ1bmN0aW9uKGJhc2UsIHBhdGgsIGZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gQ29tbW9uLnNldChiYXNlLCBwYXRoLCBDb21tb24uY2hhaW4oXHJcbiAgICAgICAgICAgIGZ1bmMsXHJcbiAgICAgICAgICAgIENvbW1vbi5nZXQoYmFzZSwgcGF0aClcclxuICAgICAgICApKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFpbnMgYSBmdW5jdGlvbiB0byBleGN1dGUgYWZ0ZXIgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9uIHRoZSBnaXZlbiBgcGF0aGAgcmVsYXRpdmUgdG8gYGJhc2VgLlxyXG4gICAgICogU2VlIGFsc28gZG9jcyBmb3IgYENvbW1vbi5jaGFpbmAuXHJcbiAgICAgKiBAbWV0aG9kIGNoYWluUGF0aEFmdGVyXHJcbiAgICAgKiBAcGFyYW0ge30gYmFzZSBUaGUgYmFzZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBiYXNlYFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hhaW4gYWZ0ZXIgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGNoYWluZWQgZnVuY3Rpb24gdGhhdCByZXBsYWNlZCB0aGUgb3JpZ2luYWxcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmNoYWluUGF0aEFmdGVyID0gZnVuY3Rpb24oYmFzZSwgcGF0aCwgZnVuYykge1xyXG4gICAgICAgIHJldHVybiBDb21tb24uc2V0KGJhc2UsIHBhdGgsIENvbW1vbi5jaGFpbihcclxuICAgICAgICAgICAgQ29tbW9uLmdldChiYXNlLCBwYXRoKSxcclxuICAgICAgICAgICAgZnVuY1xyXG4gICAgICAgICkpO1xyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvQ29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IGZ1bmN0aW9uICh4LCB5KVxyXG57XHJcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuXHJcbiAgICB0aGlzLnkgPSB5O1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnQ7XHJcblxyXG5Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc2V0VG86IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Qb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgVkVSU0lPTjogJzMuMC4wJyxcclxuXHJcbiAgICBBVVRPOiAwLFxyXG4gICAgQ0FOVkFTOiAxLFxyXG4gICAgV0VCR0w6IDJcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlci5Cb3VuZHNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hlcyAoQUFCQikuXHJcbipcclxuKiBAY2xhc3MgQm91bmRzXHJcbiovXHJcblxyXG52YXIgQm91bmRzID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJvdW5kcztcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCAoQUFCQikgZm9yIHRoZSBnaXZlbiB2ZXJ0aWNlcy5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xyXG4gICAgICogQHJldHVybiB7Ym91bmRzfSBBIG5ldyBib3VuZHMgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIEJvdW5kcy5jcmVhdGUgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xyXG4gICAgICAgIHZhciBib3VuZHMgPSB7IFxyXG4gICAgICAgICAgICBtaW46IHsgeDogMCwgeTogMCB9LCBcclxuICAgICAgICAgICAgbWF4OiB7IHg6IDAsIHk6IDAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICh2ZXJ0aWNlcylcclxuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShib3VuZHMsIHZlcnRpY2VzKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gYm91bmRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgYm91bmRzIHVzaW5nIHRoZSBnaXZlbiB2ZXJ0aWNlcyBhbmQgZXh0ZW5kcyB0aGUgYm91bmRzIGdpdmVuIGEgdmVsb2NpdHkuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc1xyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWxvY2l0eVxyXG4gICAgICovXHJcbiAgICBCb3VuZHMudXBkYXRlID0gZnVuY3Rpb24oYm91bmRzLCB2ZXJ0aWNlcywgdmVsb2NpdHkpIHtcclxuICAgICAgICBib3VuZHMubWluLnggPSBJbmZpbml0eTtcclxuICAgICAgICBib3VuZHMubWF4LnggPSAtSW5maW5pdHk7XHJcbiAgICAgICAgYm91bmRzLm1pbi55ID0gSW5maW5pdHk7XHJcbiAgICAgICAgYm91bmRzLm1heC55ID0gLUluZmluaXR5O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgaWYgKHZlcnRleC54ID4gYm91bmRzLm1heC54KSBib3VuZHMubWF4LnggPSB2ZXJ0ZXgueDtcclxuICAgICAgICAgICAgaWYgKHZlcnRleC54IDwgYm91bmRzLm1pbi54KSBib3VuZHMubWluLnggPSB2ZXJ0ZXgueDtcclxuICAgICAgICAgICAgaWYgKHZlcnRleC55ID4gYm91bmRzLm1heC55KSBib3VuZHMubWF4LnkgPSB2ZXJ0ZXgueTtcclxuICAgICAgICAgICAgaWYgKHZlcnRleC55IDwgYm91bmRzLm1pbi55KSBib3VuZHMubWluLnkgPSB2ZXJ0ZXgueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHZlbG9jaXR5KSB7XHJcbiAgICAgICAgICAgIGlmICh2ZWxvY2l0eS54ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYm91bmRzLm1heC54ICs9IHZlbG9jaXR5Lng7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZHMubWluLnggKz0gdmVsb2NpdHkueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHZlbG9jaXR5LnkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZHMubWF4LnkgKz0gdmVsb2NpdHkueTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueSArPSB2ZWxvY2l0eS55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYm91bmRzIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuICAgICAqIEBtZXRob2QgY29udGFpbnNcclxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYm91bmRzIGNvbnRhaW4gdGhlIHBvaW50LCBvdGhlcndpc2UgZmFsc2VcclxuICAgICAqL1xyXG4gICAgQm91bmRzLmNvbnRhaW5zID0gZnVuY3Rpb24oYm91bmRzLCBwb2ludCkge1xyXG4gICAgICAgIHJldHVybiBwb2ludC54ID49IGJvdW5kcy5taW4ueCAmJiBwb2ludC54IDw9IGJvdW5kcy5tYXgueCBcclxuICAgICAgICAgICAgICAgJiYgcG9pbnQueSA+PSBib3VuZHMubWluLnkgJiYgcG9pbnQueSA8PSBib3VuZHMubWF4Lnk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gYm91bmRzIGludGVyc2VjdC5cclxuICAgICAqIEBtZXRob2Qgb3ZlcmxhcHNcclxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNBXHJcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzQlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYm91bmRzIG92ZXJsYXAsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBCb3VuZHMub3ZlcmxhcHMgPSBmdW5jdGlvbihib3VuZHNBLCBib3VuZHNCKSB7XHJcbiAgICAgICAgcmV0dXJuIChib3VuZHNBLm1pbi54IDw9IGJvdW5kc0IubWF4LnggJiYgYm91bmRzQS5tYXgueCA+PSBib3VuZHNCLm1pbi54XHJcbiAgICAgICAgICAgICAgICAmJiBib3VuZHNBLm1heC55ID49IGJvdW5kc0IubWluLnkgJiYgYm91bmRzQS5taW4ueSA8PSBib3VuZHNCLm1heC55KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBib3VuZHMgYnkgdGhlIGdpdmVuIHZlY3Rvci5cclxuICAgICAqIEBtZXRob2QgdHJhbnNsYXRlXHJcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIEJvdW5kcy50cmFuc2xhdGUgPSBmdW5jdGlvbihib3VuZHMsIHZlY3Rvcikge1xyXG4gICAgICAgIGJvdW5kcy5taW4ueCArPSB2ZWN0b3IueDtcclxuICAgICAgICBib3VuZHMubWF4LnggKz0gdmVjdG9yLng7XHJcbiAgICAgICAgYm91bmRzLm1pbi55ICs9IHZlY3Rvci55O1xyXG4gICAgICAgIGJvdW5kcy5tYXgueSArPSB2ZWN0b3IueTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGlmdHMgdGhlIGJvdW5kcyB0byB0aGUgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIHNoaWZ0XHJcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgQm91bmRzLnNoaWZ0ID0gZnVuY3Rpb24oYm91bmRzLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBkZWx0YVggPSBib3VuZHMubWF4LnggLSBib3VuZHMubWluLngsXHJcbiAgICAgICAgICAgIGRlbHRhWSA9IGJvdW5kcy5tYXgueSAtIGJvdW5kcy5taW4ueTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgYm91bmRzLm1pbi54ID0gcG9zaXRpb24ueDtcclxuICAgICAgICBib3VuZHMubWF4LnggPSBwb3NpdGlvbi54ICsgZGVsdGFYO1xyXG4gICAgICAgIGJvdW5kcy5taW4ueSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgICAgYm91bmRzLm1heC55ID0gcG9zaXRpb24ueSArIGRlbHRhWTtcclxuICAgIH07XHJcbiAgICBcclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvQm91bmRzLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlZlY3RvcmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgdmVjdG9ycy5cclxuKiBWZWN0b3JzIGFyZSB0aGUgYmFzaXMgb2YgYWxsIHRoZSBnZW9tZXRyeSByZWxhdGVkIG9wZXJhdGlvbnMgaW4gdGhlIGVuZ2luZS5cclxuKiBBIGBNYXR0ZXIuVmVjdG9yYCBvYmplY3QgaXMgb2YgdGhlIGZvcm0gYHsgeDogMCwgeTogMCB9YC5cclxuKlxyXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXHJcbipcclxuKiBAY2xhc3MgVmVjdG9yXHJcbiovXHJcblxyXG4vLyBUT0RPOiBjb25zaWRlciBwYXJhbXMgZm9yIHJldXNpbmcgdmVjdG9yIG9iamVjdHNcclxuXHJcbnZhciBWZWN0b3IgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvclxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuY3JlYXRlID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHggfHwgMCwgeTogeSB8fCAwIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyB2ZWN0b3Igd2l0aCBgeGAgYW5kIGB5YCBjb3BpZWQgZnJvbSB0aGUgZ2l2ZW4gYHZlY3RvcmAuXHJcbiAgICAgKiBAbWV0aG9kIGNsb25lXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXHJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IGNsb25lZCB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLmNsb25lID0gZnVuY3Rpb24odmVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogdmVjdG9yLngsIHk6IHZlY3Rvci55IH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWFnbml0dWRlIChsZW5ndGgpIG9mIGEgdmVjdG9yLlxyXG4gICAgICogQG1ldGhvZCBtYWduaXR1ZGVcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5tYWduaXR1ZGUgPSBmdW5jdGlvbih2ZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh2ZWN0b3IueCAqIHZlY3Rvci54KSArICh2ZWN0b3IueSAqIHZlY3Rvci55KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWFnbml0dWRlIChsZW5ndGgpIG9mIGEgdmVjdG9yICh0aGVyZWZvcmUgc2F2aW5nIGEgYHNxcnRgIG9wZXJhdGlvbikuXHJcbiAgICAgKiBAbWV0aG9kIG1hZ25pdHVkZVNxdWFyZWRcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNxdWFyZWQgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLm1hZ25pdHVkZVNxdWFyZWQgPSBmdW5jdGlvbih2ZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gKHZlY3Rvci54ICogdmVjdG9yLngpICsgKHZlY3Rvci55ICogdmVjdG9yLnkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZXMgdGhlIHZlY3RvciBhYm91dCAoMCwgMCkgYnkgc3BlY2lmaWVkIGFuZ2xlLlxyXG4gICAgICogQG1ldGhvZCByb3RhdGVcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igcm90YXRlZCBhYm91dCAoMCwgMClcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLnJvdGF0ZSA9IGZ1bmN0aW9uKHZlY3RvciwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdmVjdG9yLnggKiBjb3MgLSB2ZWN0b3IueSAqIHNpbixcclxuICAgICAgICAgICAgeTogdmVjdG9yLnggKiBzaW4gKyB2ZWN0b3IueSAqIGNvc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlcyB0aGUgdmVjdG9yIGFib3V0IGEgc3BlY2lmaWVkIHBvaW50IGJ5IHNwZWNpZmllZCBhbmdsZS5cclxuICAgICAqIEBtZXRob2Qgcm90YXRlQWJvdXRcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW291dHB1dF1cclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgdmVjdG9yIHJvdGF0ZWQgYWJvdXQgdGhlIHBvaW50XHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5yb3RhdGVBYm91dCA9IGZ1bmN0aW9uKHZlY3RvciwgYW5nbGUsIHBvaW50LCBvdXRwdXQpIHtcclxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xyXG4gICAgICAgIHZhciB4ID0gcG9pbnQueCArICgodmVjdG9yLnggLSBwb2ludC54KSAqIGNvcyAtICh2ZWN0b3IueSAtIHBvaW50LnkpICogc2luKTtcclxuICAgICAgICBvdXRwdXQueSA9IHBvaW50LnkgKyAoKHZlY3Rvci54IC0gcG9pbnQueCkgKiBzaW4gKyAodmVjdG9yLnkgLSBwb2ludC55KSAqIGNvcyk7XHJcbiAgICAgICAgb3V0cHV0LnggPSB4O1xyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXNlcyBhIHZlY3RvciAoc3VjaCB0aGF0IGl0cyBtYWduaXR1ZGUgaXMgYDFgKS5cclxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXNlXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXHJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBub3JtYWxpc2VkXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5ub3JtYWxpc2UgPSBmdW5jdGlvbih2ZWN0b3IpIHtcclxuICAgICAgICB2YXIgbWFnbml0dWRlID0gVmVjdG9yLm1hZ25pdHVkZSh2ZWN0b3IpO1xyXG4gICAgICAgIGlmIChtYWduaXR1ZGUgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICByZXR1cm4geyB4OiB2ZWN0b3IueCAvIG1hZ25pdHVkZSwgeTogdmVjdG9yLnkgLyBtYWduaXR1ZGUgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkb3QtcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cclxuICAgICAqIEBtZXRob2QgZG90XHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSB0d28gdmVjdG9yc1xyXG4gICAgICovXHJcbiAgICBWZWN0b3IuZG90ID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQikge1xyXG4gICAgICAgIHJldHVybiAodmVjdG9yQS54ICogdmVjdG9yQi54KSArICh2ZWN0b3JBLnkgKiB2ZWN0b3JCLnkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNyb3NzLXByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMuXHJcbiAgICAgKiBAbWV0aG9kIGNyb3NzXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhlIHR3byB2ZWN0b3JzXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5jcm9zcyA9IGZ1bmN0aW9uKHZlY3RvckEsIHZlY3RvckIpIHtcclxuICAgICAgICByZXR1cm4gKHZlY3RvckEueCAqIHZlY3RvckIueSkgLSAodmVjdG9yQS55ICogdmVjdG9yQi54KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjcm9zcy1wcm9kdWN0IG9mIHRocmVlIHZlY3RvcnMuXHJcbiAgICAgKiBAbWV0aG9kIGNyb3NzM1xyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JCXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQ1xyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgdGhyZWUgdmVjdG9yc1xyXG4gICAgICovXHJcbiAgICBWZWN0b3IuY3Jvc3MzID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQiwgdmVjdG9yQykge1xyXG4gICAgICAgIHJldHVybiAodmVjdG9yQi54IC0gdmVjdG9yQS54KSAqICh2ZWN0b3JDLnkgLSB2ZWN0b3JBLnkpIC0gKHZlY3RvckIueSAtIHZlY3RvckEueSkgKiAodmVjdG9yQy54IC0gdmVjdG9yQS54KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSB0d28gdmVjdG9ycy5cclxuICAgICAqIEBtZXRob2QgYWRkXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBbb3V0cHV0XVxyXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igb2YgdmVjdG9yQSBhbmQgdmVjdG9yQiBhZGRlZFxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuYWRkID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQiwgb3V0cHV0KSB7XHJcbiAgICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xyXG4gICAgICAgIG91dHB1dC54ID0gdmVjdG9yQS54ICsgdmVjdG9yQi54O1xyXG4gICAgICAgIG91dHB1dC55ID0gdmVjdG9yQS55ICsgdmVjdG9yQi55O1xyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHRoZSB0d28gdmVjdG9ycy5cclxuICAgICAqIEBtZXRob2Qgc3ViXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBbb3V0cHV0XVxyXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igb2YgdmVjdG9yQSBhbmQgdmVjdG9yQiBzdWJ0cmFjdGVkXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5zdWIgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCLCBvdXRwdXQpIHtcclxuICAgICAgICBpZiAoIW91dHB1dCkgb3V0cHV0ID0ge307XHJcbiAgICAgICAgb3V0cHV0LnggPSB2ZWN0b3JBLnggLSB2ZWN0b3JCLng7XHJcbiAgICAgICAgb3V0cHV0LnkgPSB2ZWN0b3JBLnkgLSB2ZWN0b3JCLnk7XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGFuZCBhIHNjYWxhci5cclxuICAgICAqIEBtZXRob2QgbXVsdFxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhclxyXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3IgbXVsdGlwbGllZCBieSBzY2FsYXJcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLm11bHQgPSBmdW5jdGlvbih2ZWN0b3IsIHNjYWxhcikge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHZlY3Rvci54ICogc2NhbGFyLCB5OiB2ZWN0b3IueSAqIHNjYWxhciB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYW5kIGEgc2NhbGFyLlxyXG4gICAgICogQG1ldGhvZCBkaXZcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgdmVjdG9yIGRpdmlkZWQgYnkgc2NhbGFyXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5kaXYgPSBmdW5jdGlvbih2ZWN0b3IsIHNjYWxhcikge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHZlY3Rvci54IC8gc2NhbGFyLCB5OiB2ZWN0b3IueSAvIHNjYWxhciB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBlcnBlbmRpY3VsYXIgdmVjdG9yLiBTZXQgYG5lZ2F0ZWAgdG8gdHJ1ZSBmb3IgdGhlIHBlcnBlbmRpY3VsYXIgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cclxuICAgICAqIEBtZXRob2QgcGVycFxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtib29sfSBbbmVnYXRlPWZhbHNlXVxyXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgcGVycGVuZGljdWxhciB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLnBlcnAgPSBmdW5jdGlvbih2ZWN0b3IsIG5lZ2F0ZSkge1xyXG4gICAgICAgIG5lZ2F0ZSA9IG5lZ2F0ZSA9PT0gdHJ1ZSA/IC0xIDogMTtcclxuICAgICAgICByZXR1cm4geyB4OiBuZWdhdGUgKiAtdmVjdG9yLnksIHk6IG5lZ2F0ZSAqIHZlY3Rvci54IH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlcyBib3RoIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3Igc3VjaCB0aGF0IGl0IHBvaW50cyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxyXG4gICAgICogQG1ldGhvZCBuZWdcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gVGhlIG5lZ2F0ZWQgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5uZWcgPSBmdW5jdGlvbih2ZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4geyB4OiAtdmVjdG9yLngsIHk6IC12ZWN0b3IueSB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgYmV0d2VlbiB0aGUgdHdvIHZlY3RvcnMgcmVsYXRpdmUgdG8gdGhlIHgtYXhpcy5cclxuICAgICAqIEBtZXRob2QgYW5nbGVcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICovXHJcbiAgICBWZWN0b3IuYW5nbGUgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodmVjdG9yQi55IC0gdmVjdG9yQS55LCB2ZWN0b3JCLnggLSB2ZWN0b3JBLngpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbXBvcmFyeSB2ZWN0b3IgcG9vbCAobm90IHRocmVhZC1zYWZlKS5cclxuICAgICAqIEBwcm9wZXJ0eSBfdGVtcFxyXG4gICAgICogQHR5cGUge3ZlY3RvcltdfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLl90ZW1wID0gW1xyXG4gICAgICAgIFZlY3Rvci5jcmVhdGUoKSwgVmVjdG9yLmNyZWF0ZSgpLCBcclxuICAgICAgICBWZWN0b3IuY3JlYXRlKCksIFZlY3Rvci5jcmVhdGUoKSwgXHJcbiAgICAgICAgVmVjdG9yLmNyZWF0ZSgpLCBWZWN0b3IuY3JlYXRlKClcclxuICAgIF07XHJcblxyXG59KSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1ZlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSBmdW5jdGlvbiAodHlwZSlcclxue1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuXHJcbiAgICAvLyAgVGhlIGVsZW1lbnQgdGhhdCBpbml0aWF0ZWQgdGhlIGV2ZW50LlxyXG4gICAgdGhpcy50YXJnZXQ7XHJcblxyXG4gICAgdGhpcy5fcHJvcGFnYXRlID0gdHJ1ZTtcclxufTtcclxuXHJcbkV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50O1xyXG5cclxuRXZlbnQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAodGFyZ2V0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG5cclxuICAgICAgICB0aGlzLl9wcm9wYWdhdGUgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZXZlbnRzL0V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4vKipcclxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgZ2xvYmFsIGxldmVsIGNvbnRhaW5lciBvZiBGYWN0b3J5IGluc3RhbmNlcy5cclxuKiBGYWN0b3JpZXMgcmVnaXN0ZXIgdGhlbXNlbHZlcyB3aXRoIHRoaXMgY29udGFpbmVyICh3aGVuIHJlcXVpcmVkKVxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5HYW1lT2JqZWN0LkZhY3RvcnlcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXHJcbiovXHJcblxyXG52YXIgZmFjdG9yaWVzID0ge307XHJcblxyXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIC8vIGNvbnNvbGUubG9nKCdGYWN0b3J5Q29udGFpbmVyIGlzIGFsaXZlJyk7XHJcblxyXG4gICAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uIChmYWN0b3J5KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChmYWN0b3JpZXMuaGFzT3duUHJvcGVydHkoZmFjdG9yeS5LRVkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0FscmVhZHkgcmVnaXN0ZXJlZCcsIGZhY3RvcnkuS0VZKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoZmFjdG9yeS5LRVkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVnaXN0ZXJpbmcnLCBmYWN0b3J5LktFWSk7XHJcblxyXG4gICAgICAgICAgICBmYWN0b3JpZXNbZmFjdG9yeS5LRVldID0ge1xyXG4gICAgICAgICAgICAgICAgYWRkOiBmYWN0b3J5LmFkZCxcclxuICAgICAgICAgICAgICAgIG1ha2U6IGZhY3RvcnkubWFrZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldFR5cGUgPSBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWN0b3JpZXNba2V5XTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5sb2FkID0gZnVuY3Rpb24gKGRlc3QsIGlzRmFjdG9yeSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBmYWN0b3J5IGluIGZhY3RvcmllcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3JpZXMuaGFzT3duUHJvcGVydHkoZmFjdG9yeSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdMb2FkaW5nJywgZmFjdG9yeSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVzdFtmYWN0b3J5XSA9IChpc0ZhY3RvcnkpID8gZmFjdG9yaWVzW2ZhY3RvcnldLmFkZCA6IGZhY3Rvcmllc1tmYWN0b3J5XS5tYWtlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUSF9DT05TVCA9IHtcclxuXHJcbiAgICBQSTI6IE1hdGguUEkgKiAyLFxyXG4gICAgVEFVOiBNYXRoLlBJICogMC41LFxyXG4gICAgRVBTSUxPTjogMS4wZS02LFxyXG4gICAgREVHX1RPX1JBRDogTWF0aC5QSSAvIDE4MCxcclxuICAgIFJBRF9UT19ERUc6IDE4MCAvIE1hdGguUElcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1BVEhfQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQWxwaGE6IHJlcXVpcmUoJy4vQWxwaGEnKSxcclxuICAgIEJsZW5kTW9kZTogcmVxdWlyZSgnLi9CbGVuZE1vZGUnKSxcclxuICAgIENoaWxkcmVuOiByZXF1aXJlKCcuL0NoaWxkcmVuJyksXHJcbiAgICBDb2xvcjogcmVxdWlyZSgnLi9Db2xvcicpLFxyXG4gICAgRGF0YTogcmVxdWlyZSgnLi9EYXRhJyksXHJcbiAgICBHZXRCb3VuZHM6IHJlcXVpcmUoJy4vR2V0Qm91bmRzJyksXHJcbiAgICBPcmlnaW46IHJlcXVpcmUoJy4vT3JpZ2luJyksXHJcbiAgICBTY2FsZU1vZGU6IHJlcXVpcmUoJy4vU2NhbGVNb2RlJyksXHJcbiAgICBTaXplOiByZXF1aXJlKCcuL1NpemUnKSxcclxuICAgIFRleHR1cmU6IHJlcXVpcmUoJy4vVGV4dHVyZScpLFxyXG4gICAgVHJhbnNmb3JtOiByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxyXG4gICAgVHJhbnNmb3JtTWF0cml4OiByZXF1aXJlKCcuL1RyYW5zZm9ybU1hdHJpeCcpLFxyXG4gICAgVmlzaWJsZTogcmVxdWlyZSgnLi9WaXNpYmxlJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9pbmRleC5qcyIsIi8vICBUYWtlbiBmcm9tIGtsYXNzZSBieSBtYXR0ZGVzbCBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wva2xhc3NlXHJcblxyXG5mdW5jdGlvbiBoYXNHZXR0ZXJPclNldHRlciAoZGVmKVxyXG57XHJcbiAgICByZXR1cm4gKCEhZGVmLmdldCAmJiB0eXBlb2YgZGVmLmdldCA9PT0gJ2Z1bmN0aW9uJykgfHwgKCEhZGVmLnNldCAmJiB0eXBlb2YgZGVmLnNldCA9PT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFByb3BlcnR5IChkZWZpbml0aW9uLCBrLCBpc0NsYXNzRGVzY3JpcHRvcilcclxue1xyXG4gICAgLy8gIFRoaXMgbWF5IGJlIGEgbGlnaHR3ZWlnaHQgb2JqZWN0LCBPUiBpdCBtaWdodCBiZSBhIHByb3BlcnR5IHRoYXQgd2FzIGRlZmluZWQgcHJldmlvdXNseS5cclxuICAgIFxyXG4gICAgLy8gIEZvciBzaW1wbGUgY2xhc3MgZGVzY3JpcHRvcnMgd2UgY2FuIGp1c3QgYXNzdW1lIGl0cyBOT1QgcHJldmlvdXNseSBkZWZpbmVkLlxyXG4gICAgdmFyIGRlZiA9IChpc0NsYXNzRGVzY3JpcHRvcikgPyBkZWZpbml0aW9uW2tdIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZpbml0aW9uLCBrKTtcclxuXHJcbiAgICBpZiAoIWlzQ2xhc3NEZXNjcmlwdG9yICYmIGRlZi52YWx1ZSAmJiB0eXBlb2YgZGVmLnZhbHVlID09PSAnb2JqZWN0JylcclxuICAgIHtcclxuICAgICAgICBkZWYgPSBkZWYudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFRoaXMgbWlnaHQgYmUgYSByZWd1bGFyIHByb3BlcnR5LCBvciBpdCBtYXkgYmUgYSBnZXR0ZXIvc2V0dGVyIHRoZSB1c2VyIGRlZmluZWQgaW4gYSBjbGFzcy5cclxuICAgIGlmIChkZWYgJiYgaGFzR2V0dGVyT3JTZXR0ZXIoZGVmKSlcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRlZi5lbnVtZXJhYmxlID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlZi5lbnVtZXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZGVmLmNvbmZpZ3VyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWYuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkZWY7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNOb25Db25maWd1cmFibGUgKG9iaiwgaylcclxue1xyXG4gICAgdmFyIHByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgayk7XHJcblxyXG4gICAgaWYgKCFwcm9wKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJvcC52YWx1ZSAmJiB0eXBlb2YgcHJvcC52YWx1ZSA9PT0gJ29iamVjdCcpXHJcbiAgICB7XHJcbiAgICAgICAgcHJvcCA9IHByb3AudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb3AuY29uZmlndXJhYmxlID09PSBmYWxzZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dGVuZCAoY3RvciwgZGVmaW5pdGlvbiwgaXNDbGFzc0Rlc2NyaXB0b3IsIGV4dGVuZClcclxue1xyXG4gICAgZm9yICh2YXIgayBpbiBkZWZpbml0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghZGVmaW5pdGlvbi5oYXNPd25Qcm9wZXJ0eShrKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlZiA9IGdldFByb3BlcnR5KGRlZmluaXRpb24sIGssIGlzQ2xhc3NEZXNjcmlwdG9yKTtcclxuXHJcbiAgICAgICAgaWYgKGRlZiAhPT0gZmFsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSWYgRXh0ZW5kcyBpcyB1c2VkLCB3ZSB3aWxsIGNoZWNrIGl0cyBwcm90b3R5cGUgdG8gc2VlIGlmIHRoZSBmaW5hbCB2YXJpYWJsZSBleGlzdHMuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZXh0ZW5kIHx8IGN0b3I7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGFzTm9uQ29uZmlndXJhYmxlKHBhcmVudC5wcm90b3R5cGUsIGspKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgSnVzdCBza2lwIHRoZSBmaW5hbCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgaWYgKENsYXNzLmlnbm9yZUZpbmFscylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgV2UgY2Fubm90IHJlLWRlZmluZSBhIHByb3BlcnR5IHRoYXQgaXMgY29uZmlndXJhYmxlPWZhbHNlLlxyXG4gICAgICAgICAgICAgICAgLy8gIFNvIHdlIHdpbGwgY29uc2lkZXIgdGhlbSBmaW5hbCBhbmQgdGhyb3cgYW4gZXJyb3IuIFRoaXMgaXMgYnlcclxuICAgICAgICAgICAgICAgIC8vICBkZWZhdWx0IHNvIGl0IGlzIGNsZWFyIHRvIHRoZSBkZXZlbG9wZXIgd2hhdCBpcyBoYXBwZW5pbmcuXHJcbiAgICAgICAgICAgICAgICAvLyAgWW91IGNhbiBzZXQgaWdub3JlRmluYWxzIHRvIHRydWUgaWYgeW91IG5lZWQgdG8gZXh0ZW5kIGEgY2xhc3NcclxuICAgICAgICAgICAgICAgIC8vICB3aGljaCBoYXMgY29uZmlndXJhYmxlPWZhbHNlOyBpdCB3aWxsIHNpbXBseSBub3QgcmUtZGVmaW5lIGZpbmFsIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBvdmVycmlkZSBmaW5hbCBwcm9wZXJ0eSBcXCcnICsgayArICdcXCcsIHNldCBDbGFzcy5pZ25vcmVGaW5hbHMgPSB0cnVlIHRvIHNraXAnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrLCBkZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZVtrXSA9IGRlZmluaXRpb25ba107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtaXhpbiAobXlDbGFzcywgbWl4aW5zKVxyXG57XHJcbiAgICBpZiAoIW1peGlucylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1peGlucykpXHJcbiAgICB7XHJcbiAgICAgICAgbWl4aW5zID0gWyBtaXhpbnMgXTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBleHRlbmQobXlDbGFzcywgbWl4aW5zW2ldLnByb3RvdHlwZSB8fCBtaXhpbnNbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBjbGFzcyB3aXRoIHRoZSBnaXZlbiBkZXNjcmlwdG9yLlxyXG4gKiBUaGUgY29uc3RydWN0b3IsIGRlZmluZWQgYnkgdGhlIG5hbWUgYGluaXRpYWxpemVgLFxyXG4gKiBpcyBhbiBvcHRpb25hbCBmdW5jdGlvbi4gSWYgdW5zcGVjaWZpZWQsIGFuIGFub255bW91c1xyXG4gKiBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgd2hpY2ggY2FsbHMgdGhlIHBhcmVudCBjbGFzcyAoaWZcclxuICogb25lIGV4aXN0cykuXHJcbiAqXHJcbiAqIFlvdSBjYW4gYWxzbyB1c2UgYEV4dGVuZHNgIGFuZCBgTWl4aW5zYCB0byBwcm92aWRlIHN1YmNsYXNzaW5nXHJcbiAqIGFuZCBpbmhlcml0YW5jZS5cclxuICpcclxuICogQGNsYXNzICBDbGFzc1xyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb24gYSBkaWN0aW9uYXJ5IG9mIGZ1bmN0aW9ucyBmb3IgdGhlIGNsYXNzXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqICAgICAgdmFyIE15Q2xhc3MgPSBuZXcgUGhhc2VyLkNsYXNzKHtcclxuICogICAgICBcclxuICogICAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgICAgICAgICB0aGlzLmZvbyA9IDIuMDtcclxuICogICAgICAgICAgfSxcclxuICpcclxuICogICAgICAgICAgYmFyOiBmdW5jdGlvbigpIHtcclxuICogICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvbyArIDU7XHJcbiAqICAgICAgICAgIH1cclxuICogICAgICB9KTtcclxuICovXHJcbmZ1bmN0aW9uIENsYXNzIChkZWZpbml0aW9uKVxyXG57XHJcbiAgICBpZiAoIWRlZmluaXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgZGVmaW5pdGlvbiA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBUaGUgdmFyaWFibGUgbmFtZSBoZXJlIGRpY3RhdGVzIHdoYXQgd2Ugc2VlIGluIENocm9tZSBkZWJ1Z2dlclxyXG4gICAgdmFyIGluaXRpYWxpemU7XHJcbiAgICB2YXIgRXh0ZW5kcztcclxuXHJcbiAgICBpZiAoZGVmaW5pdGlvbi5pbml0aWFsaXplKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbi5pbml0aWFsaXplICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0aWFsaXplIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5pdGlhbGl6ZSA9IGRlZmluaXRpb24uaW5pdGlhbGl6ZTtcclxuXHJcbiAgICAgICAgLy8gIFVzdWFsbHkgd2Ugc2hvdWxkIGF2b2lkICdkZWxldGUnIGluIFY4IGF0IGFsbCBjb3N0cy5cclxuICAgICAgICAvLyAgSG93ZXZlciwgaXRzIHVubGlrZWx5IHRvIG1ha2UgYW55IHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VcclxuICAgICAgICAvLyAgaGVyZSBzaW5jZSB3ZSBvbmx5IGNhbGwgdGhpcyBvbiBjbGFzcyBjcmVhdGlvbiAoaS5lLiBub3Qgb2JqZWN0IGNyZWF0aW9uKS5cclxuICAgICAgICBkZWxldGUgZGVmaW5pdGlvbi5pbml0aWFsaXplO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmIChkZWZpbml0aW9uLkV4dGVuZHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYmFzZSA9IGRlZmluaXRpb24uRXh0ZW5kcztcclxuXHJcbiAgICAgICAgICAgIGluaXRpYWxpemUgPSBmdW5jdGlvbiAoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRlZmluaXRpb24uRXh0ZW5kcylcclxuICAgIHtcclxuICAgICAgICBpbml0aWFsaXplLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZGVmaW5pdGlvbi5FeHRlbmRzLnByb3RvdHlwZSk7XHJcbiAgICAgICAgaW5pdGlhbGl6ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBpbml0aWFsaXplO1xyXG5cclxuICAgICAgICAvLyAgRm9yIGdldE93blByb3BlcnR5RGVzY3JpcHRvciB0byB3b3JrLCB3ZSBuZWVkIHRvIGFjdCBkaXJlY3RseSBvbiB0aGUgRXh0ZW5kcyAob3IgTWl4aW4pXHJcblxyXG4gICAgICAgIEV4dGVuZHMgPSBkZWZpbml0aW9uLkV4dGVuZHM7XHJcblxyXG4gICAgICAgIGRlbGV0ZSBkZWZpbml0aW9uLkV4dGVuZHM7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBpbml0aWFsaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBHcmFiIHRoZSBtaXhpbnMsIGlmIHRoZXkgYXJlIHNwZWNpZmllZC4uLlxyXG4gICAgdmFyIG1peGlucyA9IG51bGw7XHJcblxyXG4gICAgaWYgKGRlZmluaXRpb24uTWl4aW5zKVxyXG4gICAge1xyXG4gICAgICAgIG1peGlucyA9IGRlZmluaXRpb24uTWl4aW5zO1xyXG4gICAgICAgIGRlbGV0ZSBkZWZpbml0aW9uLk1peGlucztcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRmlyc3QsIG1peGluIGlmIHdlIGNhbi5cclxuICAgIG1peGluKGluaXRpYWxpemUsIG1peGlucyk7XHJcblxyXG4gICAgLy8gIE5vdyB3ZSBncmFiIHRoZSBhY3R1YWwgZGVmaW5pdGlvbiB3aGljaCBkZWZpbmVzIHRoZSBvdmVycmlkZXMuXHJcbiAgICBleHRlbmQoaW5pdGlhbGl6ZSwgZGVmaW5pdGlvbiwgdHJ1ZSwgRXh0ZW5kcyk7XHJcblxyXG4gICAgcmV0dXJuIGluaXRpYWxpemU7XHJcbn1cclxuXHJcbkNsYXNzLmV4dGVuZCA9IGV4dGVuZDtcclxuQ2xhc3MubWl4aW4gPSBtaXhpbjtcclxuQ2xhc3MuaWdub3JlRmluYWxzID0gZmFsc2U7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9DbGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRklMRV9DT05TVCA9IHtcclxuXHJcbiAgICBMT0FERVJfSURMRTogMCxcclxuICAgIExPQURFUl9MT0FESU5HOiAxLFxyXG4gICAgTE9BREVSX1BST0NFU1NJTkc6IDIsXHJcbiAgICBMT0FERVJfQ09NUExFVEU6IDMsXHJcbiAgICBMT0FERVJfREVTVFJPWUVEOiA0LFxyXG5cclxuICAgIEZJTEVfUEVORElORzogNSwgICAgICAvLyBmaWxlIGlzIGluIHRoZSBsb2FkIHF1ZXVlIGJ1dCBub3QgeWV0IHN0YXJ0ZWRcclxuICAgIEZJTEVfTE9BRElORzogNiwgICAgICAvLyBmaWxlIGhhcyBiZWVuIHN0YXJ0ZWQgdG8gbG9hZCBieSB0aGUgbG9hZGVyIChvbkxvYWQgY2FsbGVkKVxyXG4gICAgRklMRV9MT0FERUQ6IDcsICAgICAgIC8vIGZpbGUgaGFzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGF3YWl0aW5nIHByb2Nlc3NpbmdcclxuICAgIEZJTEVfRkFJTEVEOiA4LCAgICAgICAvLyBmaWxlIGZhaWxlZCB0byBsb2FkXHJcbiAgICBGSUxFX1BST0NFU1NJTkc6IDksICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcclxuICAgIEZJTEVfV0FJVElOR19MSU5LRklMRTogMTAsICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcclxuICAgIEZJTEVfRVJST1JFRDogMTEsICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcclxuICAgIEZJTEVfQ09NUExFVEU6IDEyLCAgICAgLy8gZmlsZSBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZ1xyXG4gICAgRklMRV9ERVNUUk9ZRUQ6IDEzLCAgICAgLy8gZmlsZSBoYXMgYmVlbiBkZXN0cm95ZWRcclxuXHJcbiAgICBURVhUVVJFX0FUTEFTX0pTT05fQVJSQVk6IDIwLFxyXG4gICAgVEVYVFVSRV9BVExBU19KU09OX0hBU0g6IDIxXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGSUxFX0NPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XHJcbiovXHJcblxyXG52YXIgR2V0Qm90dG9tID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHJldHVybiAoZ2FtZU9iamVjdC55ICsgZ2FtZU9iamVjdC5oZWlnaHQpIC0gKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5hbmNob3JZKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qm90dG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvR2V0Qm90dG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgbGVmdCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB4IC0gb2Zmc2V0WGAuXHJcbipcclxuKiBAcHJvcGVydHkge251bWJlcn0gbGVmdFxyXG4qL1xyXG5cclxudmFyIEdldExlZnQgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxue1xyXG4gICAgcmV0dXJuIGdhbWVPYmplY3QueCAtIChnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5hbmNob3JYKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0TGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYm91bmRzL0dldExlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XHJcbiovXHJcblxyXG52YXIgR2V0UmlnaHQgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxue1xyXG4gICAgcmV0dXJuIChnYW1lT2JqZWN0LnggKyBnYW1lT2JqZWN0LndpZHRoKSAtIChnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5hbmNob3JYKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UmlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2JvdW5kcy9HZXRSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeSAtIG9mZnNldFlgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IHRvcFxyXG4qL1xyXG5cclxudmFyIEdldFRvcCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdC55IC0gKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5hbmNob3JZKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VG9wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvR2V0VG9wLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgbGVmdCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB4IC0gb2Zmc2V0WGAuXHJcbipcclxuKiBAcHJvcGVydHkge251bWJlcn0gbGVmdFxyXG4qL1xyXG5cclxudmFyIFNldEJvdHRvbSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB2YWx1ZSlcclxue1xyXG4gICAgZ2FtZU9iamVjdC55ID0gKHZhbHVlIC0gZ2FtZU9iamVjdC5oZWlnaHQpICsgKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5hbmNob3JZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0Qm90dG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvU2V0Qm90dG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgbGVmdCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB4IC0gb2Zmc2V0WGAuXHJcbipcclxuKiBAcHJvcGVydHkge251bWJlcn0gbGVmdFxyXG4qL1xyXG5cclxudmFyIFNldExlZnQgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgdmFsdWUpXHJcbntcclxuICAgIGdhbWVPYmplY3QueCA9IHZhbHVlICsgKGdhbWVPYmplY3Qud2lkdGggKiBnYW1lT2JqZWN0LmFuY2hvclgpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRMZWZ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvU2V0TGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeCAtIG9mZnNldFhgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcclxuKi9cclxuXHJcbnZhciBTZXRSaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB2YWx1ZSlcclxue1xyXG4gICAgZ2FtZU9iamVjdC54ID0gKHZhbHVlIC0gZ2FtZU9iamVjdC53aWR0aCkgKyAoZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3QuYW5jaG9yWCk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFJpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvU2V0UmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHkgLSBvZmZzZXRZYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3BcclxuKi9cclxuXHJcbnZhciBTZXRUb3AgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgdmFsdWUpXHJcbntcclxuICAgIGdhbWVPYmplY3QueSA9IHZhbHVlICsgKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5hbmNob3JZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0VG9wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvU2V0VG9wLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvT1MuanMiLCJ2YXIgT1MgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZGVza3RvcCAtIElzIHJ1bm5pbmcgb24gYSBkZXNrdG9wP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGRlc2t0b3A6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlYkFwcCAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgYXMgYSBXZWJBcHAsIGkuZS4gd2l0aGluIGEgV2ViVmlld1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdlYkFwcDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaU9TIC0gSXMgcnVubmluZyBvbiBpT1M/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgaU9TOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGlPU1ZlcnNpb24gLSBJZiBydW5uaW5nIGluIGlPUyB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgaU9TVmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpUGhvbmUgLSBJcyBydW5uaW5nIG9uIGlQaG9uZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBpUGhvbmU6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlQYWQgLSBJcyBydW5uaW5nIG9uIGlQYWQ/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgaVBhZDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29jb29uSlMgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIENvY29vbkpTP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNvY29vbkpTOiBmYWxzZSxcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29jb29uSlNBcHAgLSBJcyB0aGlzIGdhbWUgcnVubmluZyB3aXRoIENvY29vbkpTLkFwcD9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjb2Nvb25KU0FwcDogZmFsc2UsXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvcmRvdmEgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIEFwYWNoZSBDb3Jkb3ZhP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNvcmRvdmE6IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBub2RlIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBOb2RlLmpzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG5vZGU6IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBub2RlV2Via2l0IC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBOb2RlLVdlYmtpdD9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBub2RlV2Via2l0OiBmYWxzZSxcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZWxlY3Ryb24gLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIEdpdEh1YiBFbGVjdHJvbj9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBlbGVjdHJvbjogZmFsc2UsXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVqZWN0YSAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgRWplY3RhP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGVqZWN0YTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY3Jvc3N3YWxrIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciB0aGUgSW50ZWwgQ3Jvc3N3YWxrIFhESz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjcm9zc3dhbGs6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFuZHJvaWQgLSBJcyBydW5uaW5nIG9uIGFuZHJvaWQ/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgYW5kcm9pZDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2hyb21lT1MgLSBJcyBydW5uaW5nIG9uIGNocm9tZU9TP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNocm9tZU9TOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBsaW51eCAtIElzIHJ1bm5pbmcgb24gbGludXg/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbGludXg6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1hY09TIC0gSXMgcnVubmluZyBvbiBtYWNPUz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtYWNPUzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2luZG93cyAtIElzIHJ1bm5pbmcgb24gd2luZG93cz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3aW5kb3dzOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3aW5kb3dzUGhvbmUgLSBJcyBydW5uaW5nIG9uIGEgV2luZG93cyBQaG9uZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3aW5kb3dzUGhvbmU6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpdGEgLSBJcyBydW5uaW5nIG9uIGEgUGxheVN0YXRpb24gVml0YT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB2aXRhOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBraW5kbGUgLSBJcyBydW5uaW5nIG9uIGFuIEFtYXpvbiBLaW5kbGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAga2luZGxlOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBpeGVsUmF0aW8gLSBQaXhlbFJhdGlvIG9mIHRoZSBob3N0IGRldmljZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBwaXhlbFJhdGlvOiAxXHJcblxyXG59O1xyXG5cclxuZnVuY3Rpb24gaW5pdCAoKVxyXG57XHJcbiAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG5cclxuICAgIGlmICgvV2luZG93cy8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1Mud2luZG93cyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvTWFjIE9TLy50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5tYWNPUyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvTGludXgvLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmxpbnV4ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9BbmRyb2lkLy50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5hbmRyb2lkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9pUFthb11kfGlQaG9uZS9pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmlPUyA9IHRydWU7XHJcbiAgICAgICAgKG5hdmlnYXRvci5hcHBWZXJzaW9uKS5tYXRjaCgvT1MgKFxcZCspLyk7XHJcbiAgICAgICAgT1MuaU9TVmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL0tpbmRsZS8udGVzdCh1YSkgfHwgKC9cXGJLRltBLVpdW0EtWl0rLykudGVzdCh1YSkgfHwgKC9TaWxrLipNb2JpbGUgU2FmYXJpLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1Mua2luZGxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIE5PVCBkZXRlY3QgZWFybHkgZ2VuZXJhdGlvbnMgb2YgS2luZGxlIEZpcmUsIEkgdGhpbmsgdGhlcmUgaXMgbm8gcmVsaWFibGUgd2F5Li4uXHJcbiAgICAgICAgLy8gRS5nLiBcIk1vemlsbGEvNS4wIChNYWNpbnRvc2g7IFU7IEludGVsIE1hYyBPUyBYIDEwXzZfMzsgZW4tdXM7IFNpbGsvMS4xLjAtODApIEFwcGxlV2ViS2l0LzUzMy4xNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNS4wIFNhZmFyaS81MzMuMTYgU2lsay1BY2NlbGVyYXRlZD10cnVlXCJcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9Dck9TLy50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5jaHJvbWVPUyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoL1BsYXlzdGF0aW9uIFZpdGEvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy52aXRhID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoL1dpbmRvd3MgUGhvbmUvaS50ZXN0KHVhKSB8fCAoL0lFTW9iaWxlL2kpLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmFuZHJvaWQgPSBmYWxzZTtcclxuICAgICAgICBPUy5pT1MgPSBmYWxzZTtcclxuICAgICAgICBPUy5tYWNPUyA9IGZhbHNlO1xyXG4gICAgICAgIE9TLndpbmRvd3MgPSB0cnVlO1xyXG4gICAgICAgIE9TLndpbmRvd3NQaG9uZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNpbGsgPSAoL1NpbGsvKS50ZXN0KHVhKTtcclxuXHJcbiAgICBpZiAoT1Mud2luZG93cyB8fCBPUy5tYWNPUyB8fCAoT1MubGludXggJiYgIXNpbGspIHx8IE9TLmNocm9tZU9TKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmRlc2t0b3AgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBXaW5kb3dzIFBob25lIC8gVGFibGUgcmVzZXRcclxuICAgIGlmIChPUy53aW5kb3dzUGhvbmUgfHwgKCgvV2luZG93cyBOVC9pLnRlc3QodWEpKSAmJiAoL1RvdWNoL2kudGVzdCh1YSkpKSlcclxuICAgIHtcclxuICAgICAgICBPUy5kZXNrdG9wID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFdlYkFwcCBtb2RlIGluIGlPU1xyXG4gICAgaWYgKG5hdmlnYXRvci5zdGFuZGFsb25lKVxyXG4gICAge1xyXG4gICAgICAgIE9TLndlYkFwcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh3aW5kb3cuY29yZG92YSAhPT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmNvcmRvdmEgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnKSlcclxuICAgIHtcclxuICAgICAgICBPUy5ub2RlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKE9TLm5vZGUgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgPT09ICdvYmplY3QnKVxyXG4gICAge1xyXG4gICAgICAgIE9TLm5vZGVXZWJraXQgPSAhIXByb2Nlc3MudmVyc2lvbnNbJ25vZGUtd2Via2l0J107XHJcbiAgICAgICAgXHJcbiAgICAgICAgT1MuZWxlY3Ryb24gPSAhIXByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb247XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChuYXZpZ2F0b3IuaXNDb2Nvb25KUylcclxuICAgIHtcclxuICAgICAgICBPUy5jb2Nvb25KUyA9IHRydWU7XHJcblxyXG4gICAgICAgIHRyeVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgT1MuY29jb29uSlNBcHAgPSAodHlwZW9mIENvY29vbkpTICE9PSAndW5kZWZpbmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE9TLmNvY29vbkpTQXBwID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh3aW5kb3cuZWplY3RhICE9PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuZWplY3RhID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoKC9Dcm9zc3dhbGsvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5jcm9zc3dhbGsgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIE9TLmlQaG9uZSA9IHVhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaXBob25lJykgIT09IC0xO1xyXG4gICAgT1MuaVBhZCA9IHVhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaXBhZCcpICE9PSAtMTtcclxuXHJcbiAgICBPUy5waXhlbFJhdGlvID0gd2luZG93WydkZXZpY2VQaXhlbFJhdGlvJ10gfHwgMTtcclxuXHJcbiAgICByZXR1cm4gT1M7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvT1MuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLkNvbXBvc2l0ZWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgY29tcG9zaXRlIGJvZGllcy5cclxuKiBBIGNvbXBvc2l0ZSBib2R5IGlzIGEgY29sbGVjdGlvbiBvZiBgTWF0dGVyLkJvZHlgLCBgTWF0dGVyLkNvbnN0cmFpbnRgIGFuZCBvdGhlciBgTWF0dGVyLkNvbXBvc2l0ZWAsIHRoZXJlZm9yZSBjb21wb3NpdGVzIGZvcm0gYSB0cmVlIHN0cnVjdHVyZS5cclxuKiBJdCBpcyBpbXBvcnRhbnQgdG8gdXNlIHRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgdG8gbW9kaWZ5IGNvbXBvc2l0ZXMsIHJhdGhlciB0aGFuIGRpcmVjdGx5IG1vZGlmeWluZyB0aGVpciBwcm9wZXJ0aWVzLlxyXG4qIE5vdGUgdGhhdCB0aGUgYE1hdHRlci5Xb3JsZGAgb2JqZWN0IGlzIGFsc28gYSB0eXBlIG9mIGBNYXR0ZXIuQ29tcG9zaXRlYCBhbmQgYXMgc3VjaCBhbGwgY29tcG9zaXRlIG1ldGhvZHMgaGVyZSBjYW4gYWxzbyBvcGVyYXRlIG9uIGEgYE1hdHRlci5Xb3JsZGAuXHJcbipcclxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxyXG4qXHJcbiogQGNsYXNzIENvbXBvc2l0ZVxyXG4qL1xyXG5cclxudmFyIENvbXBvc2l0ZSA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGU7XHJcblxyXG52YXIgRXZlbnRzID0gcmVxdWlyZSgnLi4vY29yZS9FdmVudHMnKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcbnZhciBCb2R5ID0gcmVxdWlyZSgnLi9Cb2R5Jyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBvc2l0ZS4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBTZWUgdGhlIHByb3Blcml0ZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEBwYXJhbSB7fSBbb3B0aW9uc11cclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbW1vbi5leHRlbmQoeyBcclxuICAgICAgICAgICAgaWQ6IENvbW1vbi5uZXh0SWQoKSxcclxuICAgICAgICAgICAgdHlwZTogJ2NvbXBvc2l0ZScsXHJcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICAgICAgaXNNb2RpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGJvZGllczogW10sIFxyXG4gICAgICAgICAgICBjb25zdHJhaW50czogW10sIFxyXG4gICAgICAgICAgICBjb21wb3NpdGVzOiBbXSxcclxuICAgICAgICAgICAgbGFiZWw6ICdDb21wb3NpdGUnLFxyXG4gICAgICAgICAgICBwbHVnaW46IHt9XHJcbiAgICAgICAgfSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY29tcG9zaXRlJ3MgYGlzTW9kaWZpZWRgIGZsYWcuIFxyXG4gICAgICogSWYgYHVwZGF0ZVBhcmVudHNgIGlzIHRydWUsIGFsbCBwYXJlbnRzIHdpbGwgYmUgc2V0IChkZWZhdWx0OiBmYWxzZSkuXHJcbiAgICAgKiBJZiBgdXBkYXRlQ2hpbGRyZW5gIGlzIHRydWUsIGFsbCBjaGlsZHJlbiB3aWxsIGJlIHNldCAoZGVmYXVsdDogZmFsc2UpLlxyXG4gICAgICogQG1ldGhvZCBzZXRNb2RpZmllZFxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc01vZGlmaWVkXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGVQYXJlbnRzPWZhbHNlXVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlQ2hpbGRyZW49ZmFsc2VdXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgaXNNb2RpZmllZCwgdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pIHtcclxuICAgICAgICBjb21wb3NpdGUuaXNNb2RpZmllZCA9IGlzTW9kaWZpZWQ7XHJcblxyXG4gICAgICAgIGlmICh1cGRhdGVQYXJlbnRzICYmIGNvbXBvc2l0ZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZS5wYXJlbnQsIGlzTW9kaWZpZWQsIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh1cGRhdGVDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZENvbXBvc2l0ZSA9IGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNoaWxkQ29tcG9zaXRlLCBpc01vZGlmaWVkLCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJpYyBhZGQgZnVuY3Rpb24uIEFkZHMgb25lIG9yIG1hbnkgYm9keShzKSwgY29uc3RyYWludChzKSBvciBhIGNvbXBvc2l0ZShzKSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxyXG4gICAgICogVHJpZ2dlcnMgYGJlZm9yZUFkZGAgYW5kIGBhZnRlckFkZGAgZXZlbnRzIG9uIHRoZSBgY29tcG9zaXRlYC5cclxuICAgICAqIEBtZXRob2QgYWRkXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge30gb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgb2JqZWN0cyBhZGRlZFxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUuYWRkID0gZnVuY3Rpb24oY29tcG9zaXRlLCBvYmplY3QpIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IFtdLmNvbmNhdChvYmplY3QpO1xyXG5cclxuICAgICAgICBFdmVudHMudHJpZ2dlcihjb21wb3NpdGUsICdiZWZvcmVBZGQnLCB7IG9iamVjdDogb2JqZWN0IH0pO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IG9iamVjdHNbaV07XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdib2R5JzpcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgYWRkaW5nIGNvbXBvdW5kIHBhcnRzXHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLnBhcmVudCAhPT0gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ0NvbXBvc2l0ZS5hZGQ6IHNraXBwZWQgYWRkaW5nIGEgY29tcG91bmQgYm9keSBwYXJ0ICh5b3UgbXVzdCBhZGQgaXRzIHBhcmVudCBpbnN0ZWFkKScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KGNvbXBvc2l0ZSwgb2JqKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjb21wb3NpdGUnOlxyXG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbXBvc2l0ZShjb21wb3NpdGUsIG9iaik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbW91c2VDb25zdHJhaW50JzpcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqLmNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBFdmVudHMudHJpZ2dlcihjb21wb3NpdGUsICdhZnRlckFkZCcsIHsgb2JqZWN0OiBvYmplY3QgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJpYyByZW1vdmUgZnVuY3Rpb24uIFJlbW92ZXMgb25lIG9yIG1hbnkgYm9keShzKSwgY29uc3RyYWludChzKSBvciBhIGNvbXBvc2l0ZShzKSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxyXG4gICAgICogT3B0aW9uYWxseSBzZWFyY2hpbmcgaXRzIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LlxyXG4gICAgICogVHJpZ2dlcnMgYGJlZm9yZVJlbW92ZWAgYW5kIGBhZnRlclJlbW92ZWAgZXZlbnRzIG9uIHRoZSBgY29tcG9zaXRlYC5cclxuICAgICAqIEBtZXRob2QgcmVtb3ZlXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge30gb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWVwPWZhbHNlXVxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIG9iamVjdHMgcmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUucmVtb3ZlID0gZnVuY3Rpb24oY29tcG9zaXRlLCBvYmplY3QsIGRlZXApIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IFtdLmNvbmNhdChvYmplY3QpO1xyXG5cclxuICAgICAgICBFdmVudHMudHJpZ2dlcihjb21wb3NpdGUsICdiZWZvcmVSZW1vdmUnLCB7IG9iamVjdDogb2JqZWN0IH0pO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IG9iamVjdHNbaV07XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdib2R5JzpcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5KGNvbXBvc2l0ZSwgb2JqLCBkZWVwKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqLCBkZWVwKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjb21wb3NpdGUnOlxyXG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZShjb21wb3NpdGUsIG9iaiwgZGVlcCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbW91c2VDb25zdHJhaW50JzpcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqLmNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBFdmVudHMudHJpZ2dlcihjb21wb3NpdGUsICdhZnRlclJlbW92ZScsIHsgb2JqZWN0OiBvYmplY3QgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGNvbXBvc2l0ZSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgYWRkQ29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlQVxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZUJcclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZUEgd2l0aCB0aGUgb2JqZWN0cyBmcm9tIGNvbXBvc2l0ZUIgYWRkZWRcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLmFkZENvbXBvc2l0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZUEsIGNvbXBvc2l0ZUIpIHtcclxuICAgICAgICBjb21wb3NpdGVBLmNvbXBvc2l0ZXMucHVzaChjb21wb3NpdGVCKTtcclxuICAgICAgICBjb21wb3NpdGVCLnBhcmVudCA9IGNvbXBvc2l0ZUE7XHJcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZUEsIHRydWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlQTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9zaXRlIGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgYW5kIG9wdGlvbmFsbHkgc2VhcmNoaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZUFcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVCXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWVwPWZhbHNlXVxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlQSB3aXRoIHRoZSBjb21wb3NpdGUgcmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUucmVtb3ZlQ29tcG9zaXRlID0gZnVuY3Rpb24oY29tcG9zaXRlQSwgY29tcG9zaXRlQiwgZGVlcCkge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IENvbW1vbi5pbmRleE9mKGNvbXBvc2l0ZUEuY29tcG9zaXRlcywgY29tcG9zaXRlQik7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQ29tcG9zaXRlQXQoY29tcG9zaXRlQSwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlQSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlZXApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGVBLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZShjb21wb3NpdGVBLmNvbXBvc2l0ZXNbaV0sIGNvbXBvc2l0ZUIsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlQTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9zaXRlIGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbXBvc2l0ZUF0XHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBjb21wb3NpdGUgcmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUucmVtb3ZlQ29tcG9zaXRlQXQgPSBmdW5jdGlvbihjb21wb3NpdGUsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgY29tcG9zaXRlLmNvbXBvc2l0ZXMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcclxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgYm9keSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgYWRkQm9keVxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgYm9keSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUuYWRkQm9keSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgYm9keSkge1xyXG4gICAgICAgIGNvbXBvc2l0ZS5ib2RpZXMucHVzaChib2R5KTtcclxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgYm9keSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUsIGFuZCBvcHRpb25hbGx5IHNlYXJjaGluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCByZW1vdmVCb2R5XHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgYm9keSByZW1vdmVkXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBib2R5LCBkZWVwKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gQ29tbW9uLmluZGV4T2YoY29tcG9zaXRlLmJvZGllcywgYm9keSk7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQm9keUF0KGNvbXBvc2l0ZSwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVlcCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5KGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldLCBib2R5LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgYm9keSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCByZW1vdmVCb2R5QXRcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGJvZHkgcmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUucmVtb3ZlQm9keUF0ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBwb3NpdGlvbikge1xyXG4gICAgICAgIGNvbXBvc2l0ZS5ib2RpZXMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcclxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgY29uc3RyYWludCB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgYWRkQ29uc3RyYWludFxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50fSBjb25zdHJhaW50XHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgY29uc3RyYWludCBhZGRlZFxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgY29uc3RyYWludCkge1xyXG4gICAgICAgIGNvbXBvc2l0ZS5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjb25zdHJhaW50IGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgYW5kIG9wdGlvbmFsbHkgc2VhcmNoaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBjb25zdHJhaW50IHJlbW92ZWRcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnQgPSBmdW5jdGlvbihjb21wb3NpdGUsIGNvbnN0cmFpbnQsIGRlZXApIHtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBDb21tb24uaW5kZXhPZihjb21wb3NpdGUuY29uc3RyYWludHMsIGNvbnN0cmFpbnQpO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gLTEpIHtcclxuICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnRBdChjb21wb3NpdGUsIHBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWVwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnQoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0sIGNvbnN0cmFpbnQsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBib2R5IGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRBdFxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgY29uc3RyYWludCByZW1vdmVkXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50QXQgPSBmdW5jdGlvbihjb21wb3NpdGUsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgY29tcG9zaXRlLmNvbnN0cmFpbnRzLnNwbGljZShwb3NpdGlvbiwgMSk7XHJcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgYm9kaWVzLCBjb25zdHJhaW50cyBhbmQgY29tcG9zaXRlcyBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXHJcbiAgICAgKiBPcHRpb25hbGx5IGNsZWFyaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cclxuICAgICAqIEBtZXRob2QgY2xlYXJcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLmNsZWFyID0gZnVuY3Rpb24oY29tcG9zaXRlLCBrZWVwU3RhdGljLCBkZWVwKSB7XHJcbiAgICAgICAgaWYgKGRlZXApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuY2xlYXIoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0sIGtlZXBTdGF0aWMsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChrZWVwU3RhdGljKSB7XHJcbiAgICAgICAgICAgIGNvbXBvc2l0ZS5ib2RpZXMgPSBjb21wb3NpdGUuYm9kaWVzLmZpbHRlcihmdW5jdGlvbihib2R5KSB7IHJldHVybiBib2R5LmlzU3RhdGljOyB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb21wb3NpdGUuYm9kaWVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb21wb3NpdGUuY29uc3RyYWludHMubGVuZ3RoID0gMDtcclxuICAgICAgICBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIGFsbCBib2RpZXMgaW4gaXRzIGNoaWxkcmVuLCByZWN1cnNpdmVseS5cclxuICAgICAqIEBtZXRob2QgYWxsQm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcmV0dXJuIHtib2R5W119IEFsbCB0aGUgYm9kaWVzXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5hbGxCb2RpZXMgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gW10uY29uY2F0KGNvbXBvc2l0ZS5ib2RpZXMpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBib2RpZXMgPSBib2RpZXMuY29uY2F0KENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0pKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJvZGllcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBjb25zdHJhaW50cyBpbiB0aGUgZ2l2ZW4gY29tcG9zaXRlLCBpbmNsdWRpbmcgYWxsIGNvbnN0cmFpbnRzIGluIGl0cyBjaGlsZHJlbiwgcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBAbWV0aG9kIGFsbENvbnN0cmFpbnRzXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcmV0dXJuIHtjb25zdHJhaW50W119IEFsbCB0aGUgY29uc3RyYWludHNcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzID0gZnVuY3Rpb24oY29tcG9zaXRlKSB7XHJcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gW10uY29uY2F0KGNvbXBvc2l0ZS5jb25zdHJhaW50cyk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyhjb21wb3NpdGUuY29tcG9zaXRlc1tpXSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgY29tcG9zaXRlcyBpbiB0aGUgZ2l2ZW4gY29tcG9zaXRlLCBpbmNsdWRpbmcgYWxsIGNvbXBvc2l0ZXMgaW4gaXRzIGNoaWxkcmVuLCByZWN1cnNpdmVseS5cclxuICAgICAqIEBtZXRob2QgYWxsQ29tcG9zaXRlc1xyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlW119IEFsbCB0aGUgY29tcG9zaXRlc1xyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSkge1xyXG4gICAgICAgIHZhciBjb21wb3NpdGVzID0gW10uY29uY2F0KGNvbXBvc2l0ZS5jb21wb3NpdGVzKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgY29tcG9zaXRlcyA9IGNvbXBvc2l0ZXMuY29uY2F0KENvbXBvc2l0ZS5hbGxDb21wb3NpdGVzKGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaGVzIHRoZSBjb21wb3NpdGUgcmVjdXJzaXZlbHkgZm9yIGFuIG9iamVjdCBtYXRjaGluZyB0aGUgdHlwZSBhbmQgaWQgc3VwcGxpZWQsIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICAgICogQG1ldGhvZCBnZXRcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcclxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHJlcXVlc3RlZCBvYmplY3QsIGlmIGZvdW5kXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5nZXQgPSBmdW5jdGlvbihjb21wb3NpdGUsIGlkLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdHMsXHJcbiAgICAgICAgICAgIG9iamVjdDtcclxuXHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnYm9keSc6XHJcbiAgICAgICAgICAgIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxyXG4gICAgICAgICAgICBvYmplY3RzID0gQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKGNvbXBvc2l0ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2NvbXBvc2l0ZSc6XHJcbiAgICAgICAgICAgIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyhjb21wb3NpdGUpLmNvbmNhdChjb21wb3NpdGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghb2JqZWN0cylcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIG9iamVjdCA9IG9iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkgeyBcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5pZC50b1N0cmluZygpID09PSBpZC50b1N0cmluZygpOyBcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9iamVjdC5sZW5ndGggPT09IDAgPyBudWxsIDogb2JqZWN0WzBdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBnaXZlbiBvYmplY3QocykgZnJvbSBjb21wb3NpdGVBIHRvIGNvbXBvc2l0ZUIgKGVxdWFsIHRvIGEgcmVtb3ZlIGZvbGxvd2VkIGJ5IGFuIGFkZCkuXHJcbiAgICAgKiBAbWV0aG9kIG1vdmVcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlQX0gY29tcG9zaXRlQVxyXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gb2JqZWN0c1xyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGVCfSBjb21wb3NpdGVCXHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFJldHVybnMgY29tcG9zaXRlQVxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUubW92ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZUEsIG9iamVjdHMsIGNvbXBvc2l0ZUIpIHtcclxuICAgICAgICBDb21wb3NpdGUucmVtb3ZlKGNvbXBvc2l0ZUEsIG9iamVjdHMpO1xyXG4gICAgICAgIENvbXBvc2l0ZS5hZGQoY29tcG9zaXRlQiwgb2JqZWN0cyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXNzaWducyBuZXcgaWRzIGZvciBhbGwgb2JqZWN0cyBpbiB0aGUgY29tcG9zaXRlLCByZWN1cnNpdmVseS5cclxuICAgICAqIEBtZXRob2QgcmViYXNlXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFJldHVybnMgY29tcG9zaXRlXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5yZWJhc2UgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyhjb21wb3NpdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KENvbXBvc2l0ZS5hbGxDb21wb3NpdGVzKGNvbXBvc2l0ZSkpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgb2JqZWN0c1tpXS5pZCA9IENvbW1vbi5uZXh0SWQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGVzIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29tcG9zaXRlIGJ5IGEgZ2l2ZW4gdmVjdG9yIHJlbGF0aXZlIHRvIHRoZWlyIGN1cnJlbnQgcG9zaXRpb25zLCBcclxuICAgICAqIHdpdGhvdXQgaW1wYXJ0aW5nIGFueSB2ZWxvY2l0eS5cclxuICAgICAqIEBtZXRob2QgdHJhbnNsYXRlXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdHJhbnNsYXRpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW3JlY3Vyc2l2ZT10cnVlXVxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUudHJhbnNsYXRlID0gZnVuY3Rpb24oY29tcG9zaXRlLCB0cmFuc2xhdGlvbiwgcmVjdXJzaXZlKSB7XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHJlY3Vyc2l2ZSA/IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKSA6IGNvbXBvc2l0ZS5ib2RpZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIEJvZHkudHJhbnNsYXRlKGJvZGllc1tpXSwgdHJhbnNsYXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZXMgYWxsIGNoaWxkcmVuIGluIHRoZSBjb21wb3NpdGUgYnkgYSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgZ2l2ZW4gcG9pbnQsIHdpdGhvdXQgaW1wYXJ0aW5nIGFueSBhbmd1bGFyIHZlbG9jaXR5LlxyXG4gICAgICogQG1ldGhvZCByb3RhdGVcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvblxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtyZWN1cnNpdmU9dHJ1ZV1cclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLnJvdGF0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgcm90YXRpb24sIHBvaW50LCByZWN1cnNpdmUpIHtcclxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3Mocm90YXRpb24pLFxyXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihyb3RhdGlvbiksXHJcbiAgICAgICAgICAgIGJvZGllcyA9IHJlY3Vyc2l2ZSA/IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKSA6IGNvbXBvc2l0ZS5ib2RpZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgZHggPSBib2R5LnBvc2l0aW9uLnggLSBwb2ludC54LFxyXG4gICAgICAgICAgICAgICAgZHkgPSBib2R5LnBvc2l0aW9uLnkgLSBwb2ludC55O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwge1xyXG4gICAgICAgICAgICAgICAgeDogcG9pbnQueCArIChkeCAqIGNvcyAtIGR5ICogc2luKSxcclxuICAgICAgICAgICAgICAgIHk6IHBvaW50LnkgKyAoZHggKiBzaW4gKyBkeSAqIGNvcylcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBCb2R5LnJvdGF0ZShib2R5LCByb3RhdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29tcG9zaXRlLCBpbmNsdWRpbmcgdXBkYXRpbmcgcGh5c2ljYWwgcHJvcGVydGllcyAobWFzcywgYXJlYSwgYXhlcywgaW5lcnRpYSksIGZyb20gYSB3b3JsZC1zcGFjZSBwb2ludC5cclxuICAgICAqIEBtZXRob2Qgc2NhbGVcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVlcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxyXG4gICAgICogQHBhcmFtIHtib29sfSBbcmVjdXJzaXZlPXRydWVdXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5zY2FsZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgc2NhbGVYLCBzY2FsZVksIHBvaW50LCByZWN1cnNpdmUpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gcmVjdXJzaXZlID8gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpIDogY29tcG9zaXRlLmJvZGllcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXHJcbiAgICAgICAgICAgICAgICBkeCA9IGJvZHkucG9zaXRpb24ueCAtIHBvaW50LngsXHJcbiAgICAgICAgICAgICAgICBkeSA9IGJvZHkucG9zaXRpb24ueSAtIHBvaW50Lnk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB7XHJcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54ICsgZHggKiBzY2FsZVgsXHJcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55ICsgZHkgKiBzY2FsZVlcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBCb2R5LnNjYWxlKGJvZHksIHNjYWxlWCwgc2NhbGVZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICpcclxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCB3aGVuIGEgY2FsbCB0byBgQ29tcG9zaXRlLmFkZGAgaXMgbWFkZSwgYmVmb3JlIG9iamVjdHMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYmVmb3JlQWRkXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm9iamVjdCBUaGUgb2JqZWN0KHMpIHRvIGJlIGFkZGVkIChtYXkgYmUgYSBzaW5nbGUgYm9keSwgY29uc3RyYWludCwgY29tcG9zaXRlIG9yIGEgbWl4ZWQgYXJyYXkgb2YgdGhlc2UpXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgd2hlbiBhIGNhbGwgdG8gYENvbXBvc2l0ZS5hZGRgIGlzIG1hZGUsIGFmdGVyIG9iamVjdHMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYWZ0ZXJBZGRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQub2JqZWN0IFRoZSBvYmplY3QocykgdGhhdCBoYXZlIGJlZW4gYWRkZWQgKG1heSBiZSBhIHNpbmdsZSBib2R5LCBjb25zdHJhaW50LCBjb21wb3NpdGUgb3IgYSBtaXhlZCBhcnJheSBvZiB0aGVzZSlcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCB3aGVuIGEgY2FsbCB0byBgQ29tcG9zaXRlLnJlbW92ZWAgaXMgbWFkZSwgYmVmb3JlIG9iamVjdHMgaGF2ZSBiZWVuIHJlbW92ZWQuXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBiZWZvcmVSZW1vdmVcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQub2JqZWN0IFRoZSBvYmplY3QocykgdG8gYmUgcmVtb3ZlZCAobWF5IGJlIGEgc2luZ2xlIGJvZHksIGNvbnN0cmFpbnQsIGNvbXBvc2l0ZSBvciBhIG1peGVkIGFycmF5IG9mIHRoZXNlKVxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIHdoZW4gYSBjYWxsIHRvIGBDb21wb3NpdGUucmVtb3ZlYCBpcyBtYWRlLCBhZnRlciBvYmplY3RzIGhhdmUgYmVlbiByZW1vdmVkLlxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYWZ0ZXJSZW1vdmVcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQub2JqZWN0IFRoZSBvYmplY3QocykgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCAobWF5IGJlIGEgc2luZ2xlIGJvZHksIGNvbnN0cmFpbnQsIGNvbXBvc2l0ZSBvciBhIG1peGVkIGFycmF5IG9mIHRoZXNlKVxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLypcclxuICAgICpcclxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxyXG4gICAgKlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdW5pcXVlbHkgaWRlbnRpZnlpbmcgbnVtYmVyIGdlbmVyYXRlZCBpbiBgQ29tcG9zaXRlLmNyZWF0ZWAgYnkgYENvbW1vbi5uZXh0SWRgLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBpZFxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYFN0cmluZ2AgZGVub3RpbmcgdGhlIHR5cGUgb2Ygb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXHJcbiAgICAgKiBAdHlwZSBzdHJpbmdcclxuICAgICAqIEBkZWZhdWx0IFwiY29tcG9zaXRlXCJcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcmJpdHJhcnkgYFN0cmluZ2AgbmFtZSB0byBoZWxwIHRoZSB1c2VyIGlkZW50aWZ5IGFuZCBtYW5hZ2UgY29tcG9zaXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgbGFiZWxcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQGRlZmF1bHQgXCJDb21wb3NpdGVcIlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdGhhdCBzcGVjaWZpZXMgd2hldGhlciB0aGUgY29tcG9zaXRlIGhhcyBiZWVuIG1vZGlmaWVkIGR1cmluZyB0aGUgY3VycmVudCBzdGVwLlxyXG4gICAgICogTW9zdCBgTWF0dGVyLkNvbXBvc2l0ZWAgbWV0aG9kcyB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoaXMgZmxhZyB0byBgdHJ1ZWAgdG8gaW5mb3JtIHRoZSBlbmdpbmUgb2YgY2hhbmdlcyB0byBiZSBoYW5kbGVkLlxyXG4gICAgICogSWYgeW91IG5lZWQgdG8gY2hhbmdlIGl0IG1hbnVhbGx5LCB5b3Ugc2hvdWxkIHVzZSB0aGUgYENvbXBvc2l0ZS5zZXRNb2RpZmllZGAgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBpc01vZGlmaWVkXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYENvbXBvc2l0ZWAgdGhhdCBpcyB0aGUgcGFyZW50IG9mIHRoaXMgY29tcG9zaXRlLiBJdCBpcyBhdXRvbWF0aWNhbGx5IG1hbmFnZWQgYnkgdGhlIGBNYXR0ZXIuQ29tcG9zaXRlYCBtZXRob2RzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBwYXJlbnRcclxuICAgICAqIEB0eXBlIGNvbXBvc2l0ZVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBgQm9keWAgdGhhdCBhcmUgX2RpcmVjdF8gY2hpbGRyZW4gb2YgdGhpcyBjb21wb3NpdGUuXHJcbiAgICAgKiBUbyBhZGQgb3IgcmVtb3ZlIGJvZGllcyB5b3Ugc2hvdWxkIHVzZSBgQ29tcG9zaXRlLmFkZGAgYW5kIGBDb21wb3NpdGUucmVtb3ZlYCBtZXRob2RzIHJhdGhlciB0aGFuIGRpcmVjdGx5IG1vZGlmeWluZyB0aGlzIHByb3BlcnR5LlxyXG4gICAgICogSWYgeW91IHdpc2ggdG8gcmVjdXJzaXZlbHkgZmluZCBhbGwgZGVzY2VuZGFudHMsIHlvdSBzaG91bGQgdXNlIHRoZSBgQ29tcG9zaXRlLmFsbEJvZGllc2AgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBib2RpZXNcclxuICAgICAqIEB0eXBlIGJvZHlbXVxyXG4gICAgICogQGRlZmF1bHQgW11cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgYENvbnN0cmFpbnRgIHRoYXQgYXJlIF9kaXJlY3RfIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9zaXRlLlxyXG4gICAgICogVG8gYWRkIG9yIHJlbW92ZSBjb25zdHJhaW50cyB5b3Ugc2hvdWxkIHVzZSBgQ29tcG9zaXRlLmFkZGAgYW5kIGBDb21wb3NpdGUucmVtb3ZlYCBtZXRob2RzIHJhdGhlciB0aGFuIGRpcmVjdGx5IG1vZGlmeWluZyB0aGlzIHByb3BlcnR5LlxyXG4gICAgICogSWYgeW91IHdpc2ggdG8gcmVjdXJzaXZlbHkgZmluZCBhbGwgZGVzY2VuZGFudHMsIHlvdSBzaG91bGQgdXNlIHRoZSBgQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzYCBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXHJcbiAgICAgKiBAdHlwZSBjb25zdHJhaW50W11cclxuICAgICAqIEBkZWZhdWx0IFtdXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIGBDb21wb3NpdGVgIHRoYXQgYXJlIF9kaXJlY3RfIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9zaXRlLlxyXG4gICAgICogVG8gYWRkIG9yIHJlbW92ZSBjb21wb3NpdGVzIHlvdSBzaG91bGQgdXNlIGBDb21wb3NpdGUuYWRkYCBhbmQgYENvbXBvc2l0ZS5yZW1vdmVgIG1ldGhvZHMgcmF0aGVyIHRoYW4gZGlyZWN0bHkgbW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkuXHJcbiAgICAgKiBJZiB5b3Ugd2lzaCB0byByZWN1cnNpdmVseSBmaW5kIGFsbCBkZXNjZW5kYW50cywgeW91IHNob3VsZCB1c2UgdGhlIGBDb21wb3NpdGUuYWxsQ29tcG9zaXRlc2AgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBjb21wb3NpdGVzXHJcbiAgICAgKiBAdHlwZSBjb21wb3NpdGVbXVxyXG4gICAgICogQGRlZmF1bHQgW11cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gb2JqZWN0IHJlc2VydmVkIGZvciBzdG9yaW5nIHBsdWdpbi1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5cclxuICAgICAqIEB0eXBlIHt9XHJcbiAgICAgKi9cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvQ29tcG9zaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9ib2R5L0NvbXBvc2l0ZS5qcyIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLkV2ZW50c2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgdG8gZmlyZSBhbmQgbGlzdGVuIHRvIGV2ZW50cyBvbiBvdGhlciBvYmplY3RzLlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuKlxyXG4qIEBjbGFzcyBFdmVudHNcclxuKi9cclxuXHJcbnZhciBFdmVudHMgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRzO1xyXG5cclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4vQ29tbW9uJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gdGhlIGdpdmVuIG9iamVjdCdzIGBldmVudE5hbWVgLlxyXG4gICAgICogQG1ldGhvZCBvblxyXG4gICAgICogQHBhcmFtIHt9IG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZXNcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIEV2ZW50cy5vbiA9IGZ1bmN0aW9uKG9iamVjdCwgZXZlbnROYW1lcywgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgbmFtZXMgPSBldmVudE5hbWVzLnNwbGl0KCcgJyksXHJcbiAgICAgICAgICAgIG5hbWU7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xyXG4gICAgICAgICAgICBvYmplY3QuZXZlbnRzID0gb2JqZWN0LmV2ZW50cyB8fCB7fTtcclxuICAgICAgICAgICAgb2JqZWN0LmV2ZW50c1tuYW1lXSA9IG9iamVjdC5ldmVudHNbbmFtZV0gfHwgW107XHJcbiAgICAgICAgICAgIG9iamVjdC5ldmVudHNbbmFtZV0ucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gZXZlbnQgY2FsbGJhY2suIElmIG5vIGNhbGxiYWNrLCBjbGVhcnMgYWxsIGNhbGxiYWNrcyBpbiBgZXZlbnROYW1lc2AuIElmIG5vIGBldmVudE5hbWVzYCwgY2xlYXJzIGFsbCBldmVudHMuXHJcbiAgICAgKiBAbWV0aG9kIG9mZlxyXG4gICAgICogQHBhcmFtIHt9IG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZXNcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIEV2ZW50cy5vZmYgPSBmdW5jdGlvbihvYmplY3QsIGV2ZW50TmFtZXMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCFldmVudE5hbWVzKSB7XHJcbiAgICAgICAgICAgIG9iamVjdC5ldmVudHMgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaGFuZGxlIEV2ZW50cy5vZmYob2JqZWN0LCBjYWxsYmFjaylcclxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50TmFtZXMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBldmVudE5hbWVzO1xyXG4gICAgICAgICAgICBldmVudE5hbWVzID0gQ29tbW9uLmtleXMob2JqZWN0LmV2ZW50cykuam9pbignICcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5hbWVzID0gZXZlbnROYW1lcy5zcGxpdCgnICcpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBvYmplY3QuZXZlbnRzW25hbWVzW2ldXSxcclxuICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2pdICE9PSBjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tzLnB1c2goY2FsbGJhY2tzW2pdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2JqZWN0LmV2ZW50c1tuYW1lc1tpXV0gPSBuZXdDYWxsYmFja3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVzIGFsbCB0aGUgY2FsbGJhY2tzIHN1YnNjcmliZWQgdG8gdGhlIGdpdmVuIG9iamVjdCdzIGBldmVudE5hbWVgLCBpbiB0aGUgb3JkZXIgdGhleSBzdWJzY3JpYmVkLCBpZiBhbnkuXHJcbiAgICAgKiBAbWV0aG9kIHRyaWdnZXJcclxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVzXHJcbiAgICAgKiBAcGFyYW0ge30gZXZlbnRcclxuICAgICAqL1xyXG4gICAgRXZlbnRzLnRyaWdnZXIgPSBmdW5jdGlvbihvYmplY3QsIGV2ZW50TmFtZXMsIGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIG5hbWVzLFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICBjYWxsYmFja3MsXHJcbiAgICAgICAgICAgIGV2ZW50Q2xvbmU7XHJcblxyXG4gICAgICAgIGlmIChvYmplY3QuZXZlbnRzKSB7XHJcbiAgICAgICAgICAgIGlmICghZXZlbnQpXHJcbiAgICAgICAgICAgICAgICBldmVudCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgbmFtZXMgPSBldmVudE5hbWVzLnNwbGl0KCcgJyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBvYmplY3QuZXZlbnRzW25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudENsb25lID0gQ29tbW9uLmNsb25lKGV2ZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDbG9uZS5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudENsb25lLnNvdXJjZSA9IG9iamVjdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2pdLmFwcGx5KG9iamVjdCwgW2V2ZW50Q2xvbmVdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9FdmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvRXZlbnRzLmpzIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuVmVydGljZXNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHNldHMgb2YgdmVydGljZXMuXHJcbiogQSBzZXQgb2YgdmVydGljZXMgaXMgYW4gYXJyYXkgb2YgYE1hdHRlci5WZWN0b3JgIHdpdGggYWRkaXRpb25hbCBpbmRleGluZyBwcm9wZXJ0aWVzIGluc2VydGVkIGJ5IGBWZXJ0aWNlcy5jcmVhdGVgLlxyXG4qIEEgYE1hdHRlci5Cb2R5YCBtYWludGFpbnMgYSBzZXQgb2YgdmVydGljZXMgdG8gcmVwcmVzZW50IHRoZSBzaGFwZSBvZiB0aGUgb2JqZWN0IChpdHMgY29udmV4IGh1bGwpLlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuKlxyXG4qIEBjbGFzcyBWZXJ0aWNlc1xyXG4qL1xyXG5cclxudmFyIFZlcnRpY2VzID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRpY2VzO1xyXG5cclxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgc2V0IG9mIGBNYXR0ZXIuQm9keWAgY29tcGF0aWJsZSB2ZXJ0aWNlcy5cclxuICAgICAqIFRoZSBgcG9pbnRzYCBhcmd1bWVudCBhY2NlcHRzIGFuIGFycmF5IG9mIGBNYXR0ZXIuVmVjdG9yYCBwb2ludHMgb3JpZW50YXRlZCBhcm91bmQgdGhlIG9yaWdpbiBgKDAsIDApYCwgZm9yIGV4YW1wbGU6XHJcbiAgICAgKlxyXG4gICAgICogICAgIFt7IHg6IDAsIHk6IDAgfSwgeyB4OiAyNSwgeTogNTAgfSwgeyB4OiA1MCwgeTogMCB9XVxyXG4gICAgICpcclxuICAgICAqIFRoZSBgVmVydGljZXMuY3JlYXRlYCBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheSBvZiB2ZXJ0aWNlcywgd2hpY2ggYXJlIHNpbWlsYXIgdG8gTWF0dGVyLlZlY3RvciBvYmplY3RzLFxyXG4gICAgICogYnV0IHdpdGggc29tZSBhZGRpdGlvbmFsIHJlZmVyZW5jZXMgcmVxdWlyZWQgZm9yIGVmZmljaWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uIHJvdXRpbmVzLlxyXG4gICAgICpcclxuICAgICAqIFZlcnRpY2VzIG11c3QgYmUgc3BlY2lmaWVkIGluIGNsb2Nrd2lzZSBvcmRlci5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhlIGBib2R5YCBhcmd1bWVudCBpcyBub3Qgb3B0aW9uYWwsIGEgYE1hdHRlci5Cb2R5YCByZWZlcmVuY2UgbXVzdCBiZSBwcm92aWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3JbXX0gcG9pbnRzXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMuY3JlYXRlID0gZnVuY3Rpb24ocG9pbnRzLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXSxcclxuICAgICAgICAgICAgICAgIHZlcnRleCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBwb2ludC54LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHBvaW50LnksXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keSxcclxuICAgICAgICAgICAgICAgICAgICBpc0ludGVybmFsOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBzdHJpbmcgY29udGFpbmluZyBvcmRlcmVkIHggeSBwYWlycyBzZXBhcmF0ZWQgYnkgc3BhY2VzIChhbmQgb3B0aW9uYWxseSBjb21tYXMpLCBcclxuICAgICAqIGludG8gYSBgTWF0dGVyLlZlcnRpY2VzYCBvYmplY3QgZm9yIHRoZSBnaXZlbiBgTWF0dGVyLkJvZHlgLlxyXG4gICAgICogRm9yIHBhcnNpbmcgU1ZHIHBhdGhzLCBzZWUgYFN2Zy5wYXRoVG9WZXJ0aWNlc2AuXHJcbiAgICAgKiBAbWV0aG9kIGZyb21QYXRoXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcmV0dXJuIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMuZnJvbVBhdGggPSBmdW5jdGlvbihwYXRoLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIHBhdGhQYXR0ZXJuID0gL0w/XFxzKihbXFwtXFxkXFwuZV0rKVtcXHMsXSooW1xcLVxcZFxcLmVdKykqL2lnLFxyXG4gICAgICAgICAgICBwb2ludHMgPSBbXTtcclxuXHJcbiAgICAgICAgcGF0aC5yZXBsYWNlKHBhdGhQYXR0ZXJuLCBmdW5jdGlvbihtYXRjaCwgeCwgeSkge1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh7IHg6IHBhcnNlRmxvYXQoeCksIHk6IHBhcnNlRmxvYXQoeSkgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBWZXJ0aWNlcy5jcmVhdGUocG9pbnRzLCBib2R5KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjZW50cmUgKGNlbnRyb2lkKSBvZiB0aGUgc2V0IG9mIHZlcnRpY2VzLlxyXG4gICAgICogQG1ldGhvZCBjZW50cmVcclxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXHJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSBjZW50cmUgcG9pbnRcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMuY2VudHJlID0gZnVuY3Rpb24odmVydGljZXMpIHtcclxuICAgICAgICB2YXIgYXJlYSA9IFZlcnRpY2VzLmFyZWEodmVydGljZXMsIHRydWUpLFxyXG4gICAgICAgICAgICBjZW50cmUgPSB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgICAgICAgY3Jvc3MsXHJcbiAgICAgICAgICAgIHRlbXAsXHJcbiAgICAgICAgICAgIGo7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaiA9IChpICsgMSkgJSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNyb3NzID0gVmVjdG9yLmNyb3NzKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tqXSk7XHJcbiAgICAgICAgICAgIHRlbXAgPSBWZWN0b3IubXVsdChWZWN0b3IuYWRkKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tqXSksIGNyb3NzKTtcclxuICAgICAgICAgICAgY2VudHJlID0gVmVjdG9yLmFkZChjZW50cmUsIHRlbXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFZlY3Rvci5kaXYoY2VudHJlLCA2ICogYXJlYSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYXZlcmFnZSAobWVhbikgb2YgdGhlIHNldCBvZiB2ZXJ0aWNlcy5cclxuICAgICAqIEBtZXRob2QgbWVhblxyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gVGhlIGF2ZXJhZ2UgcG9pbnRcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMubWVhbiA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XHJcbiAgICAgICAgdmFyIGF2ZXJhZ2UgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhdmVyYWdlLnggKz0gdmVydGljZXNbaV0ueDtcclxuICAgICAgICAgICAgYXZlcmFnZS55ICs9IHZlcnRpY2VzW2ldLnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gVmVjdG9yLmRpdihhdmVyYWdlLCB2ZXJ0aWNlcy5sZW5ndGgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGFyZWEgb2YgdGhlIHNldCBvZiB2ZXJ0aWNlcy5cclxuICAgICAqIEBtZXRob2QgYXJlYVxyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhcmVhXHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLmFyZWEgPSBmdW5jdGlvbih2ZXJ0aWNlcywgc2lnbmVkKSB7XHJcbiAgICAgICAgdmFyIGFyZWEgPSAwLFxyXG4gICAgICAgICAgICBqID0gdmVydGljZXMubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhcmVhICs9ICh2ZXJ0aWNlc1tqXS54IC0gdmVydGljZXNbaV0ueCkgKiAodmVydGljZXNbal0ueSArIHZlcnRpY2VzW2ldLnkpO1xyXG4gICAgICAgICAgICBqID0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaWduZWQpXHJcbiAgICAgICAgICAgIHJldHVybiBhcmVhIC8gMjtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFyZWEpIC8gMjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtb21lbnQgb2YgaW5lcnRpYSAoc2Vjb25kIG1vbWVudCBvZiBhcmVhKSBvZiB0aGUgc2V0IG9mIHZlcnRpY2VzIGdpdmVuIHRoZSB0b3RhbCBtYXNzLlxyXG4gICAgICogQG1ldGhvZCBpbmVydGlhXHJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hc3NcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvbHlnb24ncyBtb21lbnQgb2YgaW5lcnRpYVxyXG4gICAgICovXHJcbiAgICBWZXJ0aWNlcy5pbmVydGlhID0gZnVuY3Rpb24odmVydGljZXMsIG1hc3MpIHtcclxuICAgICAgICB2YXIgbnVtZXJhdG9yID0gMCxcclxuICAgICAgICAgICAgZGVub21pbmF0b3IgPSAwLFxyXG4gICAgICAgICAgICB2ID0gdmVydGljZXMsXHJcbiAgICAgICAgICAgIGNyb3NzLFxyXG4gICAgICAgICAgICBqO1xyXG5cclxuICAgICAgICAvLyBmaW5kIHRoZSBwb2x5Z29uJ3MgbW9tZW50IG9mIGluZXJ0aWEsIHVzaW5nIHNlY29uZCBtb21lbnQgb2YgYXJlYVxyXG4gICAgICAgIC8vIGh0dHA6Ly93d3cucGh5c2ljc2ZvcnVtcy5jb20vc2hvd3RocmVhZC5waHA/dD0yNTI5M1xyXG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdi5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICBqID0gKG4gKyAxKSAlIHYubGVuZ3RoO1xyXG4gICAgICAgICAgICBjcm9zcyA9IE1hdGguYWJzKFZlY3Rvci5jcm9zcyh2W2pdLCB2W25dKSk7XHJcbiAgICAgICAgICAgIG51bWVyYXRvciArPSBjcm9zcyAqIChWZWN0b3IuZG90KHZbal0sIHZbal0pICsgVmVjdG9yLmRvdCh2W2pdLCB2W25dKSArIFZlY3Rvci5kb3QodltuXSwgdltuXSkpO1xyXG4gICAgICAgICAgICBkZW5vbWluYXRvciArPSBjcm9zcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAobWFzcyAvIDYpICogKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBzZXQgb2YgdmVydGljZXMgaW4tcGxhY2UuXHJcbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0ZVxyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMudHJhbnNsYXRlID0gZnVuY3Rpb24odmVydGljZXMsIHZlY3Rvciwgc2NhbGFyKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNjYWxhcikge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldLnggKz0gdmVjdG9yLnggKiBzY2FsYXI7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXS55ICs9IHZlY3Rvci55ICogc2NhbGFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXS54ICs9IHZlY3Rvci54O1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaV0ueSArPSB2ZWN0b3IueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZXMgdGhlIHNldCBvZiB2ZXJ0aWNlcyBpbi1wbGFjZS5cclxuICAgICAqIEBtZXRob2Qgcm90YXRlXHJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMucm90YXRlID0gZnVuY3Rpb24odmVydGljZXMsIGFuZ2xlLCBwb2ludCkge1xyXG4gICAgICAgIGlmIChhbmdsZSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxyXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2UgPSB2ZXJ0aWNlc1tpXSxcclxuICAgICAgICAgICAgICAgIGR4ID0gdmVydGljZS54IC0gcG9pbnQueCxcclxuICAgICAgICAgICAgICAgIGR5ID0gdmVydGljZS55IC0gcG9pbnQueTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2ZXJ0aWNlLnggPSBwb2ludC54ICsgKGR4ICogY29zIC0gZHkgKiBzaW4pO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlLnkgPSBwb2ludC55ICsgKGR4ICogc2luICsgZHkgKiBjb3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBgcG9pbnRgIGlzIGluc2lkZSB0aGUgc2V0IG9mIGB2ZXJ0aWNlc2AuXHJcbiAgICAgKiBAbWV0aG9kIGNvbnRhaW5zXHJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB2ZXJ0aWNlcyBjb250YWlucyBwb2ludCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLmNvbnRhaW5zID0gZnVuY3Rpb24odmVydGljZXMsIHBvaW50KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdmVydGljZSA9IHZlcnRpY2VzW2ldLFxyXG4gICAgICAgICAgICAgICAgbmV4dFZlcnRpY2UgPSB2ZXJ0aWNlc1soaSArIDEpICUgdmVydGljZXMubGVuZ3RoXTtcclxuICAgICAgICAgICAgaWYgKChwb2ludC54IC0gdmVydGljZS54KSAqIChuZXh0VmVydGljZS55IC0gdmVydGljZS55KSArIChwb2ludC55IC0gdmVydGljZS55KSAqICh2ZXJ0aWNlLnggLSBuZXh0VmVydGljZS54KSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoZSB2ZXJ0aWNlcyBmcm9tIGEgcG9pbnQgKGRlZmF1bHQgaXMgY2VudHJlKSBpbi1wbGFjZS5cclxuICAgICAqIEBtZXRob2Qgc2NhbGVcclxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMuc2NhbGUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgc2NhbGVYLCBzY2FsZVksIHBvaW50KSB7XHJcbiAgICAgICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEpXHJcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgcG9pbnQgPSBwb2ludCB8fCBWZXJ0aWNlcy5jZW50cmUodmVydGljZXMpO1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4LFxyXG4gICAgICAgICAgICBkZWx0YTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgZGVsdGEgPSBWZWN0b3Iuc3ViKHZlcnRleCwgcG9pbnQpO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpXS54ID0gcG9pbnQueCArIGRlbHRhLnggKiBzY2FsZVg7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzW2ldLnkgPSBwb2ludC55ICsgZGVsdGEueSAqIHNjYWxlWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFtZmVycyBhIHNldCBvZiB2ZXJ0aWNlcyBieSBnaXZpbmcgdGhlbSByb3VuZGVkIGNvcm5lcnMsIHJldHVybnMgYSBuZXcgc2V0IG9mIHZlcnRpY2VzLlxyXG4gICAgICogVGhlIHJhZGl1cyBwYXJhbWV0ZXIgaXMgYSBzaW5nbGUgbnVtYmVyIG9yIGFuIGFycmF5IHRvIHNwZWNpZnkgdGhlIHJhZGl1cyBmb3IgZWFjaCB2ZXJ0ZXguXHJcbiAgICAgKiBAbWV0aG9kIGNoYW1mZXJcclxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSByYWRpdXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eU1pblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlNYXhcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMuY2hhbWZlciA9IGZ1bmN0aW9uKHZlcnRpY2VzLCByYWRpdXMsIHF1YWxpdHksIHF1YWxpdHlNaW4sIHF1YWxpdHlNYXgpIHtcclxuICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgWzhdO1xyXG5cclxuICAgICAgICBpZiAoIXJhZGl1cy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJhZGl1cyA9IFtyYWRpdXNdO1xyXG5cclxuICAgICAgICAvLyBxdWFsaXR5IGRlZmF1bHRzIHRvIC0xLCB3aGljaCBpcyBhdXRvXHJcbiAgICAgICAgcXVhbGl0eSA9ICh0eXBlb2YgcXVhbGl0eSAhPT0gJ3VuZGVmaW5lZCcpID8gcXVhbGl0eSA6IC0xO1xyXG4gICAgICAgIHF1YWxpdHlNaW4gPSBxdWFsaXR5TWluIHx8IDI7XHJcbiAgICAgICAgcXVhbGl0eU1heCA9IHF1YWxpdHlNYXggfHwgMTQ7XHJcblxyXG4gICAgICAgIHZhciBuZXdWZXJ0aWNlcyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmV2VmVydGV4ID0gdmVydGljZXNbaSAtIDEgPj0gMCA/IGkgLSAxIDogdmVydGljZXMubGVuZ3RoIC0gMV0sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXSxcclxuICAgICAgICAgICAgICAgIG5leHRWZXJ0ZXggPSB2ZXJ0aWNlc1soaSArIDEpICUgdmVydGljZXMubGVuZ3RoXSxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYWRpdXMgPSByYWRpdXNbaSA8IHJhZGl1cy5sZW5ndGggPyBpIDogcmFkaXVzLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSYWRpdXMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZlcnRpY2VzLnB1c2godmVydGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJldk5vcm1hbCA9IFZlY3Rvci5ub3JtYWxpc2UoeyBcclxuICAgICAgICAgICAgICAgIHg6IHZlcnRleC55IC0gcHJldlZlcnRleC55LCBcclxuICAgICAgICAgICAgICAgIHk6IHByZXZWZXJ0ZXgueCAtIHZlcnRleC54XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5leHROb3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKHsgXHJcbiAgICAgICAgICAgICAgICB4OiBuZXh0VmVydGV4LnkgLSB2ZXJ0ZXgueSwgXHJcbiAgICAgICAgICAgICAgICB5OiB2ZXJ0ZXgueCAtIG5leHRWZXJ0ZXgueFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbFJhZGl1cyA9IE1hdGguc3FydCgyICogTWF0aC5wb3coY3VycmVudFJhZGl1cywgMikpLFxyXG4gICAgICAgICAgICAgICAgcmFkaXVzVmVjdG9yID0gVmVjdG9yLm11bHQoQ29tbW9uLmNsb25lKHByZXZOb3JtYWwpLCBjdXJyZW50UmFkaXVzKSxcclxuICAgICAgICAgICAgICAgIG1pZE5vcm1hbCA9IFZlY3Rvci5ub3JtYWxpc2UoVmVjdG9yLm11bHQoVmVjdG9yLmFkZChwcmV2Tm9ybWFsLCBuZXh0Tm9ybWFsKSwgMC41KSksXHJcbiAgICAgICAgICAgICAgICBzY2FsZWRWZXJ0ZXggPSBWZWN0b3Iuc3ViKHZlcnRleCwgVmVjdG9yLm11bHQobWlkTm9ybWFsLCBkaWFnb25hbFJhZGl1cykpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IHF1YWxpdHk7XHJcblxyXG4gICAgICAgICAgICBpZiAocXVhbGl0eSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZGVjaWRlIHByZWNpc2lvblxyXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5wb3coY3VycmVudFJhZGl1cywgMC4zMikgKiAxLjc1O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmVjaXNpb24gPSBDb21tb24uY2xhbXAocHJlY2lzaW9uLCBxdWFsaXR5TWluLCBxdWFsaXR5TWF4KTtcclxuXHJcbiAgICAgICAgICAgIC8vIHVzZSBhbiBldmVuIHZhbHVlIGZvciBwcmVjaXNpb24sIG1vcmUgbGlrZWx5IHRvIHJlZHVjZSBheGVzIGJ5IHVzaW5nIHN5bW1ldHJ5XHJcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gJSAyID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uICs9IDE7XHJcblxyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBNYXRoLmFjb3MoVmVjdG9yLmRvdChwcmV2Tm9ybWFsLCBuZXh0Tm9ybWFsKSksXHJcbiAgICAgICAgICAgICAgICB0aGV0YSA9IGFscGhhIC8gcHJlY2lzaW9uO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcmVjaXNpb247IGorKykge1xyXG4gICAgICAgICAgICAgICAgbmV3VmVydGljZXMucHVzaChWZWN0b3IuYWRkKFZlY3Rvci5yb3RhdGUocmFkaXVzVmVjdG9yLCB0aGV0YSAqIGopLCBzY2FsZWRWZXJ0ZXgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1ZlcnRpY2VzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvcnRzIHRoZSBpbnB1dCB2ZXJ0aWNlcyBpbnRvIGNsb2Nrd2lzZSBvcmRlciBpbiBwbGFjZS5cclxuICAgICAqIEBtZXRob2QgY2xvY2t3aXNlU29ydFxyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEByZXR1cm4ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xyXG4gICAgICovXHJcbiAgICBWZXJ0aWNlcy5jbG9ja3dpc2VTb3J0ID0gZnVuY3Rpb24odmVydGljZXMpIHtcclxuICAgICAgICB2YXIgY2VudHJlID0gVmVydGljZXMubWVhbih2ZXJ0aWNlcyk7XHJcblxyXG4gICAgICAgIHZlcnRpY2VzLnNvcnQoZnVuY3Rpb24odmVydGV4QSwgdmVydGV4Qikge1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLmFuZ2xlKGNlbnRyZSwgdmVydGV4QSkgLSBWZWN0b3IuYW5nbGUoY2VudHJlLCB2ZXJ0ZXhCKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmVydGljZXMgZm9ybSBhIGNvbnZleCBzaGFwZSAodmVydGljZXMgbXVzdCBiZSBpbiBjbG9ja3dpc2Ugb3JkZXIpLlxyXG4gICAgICogQG1ldGhvZCBpc0NvbnZleFxyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEByZXR1cm4ge2Jvb2x9IGB0cnVlYCBpZiB0aGUgYHZlcnRpY2VzYCBhcmUgY29udmV4LCBgZmFsc2VgIGlmIG5vdCAob3IgYG51bGxgIGlmIG5vdCBjb21wdXRhYmxlKS5cclxuICAgICAqL1xyXG4gICAgVmVydGljZXMuaXNDb252ZXggPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xyXG4gICAgICAgIC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9nZW9tZXRyeS9wb2x5Z29ubWVzaC9cclxuXHJcbiAgICAgICAgdmFyIGZsYWcgPSAwLFxyXG4gICAgICAgICAgICBuID0gdmVydGljZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBrLFxyXG4gICAgICAgICAgICB6O1xyXG5cclxuICAgICAgICBpZiAobiA8IDMpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGogPSAoaSArIDEpICUgbjtcclxuICAgICAgICAgICAgayA9IChpICsgMikgJSBuO1xyXG4gICAgICAgICAgICB6ID0gKHZlcnRpY2VzW2pdLnggLSB2ZXJ0aWNlc1tpXS54KSAqICh2ZXJ0aWNlc1trXS55IC0gdmVydGljZXNbal0ueSk7XHJcbiAgICAgICAgICAgIHogLT0gKHZlcnRpY2VzW2pdLnkgLSB2ZXJ0aWNlc1tpXS55KSAqICh2ZXJ0aWNlc1trXS54IC0gdmVydGljZXNbal0ueCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoeiA8IDApIHtcclxuICAgICAgICAgICAgICAgIGZsYWcgfD0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh6ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZmxhZyB8PSAyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZmxhZyA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmxhZyAhPT0gMCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgaW5wdXQgdmVydGljZXMgYXMgYSBuZXcgYXJyYXkgb2YgcG9pbnRzLlxyXG4gICAgICogQG1ldGhvZCBodWxsXHJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xyXG4gICAgICogQHJldHVybiBbdmVydGV4XSB2ZXJ0aWNlc1xyXG4gICAgICovXHJcbiAgICBWZXJ0aWNlcy5odWxsID0gZnVuY3Rpb24odmVydGljZXMpIHtcclxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9HZW9tZXRyeS9Db252ZXhfaHVsbC9Nb25vdG9uZV9jaGFpblxyXG5cclxuICAgICAgICB2YXIgdXBwZXIgPSBbXSxcclxuICAgICAgICAgICAgbG93ZXIgPSBbXSwgXHJcbiAgICAgICAgICAgIHZlcnRleCxcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgLy8gc29ydCB2ZXJ0aWNlcyBvbiB4LWF4aXMgKHktYXhpcyBmb3IgdGllcylcclxuICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLnNsaWNlKDApO1xyXG4gICAgICAgIHZlcnRpY2VzLnNvcnQoZnVuY3Rpb24odmVydGV4QSwgdmVydGV4Qikge1xyXG4gICAgICAgICAgICB2YXIgZHggPSB2ZXJ0ZXhBLnggLSB2ZXJ0ZXhCLng7XHJcbiAgICAgICAgICAgIHJldHVybiBkeCAhPT0gMCA/IGR4IDogdmVydGV4QS55IC0gdmVydGV4Qi55O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBidWlsZCBsb3dlciBodWxsXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGxvd2VyLmxlbmd0aCA+PSAyIFxyXG4gICAgICAgICAgICAgICAgICAgJiYgVmVjdG9yLmNyb3NzMyhsb3dlcltsb3dlci5sZW5ndGggLSAyXSwgbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0sIHZlcnRleCkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgbG93ZXIucG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxvd2VyLnB1c2godmVydGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGJ1aWxkIHVwcGVyIGh1bGxcclxuICAgICAgICBmb3IgKGkgPSB2ZXJ0aWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICh1cHBlci5sZW5ndGggPj0gMiBcclxuICAgICAgICAgICAgICAgICAgICYmIFZlY3Rvci5jcm9zczModXBwZXJbdXBwZXIubGVuZ3RoIC0gMl0sIHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCB2ZXJ0ZXgpIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHVwcGVyLnBvcCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB1cHBlci5wdXNoKHZlcnRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25jYXRlbmF0aW9uIG9mIHRoZSBsb3dlciBhbmQgdXBwZXIgaHVsbHMgZ2l2ZXMgdGhlIGNvbnZleCBodWxsXHJcbiAgICAgICAgLy8gb21pdCBsYXN0IHBvaW50cyBiZWNhdXNlIHRoZXkgYXJlIHJlcGVhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG90aGVyIGxpc3RcclxuICAgICAgICB1cHBlci5wb3AoKTtcclxuICAgICAgICBsb3dlci5wb3AoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHVwcGVyLmNvbmNhdChsb3dlcik7XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvVmVydGljZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1ZlcnRpY2VzLmpzIiwidmFyIEV2ZW50QmluZGluZyA9IHJlcXVpcmUoJy4vRXZlbnRCaW5kaW5nJyk7XHJcblxyXG52YXIgRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xyXG4gICAgdGhpcy5maWx0ZXJzID0gW107XHJcbiAgICB0aGlzLmhhc0ZpbHRlcnMgPSBmYWxzZTtcclxufTtcclxuXHJcbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFdmVudERpc3BhdGNoZXI7XHJcblxyXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGdldEJpbmRpbmc6IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdzLmhhc093blByb3BlcnR5KHR5cGUpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVCaW5kaW5nOiBmdW5jdGlvbiAodHlwZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuZ2V0QmluZGluZyh0eXBlKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZV0gPSBuZXcgRXZlbnRCaW5kaW5nKHRoaXMsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbdHlwZV07XHJcbiAgICB9LFxyXG5cclxuICAgIG9uOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIHByaW9yaXR5KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7IHByaW9yaXR5ID0gMDsgfVxyXG5cclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuY3JlYXRlQmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLmFkZChsaXN0ZW5lciwgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbmNlOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIHByaW9yaXR5KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7IHByaW9yaXR5ID0gMDsgfVxyXG5cclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuY3JlYXRlQmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLmFkZChsaXN0ZW5lciwgcHJpb3JpdHksIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBBZGQgYSBjYWxsYmFjayB0aGF0IGlzIG5vdGlmaWVkIGV2ZXJ5IHRpbWUgdGhpcyBFdmVudERpc3BhdGNoZXIgZGlzcGF0Y2hlcyBhbiBldmVudFxyXG4gICAgLy8gIG5vIG1hdHRlciB3aGF0IHRoZSBldmVudCB0eXBlIGlzLiBGaWx0ZXJzIGFyZSBpbnZva2VkIGZpcnN0LCBiZWZvcmUgYW55IGJpbmRpbmdzLFxyXG4gICAgLy8gIGFuZCBjYW4gc3RvcCBldmVudHMgaWYgdGhleSB3aXNoIChpbiB3aGljaCBjYXNlIHRoZXknbGwgbmV2ZXIgcmVhY2ggdGhlIGJpbmRpbmdzKVxyXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmZpbHRlcnMuaW5kZXhPZihjYWxsYmFjayk7XHJcblxyXG4gICAgICAgIGlmIChpID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBBZGQgdGhlIGZpbHRlclxyXG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBSZW1vdmUgdGhlIGZpbHRlclxyXG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmhhc0ZpbHRlcnMgPSAodGhpcy5maWx0ZXJzLmxlbmd0aCA+IDApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaGFzOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcodHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChiaW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmcuaGFzKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdG90YWw6IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nLnRvdGFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgIC8vICBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBsaXN0ZW5lciByZWdpc3RlcmVkIHdpdGggdGhlIEV2ZW50RGlzcGF0Y2hlciwgYSBjYWxsIHRvIHRoaXMgbWV0aG9kIGhhcyBubyBlZmZlY3QuXHJcbiAgICBvZmY6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcilcclxuICAgIHtcclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLnJlbW92ZShsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgX2Rpc3BhdGNoSGFuZGxlcjogZnVuY3Rpb24gKGV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIGV2ZW50LnJlc2V0KHRoaXMpO1xyXG5cclxuICAgICAgICAvLyAgUGFzcyB0aGUgZXZlbnQgdGhyb3VnaCB0aGUgZmlsdGVycyBmaXJzdFxyXG5cclxuICAgICAgICBpZiAodGhpcy5oYXNGaWx0ZXJzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgRGlkIHRoZSBmaWx0ZXIga2lsbCB0aGUgZXZlbnQ/IElmIHNvLCB3ZSBjYW4gYWJvcnQgbm93XHJcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Ll9wcm9wYWdhdGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyhldmVudC50eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLmRpc3BhdGNoKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hIYW5kbGVyKGV2ZW50W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEhhbmRsZXIoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFJlbW92ZXMgYWxsIGxpc3RlbmVycywgYnV0IHJldGFpbnMgdGhlIGV2ZW50IHR5cGUgZW50cmllc1xyXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAodHlwZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUFsbEZpbHRlcnM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuaGFzRmlsdGVycyA9IGZhbHNlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGVsZXRlOiBmdW5jdGlvbiAodHlwZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW3R5cGVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGV0ZUFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBiaW5kaW5nIGluIHRoaXMuYmluZGluZ3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRlbGV0ZUFsbCgpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsRmlsdGVycygpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnREaXNwYXRjaGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2xhc3MnKTtcclxuXHJcbi8qKlxyXG4qIFRoaXMgaXMgdGhlIGJhc2UgR2FtZSBPYmplY3QgY2xhc3MgdGhhdCB5b3UgY2FuIHVzZSB3aGVuIGNyZWF0aW5nIHlvdXIgb3duIGV4dGVuZGVkIEdhbWUgT2JqZWN0cy5cclxuKlxyXG4qIEBjbGFzc1xyXG4qL1xyXG5cclxudmFyIEdhbWVPYmplY3QgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR2FtZU9iamVjdCAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgICAgICB0aGlzLmlkID0gMDtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnJztcclxuXHJcbiAgICAgICAgdGhpcy5wYXJlbnQ7XHJcblxyXG4gICAgICAgIC8vICAwMDAxIHwgMDAxMCB8IDAxMDAgfCAxMDAwXHJcbiAgICAgICAgLy8gIFdpbGwgUmVuZGVyIGJpdG1hc2sgZmxhZ3MgZm9yIHRoZSBjb21wb25lbnRzIFZpc2libGUsIEFscGhhLCBUcmFuc2Zvcm0gYW5kIFRleHR1cmUgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgdGhpcy5yZW5kZXJNYXNrID0gMTU7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGbGFncyA9IDE1O1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZU9iamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvR2FtZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvR2FtZU9iamVjdC5qcyIsIlxyXG4vLyAgRW5jYXBzdWxhdGVzIGEgMkQgcmVjdGFuZ2xlIGRlZmluZWQgYnkgaXRzIGNvcm5lciBwb2ludCBpbiB0aGUgdG9wLWxlZnRcclxuLy8gIGFuZCBpdHMgZXh0ZW5kcyBpbiB4ICh3aWR0aCkgYW5kIHkgKGhlaWdodClcclxuXHJcbnZhciBSZWN0YW5nbGUgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSAwOyB9XHJcbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMDsgfVxyXG5cclxuICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgdGhpcy55ID0geTtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbn07XHJcblxyXG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjdGFuZ2xlO1xyXG5cclxuUmVjdGFuZ2xlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEVtcHR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldFRvKDAsIDAsIDAsIDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gd2lkdGg7IH1cclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWN0YW5nbGUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgbGVmdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMucmlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy54KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB2YWx1ZSAtIHRoaXMueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMuYm90dG9tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gKHRoaXMuYm90dG9tIC0gdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLnkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdmFsdWUgLSB0aGlzLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvUmVjdGFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWF0aENvcyA9IE1hdGguY29zO1xyXG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xyXG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XHJcbnZhciBtYXRoQWNvcyA9IE1hdGguYWNvcztcclxudmFyIG1hdGhBdGFuID0gTWF0aC5hdGFuO1xyXG5cclxudmFyIFRyYW5zZm9ybU1hdHJpeCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB0eCwgdHkpIFxyXG57XHJcbiAgICBhID0gdHlwZW9mIGEgPT09ICdudW1iZXInID8gYSA6IDE7XHJcbiAgICBiID0gdHlwZW9mIGIgPT09ICdudW1iZXInID8gYiA6IDA7XHJcbiAgICBjID0gdHlwZW9mIGMgPT09ICdudW1iZXInID8gYyA6IDA7XHJcbiAgICBkID0gdHlwZW9mIGQgPT09ICdudW1iZXInID8gZCA6IDE7XHJcbiAgICB0eCA9IHR5cGVvZiB0eCA9PT0gJ251bWJlcicgPyB0eCA6IDA7XHJcbiAgICB0eSA9IHR5cGVvZiB0eSA9PT0gJ251bWJlcicgPyB0eSA6IDA7XHJcblxyXG4gICAgdGhpcy5tYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KFthLCBiLCBjLCBkLCB0eCwgdHksIDAsIDAsIDFdKTtcclxuICAgIHRoaXMuZGVjb21wb3NlZE1hdHJpeCA9IHtcclxuICAgICAgICB0cmFuc2xhdGVYOiAwLFxyXG4gICAgICAgIHRyYW5zbGF0ZVk6IDAsXHJcbiAgICAgICAgc2NhbGVYOiAxLFxyXG4gICAgICAgIHNjYWxlWTogMSxcclxuICAgICAgICByb3RhdGlvbjogMFxyXG4gICAgfTtcclxufTtcclxuXHJcblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUubG9hZElkZW50aXR5ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG4gICAgXHJcbiAgICBtYXRyaXhbMF0gPSAxO1xyXG4gICAgbWF0cml4WzFdID0gMDtcclxuICAgIG1hdHJpeFsyXSA9IDA7XHJcbiAgICBtYXRyaXhbM10gPSAxO1xyXG4gICAgbWF0cml4WzRdID0gMDtcclxuICAgIG1hdHJpeFs1XSA9IDA7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5UcmFuc2Zvcm1NYXRyaXgucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KVxyXG57XHJcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcblxyXG4gICAgbWF0cml4WzRdID0gbWF0cml4WzBdICogeCArIG1hdHJpeFsyXSAqIHkgKyBtYXRyaXhbNF07XHJcbiAgICBtYXRyaXhbNV0gPSBtYXRyaXhbMV0gKiB4ICsgbWF0cml4WzNdICogeSArIG1hdHJpeFs1XTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAoeCwgeSlcclxue1xyXG4gICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG5cclxuICAgIG1hdHJpeFswXSA9IG1hdHJpeFswXSAqIHg7XHJcbiAgICBtYXRyaXhbMV0gPSBtYXRyaXhbMV0gKiB4O1xyXG4gICAgbWF0cml4WzJdID0gbWF0cml4WzJdICogeTtcclxuICAgIG1hdHJpeFszXSA9IG1hdHJpeFszXSAqIHk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5UcmFuc2Zvcm1NYXRyaXgucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChyYWRpYW4pXHJcbntcclxuICAgIHZhciByYWRpYW5TaW4gPSBtYXRoU2luKHJhZGlhbik7XHJcbiAgICB2YXIgcmFkaWFuQ29zID0gbWF0aENvcyhyYWRpYW4pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShyYWRpYW5Db3MsIC1yYWRpYW5TaW4sIHJhZGlhblNpbiwgcmFkaWFuQ29zLCAwLCAwKTtcclxufTtcclxuXHJcblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXJNYXRyaXgpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuICAgIHZhciBhMCA9IG1hdHJpeFswXTtcclxuICAgIHZhciBiMCA9IG1hdHJpeFsxXTtcclxuICAgIHZhciBjMCA9IG1hdHJpeFsyXTtcclxuICAgIHZhciBkMCA9IG1hdHJpeFszXTtcclxuICAgIHZhciB0eDAgPSBtYXRyaXhbNF07XHJcbiAgICB2YXIgdHkwID0gbWF0cml4WzVdO1xyXG4gICAgdmFyIGExID0gb3RoZXJNYXRyaXhbMF07XHJcbiAgICB2YXIgYjEgPSBvdGhlck1hdHJpeFsxXTtcclxuICAgIHZhciBjMSA9IG90aGVyTWF0cml4WzJdO1xyXG4gICAgdmFyIGQxID0gb3RoZXJNYXRyaXhbM107XHJcbiAgICB2YXIgdHgxID0gb3RoZXJNYXRyaXhbNF07XHJcbiAgICB2YXIgdHkxID0gb3RoZXJNYXRyaXhbNV07XHJcblxyXG4gICAgbWF0cml4WzBdID0gYTEgKiBhMCArIGIxICogYzA7XHJcbiAgICBtYXRyaXhbMV0gPSBhMSAqIGIwICsgYjEgKiBkMDtcclxuICAgIG1hdHJpeFsyXSA9IGMxICogYTAgKyBkMSAqIGMwO1xyXG4gICAgbWF0cml4WzNdID0gYzEgKiBiMCArIGQxICogZDA7XHJcbiAgICBtYXRyaXhbNF0gPSB0eDEgKiBhMCArIHR5MSAqIGMwICsgdHgwO1xyXG4gICAgbWF0cml4WzVdID0gdHgxICogYjAgKyB0eTEgKiBkMCArIHR5MDtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHR4LCB0eSlcclxue1xyXG4gICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG4gICAgdmFyIGEwID0gbWF0cml4WzBdO1xyXG4gICAgdmFyIGIwID0gbWF0cml4WzFdO1xyXG4gICAgdmFyIGMwID0gbWF0cml4WzJdO1xyXG4gICAgdmFyIGQwID0gbWF0cml4WzNdO1xyXG4gICAgdmFyIHR4MCA9IG1hdHJpeFs0XTtcclxuICAgIHZhciB0eTAgPSBtYXRyaXhbNV07XHJcblxyXG4gICAgbWF0cml4WzBdID0gYSAqIGEwICsgYiAqIGMwO1xyXG4gICAgbWF0cml4WzFdID0gYSAqIGIwICsgYiAqIGQwO1xyXG4gICAgbWF0cml4WzJdID0gYyAqIGEwICsgZCAqIGMwO1xyXG4gICAgbWF0cml4WzNdID0gYyAqIGIwICsgZCAqIGQwO1xyXG4gICAgbWF0cml4WzRdID0gdHggKiBhMCArIHR5ICogYzAgKyB0eDA7XHJcbiAgICBtYXRyaXhbNV0gPSB0eCAqIGIwICsgdHkgKiBkMCArIHR5MDtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHR4LCB0eSlcclxue1xyXG4gICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG5cclxuICAgIG1hdHJpeFswXSA9IGE7XHJcbiAgICBtYXRyaXhbMV0gPSBiO1xyXG4gICAgbWF0cml4WzJdID0gYztcclxuICAgIG1hdHJpeFszXSA9IGQ7XHJcbiAgICBtYXRyaXhbNF0gPSB0eDtcclxuICAgIG1hdHJpeFs1XSA9IHR5O1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVHJhbnNmb3JtTWF0cml4LnByb3RvdHlwZS5kZWNvbXBvc2VNYXRyaXggPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgZGVjb21wb3NlZE1hdHJpeCA9IHRoaXMuZGVjb21wb3NlZE1hdHJpeDtcclxuICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuICAgIHZhciBhID0gbWF0cml4WzBdO1xyXG4gICAgdmFyIGIgPSBtYXRyaXhbMV07XHJcbiAgICB2YXIgYyA9IG1hdHJpeFsyXTtcclxuICAgIHZhciBkID0gbWF0cml4WzNdO1xyXG4gICAgdmFyIGEyID0gYSAqIGE7XHJcbiAgICB2YXIgYjIgPSBiICogYjtcclxuICAgIHZhciBjMiA9IGMgKiBjO1xyXG4gICAgdmFyIGQyID0gZCAqIGQ7XHJcbiAgICB2YXIgc3ggPSBtYXRoU3FydChhMiArIGMyKTtcclxuICAgIHZhciBzeSA9IG1hdGhTcXJ0KGIyICsgZDIpO1xyXG5cclxuICAgIGRlY29tcG9zZWRNYXRyaXgudHJhbnNsYXRlWCA9IG1hdHJpeFs0XTtcclxuICAgIGRlY29tcG9zZWRNYXRyaXgudHJhbnNsYXRlWSA9IG1hdHJpeFs1XTtcclxuICAgIGRlY29tcG9zZWRNYXRyaXguc2NhbGVYID0gc3g7XHJcbiAgICBkZWNvbXBvc2VkTWF0cml4LnNjYWxlWSA9IHN5O1xyXG4gICAgZGVjb21wb3NlZE1hdHJpeC5yb3RhdGlvbiA9IG1hdGhBY29zKGEgLyBzeCkgKiAobWF0aEF0YW4oLWMgLyBhKSA8IDAgPyAtMSA6IDEpO1xyXG5cclxuICAgIHJldHVybiBkZWNvbXBvc2VkTWF0cml4O1xyXG59O1xyXG5cclxuLyogaWRlbnRpdHkgKyB0cmFuc2xhdGUgKyByb3RhdGUgKyBzY2FsZSAqL1xyXG5UcmFuc2Zvcm1NYXRyaXgucHJvdG90eXBlLmFwcGx5SVRSUyA9IGZ1bmN0aW9uICh4LCB5LCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVkpIFxyXG57XHJcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcbiAgICB2YXIgYSA9IDE7XHJcbiAgICB2YXIgYiA9IDA7XHJcbiAgICB2YXIgYyA9IDA7XHJcbiAgICB2YXIgZCA9IDE7XHJcbiAgICB2YXIgZSA9IDA7XHJcbiAgICB2YXIgZiA9IDA7XHJcbiAgICB2YXIgc3IgPSBtYXRoU2luKHJvdGF0aW9uKTtcclxuICAgIHZhciBjciA9IG1hdGhDb3Mocm90YXRpb24pO1xyXG5cclxuICAgIC8vIFRyYW5zbGF0ZVxyXG4gICAgbWF0cml4WzRdID0gYSAqIHggKyBjICogeSArIGU7XHJcbiAgICBtYXRyaXhbNV0gPSBiICogeCArIGQgKiB5ICsgZjtcclxuXHJcbiAgICAvLyBSb3RhdGVcclxuICAgIG1hdHJpeFswXSA9IGNyICogYSArIC1zciAqIGM7XHJcbiAgICBtYXRyaXhbMV0gPSBjciAqIGIgKyAtc3IgKiBkO1xyXG4gICAgbWF0cml4WzJdID0gc3IgKiBhICsgY3IgKiBjO1xyXG4gICAgbWF0cml4WzNdID0gc3IgKiBiICsgY3IgKiBkO1xyXG5cclxuICAgIC8vIFNjYWxlXHJcbiAgICBtYXRyaXhbMF0gPSBtYXRyaXhbMF0gKiBzY2FsZVg7XHJcbiAgICBtYXRyaXhbMV0gPSBtYXRyaXhbMV0gKiBzY2FsZVg7XHJcbiAgICBtYXRyaXhbMl0gPSBtYXRyaXhbMl0gKiBzY2FsZVk7XHJcbiAgICBtYXRyaXhbM10gPSBtYXRyaXhbM10gKiBzY2FsZVk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybU1hdHJpeDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXguanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcclxuXHJcbnZhciBCcm93c2VyID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFyb3JhIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBBcm9yYS5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBhcm9yYTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2hyb21lIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBDaHJvbWUuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY2hyb21lOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNocm9tZVZlcnNpb24gLSBJZiBydW5uaW5nIGluIENocm9tZSB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY2hyb21lVmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlcGlwaGFueSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gRXBpcGhhbnkuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZXBpcGhhbnk6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZpcmVmb3ggLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIEZpcmVmb3guXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZmlyZWZveDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXJlZm94VmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gRmlyZWZveCB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZmlyZWZveFZlcnNpb246IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbW9iaWxlU2FmYXJpIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBNb2JpbGUgU2FmYXJpLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG1vYmlsZVNhZmFyaTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWUgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGllOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGllVmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLiBCZXlvbmQgSUUxMCB5b3Ugc2hvdWxkIHVzZSBEZXZpY2UudHJpZGVudCBhbmQgRGV2aWNlLnRyaWRlbnRWZXJzaW9uLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGllVmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtaWRvcmkgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIE1pZG9yaS5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtaWRvcmk6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wZXJhIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBPcGVyYS5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBvcGVyYTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2FmYXJpIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBTYWZhcmkuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgc2FmYXJpOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNhZmFyaVZlcnNpb24gLSBJZiBydW5uaW5nIGluIFNhZmFyaSB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgc2FmYXJpVmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB0cmlkZW50IC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBhIFRyaWRlbnQgdmVyc2lvbiBvZiBJbnRlcm5ldCBFeHBsb3JlciAoSUUxMSspXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdHJpZGVudDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0cmlkZW50VmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTEgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLiBTZWUge0BsaW5rIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9tczUzNzUwMyh2PXZzLjg1KS5hc3B4fVxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRyaWRlbnRWZXJzaW9uOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVkZ2UgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIE1pY3Jvc29mdCBFZGdlIGJyb3dzZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZWRnZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2lsayAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gdGhlIFNpbGsgYnJvd3NlciAoYXMgdXNlZCBvbiB0aGUgQW1hem9uIEtpbmRsZSlcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBzaWxrOiBmYWxzZVxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuXHJcbiAgICBpZiAoKC9Bcm9yYS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuYXJvcmEgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL0VkZ2VcXC9cXGQrLy50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmVkZ2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9DaHJvbWVcXC8oXFxkKykvKS50ZXN0KHVhKSAmJiAhT1Mud2luZG93c1Bob25lKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuY2hyb21lID0gdHJ1ZTtcclxuICAgICAgICBCcm93c2VyLmNocm9tZVZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvRXBpcGhhbnkvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmVwaXBoYW55ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvRmlyZWZveFxcRCsoXFxkKykvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmZpcmVmb3ggPSB0cnVlO1xyXG4gICAgICAgIEJyb3dzZXIuZmlyZWZveFZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvQXBwbGVXZWJLaXQvKS50ZXN0KHVhKSAmJiBPUy5pT1MpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5tb2JpbGVTYWZhcmkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9NU0lFIChcXGQrXFwuXFxkKyk7LykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5pZSA9IHRydWU7XHJcbiAgICAgICAgQnJvd3Nlci5pZVZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvTWlkb3JpLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5taWRvcmkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9PcGVyYS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIub3BlcmEgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9TYWZhcmkvKS50ZXN0KHVhKSAmJiAhT1Mud2luZG93c1Bob25lKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvVHJpZGVudFxcLyhcXGQrXFwuXFxkKykoLiopcnY6KFxcZCtcXC5cXGQrKS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuaWUgPSB0cnVlO1xyXG4gICAgICAgIEJyb3dzZXIudHJpZGVudCA9IHRydWU7XHJcbiAgICAgICAgQnJvd3Nlci50cmlkZW50VmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xyXG4gICAgICAgIEJyb3dzZXIuaWVWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQzLCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNpbGsgZ2V0cyBpdHMgb3duIGlmIGNsYXVzZSBiZWNhdXNlIGl0cyB1YSBhbHNvIGNvbnRhaW5zICdTYWZhcmknXHJcbiAgICBpZiAoKC9TaWxrLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5zaWxrID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQnJvd3NlcjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9Ccm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvQnJvd3Nlci5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcblxyXG4vKipcclxuICogVGhlIHBvb2wgaW50byB3aGljaCB0aGUgY2FudmFzIGVsZW1lbnRzIGFyZSBwbGFjZWQuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSBwb29sXHJcbiAqIEB0eXBlIEFycmF5XHJcbiAqL1xyXG52YXIgcG9vbCA9IFtdO1xyXG5cclxuLy8gIFRoaXMgc2luZ2xldG9uIGlzIGluc3RhbnRpYXRlZCBhcyBzb29uIGFzIFBoYXNlciBsb2FkcyxcclxuLy8gIGJlZm9yZSBhIFBoYXNlci5HYW1lIGluc3RhbmNlIGhhcyBldmVuIGJlZW4gY3JlYXRlZC5cclxuLy8gIFdoaWNoIG1lYW5zIGFsbCBpbnN0YW5jZXMgb2YgUGhhc2VyIEdhbWVzIG9uIHRoZSBzYW1lIHBhZ2VcclxuLy8gIGNhbiBzaGFyZSB0aGUgb25lIHNpbmdsZSBwb29sXHJcblxyXG4vKipcclxuKiBUaGUgQ2FudmFzUG9vbCBpcyBhIGdsb2JhbCBzdGF0aWMgb2JqZWN0LCB0aGF0IGFsbG93cyBQaGFzZXIgdG8gcmVjeWNsZSBhbmQgcG9vbCBDYW52YXMgRE9NIGVsZW1lbnRzLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5DYW52YXNQb29sXHJcbiogQHN0YXRpY1xyXG4qL1xyXG52YXIgQ2FudmFzUG9vbCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIC8qKlxyXG4gICAgKiBDcmVhdGVzIGEgbmV3IENhbnZhcyBET00gZWxlbWVudCwgb3IgcHVsbHMgb25lIGZyb20gdGhlIHBvb2wgaWYgZnJlZS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5jcmVhdGVcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAcGFyYW0ge2FueX0gcGFyZW50IC0gVGhlIHBhcmVudCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgZWxlbWVudC5cclxuICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IFRoZSBjYW52YXMgZWxlbWVudC5cclxuICAgICovXHJcbiAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodCwgdHlwZSlcclxuICAgIHtcclxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDE7IH1cclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMTsgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHsgdHlwZSA9IENPTlNULkNBTlZBUzsgfVxyXG5cclxuICAgICAgICB2YXIgY2FudmFzO1xyXG4gICAgICAgIHZhciBjb250YWluZXIgPSBmaXJzdCh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXNQb29sLmNyZWF0ZSBuZXcnKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHtcclxuICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxyXG4gICAgICAgICAgICAgICAgY2FudmFzOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHBvb2wucHVzaChjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgY2FudmFzID0gY29udGFpbmVyLmNhbnZhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NhbnZhc1Bvb2wuY3JlYXRlIGV4aXN0aW5nJyk7XHJcblxyXG4gICAgICAgICAgICBjb250YWluZXIucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgY2FudmFzID0gY29udGFpbmVyLmNhbnZhcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNyZWF0ZTJEID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlKHBhcmVudCwgd2lkdGgsIGhlaWdodCwgQ09OU1QuQ0FOVkFTKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNyZWF0ZVdlYkdMID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlKHBhcmVudCwgd2lkdGgsIGhlaWdodCwgQ09OU1QuV0VCR0wpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogR2V0cyB0aGUgZmlyc3QgZnJlZSBjYW52YXMgaW5kZXggZnJvbSB0aGUgcG9vbC5cclxuICAgICpcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLmdldEZpcnN0XHJcbiAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICovXHJcbiAgICB2YXIgZmlyc3QgPSBmdW5jdGlvbiAodHlwZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7IHR5cGUgPSBDT05TVC5DQU5WQVM7IH1cclxuXHJcbiAgICAgICAgcG9vbC5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWluZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5wYXJlbnQgJiYgY29udGFpbmVyLnR5cGUgPT09IHR5cGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBMb29rcyB1cCBhIGNhbnZhcyBiYXNlZCBvbiBpdHMgcGFyZW50LCBhbmQgaWYgZm91bmQgcHV0cyBpdCBiYWNrIGluIHRoZSBwb29sLCBmcmVlaW5nIGl0IHVwIGZvciByZS11c2UuXHJcbiAgICAqIFRoZSBjYW52YXMgaGFzIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IHNldCB0byAxLCBhbmQgaXRzIHBhcmVudCBhdHRyaWJ1dGUgbnVsbGVkLlxyXG4gICAgKiBcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLnJlbW92ZVxyXG4gICAgKiBAcGFyYW0ge2FueXxIVE1MQ2FudmFzRWxlbWVudH0gcGFyZW50IC0gVGhlIHBhcmVudCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAqL1xyXG4gICAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChwYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIENoZWNrIHRvIHNlZSBpZiB0aGUgcGFyZW50IGlzIGEgY2FudmFzIG9iamVjdFxyXG4gICAgICAgIHZhciBpc0NhbnZhcyA9IHBhcmVudCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xyXG5cclxuICAgICAgICBwb29sLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhaW5lcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICgoaXNDYW52YXMgJiYgY29udGFpbmVyLmNhbnZhcyA9PT0gcGFyZW50KSB8fCAoIWlzQ2FudmFzICYmIGNvbnRhaW5lci5wYXJlbnQgPT09IHBhcmVudCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXNQb29sLnJlbW92ZSBmb3VuZCBhbmQgcmVtb3ZlZCcpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLndpZHRoID0gMTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYW52YXMuaGVpZ2h0ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIHVzZWQgY2FudmFzIGVsZW1lbnRzIGluIHRoZSBwb29sLlxyXG4gICAgKiBcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLmdldFRvdGFsXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBpbi11c2UgKHBhcmVudGVkKSBjYW52YXMgZWxlbWVudHMgaW4gdGhlIHBvb2wuXHJcbiAgICAqL1xyXG4gICAgdmFyIHRvdGFsID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYyA9IDA7XHJcblxyXG4gICAgICAgIHBvb2wuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBmcmVlIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cclxuICAgICogXHJcbiAgICAqIEBzdGF0aWNcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5nZXRGcmVlXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBmcmVlICh1bi1wYXJlbnRlZCkgY2FudmFzIGVsZW1lbnRzIGluIHRoZSBwb29sLlxyXG4gICAgKi9cclxuICAgIHZhciBmcmVlID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gcG9vbC5sZW5ndGggLSB0b3RhbCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlLFxyXG4gICAgICAgIGNyZWF0ZTJEOiBjcmVhdGUyRCxcclxuICAgICAgICBjcmVhdGVXZWJHTDogY3JlYXRlV2ViR0wsXHJcbiAgICAgICAgZmlyc3Q6IGZpcnN0LFxyXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlLFxyXG4gICAgICAgIHRvdGFsOiB0b3RhbCxcclxuICAgICAgICBmcmVlOiBmcmVlLFxyXG4gICAgICAgIHBvb2w6IHBvb2xcclxuICAgIH07XHJcbn07XHJcblxyXG4vLyAgSWYgd2UgZXhwb3J0IHRoZSBjYWxsZWQgZnVuY3Rpb24gaGVyZSwgaXQnbGwgb25seSBiZSBpbnZva2VkIG9uY2UgKG5vdCBldmVyeSB0aW1lIGl0J3MgcmVxdWlyZWQpLlxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1Bvb2woKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL0NhbnZhc1Bvb2wuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RvbS9DYW52YXNQb29sLmpzIiwidmFyIEFuZ2xlID0gZnVuY3Rpb24gKGxpbmUpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKGxpbmUueTIgLSBsaW5lLnkxLCBsaW5lLngyIC0gbGluZS54MSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRDb2xvciA9IHJlcXVpcmUoJy4vR2V0Q29sb3InKTtcclxudmFyIEdldENvbG9yMzIgPSByZXF1aXJlKCcuL0dldENvbG9yMzInKTtcclxuXHJcbnZhciBDb2xvciA9IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcclxue1xyXG4gICAgaWYgKHJlZCA9PT0gdW5kZWZpbmVkKSB7IHJlZCA9IDA7IH1cclxuICAgIGlmIChncmVlbiA9PT0gdW5kZWZpbmVkKSB7IGdyZWVuID0gMDsgfVxyXG4gICAgaWYgKGJsdWUgPT09IHVuZGVmaW5lZCkgeyBibHVlID0gMDsgfVxyXG4gICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHsgYWxwaGEgPSAyNTU7IH1cclxuXHJcbiAgICAvLyAgQWxsIHByaXZhdGVcclxuICAgIHRoaXMuciA9IDA7XHJcbiAgICB0aGlzLmcgPSAwO1xyXG4gICAgdGhpcy5iID0gMDtcclxuICAgIHRoaXMuYSA9IDI1NTtcclxuXHJcbiAgICB0aGlzLmdsID0gWyAwLjAsIDAuMCwgMC4wLCAxLjAgXTtcclxuXHJcbiAgICB0aGlzLl9jb2xvciA9IDA7XHJcbiAgICB0aGlzLl9jb2xvcjMyID0gMDtcclxuICAgIHRoaXMuX3JnYmEgPSAnJztcclxuXHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnNldFRvKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKTtcclxufTtcclxuXHJcbkNvbG9yLnByb3RvdHlwZS5jb250cnVzY3RvciA9IENvbG9yO1xyXG5cclxuQ29sb3IucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHRyYW5zcGFyZW50OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVkID0gMDtcclxuICAgICAgICB0aGlzLmdyZWVuID0gMDtcclxuICAgICAgICB0aGlzLmJsdWUgPSAwO1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBWYWx1ZXMgYXJlIGluIHRoZSByYW5nZSAwIHRvIDI1NVxyXG4gICAgc2V0VG86IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcclxuICAgIHtcclxuICAgICAgICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkgeyBhbHBoYSA9IDI1NTsgfVxyXG5cclxuICAgICAgICB0aGlzLnJlZCA9IHJlZDtcclxuICAgICAgICB0aGlzLmdyZWVuID0gZ3JlZW47XHJcbiAgICAgICAgdGhpcy5ibHVlID0gYmx1ZTtcclxuICAgICAgICB0aGlzLmFscGhhID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFZhbHVlcyBhcmUgaW4gdGhlIHJhbmdlIDAgdG8gMVxyXG4gICAgc2V0R0xUbzogZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7IGFscGhhID0gMTsgfVxyXG5cclxuICAgICAgICB0aGlzLnJlZEdMID0gcmVkO1xyXG4gICAgICAgIHRoaXMuZ3JlZW5HTCA9IGdyZWVuO1xyXG4gICAgICAgIHRoaXMuYmx1ZUdMID0gYmx1ZTtcclxuICAgICAgICB0aGlzLmFscGhhR0wgPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tUkdCOiBmdW5jdGlvbiAoY29sb3IpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZWQgPSBjb2xvci5yO1xyXG4gICAgICAgIHRoaXMuZ3JlZW4gPSBjb2xvci5nO1xyXG4gICAgICAgIHRoaXMuYmx1ZSA9IGNvbG9yLmI7XHJcblxyXG4gICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eSgnYScpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hbHBoYSA9IGNvbG9yLmE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGlydHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gR2V0Q29sb3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XHJcbiAgICAgICAgdGhpcy5fY29sb3IzMiA9IEdldENvbG9yMzIodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICB0aGlzLl9yZ2JhID0gJ3JnYmEoJyArIHRoaXMuciArICcsJyArIHRoaXMuZyArICcsJyArIHRoaXMuYiArICcsJyArICgyNTUgLyB0aGlzLmEpICsgJyknO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU2FtZSBhcyBzZXRSR0IgYnV0IHBlcmZvcm1zIHNhZmV0eSBjaGVja3Mgb24gYWxsIHRoZSB2YWx1ZXMgZ2l2ZW5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb2xvci5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBjb2xvcjoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbG9yMzI6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlydHkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjMyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJnYmE6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlydHkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZ2JhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBHZXRzIGFuZCBzZXRzIHRoZSByZWQgdmFsdWUsIG5vcm1hbGl6ZWQgdG8gdGhlIDAgdG8gMSByYW5nZVxyXG4gICAgcmVkR0w6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xbMF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmdsWzBdID0gTWF0aC5taW4oTWF0aC5hYnModmFsdWUpLCAxKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuciA9IE1hdGguZmxvb3IodGhpcy5nbFswXSAqIDI1NSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBncmVlbkdMOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsWzFdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nbFsxXSA9IE1hdGgubWluKE1hdGguYWJzKHZhbHVlKSwgMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmcgPSBNYXRoLmZsb29yKHRoaXMuZ2xbMV0gKiAyNTUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYmx1ZUdMOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsWzJdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nbFsyXSA9IE1hdGgubWluKE1hdGguYWJzKHZhbHVlKSwgMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmIgPSBNYXRoLmZsb29yKHRoaXMuZ2xbMl0gKiAyNTUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGFHTDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbFszXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xbM10gPSBNYXRoLm1pbihNYXRoLmFicyh2YWx1ZSksIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hID0gTWF0aC5mbG9vcih0aGlzLmdsWzNdICogMjU1KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBHZXRzIGFuZCBzZXRzIHRoZSByZWQgdmFsdWUsIG5vcm1hbGl6ZWQgdG8gdGhlIDAgdG8gMjU1IHJhbmdlXHJcbiAgICByZWQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihNYXRoLmFicyh2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5taW4odmFsdWUsIDI1NSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdsWzBdID0gdmFsdWUgLyAyNTU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBncmVlbjoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKE1hdGguYWJzKHZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbih2YWx1ZSwgMjU1KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2xbMV0gPSB2YWx1ZSAvIDI1NTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJsdWU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihNYXRoLmFicyh2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4odmFsdWUsIDI1NSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdsWzJdID0gdmFsdWUgLyAyNTU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbHBoYToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKE1hdGguYWJzKHZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmEgPSBNYXRoLm1pbih2YWx1ZSwgMjU1KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2xbM10gPSB2YWx1ZSAvIDI1NTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2NvbG9yL0NvbG9yLmpzIiwidmFyIEdldFVSTCA9IHJlcXVpcmUoJy4vR2V0VVJMJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIFhIUkxvYWRlciA9IHJlcXVpcmUoJy4vWEhSTG9hZGVyJyk7XHJcbnZhciBYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vWEhSU2V0dGluZ3MnKTtcclxudmFyIE1lcmdlWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL01lcmdlWEhSU2V0dGluZ3MnKTtcclxuXHJcbnZhciBGaWxlID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgdXJsLCByZXNwb25zZVR5cGUsIHhoclNldHRpbmdzLCBjb25maWcpXHJcbntcclxuICAgIC8vICBmaWxlIHR5cGUgKGltYWdlLCBqc29uLCBldGMpIGZvciBzb3J0aW5nIHdpdGhpbiB0aGUgTG9hZGVyXHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgIC8vICB1bmlxdWUgY2FjaGUga2V5ICh1bmlxdWUgd2l0aGluIGl0cyBmaWxlIHR5cGUpXHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuXHJcbiAgICAvLyAgVGhlIFVSTCBvZiB0aGUgZmlsZSwgbm90IGluY2x1ZGluZyBiYXNlVVJMXHJcbiAgICB0aGlzLnVybCA9IHVybDtcclxuXHJcbiAgICAvLyAgU2V0IHdoZW4gdGhlIExvYWRlciBjYWxscyAnbG9hZCcgb24gdGhpcyBmaWxlXHJcbiAgICB0aGlzLnNyYyA9ICcnO1xyXG5cclxuICAgIHRoaXMueGhyU2V0dGluZ3MgPSBYSFJTZXR0aW5ncyhyZXNwb25zZVR5cGUpO1xyXG5cclxuICAgIGlmICh4aHJTZXR0aW5ncylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnhoclNldHRpbmdzID0gTWVyZ2VYSFJTZXR0aW5ncyh0aGlzLnhoclNldHRpbmdzLCB4aHJTZXR0aW5ncyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy54aHJMb2FkZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BFTkRJTkc7XHJcblxyXG4gICAgLy8gIFNldCBieSBvblByb2dyZXNzIChvbmx5IGlmIGxvYWRpbmcgdmlhIFhIUilcclxuICAgIHRoaXMuYnl0ZXNUb3RhbCA9IDA7XHJcbiAgICB0aGlzLmJ5dGVzTG9hZGVkID0gLTE7XHJcbiAgICB0aGlzLnBlcmNlbnRDb21wbGV0ZSA9IC0xO1xyXG5cclxuICAgIC8vICBGb3IgQ09ScyBiYXNlZCBsb2FkaW5nLlxyXG4gICAgLy8gIElmIHRoaXMgaXMgdW5kZWZpbmVkIHRoZW4gdGhlIEZpbGUgd2lsbCBjaGVjayBCYXNlTG9hZGVyLmNyb3NzT3JpZ2luIGFuZCB1c2UgdGhhdCAoaWYgc2V0KVxyXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvLyAgVGhlIGFjdHVhbCBwcm9jZXNzZWQgZmlsZSBkYXRhXHJcbiAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gIEEgY29uZmlnIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGJ5IGZpbGUgdHlwZXMgdG8gc3RvcmUgdHJhbnNpdGlvbmFsIGRhdGFcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgIC8vICBNdWx0aXBhcnQgZmlsZT8gKGkuZS4gYW4gYXRsYXMgYW5kIGl0cyBqc29uIHRvZ2V0aGVyKVxyXG4gICAgdGhpcy5saW5rRmlsZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubGlua1R5cGUgPSAnJztcclxuXHJcbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcclxufTtcclxuXHJcbkZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmlsZTtcclxuXHJcbkZpbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHJlc2V0WEhSOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueGhyTG9hZGVyLm9ubG9hZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnhockxvYWRlci5vbmVycm9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueGhyTG9hZGVyLm9ucHJvZ3Jlc3MgPSB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYWxsZWQgd2hlbiB0aGUgSW1hZ2UgbG9hZHNcclxuICAgIC8vICBQcm9ncmVzc0V2ZW50XHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0WEhSKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcywgdHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0WEhSKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcywgZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVzTG9hZGVkID0gZXZlbnQubG9hZGVkO1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVzVG90YWwgPSBldmVudC50b3RhbDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucGVyY2VudENvbXBsZXRlID0gTWF0aC5taW4oKHRoaXMuYnl0ZXNMb2FkZWQgLyB0aGlzLmJ5dGVzVG90YWwpLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucGVyY2VudENvbXBsZXRlICsgJyUgKCcgKyB0aGlzLmJ5dGVzTG9hZGVkICsgJyBieXRlcyknKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Qcm9jZXNzOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmtGaWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlua0ZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfV0FJVElOR19MSU5LRklMRSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRoZSBsaW5rZmlsZSBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZywgYW5kIGlzIHdhaXRpbmcgZm9yIHRoaXMgZmlsZSwgc28gbGV0J3MgZG8gdGhlbSBib3RoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9DT01QTEVURTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlua0ZpbGUuc3RhdGUgPSBDT05TVC5GSUxFX0NPTVBMRVRFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRoZSBsaW5rZmlsZSBzdGlsbCBoYXNuJ3QgZmluaXNoZWQgbG9hZGluZyBhbmQvb3IgcHJvY2Vzc2luZyB5ZXRcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1dBSVRJTkdfTElOS0ZJTEU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfQ09NUExFVEU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIGJ5IHRoZSBMb2FkZXIsIHN0YXJ0cyB0aGUgYWN0dWFsIGZpbGUgZG93bmxvYWRpbmdcclxuICAgIGxvYWQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgYmFzZVVSTCwgZ2xvYmFsWEhSKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChiYXNlVVJMID09PSB1bmRlZmluZWQpIHsgYmFzZVVSTCA9ICcnOyB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgdGhpcy5zcmMgPSBHZXRVUkwodGhpcywgYmFzZVVSTCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNyYy5pbmRleE9mKCdkYXRhOicpID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvY2FsIGRhdGEgVVJJJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueGhyTG9hZGVyID0gWEhSTG9hZGVyKHRoaXMsIGdsb2JhbFhIUik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvRmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL0ZpbGUuanMiLCIvKipcclxuKiBUaGUgY2VudGVyIHggY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgKHggLSBvZmZzZXRYKSArICh3aWR0aCAvIDIpYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBjZW50ZXJYXHJcbiovXHJcblxyXG52YXIgR2V0Q2VudGVyWCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdC54IC0gKGdhbWVPYmplY3Qud2lkdGggKiBnYW1lT2JqZWN0LmFuY2hvclgpICsgKGdhbWVPYmplY3Qud2lkdGggKiAwLjUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRDZW50ZXJYO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvR2V0Q2VudGVyWC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGNlbnRlciB4IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYCh4IC0gb2Zmc2V0WCkgKyAod2lkdGggLyAyKWAuXHJcbipcclxuKiBAcHJvcGVydHkge251bWJlcn0gY2VudGVyWFxyXG4qL1xyXG5cclxudmFyIEdldENlbnRlclkgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxue1xyXG4gICAgcmV0dXJuIGdhbWVPYmplY3QueSAtIChnYW1lT2JqZWN0LmhlaWdodCAqIGdhbWVPYmplY3QuYW5jaG9yWSkgKyAoZ2FtZU9iamVjdC5oZWlnaHQgKiAwLjUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRDZW50ZXJZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvR2V0Q2VudGVyWS5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGNlbnRlciB4IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYCh4IC0gb2Zmc2V0WCkgKyAod2lkdGggLyAyKWAuXHJcbipcclxuKiBAcHJvcGVydHkge251bWJlcn0gY2VudGVyWFxyXG4qL1xyXG5cclxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuR2V0Q2VudGVyWChib2IpXHJcbi8vICBQaGFzZXIuVXRpbHMuQm91bmRzLkNlbnRlck9uKGJvYiwgeCwgeSlcclxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuQ2VudGVyWChib2IsIHgpXHJcbi8vICBQaGFzZXIuVXRpbHMuQm91bmRzLkNlbnRlclkoYm9iLCB4KVxyXG5cclxudmFyIFNldENlbnRlclggPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgeClcclxue1xyXG4gICAgdmFyIG9mZnNldFggPSBnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5hbmNob3JYO1xyXG5cclxuICAgIGdhbWVPYmplY3QueCA9ICh4ICsgb2Zmc2V0WCkgLSAoZ2FtZU9iamVjdC53aWR0aCAqIDAuNSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldENlbnRlclg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2JvdW5kcy9TZXRDZW50ZXJYLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgY2VudGVyIHggY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgKHggLSBvZmZzZXRYKSArICh3aWR0aCAvIDIpYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBjZW50ZXJYXHJcbiovXHJcblxyXG4vLyAgUGhhc2VyLlV0aWxzLkJvdW5kcy5HZXRDZW50ZXJYKGJvYilcclxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuQ2VudGVyT24oYm9iLCB4LCB5KVxyXG4vLyAgUGhhc2VyLlV0aWxzLkJvdW5kcy5DZW50ZXJYKGJvYiwgeClcclxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuQ2VudGVyWShib2IsIHgpXHJcblxyXG52YXIgU2V0Q2VudGVyWSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB5KVxyXG57XHJcbiAgICB2YXIgb2Zmc2V0WSA9IGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5hbmNob3JZO1xyXG5cclxuICAgIGdhbWVPYmplY3QueSA9ICh5ICsgb2Zmc2V0WSkgLSAoZ2FtZU9iamVjdC5oZWlnaHQgKiAwLjUpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRDZW50ZXJZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvU2V0Q2VudGVyWS5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFNvdXJjZSBvYmplY3RcclxuLy8gIFRoZSBrZXkgYXMgYSBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIGtleXMsIGkuZS4gJ2Jhbm5lcicsIG9yICdiYW5uZXIuaGlkZUJhbm5lcidcclxuLy8gIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RcclxuXHJcbnZhciBHZXRPYmplY3RWYWx1ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKVxyXG57XHJcbiAgICBpZiAoa2V5LmluZGV4T2YoJy4nKSlcclxuICAgIHtcclxuICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSBzb3VyY2U7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG5cclxuICAgICAgICAvLyAgVXNlIGZvciBsb29wIGhlcmUgc28gd2UgY2FuIGJyZWFrIGVhcmx5XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5oYXNPd25Qcm9wZXJ0eShrZXlzW2ldKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFllcyBpdCBoYXMgYSBrZXkgcHJvcGVydHksIGxldCdzIGNhcnJ5IG9uIGRvd25cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyZW50W2tleXNbaV1dO1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFtrZXlzW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkgPyBzb3VyY2Vba2V5XSA6IGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0T2JqZWN0VmFsdWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL29iamVjdC9HZXRPYmplY3RWYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG5cclxudmFyIEltYWdlRmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MsIG9wdGlvbnMpXHJcbntcclxuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHsgcGF0aCA9ICcnOyB9XHJcblxyXG4gICAgaWYgKCFrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci5pbWFnZVxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5wbmcnO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmlsZS5jYWxsKHRoaXMsICdpbWFnZScsIGtleSwgdXJsLCAnYmxvYicsIHhoclNldHRpbmdzLCBvcHRpb25zKTtcclxufTtcclxuXHJcbkltYWdlRmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcclxuSW1hZ2VGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEltYWdlRmlsZTtcclxuXHJcbkltYWdlRmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IG5ldyBJbWFnZSgpO1xyXG5cclxuICAgIHRoaXMuZGF0YS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XHJcblxyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICB0aGlzLmRhdGEub25sb2FkID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKF90aGlzLmRhdGEuc3JjKTtcclxuXHJcbiAgICAgICAgX3RoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgICAgICBjYWxsYmFjayhfdGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGF0YS5vbmVycm9yID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKF90aGlzLmRhdGEuc3JjKTtcclxuXHJcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0VSUk9SRUQ7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKF90aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kYXRhLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy54aHJMb2FkZXIucmVzcG9uc2UpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZUZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qcyIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGJvZHkgbW9kZWxzLlxyXG4qIEEgYE1hdHRlci5Cb2R5YCBpcyBhIHJpZ2lkIGJvZHkgdGhhdCBjYW4gYmUgc2ltdWxhdGVkIGJ5IGEgYE1hdHRlci5FbmdpbmVgLlxyXG4qIEZhY3RvcmllcyBmb3IgY29tbW9ubHkgdXNlZCBib2R5IGNvbmZpZ3VyYXRpb25zIChzdWNoIGFzIHJlY3RhbmdsZXMsIGNpcmNsZXMgYW5kIG90aGVyIHBvbHlnb25zKSBjYW4gYmUgZm91bmQgaW4gdGhlIG1vZHVsZSBgTWF0dGVyLkJvZGllc2AuXHJcbipcclxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxyXG5cclxuKiBAY2xhc3MgQm9keVxyXG4qL1xyXG5cclxudmFyIEJvZHkgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm9keTtcclxuXHJcbnZhciBWZXJ0aWNlcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlcnRpY2VzJyk7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcclxudmFyIFNsZWVwaW5nID0gcmVxdWlyZSgnLi4vY29yZS9TbGVlcGluZycpO1xyXG52YXIgUmVuZGVyID0gcmVxdWlyZSgnLi4vcmVuZGVyL1JlbmRlcicpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxudmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xyXG52YXIgQXhlcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0F4ZXMnKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICBCb2R5Ll9pbmVydGlhU2NhbGUgPSA0O1xyXG4gICAgQm9keS5fbmV4dENvbGxpZGluZ0dyb3VwSWQgPSAxO1xyXG4gICAgQm9keS5fbmV4dE5vbkNvbGxpZGluZ0dyb3VwSWQgPSAtMTtcclxuICAgIEJvZHkuX25leHRDYXRlZ29yeSA9IDB4MDAwMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmlnaWQgYm9keSBtb2RlbC4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxyXG4gICAgICogVmVydGljZXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gY2xvY2t3aXNlIG9yZGVyLlxyXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7Ym9keX0gYm9keVxyXG4gICAgICovXHJcbiAgICBCb2R5LmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIGlkOiBDb21tb24ubmV4dElkKCksXHJcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcclxuICAgICAgICAgICAgbGFiZWw6ICdCb2R5JyxcclxuICAgICAgICAgICAgcGFydHM6IFtdLFxyXG4gICAgICAgICAgICBwbHVnaW46IHt9LFxyXG4gICAgICAgICAgICBhbmdsZTogMCxcclxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKCdMIDAgMCBMIDQwIDAgTCA0MCA0MCBMIDAgNDAnKSxcclxuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICAgICAgICBmb3JjZTogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgICAgIHRvcnF1ZTogMCxcclxuICAgICAgICAgICAgcG9zaXRpb25JbXB1bHNlOiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgICAgICAgY29uc3RyYWludEltcHVsc2U6IHsgeDogMCwgeTogMCwgYW5nbGU6IDAgfSxcclxuICAgICAgICAgICAgdG90YWxDb250YWN0czogMCxcclxuICAgICAgICAgICAgc3BlZWQ6IDAsXHJcbiAgICAgICAgICAgIGFuZ3VsYXJTcGVlZDogMCxcclxuICAgICAgICAgICAgdmVsb2NpdHk6IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICAgICAgICBhbmd1bGFyVmVsb2NpdHk6IDAsXHJcbiAgICAgICAgICAgIGlzU2Vuc29yOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgICAgICAgICBpc1NsZWVwaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgbW90aW9uOiAwLFxyXG4gICAgICAgICAgICBzbGVlcFRocmVzaG9sZDogNjAsXHJcbiAgICAgICAgICAgIGRlbnNpdHk6IDAuMDAxLFxyXG4gICAgICAgICAgICByZXN0aXR1dGlvbjogMCxcclxuICAgICAgICAgICAgZnJpY3Rpb246IDAuMSxcclxuICAgICAgICAgICAgZnJpY3Rpb25TdGF0aWM6IDAuNSxcclxuICAgICAgICAgICAgZnJpY3Rpb25BaXI6IDAuMDEsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IDB4MDAwMSxcclxuICAgICAgICAgICAgICAgIG1hc2s6IDB4RkZGRkZGRkYsXHJcbiAgICAgICAgICAgICAgICBncm91cDogMFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzbG9wOiAwLjA1LFxyXG4gICAgICAgICAgICB0aW1lU2NhbGU6IDEsXHJcbiAgICAgICAgICAgIHJlbmRlcjoge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICBzcHJpdGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB4U2NhbGU6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgeVNjYWxlOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHhPZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeU9mZnNldDogMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGJvZHkgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgX2luaXRQcm9wZXJ0aWVzKGJvZHksIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICByZXR1cm4gYm9keTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBncm91cCBpbmRleCBmb3Igd2hpY2ggYm9kaWVzIHdpbGwgY29sbGlkZS5cclxuICAgICAqIElmIGBpc05vbkNvbGxpZGluZ2AgaXMgYHRydWVgLCByZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBncm91cCBpbmRleCBmb3Igd2hpY2ggYm9kaWVzIHdpbGwgX25vdF8gY29sbGlkZS5cclxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICogQG1ldGhvZCBuZXh0R3JvdXBcclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2lzTm9uQ29sbGlkaW5nPWZhbHNlXVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBVbmlxdWUgZ3JvdXAgaW5kZXhcclxuICAgICAqL1xyXG4gICAgQm9keS5uZXh0R3JvdXAgPSBmdW5jdGlvbihpc05vbkNvbGxpZGluZykge1xyXG4gICAgICAgIGlmIChpc05vbkNvbGxpZGluZylcclxuICAgICAgICAgICAgcmV0dXJuIEJvZHkuX25leHROb25Db2xsaWRpbmdHcm91cElkLS07XHJcblxyXG4gICAgICAgIHJldHVybiBCb2R5Ll9uZXh0Q29sbGlkaW5nR3JvdXBJZCsrO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5leHQgdW5pcXVlIGNhdGVnb3J5IGJpdGZpZWxkIChzdGFydGluZyBhZnRlciB0aGUgaW5pdGlhbCBkZWZhdWx0IGNhdGVnb3J5IGAweDAwMDFgKS5cclxuICAgICAqIFRoZXJlIGFyZSAzMiBhdmFpbGFibGUuIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICogQG1ldGhvZCBuZXh0Q2F0ZWdvcnlcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVW5pcXVlIGNhdGVnb3J5IGJpdGZpZWxkXHJcbiAgICAgKi9cclxuICAgIEJvZHkubmV4dENhdGVnb3J5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgQm9keS5fbmV4dENhdGVnb3J5ID0gQm9keS5fbmV4dENhdGVnb3J5IDw8IDE7XHJcbiAgICAgICAgcmV0dXJuIEJvZHkuX25leHRDYXRlZ29yeTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXNlcyBib2R5IHByb3BlcnRpZXMuXHJcbiAgICAgKiBAbWV0aG9kIF9pbml0UHJvcGVydGllc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHt9IFtvcHRpb25zXVxyXG4gICAgICovXHJcbiAgICB2YXIgX2luaXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oYm9keSwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAvLyBpbml0IHJlcXVpcmVkIHByb3BlcnRpZXMgKG9yZGVyIGlzIGltcG9ydGFudClcclxuICAgICAgICBCb2R5LnNldChib2R5LCB7XHJcbiAgICAgICAgICAgIGJvdW5kczogYm9keS5ib3VuZHMgfHwgQm91bmRzLmNyZWF0ZShib2R5LnZlcnRpY2VzKSxcclxuICAgICAgICAgICAgcG9zaXRpb25QcmV2OiBib2R5LnBvc2l0aW9uUHJldiB8fCBWZWN0b3IuY2xvbmUoYm9keS5wb3NpdGlvbiksXHJcbiAgICAgICAgICAgIGFuZ2xlUHJldjogYm9keS5hbmdsZVByZXYgfHwgYm9keS5hbmdsZSxcclxuICAgICAgICAgICAgdmVydGljZXM6IGJvZHkudmVydGljZXMsXHJcbiAgICAgICAgICAgIHBhcnRzOiBib2R5LnBhcnRzIHx8IFtib2R5XSxcclxuICAgICAgICAgICAgaXNTdGF0aWM6IGJvZHkuaXNTdGF0aWMsXHJcbiAgICAgICAgICAgIGlzU2xlZXBpbmc6IGJvZHkuaXNTbGVlcGluZyxcclxuICAgICAgICAgICAgcGFyZW50OiBib2R5LnBhcmVudCB8fCBib2R5XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIFZlcnRpY2VzLnJvdGF0ZShib2R5LnZlcnRpY2VzLCBib2R5LmFuZ2xlLCBib2R5LnBvc2l0aW9uKTtcclxuICAgICAgICBBeGVzLnJvdGF0ZShib2R5LmF4ZXMsIGJvZHkuYW5nbGUpO1xyXG4gICAgICAgIEJvdW5kcy51cGRhdGUoYm9keS5ib3VuZHMsIGJvZHkudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xyXG5cclxuICAgICAgICAvLyBhbGxvdyBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgcHJvcGVydGllc1xyXG4gICAgICAgIEJvZHkuc2V0KGJvZHksIHtcclxuICAgICAgICAgICAgYXhlczogb3B0aW9ucy5heGVzIHx8IGJvZHkuYXhlcyxcclxuICAgICAgICAgICAgYXJlYTogb3B0aW9ucy5hcmVhIHx8IGJvZHkuYXJlYSxcclxuICAgICAgICAgICAgbWFzczogb3B0aW9ucy5tYXNzIHx8IGJvZHkubWFzcyxcclxuICAgICAgICAgICAgaW5lcnRpYTogb3B0aW9ucy5pbmVydGlhIHx8IGJvZHkuaW5lcnRpYVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyByZW5kZXIgcHJvcGVydGllc1xyXG4gICAgICAgIHZhciBkZWZhdWx0RmlsbFN0eWxlID0gKGJvZHkuaXNTdGF0aWMgPyAnIzJlMmI0NCcgOiBDb21tb24uY2hvb3NlKFsnIzAwNkJBNicsICcjMDQ5NkZGJywgJyNGRkJDNDInLCAnI0Q4MTE1OScsICcjOEYyRDU2J10pKSxcclxuICAgICAgICAgICAgZGVmYXVsdFN0cm9rZVN0eWxlID0gQ29tbW9uLnNoYWRlQ29sb3IoZGVmYXVsdEZpbGxTdHlsZSwgLTIwKTtcclxuICAgICAgICBib2R5LnJlbmRlci5maWxsU3R5bGUgPSBib2R5LnJlbmRlci5maWxsU3R5bGUgfHwgZGVmYXVsdEZpbGxTdHlsZTtcclxuICAgICAgICBib2R5LnJlbmRlci5zdHJva2VTdHlsZSA9IGJvZHkucmVuZGVyLnN0cm9rZVN0eWxlIHx8IGRlZmF1bHRTdHJva2VTdHlsZTtcclxuICAgICAgICBib2R5LnJlbmRlci5zcHJpdGUueE9mZnNldCArPSAtKGJvZHkuYm91bmRzLm1pbi54IC0gYm9keS5wb3NpdGlvbi54KSAvIChib2R5LmJvdW5kcy5tYXgueCAtIGJvZHkuYm91bmRzLm1pbi54KTtcclxuICAgICAgICBib2R5LnJlbmRlci5zcHJpdGUueU9mZnNldCArPSAtKGJvZHkuYm91bmRzLm1pbi55IC0gYm9keS5wb3NpdGlvbi55KSAvIChib2R5LmJvdW5kcy5tYXgueSAtIGJvZHkuYm91bmRzLm1pbi55KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHByb3BlcnR5IGFuZCBhIHZhbHVlIChvciBtYXAgb2YpLCBzZXRzIHRoZSBwcm9wZXJ0eShzKSBvbiB0aGUgYm9keSwgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIHNldHRlciBmdW5jdGlvbnMgaWYgdGhleSBleGlzdC5cclxuICAgICAqIFByZWZlciB0byB1c2UgdGhlIGFjdHVhbCBzZXR0ZXIgZnVuY3Rpb25zIGluIHBlcmZvcm1hbmNlIGNyaXRpY2FsIHNpdHVhdGlvbnMuXHJcbiAgICAgKiBAbWV0aG9kIHNldFxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge30gc2V0dGluZ3MgQSBwcm9wZXJ0eSBuYW1lIChvciBtYXAgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzKSB0byBzZXQgb24gdGhlIGJvZHkuXHJcbiAgICAgKiBAcGFyYW0ge30gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCBpZiBgc2V0dGluZ3NgIGlzIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2V0ID0gZnVuY3Rpb24oYm9keSwgc2V0dGluZ3MsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHByb3BlcnR5O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHNldHRpbmdzO1xyXG4gICAgICAgICAgICBzZXR0aW5ncyA9IHt9O1xyXG4gICAgICAgICAgICBzZXR0aW5nc1twcm9wZXJ0eV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5nc1twcm9wZXJ0eV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnaXNTdGF0aWMnOlxyXG4gICAgICAgICAgICAgICAgQm9keS5zZXRTdGF0aWMoYm9keSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2lzU2xlZXBpbmcnOlxyXG4gICAgICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtYXNzJzpcclxuICAgICAgICAgICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGVuc2l0eSc6XHJcbiAgICAgICAgICAgICAgICBCb2R5LnNldERlbnNpdHkoYm9keSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2luZXJ0aWEnOlxyXG4gICAgICAgICAgICAgICAgQm9keS5zZXRJbmVydGlhKGJvZHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd2ZXJ0aWNlcyc6XHJcbiAgICAgICAgICAgICAgICBCb2R5LnNldFZlcnRpY2VzKGJvZHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdwb3NpdGlvbic6XHJcbiAgICAgICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdhbmdsZSc6XHJcbiAgICAgICAgICAgICAgICBCb2R5LnNldEFuZ2xlKGJvZHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd2ZWxvY2l0eSc6XHJcbiAgICAgICAgICAgICAgICBCb2R5LnNldFZlbG9jaXR5KGJvZHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdhbmd1bGFyVmVsb2NpdHknOlxyXG4gICAgICAgICAgICAgICAgQm9keS5zZXRBbmd1bGFyVmVsb2NpdHkoYm9keSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3BhcnRzJzpcclxuICAgICAgICAgICAgICAgIEJvZHkuc2V0UGFydHMoYm9keSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBib2R5W3Byb3BlcnR5XSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBib2R5IGFzIHN0YXRpYywgaW5jbHVkaW5nIGlzU3RhdGljIGZsYWcgYW5kIHNldHRpbmcgbWFzcyBhbmQgaW5lcnRpYSB0byBJbmZpbml0eS5cclxuICAgICAqIEBtZXRob2Qgc2V0U3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gaXNTdGF0aWNcclxuICAgICAqL1xyXG4gICAgQm9keS5zZXRTdGF0aWMgPSBmdW5jdGlvbihib2R5LCBpc1N0YXRpYykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV07XHJcbiAgICAgICAgICAgIHBhcnQuaXNTdGF0aWMgPSBpc1N0YXRpYztcclxuXHJcbiAgICAgICAgICAgIGlmIChpc1N0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgcGFydC5fb3JpZ2luYWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdGl0dXRpb246IHBhcnQucmVzdGl0dXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb246IHBhcnQuZnJpY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgbWFzczogcGFydC5tYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWE6IHBhcnQuaW5lcnRpYSxcclxuICAgICAgICAgICAgICAgICAgICBkZW5zaXR5OiBwYXJ0LmRlbnNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZU1hc3M6IHBhcnQuaW52ZXJzZU1hc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUluZXJ0aWE6IHBhcnQuaW52ZXJzZUluZXJ0aWFcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgcGFydC5yZXN0aXR1dGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LmZyaWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgIHBhcnQubWFzcyA9IHBhcnQuaW5lcnRpYSA9IHBhcnQuZGVuc2l0eSA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICAgICAgcGFydC5pbnZlcnNlTWFzcyA9IHBhcnQuaW52ZXJzZUluZXJ0aWEgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb25QcmV2LnggPSBwYXJ0LnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uUHJldi55ID0gcGFydC5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgcGFydC5hbmdsZVByZXYgPSBwYXJ0LmFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgcGFydC5hbmd1bGFyVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgcGFydC5zcGVlZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LmFuZ3VsYXJTcGVlZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBwYXJ0Lm1vdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC5fb3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHBhcnQucmVzdGl0dXRpb24gPSBwYXJ0Ll9vcmlnaW5hbC5yZXN0aXR1dGlvbjtcclxuICAgICAgICAgICAgICAgIHBhcnQuZnJpY3Rpb24gPSBwYXJ0Ll9vcmlnaW5hbC5mcmljdGlvbjtcclxuICAgICAgICAgICAgICAgIHBhcnQubWFzcyA9IHBhcnQuX29yaWdpbmFsLm1hc3M7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LmluZXJ0aWEgPSBwYXJ0Ll9vcmlnaW5hbC5pbmVydGlhO1xyXG4gICAgICAgICAgICAgICAgcGFydC5kZW5zaXR5ID0gcGFydC5fb3JpZ2luYWwuZGVuc2l0eTtcclxuICAgICAgICAgICAgICAgIHBhcnQuaW52ZXJzZU1hc3MgPSBwYXJ0Ll9vcmlnaW5hbC5pbnZlcnNlTWFzcztcclxuICAgICAgICAgICAgICAgIHBhcnQuaW52ZXJzZUluZXJ0aWEgPSBwYXJ0Ll9vcmlnaW5hbC5pbnZlcnNlSW5lcnRpYTtcclxuXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFydC5fb3JpZ2luYWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFzcyBvZiB0aGUgYm9keS4gSW52ZXJzZSBtYXNzIGFuZCBkZW5zaXR5IGFyZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlLlxyXG4gICAgICogQG1ldGhvZCBzZXRNYXNzXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNzXHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2V0TWFzcyA9IGZ1bmN0aW9uKGJvZHksIG1hc3MpIHtcclxuICAgICAgICBib2R5Lm1hc3MgPSBtYXNzO1xyXG4gICAgICAgIGJvZHkuaW52ZXJzZU1hc3MgPSAxIC8gYm9keS5tYXNzO1xyXG4gICAgICAgIGJvZHkuZGVuc2l0eSA9IGJvZHkubWFzcyAvIGJvZHkuYXJlYTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBkZW5zaXR5IG9mIHRoZSBib2R5LiBNYXNzIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjaGFuZ2UuXHJcbiAgICAgKiBAbWV0aG9kIHNldERlbnNpdHlcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbnNpdHlcclxuICAgICAqL1xyXG4gICAgQm9keS5zZXREZW5zaXR5ID0gZnVuY3Rpb24oYm9keSwgZGVuc2l0eSkge1xyXG4gICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCBkZW5zaXR5ICogYm9keS5hcmVhKTtcclxuICAgICAgICBib2R5LmRlbnNpdHkgPSBkZW5zaXR5O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1vbWVudCBvZiBpbmVydGlhIChpLmUuIHNlY29uZCBtb21lbnQgb2YgYXJlYSkgb2YgdGhlIGJvZHkgb2YgdGhlIGJvZHkuIFxyXG4gICAgICogSW52ZXJzZSBpbmVydGlhIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjaGFuZ2UuIE1hc3MgaXMgbm90IGNoYW5nZWQuXHJcbiAgICAgKiBAbWV0aG9kIHNldEluZXJ0aWFcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZXJ0aWFcclxuICAgICAqL1xyXG4gICAgQm9keS5zZXRJbmVydGlhID0gZnVuY3Rpb24oYm9keSwgaW5lcnRpYSkge1xyXG4gICAgICAgIGJvZHkuaW5lcnRpYSA9IGluZXJ0aWE7XHJcbiAgICAgICAgYm9keS5pbnZlcnNlSW5lcnRpYSA9IDEgLyBib2R5LmluZXJ0aWE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYm9keSdzIHZlcnRpY2VzIGFuZCB1cGRhdGVzIGJvZHkgcHJvcGVydGllcyBhY2NvcmRpbmdseSwgaW5jbHVkaW5nIGluZXJ0aWEsIGFyZWEgYW5kIG1hc3MgKHdpdGggcmVzcGVjdCB0byBgYm9keS5kZW5zaXR5YCkuXHJcbiAgICAgKiBWZXJ0aWNlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdHJhbnNmb3JtZWQgdG8gYmUgb3JpZW50YXRlZCBhcm91bmQgdGhlaXIgY2VudHJlIG9mIG1hc3MgYXMgdGhlIG9yaWdpbi5cclxuICAgICAqIFRoZXkgYXJlIHRoZW4gYXV0b21hdGljYWxseSB0cmFuc2xhdGVkIHRvIHdvcmxkIHNwYWNlIGJhc2VkIG9uIGBib2R5LnBvc2l0aW9uYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYHZlcnRpY2VzYCBhcmd1bWVudCBzaG91bGQgYmUgcGFzc2VkIGFzIGFuIGFycmF5IG9mIGBNYXR0ZXIuVmVjdG9yYCBwb2ludHMgKG9yIGEgYE1hdHRlci5WZXJ0aWNlc2AgYXJyYXkpLlxyXG4gICAgICogVmVydGljZXMgbXVzdCBmb3JtIGEgY29udmV4IGh1bGwsIGNvbmNhdmUgaHVsbHMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBzZXRWZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge3ZlY3RvcltdfSB2ZXJ0aWNlc1xyXG4gICAgICovXHJcbiAgICBCb2R5LnNldFZlcnRpY2VzID0gZnVuY3Rpb24oYm9keSwgdmVydGljZXMpIHtcclxuICAgICAgICAvLyBjaGFuZ2UgdmVydGljZXNcclxuICAgICAgICBpZiAodmVydGljZXNbMF0uYm9keSA9PT0gYm9keSkge1xyXG4gICAgICAgICAgICBib2R5LnZlcnRpY2VzID0gdmVydGljZXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYm9keS52ZXJ0aWNlcyA9IFZlcnRpY2VzLmNyZWF0ZSh2ZXJ0aWNlcywgYm9keSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1cGRhdGUgcHJvcGVydGllc1xyXG4gICAgICAgIGJvZHkuYXhlcyA9IEF4ZXMuZnJvbVZlcnRpY2VzKGJvZHkudmVydGljZXMpO1xyXG4gICAgICAgIGJvZHkuYXJlYSA9IFZlcnRpY2VzLmFyZWEoYm9keS52ZXJ0aWNlcyk7XHJcbiAgICAgICAgQm9keS5zZXRNYXNzKGJvZHksIGJvZHkuZGVuc2l0eSAqIGJvZHkuYXJlYSk7XHJcblxyXG4gICAgICAgIC8vIG9yaWVudCB2ZXJ0aWNlcyBhcm91bmQgdGhlIGNlbnRyZSBvZiBtYXNzIGF0IG9yaWdpbiAoMCwgMClcclxuICAgICAgICB2YXIgY2VudHJlID0gVmVydGljZXMuY2VudHJlKGJvZHkudmVydGljZXMpO1xyXG4gICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShib2R5LnZlcnRpY2VzLCBjZW50cmUsIC0xKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGluZXJ0aWEgd2hpbGUgdmVydGljZXMgYXJlIGF0IG9yaWdpbiAoMCwgMClcclxuICAgICAgICBCb2R5LnNldEluZXJ0aWEoYm9keSwgQm9keS5faW5lcnRpYVNjYWxlICogVmVydGljZXMuaW5lcnRpYShib2R5LnZlcnRpY2VzLCBib2R5Lm1hc3MpKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGdlb21ldHJ5XHJcbiAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKGJvZHkudmVydGljZXMsIGJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgIEJvdW5kcy51cGRhdGUoYm9keS5ib3VuZHMsIGJvZHkudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBhcnRzIG9mIHRoZSBgYm9keWAgYW5kIHVwZGF0ZXMgbWFzcywgaW5lcnRpYSBhbmQgY2VudHJvaWQuXHJcbiAgICAgKiBFYWNoIHBhcnQgd2lsbCBoYXZlIGl0cyBwYXJlbnQgc2V0IHRvIGBib2R5YC5cclxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGNvbnZleCBodWxsIHdpbGwgYmUgYXV0b21hdGljYWxseSBjb21wdXRlZCBhbmQgc2V0IG9uIGBib2R5YCwgdW5sZXNzIGBhdXRvSHVsbGAgaXMgc2V0IHRvIGBmYWxzZS5gXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgd2lsbCBlbnN1cmUgdGhhdCB0aGUgZmlyc3QgcGFydCBpbiBgYm9keS5wYXJ0c2Agd2lsbCBhbHdheXMgYmUgdGhlIGBib2R5YC5cclxuICAgICAqIEBtZXRob2Qgc2V0UGFydHNcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIFtib2R5XSBwYXJ0c1xyXG4gICAgICogQHBhcmFtIHtib29sfSBbYXV0b0h1bGw9dHJ1ZV1cclxuICAgICAqL1xyXG4gICAgQm9keS5zZXRQYXJ0cyA9IGZ1bmN0aW9uKGJvZHksIHBhcnRzLCBhdXRvSHVsbCkge1xyXG4gICAgICAgIHZhciBpO1xyXG5cclxuICAgICAgICAvLyBhZGQgYWxsIHRoZSBwYXJ0cywgZW5zdXJpbmcgdGhhdCB0aGUgZmlyc3QgcGFydCBpcyBhbHdheXMgdGhlIHBhcmVudCBib2R5XHJcbiAgICAgICAgcGFydHMgPSBwYXJ0cy5zbGljZSgwKTtcclxuICAgICAgICBib2R5LnBhcnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgYm9keS5wYXJ0cy5wdXNoKGJvZHkpO1xyXG4gICAgICAgIGJvZHkucGFyZW50ID0gYm9keTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XHJcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSBib2R5KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LnBhcmVudCA9IGJvZHk7XHJcbiAgICAgICAgICAgICAgICBib2R5LnBhcnRzLnB1c2gocGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChib2R5LnBhcnRzLmxlbmd0aCA9PT0gMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBhdXRvSHVsbCA9IHR5cGVvZiBhdXRvSHVsbCAhPT0gJ3VuZGVmaW5lZCcgPyBhdXRvSHVsbCA6IHRydWU7XHJcblxyXG4gICAgICAgIC8vIGZpbmQgdGhlIGNvbnZleCBodWxsIG9mIGFsbCBwYXJ0cyB0byBzZXQgb24gdGhlIHBhcmVudCBib2R5XHJcbiAgICAgICAgaWYgKGF1dG9IdWxsKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KHBhcnRzW2ldLnZlcnRpY2VzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVydGljZXMuY2xvY2t3aXNlU29ydCh2ZXJ0aWNlcyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaHVsbCA9IFZlcnRpY2VzLmh1bGwodmVydGljZXMpLFxyXG4gICAgICAgICAgICAgICAgaHVsbENlbnRyZSA9IFZlcnRpY2VzLmNlbnRyZShodWxsKTtcclxuXHJcbiAgICAgICAgICAgIEJvZHkuc2V0VmVydGljZXMoYm9keSwgaHVsbCk7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShib2R5LnZlcnRpY2VzLCBodWxsQ2VudHJlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHN1bSB0aGUgcHJvcGVydGllcyBvZiBhbGwgY29tcG91bmQgcGFydHMgb2YgdGhlIHBhcmVudCBib2R5XHJcbiAgICAgICAgdmFyIHRvdGFsID0gX3RvdGFsUHJvcGVydGllcyhib2R5KTtcclxuXHJcbiAgICAgICAgYm9keS5hcmVhID0gdG90YWwuYXJlYTtcclxuICAgICAgICBib2R5LnBhcmVudCA9IGJvZHk7XHJcbiAgICAgICAgYm9keS5wb3NpdGlvbi54ID0gdG90YWwuY2VudHJlLng7XHJcbiAgICAgICAgYm9keS5wb3NpdGlvbi55ID0gdG90YWwuY2VudHJlLnk7XHJcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCA9IHRvdGFsLmNlbnRyZS54O1xyXG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSB0b3RhbC5jZW50cmUueTtcclxuXHJcbiAgICAgICAgQm9keS5zZXRNYXNzKGJvZHksIHRvdGFsLm1hc3MpO1xyXG4gICAgICAgIEJvZHkuc2V0SW5lcnRpYShib2R5LCB0b3RhbC5pbmVydGlhKTtcclxuICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHRvdGFsLmNlbnRyZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGJvZHkgaW5zdGFudGx5LiBWZWxvY2l0eSwgYW5nbGUsIGZvcmNlIGV0Yy4gYXJlIHVuY2hhbmdlZC5cclxuICAgICAqIEBtZXRob2Qgc2V0UG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihib2R5LCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBkZWx0YSA9IFZlY3Rvci5zdWIocG9zaXRpb24sIGJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggKz0gZGVsdGEueDtcclxuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ICs9IGRlbHRhLnk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV07XHJcbiAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueCArPSBkZWx0YS54O1xyXG4gICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnkgKz0gZGVsdGEueTtcclxuICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKHBhcnQudmVydGljZXMsIGRlbHRhKTtcclxuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGFuZ2xlIG9mIHRoZSBib2R5IGluc3RhbnRseS4gQW5ndWxhciB2ZWxvY2l0eSwgcG9zaXRpb24sIGZvcmNlIGV0Yy4gYXJlIHVuY2hhbmdlZC5cclxuICAgICAqIEBtZXRob2Qgc2V0QW5nbGVcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2V0QW5nbGUgPSBmdW5jdGlvbihib2R5LCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBkZWx0YSA9IGFuZ2xlIC0gYm9keS5hbmdsZTtcclxuICAgICAgICBib2R5LmFuZ2xlUHJldiArPSBkZWx0YTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXTtcclxuICAgICAgICAgICAgcGFydC5hbmdsZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgVmVydGljZXMucm90YXRlKHBhcnQudmVydGljZXMsIGRlbHRhLCBib2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgQXhlcy5yb3RhdGUocGFydC5heGVzLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIEJvdW5kcy51cGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgIFZlY3Rvci5yb3RhdGVBYm91dChwYXJ0LnBvc2l0aW9uLCBkZWx0YSwgYm9keS5wb3NpdGlvbiwgcGFydC5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBib2R5IGluc3RhbnRseS4gUG9zaXRpb24sIGFuZ2xlLCBmb3JjZSBldGMuIGFyZSB1bmNoYW5nZWQuIFNlZSBhbHNvIGBCb2R5LmFwcGx5Rm9yY2VgLlxyXG4gICAgICogQG1ldGhvZCBzZXRWZWxvY2l0eVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVsb2NpdHlcclxuICAgICAqL1xyXG4gICAgQm9keS5zZXRWZWxvY2l0eSA9IGZ1bmN0aW9uKGJvZHksIHZlbG9jaXR5KSB7XHJcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCA9IGJvZHkucG9zaXRpb24ueCAtIHZlbG9jaXR5Lng7XHJcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSA9IGJvZHkucG9zaXRpb24ueSAtIHZlbG9jaXR5Lnk7XHJcbiAgICAgICAgYm9keS52ZWxvY2l0eS54ID0gdmVsb2NpdHkueDtcclxuICAgICAgICBib2R5LnZlbG9jaXR5LnkgPSB2ZWxvY2l0eS55O1xyXG4gICAgICAgIGJvZHkuc3BlZWQgPSBWZWN0b3IubWFnbml0dWRlKGJvZHkudmVsb2NpdHkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHkgaW5zdGFudGx5LiBQb3NpdGlvbiwgYW5nbGUsIGZvcmNlIGV0Yy4gYXJlIHVuY2hhbmdlZC4gU2VlIGFsc28gYEJvZHkuYXBwbHlGb3JjZWAuXHJcbiAgICAgKiBAbWV0aG9kIHNldEFuZ3VsYXJWZWxvY2l0eVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmVsb2NpdHlcclxuICAgICAqL1xyXG4gICAgQm9keS5zZXRBbmd1bGFyVmVsb2NpdHkgPSBmdW5jdGlvbihib2R5LCB2ZWxvY2l0eSkge1xyXG4gICAgICAgIGJvZHkuYW5nbGVQcmV2ID0gYm9keS5hbmdsZSAtIHZlbG9jaXR5O1xyXG4gICAgICAgIGJvZHkuYW5ndWxhclZlbG9jaXR5ID0gdmVsb2NpdHk7XHJcbiAgICAgICAgYm9keS5hbmd1bGFyU3BlZWQgPSBNYXRoLmFicyhib2R5LmFuZ3VsYXJWZWxvY2l0eSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgYSBib2R5IGJ5IGEgZ2l2ZW4gdmVjdG9yIHJlbGF0aXZlIHRvIGl0cyBjdXJyZW50IHBvc2l0aW9uLCB3aXRob3V0IGltcGFydGluZyBhbnkgdmVsb2NpdHkuXHJcbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0ZVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdHJhbnNsYXRpb25cclxuICAgICAqL1xyXG4gICAgQm9keS50cmFuc2xhdGUgPSBmdW5jdGlvbihib2R5LCB0cmFuc2xhdGlvbikge1xyXG4gICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwgVmVjdG9yLmFkZChib2R5LnBvc2l0aW9uLCB0cmFuc2xhdGlvbikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZXMgYSBib2R5IGJ5IGEgZ2l2ZW4gYW5nbGUgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgYW5nbGUsIHdpdGhvdXQgaW1wYXJ0aW5nIGFueSBhbmd1bGFyIHZlbG9jaXR5LlxyXG4gICAgICogQG1ldGhvZCByb3RhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uXHJcbiAgICAgKi9cclxuICAgIEJvZHkucm90YXRlID0gZnVuY3Rpb24oYm9keSwgcm90YXRpb24pIHtcclxuICAgICAgICBCb2R5LnNldEFuZ2xlKGJvZHksIGJvZHkuYW5nbGUgKyByb3RhdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoZSBib2R5LCBpbmNsdWRpbmcgdXBkYXRpbmcgcGh5c2ljYWwgcHJvcGVydGllcyAobWFzcywgYXJlYSwgYXhlcywgaW5lcnRpYSksIGZyb20gYSB3b3JsZC1zcGFjZSBwb2ludCAoZGVmYXVsdCBpcyBib2R5IGNlbnRyZSkuXHJcbiAgICAgKiBAbWV0aG9kIHNjYWxlXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVlcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBbcG9pbnRdXHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2NhbGUgPSBmdW5jdGlvbihib2R5LCBzY2FsZVgsIHNjYWxlWSwgcG9pbnQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gc2NhbGUgdmVydGljZXNcclxuICAgICAgICAgICAgVmVydGljZXMuc2NhbGUocGFydC52ZXJ0aWNlcywgc2NhbGVYLCBzY2FsZVksIGJvZHkucG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgLy8gdXBkYXRlIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgcGFydC5heGVzID0gQXhlcy5mcm9tVmVydGljZXMocGFydC52ZXJ0aWNlcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWJvZHkuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgIHBhcnQuYXJlYSA9IFZlcnRpY2VzLmFyZWEocGFydC52ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgICAgICBCb2R5LnNldE1hc3MocGFydCwgYm9keS5kZW5zaXR5ICogcGFydC5hcmVhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaW5lcnRpYSAocmVxdWlyZXMgdmVydGljZXMgdG8gYmUgYXQgb3JpZ2luKVxyXG4gICAgICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKHBhcnQudmVydGljZXMsIHsgeDogLXBhcnQucG9zaXRpb24ueCwgeTogLXBhcnQucG9zaXRpb24ueSB9KTtcclxuICAgICAgICAgICAgICAgIEJvZHkuc2V0SW5lcnRpYShwYXJ0LCBWZXJ0aWNlcy5pbmVydGlhKHBhcnQudmVydGljZXMsIHBhcnQubWFzcykpO1xyXG4gICAgICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKHBhcnQudmVydGljZXMsIHsgeDogcGFydC5wb3NpdGlvbi54LCB5OiBwYXJ0LnBvc2l0aW9uLnkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBib3VuZHNcclxuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBoYW5kbGUgY2lyY2xlc1xyXG4gICAgICAgIGlmIChib2R5LmNpcmNsZVJhZGl1cykgeyBcclxuICAgICAgICAgICAgaWYgKHNjYWxlWCA9PT0gc2NhbGVZKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5LmNpcmNsZVJhZGl1cyAqPSBzY2FsZVg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBib2R5IGlzIG5vIGxvbmdlciBhIGNpcmNsZVxyXG4gICAgICAgICAgICAgICAgYm9keS5jaXJjbGVSYWRpdXMgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWJvZHkuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgdmFyIHRvdGFsID0gX3RvdGFsUHJvcGVydGllcyhib2R5KTtcclxuICAgICAgICAgICAgYm9keS5hcmVhID0gdG90YWwuYXJlYTtcclxuICAgICAgICAgICAgQm9keS5zZXRNYXNzKGJvZHksIHRvdGFsLm1hc3MpO1xyXG4gICAgICAgICAgICBCb2R5LnNldEluZXJ0aWEoYm9keSwgdG90YWwuaW5lcnRpYSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgc2ltdWxhdGlvbiBzdGVwIGZvciB0aGUgZ2l2ZW4gYGJvZHlgLCBpbmNsdWRpbmcgdXBkYXRpbmcgcG9zaXRpb24gYW5kIGFuZ2xlIHVzaW5nIFZlcmxldCBpbnRlZ3JhdGlvbi5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3JyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIEJvZHkudXBkYXRlID0gZnVuY3Rpb24oYm9keSwgZGVsdGFUaW1lLCB0aW1lU2NhbGUsIGNvcnJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgZGVsdGFUaW1lU3F1YXJlZCA9IE1hdGgucG93KGRlbHRhVGltZSAqIHRpbWVTY2FsZSAqIGJvZHkudGltZVNjYWxlLCAyKTtcclxuXHJcbiAgICAgICAgLy8gZnJvbSB0aGUgcHJldmlvdXMgc3RlcFxyXG4gICAgICAgIHZhciBmcmljdGlvbkFpciA9IDEgLSBib2R5LmZyaWN0aW9uQWlyICogdGltZVNjYWxlICogYm9keS50aW1lU2NhbGUsXHJcbiAgICAgICAgICAgIHZlbG9jaXR5UHJldlggPSBib2R5LnBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uUHJldi54LFxyXG4gICAgICAgICAgICB2ZWxvY2l0eVByZXZZID0gYm9keS5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvblByZXYueTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5IHdpdGggVmVybGV0IGludGVncmF0aW9uXHJcbiAgICAgICAgYm9keS52ZWxvY2l0eS54ID0gKHZlbG9jaXR5UHJldlggKiBmcmljdGlvbkFpciAqIGNvcnJlY3Rpb24pICsgKGJvZHkuZm9yY2UueCAvIGJvZHkubWFzcykgKiBkZWx0YVRpbWVTcXVhcmVkO1xyXG4gICAgICAgIGJvZHkudmVsb2NpdHkueSA9ICh2ZWxvY2l0eVByZXZZICogZnJpY3Rpb25BaXIgKiBjb3JyZWN0aW9uKSArIChib2R5LmZvcmNlLnkgLyBib2R5Lm1hc3MpICogZGVsdGFUaW1lU3F1YXJlZDtcclxuXHJcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCA9IGJvZHkucG9zaXRpb24ueDtcclxuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ID0gYm9keS5wb3NpdGlvbi55O1xyXG4gICAgICAgIGJvZHkucG9zaXRpb24ueCArPSBib2R5LnZlbG9jaXR5Lng7XHJcbiAgICAgICAgYm9keS5wb3NpdGlvbi55ICs9IGJvZHkudmVsb2NpdHkueTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGFuZ3VsYXIgdmVsb2NpdHkgd2l0aCBWZXJsZXQgaW50ZWdyYXRpb25cclxuICAgICAgICBib2R5LmFuZ3VsYXJWZWxvY2l0eSA9ICgoYm9keS5hbmdsZSAtIGJvZHkuYW5nbGVQcmV2KSAqIGZyaWN0aW9uQWlyICogY29ycmVjdGlvbikgKyAoYm9keS50b3JxdWUgLyBib2R5LmluZXJ0aWEpICogZGVsdGFUaW1lU3F1YXJlZDtcclxuICAgICAgICBib2R5LmFuZ2xlUHJldiA9IGJvZHkuYW5nbGU7XHJcbiAgICAgICAgYm9keS5hbmdsZSArPSBib2R5LmFuZ3VsYXJWZWxvY2l0eTtcclxuXHJcbiAgICAgICAgLy8gdHJhY2sgc3BlZWQgYW5kIGFjY2VsZXJhdGlvblxyXG4gICAgICAgIGJvZHkuc3BlZWQgPSBWZWN0b3IubWFnbml0dWRlKGJvZHkudmVsb2NpdHkpO1xyXG4gICAgICAgIGJvZHkuYW5ndWxhclNwZWVkID0gTWF0aC5hYnMoYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xyXG5cclxuICAgICAgICAvLyB0cmFuc2Zvcm0gdGhlIGJvZHkgZ2VvbWV0cnlcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnggKz0gYm9keS52ZWxvY2l0eS54O1xyXG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi55ICs9IGJvZHkudmVsb2NpdHkueTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGJvZHkuYW5ndWxhclZlbG9jaXR5ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcy5yb3RhdGUocGFydC52ZXJ0aWNlcywgYm9keS5hbmd1bGFyVmVsb2NpdHksIGJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgQXhlcy5yb3RhdGUocGFydC5heGVzLCBib2R5LmFuZ3VsYXJWZWxvY2l0eSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3Iucm90YXRlQWJvdXQocGFydC5wb3NpdGlvbiwgYm9keS5hbmd1bGFyVmVsb2NpdHksIGJvZHkucG9zaXRpb24sIHBhcnQucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhIGZvcmNlIHRvIGEgYm9keSBmcm9tIGEgZ2l2ZW4gd29ybGQtc3BhY2UgcG9zaXRpb24sIGluY2x1ZGluZyByZXN1bHRpbmcgdG9ycXVlLlxyXG4gICAgICogQG1ldGhvZCBhcHBseUZvcmNlXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IGZvcmNlXHJcbiAgICAgKi9cclxuICAgIEJvZHkuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKGJvZHksIHBvc2l0aW9uLCBmb3JjZSkge1xyXG4gICAgICAgIGJvZHkuZm9yY2UueCArPSBmb3JjZS54O1xyXG4gICAgICAgIGJvZHkuZm9yY2UueSArPSBmb3JjZS55O1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSB7IHg6IHBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnkgLSBib2R5LnBvc2l0aW9uLnkgfTtcclxuICAgICAgICBib2R5LnRvcnF1ZSArPSBvZmZzZXQueCAqIGZvcmNlLnkgLSBvZmZzZXQueSAqIGZvcmNlLng7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3VtcyBvZiB0aGUgcHJvcGVydGllcyBvZiBhbGwgY29tcG91bmQgcGFydHMgb2YgdGhlIHBhcmVudCBib2R5LlxyXG4gICAgICogQG1ldGhvZCBfdG90YWxQcm9wZXJ0aWVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcmV0dXJuIHt9XHJcbiAgICAgKi9cclxuICAgIHZhciBfdG90YWxQcm9wZXJ0aWVzID0gZnVuY3Rpb24oYm9keSkge1xyXG4gICAgICAgIC8vIGh0dHBzOi8vZWNvdXJzZXMub3UuZWR1L2NnaS1iaW4vZWJvb2suY2dpP2RvYz0mdG9waWM9c3QmY2hhcF9zZWM9MDcuMiZwYWdlPXRoZW9yeVxyXG4gICAgICAgIC8vIGh0dHA6Ly9vdXRwdXQudG8vc2lkZXdheS9kZWZhdWx0LmFzcD9xbm89MTIxMTAwMDg3XHJcblxyXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBtYXNzOiAwLFxyXG4gICAgICAgICAgICBhcmVhOiAwLFxyXG4gICAgICAgICAgICBpbmVydGlhOiAwLFxyXG4gICAgICAgICAgICBjZW50cmU6IHsgeDogMCwgeTogMCB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gc3VtIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCBjb21wb3VuZCBwYXJ0cyBvZiB0aGUgcGFyZW50IGJvZHlcclxuICAgICAgICBmb3IgKHZhciBpID0gYm9keS5wYXJ0cy5sZW5ndGggPT09IDEgPyAwIDogMTsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLm1hc3MgKz0gcGFydC5tYXNzO1xyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmFyZWEgKz0gcGFydC5hcmVhO1xyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmluZXJ0aWEgKz0gcGFydC5pbmVydGlhO1xyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmNlbnRyZSA9IFZlY3Rvci5hZGQocHJvcGVydGllcy5jZW50cmUsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yLm11bHQocGFydC5wb3NpdGlvbiwgcGFydC5tYXNzICE9PSBJbmZpbml0eSA/IHBhcnQubWFzcyA6IDEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3BlcnRpZXMuY2VudHJlID0gVmVjdG9yLmRpdihwcm9wZXJ0aWVzLmNlbnRyZSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMubWFzcyAhPT0gSW5maW5pdHkgPyBwcm9wZXJ0aWVzLm1hc3MgOiBib2R5LnBhcnRzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgRXZlbnRzIERvY3VtZW50YXRpb25cclxuICAgICpcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIHdoZW4gYSBib2R5IHN0YXJ0cyBzbGVlcGluZyAod2hlcmUgYHRoaXNgIGlzIHRoZSBib2R5KS5cclxuICAgICpcclxuICAgICogQGV2ZW50IHNsZWVwU3RhcnRcclxuICAgICogQHRoaXMge2JvZHl9IFRoZSBib2R5IHRoYXQgaGFzIHN0YXJ0ZWQgc2xlZXBpbmdcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGVuZHMgc2xlZXBpbmcgKHdoZXJlIGB0aGlzYCBpcyB0aGUgYm9keSkuXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBzbGVlcEVuZFxyXG4gICAgKiBAdGhpcyB7Ym9keX0gVGhlIGJvZHkgdGhhdCBoYXMgZW5kZWQgc2xlZXBpbmdcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLypcclxuICAgICpcclxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxyXG4gICAgKlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdW5pcXVlbHkgaWRlbnRpZnlpbmcgbnVtYmVyIGdlbmVyYXRlZCBpbiBgQm9keS5jcmVhdGVgIGJ5IGBDb21tb24ubmV4dElkYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgaWRcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBTdHJpbmdgIGRlbm90aW5nIHRoZSB0eXBlIG9mIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxyXG4gICAgICogQHR5cGUgc3RyaW5nXHJcbiAgICAgKiBAZGVmYXVsdCBcImJvZHlcIlxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFyYml0cmFyeSBgU3RyaW5nYCBuYW1lIHRvIGhlbHAgdGhlIHVzZXIgaWRlbnRpZnkgYW5kIG1hbmFnZSBib2RpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGxhYmVsXHJcbiAgICAgKiBAdHlwZSBzdHJpbmdcclxuICAgICAqIEBkZWZhdWx0IFwiQm9keVwiXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIGJvZGllcyB0aGF0IG1ha2UgdXAgdGhpcyBib2R5LiBcclxuICAgICAqIFRoZSBmaXJzdCBib2R5IGluIHRoZSBhcnJheSBtdXN0IGFsd2F5cyBiZSBhIHNlbGYgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGJvZHkgaW5zdGFuY2UuXHJcbiAgICAgKiBBbGwgYm9kaWVzIGluIHRoZSBgcGFydHNgIGFycmF5IHRvZ2V0aGVyIGZvcm0gYSBzaW5nbGUgcmlnaWQgY29tcG91bmQgYm9keS5cclxuICAgICAqIFBhcnRzIGFyZSBhbGxvd2VkIHRvIG92ZXJsYXAsIGhhdmUgZ2FwcyBvciBob2xlcyBvciBldmVuIGZvcm0gY29uY2F2ZSBib2RpZXMuXHJcbiAgICAgKiBQYXJ0cyB0aGVtc2VsdmVzIHNob3VsZCBuZXZlciBiZSBhZGRlZCB0byBhIGBXb3JsZGAsIG9ubHkgdGhlIHBhcmVudCBib2R5IHNob3VsZCBiZS5cclxuICAgICAqIFVzZSBgQm9keS5zZXRQYXJ0c2Agd2hlbiBzZXR0aW5nIHBhcnRzIHRvIGVuc3VyZSBjb3JyZWN0IHVwZGF0ZXMgb2YgYWxsIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHBhcnRzXHJcbiAgICAgKiBAdHlwZSBib2R5W11cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gb2JqZWN0IHJlc2VydmVkIGZvciBzdG9yaW5nIHBsdWdpbi1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5cclxuICAgICAqIEB0eXBlIHt9XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc2VsZiByZWZlcmVuY2UgaWYgdGhlIGJvZHkgaXMgX25vdF8gYSBwYXJ0IG9mIGFub3RoZXIgYm9keS5cclxuICAgICAqIE90aGVyd2lzZSB0aGlzIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBib2R5IHRoYXQgdGhpcyBpcyBhIHBhcnQgb2YuXHJcbiAgICAgKiBTZWUgYGJvZHkucGFydHNgLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBwYXJlbnRcclxuICAgICAqIEB0eXBlIGJvZHlcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCBzcGVjaWZ5aW5nIHRoZSBhbmdsZSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBgVmVjdG9yYCBvYmplY3RzIHRoYXQgc3BlY2lmeSB0aGUgY29udmV4IGh1bGwgb2YgdGhlIHJpZ2lkIGJvZHkuXHJcbiAgICAgKiBUaGVzZSBzaG91bGQgYmUgcHJvdmlkZWQgYWJvdXQgdGhlIG9yaWdpbiBgKDAsIDApYC4gRS5nLlxyXG4gICAgICpcclxuICAgICAqICAgICBbeyB4OiAwLCB5OiAwIH0sIHsgeDogMjUsIHk6IDUwIH0sIHsgeDogNTAsIHk6IDAgfV1cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHBhc3NlZCB2aWEgYEJvZHkuY3JlYXRlYCwgdGhlIHZlcnRpY2VzIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIGBib2R5LnBvc2l0aW9uYCAoaS5lLiB3b3JsZC1zcGFjZSwgYW5kIGNvbnN0YW50bHkgdXBkYXRlZCBieSBgQm9keS51cGRhdGVgIGR1cmluZyBzaW11bGF0aW9uKS5cclxuICAgICAqIFRoZSBgVmVjdG9yYCBvYmplY3RzIGFyZSBhbHNvIGF1Z21lbnRlZCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyByZXF1aXJlZCBmb3IgZWZmaWNpZW50IGNvbGxpc2lvbiBkZXRlY3Rpb24uIFxyXG4gICAgICpcclxuICAgICAqIE90aGVyIHByb3BlcnRpZXMgc3VjaCBhcyBgaW5lcnRpYWAgYW5kIGBib3VuZHNgIGFyZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgZnJvbSB0aGUgcGFzc2VkIHZlcnRpY2VzICh1bmxlc3MgcHJvdmlkZWQgdmlhIGBvcHRpb25zYCkuXHJcbiAgICAgKiBDb25jYXZlIGh1bGxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4gVGhlIG1vZHVsZSBgTWF0dGVyLlZlcnRpY2VzYCBjb250YWlucyB1c2VmdWwgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIHZlcnRpY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xyXG4gICAgICogQHR5cGUgdmVjdG9yW11cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IHNwZWNpZmllcyB0aGUgY3VycmVudCB3b3JsZC1zcGFjZSBwb3NpdGlvbiBvZiB0aGUgYm9keS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cclxuICAgICAqIEB0eXBlIHZlY3RvclxyXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IHNwZWNpZmllcyB0aGUgZm9yY2UgdG8gYXBwbHkgaW4gdGhlIGN1cnJlbnQgc3RlcC4gSXQgaXMgemVyb2VkIGFmdGVyIGV2ZXJ5IGBCb2R5LnVwZGF0ZWAuIFNlZSBhbHNvIGBCb2R5LmFwcGx5Rm9yY2VgLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBmb3JjZVxyXG4gICAgICogQHR5cGUgdmVjdG9yXHJcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSB0b3JxdWUgKHR1cm5pbmcgZm9yY2UpIHRvIGFwcGx5IGluIHRoZSBjdXJyZW50IHN0ZXAuIEl0IGlzIHplcm9lZCBhZnRlciBldmVyeSBgQm9keS51cGRhdGVgLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB0b3JxdWVcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgX21lYXN1cmVzXyB0aGUgY3VycmVudCBzcGVlZCBvZiB0aGUgYm9keSBhZnRlciB0aGUgbGFzdCBgQm9keS51cGRhdGVgLiBJdCBpcyByZWFkLW9ubHkgYW5kIGFsd2F5cyBwb3NpdGl2ZSAoaXQncyB0aGUgbWFnbml0dWRlIG9mIGBib2R5LnZlbG9jaXR5YCkuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAcHJvcGVydHkgc3BlZWRcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgX21lYXN1cmVzXyB0aGUgY3VycmVudCBhbmd1bGFyIHNwZWVkIG9mIHRoZSBib2R5IGFmdGVyIHRoZSBsYXN0IGBCb2R5LnVwZGF0ZWAuIEl0IGlzIHJlYWQtb25seSBhbmQgYWx3YXlzIHBvc2l0aXZlIChpdCdzIHRoZSBtYWduaXR1ZGUgb2YgYGJvZHkuYW5ndWxhclZlbG9jaXR5YCkuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclNwZWVkXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IF9tZWFzdXJlc18gdGhlIGN1cnJlbnQgdmVsb2NpdHkgb2YgdGhlIGJvZHkgYWZ0ZXIgdGhlIGxhc3QgYEJvZHkudXBkYXRlYC4gSXQgaXMgcmVhZC1vbmx5LiBcclxuICAgICAqIElmIHlvdSBuZWVkIHRvIG1vZGlmeSBhIGJvZHkncyB2ZWxvY2l0eSBkaXJlY3RseSwgeW91IHNob3VsZCBlaXRoZXIgYXBwbHkgYSBmb3JjZSBvciBzaW1wbHkgY2hhbmdlIHRoZSBib2R5J3MgYHBvc2l0aW9uYCAoYXMgdGhlIGVuZ2luZSB1c2VzIHBvc2l0aW9uLVZlcmxldCBpbnRlZ3JhdGlvbikuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAcHJvcGVydHkgdmVsb2NpdHlcclxuICAgICAqIEB0eXBlIHZlY3RvclxyXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IF9tZWFzdXJlc18gdGhlIGN1cnJlbnQgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgYm9keSBhZnRlciB0aGUgbGFzdCBgQm9keS51cGRhdGVgLiBJdCBpcyByZWFkLW9ubHkuIFxyXG4gICAgICogSWYgeW91IG5lZWQgdG8gbW9kaWZ5IGEgYm9keSdzIGFuZ3VsYXIgdmVsb2NpdHkgZGlyZWN0bHksIHlvdSBzaG91bGQgYXBwbHkgYSB0b3JxdWUgb3Igc2ltcGx5IGNoYW5nZSB0aGUgYm9keSdzIGBhbmdsZWAgKGFzIHRoZSBlbmdpbmUgdXNlcyBwb3NpdGlvbi1WZXJsZXQgaW50ZWdyYXRpb24pLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJWZWxvY2l0eVxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgYm9keSBpcyBjb25zaWRlcmVkIHN0YXRpYy4gQSBzdGF0aWMgYm9keSBjYW4gbmV2ZXIgY2hhbmdlIHBvc2l0aW9uIG9yIGFuZ2xlIGFuZCBpcyBjb21wbGV0ZWx5IGZpeGVkLlxyXG4gICAgICogSWYgeW91IG5lZWQgdG8gc2V0IGEgYm9keSBhcyBzdGF0aWMgYWZ0ZXIgaXRzIGNyZWF0aW9uLCB5b3Ugc2hvdWxkIHVzZSBgQm9keS5zZXRTdGF0aWNgIGFzIHRoaXMgcmVxdWlyZXMgbW9yZSB0aGFuIGp1c3Qgc2V0dGluZyB0aGlzIGZsYWcuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGlzU3RhdGljXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBhIGJvZHkgaXMgYSBzZW5zb3IuIFNlbnNvciB0cmlnZ2VycyBjb2xsaXNpb24gZXZlbnRzLCBidXQgZG9lc24ndCByZWFjdCB3aXRoIGNvbGxpZGluZyBib2R5IHBoeXNpY2FsbHkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGlzU2Vuc29yXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgYm9keSBpcyBjb25zaWRlcmVkIHNsZWVwaW5nLiBBIHNsZWVwaW5nIGJvZHkgYWN0cyBzaW1pbGFyIHRvIGEgc3RhdGljIGJvZHksIGV4Y2VwdCBpdCBpcyBvbmx5IHRlbXBvcmFyeSBhbmQgY2FuIGJlIGF3b2tlbi5cclxuICAgICAqIElmIHlvdSBuZWVkIHRvIHNldCBhIGJvZHkgYXMgc2xlZXBpbmcsIHlvdSBzaG91bGQgdXNlIGBTbGVlcGluZy5zZXRgIGFzIHRoaXMgcmVxdWlyZXMgbW9yZSB0aGFuIGp1c3Qgc2V0dGluZyB0aGlzIGZsYWcuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGlzU2xlZXBpbmdcclxuICAgICAqIEB0eXBlIGJvb2xlYW5cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBfbWVhc3VyZXNfIHRoZSBhbW91bnQgb2YgbW92ZW1lbnQgYSBib2R5IGN1cnJlbnRseSBoYXMgKGEgY29tYmluYXRpb24gb2YgYHNwZWVkYCBhbmQgYGFuZ3VsYXJTcGVlZGApLiBJdCBpcyByZWFkLW9ubHkgYW5kIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAqIEl0IGlzIHVzZWQgYW5kIHVwZGF0ZWQgYnkgdGhlIGBNYXR0ZXIuU2xlZXBpbmdgIG1vZHVsZSBkdXJpbmcgc2ltdWxhdGlvbiB0byBkZWNpZGUgaWYgYSBib2R5IGhhcyBjb21lIHRvIHJlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAcHJvcGVydHkgbW90aW9uXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIG51bWJlciBvZiB1cGRhdGVzIGluIHdoaWNoIHRoaXMgYm9keSBtdXN0IGhhdmUgbmVhci16ZXJvIHZlbG9jaXR5IGJlZm9yZSBpdCBpcyBzZXQgYXMgc2xlZXBpbmcgYnkgdGhlIGBNYXR0ZXIuU2xlZXBpbmdgIG1vZHVsZSAoaWYgc2xlZXBpbmcgaXMgZW5hYmxlZCBieSB0aGUgZW5naW5lKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgc2xlZXBUaHJlc2hvbGRcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgNjBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGRlbnNpdHkgb2YgdGhlIGJvZHksIHRoYXQgaXMgaXRzIG1hc3MgcGVyIHVuaXQgYXJlYS5cclxuICAgICAqIElmIHlvdSBwYXNzIHRoZSBkZW5zaXR5IHZpYSBgQm9keS5jcmVhdGVgIHRoZSBgbWFzc2AgcHJvcGVydHkgaXMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGZvciB5b3UgYmFzZWQgb24gdGhlIHNpemUgKGFyZWEpIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBUaGlzIGlzIGdlbmVyYWxseSBwcmVmZXJhYmxlIHRvIHNpbXBseSBzZXR0aW5nIG1hc3MgYW5kIGFsbG93cyBmb3IgbW9yZSBpbnR1aXRpdmUgZGVmaW5pdGlvbiBvZiBtYXRlcmlhbHMgKGUuZy4gcm9jayBoYXMgYSBoaWdoZXIgZGVuc2l0eSB0aGFuIHdvb2QpLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBkZW5zaXR5XHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDAuMDAxXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBtYXNzIG9mIHRoZSBib2R5LCBhbHRob3VnaCBpdCBtYXkgYmUgbW9yZSBhcHByb3ByaWF0ZSB0byBzcGVjaWZ5IHRoZSBgZGVuc2l0eWAgcHJvcGVydHkgaW5zdGVhZC5cclxuICAgICAqIElmIHlvdSBtb2RpZnkgdGhpcyB2YWx1ZSwgeW91IG11c3QgYWxzbyBtb2RpZnkgdGhlIGBib2R5LmludmVyc2VNYXNzYCBwcm9wZXJ0eSAoYDEgLyBtYXNzYCkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IG1hc3NcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgaW52ZXJzZSBtYXNzIG9mIHRoZSBib2R5IChgMSAvIG1hc3NgKS5cclxuICAgICAqIElmIHlvdSBtb2RpZnkgdGhpcyB2YWx1ZSwgeW91IG11c3QgYWxzbyBtb2RpZnkgdGhlIGBib2R5Lm1hc3NgIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBpbnZlcnNlTWFzc1xyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBtb21lbnQgb2YgaW5lcnRpYSAoaS5lLiBzZWNvbmQgbW9tZW50IG9mIGFyZWEpIG9mIHRoZSBib2R5LlxyXG4gICAgICogSXQgaXMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGZyb20gdGhlIGdpdmVuIGNvbnZleCBodWxsIChgdmVydGljZXNgIGFycmF5KSBhbmQgZGVuc2l0eSBpbiBgQm9keS5jcmVhdGVgLlxyXG4gICAgICogSWYgeW91IG1vZGlmeSB0aGlzIHZhbHVlLCB5b3UgbXVzdCBhbHNvIG1vZGlmeSB0aGUgYGJvZHkuaW52ZXJzZUluZXJ0aWFgIHByb3BlcnR5IChgMSAvIGluZXJ0aWFgKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgaW5lcnRpYVxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBpbnZlcnNlIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBib2R5IChgMSAvIGluZXJ0aWFgKS5cclxuICAgICAqIElmIHlvdSBtb2RpZnkgdGhpcyB2YWx1ZSwgeW91IG11c3QgYWxzbyBtb2RpZnkgdGhlIGBib2R5LmluZXJ0aWFgIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBpbnZlcnNlSW5lcnRpYVxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSByZXN0aXR1dGlvbiAoZWxhc3RpY2l0eSkgb2YgdGhlIGJvZHkuIFRoZSB2YWx1ZSBpcyBhbHdheXMgcG9zaXRpdmUgYW5kIGlzIGluIHRoZSByYW5nZSBgKDAsIDEpYC5cclxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIGNvbGxpc2lvbnMgbWF5IGJlIHBlcmZlY3RseSBpbmVsYXN0aWMgYW5kIG5vIGJvdW5jaW5nIG1heSBvY2N1ci4gXHJcbiAgICAgKiBBIHZhbHVlIG9mIGAwLjhgIG1lYW5zIHRoZSBib2R5IG1heSBib3VuY2UgYmFjayB3aXRoIGFwcHJveGltYXRlbHkgODAlIG9mIGl0cyBraW5ldGljIGVuZXJneS5cclxuICAgICAqIE5vdGUgdGhhdCBjb2xsaXNpb24gcmVzcG9uc2UgaXMgYmFzZWQgb24gX3BhaXJzXyBvZiBib2RpZXMsIGFuZCB0aGF0IGByZXN0aXR1dGlvbmAgdmFsdWVzIGFyZSBfY29tYmluZWRfIHdpdGggdGhlIGZvbGxvd2luZyBmb3JtdWxhOlxyXG4gICAgICpcclxuICAgICAqICAgICBNYXRoLm1heChib2R5QS5yZXN0aXR1dGlvbiwgYm9keUIucmVzdGl0dXRpb24pXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGZyaWN0aW9uIG9mIHRoZSBib2R5LiBUaGUgdmFsdWUgaXMgYWx3YXlzIHBvc2l0aXZlIGFuZCBpcyBpbiB0aGUgcmFuZ2UgYCgwLCAxKWAuXHJcbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyB0aGF0IHRoZSBib2R5IG1heSBzbGlkZSBpbmRlZmluaXRlbHkuXHJcbiAgICAgKiBBIHZhbHVlIG9mIGAxYCBtZWFucyB0aGUgYm9keSBtYXkgY29tZSB0byBhIHN0b3AgYWxtb3N0IGluc3RhbnRseSBhZnRlciBhIGZvcmNlIGlzIGFwcGxpZWQuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGVmZmVjdHMgb2YgdGhlIHZhbHVlIG1heSBiZSBub24tbGluZWFyLiBcclxuICAgICAqIEhpZ2ggdmFsdWVzIG1heSBiZSB1bnN0YWJsZSBkZXBlbmRpbmcgb24gdGhlIGJvZHkuXHJcbiAgICAgKiBUaGUgZW5naW5lIHVzZXMgYSBDb3Vsb21iIGZyaWN0aW9uIG1vZGVsIGluY2x1ZGluZyBzdGF0aWMgYW5kIGtpbmV0aWMgZnJpY3Rpb24uXHJcbiAgICAgKiBOb3RlIHRoYXQgY29sbGlzaW9uIHJlc3BvbnNlIGlzIGJhc2VkIG9uIF9wYWlyc18gb2YgYm9kaWVzLCBhbmQgdGhhdCBgZnJpY3Rpb25gIHZhbHVlcyBhcmUgX2NvbWJpbmVkXyB3aXRoIHRoZSBmb2xsb3dpbmcgZm9ybXVsYTpcclxuICAgICAqXHJcbiAgICAgKiAgICAgTWF0aC5taW4oYm9keUEuZnJpY3Rpb24sIGJvZHlCLmZyaWN0aW9uKVxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAwLjFcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHN0YXRpYyBmcmljdGlvbiBvZiB0aGUgYm9keSAoaW4gdGhlIENvdWxvbWIgZnJpY3Rpb24gbW9kZWwpLiBcclxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIHRoZSBib2R5IHdpbGwgbmV2ZXIgJ3N0aWNrJyB3aGVuIGl0IGlzIG5lYXJseSBzdGF0aW9uYXJ5IGFuZCBvbmx5IGR5bmFtaWMgYGZyaWN0aW9uYCBpcyB1c2VkLlxyXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUgKGUuZy4gYDEwYCksIHRoZSBtb3JlIGZvcmNlIGl0IHdpbGwgdGFrZSB0byBpbml0aWFsbHkgZ2V0IHRoZSBib2R5IG1vdmluZyB3aGVuIG5lYXJseSBzdGF0aW9uYXJ5LlxyXG4gICAgICogVGhpcyB2YWx1ZSBpcyBtdWx0aXBsaWVkIHdpdGggdGhlIGBmcmljdGlvbmAgcHJvcGVydHkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gY2hhbmdlIGBmcmljdGlvbmAgYW5kIG1haW50YWluIGFuIGFwcHJvcHJpYXRlIGFtb3VudCBvZiBzdGF0aWMgZnJpY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uU3RhdGljXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgYWlyIGZyaWN0aW9uIG9mIHRoZSBib2R5IChhaXIgcmVzaXN0YW5jZSkuIFxyXG4gICAgICogQSB2YWx1ZSBvZiBgMGAgbWVhbnMgdGhlIGJvZHkgd2lsbCBuZXZlciBzbG93IGFzIGl0IG1vdmVzIHRocm91Z2ggc3BhY2UuXHJcbiAgICAgKiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSwgdGhlIGZhc3RlciBhIGJvZHkgc2xvd3Mgd2hlbiBtb3ZpbmcgdGhyb3VnaCBzcGFjZS5cclxuICAgICAqIFRoZSBlZmZlY3RzIG9mIHRoZSB2YWx1ZSBhcmUgbm9uLWxpbmVhci4gXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uQWlyXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDAuMDFcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBmaWx0ZXJpbmcgcHJvcGVydGllcyBvZiB0aGlzIGJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogQ29sbGlzaW9ucyBiZXR3ZWVuIHR3byBib2RpZXMgd2lsbCBvYmV5IHRoZSBmb2xsb3dpbmcgcnVsZXM6XHJcbiAgICAgKiAtIElmIHRoZSB0d28gYm9kaWVzIGhhdmUgdGhlIHNhbWUgbm9uLXplcm8gdmFsdWUgb2YgYGNvbGxpc2lvbkZpbHRlci5ncm91cGAsXHJcbiAgICAgKiAgIHRoZXkgd2lsbCBhbHdheXMgY29sbGlkZSBpZiB0aGUgdmFsdWUgaXMgcG9zaXRpdmUsIGFuZCB0aGV5IHdpbGwgbmV2ZXIgY29sbGlkZVxyXG4gICAgICogICBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmUuXHJcbiAgICAgKiAtIElmIHRoZSB0d28gYm9kaWVzIGhhdmUgZGlmZmVyZW50IHZhbHVlcyBvZiBgY29sbGlzaW9uRmlsdGVyLmdyb3VwYCBvciBpZiBvbmVcclxuICAgICAqICAgKG9yIGJvdGgpIG9mIHRoZSBib2RpZXMgaGFzIGEgdmFsdWUgb2YgMCwgdGhlbiB0aGUgY2F0ZWdvcnkvbWFzayBydWxlcyBhcHBseSBhcyBmb2xsb3dzOlxyXG4gICAgICpcclxuICAgICAqIEVhY2ggYm9keSBiZWxvbmdzIHRvIGEgY29sbGlzaW9uIGNhdGVnb3J5LCBnaXZlbiBieSBgY29sbGlzaW9uRmlsdGVyLmNhdGVnb3J5YC4gVGhpc1xyXG4gICAgICogdmFsdWUgaXMgdXNlZCBhcyBhIGJpdCBmaWVsZCBhbmQgdGhlIGNhdGVnb3J5IHNob3VsZCBoYXZlIG9ubHkgb25lIGJpdCBzZXQsIG1lYW5pbmcgdGhhdFxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgaXMgYSBwb3dlciBvZiB0d28gaW4gdGhlIHJhbmdlIFsxLCAyXjMxXS4gVGh1cywgdGhlcmUgYXJlIDMyXHJcbiAgICAgKiBkaWZmZXJlbnQgY29sbGlzaW9uIGNhdGVnb3JpZXMgYXZhaWxhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEVhY2ggYm9keSBhbHNvIGRlZmluZXMgYSBjb2xsaXNpb24gYml0bWFzaywgZ2l2ZW4gYnkgYGNvbGxpc2lvbkZpbHRlci5tYXNrYCB3aGljaCBzcGVjaWZpZXNcclxuICAgICAqIHRoZSBjYXRlZ29yaWVzIGl0IGNvbGxpZGVzIHdpdGggKHRoZSB2YWx1ZSBpcyB0aGUgYml0d2lzZSBBTkQgdmFsdWUgb2YgYWxsIHRoZXNlIGNhdGVnb3JpZXMpLlxyXG4gICAgICpcclxuICAgICAqIFVzaW5nIHRoZSBjYXRlZ29yeS9tYXNrIHJ1bGVzLCB0d28gYm9kaWVzIGBBYCBhbmQgYEJgIGNvbGxpZGUgaWYgZWFjaCBpbmNsdWRlcyB0aGUgb3RoZXInc1xyXG4gICAgICogY2F0ZWdvcnkgaW4gaXRzIG1hc2ssIGkuZS4gYChjYXRlZ29yeUEgJiBtYXNrQikgIT09IDBgIGFuZCBgKGNhdGVnb3J5QiAmIG1hc2tBKSAhPT0gMGBcclxuICAgICAqIGFyZSBib3RoIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlclxyXG4gICAgICogQHR5cGUgb2JqZWN0XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIEludGVnZXIgYE51bWJlcmAsIHRoYXQgc3BlY2lmaWVzIHRoZSBjb2xsaXNpb24gZ3JvdXAgdGhpcyBib2R5IGJlbG9uZ3MgdG8uXHJcbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uRmlsdGVyLmdyb3VwXHJcbiAgICAgKiBAdHlwZSBvYmplY3RcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBiaXQgZmllbGQgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBjYXRlZ29yeSB0aGlzIGJvZHkgYmVsb25ncyB0by5cclxuICAgICAqIFRoZSBjYXRlZ29yeSB2YWx1ZSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBiaXQgc2V0LCBmb3IgZXhhbXBsZSBgMHgwMDAxYC5cclxuICAgICAqIFRoaXMgbWVhbnMgdGhlcmUgYXJlIHVwIHRvIDMyIHVuaXF1ZSBjb2xsaXNpb24gY2F0ZWdvcmllcyBhdmFpbGFibGUuXHJcbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uRmlsdGVyLmNhdGVnb3J5XHJcbiAgICAgKiBAdHlwZSBvYmplY3RcclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBiaXQgbWFzayB0aGF0IHNwZWNpZmllcyB0aGUgY29sbGlzaW9uIGNhdGVnb3JpZXMgdGhpcyBib2R5IG1heSBjb2xsaWRlIHdpdGguXHJcbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uRmlsdGVyLm1hc2tcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICogQGRlZmF1bHQgLTFcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyBhIHRvbGVyYW5jZSBvbiBob3cgZmFyIGEgYm9keSBpcyBhbGxvd2VkIHRvICdzaW5rJyBvciByb3RhdGUgaW50byBvdGhlciBib2RpZXMuXHJcbiAgICAgKiBBdm9pZCBjaGFuZ2luZyB0aGlzIHZhbHVlIHVubGVzcyB5b3UgdW5kZXJzdGFuZCB0aGUgcHVycG9zZSBvZiBgc2xvcGAgaW4gcGh5c2ljcyBlbmdpbmVzLlxyXG4gICAgICogVGhlIGRlZmF1bHQgc2hvdWxkIGdlbmVyYWxseSBzdWZmaWNlLCBhbHRob3VnaCB2ZXJ5IGxhcmdlIGJvZGllcyBtYXkgcmVxdWlyZSBsYXJnZXIgdmFsdWVzIGZvciBzdGFibGUgc3RhY2tpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHNsb3BcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMC4wNVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgYWxsb3dzIHBlci1ib2R5IHRpbWUgc2NhbGluZywgZS5nLiBhIGZvcmNlLWZpZWxkIHdoZXJlIGJvZGllcyBpbnNpZGUgYXJlIGluIHNsb3ctbW90aW9uLCB3aGlsZSBvdGhlcnMgYXJlIGF0IGZ1bGwgc3BlZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHRpbWVTY2FsZVxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgZGVmaW5lcyB0aGUgcmVuZGVyaW5nIHByb3BlcnRpZXMgdG8gYmUgY29uc3VtZWQgYnkgdGhlIG1vZHVsZSBgTWF0dGVyLlJlbmRlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlbmRlclxyXG4gICAgICogQHR5cGUgb2JqZWN0XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZmxhZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgYm9keSBzaG91bGQgYmUgcmVuZGVyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlbmRlci52aXNpYmxlXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wYWNpdHkgdG8gdXNlIHdoZW4gcmVuZGVyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIub3BhY2l0eVxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBkZWZpbmVzIHRoZSBzcHJpdGUgcHJvcGVydGllcyB0byB1c2Ugd2hlbiByZW5kZXJpbmcsIGlmIGFueS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnNwcml0ZVxyXG4gICAgICogQHR5cGUgb2JqZWN0XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGBTdHJpbmdgIHRoYXQgZGVmaW5lcyB0aGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gdXNlIGFzIHRoZSBzcHJpdGUgdGV4dHVyZSwgaWYgYW55LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnRleHR1cmVcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICAgXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBzY2FsaW5nIGluIHRoZSB4LWF4aXMgZm9yIHRoZSBzcHJpdGUsIGlmIGFueS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnNwcml0ZS54U2NhbGVcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgc2NhbGluZyBpbiB0aGUgeS1heGlzIGZvciB0aGUgc3ByaXRlLCBpZiBhbnkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueVNjYWxlXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqL1xyXG5cclxuICAgICAvKipcclxuICAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgb2Zmc2V0IGluIHRoZSB4LWF4aXMgZm9yIHRoZSBzcHJpdGUgKG5vcm1hbGlzZWQgYnkgdGV4dHVyZSB3aWR0aCkuXHJcbiAgICAgICpcclxuICAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnNwcml0ZS54T2Zmc2V0XHJcbiAgICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAqL1xyXG5cclxuICAgICAvKipcclxuICAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgb2Zmc2V0IGluIHRoZSB5LWF4aXMgZm9yIHRoZSBzcHJpdGUgKG5vcm1hbGlzZWQgYnkgdGV4dHVyZSBoZWlnaHQpLlxyXG4gICAgICAqXHJcbiAgICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueU9mZnNldFxyXG4gICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBsaW5lIHdpZHRoIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgYm9keSBvdXRsaW5lIChpZiBhIHNwcml0ZSBpcyBub3QgZGVmaW5lZCkuXHJcbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyBubyBvdXRsaW5lIHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5saW5lV2lkdGhcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMS41XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYFN0cmluZ2AgdGhhdCBkZWZpbmVzIHRoZSBmaWxsIHN0eWxlIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgYm9keSAoaWYgYSBzcHJpdGUgaXMgbm90IGRlZmluZWQpLlxyXG4gICAgICogSXQgaXMgdGhlIHNhbWUgYXMgd2hlbiB1c2luZyBhIGNhbnZhcywgc28gaXQgYWNjZXB0cyBDU1Mgc3R5bGUgcHJvcGVydHkgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuZmlsbFN0eWxlXHJcbiAgICAgKiBAdHlwZSBzdHJpbmdcclxuICAgICAqIEBkZWZhdWx0IGEgcmFuZG9tIGNvbG91clxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBTdHJpbmdgIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIHN0eWxlIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgYm9keSBvdXRsaW5lIChpZiBhIHNwcml0ZSBpcyBub3QgZGVmaW5lZCkuXHJcbiAgICAgKiBJdCBpcyB0aGUgc2FtZSBhcyB3aGVuIHVzaW5nIGEgY2FudmFzLCBzbyBpdCBhY2NlcHRzIENTUyBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zdHJva2VTdHlsZVxyXG4gICAgICogQHR5cGUgc3RyaW5nXHJcbiAgICAgKiBAZGVmYXVsdCBhIHJhbmRvbSBjb2xvdXJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgdW5pcXVlIGF4aXMgdmVjdG9ycyAoZWRnZSBub3JtYWxzKSB1c2VkIGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uLlxyXG4gICAgICogVGhlc2UgYXJlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBmcm9tIHRoZSBnaXZlbiBjb252ZXggaHVsbCAoYHZlcnRpY2VzYCBhcnJheSkgaW4gYEJvZHkuY3JlYXRlYC5cclxuICAgICAqIFRoZXkgYXJlIGNvbnN0YW50bHkgdXBkYXRlZCBieSBgQm9keS51cGRhdGVgIGR1cmluZyB0aGUgc2ltdWxhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgYXhlc1xyXG4gICAgICogQHR5cGUgdmVjdG9yW11cclxuICAgICAqL1xyXG4gICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgX21lYXN1cmVzXyB0aGUgYXJlYSBvZiB0aGUgYm9keSdzIGNvbnZleCBodWxsLCBjYWxjdWxhdGVkIGF0IGNyZWF0aW9uIGJ5IGBCb2R5LmNyZWF0ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGFyZWFcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQGRlZmF1bHQgXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYEJvdW5kc2Agb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgQUFCQiByZWdpb24gZm9yIHRoZSBib2R5LlxyXG4gICAgICogSXQgaXMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGZyb20gdGhlIGdpdmVuIGNvbnZleCBodWxsIChgdmVydGljZXNgIGFycmF5KSBpbiBgQm9keS5jcmVhdGVgIGFuZCBjb25zdGFudGx5IHVwZGF0ZWQgYnkgYEJvZHkudXBkYXRlYCBkdXJpbmcgc2ltdWxhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgYm91bmRzXHJcbiAgICAgKiBAdHlwZSBib3VuZHNcclxuICAgICAqL1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Cb2R5LmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9ib2R5L0JvZHkuanMiLCIvKipcclxuKiBUaGUgYE1hdHRlci5Db25zdHJhaW50YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb25zdHJhaW50cy5cclxuKiBDb25zdHJhaW50cyBhcmUgdXNlZCBmb3Igc3BlY2lmeWluZyB0aGF0IGEgZml4ZWQgZGlzdGFuY2UgbXVzdCBiZSBtYWludGFpbmVkIGJldHdlZW4gdHdvIGJvZGllcyAob3IgYSBib2R5IGFuZCBhIGZpeGVkIHdvcmxkLXNwYWNlIHBvc2l0aW9uKS5cclxuKiBUaGUgc3RpZmZuZXNzIG9mIGNvbnN0cmFpbnRzIGNhbiBiZSBtb2RpZmllZCB0byBjcmVhdGUgc3ByaW5ncyBvciBlbGFzdGljLlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuKlxyXG4qIEBjbGFzcyBDb25zdHJhaW50XHJcbiovXHJcblxyXG4vLyBUT0RPOiBmaXggaW5zdGFiaWxpdHkgaXNzdWVzIHdpdGggdG9ycXVlXHJcbi8vIFRPRE86IGxpbmtlZCBjb25zdHJhaW50c1xyXG4vLyBUT0RPOiBicmVha2FibGUgY29uc3RyYWludHNcclxuLy8gVE9ETzogY29sbGlzaW9uIGNvbnN0cmFpbnRzXHJcbi8vIFRPRE86IGFsbG93IGNvbnN0cmFpbmVkIGJvZGllcyB0byBzbGVlcFxyXG4vLyBUT0RPOiBoYW5kbGUgMCBsZW5ndGggY29uc3RyYWludHMgcHJvcGVybHlcclxuLy8gVE9ETzogaW1wdWxzZSBjYWNoaW5nIGFuZCB3YXJtaW5nXHJcblxyXG52YXIgQ29uc3RyYWludCA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xyXG5cclxudmFyIFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVydGljZXMnKTtcclxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xyXG52YXIgU2xlZXBpbmcgPSByZXF1aXJlKCcuLi9jb3JlL1NsZWVwaW5nJyk7XHJcbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcclxudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9BeGVzJyk7XHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBfbWluTGVuZ3RoID0gMC4wMDAwMDEsXHJcbiAgICAgICAgX21pbkRpZmZlcmVuY2UgPSAwLjAwMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29uc3RyYWludC5cclxuICAgICAqIEFsbCBwcm9wZXJ0aWVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMsIGFuZCBtYW55IGFyZSBwcmUtY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIG90aGVyIHByb3BlcnRpZXMuXHJcbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEBwYXJhbSB7fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHtjb25zdHJhaW50fSBjb25zdHJhaW50XHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBjb25zdHJhaW50ID0gb3B0aW9ucztcclxuXHJcbiAgICAgICAgLy8gaWYgYm9kaWVzIGRlZmluZWQgYnV0IG5vIHBvaW50cywgdXNlIGJvZHkgY2VudHJlXHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQuYm9keUEgJiYgIWNvbnN0cmFpbnQucG9pbnRBKVxyXG4gICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QSA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIGlmIChjb25zdHJhaW50LmJvZHlCICYmICFjb25zdHJhaW50LnBvaW50QilcclxuICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEIgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHN0YXRpYyBsZW5ndGggdXNpbmcgaW5pdGlhbCB3b3JsZCBzcGFjZSBwb2ludHNcclxuICAgICAgICB2YXIgaW5pdGlhbFBvaW50QSA9IGNvbnN0cmFpbnQuYm9keUEgPyBWZWN0b3IuYWRkKGNvbnN0cmFpbnQuYm9keUEucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRBKSA6IGNvbnN0cmFpbnQucG9pbnRBLFxyXG4gICAgICAgICAgICBpbml0aWFsUG9pbnRCID0gY29uc3RyYWludC5ib2R5QiA/IFZlY3Rvci5hZGQoY29uc3RyYWludC5ib2R5Qi5wb3NpdGlvbiwgY29uc3RyYWludC5wb2ludEIpIDogY29uc3RyYWludC5wb2ludEIsXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IFZlY3Rvci5tYWduaXR1ZGUoVmVjdG9yLnN1Yihpbml0aWFsUG9pbnRBLCBpbml0aWFsUG9pbnRCKSk7XHJcbiAgICBcclxuICAgICAgICBjb25zdHJhaW50Lmxlbmd0aCA9IGNvbnN0cmFpbnQubGVuZ3RoIHx8IGxlbmd0aCB8fCBfbWluTGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICB2YXIgcmVuZGVyID0ge1xyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiAnI2ZmZmZmZidcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0cmFpbnQucmVuZGVyID0gQ29tbW9uLmV4dGVuZChyZW5kZXIsIGNvbnN0cmFpbnQucmVuZGVyKTtcclxuXHJcbiAgICAgICAgLy8gb3B0aW9uIGRlZmF1bHRzXHJcbiAgICAgICAgY29uc3RyYWludC5pZCA9IGNvbnN0cmFpbnQuaWQgfHwgQ29tbW9uLm5leHRJZCgpO1xyXG4gICAgICAgIGNvbnN0cmFpbnQubGFiZWwgPSBjb25zdHJhaW50LmxhYmVsIHx8ICdDb25zdHJhaW50JztcclxuICAgICAgICBjb25zdHJhaW50LnR5cGUgPSAnY29uc3RyYWludCc7XHJcbiAgICAgICAgY29uc3RyYWludC5zdGlmZm5lc3MgPSBjb25zdHJhaW50LnN0aWZmbmVzcyB8fCAxO1xyXG4gICAgICAgIGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyA9IGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyB8fCAwO1xyXG4gICAgICAgIGNvbnN0cmFpbnQuYW5nbGVBID0gY29uc3RyYWludC5ib2R5QSA/IGNvbnN0cmFpbnQuYm9keUEuYW5nbGUgOiBjb25zdHJhaW50LmFuZ2xlQTtcclxuICAgICAgICBjb25zdHJhaW50LmFuZ2xlQiA9IGNvbnN0cmFpbnQuYm9keUIgPyBjb25zdHJhaW50LmJvZHlCLmFuZ2xlIDogY29uc3RyYWludC5hbmdsZUI7XHJcbiAgICAgICAgY29uc3RyYWludC5wbHVnaW4gPSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29sdmVzIGFsbCBjb25zdHJhaW50cyBpbiBhIGxpc3Qgb2YgY29sbGlzaW9ucy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIHNvbHZlQWxsXHJcbiAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnRbXX0gY29uc3RyYWludHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcclxuICAgICAqL1xyXG4gICAgQ29uc3RyYWludC5zb2x2ZUFsbCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCB0aW1lU2NhbGUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIENvbnN0cmFpbnQuc29sdmUoY29uc3RyYWludHNbaV0sIHRpbWVTY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvbHZlcyBhIGRpc3RhbmNlIGNvbnN0cmFpbnQgd2l0aCBHYXVzcy1TaWVkZWwgbWV0aG9kLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2Qgc29sdmVcclxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTY2FsZVxyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LnNvbHZlID0gZnVuY3Rpb24oY29uc3RyYWludCwgdGltZVNjYWxlKSB7XHJcbiAgICAgICAgdmFyIGJvZHlBID0gY29uc3RyYWludC5ib2R5QSxcclxuICAgICAgICAgICAgYm9keUIgPSBjb25zdHJhaW50LmJvZHlCLFxyXG4gICAgICAgICAgICBwb2ludEEgPSBjb25zdHJhaW50LnBvaW50QSxcclxuICAgICAgICAgICAgcG9pbnRCID0gY29uc3RyYWludC5wb2ludEI7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSByZWZlcmVuY2UgYW5nbGVcclxuICAgICAgICBpZiAoYm9keUEgJiYgIWJvZHlBLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRBID0gVmVjdG9yLnJvdGF0ZShwb2ludEEsIGJvZHlBLmFuZ2xlIC0gY29uc3RyYWludC5hbmdsZUEpO1xyXG4gICAgICAgICAgICBjb25zdHJhaW50LmFuZ2xlQSA9IGJvZHlBLmFuZ2xlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyB1cGRhdGUgcmVmZXJlbmNlIGFuZ2xlXHJcbiAgICAgICAgaWYgKGJvZHlCICYmICFib2R5Qi5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QiA9IFZlY3Rvci5yb3RhdGUocG9pbnRCLCBib2R5Qi5hbmdsZSAtIGNvbnN0cmFpbnQuYW5nbGVCKTtcclxuICAgICAgICAgICAgY29uc3RyYWludC5hbmdsZUIgPSBib2R5Qi5hbmdsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwb2ludEFXb3JsZCA9IHBvaW50QSxcclxuICAgICAgICAgICAgcG9pbnRCV29ybGQgPSBwb2ludEI7XHJcblxyXG4gICAgICAgIGlmIChib2R5QSkgcG9pbnRBV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uLCBwb2ludEEpO1xyXG4gICAgICAgIGlmIChib2R5QikgcG9pbnRCV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlCLnBvc2l0aW9uLCBwb2ludEIpO1xyXG5cclxuICAgICAgICBpZiAoIXBvaW50QVdvcmxkIHx8ICFwb2ludEJXb3JsZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgZGVsdGEgPSBWZWN0b3Iuc3ViKHBvaW50QVdvcmxkLCBwb2ludEJXb3JsZCksXHJcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSBWZWN0b3IubWFnbml0dWRlKGRlbHRhKTtcclxuXHJcbiAgICAgICAgLy8gcHJldmVudCBzaW5ndWxhcml0eVxyXG4gICAgICAgIGlmIChjdXJyZW50TGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoID0gX21pbkxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gc29sdmUgZGlzdGFuY2UgY29uc3RyYWludCB3aXRoIEdhdXNzLVNpZWRlbCBtZXRob2RcclxuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IChjdXJyZW50TGVuZ3RoIC0gY29uc3RyYWludC5sZW5ndGgpIC8gY3VycmVudExlbmd0aCxcclxuICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yLmRpdihkZWx0YSwgY3VycmVudExlbmd0aCksXHJcbiAgICAgICAgICAgIGZvcmNlID0gVmVjdG9yLm11bHQoZGVsdGEsIGRpZmZlcmVuY2UgKiAwLjUgKiBjb25zdHJhaW50LnN0aWZmbmVzcyAqIHRpbWVTY2FsZSAqIHRpbWVTY2FsZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gaWYgZGlmZmVyZW5jZSBpcyB2ZXJ5IHNtYWxsLCB3ZSBjYW4gc2tpcFxyXG4gICAgICAgIGlmIChNYXRoLmFicygxIC0gKGN1cnJlbnRMZW5ndGggLyBjb25zdHJhaW50Lmxlbmd0aCkpIDwgX21pbkRpZmZlcmVuY2UgKiB0aW1lU2NhbGUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIHZlbG9jaXR5UG9pbnRBLFxyXG4gICAgICAgICAgICB2ZWxvY2l0eVBvaW50QixcclxuICAgICAgICAgICAgb2Zmc2V0QSxcclxuICAgICAgICAgICAgb2Zmc2V0QixcclxuICAgICAgICAgICAgb0FuLFxyXG4gICAgICAgICAgICBvQm4sXHJcbiAgICAgICAgICAgIGJvZHlBRGVub20sXHJcbiAgICAgICAgICAgIGJvZHlCRGVub207XHJcbiAgICBcclxuICAgICAgICBpZiAoYm9keUEgJiYgIWJvZHlBLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIC8vIHBvaW50IGJvZHkgb2Zmc2V0XHJcbiAgICAgICAgICAgIG9mZnNldEEgPSB7IFxyXG4gICAgICAgICAgICAgICAgeDogcG9pbnRBV29ybGQueCAtIGJvZHlBLnBvc2l0aW9uLnggKyBmb3JjZS54LCBcclxuICAgICAgICAgICAgICAgIHk6IHBvaW50QVdvcmxkLnkgLSBib2R5QS5wb3NpdGlvbi55ICsgZm9yY2UueVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGJvZHlBLnZlbG9jaXR5LnggPSBib2R5QS5wb3NpdGlvbi54IC0gYm9keUEucG9zaXRpb25QcmV2Lng7XHJcbiAgICAgICAgICAgIGJvZHlBLnZlbG9jaXR5LnkgPSBib2R5QS5wb3NpdGlvbi55IC0gYm9keUEucG9zaXRpb25QcmV2Lnk7XHJcbiAgICAgICAgICAgIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSA9IGJvZHlBLmFuZ2xlIC0gYm9keUEuYW5nbGVQcmV2O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gZmluZCBwb2ludCB2ZWxvY2l0eSBhbmQgYm9keSBtYXNzXHJcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRBID0gVmVjdG9yLmFkZChib2R5QS52ZWxvY2l0eSwgVmVjdG9yLm11bHQoVmVjdG9yLnBlcnAob2Zmc2V0QSksIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSkpO1xyXG4gICAgICAgICAgICBvQW4gPSBWZWN0b3IuZG90KG9mZnNldEEsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgIGJvZHlBRGVub20gPSBib2R5QS5pbnZlcnNlTWFzcyArIGJvZHlBLmludmVyc2VJbmVydGlhICogb0FuICogb0FuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRBID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIGJvZHlBRGVub20gPSBib2R5QSA/IGJvZHlBLmludmVyc2VNYXNzIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGlmIChib2R5QiAmJiAhYm9keUIuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgLy8gcG9pbnQgYm9keSBvZmZzZXRcclxuICAgICAgICAgICAgb2Zmc2V0QiA9IHsgXHJcbiAgICAgICAgICAgICAgICB4OiBwb2ludEJXb3JsZC54IC0gYm9keUIucG9zaXRpb24ueCAtIGZvcmNlLngsIFxyXG4gICAgICAgICAgICAgICAgeTogcG9pbnRCV29ybGQueSAtIGJvZHlCLnBvc2l0aW9uLnkgLSBmb3JjZS55IFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGJvZHlCLnZlbG9jaXR5LnggPSBib2R5Qi5wb3NpdGlvbi54IC0gYm9keUIucG9zaXRpb25QcmV2Lng7XHJcbiAgICAgICAgICAgIGJvZHlCLnZlbG9jaXR5LnkgPSBib2R5Qi5wb3NpdGlvbi55IC0gYm9keUIucG9zaXRpb25QcmV2Lnk7XHJcbiAgICAgICAgICAgIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSA9IGJvZHlCLmFuZ2xlIC0gYm9keUIuYW5nbGVQcmV2O1xyXG5cclxuICAgICAgICAgICAgLy8gZmluZCBwb2ludCB2ZWxvY2l0eSBhbmQgYm9keSBtYXNzXHJcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCID0gVmVjdG9yLmFkZChib2R5Qi52ZWxvY2l0eSwgVmVjdG9yLm11bHQoVmVjdG9yLnBlcnAob2Zmc2V0QiksIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSkpO1xyXG4gICAgICAgICAgICBvQm4gPSBWZWN0b3IuZG90KG9mZnNldEIsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgIGJvZHlCRGVub20gPSBib2R5Qi5pbnZlcnNlTWFzcyArIGJvZHlCLmludmVyc2VJbmVydGlhICogb0JuICogb0JuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIGJvZHlCRGVub20gPSBib2R5QiA/IGJvZHlCLmludmVyc2VNYXNzIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlbGF0aXZlVmVsb2NpdHkgPSBWZWN0b3Iuc3ViKHZlbG9jaXR5UG9pbnRCLCB2ZWxvY2l0eVBvaW50QSksXHJcbiAgICAgICAgICAgIG5vcm1hbEltcHVsc2UgPSBWZWN0b3IuZG90KG5vcm1hbCwgcmVsYXRpdmVWZWxvY2l0eSkgLyAoYm9keUFEZW5vbSArIGJvZHlCRGVub20pO1xyXG4gICAgXHJcbiAgICAgICAgaWYgKG5vcm1hbEltcHVsc2UgPiAwKSBub3JtYWxJbXB1bHNlID0gMDtcclxuICAgIFxyXG4gICAgICAgIHZhciBub3JtYWxWZWxvY2l0eSA9IHtcclxuICAgICAgICAgICAgeDogbm9ybWFsLnggKiBub3JtYWxJbXB1bHNlLCBcclxuICAgICAgICAgICAgeTogbm9ybWFsLnkgKiBub3JtYWxJbXB1bHNlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHRvcnF1ZTtcclxuIFxyXG4gICAgICAgIGlmIChib2R5QSAmJiAhYm9keUEuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgdG9ycXVlID0gVmVjdG9yLmNyb3NzKG9mZnNldEEsIG5vcm1hbFZlbG9jaXR5KSAqIGJvZHlBLmludmVyc2VJbmVydGlhICogKDEgLSBjb25zdHJhaW50LmFuZ3VsYXJTdGlmZm5lc3MpO1xyXG5cclxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBhcHBsaWVkIGltcHVsc2VzIGZvciBwb3N0IHNvbHZpbmdcclxuICAgICAgICAgICAgYm9keUEuY29uc3RyYWludEltcHVsc2UueCAtPSBmb3JjZS54O1xyXG4gICAgICAgICAgICBib2R5QS5jb25zdHJhaW50SW1wdWxzZS55IC09IGZvcmNlLnk7XHJcbiAgICAgICAgICAgIGJvZHlBLmNvbnN0cmFpbnRJbXB1bHNlLmFuZ2xlICs9IHRvcnF1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGx5IGZvcmNlc1xyXG4gICAgICAgICAgICBib2R5QS5wb3NpdGlvbi54IC09IGZvcmNlLng7XHJcbiAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uLnkgLT0gZm9yY2UueTtcclxuICAgICAgICAgICAgYm9keUEuYW5nbGUgKz0gdG9ycXVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJvZHlCICYmICFib2R5Qi5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICB0b3JxdWUgPSBWZWN0b3IuY3Jvc3Mob2Zmc2V0Qiwgbm9ybWFsVmVsb2NpdHkpICogYm9keUIuaW52ZXJzZUluZXJ0aWEgKiAoMSAtIGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGFwcGxpZWQgaW1wdWxzZXMgZm9yIHBvc3Qgc29sdmluZ1xyXG4gICAgICAgICAgICBib2R5Qi5jb25zdHJhaW50SW1wdWxzZS54ICs9IGZvcmNlLng7XHJcbiAgICAgICAgICAgIGJvZHlCLmNvbnN0cmFpbnRJbXB1bHNlLnkgKz0gZm9yY2UueTtcclxuICAgICAgICAgICAgYm9keUIuY29uc3RyYWludEltcHVsc2UuYW5nbGUgLT0gdG9ycXVlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gYXBwbHkgZm9yY2VzXHJcbiAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uLnggKz0gZm9yY2UueDtcclxuICAgICAgICAgICAgYm9keUIucG9zaXRpb24ueSArPSBmb3JjZS55O1xyXG4gICAgICAgICAgICBib2R5Qi5hbmdsZSAtPSB0b3JxdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBib2R5IHVwZGF0ZXMgcmVxdWlyZWQgYWZ0ZXIgc29sdmluZyBjb25zdHJhaW50cy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIHBvc3RTb2x2ZUFsbFxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LnBvc3RTb2x2ZUFsbCA9IGZ1bmN0aW9uKGJvZGllcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IGJvZHkuY29uc3RyYWludEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW1wdWxzZS54ID09PSAwICYmIGltcHVsc2UueSA9PT0gMCAmJiBpbXB1bHNlLmFuZ2xlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBnZW9tZXRyeSBhbmQgcmVzZXRcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBib2R5LnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbal07XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBpbXB1bHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnggKz0gaW1wdWxzZS54O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSArPSBpbXB1bHNlLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGltcHVsc2UuYW5nbGUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy5yb3RhdGUocGFydC52ZXJ0aWNlcywgaW1wdWxzZS5hbmdsZSwgYm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgQXhlcy5yb3RhdGUocGFydC5heGVzLCBpbXB1bHNlLmFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yLnJvdGF0ZUFib3V0KHBhcnQucG9zaXRpb24sIGltcHVsc2UuYW5nbGUsIGJvZHkucG9zaXRpb24sIHBhcnQucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW1wdWxzZS5hbmdsZSA9IDA7XHJcbiAgICAgICAgICAgIGltcHVsc2UueCA9IDA7XHJcbiAgICAgICAgICAgIGltcHVsc2UueSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW50ZWdlciBgTnVtYmVyYCB1bmlxdWVseSBpZGVudGlmeWluZyBudW1iZXIgZ2VuZXJhdGVkIGluIGBDb21wb3NpdGUuY3JlYXRlYCBieSBgQ29tbW9uLm5leHRJZGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGlkXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgU3RyaW5nYCBkZW5vdGluZyB0aGUgdHlwZSBvZiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQGRlZmF1bHQgXCJjb25zdHJhaW50XCJcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcmJpdHJhcnkgYFN0cmluZ2AgbmFtZSB0byBoZWxwIHRoZSB1c2VyIGlkZW50aWZ5IGFuZCBtYW5hZ2UgYm9kaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBsYWJlbFxyXG4gICAgICogQHR5cGUgc3RyaW5nXHJcbiAgICAgKiBAZGVmYXVsdCBcIkNvbnN0cmFpbnRcIlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBgT2JqZWN0YCB0aGF0IGRlZmluZXMgdGhlIHJlbmRlcmluZyBwcm9wZXJ0aWVzIHRvIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb2R1bGUgYE1hdHRlci5SZW5kZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXJcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGNvbnN0cmFpbnQgc2hvdWxkIGJlIHJlbmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIudmlzaWJsZVxyXG4gICAgICogQHR5cGUgYm9vbGVhblxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbGluZSB3aWR0aCB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGNvbnN0cmFpbnQgb3V0bGluZS5cclxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIG5vIG91dGxpbmUgd2lsbCBiZSByZW5kZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLmxpbmVXaWR0aFxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYFN0cmluZ2AgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2Ugc3R5bGUgdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSBjb25zdHJhaW50IG91dGxpbmUuXHJcbiAgICAgKiBJdCBpcyB0aGUgc2FtZSBhcyB3aGVuIHVzaW5nIGEgY2FudmFzLCBzbyBpdCBhY2NlcHRzIENTUyBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zdHJva2VTdHlsZVxyXG4gICAgICogQHR5cGUgc3RyaW5nXHJcbiAgICAgKiBAZGVmYXVsdCBhIHJhbmRvbSBjb2xvdXJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpcnN0IHBvc3NpYmxlIGBCb2R5YCB0aGF0IHRoaXMgY29uc3RyYWludCBpcyBhdHRhY2hlZCB0by5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgYm9keUFcclxuICAgICAqIEB0eXBlIGJvZHlcclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNlY29uZCBwb3NzaWJsZSBgQm9keWAgdGhhdCB0aGlzIGNvbnN0cmFpbnQgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGJvZHlCXHJcbiAgICAgKiBAdHlwZSBib2R5XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYFZlY3RvcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG9mZnNldCBvZiB0aGUgY29uc3RyYWludCBmcm9tIGNlbnRlciBvZiB0aGUgYGNvbnN0cmFpbnQuYm9keUFgIGlmIGRlZmluZWQsIG90aGVyd2lzZSBhIHdvcmxkLXNwYWNlIHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBwb2ludEFcclxuICAgICAqIEB0eXBlIHZlY3RvclxyXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IHNwZWNpZmllcyB0aGUgb2Zmc2V0IG9mIHRoZSBjb25zdHJhaW50IGZyb20gY2VudGVyIG9mIHRoZSBgY29uc3RyYWludC5ib2R5QWAgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIGEgd29ybGQtc3BhY2UgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHBvaW50QlxyXG4gICAgICogQHR5cGUgdmVjdG9yXHJcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBzdGlmZm5lc3Mgb2YgdGhlIGNvbnN0cmFpbnQsIGkuZS4gdGhlIHJhdGUgYXQgd2hpY2ggaXQgcmV0dXJucyB0byBpdHMgcmVzdGluZyBgY29uc3RyYWludC5sZW5ndGhgLlxyXG4gICAgICogQSB2YWx1ZSBvZiBgMWAgbWVhbnMgdGhlIGNvbnN0cmFpbnQgc2hvdWxkIGJlIHZlcnkgc3RpZmYuXHJcbiAgICAgKiBBIHZhbHVlIG9mIGAwLjJgIG1lYW5zIHRoZSBjb25zdHJhaW50IGFjdHMgbGlrZSBhIHNvZnQgc3ByaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSB0YXJnZXQgcmVzdGluZyBsZW5ndGggb2YgdGhlIGNvbnN0cmFpbnQuIFxyXG4gICAgICogSXQgaXMgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGluIGBDb25zdHJhaW50LmNyZWF0ZWAgZnJvbSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgYGNvbnN0cmFpbnQuYm9keUFgIGFuZCBgY29uc3RyYWludC5ib2R5QmAuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGxlbmd0aFxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCByZXNlcnZlZCBmb3Igc3RvcmluZyBwbHVnaW4tc3BlY2lmaWMgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luXHJcbiAgICAgKiBAdHlwZSB7fVxyXG4gICAgICovXHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb25zdHJhaW50L0NvbnN0cmFpbnQuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbnN0cmFpbnQvQ29uc3RyYWludC5qcyIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlNsZWVwaW5nYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyB0byBtYW5hZ2UgdGhlIHNsZWVwaW5nIHN0YXRlIG9mIGJvZGllcy5cclxuKlxyXG4qIEBjbGFzcyBTbGVlcGluZ1xyXG4qL1xyXG5cclxudmFyIFNsZWVwaW5nID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNsZWVwaW5nO1xyXG5cclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4vRXZlbnRzJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgU2xlZXBpbmcuX21vdGlvbldha2VUaHJlc2hvbGQgPSAwLjE4O1xyXG4gICAgU2xlZXBpbmcuX21vdGlvblNsZWVwVGhyZXNob2xkID0gMC4wODtcclxuICAgIFNsZWVwaW5nLl9taW5CaWFzID0gMC45O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHV0cyBib2RpZXMgdG8gc2xlZXAgb3Igd2FrZXMgdGhlbSB1cCBkZXBlbmRpbmcgb24gdGhlaXIgbW90aW9uLlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcclxuICAgICAqL1xyXG4gICAgU2xlZXBpbmcudXBkYXRlID0gZnVuY3Rpb24oYm9kaWVzLCB0aW1lU2NhbGUpIHtcclxuICAgICAgICB2YXIgdGltZUZhY3RvciA9IHRpbWVTY2FsZSAqIHRpbWVTY2FsZSAqIHRpbWVTY2FsZTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGJvZGllcyBzbGVlcGluZyBzdGF0dXNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXSxcclxuICAgICAgICAgICAgICAgIG1vdGlvbiA9IGJvZHkuc3BlZWQgKiBib2R5LnNwZWVkICsgYm9keS5hbmd1bGFyU3BlZWQgKiBib2R5LmFuZ3VsYXJTcGVlZDtcclxuXHJcbiAgICAgICAgICAgIC8vIHdha2UgdXAgYm9kaWVzIGlmIHRoZXkgaGF2ZSBhIGZvcmNlIGFwcGxpZWRcclxuICAgICAgICAgICAgaWYgKGJvZHkuZm9yY2UueCAhPT0gMCB8fCBib2R5LmZvcmNlLnkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG1pbk1vdGlvbiA9IE1hdGgubWluKGJvZHkubW90aW9uLCBtb3Rpb24pLFxyXG4gICAgICAgICAgICAgICAgbWF4TW90aW9uID0gTWF0aC5tYXgoYm9keS5tb3Rpb24sIG1vdGlvbik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIGJpYXNlZCBhdmVyYWdlIG1vdGlvbiBlc3RpbWF0aW9uIGJldHdlZW4gZnJhbWVzXHJcbiAgICAgICAgICAgIGJvZHkubW90aW9uID0gU2xlZXBpbmcuX21pbkJpYXMgKiBtaW5Nb3Rpb24gKyAoMSAtIFNsZWVwaW5nLl9taW5CaWFzKSAqIG1heE1vdGlvbjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChib2R5LnNsZWVwVGhyZXNob2xkID4gMCAmJiBib2R5Lm1vdGlvbiA8IFNsZWVwaW5nLl9tb3Rpb25TbGVlcFRocmVzaG9sZCAqIHRpbWVGYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGJvZHkuc2xlZXBDb3VudGVyICs9IDE7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChib2R5LnNsZWVwQ291bnRlciA+PSBib2R5LnNsZWVwVGhyZXNob2xkKVxyXG4gICAgICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCB0cnVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChib2R5LnNsZWVwQ291bnRlciA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJvZHkuc2xlZXBDb3VudGVyIC09IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBzZXQgb2YgY29sbGlkaW5nIHBhaXJzLCB3YWtlcyB0aGUgc2xlZXBpbmcgYm9kaWVzIGludm9sdmVkLlxyXG4gICAgICogQG1ldGhvZCBhZnRlckNvbGxpc2lvbnNcclxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTY2FsZVxyXG4gICAgICovXHJcbiAgICBTbGVlcGluZy5hZnRlckNvbGxpc2lvbnMgPSBmdW5jdGlvbihwYWlycywgdGltZVNjYWxlKSB7XHJcbiAgICAgICAgdmFyIHRpbWVGYWN0b3IgPSB0aW1lU2NhbGUgKiB0aW1lU2NhbGUgKiB0aW1lU2NhbGU7XHJcblxyXG4gICAgICAgIC8vIHdha2UgdXAgYm9kaWVzIGludm9sdmVkIGluIGNvbGxpc2lvbnNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBkb24ndCB3YWtlIGluYWN0aXZlIHBhaXJzXHJcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uLFxyXG4gICAgICAgICAgICAgICAgYm9keUEgPSBjb2xsaXNpb24uYm9keUEucGFyZW50LCBcclxuICAgICAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLmJvZHlCLnBhcmVudDtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FrZSBpZiBhdCBsZWFzdCBvbmUgYm9keSBpcyBzdGF0aWNcclxuICAgICAgICAgICAgaWYgKChib2R5QS5pc1NsZWVwaW5nICYmIGJvZHlCLmlzU2xlZXBpbmcpIHx8IGJvZHlBLmlzU3RhdGljIHx8IGJvZHlCLmlzU3RhdGljKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChib2R5QS5pc1NsZWVwaW5nIHx8IGJvZHlCLmlzU2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbGVlcGluZ0JvZHkgPSAoYm9keUEuaXNTbGVlcGluZyAmJiAhYm9keUEuaXNTdGF0aWMpID8gYm9keUEgOiBib2R5QixcclxuICAgICAgICAgICAgICAgICAgICBtb3ZpbmdCb2R5ID0gc2xlZXBpbmdCb2R5ID09PSBib2R5QSA/IGJvZHlCIDogYm9keUE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFzbGVlcGluZ0JvZHkuaXNTdGF0aWMgJiYgbW92aW5nQm9keS5tb3Rpb24gPiBTbGVlcGluZy5fbW90aW9uV2FrZVRocmVzaG9sZCAqIHRpbWVGYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoc2xlZXBpbmdCb2R5LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gIFxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBib2R5IGFzIHNsZWVwaW5nIG9yIGF3YWtlLlxyXG4gICAgICogQG1ldGhvZCBzZXRcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1NsZWVwaW5nXHJcbiAgICAgKi9cclxuICAgIFNsZWVwaW5nLnNldCA9IGZ1bmN0aW9uKGJvZHksIGlzU2xlZXBpbmcpIHtcclxuICAgICAgICB2YXIgd2FzU2xlZXBpbmcgPSBib2R5LmlzU2xlZXBpbmc7XHJcblxyXG4gICAgICAgIGlmIChpc1NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgIGJvZHkuaXNTbGVlcGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGJvZHkuc2xlZXBDb3VudGVyID0gYm9keS5zbGVlcFRocmVzaG9sZDtcclxuXHJcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25JbXB1bHNlLnggPSAwO1xyXG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uSW1wdWxzZS55ID0gMDtcclxuXHJcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggPSBib2R5LnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSBib2R5LnBvc2l0aW9uLnk7XHJcblxyXG4gICAgICAgICAgICBib2R5LmFuZ2xlUHJldiA9IGJvZHkuYW5nbGU7XHJcbiAgICAgICAgICAgIGJvZHkuc3BlZWQgPSAwO1xyXG4gICAgICAgICAgICBib2R5LmFuZ3VsYXJTcGVlZCA9IDA7XHJcbiAgICAgICAgICAgIGJvZHkubW90aW9uID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICghd2FzU2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKGJvZHksICdzbGVlcFN0YXJ0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBib2R5LmlzU2xlZXBpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgYm9keS5zbGVlcENvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHdhc1NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBFdmVudHMudHJpZ2dlcihib2R5LCAnc2xlZXBFbmQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL1NsZWVwaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL1NsZWVwaW5nLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgREVGQVVMVDogMCxcclxuICAgIExJTkVBUjogMCxcclxuICAgIE5FQVJFU1Q6IDFcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL1NjYWxlTW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXcmFwID0gZnVuY3Rpb24gKHZhbHVlLCBtaW4sIG1heClcclxue1xyXG4gICAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xyXG5cclxuICAgIGlmIChyYW5nZSA8PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gKHZhbHVlIC0gbWluKSAlIHJhbmdlO1xyXG5cclxuICAgIGlmIChyZXN1bHQgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIHJlc3VsdCArPSByYW5nZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0ICsgbWluO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXcmFwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1dyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlBhaXJgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGNvbGxpc2lvbiBwYWlycy5cclxuKlxyXG4qIEBjbGFzcyBQYWlyXHJcbiovXHJcblxyXG52YXIgUGFpciA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYWlyO1xyXG5cclxudmFyIENvbnRhY3QgPSByZXF1aXJlKCcuL0NvbnRhY3QnKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcGFpci5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge2NvbGxpc2lvbn0gY29sbGlzaW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXHJcbiAgICAgKiBAcmV0dXJuIHtwYWlyfSBBIG5ldyBwYWlyXHJcbiAgICAgKi9cclxuICAgIFBhaXIuY3JlYXRlID0gZnVuY3Rpb24oY29sbGlzaW9uLCB0aW1lc3RhbXApIHtcclxuICAgICAgICB2YXIgYm9keUEgPSBjb2xsaXNpb24uYm9keUEsXHJcbiAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLmJvZHlCLFxyXG4gICAgICAgICAgICBwYXJlbnRBID0gY29sbGlzaW9uLnBhcmVudEEsXHJcbiAgICAgICAgICAgIHBhcmVudEIgPSBjb2xsaXNpb24ucGFyZW50QjtcclxuXHJcbiAgICAgICAgdmFyIHBhaXIgPSB7XHJcbiAgICAgICAgICAgIGlkOiBQYWlyLmlkKGJvZHlBLCBib2R5QiksXHJcbiAgICAgICAgICAgIGJvZHlBOiBib2R5QSxcclxuICAgICAgICAgICAgYm9keUI6IGJvZHlCLFxyXG4gICAgICAgICAgICBjb250YWN0czoge30sXHJcbiAgICAgICAgICAgIGFjdGl2ZUNvbnRhY3RzOiBbXSxcclxuICAgICAgICAgICAgc2VwYXJhdGlvbjogMCxcclxuICAgICAgICAgICAgaXNBY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIGlzU2Vuc29yOiBib2R5QS5pc1NlbnNvciB8fCBib2R5Qi5pc1NlbnNvcixcclxuICAgICAgICAgICAgdGltZUNyZWF0ZWQ6IHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgdGltZVVwZGF0ZWQ6IHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgaW52ZXJzZU1hc3M6IHBhcmVudEEuaW52ZXJzZU1hc3MgKyBwYXJlbnRCLmludmVyc2VNYXNzLFxyXG4gICAgICAgICAgICBmcmljdGlvbjogTWF0aC5taW4ocGFyZW50QS5mcmljdGlvbiwgcGFyZW50Qi5mcmljdGlvbiksXHJcbiAgICAgICAgICAgIGZyaWN0aW9uU3RhdGljOiBNYXRoLm1heChwYXJlbnRBLmZyaWN0aW9uU3RhdGljLCBwYXJlbnRCLmZyaWN0aW9uU3RhdGljKSxcclxuICAgICAgICAgICAgcmVzdGl0dXRpb246IE1hdGgubWF4KHBhcmVudEEucmVzdGl0dXRpb24sIHBhcmVudEIucmVzdGl0dXRpb24pLFxyXG4gICAgICAgICAgICBzbG9wOiBNYXRoLm1heChwYXJlbnRBLnNsb3AsIHBhcmVudEIuc2xvcClcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBQYWlyLnVwZGF0ZShwYWlyLCBjb2xsaXNpb24sIHRpbWVzdGFtcCk7XHJcblxyXG4gICAgICAgIHJldHVybiBwYWlyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgYSBwYWlyIGdpdmVuIGEgY29sbGlzaW9uLlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqIEBwYXJhbSB7cGFpcn0gcGFpclxyXG4gICAgICogQHBhcmFtIHtjb2xsaXNpb259IGNvbGxpc2lvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxyXG4gICAgICovXHJcbiAgICBQYWlyLnVwZGF0ZSA9IGZ1bmN0aW9uKHBhaXIsIGNvbGxpc2lvbiwgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgdmFyIGNvbnRhY3RzID0gcGFpci5jb250YWN0cyxcclxuICAgICAgICAgICAgc3VwcG9ydHMgPSBjb2xsaXNpb24uc3VwcG9ydHMsXHJcbiAgICAgICAgICAgIGFjdGl2ZUNvbnRhY3RzID0gcGFpci5hY3RpdmVDb250YWN0cyxcclxuICAgICAgICAgICAgcGFyZW50QSA9IGNvbGxpc2lvbi5wYXJlbnRBLFxyXG4gICAgICAgICAgICBwYXJlbnRCID0gY29sbGlzaW9uLnBhcmVudEI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcGFpci5jb2xsaXNpb24gPSBjb2xsaXNpb247XHJcbiAgICAgICAgcGFpci5pbnZlcnNlTWFzcyA9IHBhcmVudEEuaW52ZXJzZU1hc3MgKyBwYXJlbnRCLmludmVyc2VNYXNzO1xyXG4gICAgICAgIHBhaXIuZnJpY3Rpb24gPSBNYXRoLm1pbihwYXJlbnRBLmZyaWN0aW9uLCBwYXJlbnRCLmZyaWN0aW9uKTtcclxuICAgICAgICBwYWlyLmZyaWN0aW9uU3RhdGljID0gTWF0aC5tYXgocGFyZW50QS5mcmljdGlvblN0YXRpYywgcGFyZW50Qi5mcmljdGlvblN0YXRpYyk7XHJcbiAgICAgICAgcGFpci5yZXN0aXR1dGlvbiA9IE1hdGgubWF4KHBhcmVudEEucmVzdGl0dXRpb24sIHBhcmVudEIucmVzdGl0dXRpb24pO1xyXG4gICAgICAgIHBhaXIuc2xvcCA9IE1hdGgubWF4KHBhcmVudEEuc2xvcCwgcGFyZW50Qi5zbG9wKTtcclxuICAgICAgICBhY3RpdmVDb250YWN0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjb2xsaXNpb24uY29sbGlkZWQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdXBwb3J0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1cHBvcnQgPSBzdXBwb3J0c1tpXSxcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0SWQgPSBDb250YWN0LmlkKHN1cHBvcnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QgPSBjb250YWN0c1tjb250YWN0SWRdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb250YWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ29udGFjdHMucHVzaChjb250YWN0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ29udGFjdHMucHVzaChjb250YWN0c1tjb250YWN0SWRdID0gQ29udGFjdC5jcmVhdGUoc3VwcG9ydCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYWlyLnNlcGFyYXRpb24gPSBjb2xsaXNpb24uZGVwdGg7XHJcbiAgICAgICAgICAgIFBhaXIuc2V0QWN0aXZlKHBhaXIsIHRydWUsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHBhaXIuaXNBY3RpdmUgPT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICBQYWlyLnNldEFjdGl2ZShwYWlyLCBmYWxzZSwgdGltZXN0YW1wKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIHBhaXIgYXMgYWN0aXZlIG9yIGluYWN0aXZlLlxyXG4gICAgICogQG1ldGhvZCBzZXRBY3RpdmVcclxuICAgICAqIEBwYXJhbSB7cGFpcn0gcGFpclxyXG4gICAgICogQHBhcmFtIHtib29sfSBpc0FjdGl2ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxyXG4gICAgICovXHJcbiAgICBQYWlyLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHBhaXIsIGlzQWN0aXZlLCB0aW1lc3RhbXApIHtcclxuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgcGFpci5pc0FjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHBhaXIudGltZVVwZGF0ZWQgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFpci5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBwYWlyLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaWQgZm9yIHRoZSBnaXZlbiBwYWlyLlxyXG4gICAgICogQG1ldGhvZCBpZFxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBVbmlxdWUgcGFpcklkXHJcbiAgICAgKi9cclxuICAgIFBhaXIuaWQgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpIHtcclxuICAgICAgICBpZiAoYm9keUEuaWQgPCBib2R5Qi5pZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ0EnICsgYm9keUEuaWQgKyAnQicgKyBib2R5Qi5pZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ0EnICsgYm9keUIuaWQgKyAnQicgKyBib2R5QS5pZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1BhaXIuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9QYWlyLmpzIiwidmFyIEJ1ZmZlcjMyID0gZnVuY3Rpb24gKGJ5dGVTaXplKVxyXG57XHJcbiAgICB0aGlzLmR3b3JkTGVuZ3RoID0gMDtcclxuICAgIHRoaXMuZHdvcmRDYXBhY2l0eSA9IGJ5dGVTaXplIC8gNDtcclxuICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTaXplKTtcclxuICAgIHRoaXMuZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICB0aGlzLmludFZpZXcgPSBuZXcgSW50MzJBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICB0aGlzLnVpbnRWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuYnVmZmVyKTtcclxufTtcclxuXHJcbkJ1ZmZlcjMyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuZHdvcmRMZW5ndGggPSAwO1xyXG59O1xyXG5cclxuQnVmZmVyMzIucHJvdG90eXBlLmdldEJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5kd29yZExlbmd0aCAqIDQ7XHJcbn07XHJcblxyXG5CdWZmZXIzMi5wcm90b3R5cGUuZ2V0Qnl0ZUNhcGFjaXR5ID0gZnVuY3Rpb24gKCkgXHJcbntcclxuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG59O1xyXG5cclxuQnVmZmVyMzIucHJvdG90eXBlLmFsbG9jYXRlID0gZnVuY3Rpb24gKGR3b3JkU2l6ZSlcclxue1xyXG4gICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLmR3b3JkTGVuZ3RoO1xyXG4gICAgdGhpcy5kd29yZExlbmd0aCArPSBkd29yZFNpemU7XHJcbiAgICByZXR1cm4gY3VycmVudExlbmd0aDtcclxufTtcclxuXHJcbkJ1ZmZlcjMyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNGbG9hdCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmZsb2F0Vmlldy5zdWJhcnJheSgwLCB0aGlzLmR3b3JkTGVuZ3RoKTtcclxufTtcclxuXHJcbkJ1ZmZlcjMyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNJbnQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5pbnRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xyXG59O1xyXG5cclxuQnVmZmVyMzIucHJvdG90eXBlLmdldFVzZWRCdWZmZXJBc1VpbnQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy51aW50Vmlldy5zdWJhcnJheSgwLCB0aGlzLmR3b3JkTGVuZ3RoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyMzI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL2J1ZmZlci9CdWZmZXIzMi5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uIChnbCwgYnVmZmVyVHlwZSwgdXNhZ2UsIGJ1ZmZlckRhdGEsIGJ1ZmZlclNpemUpXHJcbntcclxuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIGdsLmJpbmRCdWZmZXIoYnVmZmVyVHlwZSwgYnVmZmVyKTtcclxuICAgIGlmIChidWZmZXJEYXRhICYmIEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXJEYXRhKSlcclxuICAgIHtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGJ1ZmZlclR5cGUsIGJ1ZmZlckRhdGEsIHVzYWdlKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGJ1ZmZlclR5cGUsIGJ1ZmZlclNpemUsIHVzYWdlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBidWZmZXI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZUJ1ZmZlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvYnVmZmVyL0NyZWF0ZUJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbiAoZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpXHJcbntcclxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XHJcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICBnbC52YWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsaW5rIHByb2dyYW0uIEVycm9yOiBcXG4nICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb2dyYW07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVByb2dyYW07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3JlYXRlU2hhZGVyID0gZnVuY3Rpb24gKGdsLCBzaGFkZXJTb3VyY2UsIHNoYWRlclR5cGUpXHJcbntcclxuICAgIHZhciBzaGFkZXIgPSBudWxsO1xyXG4gICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xyXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCAnICsgKHNoYWRlclR5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyAndmVydGV4JyA6IHNoYWRlclR5cGUgPT09IGdsLkZSQUdNRU5UX1NIQURFUiA/ICdmcmFnbWVudCcgOiAnaW52YWxpZCcpICsgJyBzaGFkZXIgY29tcGlsYXRpb24uIEVycm9yOiBcXG4nICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBzaGFkZXI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVNoYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJpbmRWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uIChnbCwgdmFvKVxyXG57XHJcbiAgICB2YXIgYXR0cmlidXRlcyA9IHZhby5hdHRyaWJ1dGVzO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZhby5idWZmZXIpO1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGF0dHJpYiA9IGF0dHJpYnV0ZXNbaW5kZXhdO1xyXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGF0dHJpYi5sb2NhdGlvbjtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuICAgICAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgICAgIGF0dHJpYi5zaXplLFxyXG4gICAgICAgICAgICBhdHRyaWIudHlwZSxcclxuICAgICAgICAgICAgYXR0cmliLm5vcm1hbGl6ZWQsXHJcbiAgICAgICAgICAgIGF0dHJpYi5zdHJpZGUsXHJcbiAgICAgICAgICAgIGF0dHJpYi5vZmZzZXRcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaW5kVmVydGV4QXJyYXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9CaW5kVmVydGV4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL0F0dHJpYnV0ZScpO1xyXG5cclxudmFyIENyZWF0ZUF0dHJpYkRlc2MgPSBmdW5jdGlvbiAoZ2wsIHByb2dyYW0sIG5hbWUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KVxyXG57XHJcbiAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZShcclxuICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcclxuICAgICAgICBzaXplLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgbm9ybWFsaXplZCxcclxuICAgICAgICBzdHJpZGUsXHJcbiAgICAgICAgb2Zmc2V0XHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVBdHRyaWJEZXNjO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MuanMiLCJ2YXIgVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAodmJvLCBhdHRyaWJ1dGVzKVxyXG57XHJcbiAgICB0aGlzLmJ1ZmZlciA9IHZibztcclxuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEFycmF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vVmVydGV4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9Jc1BsYWluT2JqZWN0Jyk7XHJcblxyXG4vKipcclxuKiBUaGlzIGlzIGEgc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwOi8vYXBpLmpxdWVyeS5jb20valF1ZXJ5LmV4dGVuZC9cclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5VdGlscy5leHRlbmRcclxuKiBAcGFyYW0ge2Jvb2xlYW59IGRlZXAgLSBQZXJmb3JtIGEgZGVlcCBjb3B5P1xyXG4qIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCB0byBjb3B5IHRvLlxyXG4qIEByZXR1cm4ge29iamVjdH0gVGhlIGV4dGVuZGVkIG9iamVjdC5cclxuKi9cclxudmFyIEV4dGVuZCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcclxuICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXHJcbiAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcclxuICAgICAgICBkZWVwID0gZmFsc2U7XHJcblxyXG4gICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxyXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiKVxyXG4gICAge1xyXG4gICAgICAgIGRlZXAgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xyXG4gICAgICAgIC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcclxuICAgICAgICBpID0gMjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBleHRlbmQgUGhhc2VyIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxyXG4gICAgaWYgKGxlbmd0aCA9PT0gaSlcclxuICAgIHtcclxuICAgICAgICB0YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgIC0taTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcclxuICAgICAgICBpZiAoKG9wdGlvbnMgPSBhcmd1bWVudHNbaV0pICE9IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XHJcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1tuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBjb3B5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZXAgJiYgY29weSAmJiAoSXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvcHkpKSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheShzcmMpID8gc3JjIDogW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIElzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gRXh0ZW5kKGRlZXAsIGNsb25lLCBjb3B5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gY29weTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXh0ZW5kO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9vYmplY3QvRXh0ZW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9vYmplY3QvRXh0ZW5kLmpzIiwidmFyIENhbnZhc0ludGVycG9sYXRpb24gPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldHMgdGhlIENTUyBpbWFnZS1yZW5kZXJpbmcgcHJvcGVydHkgb24gdGhlIGdpdmVuIGNhbnZhcyB0byBiZSAnY3Jpc3AnIChha2EgJ29wdGltaXplIGNvbnRyYXN0JyBvbiB3ZWJraXQpLlxyXG4gICAgKiBOb3RlIHRoYXQgaWYgdGhpcyBkb2Vzbid0IGdpdmVuIHRoZSBkZXNpcmVkIHJlc3VsdCB0aGVuIHNlZSB0aGUgc2V0U21vb3RoaW5nRW5hYmxlZC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzLnNldEltYWdlUmVuZGVyaW5nQ3Jpc3BcclxuICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyB0byBzZXQgaW1hZ2UtcmVuZGVyaW5nIGNyaXNwIG9uLlxyXG4gICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gUmV0dXJucyB0aGUgc291cmNlIGNhbnZhcy5cclxuICAgICovXHJcbiAgICBzZXRDcmlzcDogZnVuY3Rpb24gKGNhbnZhcylcclxuICAgIHtcclxuICAgICAgICB2YXIgdHlwZXMgPSBbICdvcHRpbWl6ZVNwZWVkJywgJ2NyaXNwLWVkZ2VzJywgJy1tb3otY3Jpc3AtZWRnZXMnLCAnLXdlYmtpdC1vcHRpbWl6ZS1jb250cmFzdCcsICdvcHRpbWl6ZS1jb250cmFzdCcsICdwaXhlbGF0ZWQnIF07XHJcblxyXG4gICAgICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24odHlwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZVsnaW1hZ2UtcmVuZGVyaW5nJ10gPSB0eXBlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjYW52YXMuc3R5bGUubXNJbnRlcnBvbGF0aW9uTW9kZSA9ICduZWFyZXN0LW5laWdoYm9yJztcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldHMgdGhlIENTUyBpbWFnZS1yZW5kZXJpbmcgcHJvcGVydHkgb24gdGhlIGdpdmVuIGNhbnZhcyB0byBiZSAnYmljdWJpYycgKGFrYSAnYXV0bycpLlxyXG4gICAgKiBOb3RlIHRoYXQgaWYgdGhpcyBkb2Vzbid0IGdpdmVuIHRoZSBkZXNpcmVkIHJlc3VsdCB0aGVuIHNlZSB0aGUgQ2FudmFzVXRpbHMuc2V0U21vb3RoaW5nRW5hYmxlZCBtZXRob2QuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkNhbnZhcy5zZXRJbWFnZVJlbmRlcmluZ0JpY3ViaWNcclxuICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIFRoZSBjYW52YXMgdG8gc2V0IGltYWdlLXJlbmRlcmluZyBiaWN1YmljIG9uLlxyXG4gICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gUmV0dXJucyB0aGUgc291cmNlIGNhbnZhcy5cclxuICAgICovXHJcbiAgICBzZXRCaWN1YmljOiBmdW5jdGlvbiAoY2FudmFzKVxyXG4gICAge1xyXG4gICAgICAgIGNhbnZhcy5zdHlsZVsnaW1hZ2UtcmVuZGVyaW5nJ10gPSAnYXV0byc7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlLm1zSW50ZXJwb2xhdGlvbk1vZGUgPSAnYmljdWJpYyc7XHJcblxyXG4gICAgICAgIHJldHVybiBjYW52YXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNJbnRlcnBvbGF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kb20vQ2FudmFzSW50ZXJwb2xhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBBUkM6IDAsXHJcbiAgICBCRUdJTl9QQVRIOiAxLFxyXG4gICAgQ0xPU0VfUEFUSDogMixcclxuICAgIEZJTExfUkVDVDogMyxcclxuICAgIExJTkVfVE86IDQsXHJcbiAgICBNT1ZFX1RPOiA1LFxyXG4gICAgTElORV9TVFlMRTogNixcclxuICAgIEZJTExfU1RZTEU6IDcsXHJcbiAgICBGSUxMX1BBVEg6IDgsXHJcbiAgICBTVFJPS0VfUEFUSDogOSxcclxuICAgIEZJTExfVFJJQU5HTEU6IDEwLFxyXG4gICAgU1RST0tFX1RSSUFOR0xFOiAxMVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9Db21tYW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKGNpcmNsZSwgeCwgeSlcclxue1xyXG4gICAgLy8gIENoZWNrIGlmIHgveSBhcmUgd2l0aGluIHRoZSBib3VuZHMgZmlyc3RcclxuICAgIGlmIChjaXJjbGUucmFkaXVzID4gMCAmJiB4ID49IGNpcmNsZS5sZWZ0ICYmIHggPD0gY2lyY2xlLnJpZ2h0ICYmIHkgPj0gY2lyY2xlLnRvcCAmJiB5IDw9IGNpcmNsZS5ib3R0b20pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGR4ID0gKGNpcmNsZS54IC0geCkgKiAoY2lyY2xlLnggLSB4KTtcclxuICAgICAgICB2YXIgZHkgPSAoY2lyY2xlLnkgLSB5KSAqIChjaXJjbGUueSAtIHkpO1xyXG5cclxuICAgICAgICByZXR1cm4gKGR4ICsgZHkpIDw9IChjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cyk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWlucztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWlucyA9IGZ1bmN0aW9uIChlbGxpcHNlLCB4LCB5KVxyXG57XHJcbiAgICBpZiAoZWxsaXBzZS53aWR0aCA8PSAwIHx8IGVsbGlwc2UuaGVpZ2h0IDw9IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gXHJcbiAgICAvLyAgTm9ybWFsaXplIHRoZSBjb29yZHMgdG8gYW4gZWxsaXBzZSB3aXRoIGNlbnRlciAwLDAgYW5kIGEgcmFkaXVzIG9mIDAuNVxyXG4gICAgdmFyIG5vcm14ID0gKCh4IC0gZWxsaXBzZS54KSAvIGVsbGlwc2Uud2lkdGgpIC0gMC41O1xyXG4gICAgdmFyIG5vcm15ID0gKCh5IC0gZWxsaXBzZS55KSAvIGVsbGlwc2UuaGVpZ2h0KSAtIDAuNTtcclxuIFxyXG4gICAgbm9ybXggKj0gbm9ybXg7XHJcbiAgICBub3JteSAqPSBub3JteTtcclxuIFxyXG4gICAgcmV0dXJuIChub3JteCArIG5vcm15IDwgMC4yNSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENvbnZlcnQgYSBkaXN0YW5jZSBhbG9uZyB0aGlzIGN1cnZlIGludG8gYSBgdGltZWAgdmFsdWUgd2hpY2ggd2lsbCBiZSBiZXR3ZWVuIDAgYW5kIDEuXHJcbiogXHJcbiogRm9yIGV4YW1wbGUgaWYgdGhpcyBjdXJ2ZSBoYXMgYSBsZW5ndGggb2YgMTAwIHBpeGVscyB0aGVuIGBmaW5kVCg1MClgIHdvdWxkIHJldHVybiBgMC41YC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZmluZFRcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGRpc3RhbmNlIC0gVGhlIGRpc3RhbmNlIGludG8gdGhlIGN1cnZlIGluIHBpeGVscy4gU2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0aW1lIChgdGApIHZhbHVlLCBhIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cclxuKi9cclxudmFyIEZpbmRUID0gZnVuY3Rpb24gKGN1cnZlLCBkaXN0YW5jZSlcclxue1xyXG4gICAgaWYgKGRpc3RhbmNlIDw9IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZpbmQgdGhlIF9wb2ludHMgd2hpY2ggYnJhY2tldCB0aGUgZGlzdGFuY2UgdmFsdWVcclxuICAgIHZhciB0aSA9IE1hdGguZmxvb3IoZGlzdGFuY2UgLyBjdXJ2ZS5sZW5ndGggKiBjdXJ2ZS5fYWNjdXJhY3kpO1xyXG5cclxuICAgIHdoaWxlICh0aSA+IDAgJiYgY3VydmUuX3BvaW50c1t0aV0gPiBkaXN0YW5jZSlcclxuICAgIHtcclxuICAgICAgICB0aS0tO1xyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlICh0aSA8IGN1cnZlLl9hY2N1cmFjeSAmJiBjdXJ2ZS5fcG9pbnRzW3RpXSA8IGRpc3RhbmNlKVxyXG4gICAge1xyXG4gICAgICAgIHRpKys7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIExpbmVhciBpbnRlcnBvbGF0aW9uIHRvIGdldCBhIG1vcmUgYWNjdXJhdGUgZml4XHJcbiAgICB2YXIgZHQgPSBjdXJ2ZS5fcG9pbnRzW3RpXSAtIGN1cnZlLl9wb2ludHNbdGkgLSAxXTtcclxuICAgIHZhciBkID0gZGlzdGFuY2UgLSBjdXJ2ZS5fcG9pbnRzW3RpIC0gMV07XHJcblxyXG4gICAgcmV0dXJuICgodGkgLSAxKSAvIGN1cnZlLl9hY2N1cmFjeSkgKyBkIC8gKGR0ICogY3VydmUuX2FjY3VyYWN5KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmluZFQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9GaW5kVC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbi8qKlxyXG4qIEdldCBhIHBvaW50IG9uIHRoZSBjdXJ2ZSB1c2luZyB0aGUgYHRgICh0aW1lKSB2YWx1ZSwgd2hpY2ggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldFBvaW50XHJcbiogQHBhcmFtIHtudW1iZXJ9IFt0PTBdIC0gVGhlIHRpbWUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCBhIHBvaW50LiBUaGlzIGlzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCB3aGVyZSAwIHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZSBhbmQgMSB0aGUgZW5kLlxyXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fE9iamVjdH0gW3BvaW50XSAtIEFuIG9wdGlvbmFsIFBoYXNlci5Qb2ludCwgb3IgT2JqZWN0IGNvbnRhaW5pbmcgcHVibGljIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuIElmIGdpdmVuIHRoZSByZXN1bHRpbmcgdmFsdWVzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBPYmplY3RzIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuIElmIG9taXR0ZWQgYSBuZXcgUGhhc2VyLlBvaW50IG9iamVjdCBpcyBjcmVhdGVkLlxyXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gQW4gT2JqZWN0IHdpdGggdGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgYXQgdGhlIHNwZWNpZmllZCBgdGAgdmFsdWUgc2V0IGluIGl0cyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLlxyXG4qL1xyXG52YXIgR2V0UG9pbnQgPSBmdW5jdGlvbiAoY3VydmUsIHQsIG91dClcclxue1xyXG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgeyB0ID0gMDsgfVxyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgaWYgKHQgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIHQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0ID4gMSlcclxuICAgIHtcclxuICAgICAgICB0ID0gMTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdDIgPSB0ICogdDtcclxuICAgIHZhciB0MyA9IHQgKiB0MjtcclxuXHJcbiAgICBvdXQueCA9IHQzICogY3VydmUuX2F4ICsgdDIgKiBjdXJ2ZS5fYnggKyB0ICogY3VydmUuX3YxeCArIGN1cnZlLl9wMXg7XHJcbiAgICBvdXQueSA9IHQzICogY3VydmUuX2F5ICsgdDIgKiBjdXJ2ZS5fYnkgKyB0ICogY3VydmUuX3YxeSArIGN1cnZlLl9wMXk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL0dldFBvaW50LmpzIiwiXHJcbnZhciBSb3RhdGVBcm91bmRYWSA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5LCBhbmdsZSlcclxue1xyXG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICB2YXIgdHggPSBsaW5lLngxIC0geDtcclxuICAgIHZhciB0eSA9IGxpbmUueTEgLSB5O1xyXG5cclxuICAgIGxpbmUueDEgPSB0eCAqIGMgLSB0eSAqIHMgKyB4O1xyXG4gICAgbGluZS55MSA9IHR4ICogcyArIHR5ICogYyArIHk7XHJcblxyXG4gICAgdHggPSBsaW5lLngyIC0geDtcclxuICAgIHR5ID0gbGluZS55MiAtIHk7XHJcblxyXG4gICAgbGluZS54MiA9IHR4ICogYyAtIHR5ICogcyArIHg7XHJcbiAgICBsaW5lLnkyID0gdHggKiBzICsgdHkgKiBjICsgeTtcclxuXHJcbiAgICByZXR1cm4gbGluZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kWFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9Sb3RhdGVBcm91bmRYWS5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERvdCA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qilcclxue1xyXG4gICAgcmV0dXJuICgocG9pbnRBLnggKiBwb2ludEIueCkgKyAocG9pbnRBLnkgKiBwb2ludEIueSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEb3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvRG90LmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0QXNwZWN0UmF0aW8gPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmV0dXJuIChyZWN0LmhlaWdodCA9PT0gMCkgPyBOYU4gOiByZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEFzcGVjdFJhdGlvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9HZXRBc3BlY3RSYXRpby5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEdpdmVuIDMgY29sb3IgdmFsdWVzIHRoaXMgd2lsbCByZXR1cm4gYW4gaW50ZWdlciByZXByZXNlbnRhdGlvbiBvZiBpdC5cclxuICpcclxuICogQG1ldGhvZCBnZXRDb2xvclxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHIgLSBUaGUgcmVkIGNvbG9yIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cclxuICogQHBhcmFtIHtpbnRlZ2VyfSBnIC0gVGhlIGdyZWVuIGNvbG9yIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cclxuICogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJsdWUgY29sb3IgY29tcG9uZW50IGluIHRoZSByYW5nZSAwIC0gMjU1LlxyXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfSBBIG5hdGl2ZSBjb2xvciB2YWx1ZSBpbnRlZ2VyIChmb3JtYXQ6IDB4UlJHR0JCKS5cclxuICovXHJcbnZhciBHZXRDb2xvciA9IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlKVxyXG57XHJcbiAgICByZXR1cm4gcmVkIDw8IDE2IHwgZ3JlZW4gPDwgOCB8IGJsdWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldENvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9HZXRDb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBCQUNLU1BBQ0U6IDgsXHJcbiAgICBUQUI6IDksXHJcbiAgICBFTlRFUjogMTMsXHJcblxyXG4gICAgU0hJRlQ6IDE2LFxyXG4gICAgQ1RSTDogMTcsXHJcbiAgICBBTFQ6IDE4LFxyXG5cclxuICAgIFBBVVNFOiAxOSxcclxuICAgIENBUFNfTE9DSzogMjAsXHJcbiAgICBFU0M6IDI3LFxyXG4gICAgU1BBQ0U6IDMyLFxyXG5cclxuICAgIFBBR0VfVVA6IDMzLFxyXG4gICAgUEFHRV9ET1dOOiAzNCxcclxuICAgIEVORDogMzUsXHJcbiAgICBIT01FOiAzNixcclxuXHJcbiAgICBMRUZUOiAzNyxcclxuICAgIFVQOiAzOCxcclxuICAgIFJJR0hUOiAzOSxcclxuICAgIERPV046IDQwLFxyXG5cclxuICAgIFBSSU5UX1NDUkVFTjogNDIsXHJcbiAgICBJTlNFUlQ6IDQ1LFxyXG4gICAgREVMRVRFOiA0NixcclxuXHJcbiAgICBaRVJPOiA0OCxcclxuICAgIE9ORTogNDksXHJcbiAgICBUV086IDUwLFxyXG4gICAgVEhSRUU6IDUxLFxyXG4gICAgRk9VUjogNTIsXHJcbiAgICBGSVZFOiA1MyxcclxuICAgIFNJWDogNTQsXHJcbiAgICBTRVZFTjogNTUsXHJcbiAgICBFSUdIVDogNTYsXHJcbiAgICBOSU5FOiA1NyxcclxuXHJcbiAgICBBOiA2NSxcclxuICAgIEI6IDY2LFxyXG4gICAgQzogNjcsXHJcbiAgICBEOiA2OCxcclxuICAgIEU6IDY5LFxyXG4gICAgRjogNzAsXHJcbiAgICBHOiA3MSxcclxuICAgIEg6IDcyLFxyXG4gICAgSTogNzMsXHJcbiAgICBKOiA3NCxcclxuICAgIEs6IDc1LFxyXG4gICAgTDogNzYsXHJcbiAgICBNOiA3NyxcclxuICAgIE46IDc4LFxyXG4gICAgTzogNzksXHJcbiAgICBQOiA4MCxcclxuICAgIFE6IDgxLFxyXG4gICAgUjogODIsXHJcbiAgICBTOiA4MyxcclxuICAgIFQ6IDg0LFxyXG4gICAgVTogODUsXHJcbiAgICBWOiA4NixcclxuICAgIFc6IDg3LFxyXG4gICAgWDogODgsXHJcbiAgICBZOiA4OSxcclxuICAgIFo6IDkwLFxyXG5cclxuICAgIEYxOiAxMTIsXHJcbiAgICBGMjogMTEzLFxyXG4gICAgRjM6IDExNCxcclxuICAgIEY0OiAxMTUsXHJcbiAgICBGNTogMTE2LFxyXG4gICAgRjY6IDExNyxcclxuICAgIEY3OiAxMTgsXHJcbiAgICBGODogMTE5LFxyXG4gICAgRjk6IDEyMCxcclxuICAgIEYxMDogMTIxLFxyXG4gICAgRjExOiAxMjIsXHJcbiAgICBGMTI6IDEyMyxcclxuXHJcbiAgICBTRU1JQ09MT046IDE4NixcclxuICAgIFBMVVM6IDE4NyxcclxuICAgIENPTU1BOiAxODgsXHJcbiAgICBNSU5VUzogMTg5LFxyXG4gICAgUEVSSU9EOiAxOTAsXHJcbiAgICBGT1JXQURfU0xBU0g6IDE5MSxcclxuICAgIEJBQ0tfU0xBU0g6IDIyMCxcclxuICAgIFFVT1RFUzogMjIyXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2tleXMvS2V5Q29kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBDcmVhdGVzIGFuIFhIUlNldHRpbmdzIE9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcblxyXG52YXIgWEhSU2V0dGluZ3MgPSBmdW5jdGlvbiAocmVzcG9uc2VUeXBlLCBhc3luYywgdXNlciwgcGFzc3dvcmQsIHRpbWVvdXQpXHJcbntcclxuICAgIGlmIChyZXNwb25zZVR5cGUgPT09IHVuZGVmaW5lZCkgeyByZXNwb25zZVR5cGUgPSAnJzsgfVxyXG4gICAgaWYgKGFzeW5jID09PSB1bmRlZmluZWQpIHsgYXN5bmMgPSB0cnVlOyB9XHJcbiAgICBpZiAodXNlciA9PT0gdW5kZWZpbmVkKSB7IHVzZXIgPSAnJzsgfVxyXG4gICAgaWYgKHBhc3N3b3JkID09PSB1bmRlZmluZWQpIHsgcGFzc3dvcmQgPSAnJzsgfVxyXG4gICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkgeyB0aW1lb3V0ID0gMDsgfVxyXG5cclxuICAgIC8vIEJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCwgc2V0IHRoZSB4aHIucmVzcG9uc2VUeXBlIHRvIFwidGV4dFwiLCBcclxuICAgIC8vIFwiYXJyYXlidWZmZXJcIiwgXCJibG9iXCIsIG9yIFwiZG9jdW1lbnRcIiwgZGVwZW5kaW5nIG9uIHlvdXIgZGF0YSBuZWVkcy4gXHJcbiAgICAvLyBOb3RlLCBzZXR0aW5nIHhoci5yZXNwb25zZVR5cGUgPSAnJyAob3Igb21pdHRpbmcpIHdpbGwgZGVmYXVsdCB0aGUgcmVzcG9uc2UgdG8gXCJ0ZXh0XCIuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgLy8gIElnbm9yZWQgYnkgdGhlIExvYWRlciwgb25seSB1c2VkIGJ5IEZpbGUuXHJcbiAgICAgICAgcmVzcG9uc2VUeXBlOiByZXNwb25zZVR5cGUsXHJcblxyXG4gICAgICAgIGFzeW5jOiBhc3luYyxcclxuXHJcbiAgICAgICAgLy8gIGNyZWRlbnRpYWxzXHJcbiAgICAgICAgdXNlcjogdXNlcixcclxuICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXHJcblxyXG4gICAgICAgIC8vICB0aW1lb3V0IGluIG1zICgwID0gbm8gdGltZW91dClcclxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxyXG5cclxuICAgICAgICAvLyAgc2V0UmVxdWVzdEhlYWRlclxyXG4gICAgICAgIGhlYWRlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgIGhlYWRlclZhbHVlOiB1bmRlZmluZWQsXHJcblxyXG4gICAgICAgIC8vICBvdmVycmlkZU1pbWVUeXBlXHJcbiAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogdW5kZWZpbmVkXHJcblxyXG4gICAgfTtcclxuICAgIFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYSFJTZXR0aW5ncztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL1hIUlNldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlbiA9IGZ1bmN0aW9uIChtaW4sIG1heClcclxue1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuRGV0ZWN0b3JgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBkZXRlY3RpbmcgY29sbGlzaW9ucyBnaXZlbiBhIHNldCBvZiBwYWlycy5cclxuKlxyXG4qIEBjbGFzcyBEZXRlY3RvclxyXG4qL1xyXG5cclxuLy8gVE9ETzogc3BlY3VsYXRpdmUgY29udGFjdHNcclxuXHJcbnZhciBEZXRlY3RvciA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZXRlY3RvcjtcclxuXHJcbnZhciBTQVQgPSByZXF1aXJlKCcuL1NBVCcpO1xyXG52YXIgUGFpciA9IHJlcXVpcmUoJy4vUGFpcicpO1xyXG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyBhbGwgY29sbGlzaW9ucyBnaXZlbiBhIGxpc3Qgb2YgcGFpcnMuXHJcbiAgICAgKiBAbWV0aG9kIGNvbGxpc2lvbnNcclxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBicm9hZHBoYXNlUGFpcnNcclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcclxuICAgICAqIEByZXR1cm4ge2FycmF5fSBjb2xsaXNpb25zXHJcbiAgICAgKi9cclxuICAgIERldGVjdG9yLmNvbGxpc2lvbnMgPSBmdW5jdGlvbihicm9hZHBoYXNlUGFpcnMsIGVuZ2luZSkge1xyXG4gICAgICAgIHZhciBjb2xsaXNpb25zID0gW10sXHJcbiAgICAgICAgICAgIHBhaXJzVGFibGUgPSBlbmdpbmUucGFpcnMudGFibGU7XHJcblxyXG4gICAgICAgIC8vIEBpZiBERUJVR1xyXG4gICAgICAgIHZhciBtZXRyaWNzID0gZW5naW5lLm1ldHJpY3M7XHJcbiAgICAgICAgLy8gQGVuZGlmXHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicm9hZHBoYXNlUGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHlBID0gYnJvYWRwaGFzZVBhaXJzW2ldWzBdLCBcclxuICAgICAgICAgICAgICAgIGJvZHlCID0gYnJvYWRwaGFzZVBhaXJzW2ldWzFdO1xyXG5cclxuICAgICAgICAgICAgaWYgKChib2R5QS5pc1N0YXRpYyB8fCBib2R5QS5pc1NsZWVwaW5nKSAmJiAoYm9keUIuaXNTdGF0aWMgfHwgYm9keUIuaXNTbGVlcGluZykpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICghRGV0ZWN0b3IuY2FuQ29sbGlkZShib2R5QS5jb2xsaXNpb25GaWx0ZXIsIGJvZHlCLmNvbGxpc2lvbkZpbHRlcikpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEBpZiBERUJVR1xyXG4gICAgICAgICAgICBtZXRyaWNzLm1pZHBoYXNlVGVzdHMgKz0gMTtcclxuICAgICAgICAgICAgLy8gQGVuZGlmXHJcblxyXG4gICAgICAgICAgICAvLyBtaWQgcGhhc2VcclxuICAgICAgICAgICAgaWYgKEJvdW5kcy5vdmVybGFwcyhib2R5QS5ib3VuZHMsIGJvZHlCLmJvdW5kcykpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBib2R5QS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBib2R5QS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0QSA9IGJvZHlBLnBhcnRzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gYm9keUIucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBrIDwgYm9keUIucGFydHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRCID0gYm9keUIucGFydHNba107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHBhcnRBID09PSBib2R5QSAmJiBwYXJ0QiA9PT0gYm9keUIpIHx8IEJvdW5kcy5vdmVybGFwcyhwYXJ0QS5ib3VuZHMsIHBhcnRCLmJvdW5kcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgYSBwcmV2aW91cyBjb2xsaXNpb24gd2UgY291bGQgcmV1c2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWlySWQgPSBQYWlyLmlkKHBhcnRBLCBwYXJ0QiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpciA9IHBhaXJzVGFibGVbcGFpcklkXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NvbGxpc2lvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFpciAmJiBwYWlyLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDb2xsaXNpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5hcnJvdyBwaGFzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IFNBVC5jb2xsaWRlcyhwYXJ0QSwgcGFydEIsIHByZXZpb3VzQ29sbGlzaW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAaWYgREVCVUdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY3MubmFycm93cGhhc2VUZXN0cyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxpc2lvbi5yZXVzZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5uYXJyb3dSZXVzZUNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAZW5kaWZcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uLmNvbGxpZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9ucy5wdXNoKGNvbGxpc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQGlmIERFQlVHXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5uYXJyb3dEZXRlY3Rpb25zICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQGVuZGlmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb2xsaXNpb25zO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGJvdGggc3VwcGxpZWQgY29sbGlzaW9uIGZpbHRlcnMgd2lsbCBhbGxvdyBhIGNvbGxpc2lvbiB0byBvY2N1ci5cclxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICogQG1ldGhvZCBjYW5Db2xsaWRlXHJcbiAgICAgKiBAcGFyYW0ge30gZmlsdGVyQVxyXG4gICAgICogQHBhcmFtIHt9IGZpbHRlckJcclxuICAgICAqIEByZXR1cm4ge2Jvb2x9IGB0cnVlYCBpZiBjb2xsaXNpb24gY2FuIG9jY3VyXHJcbiAgICAgKi9cclxuICAgIERldGVjdG9yLmNhbkNvbGxpZGUgPSBmdW5jdGlvbihmaWx0ZXJBLCBmaWx0ZXJCKSB7XHJcbiAgICAgICAgaWYgKGZpbHRlckEuZ3JvdXAgPT09IGZpbHRlckIuZ3JvdXAgJiYgZmlsdGVyQS5ncm91cCAhPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckEuZ3JvdXAgPiAwO1xyXG5cclxuICAgICAgICByZXR1cm4gKGZpbHRlckEubWFzayAmIGZpbHRlckIuY2F0ZWdvcnkpICE9PSAwICYmIChmaWx0ZXJCLm1hc2sgJiBmaWx0ZXJBLmNhdGVnb3J5KSAhPT0gMDtcclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vRGV0ZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9EZXRlY3Rvci5qcyIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLkdyaWRgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGNvbGxpc2lvbiBicm9hZHBoYXNlIGdyaWQgc3RydWN0dXJlcy5cclxuKlxyXG4qIEBjbGFzcyBHcmlkXHJcbiovXHJcblxyXG52YXIgR3JpZCA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHcmlkO1xyXG5cclxudmFyIFBhaXIgPSByZXF1aXJlKCcuL1BhaXInKTtcclxudmFyIERldGVjdG9yID0gcmVxdWlyZSgnLi9EZXRlY3RvcicpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZ3JpZC5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7Z3JpZH0gQSBuZXcgZ3JpZFxyXG4gICAgICovXHJcbiAgICBHcmlkLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IEdyaWQsXHJcbiAgICAgICAgICAgIGRldGVjdG9yOiBEZXRlY3Rvci5jb2xsaXNpb25zLFxyXG4gICAgICAgICAgICBidWNrZXRzOiB7fSxcclxuICAgICAgICAgICAgcGFpcnM6IHt9LFxyXG4gICAgICAgICAgICBwYWlyc0xpc3Q6IFtdLFxyXG4gICAgICAgICAgICBidWNrZXRXaWR0aDogNDgsXHJcbiAgICAgICAgICAgIGJ1Y2tldEhlaWdodDogNDhcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIGEgc2luZ2xlIGdyaWQgYnVja2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBidWNrZXRXaWR0aFxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCA0OFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIGEgc2luZ2xlIGdyaWQgYnVja2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBidWNrZXRIZWlnaHRcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgNDhcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgZ3JpZC5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge2dyaWR9IGdyaWRcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VVcGRhdGVcclxuICAgICAqL1xyXG4gICAgR3JpZC51cGRhdGUgPSBmdW5jdGlvbihncmlkLCBib2RpZXMsIGVuZ2luZSwgZm9yY2VVcGRhdGUpIHtcclxuICAgICAgICB2YXIgaSwgY29sLCByb3csXHJcbiAgICAgICAgICAgIHdvcmxkID0gZW5naW5lLndvcmxkLFxyXG4gICAgICAgICAgICBidWNrZXRzID0gZ3JpZC5idWNrZXRzLFxyXG4gICAgICAgICAgICBidWNrZXQsXHJcbiAgICAgICAgICAgIGJ1Y2tldElkLFxyXG4gICAgICAgICAgICBncmlkQ2hhbmdlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBAaWYgREVCVUdcclxuICAgICAgICB2YXIgbWV0cmljcyA9IGVuZ2luZS5tZXRyaWNzO1xyXG4gICAgICAgIG1ldHJpY3MuYnJvYWRwaGFzZVRlc3RzID0gMDtcclxuICAgICAgICAvLyBAZW5kaWZcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChib2R5LmlzU2xlZXBpbmcgJiYgIWZvcmNlVXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAvLyBkb24ndCB1cGRhdGUgb3V0IG9mIHdvcmxkIGJvZGllc1xyXG4gICAgICAgICAgICBpZiAoYm9keS5ib3VuZHMubWF4LnggPCB3b3JsZC5ib3VuZHMubWluLnggfHwgYm9keS5ib3VuZHMubWluLnggPiB3b3JsZC5ib3VuZHMubWF4LnhcclxuICAgICAgICAgICAgICAgIHx8IGJvZHkuYm91bmRzLm1heC55IDwgd29ybGQuYm91bmRzLm1pbi55IHx8IGJvZHkuYm91bmRzLm1pbi55ID4gd29ybGQuYm91bmRzLm1heC55KVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3UmVnaW9uID0gX2dldFJlZ2lvbihncmlkLCBib2R5KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBib2R5IGhhcyBjaGFuZ2VkIGdyaWQgcmVnaW9uXHJcbiAgICAgICAgICAgIGlmICghYm9keS5yZWdpb24gfHwgbmV3UmVnaW9uLmlkICE9PSBib2R5LnJlZ2lvbi5pZCB8fCBmb3JjZVVwZGF0ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEBpZiBERUJVR1xyXG4gICAgICAgICAgICAgICAgbWV0cmljcy5icm9hZHBoYXNlVGVzdHMgKz0gMTtcclxuICAgICAgICAgICAgICAgIC8vIEBlbmRpZlxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghYm9keS5yZWdpb24gfHwgZm9yY2VVcGRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5yZWdpb24gPSBuZXdSZWdpb247XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHVuaW9uID0gX3JlZ2lvblVuaW9uKG5ld1JlZ2lvbiwgYm9keS5yZWdpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBncmlkIGJ1Y2tldHMgYWZmZWN0ZWQgYnkgcmVnaW9uIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSB1bmlvbiBvZiBib3RoIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIGZvciAoY29sID0gdW5pb24uc3RhcnRDb2w7IGNvbCA8PSB1bmlvbi5lbmRDb2w7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSB1bmlvbi5zdGFydFJvdzsgcm93IDw9IHVuaW9uLmVuZFJvdzsgcm93KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0SWQgPSBfZ2V0QnVja2V0SWQoY29sLCByb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSBidWNrZXRzW2J1Y2tldElkXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0luc2lkZU5ld1JlZ2lvbiA9IChjb2wgPj0gbmV3UmVnaW9uLnN0YXJ0Q29sICYmIGNvbCA8PSBuZXdSZWdpb24uZW5kQ29sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHJvdyA+PSBuZXdSZWdpb24uc3RhcnRSb3cgJiYgcm93IDw9IG5ld1JlZ2lvbi5lbmRSb3cpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzSW5zaWRlT2xkUmVnaW9uID0gKGNvbCA+PSBib2R5LnJlZ2lvbi5zdGFydENvbCAmJiBjb2wgPD0gYm9keS5yZWdpb24uZW5kQ29sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHJvdyA+PSBib2R5LnJlZ2lvbi5zdGFydFJvdyAmJiByb3cgPD0gYm9keS5yZWdpb24uZW5kUm93KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIG9sZCByZWdpb24gYnVja2V0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW5zaWRlTmV3UmVnaW9uICYmIGlzSW5zaWRlT2xkUmVnaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbnNpZGVPbGRSZWdpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVja2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYnVja2V0UmVtb3ZlQm9keShncmlkLCBidWNrZXQsIGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gbmV3IHJlZ2lvbiBidWNrZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5LnJlZ2lvbiA9PT0gbmV3UmVnaW9uIHx8IChpc0luc2lkZU5ld1JlZ2lvbiAmJiAhaXNJbnNpZGVPbGRSZWdpb24pIHx8IGZvcmNlVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1Y2tldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSBfY3JlYXRlQnVja2V0KGJ1Y2tldHMsIGJ1Y2tldElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9idWNrZXRBZGRCb2R5KGdyaWQsIGJ1Y2tldCwgYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBuZXcgcmVnaW9uXHJcbiAgICAgICAgICAgICAgICBib2R5LnJlZ2lvbiA9IG5ld1JlZ2lvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmbGFnIGNoYW5nZXMgc28gd2UgY2FuIHVwZGF0ZSBwYWlyc1xyXG4gICAgICAgICAgICAgICAgZ3JpZENoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1cGRhdGUgcGFpcnMgbGlzdCBvbmx5IGlmIHBhaXJzIGNoYW5nZWQgKGkuZS4gYSBib2R5IGNoYW5nZWQgcmVnaW9uKVxyXG4gICAgICAgIGlmIChncmlkQ2hhbmdlZClcclxuICAgICAgICAgICAgZ3JpZC5wYWlyc0xpc3QgPSBfY3JlYXRlQWN0aXZlUGFpcnNMaXN0KGdyaWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgZ3JpZC5cclxuICAgICAqIEBtZXRob2QgY2xlYXJcclxuICAgICAqIEBwYXJhbSB7Z3JpZH0gZ3JpZFxyXG4gICAgICovXHJcbiAgICBHcmlkLmNsZWFyID0gZnVuY3Rpb24oZ3JpZCkge1xyXG4gICAgICAgIGdyaWQuYnVja2V0cyA9IHt9O1xyXG4gICAgICAgIGdyaWQucGFpcnMgPSB7fTtcclxuICAgICAgICBncmlkLnBhaXJzTGlzdCA9IFtdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHRoZSB1bmlvbiBvZiB0d28gcmVnaW9ucy5cclxuICAgICAqIEBtZXRob2QgX3JlZ2lvblVuaW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHt9IHJlZ2lvbkFcclxuICAgICAqIEBwYXJhbSB7fSByZWdpb25CXHJcbiAgICAgKiBAcmV0dXJuIHt9IHJlZ2lvblxyXG4gICAgICovXHJcbiAgICB2YXIgX3JlZ2lvblVuaW9uID0gZnVuY3Rpb24ocmVnaW9uQSwgcmVnaW9uQikge1xyXG4gICAgICAgIHZhciBzdGFydENvbCA9IE1hdGgubWluKHJlZ2lvbkEuc3RhcnRDb2wsIHJlZ2lvbkIuc3RhcnRDb2wpLFxyXG4gICAgICAgICAgICBlbmRDb2wgPSBNYXRoLm1heChyZWdpb25BLmVuZENvbCwgcmVnaW9uQi5lbmRDb2wpLFxyXG4gICAgICAgICAgICBzdGFydFJvdyA9IE1hdGgubWluKHJlZ2lvbkEuc3RhcnRSb3csIHJlZ2lvbkIuc3RhcnRSb3cpLFxyXG4gICAgICAgICAgICBlbmRSb3cgPSBNYXRoLm1heChyZWdpb25BLmVuZFJvdywgcmVnaW9uQi5lbmRSb3cpO1xyXG5cclxuICAgICAgICByZXR1cm4gX2NyZWF0ZVJlZ2lvbihzdGFydENvbCwgZW5kQ29sLCBzdGFydFJvdywgZW5kUm93KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByZWdpb24gYSBnaXZlbiBib2R5IGZhbGxzIGluIGZvciBhIGdpdmVuIGdyaWQuXHJcbiAgICAgKiBAbWV0aG9kIF9nZXRSZWdpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxyXG4gICAgICogQHBhcmFtIHt9IGJvZHlcclxuICAgICAqIEByZXR1cm4ge30gcmVnaW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBfZ2V0UmVnaW9uID0gZnVuY3Rpb24oZ3JpZCwgYm9keSkge1xyXG4gICAgICAgIHZhciBib3VuZHMgPSBib2R5LmJvdW5kcyxcclxuICAgICAgICAgICAgc3RhcnRDb2wgPSBNYXRoLmZsb29yKGJvdW5kcy5taW4ueCAvIGdyaWQuYnVja2V0V2lkdGgpLFxyXG4gICAgICAgICAgICBlbmRDb2wgPSBNYXRoLmZsb29yKGJvdW5kcy5tYXgueCAvIGdyaWQuYnVja2V0V2lkdGgpLFxyXG4gICAgICAgICAgICBzdGFydFJvdyA9IE1hdGguZmxvb3IoYm91bmRzLm1pbi55IC8gZ3JpZC5idWNrZXRIZWlnaHQpLFxyXG4gICAgICAgICAgICBlbmRSb3cgPSBNYXRoLmZsb29yKGJvdW5kcy5tYXgueSAvIGdyaWQuYnVja2V0SGVpZ2h0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSZWdpb24oc3RhcnRDb2wsIGVuZENvbCwgc3RhcnRSb3csIGVuZFJvdyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJlZ2lvbi5cclxuICAgICAqIEBtZXRob2QgX2NyZWF0ZVJlZ2lvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7fSBzdGFydENvbFxyXG4gICAgICogQHBhcmFtIHt9IGVuZENvbFxyXG4gICAgICogQHBhcmFtIHt9IHN0YXJ0Um93XHJcbiAgICAgKiBAcGFyYW0ge30gZW5kUm93XHJcbiAgICAgKiBAcmV0dXJuIHt9IHJlZ2lvblxyXG4gICAgICovXHJcbiAgICB2YXIgX2NyZWF0ZVJlZ2lvbiA9IGZ1bmN0aW9uKHN0YXJ0Q29sLCBlbmRDb2wsIHN0YXJ0Um93LCBlbmRSb3cpIHtcclxuICAgICAgICByZXR1cm4geyBcclxuICAgICAgICAgICAgaWQ6IHN0YXJ0Q29sICsgJywnICsgZW5kQ29sICsgJywnICsgc3RhcnRSb3cgKyAnLCcgKyBlbmRSb3csXHJcbiAgICAgICAgICAgIHN0YXJ0Q29sOiBzdGFydENvbCwgXHJcbiAgICAgICAgICAgIGVuZENvbDogZW5kQ29sLCBcclxuICAgICAgICAgICAgc3RhcnRSb3c6IHN0YXJ0Um93LCBcclxuICAgICAgICAgICAgZW5kUm93OiBlbmRSb3cgXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBidWNrZXQgaWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxyXG4gICAgICogQG1ldGhvZCBfZ2V0QnVja2V0SWRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge30gY29sdW1uXHJcbiAgICAgKiBAcGFyYW0ge30gcm93XHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGJ1Y2tldCBpZFxyXG4gICAgICovXHJcbiAgICB2YXIgX2dldEJ1Y2tldElkID0gZnVuY3Rpb24oY29sdW1uLCByb3cpIHtcclxuICAgICAgICByZXR1cm4gJ0MnICsgY29sdW1uICsgJ1InICsgcm93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBidWNrZXQuXHJcbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVCdWNrZXRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge30gYnVja2V0c1xyXG4gICAgICogQHBhcmFtIHt9IGJ1Y2tldElkXHJcbiAgICAgKiBAcmV0dXJuIHt9IGJ1Y2tldFxyXG4gICAgICovXHJcbiAgICB2YXIgX2NyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uKGJ1Y2tldHMsIGJ1Y2tldElkKSB7XHJcbiAgICAgICAgdmFyIGJ1Y2tldCA9IGJ1Y2tldHNbYnVja2V0SWRdID0gW107XHJcbiAgICAgICAgcmV0dXJuIGJ1Y2tldDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgYm9keSB0byBhIGJ1Y2tldC5cclxuICAgICAqIEBtZXRob2QgX2J1Y2tldEFkZEJvZHlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxyXG4gICAgICogQHBhcmFtIHt9IGJ1Y2tldFxyXG4gICAgICogQHBhcmFtIHt9IGJvZHlcclxuICAgICAqL1xyXG4gICAgdmFyIF9idWNrZXRBZGRCb2R5ID0gZnVuY3Rpb24oZ3JpZCwgYnVja2V0LCBib2R5KSB7XHJcbiAgICAgICAgLy8gYWRkIG5ldyBwYWlyc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGJ1Y2tldFtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChib2R5LmlkID09PSBib2R5Qi5pZCB8fCAoYm9keS5pc1N0YXRpYyAmJiBib2R5Qi5pc1N0YXRpYykpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiBidWNrZXRzIHRoZSBwYWlyIGV4aXN0cyBpblxyXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIEdyaWQudXBkYXRlIHRvIHdvcmtcclxuICAgICAgICAgICAgdmFyIHBhaXJJZCA9IFBhaXIuaWQoYm9keSwgYm9keUIpLFxyXG4gICAgICAgICAgICAgICAgcGFpciA9IGdyaWQucGFpcnNbcGFpcklkXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYWlyKSB7XHJcbiAgICAgICAgICAgICAgICBwYWlyWzJdICs9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBncmlkLnBhaXJzW3BhaXJJZF0gPSBbYm9keSwgYm9keUIsIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhZGQgdG8gYm9kaWVzIChhZnRlciBwYWlycywgb3RoZXJ3aXNlIHBhaXJzIHdpdGggc2VsZilcclxuICAgICAgICBidWNrZXQucHVzaChib2R5KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgYm9keSBmcm9tIGEgYnVja2V0LlxyXG4gICAgICogQG1ldGhvZCBfYnVja2V0UmVtb3ZlQm9keVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7fSBncmlkXHJcbiAgICAgKiBAcGFyYW0ge30gYnVja2V0XHJcbiAgICAgKiBAcGFyYW0ge30gYm9keVxyXG4gICAgICovXHJcbiAgICB2YXIgX2J1Y2tldFJlbW92ZUJvZHkgPSBmdW5jdGlvbihncmlkLCBidWNrZXQsIGJvZHkpIHtcclxuICAgICAgICAvLyByZW1vdmUgZnJvbSBidWNrZXRcclxuICAgICAgICBidWNrZXQuc3BsaWNlKENvbW1vbi5pbmRleE9mKGJ1Y2tldCwgYm9keSksIDEpO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgcGFpciBjb3VudHNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgYnVja2V0cyB0aGUgcGFpciBleGlzdHMgaW5cclxuICAgICAgICAgICAgLy8gaW1wb3J0YW50IGZvciBfY3JlYXRlQWN0aXZlUGFpcnNMaXN0IHRvIHdvcmtcclxuICAgICAgICAgICAgdmFyIGJvZHlCID0gYnVja2V0W2ldLFxyXG4gICAgICAgICAgICAgICAgcGFpcklkID0gUGFpci5pZChib2R5LCBib2R5QiksXHJcbiAgICAgICAgICAgICAgICBwYWlyID0gZ3JpZC5wYWlyc1twYWlySWRdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBhaXIpXHJcbiAgICAgICAgICAgICAgICBwYWlyWzJdIC09IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIGxpc3Qgb2YgdGhlIGFjdGl2ZSBwYWlycyBpbiB0aGUgZ3JpZC5cclxuICAgICAqIEBtZXRob2QgX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7fSBncmlkXHJcbiAgICAgKiBAcmV0dXJuIFtdIHBhaXJzXHJcbiAgICAgKi9cclxuICAgIHZhciBfY3JlYXRlQWN0aXZlUGFpcnNMaXN0ID0gZnVuY3Rpb24oZ3JpZCkge1xyXG4gICAgICAgIHZhciBwYWlyS2V5cyxcclxuICAgICAgICAgICAgcGFpcixcclxuICAgICAgICAgICAgcGFpcnMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gZ3JpZC5wYWlycyBpcyB1c2VkIGFzIGEgaGFzaG1hcFxyXG4gICAgICAgIHBhaXJLZXlzID0gQ29tbW9uLmtleXMoZ3JpZC5wYWlycyk7XHJcblxyXG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBncmlkLnBhaXJzXHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwYWlyS2V5cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBwYWlyID0gZ3JpZC5wYWlyc1twYWlyS2V5c1trXV07XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBwYWlyIGV4aXN0cyBpbiBhdCBsZWFzdCBvbmUgYnVja2V0XHJcbiAgICAgICAgICAgIC8vIGl0IGlzIGEgcGFpciB0aGF0IG5lZWRzIGZ1cnRoZXIgY29sbGlzaW9uIHRlc3Rpbmcgc28gcHVzaCBpdFxyXG4gICAgICAgICAgICBpZiAocGFpclsyXSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2gocGFpcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZ3JpZC5wYWlyc1twYWlyS2V5c1trXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYWlycztcclxuICAgIH07XHJcbiAgICBcclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL0dyaWQuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9HcmlkLmpzIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuU0FUYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgZGV0ZWN0aW5nIGNvbGxpc2lvbnMgdXNpbmcgdGhlIFNlcGFyYXRpbmcgQXhpcyBUaGVvcmVtLlxyXG4qXHJcbiogQGNsYXNzIFNBVFxyXG4qL1xyXG5cclxuLy8gVE9ETzogdHJ1ZSBjaXJjbGVzIGFuZCBjdXJ2ZXNcclxuXHJcbnZhciBTQVQgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU0FUO1xyXG5cclxudmFyIFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVydGljZXMnKTtcclxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZWN0IGNvbGxpc2lvbiBiZXR3ZWVuIHR3byBib2RpZXMgdXNpbmcgdGhlIFNlcGFyYXRpbmcgQXhpcyBUaGVvcmVtLlxyXG4gICAgICogQG1ldGhvZCBjb2xsaWRlc1xyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtjb2xsaXNpb259IHByZXZpb3VzQ29sbGlzaW9uXHJcbiAgICAgKiBAcmV0dXJuIHtjb2xsaXNpb259IGNvbGxpc2lvblxyXG4gICAgICovXHJcbiAgICBTQVQuY29sbGlkZXMgPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHByZXZpb3VzQ29sbGlzaW9uKSB7XHJcbiAgICAgICAgdmFyIG92ZXJsYXBBQixcclxuICAgICAgICAgICAgb3ZlcmxhcEJBLCBcclxuICAgICAgICAgICAgbWluT3ZlcmxhcCxcclxuICAgICAgICAgICAgY29sbGlzaW9uLFxyXG4gICAgICAgICAgICBjYW5SZXVzZVByZXZDb2wgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHByZXZpb3VzQ29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgIC8vIGVzdGltYXRlIHRvdGFsIG1vdGlvblxyXG4gICAgICAgICAgICB2YXIgcGFyZW50QSA9IGJvZHlBLnBhcmVudCxcclxuICAgICAgICAgICAgICAgIHBhcmVudEIgPSBib2R5Qi5wYXJlbnQsXHJcbiAgICAgICAgICAgICAgICBtb3Rpb24gPSBwYXJlbnRBLnNwZWVkICogcGFyZW50QS5zcGVlZCArIHBhcmVudEEuYW5ndWxhclNwZWVkICogcGFyZW50QS5hbmd1bGFyU3BlZWRcclxuICAgICAgICAgICAgICAgICAgICAgICArIHBhcmVudEIuc3BlZWQgKiBwYXJlbnRCLnNwZWVkICsgcGFyZW50Qi5hbmd1bGFyU3BlZWQgKiBwYXJlbnRCLmFuZ3VsYXJTcGVlZDtcclxuXHJcbiAgICAgICAgICAgIC8vIHdlIG1heSBiZSBhYmxlIHRvIChwYXJ0aWFsbHkpIHJldXNlIGNvbGxpc2lvbiByZXN1bHQgXHJcbiAgICAgICAgICAgIC8vIGJ1dCBvbmx5IHNhZmUgaWYgY29sbGlzaW9uIHdhcyByZXN0aW5nXHJcbiAgICAgICAgICAgIGNhblJldXNlUHJldkNvbCA9IHByZXZpb3VzQ29sbGlzaW9uICYmIHByZXZpb3VzQ29sbGlzaW9uLmNvbGxpZGVkICYmIG1vdGlvbiA8IDAuMjtcclxuXHJcbiAgICAgICAgICAgIC8vIHJldXNlIGNvbGxpc2lvbiBvYmplY3RcclxuICAgICAgICAgICAgY29sbGlzaW9uID0gcHJldmlvdXNDb2xsaXNpb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29sbGlzaW9uID0geyBjb2xsaWRlZDogZmFsc2UsIGJvZHlBOiBib2R5QSwgYm9keUI6IGJvZHlCIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJldmlvdXNDb2xsaXNpb24gJiYgY2FuUmV1c2VQcmV2Q29sKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhbiByZXVzZSB0aGUgY29sbGlzaW9uIHJlc3VsdFxyXG4gICAgICAgICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gdGVzdCB0aGUgcHJldmlvdXNseSBmb3VuZCBheGlzXHJcbiAgICAgICAgICAgIHZhciBheGlzQm9keUEgPSBjb2xsaXNpb24uYXhpc0JvZHksXHJcbiAgICAgICAgICAgICAgICBheGlzQm9keUIgPSBheGlzQm9keUEgPT09IGJvZHlBID8gYm9keUIgOiBib2R5QSxcclxuICAgICAgICAgICAgICAgIGF4ZXMgPSBbYXhpc0JvZHlBLmF4ZXNbcHJldmlvdXNDb2xsaXNpb24uYXhpc051bWJlcl1dO1xyXG5cclxuICAgICAgICAgICAgbWluT3ZlcmxhcCA9IF9vdmVybGFwQXhlcyhheGlzQm9keUEudmVydGljZXMsIGF4aXNCb2R5Qi52ZXJ0aWNlcywgYXhlcyk7XHJcbiAgICAgICAgICAgIGNvbGxpc2lvbi5yZXVzZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1pbk92ZXJsYXAub3ZlcmxhcCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uY29sbGlkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsaXNpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCByZXVzZSBhIHJlc3VsdCwgcGVyZm9ybSBhIGZ1bGwgU0FUIHRlc3RcclxuXHJcbiAgICAgICAgICAgIG92ZXJsYXBBQiA9IF9vdmVybGFwQXhlcyhib2R5QS52ZXJ0aWNlcywgYm9keUIudmVydGljZXMsIGJvZHlBLmF4ZXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG92ZXJsYXBBQi5vdmVybGFwIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbi5jb2xsaWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxpc2lvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3ZlcmxhcEJBID0gX292ZXJsYXBBeGVzKGJvZHlCLnZlcnRpY2VzLCBib2R5QS52ZXJ0aWNlcywgYm9keUIuYXhlcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcEJBLm92ZXJsYXAgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uLmNvbGxpZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcEFCLm92ZXJsYXAgPCBvdmVybGFwQkEub3ZlcmxhcCkge1xyXG4gICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXBBQjtcclxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbi5heGlzQm9keSA9IGJvZHlBO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXBCQTtcclxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbi5heGlzQm9keSA9IGJvZHlCO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIHJldXNlIGxhdGVyXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbi5heGlzTnVtYmVyID0gbWluT3ZlcmxhcC5heGlzTnVtYmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29sbGlzaW9uLmJvZHlBID0gYm9keUEuaWQgPCBib2R5Qi5pZCA/IGJvZHlBIDogYm9keUI7XHJcbiAgICAgICAgY29sbGlzaW9uLmJvZHlCID0gYm9keUEuaWQgPCBib2R5Qi5pZCA/IGJvZHlCIDogYm9keUE7XHJcbiAgICAgICAgY29sbGlzaW9uLmNvbGxpZGVkID0gdHJ1ZTtcclxuICAgICAgICBjb2xsaXNpb24uZGVwdGggPSBtaW5PdmVybGFwLm92ZXJsYXA7XHJcbiAgICAgICAgY29sbGlzaW9uLnBhcmVudEEgPSBjb2xsaXNpb24uYm9keUEucGFyZW50O1xyXG4gICAgICAgIGNvbGxpc2lvbi5wYXJlbnRCID0gY29sbGlzaW9uLmJvZHlCLnBhcmVudDtcclxuICAgICAgICBcclxuICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5ib2R5QTtcclxuICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5ib2R5QjtcclxuXHJcbiAgICAgICAgLy8gZW5zdXJlIG5vcm1hbCBpcyBmYWNpbmcgYXdheSBmcm9tIGJvZHlBXHJcbiAgICAgICAgaWYgKFZlY3Rvci5kb3QobWluT3ZlcmxhcC5heGlzLCBWZWN0b3Iuc3ViKGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbikpIDwgMCkge1xyXG4gICAgICAgICAgICBjb2xsaXNpb24ubm9ybWFsID0ge1xyXG4gICAgICAgICAgICAgICAgeDogbWluT3ZlcmxhcC5heGlzLngsXHJcbiAgICAgICAgICAgICAgICB5OiBtaW5PdmVybGFwLmF4aXMueVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbGxpc2lvbi5ub3JtYWwgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiAtbWluT3ZlcmxhcC5heGlzLngsXHJcbiAgICAgICAgICAgICAgICB5OiAtbWluT3ZlcmxhcC5heGlzLnlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbGxpc2lvbi50YW5nZW50ID0gVmVjdG9yLnBlcnAoY29sbGlzaW9uLm5vcm1hbCk7XHJcblxyXG4gICAgICAgIGNvbGxpc2lvbi5wZW5ldHJhdGlvbiA9IGNvbGxpc2lvbi5wZW5ldHJhdGlvbiB8fCB7fTtcclxuICAgICAgICBjb2xsaXNpb24ucGVuZXRyYXRpb24ueCA9IGNvbGxpc2lvbi5ub3JtYWwueCAqIGNvbGxpc2lvbi5kZXB0aDtcclxuICAgICAgICBjb2xsaXNpb24ucGVuZXRyYXRpb24ueSA9IGNvbGxpc2lvbi5ub3JtYWwueSAqIGNvbGxpc2lvbi5kZXB0aDsgXHJcblxyXG4gICAgICAgIC8vIGZpbmQgc3VwcG9ydCBwb2ludHMsIHRoZXJlIGlzIGFsd2F5cyBlaXRoZXIgZXhhY3RseSBvbmUgb3IgdHdvXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzQiA9IF9maW5kU3VwcG9ydHMoYm9keUEsIGJvZHlCLCBjb2xsaXNpb24ubm9ybWFsKSxcclxuICAgICAgICAgICAgc3VwcG9ydHMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gZmluZCB0aGUgc3VwcG9ydHMgZnJvbSBib2R5QiB0aGF0IGFyZSBpbnNpZGUgYm9keUFcclxuICAgICAgICBpZiAoVmVydGljZXMuY29udGFpbnMoYm9keUEudmVydGljZXMsIHZlcnRpY2VzQlswXSkpXHJcbiAgICAgICAgICAgIHN1cHBvcnRzLnB1c2godmVydGljZXNCWzBdKTtcclxuXHJcbiAgICAgICAgaWYgKFZlcnRpY2VzLmNvbnRhaW5zKGJvZHlBLnZlcnRpY2VzLCB2ZXJ0aWNlc0JbMV0pKVxyXG4gICAgICAgICAgICBzdXBwb3J0cy5wdXNoKHZlcnRpY2VzQlsxXSk7XHJcblxyXG4gICAgICAgIC8vIGZpbmQgdGhlIHN1cHBvcnRzIGZyb20gYm9keUEgdGhhdCBhcmUgaW5zaWRlIGJvZHlCXHJcbiAgICAgICAgaWYgKHN1cHBvcnRzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzQSA9IF9maW5kU3VwcG9ydHMoYm9keUIsIGJvZHlBLCBWZWN0b3IubmVnKGNvbGxpc2lvbi5ub3JtYWwpKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoVmVydGljZXMuY29udGFpbnMoYm9keUIudmVydGljZXMsIHZlcnRpY2VzQVswXSkpXHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0cy5wdXNoKHZlcnRpY2VzQVswXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3VwcG9ydHMubGVuZ3RoIDwgMiAmJiBWZXJ0aWNlcy5jb250YWlucyhib2R5Qi52ZXJ0aWNlcywgdmVydGljZXNBWzFdKSlcclxuICAgICAgICAgICAgICAgIHN1cHBvcnRzLnB1c2godmVydGljZXNBWzFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFjY291bnQgZm9yIHRoZSBlZGdlIGNhc2Ugb2Ygb3ZlcmxhcHBpbmcgYnV0IG5vIHZlcnRleCBjb250YWlubWVudFxyXG4gICAgICAgIGlmIChzdXBwb3J0cy5sZW5ndGggPCAxKVxyXG4gICAgICAgICAgICBzdXBwb3J0cyA9IFt2ZXJ0aWNlc0JbMF1dO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbGxpc2lvbi5zdXBwb3J0cyA9IHN1cHBvcnRzO1xyXG5cclxuICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIG92ZXJsYXAgYmV0d2VlbiB0d28gc2V0cyBvZiB2ZXJ0aWNlcy5cclxuICAgICAqIEBtZXRob2QgX292ZXJsYXBBeGVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHt9IHZlcnRpY2VzQVxyXG4gICAgICogQHBhcmFtIHt9IHZlcnRpY2VzQlxyXG4gICAgICogQHBhcmFtIHt9IGF4ZXNcclxuICAgICAqIEByZXR1cm4gcmVzdWx0XHJcbiAgICAgKi9cclxuICAgIHZhciBfb3ZlcmxhcEF4ZXMgPSBmdW5jdGlvbih2ZXJ0aWNlc0EsIHZlcnRpY2VzQiwgYXhlcykge1xyXG4gICAgICAgIHZhciBwcm9qZWN0aW9uQSA9IFZlY3Rvci5fdGVtcFswXSwgXHJcbiAgICAgICAgICAgIHByb2plY3Rpb25CID0gVmVjdG9yLl90ZW1wWzFdLFxyXG4gICAgICAgICAgICByZXN1bHQgPSB7IG92ZXJsYXA6IE51bWJlci5NQVhfVkFMVUUgfSxcclxuICAgICAgICAgICAgb3ZlcmxhcCxcclxuICAgICAgICAgICAgYXhpcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGF4aXMgPSBheGVzW2ldO1xyXG5cclxuICAgICAgICAgICAgX3Byb2plY3RUb0F4aXMocHJvamVjdGlvbkEsIHZlcnRpY2VzQSwgYXhpcyk7XHJcbiAgICAgICAgICAgIF9wcm9qZWN0VG9BeGlzKHByb2plY3Rpb25CLCB2ZXJ0aWNlc0IsIGF4aXMpO1xyXG5cclxuICAgICAgICAgICAgb3ZlcmxhcCA9IE1hdGgubWluKHByb2plY3Rpb25BLm1heCAtIHByb2plY3Rpb25CLm1pbiwgcHJvamVjdGlvbkIubWF4IC0gcHJvamVjdGlvbkEubWluKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5vdmVybGFwID0gb3ZlcmxhcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgcmVzdWx0Lm92ZXJsYXApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5vdmVybGFwID0gb3ZlcmxhcDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5heGlzID0gYXhpcztcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5heGlzTnVtYmVyID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9qZWN0cyB2ZXJ0aWNlcyBvbiBhbiBheGlzIGFuZCByZXR1cm5zIGFuIGludGVydmFsLlxyXG4gICAgICogQG1ldGhvZCBfcHJvamVjdFRvQXhpc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7fSBwcm9qZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge30gdmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7fSBheGlzXHJcbiAgICAgKi9cclxuICAgIHZhciBfcHJvamVjdFRvQXhpcyA9IGZ1bmN0aW9uKHByb2plY3Rpb24sIHZlcnRpY2VzLCBheGlzKSB7XHJcbiAgICAgICAgdmFyIG1pbiA9IFZlY3Rvci5kb3QodmVydGljZXNbMF0sIGF4aXMpLFxyXG4gICAgICAgICAgICBtYXggPSBtaW47XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdmFyIGRvdCA9IFZlY3Rvci5kb3QodmVydGljZXNbaV0sIGF4aXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRvdCA+IG1heCkgeyBcclxuICAgICAgICAgICAgICAgIG1heCA9IGRvdDsgXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG90IDwgbWluKSB7IFxyXG4gICAgICAgICAgICAgICAgbWluID0gZG90OyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvamVjdGlvbi5taW4gPSBtaW47XHJcbiAgICAgICAgcHJvamVjdGlvbi5tYXggPSBtYXg7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHN1cHBvcnRpbmcgdmVydGljZXMgZ2l2ZW4gdHdvIGJvZGllcyBhbG9uZyBhIGdpdmVuIGRpcmVjdGlvbiB1c2luZyBoaWxsLWNsaW1iaW5nLlxyXG4gICAgICogQG1ldGhvZCBfZmluZFN1cHBvcnRzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHt9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge30gYm9keUJcclxuICAgICAqIEBwYXJhbSB7fSBub3JtYWxcclxuICAgICAqIEByZXR1cm4gW3ZlY3Rvcl1cclxuICAgICAqL1xyXG4gICAgdmFyIF9maW5kU3VwcG9ydHMgPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIG5vcm1hbCkge1xyXG4gICAgICAgIHZhciBuZWFyZXN0RGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhUb0JvZHkgPSBWZWN0b3IuX3RlbXBbMF0sXHJcbiAgICAgICAgICAgIHZlcnRpY2VzID0gYm9keUIudmVydGljZXMsXHJcbiAgICAgICAgICAgIGJvZHlBUG9zaXRpb24gPSBib2R5QS5wb3NpdGlvbixcclxuICAgICAgICAgICAgZGlzdGFuY2UsXHJcbiAgICAgICAgICAgIHZlcnRleCxcclxuICAgICAgICAgICAgdmVydGV4QSxcclxuICAgICAgICAgICAgdmVydGV4QjtcclxuXHJcbiAgICAgICAgLy8gZmluZCBjbG9zZXN0IHZlcnRleCBvbiBib2R5QlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIHZlcnRleFRvQm9keS54ID0gdmVydGV4LnggLSBib2R5QVBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIHZlcnRleFRvQm9keS55ID0gdmVydGV4LnkgLSBib2R5QVBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlID0gLVZlY3Rvci5kb3Qobm9ybWFsLCB2ZXJ0ZXhUb0JvZHkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbmVhcmVzdERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZWFyZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIHZlcnRleEEgPSB2ZXJ0ZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmQgbmV4dCBjbG9zZXN0IHZlcnRleCB1c2luZyB0aGUgdHdvIGNvbm5lY3RlZCB0byBpdFxyXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSB2ZXJ0ZXhBLmluZGV4IC0gMSA+PSAwID8gdmVydGV4QS5pbmRleCAtIDEgOiB2ZXJ0aWNlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW3ByZXZJbmRleF07XHJcbiAgICAgICAgdmVydGV4VG9Cb2R5LnggPSB2ZXJ0ZXgueCAtIGJvZHlBUG9zaXRpb24ueDtcclxuICAgICAgICB2ZXJ0ZXhUb0JvZHkueSA9IHZlcnRleC55IC0gYm9keUFQb3NpdGlvbi55O1xyXG4gICAgICAgIG5lYXJlc3REaXN0YW5jZSA9IC1WZWN0b3IuZG90KG5vcm1hbCwgdmVydGV4VG9Cb2R5KTtcclxuICAgICAgICB2ZXJ0ZXhCID0gdmVydGV4O1xyXG5cclxuICAgICAgICB2YXIgbmV4dEluZGV4ID0gKHZlcnRleEEuaW5kZXggKyAxKSAlIHZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tuZXh0SW5kZXhdO1xyXG4gICAgICAgIHZlcnRleFRvQm9keS54ID0gdmVydGV4LnggLSBib2R5QVBvc2l0aW9uLng7XHJcbiAgICAgICAgdmVydGV4VG9Cb2R5LnkgPSB2ZXJ0ZXgueSAtIGJvZHlBUG9zaXRpb24ueTtcclxuICAgICAgICBkaXN0YW5jZSA9IC1WZWN0b3IuZG90KG5vcm1hbCwgdmVydGV4VG9Cb2R5KTtcclxuICAgICAgICBpZiAoZGlzdGFuY2UgPCBuZWFyZXN0RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgdmVydGV4QiA9IHZlcnRleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBbdmVydGV4QSwgdmVydGV4Ql07XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1NBVC5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1NBVC5qcyIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLk1vdXNlYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBtb3VzZSBpbnB1dHMuXHJcbipcclxuKiBAY2xhc3MgTW91c2VcclxuKi9cclxuXHJcbnZhciBNb3VzZSA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZTtcclxuXHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG1vdXNlIGlucHV0LlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4ge21vdXNlfSBBIG5ldyBtb3VzZVxyXG4gICAgICovXHJcbiAgICBNb3VzZS5jcmVhdGUgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIG1vdXNlID0ge307XHJcblxyXG4gICAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgICAgICBDb21tb24ubG9nKCdNb3VzZS5jcmVhdGU6IGVsZW1lbnQgd2FzIHVuZGVmaW5lZCwgZGVmYXVsdGluZyB0byBkb2N1bWVudC5ib2R5JywgJ3dhcm4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgbW91c2UuZWxlbWVudCA9IGVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcclxuICAgICAgICBtb3VzZS5hYnNvbHV0ZSA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIG1vdXNlLnBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgbW91c2UubW91c2Vkb3duUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICBtb3VzZS5tb3VzZXVwUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICBtb3VzZS5vZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICBtb3VzZS5zY2FsZSA9IHsgeDogMSwgeTogMSB9O1xyXG4gICAgICAgIG1vdXNlLndoZWVsRGVsdGEgPSAwO1xyXG4gICAgICAgIG1vdXNlLmJ1dHRvbiA9IC0xO1xyXG4gICAgICAgIG1vdXNlLnBpeGVsUmF0aW8gPSBtb3VzZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1waXhlbC1yYXRpbycpIHx8IDE7XHJcblxyXG4gICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cyA9IHtcclxuICAgICAgICAgICAgbW91c2Vtb3ZlOiBudWxsLFxyXG4gICAgICAgICAgICBtb3VzZWRvd246IG51bGwsXHJcbiAgICAgICAgICAgIG1vdXNldXA6IG51bGwsXHJcbiAgICAgICAgICAgIG1vdXNld2hlZWw6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIG1vdXNlLm1vdXNlbW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7IFxyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBfZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCBtb3VzZS5lbGVtZW50LCBtb3VzZS5waXhlbFJhdGlvKSxcclxuICAgICAgICAgICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcclxuXHJcbiAgICAgICAgICAgIGlmICh0b3VjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VzZS5idXR0b24gPSAwO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueCA9IHBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnkgPSBwb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi54ID0gbW91c2UuYWJzb2x1dGUueCAqIG1vdXNlLnNjYWxlLnggKyBtb3VzZS5vZmZzZXQueDtcclxuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueSA9IG1vdXNlLmFic29sdXRlLnkgKiBtb3VzZS5zY2FsZS55ICsgbW91c2Uub2Zmc2V0Lnk7XHJcbiAgICAgICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZW1vdmUgPSBldmVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIG1vdXNlLm1vdXNlZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF9nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb24oZXZlbnQsIG1vdXNlLmVsZW1lbnQsIG1vdXNlLnBpeGVsUmF0aW8pLFxyXG4gICAgICAgICAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRvdWNoZXMpIHtcclxuICAgICAgICAgICAgICAgIG1vdXNlLmJ1dHRvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW91c2UuYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS54ID0gcG9zaXRpb24ueDtcclxuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xyXG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcclxuICAgICAgICAgICAgbW91c2UubW91c2Vkb3duUG9zaXRpb24ueCA9IG1vdXNlLnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIG1vdXNlLm1vdXNlZG93blBvc2l0aW9uLnkgPSBtb3VzZS5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2Vkb3duID0gZXZlbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBtb3VzZS5tb3VzZXVwID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvbihldmVudCwgbW91c2UuZWxlbWVudCwgbW91c2UucGl4ZWxSYXRpbyksXHJcbiAgICAgICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XHJcblxyXG4gICAgICAgICAgICBpZiAodG91Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbW91c2UuYnV0dG9uID0gLTE7XHJcbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnggPSBwb3NpdGlvbi54O1xyXG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS55ID0gcG9zaXRpb24ueTtcclxuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueCA9IG1vdXNlLmFic29sdXRlLnggKiBtb3VzZS5zY2FsZS54ICsgbW91c2Uub2Zmc2V0Lng7XHJcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xyXG4gICAgICAgICAgICBtb3VzZS5tb3VzZXVwUG9zaXRpb24ueCA9IG1vdXNlLnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIG1vdXNlLm1vdXNldXBQb3NpdGlvbi55ID0gbW91c2UucG9zaXRpb24ueTtcclxuICAgICAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNldXAgPSBldmVudDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBtb3VzZS5tb3VzZXdoZWVsID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgbW91c2Uud2hlZWxEZWx0YSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBldmVudC53aGVlbERlbHRhIHx8IC1ldmVudC5kZXRhaWwpKTtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBNb3VzZS5zZXRFbGVtZW50KG1vdXNlLCBtb3VzZS5lbGVtZW50KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG1vdXNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVsZW1lbnQgdGhlIG1vdXNlIGlzIGJvdW5kIHRvIChhbmQgcmVsYXRpdmUgdG8pLlxyXG4gICAgICogQG1ldGhvZCBzZXRFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAgICovXHJcbiAgICBNb3VzZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24obW91c2UsIGVsZW1lbnQpIHtcclxuICAgICAgICBtb3VzZS5lbGVtZW50ID0gZWxlbWVudDtcclxuXHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZS5tb3VzZW1vdmUpO1xyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2UubW91c2Vkb3duKTtcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZS5tb3VzZXVwKTtcclxuICAgICAgICBcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBtb3VzZS5tb3VzZXdoZWVsKTtcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgbW91c2UubW91c2V3aGVlbCk7XHJcblxyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgbW91c2UubW91c2Vtb3ZlKTtcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBtb3VzZS5tb3VzZWRvd24pO1xyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBtb3VzZS5tb3VzZXVwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYWxsIGNhcHR1cmVkIHNvdXJjZSBldmVudHMuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyU291cmNlRXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxyXG4gICAgICovXHJcbiAgICBNb3VzZS5jbGVhclNvdXJjZUV2ZW50cyA9IGZ1bmN0aW9uKG1vdXNlKSB7XHJcbiAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNlbW92ZSA9IG51bGw7XHJcbiAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNlZG93biA9IG51bGw7XHJcbiAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNldXAgPSBudWxsO1xyXG4gICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZXdoZWVsID0gbnVsbDtcclxuICAgICAgICBtb3VzZS53aGVlbERlbHRhID0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiBvZmZzZXQuXHJcbiAgICAgKiBAbWV0aG9kIHNldE9mZnNldFxyXG4gICAgICogQHBhcmFtIHttb3VzZX0gbW91c2VcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBvZmZzZXRcclxuICAgICAqL1xyXG4gICAgTW91c2Uuc2V0T2Zmc2V0ID0gZnVuY3Rpb24obW91c2UsIG9mZnNldCkge1xyXG4gICAgICAgIG1vdXNlLm9mZnNldC54ID0gb2Zmc2V0Lng7XHJcbiAgICAgICAgbW91c2Uub2Zmc2V0LnkgPSBvZmZzZXQueTtcclxuICAgICAgICBtb3VzZS5wb3NpdGlvbi54ID0gbW91c2UuYWJzb2x1dGUueCAqIG1vdXNlLnNjYWxlLnggKyBtb3VzZS5vZmZzZXQueDtcclxuICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiBzY2FsZS5cclxuICAgICAqIEBtZXRob2Qgc2V0U2NhbGVcclxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gc2NhbGVcclxuICAgICAqL1xyXG4gICAgTW91c2Uuc2V0U2NhbGUgPSBmdW5jdGlvbihtb3VzZSwgc2NhbGUpIHtcclxuICAgICAgICBtb3VzZS5zY2FsZS54ID0gc2NhbGUueDtcclxuICAgICAgICBtb3VzZS5zY2FsZS55ID0gc2NhbGUueTtcclxuICAgICAgICBtb3VzZS5wb3NpdGlvbi54ID0gbW91c2UuYWJzb2x1dGUueCAqIG1vdXNlLnNjYWxlLnggKyBtb3VzZS5vZmZzZXQueDtcclxuICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gYW4gZWxlbWVudCBnaXZlbiBhIHNjcmVlbiBwaXhlbCByYXRpby5cclxuICAgICAqIEBtZXRob2QgX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7fSBldmVudFxyXG4gICAgICogQHBhcmFtIHt9IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvXHJcbiAgICAgKiBAcmV0dXJuIHt9XHJcbiAgICAgKi9cclxuICAgIHZhciBfZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oZXZlbnQsIGVsZW1lbnQsIHBpeGVsUmF0aW8pIHtcclxuICAgICAgICB2YXIgZWxlbWVudEJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgICAgIHJvb3ROb2RlID0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keSksXHJcbiAgICAgICAgICAgIHNjcm9sbFggPSAod2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogcm9vdE5vZGUuc2Nyb2xsTGVmdCxcclxuICAgICAgICAgICAgc2Nyb2xsWSA9ICh3aW5kb3cucGFnZVlPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiByb290Tm9kZS5zY3JvbGxUb3AsXHJcbiAgICAgICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcclxuICAgICAgICAgICAgeCwgeTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodG91Y2hlcykge1xyXG4gICAgICAgICAgICB4ID0gdG91Y2hlc1swXS5wYWdlWCAtIGVsZW1lbnRCb3VuZHMubGVmdCAtIHNjcm9sbFg7XHJcbiAgICAgICAgICAgIHkgPSB0b3VjaGVzWzBdLnBhZ2VZIC0gZWxlbWVudEJvdW5kcy50b3AgLSBzY3JvbGxZO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHggPSBldmVudC5wYWdlWCAtIGVsZW1lbnRCb3VuZHMubGVmdCAtIHNjcm9sbFg7XHJcbiAgICAgICAgICAgIHkgPSBldmVudC5wYWdlWSAtIGVsZW1lbnRCb3VuZHMudG9wIC0gc2Nyb2xsWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IFxyXG4gICAgICAgICAgICB4OiB4IC8gKGVsZW1lbnQuY2xpZW50V2lkdGggLyAoZWxlbWVudC53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoKSAqIHBpeGVsUmF0aW8pLFxyXG4gICAgICAgICAgICB5OiB5IC8gKGVsZW1lbnQuY2xpZW50SGVpZ2h0IC8gKGVsZW1lbnQuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0KSAqIHBpeGVsUmF0aW8pXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL01vdXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL01vdXNlLmpzIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuQm9kaWVzYCBtb2R1bGUgY29udGFpbnMgZmFjdG9yeSBtZXRob2RzIGZvciBjcmVhdGluZyByaWdpZCBib2R5IG1vZGVscyBcclxuKiB3aXRoIGNvbW1vbmx5IHVzZWQgYm9keSBjb25maWd1cmF0aW9ucyAoc3VjaCBhcyByZWN0YW5nbGVzLCBjaXJjbGVzIGFuZCBvdGhlciBwb2x5Z29ucykuXHJcbipcclxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxyXG4qXHJcbiogQGNsYXNzIEJvZGllc1xyXG4qL1xyXG5cclxuLy8gVE9ETzogdHJ1ZSBjaXJjbGUgYm9kaWVzXHJcblxyXG52YXIgQm9kaWVzID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJvZGllcztcclxuXHJcbnZhciBWZXJ0aWNlcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlcnRpY2VzJyk7XHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG52YXIgQm9keSA9IHJlcXVpcmUoJy4uL2JvZHkvQm9keScpO1xyXG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcclxudmFyIGRlY29tcCA9IHJlcXVpcmUoJy4uLy4uL3BvbHktZGVjb21wLycpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSByZWN0YW5nbGUgaHVsbC4gXHJcbiAgICAgKiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cclxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIG9mIHRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcmV0dXJuIHtib2R5fSBBIG5ldyByZWN0YW5nbGUgYm9keVxyXG4gICAgICovXHJcbiAgICBCb2RpZXMucmVjdGFuZ2xlID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICB2YXIgcmVjdGFuZ2xlID0geyBcclxuICAgICAgICAgICAgbGFiZWw6ICdSZWN0YW5nbGUgQm9keScsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcclxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKCdMIDAgMCBMICcgKyB3aWR0aCArICcgMCBMICcgKyB3aWR0aCArICcgJyArIGhlaWdodCArICcgTCAwICcgKyBoZWlnaHQpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbWZlcikge1xyXG4gICAgICAgICAgICB2YXIgY2hhbWZlciA9IG9wdGlvbnMuY2hhbWZlcjtcclxuICAgICAgICAgICAgcmVjdGFuZ2xlLnZlcnRpY2VzID0gVmVydGljZXMuY2hhbWZlcihyZWN0YW5nbGUudmVydGljZXMsIGNoYW1mZXIucmFkaXVzLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbWZlci5xdWFsaXR5LCBjaGFtZmVyLnF1YWxpdHlNaW4sIGNoYW1mZXIucXVhbGl0eU1heCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNoYW1mZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gQm9keS5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7fSwgcmVjdGFuZ2xlLCBvcHRpb25zKSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmlnaWQgYm9keSBtb2RlbCB3aXRoIGEgdHJhcGV6b2lkIGh1bGwuIFxyXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBvZiB0aGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgdHJhcGV6b2lkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3BlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcmV0dXJuIHtib2R5fSBBIG5ldyB0cmFwZXpvaWQgYm9keVxyXG4gICAgICovXHJcbiAgICBCb2RpZXMudHJhcGV6b2lkID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgc2xvcGUsIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgc2xvcGUgKj0gMC41O1xyXG4gICAgICAgIHZhciByb29mID0gKDEgLSAoc2xvcGUgKiAyKSkgKiB3aWR0aDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgeDEgPSB3aWR0aCAqIHNsb3BlLFxyXG4gICAgICAgICAgICB4MiA9IHgxICsgcm9vZixcclxuICAgICAgICAgICAgeDMgPSB4MiArIHgxLFxyXG4gICAgICAgICAgICB2ZXJ0aWNlc1BhdGg7XHJcblxyXG4gICAgICAgIGlmIChzbG9wZSA8IDAuNSkge1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1BhdGggPSAnTCAwIDAgTCAnICsgeDEgKyAnICcgKyAoLWhlaWdodCkgKyAnIEwgJyArIHgyICsgJyAnICsgKC1oZWlnaHQpICsgJyBMICcgKyB4MyArICcgMCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmVydGljZXNQYXRoID0gJ0wgMCAwIEwgJyArIHgyICsgJyAnICsgKC1oZWlnaHQpICsgJyBMICcgKyB4MyArICcgMCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdHJhcGV6b2lkID0geyBcclxuICAgICAgICAgICAgbGFiZWw6ICdUcmFwZXpvaWQgQm9keScsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcclxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKHZlcnRpY2VzUGF0aClcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5jaGFtZmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFtZmVyID0gb3B0aW9ucy5jaGFtZmVyO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWQudmVydGljZXMgPSBWZXJ0aWNlcy5jaGFtZmVyKHRyYXBlem9pZC52ZXJ0aWNlcywgY2hhbWZlci5yYWRpdXMsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFtZmVyLnF1YWxpdHksIGNoYW1mZXIucXVhbGl0eU1pbiwgY2hhbWZlci5xdWFsaXR5TWF4KTtcclxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbWZlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHt9LCB0cmFwZXpvaWQsIG9wdGlvbnMpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJpZ2lkIGJvZHkgbW9kZWwgd2l0aCBhIGNpcmNsZSBodWxsLiBcclxuICAgICAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxyXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGNpcmNsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heFNpZGVzXVxyXG4gICAgICogQHJldHVybiB7Ym9keX0gQSBuZXcgY2lyY2xlIGJvZHlcclxuICAgICAqL1xyXG4gICAgQm9kaWVzLmNpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgb3B0aW9ucywgbWF4U2lkZXMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IHtcclxuICAgICAgICAgICAgbGFiZWw6ICdDaXJjbGUgQm9keScsXHJcbiAgICAgICAgICAgIGNpcmNsZVJhZGl1czogcmFkaXVzXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBhcHByb3hpbWF0ZSBjaXJjbGVzIHdpdGggcG9seWdvbnMgdW50aWwgdHJ1ZSBjaXJjbGVzIGltcGxlbWVudGVkIGluIFNBVFxyXG4gICAgICAgIG1heFNpZGVzID0gbWF4U2lkZXMgfHwgMjU7XHJcbiAgICAgICAgdmFyIHNpZGVzID0gTWF0aC5jZWlsKE1hdGgubWF4KDEwLCBNYXRoLm1pbihtYXhTaWRlcywgcmFkaXVzKSkpO1xyXG5cclxuICAgICAgICAvLyBvcHRpbWlzYXRpb246IGFsd2F5cyB1c2UgZXZlbiBudW1iZXIgb2Ygc2lkZXMgKGhhbGYgdGhlIG51bWJlciBvZiB1bmlxdWUgYXhlcylcclxuICAgICAgICBpZiAoc2lkZXMgJSAyID09PSAxKVxyXG4gICAgICAgICAgICBzaWRlcyArPSAxO1xyXG5cclxuICAgICAgICByZXR1cm4gQm9kaWVzLnBvbHlnb24oeCwgeSwgc2lkZXMsIHJhZGl1cywgQ29tbW9uLmV4dGVuZCh7fSwgY2lyY2xlLCBvcHRpb25zKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSByZWd1bGFyIHBvbHlnb24gaHVsbCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygc2lkZXMuIFxyXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBvZiB0aGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgcG9seWdvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lkZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEByZXR1cm4ge2JvZHl9IEEgbmV3IHJlZ3VsYXIgcG9seWdvbiBib2R5XHJcbiAgICAgKi9cclxuICAgIEJvZGllcy5wb2x5Z29uID0gZnVuY3Rpb24oeCwgeSwgc2lkZXMsIHJhZGl1cywgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICBpZiAoc2lkZXMgPCAzKVxyXG4gICAgICAgICAgICByZXR1cm4gQm9kaWVzLmNpcmNsZSh4LCB5LCByYWRpdXMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIHNpZGVzLFxyXG4gICAgICAgICAgICBwYXRoID0gJycsXHJcbiAgICAgICAgICAgIG9mZnNldCA9IHRoZXRhICogMC41O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gb2Zmc2V0ICsgKGkgKiB0aGV0YSksXHJcbiAgICAgICAgICAgICAgICB4eCA9IE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcclxuICAgICAgICAgICAgICAgIHl5ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgcGF0aCArPSAnTCAnICsgeHgudG9GaXhlZCgzKSArICcgJyArIHl5LnRvRml4ZWQoMykgKyAnICc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcG9seWdvbiA9IHsgXHJcbiAgICAgICAgICAgIGxhYmVsOiAnUG9seWdvbiBCb2R5JyxcclxuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogeCwgeTogeSB9LFxyXG4gICAgICAgICAgICB2ZXJ0aWNlczogVmVydGljZXMuZnJvbVBhdGgocGF0aClcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5jaGFtZmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFtZmVyID0gb3B0aW9ucy5jaGFtZmVyO1xyXG4gICAgICAgICAgICBwb2x5Z29uLnZlcnRpY2VzID0gVmVydGljZXMuY2hhbWZlcihwb2x5Z29uLnZlcnRpY2VzLCBjaGFtZmVyLnJhZGl1cywgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW1mZXIucXVhbGl0eSwgY2hhbWZlci5xdWFsaXR5TWluLCBjaGFtZmVyLnF1YWxpdHlNYXgpO1xyXG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGFtZmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIEJvZHkuY3JlYXRlKENvbW1vbi5leHRlbmQoe30sIHBvbHlnb24sIG9wdGlvbnMpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYm9keSB1c2luZyB0aGUgc3VwcGxpZWQgdmVydGljZXMgKG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbXVsdGlwbGUgc2V0cyBvZiB2ZXJ0aWNlcykuXHJcbiAgICAgKiBJZiB0aGUgdmVydGljZXMgYXJlIGNvbnZleCwgdGhleSB3aWxsIHBhc3MgdGhyb3VnaCBhcyBzdXBwbGllZC5cclxuICAgICAqIE90aGVyd2lzZSBpZiB0aGUgdmVydGljZXMgYXJlIGNvbmNhdmUsIHRoZXkgd2lsbCBiZSBkZWNvbXBvc2VkIGlmIFtwb2x5LWRlY29tcC5qc10oaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3BvbHktZGVjb21wLmpzKSBpcyBhdmFpbGFibGUuXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9jZXNzIGlzIG5vdCBndWFyYW50ZWVkIHRvIHN1cHBvcnQgY29tcGxleCBzZXRzIG9mIHZlcnRpY2VzIChlLmcuIHRob3NlIHdpdGggaG9sZXMgbWF5IGZhaWwpLlxyXG4gICAgICogQnkgZGVmYXVsdCB0aGUgZGVjb21wb3NpdGlvbiB3aWxsIGRpc2NhcmQgY29sbGluZWFyIGVkZ2VzICh0byBpbXByb3ZlIHBlcmZvcm1hbmNlKS5cclxuICAgICAqIEl0IGNhbiBhbHNvIG9wdGlvbmFsbHkgZGlzY2FyZCBhbnkgcGFydHMgdGhhdCBoYXZlIGFuIGFyZWEgbGVzcyB0aGFuIGBtaW5pbXVtQXJlYWAuXHJcbiAgICAgKiBJZiB0aGUgdmVydGljZXMgY2FuIG5vdCBiZSBkZWNvbXBvc2VkLCB0aGUgcmVzdWx0IHdpbGwgZmFsbCBiYWNrIHRvIHVzaW5nIHRoZSBjb252ZXggaHVsbC5cclxuICAgICAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IGBNYXR0ZXIuQm9keWAgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBvZiB0aGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgZnJvbVZlcnRpY2VzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSBbW3ZlY3Rvcl1dIHZlcnRleFNldHNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2ZsYWdJbnRlcm5hbD1mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVtb3ZlQ29sbGluZWFyPTAuMDFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbmltdW1BcmVhPTEwXVxyXG4gICAgICogQHJldHVybiB7Ym9keX1cclxuICAgICAqL1xyXG4gICAgQm9kaWVzLmZyb21WZXJ0aWNlcyA9IGZ1bmN0aW9uKHgsIHksIHZlcnRleFNldHMsIG9wdGlvbnMsIGZsYWdJbnRlcm5hbCwgcmVtb3ZlQ29sbGluZWFyLCBtaW5pbXVtQXJlYSkge1xyXG4gICAgICAgIHZhciBib2R5LFxyXG4gICAgICAgICAgICBwYXJ0cyxcclxuICAgICAgICAgICAgaXNDb252ZXgsXHJcbiAgICAgICAgICAgIHZlcnRpY2VzLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBrLFxyXG4gICAgICAgICAgICB2LFxyXG4gICAgICAgICAgICB6O1xyXG5cclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBwYXJ0cyA9IFtdO1xyXG5cclxuICAgICAgICBmbGFnSW50ZXJuYWwgPSB0eXBlb2YgZmxhZ0ludGVybmFsICE9PSAndW5kZWZpbmVkJyA/IGZsYWdJbnRlcm5hbCA6IGZhbHNlO1xyXG4gICAgICAgIHJlbW92ZUNvbGxpbmVhciA9IHR5cGVvZiByZW1vdmVDb2xsaW5lYXIgIT09ICd1bmRlZmluZWQnID8gcmVtb3ZlQ29sbGluZWFyIDogMC4wMTtcclxuICAgICAgICBtaW5pbXVtQXJlYSA9IHR5cGVvZiBtaW5pbXVtQXJlYSAhPT0gJ3VuZGVmaW5lZCcgPyBtaW5pbXVtQXJlYSA6IDEwO1xyXG5cclxuICAgICAgICBpZiAoIWRlY29tcCkge1xyXG4gICAgICAgICAgICBDb21tb24ud2FybignQm9kaWVzLmZyb21WZXJ0aWNlczogcG9seS1kZWNvbXAuanMgcmVxdWlyZWQuIENvdWxkIG5vdCBkZWNvbXBvc2UgdmVydGljZXMuIEZhbGxiYWNrIHRvIGNvbnZleCBodWxsLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZW5zdXJlIHZlcnRleFNldHMgaXMgYW4gYXJyYXkgb2YgYXJyYXlzXHJcbiAgICAgICAgaWYgKCFDb21tb24uaXNBcnJheSh2ZXJ0ZXhTZXRzWzBdKSkge1xyXG4gICAgICAgICAgICB2ZXJ0ZXhTZXRzID0gW3ZlcnRleFNldHNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IHZlcnRleFNldHMubGVuZ3RoOyB2ICs9IDEpIHtcclxuICAgICAgICAgICAgdmVydGljZXMgPSB2ZXJ0ZXhTZXRzW3ZdO1xyXG4gICAgICAgICAgICBpc0NvbnZleCA9IFZlcnRpY2VzLmlzQ29udmV4KHZlcnRpY2VzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc0NvbnZleCB8fCAhZGVjb21wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDb252ZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IFZlcnRpY2VzLmNsb2Nrd2lzZVNvcnQodmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayB0byBjb252ZXggaHVsbCB3aGVuIGRlY29tcG9zaXRpb24gaXMgbm90IHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMgPSBWZXJ0aWNlcy5odWxsKHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyB4OiB4LCB5OiB5IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgYSBkZWNvbXBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgY29uY2F2ZSA9IHZlcnRpY2VzLm1hcChmdW5jdGlvbih2ZXJ0ZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3ZlcnRleC54LCB2ZXJ0ZXgueV07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB2ZXJ0aWNlcyBhcmUgY29uY2F2ZSBhbmQgc2ltcGxlLCB3ZSBjYW4gZGVjb21wb3NlIGludG8gcGFydHNcclxuICAgICAgICAgICAgICAgIGRlY29tcC5tYWtlQ0NXKGNvbmNhdmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZUNvbGxpbmVhciAhPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgZGVjb21wLnJlbW92ZUNvbGxpbmVhclBvaW50cyhjb25jYXZlLCByZW1vdmVDb2xsaW5lYXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgcXVpY2sgZGVjb21wb3NpdGlvbiBhbGdvcml0aG0gKEJheWF6aXQpXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjb21wb3NlZCA9IGRlY29tcC5xdWlja0RlY29tcChjb25jYXZlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBkZWNvbXBvc2VkIGNodW5rXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVjb21wb3NlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHVuayA9IGRlY29tcG9zZWRbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdmVydGljZXMgaW50byB0aGUgY29ycmVjdCBzdHJ1Y3R1cmVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtWZXJ0aWNlcyA9IGNodW5rLm1hcChmdW5jdGlvbih2ZXJ0aWNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogdmVydGljZXNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB2ZXJ0aWNlc1sxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHNtYWxsIGNodW5rc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5pbXVtQXJlYSA+IDAgJiYgVmVydGljZXMuYXJlYShjaHVua1ZlcnRpY2VzKSA8IG1pbmltdW1BcmVhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY29tcG91bmQgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogVmVydGljZXMuY2VudHJlKGNodW5rVmVydGljZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlczogY2h1bmtWZXJ0aWNlc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgYm9keSBwYXJ0c1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYXJ0c1tpXSA9IEJvZHkuY3JlYXRlKENvbW1vbi5leHRlbmQocGFydHNbaV0sIG9wdGlvbnMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZsYWcgaW50ZXJuYWwgZWRnZXMgKGNvaW5jaWRlbnQgcGFydCBlZGdlcylcclxuICAgICAgICBpZiAoZmxhZ0ludGVybmFsKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2luY2lkZW50X21heF9kaXN0ID0gNTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRBID0gcGFydHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0QiA9IHBhcnRzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQm91bmRzLm92ZXJsYXBzKHBhcnRBLmJvdW5kcywgcGFydEIuYm91bmRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF2ID0gcGFydEEudmVydGljZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYnYgPSBwYXJ0Qi52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgdmVydGljZXMgb2YgYm90aCBwYXJ0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcGFydEEudmVydGljZXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeiA9IDA7IHogPCBwYXJ0Qi52ZXJ0aWNlcy5sZW5ndGg7IHorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgZGlzdGFuY2VzIGJldHdlZW4gdGhlIHZlcnRpY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhID0gVmVjdG9yLm1hZ25pdHVkZVNxdWFyZWQoVmVjdG9yLnN1YihwYXZbKGsgKyAxKSAlIHBhdi5sZW5ndGhdLCBwYnZbel0pKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIgPSBWZWN0b3IubWFnbml0dWRlU3F1YXJlZChWZWN0b3Iuc3ViKHBhdltrXSwgcGJ2Wyh6ICsgMSkgJSBwYnYubGVuZ3RoXSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBib3RoIHZlcnRpY2VzIGFyZSB2ZXJ5IGNsb3NlLCBjb25zaWRlciB0aGUgZWRnZSBjb25jaWRlbnQgKGludGVybmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYSA8IGNvaW5jaWRlbnRfbWF4X2Rpc3QgJiYgZGIgPCBjb2luY2lkZW50X21heF9kaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdltrXS5pc0ludGVybmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGJ2W3pdLmlzSW50ZXJuYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcGFyZW50IGJvZHkgdG8gYmUgcmV0dXJuZWQsIHRoYXQgY29udGFpbnMgZ2VuZXJhdGVkIGNvbXBvdW5kIHBhcnRzXHJcbiAgICAgICAgICAgIGJvZHkgPSBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgcGFydHM6IHBhcnRzLnNsaWNlKDApIH0sIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB7IHg6IHgsIHk6IHkgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2ZhY3RvcnkvQm9kaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9mYWN0b3J5L0JvZGllcy5qcyIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLkF4ZXNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHNldHMgb2YgYXhlcy5cclxuKlxyXG4qIEBjbGFzcyBBeGVzXHJcbiovXHJcblxyXG52YXIgQXhlcyA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBeGVzO1xyXG5cclxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgc2V0IG9mIGF4ZXMgZnJvbSB0aGUgZ2l2ZW4gdmVydGljZXMuXHJcbiAgICAgKiBAbWV0aG9kIGZyb21WZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEByZXR1cm4ge2F4ZXN9IEEgbmV3IGF4ZXMgZnJvbSB0aGUgZ2l2ZW4gdmVydGljZXNcclxuICAgICAqL1xyXG4gICAgQXhlcy5mcm9tVmVydGljZXMgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xyXG4gICAgICAgIHZhciBheGVzID0ge307XHJcblxyXG4gICAgICAgIC8vIGZpbmQgdGhlIHVuaXF1ZSBheGVzLCB1c2luZyBlZGdlIG5vcm1hbCBncmFkaWVudHNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBqID0gKGkgKyAxKSAlIHZlcnRpY2VzLmxlbmd0aCwgXHJcbiAgICAgICAgICAgICAgICBub3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKHsgXHJcbiAgICAgICAgICAgICAgICAgICAgeDogdmVydGljZXNbal0ueSAtIHZlcnRpY2VzW2ldLnksIFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHZlcnRpY2VzW2ldLnggLSB2ZXJ0aWNlc1tqXS54XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIGdyYWRpZW50ID0gKG5vcm1hbC55ID09PSAwKSA/IEluZmluaXR5IDogKG5vcm1hbC54IC8gbm9ybWFsLnkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gbGltaXQgcHJlY2lzaW9uXHJcbiAgICAgICAgICAgIGdyYWRpZW50ID0gZ3JhZGllbnQudG9GaXhlZCgzKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBheGVzW2dyYWRpZW50XSA9IG5vcm1hbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBDb21tb24udmFsdWVzKGF4ZXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZXMgYSBzZXQgb2YgYXhlcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXHJcbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxyXG4gICAgICogQHBhcmFtIHtheGVzfSBheGVzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQXhlcy5yb3RhdGUgPSBmdW5jdGlvbihheGVzLCBhbmdsZSkge1xyXG4gICAgICAgIGlmIChhbmdsZSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXHJcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhlc1tpXSxcclxuICAgICAgICAgICAgICAgIHh4O1xyXG4gICAgICAgICAgICB4eCA9IGF4aXMueCAqIGNvcyAtIGF4aXMueSAqIHNpbjtcclxuICAgICAgICAgICAgYXhpcy55ID0gYXhpcy54ICogc2luICsgYXhpcy55ICogY29zO1xyXG4gICAgICAgICAgICBheGlzLnggPSB4eDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvQXhlcy5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvQXhlcy5qcyIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlJlbmRlcmAgbW9kdWxlIGlzIGEgc2ltcGxlIEhUTUw1IGNhbnZhcyBiYXNlZCByZW5kZXJlciBmb3IgdmlzdWFsaXNpbmcgaW5zdGFuY2VzIG9mIGBNYXR0ZXIuRW5naW5lYC5cclxuKiBJdCBpcyBpbnRlbmRlZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIGRlYnVnZ2luZyBwdXJwb3NlcywgYnV0IG1heSBhbHNvIGJlIHN1aXRhYmxlIGZvciBzaW1wbGUgZ2FtZXMuXHJcbiogSXQgaW5jbHVkZXMgYSBudW1iZXIgb2YgZHJhd2luZyBvcHRpb25zIGluY2x1ZGluZyB3aXJlZnJhbWUsIHZlY3RvciB3aXRoIHN1cHBvcnQgZm9yIHNwcml0ZXMgYW5kIHZpZXdwb3J0cy5cclxuKlxyXG4qIEBjbGFzcyBSZW5kZXJcclxuKi9cclxuXHJcbnZhciBSZW5kZXIgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyO1xyXG5cclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcbnZhciBDb21wb3NpdGUgPSByZXF1aXJlKCcuLi9ib2R5L0NvbXBvc2l0ZScpO1xyXG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcbnZhciBFdmVudHMgPSByZXF1aXJlKCcuLi9jb3JlL0V2ZW50cycpO1xyXG52YXIgR3JpZCA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9HcmlkJyk7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcclxudmFyIE1vdXNlID0gcmVxdWlyZSgnLi4vY29yZS9Nb3VzZScpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG4gICAgXHJcbiAgICB2YXIgX3JlcXVlc3RBbmltYXRpb25GcmFtZSxcclxuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKXsgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKENvbW1vbi5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcbiAgIFxyXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyByZW5kZXJlci4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxyXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcmV0dXJuIHtyZW5kZXJ9IEEgbmV3IHJlbmRlcmVyXHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyOiBSZW5kZXIsXHJcbiAgICAgICAgICAgIGVuZ2luZTogbnVsbCxcclxuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcclxuICAgICAgICAgICAgY2FudmFzOiBudWxsLFxyXG4gICAgICAgICAgICBtb3VzZTogbnVsbCxcclxuICAgICAgICAgICAgZnJhbWVSZXF1ZXN0SWQ6IG51bGwsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYwMCxcclxuICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IDEsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnIzE4MTgxZCcsXHJcbiAgICAgICAgICAgICAgICB3aXJlZnJhbWVCYWNrZ3JvdW5kOiAnIzBmMGYxMycsXHJcbiAgICAgICAgICAgICAgICBoYXNCb3VuZHM6ICEhb3B0aW9ucy5ib3VuZHMsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgd2lyZWZyYW1lczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNob3dTbGVlcGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNob3dEZWJ1ZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93QnJvYWRwaGFzZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93Qm91bmRzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dWZWxvY2l0eTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93Q29sbGlzaW9uczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93U2VwYXJhdGlvbnM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0F4ZXM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd1Bvc2l0aW9uczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93QW5nbGVJbmRpY2F0b3I6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0lkczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93U2hhZG93czogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93VmVydGV4TnVtYmVyczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93Q29udmV4SHVsbHM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0ludGVybmFsRWRnZXM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd01vdXNlUG9zaXRpb246IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgcmVuZGVyID0gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGlmIChyZW5kZXIuY2FudmFzKSB7XHJcbiAgICAgICAgICAgIHJlbmRlci5jYW52YXMud2lkdGggPSByZW5kZXIub3B0aW9ucy53aWR0aCB8fCByZW5kZXIuY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICByZW5kZXIuY2FudmFzLmhlaWdodCA9IHJlbmRlci5vcHRpb25zLmhlaWdodCB8fCByZW5kZXIuY2FudmFzLmhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlci5tb3VzZSA9IG9wdGlvbnMubW91c2U7XHJcbiAgICAgICAgcmVuZGVyLmVuZ2luZSA9IG9wdGlvbnMuZW5naW5lO1xyXG4gICAgICAgIHJlbmRlci5jYW52YXMgPSByZW5kZXIuY2FudmFzIHx8IF9jcmVhdGVDYW52YXMocmVuZGVyLm9wdGlvbnMud2lkdGgsIHJlbmRlci5vcHRpb25zLmhlaWdodCk7XHJcbiAgICAgICAgcmVuZGVyLmNvbnRleHQgPSByZW5kZXIuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgcmVuZGVyLnRleHR1cmVzID0ge307XHJcblxyXG4gICAgICAgIHJlbmRlci5ib3VuZHMgPSByZW5kZXIuYm91bmRzIHx8IHsgXHJcbiAgICAgICAgICAgIG1pbjogeyBcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwXHJcbiAgICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgICBtYXg6IHsgXHJcbiAgICAgICAgICAgICAgICB4OiByZW5kZXIuY2FudmFzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgeTogcmVuZGVyLmNhbnZhcy5oZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChyZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvICE9PSAxKSB7XHJcbiAgICAgICAgICAgIFJlbmRlci5zZXRQaXhlbFJhdGlvKHJlbmRlciwgcmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoQ29tbW9uLmlzRWxlbWVudChyZW5kZXIuZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmVuZGVyLmVsZW1lbnQuYXBwZW5kQ2hpbGQocmVuZGVyLmNhbnZhcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ29tbW9uLmxvZygnUmVuZGVyLmNyZWF0ZTogb3B0aW9ucy5lbGVtZW50IHdhcyB1bmRlZmluZWQsIHJlbmRlci5jYW52YXMgd2FzIGNyZWF0ZWQgYnV0IG5vdCBhcHBlbmRlZCcsICd3YXJuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVuZGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRpbnVvdXNseSB1cGRhdGVzIHRoZSByZW5kZXIgY2FudmFzIG9uIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBldmVudC5cclxuICAgICAqIEBtZXRob2QgcnVuXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5ydW4gPSBmdW5jdGlvbihyZW5kZXIpIHtcclxuICAgICAgICAoZnVuY3Rpb24gbG9vcCh0aW1lKXtcclxuICAgICAgICAgICAgcmVuZGVyLmZyYW1lUmVxdWVzdElkID0gX3JlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcclxuICAgICAgICAgICAgUmVuZGVyLndvcmxkKHJlbmRlcik7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmRzIGV4ZWN1dGlvbiBvZiBgUmVuZGVyLnJ1bmAgb24gdGhlIGdpdmVuIGByZW5kZXJgLCBieSBjYW5jZWxpbmcgdGhlIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0IGV2ZW50IGxvb3AuXHJcbiAgICAgKiBAbWV0aG9kIHN0b3BcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLnN0b3AgPSBmdW5jdGlvbihyZW5kZXIpIHtcclxuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVuZGVyLmZyYW1lUmVxdWVzdElkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIgYW5kIHVwZGF0ZXMgdGhlIGNhbnZhcy5cclxuICAgICAqIFRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBjb3JyZWN0IHJhdGlvLCBwYXNzIHRoZSBzdHJpbmcgYCdhdXRvJ2AgZm9yIGBwaXhlbFJhdGlvYC5cclxuICAgICAqIEBtZXRob2Qgc2V0UGl4ZWxSYXRpb1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW9cclxuICAgICAqL1xyXG4gICAgUmVuZGVyLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbihyZW5kZXIsIHBpeGVsUmF0aW8pIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxyXG4gICAgICAgICAgICBjYW52YXMgPSByZW5kZXIuY2FudmFzO1xyXG5cclxuICAgICAgICBpZiAocGl4ZWxSYXRpbyA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBfZ2V0UGl4ZWxSYXRpbyhjYW52YXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0aW9ucy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcclxuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLXBpeGVsLXJhdGlvJywgcGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gb3B0aW9ucy53aWR0aCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICogcGl4ZWxSYXRpbztcclxuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcHRpb25zLndpZHRoICsgJ3B4JztcclxuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKyAncHgnO1xyXG4gICAgICAgIHJlbmRlci5jb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9ucyBhbmQgc2l6ZXMgdGhlIHZpZXdwb3J0IGFyb3VuZCB0aGUgZ2l2ZW4gb2JqZWN0IGJvdW5kcy5cclxuICAgICAqIE9iamVjdHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAtIGBvYmplY3QuYm91bmRzYFxyXG4gICAgICogLSBgb2JqZWN0LnBvc2l0aW9uYFxyXG4gICAgICogLSBgb2JqZWN0Lm1pbmAgYW5kIGBvYmplY3QubWF4YFxyXG4gICAgICogLSBgb2JqZWN0LnhgIGFuZCBgb2JqZWN0LnlgXHJcbiAgICAgKiBAbWV0aG9kIGxvb2tBdFxyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gb2JqZWN0c1xyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtwYWRkaW5nXVxyXG4gICAgICogQHBhcmFtIHtib29sfSBbY2VudGVyPXRydWVdXHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5sb29rQXQgPSBmdW5jdGlvbihyZW5kZXIsIG9iamVjdHMsIHBhZGRpbmcsIGNlbnRlcikge1xyXG4gICAgICAgIGNlbnRlciA9IHR5cGVvZiBjZW50ZXIgIT09ICd1bmRlZmluZWQnID8gY2VudGVyIDogdHJ1ZTtcclxuICAgICAgICBvYmplY3RzID0gQ29tbW9uLmlzQXJyYXkob2JqZWN0cykgPyBvYmplY3RzIDogW29iamVjdHNdO1xyXG4gICAgICAgIHBhZGRpbmcgPSBwYWRkaW5nIHx8IHtcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGZpbmQgYm91bmRzIG9mIGFsbCBvYmplY3RzXHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IHtcclxuICAgICAgICAgICAgbWluOiB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSB9LFxyXG4gICAgICAgICAgICBtYXg6IHsgeDogLUluZmluaXR5LCB5OiAtSW5maW5pdHkgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c1tpXSxcclxuICAgICAgICAgICAgICAgIG1pbiA9IG9iamVjdC5ib3VuZHMgPyBvYmplY3QuYm91bmRzLm1pbiA6IChvYmplY3QubWluIHx8IG9iamVjdC5wb3NpdGlvbiB8fCBvYmplY3QpLFxyXG4gICAgICAgICAgICAgICAgbWF4ID0gb2JqZWN0LmJvdW5kcyA/IG9iamVjdC5ib3VuZHMubWF4IDogKG9iamVjdC5tYXggfHwgb2JqZWN0LnBvc2l0aW9uIHx8IG9iamVjdCk7IFxyXG5cclxuICAgICAgICAgICAgaWYgKG1pbiAmJiBtYXgpIHsgXHJcbiAgICAgICAgICAgICAgICBpZiAobWluLnggPCBib3VuZHMubWluLngpIFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueCA9IG1pbi54O1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKG1heC54ID4gYm91bmRzLm1heC54KSBcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHMubWF4LnggPSBtYXgueDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWluLnkgPCBib3VuZHMubWluLnkpIFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueSA9IG1pbi55O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXgueSA+IGJvdW5kcy5tYXgueSkgXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLm1heC55ID0gbWF4Lnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmQgcmF0aW9zXHJcbiAgICAgICAgdmFyIHdpZHRoID0gKGJvdW5kcy5tYXgueCAtIGJvdW5kcy5taW4ueCkgKyAyICogcGFkZGluZy54LFxyXG4gICAgICAgICAgICBoZWlnaHQgPSAoYm91bmRzLm1heC55IC0gYm91bmRzLm1pbi55KSArIDIgKiBwYWRkaW5nLnksXHJcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSByZW5kZXIuY2FudmFzLmhlaWdodCxcclxuICAgICAgICAgICAgdmlld1dpZHRoID0gcmVuZGVyLmNhbnZhcy53aWR0aCxcclxuICAgICAgICAgICAgb3V0ZXJSYXRpbyA9IHZpZXdXaWR0aCAvIHZpZXdIZWlnaHQsXHJcbiAgICAgICAgICAgIGlubmVyUmF0aW8gPSB3aWR0aCAvIGhlaWdodCxcclxuICAgICAgICAgICAgc2NhbGVYID0gMSxcclxuICAgICAgICAgICAgc2NhbGVZID0gMTtcclxuXHJcbiAgICAgICAgLy8gZmluZCBzY2FsZSBmYWN0b3JcclxuICAgICAgICBpZiAoaW5uZXJSYXRpbyA+IG91dGVyUmF0aW8pIHtcclxuICAgICAgICAgICAgc2NhbGVZID0gaW5uZXJSYXRpbyAvIG91dGVyUmF0aW87XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2NhbGVYID0gb3V0ZXJSYXRpbyAvIGlubmVyUmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBlbmFibGUgYm91bmRzXHJcbiAgICAgICAgcmVuZGVyLm9wdGlvbnMuaGFzQm91bmRzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gcG9zaXRpb24gYW5kIHNpemVcclxuICAgICAgICByZW5kZXIuYm91bmRzLm1pbi54ID0gYm91bmRzLm1pbi54O1xyXG4gICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnggPSBib3VuZHMubWluLnggKyB3aWR0aCAqIHNjYWxlWDtcclxuICAgICAgICByZW5kZXIuYm91bmRzLm1pbi55ID0gYm91bmRzLm1pbi55O1xyXG4gICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnkgPSBib3VuZHMubWluLnkgKyBoZWlnaHQgKiBzY2FsZVk7XHJcblxyXG4gICAgICAgIC8vIGNlbnRlclxyXG4gICAgICAgIGlmIChjZW50ZXIpIHtcclxuICAgICAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueCArPSB3aWR0aCAqIDAuNSAtICh3aWR0aCAqIHNjYWxlWCkgKiAwLjU7XHJcbiAgICAgICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnggKz0gd2lkdGggKiAwLjUgLSAod2lkdGggKiBzY2FsZVgpICogMC41O1xyXG4gICAgICAgICAgICByZW5kZXIuYm91bmRzLm1pbi55ICs9IGhlaWdodCAqIDAuNSAtIChoZWlnaHQgKiBzY2FsZVkpICogMC41O1xyXG4gICAgICAgICAgICByZW5kZXIuYm91bmRzLm1heC55ICs9IGhlaWdodCAqIDAuNSAtIChoZWlnaHQgKiBzY2FsZVkpICogMC41O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcGFkZGluZ1xyXG4gICAgICAgIHJlbmRlci5ib3VuZHMubWluLnggLT0gcGFkZGluZy54O1xyXG4gICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnggLT0gcGFkZGluZy54O1xyXG4gICAgICAgIHJlbmRlci5ib3VuZHMubWluLnkgLT0gcGFkZGluZy55O1xyXG4gICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnkgLT0gcGFkZGluZy55O1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgbW91c2VcclxuICAgICAgICBpZiAocmVuZGVyLm1vdXNlKSB7XHJcbiAgICAgICAgICAgIE1vdXNlLnNldFNjYWxlKHJlbmRlci5tb3VzZSwge1xyXG4gICAgICAgICAgICAgICAgeDogKHJlbmRlci5ib3VuZHMubWF4LnggLSByZW5kZXIuYm91bmRzLm1pbi54KSAvIHJlbmRlci5jYW52YXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICB5OiAocmVuZGVyLmJvdW5kcy5tYXgueSAtIHJlbmRlci5ib3VuZHMubWluLnkpIC8gcmVuZGVyLmNhbnZhcy5oZWlnaHRcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBNb3VzZS5zZXRPZmZzZXQocmVuZGVyLm1vdXNlLCByZW5kZXIuYm91bmRzLm1pbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdmlld3BvcnQgdHJhbnNmb3JtcyBiYXNlZCBvbiBgcmVuZGVyLmJvdW5kc2AgdG8gYSByZW5kZXIgY29udGV4dC5cclxuICAgICAqIEBtZXRob2Qgc3RhcnRWaWV3VHJhbnNmb3JtXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5zdGFydFZpZXdUcmFuc2Zvcm0gPSBmdW5jdGlvbihyZW5kZXIpIHtcclxuICAgICAgICB2YXIgYm91bmRzV2lkdGggPSByZW5kZXIuYm91bmRzLm1heC54IC0gcmVuZGVyLmJvdW5kcy5taW4ueCxcclxuICAgICAgICAgICAgYm91bmRzSGVpZ2h0ID0gcmVuZGVyLmJvdW5kcy5tYXgueSAtIHJlbmRlci5ib3VuZHMubWluLnksXHJcbiAgICAgICAgICAgIGJvdW5kc1NjYWxlWCA9IGJvdW5kc1dpZHRoIC8gcmVuZGVyLm9wdGlvbnMud2lkdGgsXHJcbiAgICAgICAgICAgIGJvdW5kc1NjYWxlWSA9IGJvdW5kc0hlaWdodCAvIHJlbmRlci5vcHRpb25zLmhlaWdodDtcclxuXHJcbiAgICAgICAgcmVuZGVyLmNvbnRleHQuc2NhbGUoMSAvIGJvdW5kc1NjYWxlWCwgMSAvIGJvdW5kc1NjYWxlWSk7XHJcbiAgICAgICAgcmVuZGVyLmNvbnRleHQudHJhbnNsYXRlKC1yZW5kZXIuYm91bmRzLm1pbi54LCAtcmVuZGVyLmJvdW5kcy5taW4ueSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIGFsbCB0cmFuc2Zvcm1zIG9uIHRoZSByZW5kZXIgY29udGV4dC5cclxuICAgICAqIEBtZXRob2QgZW5kVmlld1RyYW5zZm9ybVxyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICovXHJcbiAgICBSZW5kZXIuZW5kVmlld1RyYW5zZm9ybSA9IGZ1bmN0aW9uKHJlbmRlcikge1xyXG4gICAgICAgIHJlbmRlci5jb250ZXh0LnNldFRyYW5zZm9ybShyZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvLCAwLCAwLCByZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvLCAwLCAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBgZW5naW5lYCdzIGBNYXR0ZXIuV29ybGRgIG9iamVjdC5cclxuICAgICAqIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBhbGwgcmVuZGVyaW5nIGFuZCBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHNjZW5lIGNoYW5nZXMuXHJcbiAgICAgKiBAbWV0aG9kIHdvcmxkXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIFJlbmRlci53b3JsZCA9IGZ1bmN0aW9uKHJlbmRlcikge1xyXG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxyXG4gICAgICAgICAgICB3b3JsZCA9IGVuZ2luZS53b3JsZCxcclxuICAgICAgICAgICAgY2FudmFzID0gcmVuZGVyLmNhbnZhcyxcclxuICAgICAgICAgICAgY29udGV4dCA9IHJlbmRlci5jb250ZXh0LFxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIGFsbEJvZGllcyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMod29ybGQpLFxyXG4gICAgICAgICAgICBhbGxDb25zdHJhaW50cyA9IENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyh3b3JsZCksXHJcbiAgICAgICAgICAgIGJhY2tncm91bmQgPSBvcHRpb25zLndpcmVmcmFtZXMgPyBvcHRpb25zLndpcmVmcmFtZUJhY2tncm91bmQgOiBvcHRpb25zLmJhY2tncm91bmQsXHJcbiAgICAgICAgICAgIGJvZGllcyA9IFtdLFxyXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IFtdLFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICB2YXIgZXZlbnQgPSB7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZW5naW5lLnRpbWluZy50aW1lc3RhbXBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBFdmVudHMudHJpZ2dlcihyZW5kZXIsICdiZWZvcmVSZW5kZXInLCBldmVudCk7XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IGJhY2tncm91bmQgaWYgaXQgaGFzIGNoYW5nZWRcclxuICAgICAgICBpZiAocmVuZGVyLmN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kKVxyXG4gICAgICAgICAgICBfYXBwbHlCYWNrZ3JvdW5kKHJlbmRlciwgYmFja2dyb3VuZCk7XHJcblxyXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXMgd2l0aCBhIHRyYW5zcGFyZW50IGZpbGwsIHRvIGFsbG93IHRoZSBjYW52YXMgYmFja2dyb3VuZCB0byBzaG93XHJcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLWluJztcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwidHJhbnNwYXJlbnRcIjtcclxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xyXG5cclxuICAgICAgICAvLyBoYW5kbGUgYm91bmRzXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgYm9kaWVzIHRoYXQgYXJlIG5vdCBpbiB2aWV3XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxCb2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYWxsQm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKEJvdW5kcy5vdmVybGFwcyhib2R5LmJvdW5kcywgcmVuZGVyLmJvdW5kcykpXHJcbiAgICAgICAgICAgICAgICAgICAgYm9kaWVzLnB1c2goYm9keSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgY29uc3RyYWludHMgdGhhdCBhcmUgbm90IGluIHZpZXdcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbENvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGFsbENvbnN0cmFpbnRzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBID0gY29uc3RyYWludC5ib2R5QSxcclxuICAgICAgICAgICAgICAgICAgICBib2R5QiA9IGNvbnN0cmFpbnQuYm9keUIsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRBV29ybGQgPSBjb25zdHJhaW50LnBvaW50QSxcclxuICAgICAgICAgICAgICAgICAgICBwb2ludEJXb3JsZCA9IGNvbnN0cmFpbnQucG9pbnRCO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChib2R5QSkgcG9pbnRBV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50QSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUIpIHBvaW50QldvcmxkID0gVmVjdG9yLmFkZChib2R5Qi5wb3NpdGlvbiwgY29uc3RyYWludC5wb2ludEIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghcG9pbnRBV29ybGQgfHwgIXBvaW50QldvcmxkKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMocmVuZGVyLmJvdW5kcywgcG9pbnRBV29ybGQpIHx8IEJvdW5kcy5jb250YWlucyhyZW5kZXIuYm91bmRzLCBwb2ludEJXb3JsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRoZSB2aWV3XHJcbiAgICAgICAgICAgIFJlbmRlci5zdGFydFZpZXdUcmFuc2Zvcm0ocmVuZGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBtb3VzZVxyXG4gICAgICAgICAgICBpZiAocmVuZGVyLm1vdXNlKSB7XHJcbiAgICAgICAgICAgICAgICBNb3VzZS5zZXRTY2FsZShyZW5kZXIubW91c2UsIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiAocmVuZGVyLmJvdW5kcy5tYXgueCAtIHJlbmRlci5ib3VuZHMubWluLngpIC8gcmVuZGVyLmNhbnZhcy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICB5OiAocmVuZGVyLmJvdW5kcy5tYXgueSAtIHJlbmRlci5ib3VuZHMubWluLnkpIC8gcmVuZGVyLmNhbnZhcy5oZWlnaHRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIE1vdXNlLnNldE9mZnNldChyZW5kZXIubW91c2UsIHJlbmRlci5ib3VuZHMubWluKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gYWxsQ29uc3RyYWludHM7XHJcbiAgICAgICAgICAgIGJvZGllcyA9IGFsbEJvZGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghb3B0aW9ucy53aXJlZnJhbWVzIHx8IChlbmdpbmUuZW5hYmxlU2xlZXBpbmcgJiYgb3B0aW9ucy5zaG93U2xlZXBpbmcpKSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bGx5IGZlYXR1cmVkIHJlbmRlcmluZyBvZiBib2RpZXNcclxuICAgICAgICAgICAgUmVuZGVyLmJvZGllcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0NvbnZleEh1bGxzKVxyXG4gICAgICAgICAgICAgICAgUmVuZGVyLmJvZHlDb252ZXhIdWxscyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XHJcblxyXG4gICAgICAgICAgICAvLyBvcHRpbWlzZWQgbWV0aG9kIGZvciB3aXJlZnJhbWVzIG9ubHlcclxuICAgICAgICAgICAgUmVuZGVyLmJvZHlXaXJlZnJhbWVzKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dCb3VuZHMpXHJcbiAgICAgICAgICAgIFJlbmRlci5ib2R5Qm91bmRzKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0F4ZXMgfHwgb3B0aW9ucy5zaG93QW5nbGVJbmRpY2F0b3IpXHJcbiAgICAgICAgICAgIFJlbmRlci5ib2R5QXhlcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Bvc2l0aW9ucylcclxuICAgICAgICAgICAgUmVuZGVyLmJvZHlQb3NpdGlvbnMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93VmVsb2NpdHkpXHJcbiAgICAgICAgICAgIFJlbmRlci5ib2R5VmVsb2NpdHkocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93SWRzKVxyXG4gICAgICAgICAgICBSZW5kZXIuYm9keUlkcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dTZXBhcmF0aW9ucylcclxuICAgICAgICAgICAgUmVuZGVyLnNlcGFyYXRpb25zKHJlbmRlciwgZW5naW5lLnBhaXJzLmxpc3QsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93Q29sbGlzaW9ucylcclxuICAgICAgICAgICAgUmVuZGVyLmNvbGxpc2lvbnMocmVuZGVyLCBlbmdpbmUucGFpcnMubGlzdCwgY29udGV4dCk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dWZXJ0ZXhOdW1iZXJzKVxyXG4gICAgICAgICAgICBSZW5kZXIudmVydGV4TnVtYmVycyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dNb3VzZVBvc2l0aW9uKVxyXG4gICAgICAgICAgICBSZW5kZXIubW91c2VQb3NpdGlvbihyZW5kZXIsIHJlbmRlci5tb3VzZSwgY29udGV4dCk7XHJcblxyXG4gICAgICAgIFJlbmRlci5jb25zdHJhaW50cyhjb25zdHJhaW50cywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dCcm9hZHBoYXNlICYmIGVuZ2luZS5icm9hZHBoYXNlLmNvbnRyb2xsZXIgPT09IEdyaWQpXHJcbiAgICAgICAgICAgIFJlbmRlci5ncmlkKHJlbmRlciwgZW5naW5lLmJyb2FkcGhhc2UsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93RGVidWcpXHJcbiAgICAgICAgICAgIFJlbmRlci5kZWJ1ZyhyZW5kZXIsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5oYXNCb3VuZHMpIHtcclxuICAgICAgICAgICAgLy8gcmV2ZXJ0IHZpZXcgdHJhbnNmb3Jtc1xyXG4gICAgICAgICAgICBSZW5kZXIuZW5kVmlld1RyYW5zZm9ybShyZW5kZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocmVuZGVyLCAnYWZ0ZXJSZW5kZXInLCBldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVzY3JpcHRpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGRlYnVnXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmRlYnVnID0gZnVuY3Rpb24ocmVuZGVyLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxyXG4gICAgICAgICAgICBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxyXG4gICAgICAgICAgICB3b3JsZCA9IGVuZ2luZS53b3JsZCxcclxuICAgICAgICAgICAgbWV0cmljcyA9IGVuZ2luZS5tZXRyaWNzLFxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIGJvZGllcyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMod29ybGQpLFxyXG4gICAgICAgICAgICBzcGFjZSA9IFwiICAgIFwiO1xyXG5cclxuICAgICAgICBpZiAoZW5naW5lLnRpbWluZy50aW1lc3RhbXAgLSAocmVuZGVyLmRlYnVnVGltZXN0YW1wIHx8IDApID49IDUwMCkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IFwiXCI7XHJcblxyXG4gICAgICAgICAgICBpZiAobWV0cmljcy50aW1pbmcpIHtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gXCJmcHM6IFwiICsgTWF0aC5yb3VuZChtZXRyaWNzLnRpbWluZy5mcHMpICsgc3BhY2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEBpZiBERUJVR1xyXG4gICAgICAgICAgICBpZiAobWV0cmljcy5leHRlbmRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1ldHJpY3MudGltaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcImRlbHRhOiBcIiArIG1ldHJpY3MudGltaW5nLmRlbHRhLnRvRml4ZWQoMykgKyBzcGFjZTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiY29ycmVjdGlvbjogXCIgKyBtZXRyaWNzLnRpbWluZy5jb3JyZWN0aW9uLnRvRml4ZWQoMykgKyBzcGFjZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiYm9kaWVzOiBcIiArIGJvZGllcy5sZW5ndGggKyBzcGFjZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW5naW5lLmJyb2FkcGhhc2UuY29udHJvbGxlciA9PT0gR3JpZClcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiYnVja2V0czogXCIgKyBtZXRyaWNzLmJ1Y2tldHMgKyBzcGFjZTtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiXFxuXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcImNvbGxpc2lvbnM6IFwiICsgbWV0cmljcy5jb2xsaXNpb25zICsgc3BhY2U7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwicGFpcnM6IFwiICsgZW5naW5lLnBhaXJzLmxpc3QubGVuZ3RoICsgc3BhY2U7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiYnJvYWQ6IFwiICsgbWV0cmljcy5icm9hZEVmZiArIHNwYWNlO1xyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIm1pZDogXCIgKyBtZXRyaWNzLm1pZEVmZiArIHNwYWNlO1xyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIm5hcnJvdzogXCIgKyBtZXRyaWNzLm5hcnJvd0VmZiArIHNwYWNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEBlbmRpZiAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgcmVuZGVyLmRlYnVnU3RyaW5nID0gdGV4dDtcclxuICAgICAgICAgICAgcmVuZGVyLmRlYnVnVGltZXN0YW1wID0gZW5naW5lLnRpbWluZy50aW1lc3RhbXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVuZGVyLmRlYnVnU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGMuZm9udCA9IFwiMTJweCBBcmlhbFwiO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjUpJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC41KSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHJlbmRlci5kZWJ1Z1N0cmluZy5zcGxpdCgnXFxuJyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjLmZpbGxUZXh0KHNwbGl0W2ldLCA1MCwgNTAgKyBpICogMTgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc2NyaXB0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCBjb25zdHJhaW50c1xyXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50W119IGNvbnN0cmFpbnRzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmNvbnN0cmFpbnRzID0gZnVuY3Rpb24oY29uc3RyYWludHMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQ7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghY29uc3RyYWludC5yZW5kZXIudmlzaWJsZSB8fCAhY29uc3RyYWludC5wb2ludEEgfHwgIWNvbnN0cmFpbnQucG9pbnRCKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSBjb25zdHJhaW50LmJvZHlBLFxyXG4gICAgICAgICAgICAgICAgYm9keUIgPSBjb25zdHJhaW50LmJvZHlCO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJvZHlBKSB7XHJcbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgYy5tb3ZlVG8oYm9keUEucG9zaXRpb24ueCArIGNvbnN0cmFpbnQucG9pbnRBLngsIGJvZHlBLnBvc2l0aW9uLnkgKyBjb25zdHJhaW50LnBvaW50QS55KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjLm1vdmVUbyhjb25zdHJhaW50LnBvaW50QS54LCBjb25zdHJhaW50LnBvaW50QS55KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGJvZHlCKSB7XHJcbiAgICAgICAgICAgICAgICBjLmxpbmVUbyhib2R5Qi5wb3NpdGlvbi54ICsgY29uc3RyYWludC5wb2ludEIueCwgYm9keUIucG9zaXRpb24ueSArIGNvbnN0cmFpbnQucG9pbnRCLnkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYy5saW5lVG8oY29uc3RyYWludC5wb2ludEIueCwgY29uc3RyYWludC5wb2ludEIueSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50LnJlbmRlci5saW5lV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGMubGluZVdpZHRoID0gY29uc3RyYWludC5yZW5kZXIubGluZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9IGNvbnN0cmFpbnQucmVuZGVyLnN0cm9rZVN0eWxlO1xyXG4gICAgICAgICAgICAgICAgYy5zdHJva2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogRGVzY3JpcHRpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGJvZHlTaGFkb3dzXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmJvZHlTaGFkb3dzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXHJcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmU7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoYm9keS5jaXJjbGVSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjLmFyYyhib2R5LnBvc2l0aW9uLngsIGJvZHkucG9zaXRpb24ueSwgYm9keS5jaXJjbGVSYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgYy5tb3ZlVG8oYm9keS52ZXJ0aWNlc1swXS54LCBib2R5LnZlcnRpY2VzWzBdLnkpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBib2R5LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8oYm9keS52ZXJ0aWNlc1tqXS54LCBib2R5LnZlcnRpY2VzW2pdLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYy5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IGJvZHkucG9zaXRpb24ueCAtIHJlbmRlci5vcHRpb25zLndpZHRoICogMC41LFxyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VZID0gYm9keS5wb3NpdGlvbi55IC0gcmVuZGVyLm9wdGlvbnMuaGVpZ2h0ICogMC4yLFxyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZVgpICsgTWF0aC5hYnMoZGlzdGFuY2VZKTtcclxuXHJcbiAgICAgICAgICAgIGMuc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwLjE1KSc7XHJcbiAgICAgICAgICAgIGMuc2hhZG93T2Zmc2V0WCA9IDAuMDUgKiBkaXN0YW5jZVg7XHJcbiAgICAgICAgICAgIGMuc2hhZG93T2Zmc2V0WSA9IDAuMDUgKiBkaXN0YW5jZVk7XHJcbiAgICAgICAgICAgIGMuc2hhZG93Qmx1ciA9IDEgKyAxMiAqIE1hdGgubWluKDEsIGRpc3RhbmNlIC8gMTAwMCk7XHJcblxyXG4gICAgICAgICAgICBjLmZpbGwoKTtcclxuXHJcbiAgICAgICAgICAgIGMuc2hhZG93Q29sb3IgPSBudWxsO1xyXG4gICAgICAgICAgICBjLnNoYWRvd09mZnNldFggPSBudWxsO1xyXG4gICAgICAgICAgICBjLnNoYWRvd09mZnNldFkgPSBudWxsO1xyXG4gICAgICAgICAgICBjLnNoYWRvd0JsdXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNjcmlwdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmJvZGllcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxyXG4gICAgICAgICAgICBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIHNob3dJbnRlcm5hbEVkZ2VzID0gb3B0aW9ucy5zaG93SW50ZXJuYWxFZGdlcyB8fCAhb3B0aW9ucy53aXJlZnJhbWVzLFxyXG4gICAgICAgICAgICBib2R5LFxyXG4gICAgICAgICAgICBwYXJ0LFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBrO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBjb21wb3VuZCBwYXJ0c1xyXG4gICAgICAgICAgICBmb3IgKGsgPSBib2R5LnBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgayA8IGJvZHkucGFydHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHBhcnQgPSBib2R5LnBhcnRzW2tdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghcGFydC5yZW5kZXIudmlzaWJsZSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93U2xlZXBpbmcgJiYgYm9keS5pc1NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5nbG9iYWxBbHBoYSA9IDAuNSAqIHBhcnQucmVuZGVyLm9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQucmVuZGVyLm9wYWNpdHkgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjLmdsb2JhbEFscGhhID0gcGFydC5yZW5kZXIub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocGFydC5yZW5kZXIuc3ByaXRlICYmIHBhcnQucmVuZGVyLnNwcml0ZS50ZXh0dXJlICYmICFvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0IHNwcml0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBwYXJ0LnJlbmRlci5zcHJpdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUgPSBfZ2V0VGV4dHVyZShyZW5kZXIsIHNwcml0ZS50ZXh0dXJlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYy50cmFuc2xhdGUocGFydC5wb3NpdGlvbi54LCBwYXJ0LnBvc2l0aW9uLnkpOyBcclxuICAgICAgICAgICAgICAgICAgICBjLnJvdGF0ZShwYXJ0LmFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYy5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUud2lkdGggKiAtc3ByaXRlLnhPZmZzZXQgKiBzcHJpdGUueFNjYWxlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5oZWlnaHQgKiAtc3ByaXRlLnlPZmZzZXQgKiBzcHJpdGUueVNjYWxlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS53aWR0aCAqIHNwcml0ZS54U2NhbGUsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmhlaWdodCAqIHNwcml0ZS55U2NhbGVcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnQgdHJhbnNsYXRpb24sIGhvcGVmdWxseSBmYXN0ZXIgdGhhbiBzYXZlIC8gcmVzdG9yZVxyXG4gICAgICAgICAgICAgICAgICAgIGMucm90YXRlKC1wYXJ0LmFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICBjLnRyYW5zbGF0ZSgtcGFydC5wb3NpdGlvbi54LCAtcGFydC5wb3NpdGlvbi55KTsgXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcnQgcG9seWdvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LmNpcmNsZVJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmFyYyhwYXJ0LnBvc2l0aW9uLngsIHBhcnQucG9zaXRpb24ueSwgcGFydC5jaXJjbGVSYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWzBdLngsIHBhcnQudmVydGljZXNbMF0ueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHBhcnQudmVydGljZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFydC52ZXJ0aWNlc1tqIC0gMV0uaXNJbnRlcm5hbCB8fCBzaG93SW50ZXJuYWxFZGdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC52ZXJ0aWNlc1tqXS54LCBwYXJ0LnZlcnRpY2VzW2pdLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnZlcnRpY2VzW2pdLmlzSW50ZXJuYWwgJiYgIXNob3dJbnRlcm5hbEVkZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC52ZXJ0aWNlc1soaiArIDEpICUgcGFydC52ZXJ0aWNlcy5sZW5ndGhdLngsIHBhcnQudmVydGljZXNbKGogKyAxKSAlIHBhcnQudmVydGljZXMubGVuZ3RoXS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC52ZXJ0aWNlc1swXS54LCBwYXJ0LnZlcnRpY2VzWzBdLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSBwYXJ0LnJlbmRlci5maWxsU3R5bGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5yZW5kZXIubGluZVdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVXaWR0aCA9IHBhcnQucmVuZGVyLmxpbmVXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSBwYXJ0LnJlbmRlci5zdHJva2VTdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVdpZHRoID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICcjYmJiJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5zdHJva2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYy5nbG9iYWxBbHBoYSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3B0aW1pc2VkIG1ldGhvZCBmb3IgZHJhd2luZyBib2R5IHdpcmVmcmFtZXMgaW4gb25lIHBhc3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGJvZHlXaXJlZnJhbWVzXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmJvZHlXaXJlZnJhbWVzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXHJcbiAgICAgICAgICAgIHNob3dJbnRlcm5hbEVkZ2VzID0gcmVuZGVyLm9wdGlvbnMuc2hvd0ludGVybmFsRWRnZXMsXHJcbiAgICAgICAgICAgIGJvZHksXHJcbiAgICAgICAgICAgIHBhcnQsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGosXHJcbiAgICAgICAgICAgIGs7XHJcblxyXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XHJcblxyXG4gICAgICAgIC8vIHJlbmRlciBhbGwgYm9kaWVzXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAvLyBoYW5kbGUgY29tcG91bmQgcGFydHNcclxuICAgICAgICAgICAgZm9yIChrID0gYm9keS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBib2R5LnBhcnRzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0ID0gYm9keS5wYXJ0c1trXTtcclxuXHJcbiAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWzBdLngsIHBhcnQudmVydGljZXNbMF0ueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IHBhcnQudmVydGljZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQudmVydGljZXNbaiAtIDFdLmlzSW50ZXJuYWwgfHwgc2hvd0ludGVybmFsRWRnZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC52ZXJ0aWNlc1tqXS54LCBwYXJ0LnZlcnRpY2VzW2pdLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnZlcnRpY2VzW2pdLmlzSW50ZXJuYWwgJiYgIXNob3dJbnRlcm5hbEVkZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbKGogKyAxKSAlIHBhcnQudmVydGljZXMubGVuZ3RoXS54LCBwYXJ0LnZlcnRpY2VzWyhqICsgMSkgJSBwYXJ0LnZlcnRpY2VzLmxlbmd0aF0ueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjLmxpbmVUbyhwYXJ0LnZlcnRpY2VzWzBdLngsIHBhcnQudmVydGljZXNbMF0ueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMubGluZVdpZHRoID0gMTtcclxuICAgICAgICBjLnN0cm9rZVN0eWxlID0gJyNiYmInO1xyXG4gICAgICAgIGMuc3Ryb2tlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3B0aW1pc2VkIG1ldGhvZCBmb3IgZHJhd2luZyBib2R5IGNvbnZleCBodWxsIHdpcmVmcmFtZXMgaW4gb25lIHBhc3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGJvZHlDb252ZXhIdWxsc1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5ib2R5Q29udmV4SHVsbHMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjID0gY29udGV4dCxcclxuICAgICAgICAgICAgYm9keSxcclxuICAgICAgICAgICAgcGFydCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgaztcclxuXHJcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuXHJcbiAgICAgICAgLy8gcmVuZGVyIGNvbnZleCBodWxsc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSB8fCBib2R5LnBhcnRzLmxlbmd0aCA9PT0gMSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgYy5tb3ZlVG8oYm9keS52ZXJ0aWNlc1swXS54LCBib2R5LnZlcnRpY2VzWzBdLnkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IGJvZHkudmVydGljZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGMubGluZVRvKGJvZHkudmVydGljZXNbal0ueCwgYm9keS52ZXJ0aWNlc1tqXS55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYy5saW5lVG8oYm9keS52ZXJ0aWNlc1swXS54LCBib2R5LnZlcnRpY2VzWzBdLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xyXG4gICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjIpJztcclxuICAgICAgICBjLnN0cm9rZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYm9keSB2ZXJ0ZXggbnVtYmVycy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIHZlcnRleE51bWJlcnNcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBSZW5kZXIudmVydGV4TnVtYmVycyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBrO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGJvZGllc1tpXS5wYXJ0cztcclxuICAgICAgICAgICAgZm9yIChrID0gcGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBrIDwgcGFydHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNba107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGFydC52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC4yKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5maWxsVGV4dChpICsgJ18nICsgaiwgcGFydC5wb3NpdGlvbi54ICsgKHBhcnQudmVydGljZXNbal0ueCAtIHBhcnQucG9zaXRpb24ueCkgKiAwLjgsIHBhcnQucG9zaXRpb24ueSArIChwYXJ0LnZlcnRpY2VzW2pdLnkgLSBwYXJ0LnBvc2l0aW9uLnkpICogMC44KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIG1vdXNlIHBvc2l0aW9uLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgbW91c2VQb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHttb3VzZX0gbW91c2VcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBSZW5kZXIubW91c2VQb3NpdGlvbiA9IGZ1bmN0aW9uKHJlbmRlciwgbW91c2UsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQ7XHJcbiAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjgpJztcclxuICAgICAgICBjLmZpbGxUZXh0KG1vdXNlLnBvc2l0aW9uLnggKyAnICAnICsgbW91c2UucG9zaXRpb24ueSwgbW91c2UucG9zaXRpb24ueCArIDUsIG1vdXNlLnBvc2l0aW9uLnkgLSA1KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBib2R5IGJvdW5kc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgYm9keUJvdW5kc1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5ib2R5Qm91bmRzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXHJcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucztcclxuXHJcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoYm9keS5yZW5kZXIudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gYm9kaWVzW2ldLnBhcnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBjLnJlY3QocGFydC5ib3VuZHMubWluLngsIHBhcnQuYm91bmRzLm1pbi55LCBwYXJ0LmJvdW5kcy5tYXgueCAtIHBhcnQuYm91bmRzLm1pbi54LCBwYXJ0LmJvdW5kcy5tYXgueSAtIHBhcnQuYm91bmRzLm1pbi55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xyXG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC4wOCknO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwwLjEpJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMubGluZVdpZHRoID0gMTtcclxuICAgICAgICBjLnN0cm9rZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGJvZHkgYW5nbGUgaW5kaWNhdG9ycyBhbmQgYXhlc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgYm9keUF4ZXNcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBSZW5kZXIuYm9keUF4ZXMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjID0gY29udGV4dCxcclxuICAgICAgICAgICAgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxyXG4gICAgICAgICAgICBwYXJ0LFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBrO1xyXG5cclxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgcGFydHMgPSBib2R5LnBhcnRzO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93QXhlcykge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGFsbCBheGVzXHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBwYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcGFydC5heGVzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzID0gcGFydC5heGVzW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnBvc2l0aW9uLngsIHBhcnQucG9zaXRpb24ueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQucG9zaXRpb24ueCArIGF4aXMueCAqIDIwLCBwYXJ0LnBvc2l0aW9uLnkgKyBheGlzLnkgKiAyMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gcGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHBhcnQuYXhlcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgYSBzaW5nbGUgYXhpcyBpbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC5wb3NpdGlvbi54LCBwYXJ0LnBvc2l0aW9uLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbygocGFydC52ZXJ0aWNlc1swXS54ICsgcGFydC52ZXJ0aWNlc1twYXJ0LnZlcnRpY2VzLmxlbmd0aC0xXS54KSAvIDIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGFydC52ZXJ0aWNlc1swXS55ICsgcGFydC52ZXJ0aWNlc1twYXJ0LnZlcnRpY2VzLmxlbmd0aC0xXS55KSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xyXG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ2luZGlhbnJlZCc7XHJcbiAgICAgICAgICAgIGMubGluZVdpZHRoID0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC40KSc7XHJcbiAgICAgICAgICAgIGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ292ZXJsYXknO1xyXG4gICAgICAgICAgICBjLmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjLnN0cm9rZSgpO1xyXG4gICAgICAgIGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBib2R5IHBvc2l0aW9uc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgYm9keVBvc2l0aW9uc1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5ib2R5UG9zaXRpb25zID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXHJcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcclxuICAgICAgICAgICAgYm9keSxcclxuICAgICAgICAgICAgcGFydCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaztcclxuXHJcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuXHJcbiAgICAgICAgLy8gcmVuZGVyIGN1cnJlbnQgcG9zaXRpb25zXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAvLyBoYW5kbGUgY29tcG91bmQgcGFydHNcclxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGJvZHkucGFydHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHBhcnQgPSBib2R5LnBhcnRzW2tdO1xyXG4gICAgICAgICAgICAgICAgYy5hcmMocGFydC5wb3NpdGlvbi54LCBwYXJ0LnBvc2l0aW9uLnksIDMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBjLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XHJcbiAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ2luZGlhbnJlZCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjUpJztcclxuICAgICAgICB9XHJcbiAgICAgICAgYy5maWxsKCk7XHJcblxyXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XHJcblxyXG4gICAgICAgIC8vIHJlbmRlciBwcmV2aW91cyBwb3NpdGlvbnNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChib2R5LnJlbmRlci52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjLmFyYyhib2R5LnBvc2l0aW9uUHJldi54LCBib2R5LnBvc2l0aW9uUHJldi55LCAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgYy5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC44KSc7XHJcbiAgICAgICAgYy5maWxsKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYm9keSB2ZWxvY2l0eVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgYm9keVZlbG9jaXR5XHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmJvZHlWZWxvY2l0eSA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0O1xyXG5cclxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgYy5tb3ZlVG8oYm9keS5wb3NpdGlvbi54LCBib2R5LnBvc2l0aW9uLnkpO1xyXG4gICAgICAgICAgICBjLmxpbmVUbyhib2R5LnBvc2l0aW9uLnggKyAoYm9keS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvblByZXYueCkgKiAyLCBib2R5LnBvc2l0aW9uLnkgKyAoYm9keS5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvblByZXYueSkgKiAyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMubGluZVdpZHRoID0gMztcclxuICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ2Nvcm5mbG93ZXJibHVlJztcclxuICAgICAgICBjLnN0cm9rZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGJvZHkgaWRzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCBib2R5SWRzXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmJvZHlJZHMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjID0gY29udGV4dCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgajtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWJvZGllc1tpXS5yZW5kZXIudmlzaWJsZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhcnRzID0gYm9kaWVzW2ldLnBhcnRzO1xyXG4gICAgICAgICAgICBmb3IgKGogPSBwYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tqXTtcclxuICAgICAgICAgICAgICAgIGMuZm9udCA9IFwiMTJweCBBcmlhbFwiO1xyXG4gICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjUpJztcclxuICAgICAgICAgICAgICAgIGMuZmlsbFRleHQocGFydC5pZCwgcGFydC5wb3NpdGlvbi54ICsgMTAsIHBhcnQucG9zaXRpb24ueSAtIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNjcmlwdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgY29sbGlzaW9uc1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmNvbGxpc2lvbnMgPSBmdW5jdGlvbihyZW5kZXIsIHBhaXJzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIHBhaXIsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbixcclxuICAgICAgICAgICAgY29ycmVjdGVkLFxyXG4gICAgICAgICAgICBib2R5QSxcclxuICAgICAgICAgICAgYm9keUIsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGo7XHJcblxyXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XHJcblxyXG4gICAgICAgIC8vIHJlbmRlciBjb2xsaXNpb24gcG9zaXRpb25zXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYWlyLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHBhaXIuYWN0aXZlQ29udGFjdHNbal0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gY29udGFjdC52ZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICBjLnJlY3QodmVydGV4LnggLSAxLjUsIHZlcnRleC55IC0gMS41LCAzLjUsIDMuNSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdvcmFuZ2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjLmZpbGwoKTtcclxuXHJcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgLy8gcmVuZGVyIGNvbGxpc2lvbiBub3JtYWxzXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XHJcblxyXG4gICAgICAgICAgICBpZiAocGFpci5hY3RpdmVDb250YWN0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsUG9zWCA9IHBhaXIuYWN0aXZlQ29udGFjdHNbMF0udmVydGV4LngsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsUG9zWSA9IHBhaXIuYWN0aXZlQ29udGFjdHNbMF0udmVydGV4Lnk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBhaXIuYWN0aXZlQ29udGFjdHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsUG9zWCA9IChwYWlyLmFjdGl2ZUNvbnRhY3RzWzBdLnZlcnRleC54ICsgcGFpci5hY3RpdmVDb250YWN0c1sxXS52ZXJ0ZXgueCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFBvc1kgPSAocGFpci5hY3RpdmVDb250YWN0c1swXS52ZXJ0ZXgueSArIHBhaXIuYWN0aXZlQ29udGFjdHNbMV0udmVydGV4LnkpIC8gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxpc2lvbi5ib2R5QiA9PT0gY29sbGlzaW9uLnN1cHBvcnRzWzBdLmJvZHkgfHwgY29sbGlzaW9uLmJvZHlBLmlzU3RhdGljID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8obm9ybWFsUG9zWCAtIGNvbGxpc2lvbi5ub3JtYWwueCAqIDgsIG5vcm1hbFBvc1kgLSBjb2xsaXNpb24ubm9ybWFsLnkgKiA4KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8obm9ybWFsUG9zWCArIGNvbGxpc2lvbi5ub3JtYWwueCAqIDgsIG5vcm1hbFBvc1kgKyBjb2xsaXNpb24ubm9ybWFsLnkgKiA4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjLmxpbmVUbyhub3JtYWxQb3NYLCBub3JtYWxQb3NZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xyXG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDE2NSwwLDAuNyknO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAnb3JhbmdlJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMubGluZVdpZHRoID0gMTtcclxuICAgICAgICBjLnN0cm9rZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc2NyaXB0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCBzZXBhcmF0aW9uc1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLnNlcGFyYXRpb25zID0gZnVuY3Rpb24ocmVuZGVyLCBwYWlycywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjID0gY29udGV4dCxcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxyXG4gICAgICAgICAgICBwYWlyLFxyXG4gICAgICAgICAgICBjb2xsaXNpb24sXHJcbiAgICAgICAgICAgIGNvcnJlY3RlZCxcclxuICAgICAgICAgICAgYm9keUEsXHJcbiAgICAgICAgICAgIGJvZHlCLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBqO1xyXG5cclxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG5cclxuICAgICAgICAvLyByZW5kZXIgc2VwYXJhdGlvbnNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcclxuICAgICAgICAgICAgYm9keUEgPSBjb2xsaXNpb24uYm9keUE7XHJcbiAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLmJvZHlCO1xyXG5cclxuICAgICAgICAgICAgdmFyIGsgPSAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFib2R5Qi5pc1N0YXRpYyAmJiAhYm9keUEuaXNTdGF0aWMpIGsgPSAwLjU7XHJcbiAgICAgICAgICAgIGlmIChib2R5Qi5pc1N0YXRpYykgayA9IDA7XHJcblxyXG4gICAgICAgICAgICBjLm1vdmVUbyhib2R5Qi5wb3NpdGlvbi54LCBib2R5Qi5wb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgYy5saW5lVG8oYm9keUIucG9zaXRpb24ueCAtIGNvbGxpc2lvbi5wZW5ldHJhdGlvbi54ICogaywgYm9keUIucG9zaXRpb24ueSAtIGNvbGxpc2lvbi5wZW5ldHJhdGlvbi55ICogayk7XHJcblxyXG4gICAgICAgICAgICBrID0gMTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYm9keUIuaXNTdGF0aWMgJiYgIWJvZHlBLmlzU3RhdGljKSBrID0gMC41O1xyXG4gICAgICAgICAgICBpZiAoYm9keUEuaXNTdGF0aWMpIGsgPSAwO1xyXG5cclxuICAgICAgICAgICAgYy5tb3ZlVG8oYm9keUEucG9zaXRpb24ueCwgYm9keUEucG9zaXRpb24ueSk7XHJcbiAgICAgICAgICAgIGMubGluZVRvKGJvZHlBLnBvc2l0aW9uLnggKyBjb2xsaXNpb24ucGVuZXRyYXRpb24ueCAqIGssIGJvZHlBLnBvc2l0aW9uLnkgKyBjb2xsaXNpb24ucGVuZXRyYXRpb24ueSAqIGspO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xyXG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDE2NSwwLDAuNSknO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAnb3JhbmdlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgYy5zdHJva2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNjcmlwdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgZ3JpZFxyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtncmlkfSBncmlkXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmdyaWQgPSBmdW5jdGlvbihyZW5kZXIsIGdyaWQsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucztcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xyXG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDE4MCwwLDAuMSknO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMTgwLDAsMC41KSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG5cclxuICAgICAgICB2YXIgYnVja2V0S2V5cyA9IENvbW1vbi5rZXlzKGdyaWQuYnVja2V0cyk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYnVja2V0SWQgPSBidWNrZXRLZXlzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGdyaWQuYnVja2V0c1tidWNrZXRJZF0ubGVuZ3RoIDwgMilcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IGJ1Y2tldElkLnNwbGl0KC9DfFIvKTtcclxuICAgICAgICAgICAgYy5yZWN0KDAuNSArIHBhcnNlSW50KHJlZ2lvblsxXSwgMTApICogZ3JpZC5idWNrZXRXaWR0aCwgXHJcbiAgICAgICAgICAgICAgICAgICAgMC41ICsgcGFyc2VJbnQocmVnaW9uWzJdLCAxMCkgKiBncmlkLmJ1Y2tldEhlaWdodCwgXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5idWNrZXRXaWR0aCwgXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5idWNrZXRIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xyXG4gICAgICAgIGMuc3Ryb2tlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVzY3JpcHRpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGluc3BlY3RvclxyXG4gICAgICogQHBhcmFtIHtpbnNwZWN0b3J9IGluc3BlY3RvclxyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5pbnNwZWN0b3IgPSBmdW5jdGlvbihpbnNwZWN0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgZW5naW5lID0gaW5zcGVjdG9yLmVuZ2luZSxcclxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBpbnNwZWN0b3Iuc2VsZWN0ZWQsXHJcbiAgICAgICAgICAgIHJlbmRlciA9IGluc3BlY3Rvci5yZW5kZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcclxuICAgICAgICAgICAgYm91bmRzO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5oYXNCb3VuZHMpIHtcclxuICAgICAgICAgICAgdmFyIGJvdW5kc1dpZHRoID0gcmVuZGVyLmJvdW5kcy5tYXgueCAtIHJlbmRlci5ib3VuZHMubWluLngsXHJcbiAgICAgICAgICAgICAgICBib3VuZHNIZWlnaHQgPSByZW5kZXIuYm91bmRzLm1heC55IC0gcmVuZGVyLmJvdW5kcy5taW4ueSxcclxuICAgICAgICAgICAgICAgIGJvdW5kc1NjYWxlWCA9IGJvdW5kc1dpZHRoIC8gcmVuZGVyLm9wdGlvbnMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBib3VuZHNTY2FsZVkgPSBib3VuZHNIZWlnaHQgLyByZW5kZXIub3B0aW9ucy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb250ZXh0LnNjYWxlKDEgLyBib3VuZHNTY2FsZVgsIDEgLyBib3VuZHNTY2FsZVkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtcmVuZGVyLmJvdW5kcy5taW4ueCwgLXJlbmRlci5ib3VuZHMubWluLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHNlbGVjdGVkW2ldLmRhdGE7XHJcblxyXG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcclxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjkpJztcclxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbMSwyXSk7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnYm9keSc6XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGJvZHkgc2VsZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgYm91bmRzID0gaXRlbS5ib3VuZHM7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWN0KE1hdGguZmxvb3IoYm91bmRzLm1pbi54IC0gMyksIE1hdGguZmxvb3IoYm91bmRzLm1pbi55IC0gMyksIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoYm91bmRzLm1heC54IC0gYm91bmRzLm1pbi54ICsgNiksIE1hdGguZmxvb3IoYm91bmRzLm1heC55IC0gYm91bmRzLm1pbi55ICsgNikpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgY29uc3RyYWludCBzZWxlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBpdGVtLnBvaW50QTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmJvZHlBKVxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gaXRlbS5wb2ludEI7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMocG9pbnQueCwgcG9pbnQueSwgMTAsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC0wLjUsIC0wLjUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVuZGVyIHNlbGVjdGlvbiByZWdpb25cclxuICAgICAgICBpZiAoaW5zcGVjdG9yLnNlbGVjdFN0YXJ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xyXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDE2NSwwLDAuNiknO1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjEpJztcclxuICAgICAgICAgICAgYm91bmRzID0gaW5zcGVjdG9yLnNlbGVjdEJvdW5kcztcclxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5yZWN0KE1hdGguZmxvb3IoYm91bmRzLm1pbi54KSwgTWF0aC5mbG9vcihib3VuZHMubWluLnkpLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoYm91bmRzLm1heC54IC0gYm91bmRzLm1pbi54KSwgTWF0aC5mbG9vcihib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnkpKTtcclxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC0wLjUsIC0wLjUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKVxyXG4gICAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNjcmlwdGlvblxyXG4gICAgICogQG1ldGhvZCBfY3JlYXRlQ2FudmFzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHt9IHdpZHRoXHJcbiAgICAgKiBAcGFyYW0ge30gaGVpZ2h0XHJcbiAgICAgKiBAcmV0dXJuIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICB2YXIgX2NyZWF0ZUNhbnZhcyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBjYW52YXMub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XHJcbiAgICAgICAgY2FudmFzLm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG4gICAgICAgIHJldHVybiBjYW52YXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcGl4ZWwgcmF0aW8gb2YgdGhlIGNhbnZhcy5cclxuICAgICAqIEBtZXRob2QgX2dldFBpeGVsUmF0aW9cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjYW52YXNcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcGl4ZWwgcmF0aW9cclxuICAgICAqL1xyXG4gICAgdmFyIF9nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oY2FudmFzKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcclxuICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXHJcbiAgICAgICAgICAgIGJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gPSBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xyXG5cclxuICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVBpeGVsUmF0aW87XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcmVxdWVzdGVkIHRleHR1cmUgKGFuIEltYWdlKSB2aWEgaXRzIHBhdGhcclxuICAgICAqIEBtZXRob2QgX2dldFRleHR1cmVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VQYXRoXHJcbiAgICAgKiBAcmV0dXJuIHtJbWFnZX0gdGV4dHVyZVxyXG4gICAgICovXHJcbiAgICB2YXIgX2dldFRleHR1cmUgPSBmdW5jdGlvbihyZW5kZXIsIGltYWdlUGF0aCkge1xyXG4gICAgICAgIHZhciBpbWFnZSA9IHJlbmRlci50ZXh0dXJlc1tpbWFnZVBhdGhdO1xyXG5cclxuICAgICAgICBpZiAoaW1hZ2UpXHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcclxuXHJcbiAgICAgICAgaW1hZ2UgPSByZW5kZXIudGV4dHVyZXNbaW1hZ2VQYXRoXSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltYWdlLnNyYyA9IGltYWdlUGF0aDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGJhY2tncm91bmQgdG8gdGhlIGNhbnZhcyB1c2luZyBDU1MuXHJcbiAgICAgKiBAbWV0aG9kIGFwcGx5QmFja2dyb3VuZFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYWNrZ3JvdW5kXHJcbiAgICAgKi9cclxuICAgIHZhciBfYXBwbHlCYWNrZ3JvdW5kID0gZnVuY3Rpb24ocmVuZGVyLCBiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgdmFyIGNzc0JhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xyXG5cclxuICAgICAgICBpZiAoLyhqcGd8Z2lmfHBuZykkLy50ZXN0KGJhY2tncm91bmQpKVxyXG4gICAgICAgICAgICBjc3NCYWNrZ3JvdW5kID0gJ3VybCgnICsgYmFja2dyb3VuZCArICcpJztcclxuXHJcbiAgICAgICAgcmVuZGVyLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gY3NzQmFja2dyb3VuZDtcclxuICAgICAgICByZW5kZXIuY2FudmFzLnN0eWxlLmJhY2tncm91bmRTaXplID0gXCJjb250YWluXCI7XHJcbiAgICAgICAgcmVuZGVyLmN1cnJlbnRCYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICpcclxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCBiZWZvcmUgcmVuZGVyaW5nXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBiZWZvcmVSZW5kZXJcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCBhZnRlciByZW5kZXJpbmdcclxuICAgICpcclxuICAgICogQGV2ZW50IGFmdGVyUmVuZGVyXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBiYWNrLXJlZmVyZW5jZSB0byB0aGUgYE1hdHRlci5SZW5kZXJgIG1vZHVsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgY29udHJvbGxlclxyXG4gICAgICogQHR5cGUgcmVuZGVyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgTWF0dGVyLkVuZ2luZWAgaW5zdGFuY2UgdG8gYmUgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgZW5naW5lXHJcbiAgICAgKiBAdHlwZSBlbmdpbmVcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgd2hlcmUgdGhlIGNhbnZhcyBpcyB0byBiZSBpbnNlcnRlZCAoaWYgYHJlbmRlci5jYW52YXNgIGhhcyBub3QgYmVlbiBzcGVjaWZpZWQpXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGVsZW1lbnRcclxuICAgICAqIEB0eXBlIEhUTUxFbGVtZW50XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0byByZW5kZXIgdG8uIElmIG5vdCBzcGVjaWZpZWQsIG9uZSB3aWxsIGJlIGNyZWF0ZWQgaWYgYHJlbmRlci5lbGVtZW50YCBoYXMgYmVlbiBzcGVjaWZpZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGNhbnZhc1xyXG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnNcclxuICAgICAqIEB0eXBlIHt9XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YXJnZXQgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBgcmVuZGVyLmNhbnZhc2AgdG8gYmUgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy53aWR0aFxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCA4MDBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRhcmdldCBoZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBgcmVuZGVyLmNhbnZhc2AgdG8gYmUgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5oZWlnaHRcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgNjAwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZmxhZyB0aGF0IHNwZWNpZmllcyBpZiBgcmVuZGVyLmJvdW5kc2Agc2hvdWxkIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuaGFzQm91bmRzXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBCb3VuZHNgIG9iamVjdCB0aGF0IHNwZWNpZmllcyB0aGUgZHJhd2luZyB2aWV3IHJlZ2lvbi4gXHJcbiAgICAgKiBSZW5kZXJpbmcgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHRyYW5zZm9ybWVkIGFuZCBzY2FsZWQgdG8gZml0IHdpdGhpbiB0aGUgY2FudmFzIHNpemUgKGByZW5kZXIub3B0aW9ucy53aWR0aGAgYW5kIGByZW5kZXIub3B0aW9ucy5oZWlnaHRgKS5cclxuICAgICAqIFRoaXMgYWxsb3dzIGZvciBjcmVhdGluZyB2aWV3cyB0aGF0IGNhbiBwYW4gb3Igem9vbSBhcm91bmQgdGhlIHNjZW5lLlxyXG4gICAgICogWW91IG11c3QgYWxzbyBzZXQgYHJlbmRlci5vcHRpb25zLmhhc0JvdW5kc2AgdG8gYHRydWVgIHRvIGVuYWJsZSBib3VuZGVkIHJlbmRlcmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgYm91bmRzXHJcbiAgICAgKiBAdHlwZSBib3VuZHNcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIDJkIHJlbmRlcmluZyBjb250ZXh0IGZyb20gdGhlIGByZW5kZXIuY2FudmFzYCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBjb250ZXh0XHJcbiAgICAgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNwcml0ZSB0ZXh0dXJlIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB0ZXh0dXJlc1xyXG4gICAgICogQHR5cGUge31cclxuICAgICAqL1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlci5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE5PUk1BTDogMCxcclxuICAgIEFERDogMSxcclxuICAgIE1VTFRJUExZOiAyLFxyXG4gICAgU0NSRUVOOiAzLFxyXG4gICAgT1ZFUkxBWTogNCxcclxuICAgIERBUktFTjogNSxcclxuICAgIExJR0hURU46IDYsXHJcbiAgICBDT0xPUl9ET0RHRTogNyxcclxuICAgIENPTE9SX0JVUk46IDgsXHJcbiAgICBIQVJEX0xJR0hUOiA5LFxyXG4gICAgU09GVF9MSUdIVDogMTAsXHJcbiAgICBESUZGRVJFTkNFOiAxMSxcclxuICAgIEVYQ0xVU0lPTjogMTIsXHJcbiAgICBIVUU6IDEzLFxyXG4gICAgU0FUVVJBVElPTjogMTQsXHJcbiAgICBDT0xPUjogMTUsXHJcbiAgICBMVU1JTk9TSVRZOiAxNlxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvQmxlbmRNb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJ1ZmZlcjE2ID0gZnVuY3Rpb24gKGJ5dGVTaXplKVxyXG57XHJcbiAgICB0aGlzLndvcmRMZW5ndGggPSAwO1xyXG4gICAgdGhpcy53b3JkQ2FwYWNpdHkgPSBieXRlU2l6ZSAvIDI7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU2l6ZSk7XHJcbiAgICB0aGlzLmludFZpZXcgPSBuZXcgSW50MTZBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICB0aGlzLnVpbnRWaWV3ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYnVmZmVyKTtcclxufTtcclxuXHJcbkJ1ZmZlcjE2LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMud29yZExlbmd0aCA9IDA7XHJcbn07XHJcblxyXG5CdWZmZXIxNi5wcm90b3R5cGUuZ2V0Qnl0ZUxlbmd0aCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLndvcmRMZW5ndGggKiAyO1xyXG59O1xyXG5cclxuQnVmZmVyMTYucHJvdG90eXBlLmdldEJ5dGVDYXBhY2l0eSA9IGZ1bmN0aW9uICgpIFxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcclxufTtcclxuXHJcbkJ1ZmZlcjE2LnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uICh3b3JkU2l6ZSlcclxue1xyXG4gICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLndvcmRMZW5ndGg7XHJcbiAgICB0aGlzLndvcmRMZW5ndGggKz0gd29yZFNpemU7XHJcbiAgICByZXR1cm4gY3VycmVudExlbmd0aDtcclxufTtcclxuXHJcbkJ1ZmZlcjE2LnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNTaG9ydCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmludFZpZXcuc3ViYXJyYXkoMCwgdGhpcy53b3JkTGVuZ3RoKTtcclxufTtcclxuXHJcbkJ1ZmZlcjE2LnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNXb3JkID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMudWludFZpZXcuc3ViYXJyYXkoMCwgdGhpcy53b3JkTGVuZ3RoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyMTY7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL2J1ZmZlci9CdWZmZXIxNi5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBOT09QID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgLy8gIE5PT1AgKE5vIE9wZXJhdGlvbikgQ2FsbGJhY2tcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTk9PUDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvTk9PUC5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJORCA9IHJlcXVpcmUoJy4vcmFuZG9tLWRhdGEtZ2VuZXJhdG9yL1JhbmRvbURhdGFHZW5lcmF0b3InKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIC8vICBDT05TVHMgKG1ha2VzIHRoZW0gdmlzaWJsZSB1bmRlciBQaGFzZXIuTWF0aClcclxuICAgIFBJMjogTWF0aC5QSSAqIDIsXHJcbiAgICBUQVU6IE1hdGguUEkgKiAwLjUsXHJcbiAgICBFUFNJTE9OOiAxLjBlLTYsXHJcbiAgICBERUdfVE9fUkFEOiBNYXRoLlBJIC8gMTgwLFxyXG4gICAgUkFEX1RPX0RFRzogMTgwIC8gTWF0aC5QSSxcclxuXHJcbiAgICAvLyAgQ29sbGVjdGlvbnMgb2YgZnVuY3Rpb25zXHJcbiAgICBBbmdsZTogcmVxdWlyZSgnLi9hbmdsZS8nKSxcclxuICAgIERpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlLycpLFxyXG4gICAgRWFzaW5nOiByZXF1aXJlKCcuL2Vhc2luZy8nKSxcclxuICAgIEZ1enp5OiByZXF1aXJlKCcuL2Z1enp5LycpLFxyXG4gICAgSW50ZXJwb2xhdGlvbjogcmVxdWlyZSgnLi9pbnRlcnBvbGF0aW9uLycpLFxyXG4gICAgUG93MjogcmVxdWlyZSgnLi9wb3cyLycpLFxyXG4gICAgU25hcDogcmVxdWlyZSgnLi9zbmFwLycpLFxyXG5cclxuICAgIC8vICBSYW5kb20gRGF0YSBHZW5lcmF0b3JcclxuICAgIFJORDogbmV3IFJORCgpLFxyXG5cclxuICAgIC8vICBTaW5nbGUgZnVuY3Rpb25zXHJcbiAgICBBdmVyYWdlOiByZXF1aXJlKCcuL0F2ZXJhZ2UnKSxcclxuICAgIEJlcm5zdGVpbjogcmVxdWlyZSgnLi9CZXJuc3RlaW4nKSxcclxuICAgIEJldHdlZW46IHJlcXVpcmUoJy4vQmV0d2VlbicpLFxyXG4gICAgQ2F0bXVsbFJvbTogcmVxdWlyZSgnLi9DYXRtdWxsUm9tJyksXHJcbiAgICBDZWlsVG86IHJlcXVpcmUoJy4vQ2VpbFRvJyksXHJcbiAgICBDbGFtcDogcmVxdWlyZSgnLi9DbGFtcCcpLFxyXG4gICAgRGVnVG9SYWQ6IHJlcXVpcmUoJy4vRGVnVG9SYWQnKSxcclxuICAgIERpZmZlcmVuY2U6IHJlcXVpcmUoJy4vRGlmZmVyZW5jZScpLFxyXG4gICAgRmFjdG9yaWFsOiByZXF1aXJlKCcuL0ZhY3RvcmlhbCcpLFxyXG4gICAgRmxvYXRCZXR3ZWVuOiByZXF1aXJlKCcuL0Zsb2F0QmV0d2VlbicpLFxyXG4gICAgRmxvb3JUbzogcmVxdWlyZSgnLi9GbG9vclRvJyksXHJcbiAgICBMaW5lYXI6IHJlcXVpcmUoJy4vTGluZWFyJyksXHJcbiAgICBNYXhBZGQ6IHJlcXVpcmUoJy4vTWF4QWRkJyksXHJcbiAgICBNaW5TdWI6IHJlcXVpcmUoJy4vTWluU3ViJyksXHJcbiAgICBQZXJjZW50OiByZXF1aXJlKCcuL1BlcmNlbnQnKSxcclxuICAgIFJhZFRvRGVnOiByZXF1aXJlKCcuL1JhZFRvRGVnJyksXHJcbiAgICBSb3RhdGU6IHJlcXVpcmUoJy4vUm90YXRlJyksXHJcbiAgICBSb3RhdGVBcm91bmQ6IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kJyksXHJcbiAgICBSb3RhdGVBcm91bmREaXN0YW5jZTogcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmREaXN0YW5jZScpLFxyXG4gICAgUm91bmRBd2F5RnJvbVplcm86IHJlcXVpcmUoJy4vUm91bmRBd2F5RnJvbVplcm8nKSxcclxuICAgIFJvdW5kVG86IHJlcXVpcmUoJy4vUm91bmRUbycpLFxyXG4gICAgU2luQ29zVGFibGVHZW5lcmF0b3I6IHJlcXVpcmUoJy4vU2luQ29zVGFibGVHZW5lcmF0b3InKSxcclxuICAgIFNtb290aGVyU3RlcDogcmVxdWlyZSgnLi9TbW9vdGhlclN0ZXAnKSxcclxuICAgIFNtb290aFN0ZXA6IHJlcXVpcmUoJy4vU21vb3RoU3RlcCcpLFxyXG4gICAgV2l0aGluOiByZXF1aXJlKCcuL1dpdGhpbicpLFxyXG4gICAgV3JhcDogcmVxdWlyZSgnLi9XcmFwJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvaW5kZXguanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgU3lzdGVtcyA9IHJlcXVpcmUoJy4vU3lzdGVtcycpO1xyXG5cclxuLyoqXHJcbiogQSBCYXNlIFN0YXRlIENsYXNzLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5TdGF0ZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qL1xyXG52YXIgU3RhdGUgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICAvLyAgVGhlIFN0YXRlIFN5c3RlbXMuIFlvdSBtdXN0IG5ldmVyIG92ZXJ3cml0ZSB0aGlzIHByb3BlcnR5LCBvciBhbGwgaGVsbCB3aWxsIGJyZWFrIGxvc2UuXHJcbiAgICB0aGlzLnN5cyA9IG5ldyBTeXN0ZW1zKHRoaXMsIGNvbmZpZyk7XHJcblxyXG4gICAgdGhpcy5zZXR0aW5ncyA9IHRoaXMuc3lzLnNldHRpbmdzO1xyXG59O1xyXG5cclxuU3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhdGU7XHJcblxyXG5TdGF0ZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLy8gIFNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHlvdXIgb3duIFN0YXRlc1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU2hvdWxkIGJlIG92ZXJyaWRkZW4gYnkgeW91ciBvd24gU3RhdGVzXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvU3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL1N0YXRlLmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGUubDsgfVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZS5pOyB9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENvbnRleHQgPSBmdW5jdGlvbiAoY2FudmFzLCBvcHRpb25zKVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIG9wdGlvbnMpIHx8IFxyXG4gICAgICAgIG51bGxcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldENvbnRleHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NhbnZhcy9HZXRDb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnQnKTtcclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBEYXRhIENvbXBvbmVudCBmZWF0dXJlcyBhIG1lYW5zIHRvIHN0b3JlIHBpZWNlcyBvZiBkYXRhIHNwZWNpZmljIHRvIGEgR2FtZSBPYmplY3QsXHJcbiogc2VhcmNoIGl0LCBxdWVyeSBpdCwgYW5kIHJldHJpZXZlIGl0LlxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcbnZhciBEYXRhID0gZnVuY3Rpb24gKHBhcmVudClcclxue1xyXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XHJcblxyXG4gICAgdGhpcy5saXN0ID0ge307XHJcblxyXG4gICAgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzID0ge307XHJcbiAgICB0aGlzLl9hZnRlckNhbGxiYWNrcyA9IHt9O1xyXG5cclxuICAgIHRoaXMuX2Zyb3plbiA9IGZhbHNlO1xyXG59O1xyXG5cclxuRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhO1xyXG5cclxuRGF0YS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLy8gIFJldHJpZXZlcyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXksIG9yIHVuZGVmaW5lZCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0QWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXN1bHRzW2tleV0gPSB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfSxcclxuXHJcbiAgICBxdWVyeTogZnVuY3Rpb24gKHNlYXJjaClcclxuICAgIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGtleS5tYXRjaChzZWFyY2gpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKGtleSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5fZnJvemVuKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXI7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICAgICAgLy8gIElmIHRoZXJlIGlzIGEgJ2JlZm9yZScgY2FsbGJhY2ssIHRoZW4gY2hlY2sgaXQgZm9yIGEgcmVzdWx0XHJcbiAgICAgICAgaWYgKHRoaXMuX2JlZm9yZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIgPSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGxpc3RlbmVyLmNhbGxiYWNrLmNhbGwobGlzdGVuZXIuc2NvcGUsIHRoaXMucGFyZW50LCBrZXksIGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuTE9BREVSX1NUQVJUX0VWRU5UKHRoaXMpKTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0W2tleV0gPSBkYXRhO1xyXG5cclxuICAgICAgICAvLyAgSWYgdGhlcmUgaXMgYSAnYWZ0ZXInIGNhbGxiYWNrLCB0aGVuIGNoZWNrIGl0IGZvciBhIHJlc3VsdFxyXG4gICAgICAgIGlmICh0aGlzLl9hZnRlckNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIgPSB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIuY2FsbGJhY2suY2FsbChsaXN0ZW5lci5zY29wZSwgdGhpcy5wYXJlbnQsIGtleSwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdFtrZXldID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgYmVmb3JlOiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaywgc2NvcGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUmVtb3ZlIGVudHJ5XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzW2tleV0gPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgc2NvcGU6IHNjb3BlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZnRlcjogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2ssIHNjb3BlKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFJlbW92ZSBlbnRyeVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUgfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBQYXNzZXMgYWxsIGRhdGEgZW50cmllcyB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suIFN0b3JlcyB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjay5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBlYWNoXHJcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBbc2NvcGVdIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgICogQHBhcmFtIHsuLi4qfSBbYXJndW1lbnRzXSAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBhZnRlciB0aGUgZ2FtZSBvYmplY3QsIGtleSwgYW5kIGRhdGEuXHJcbiAgICAqL1xyXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYXJncyA9IFsgdGhpcy5wYXJlbnQsIG51bGwsIHVuZGVmaW5lZCBdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3NbMV0gPSBrZXk7XHJcbiAgICAgICAgICAgIGFyZ3NbMl0gPSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1lcmdlOiBmdW5jdGlvbiAoZGF0YSwgb3ZlcndyaXRlKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChvdmVyd3JpdGUgPT09IHVuZGVmaW5lZCkgeyBvdmVyd3JpdGUgPSB0cnVlOyB9XHJcblxyXG4gICAgICAgIC8vICBNZXJnZSBkYXRhIGZyb20gYW5vdGhlciBjb21wb25lbnQgaW50byB0aGlzIG9uZVxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZSB8fCAoIW92ZXJ3cml0ZSAmJiAhdGhpcy5oYXMoa2V5KSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdFtrZXldID0gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5fZnJvemVuICYmIHRoaXMuaGFzKGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyhrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLl9iZWZvcmVDYWxsYmFja3MuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9hZnRlckNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2FmdGVyQ2FsbGJhY2tzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgR2V0cyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuICdrZXknLCBkZWxldGVzIGl0IGZyb20gdGhpcyBEYXRhIHN0b3JlLCB0aGVuIHJldHVybnMgaXQuXHJcbiAgICBwb3A6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fZnJvemVuICYmIHRoaXMuaGFzKGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5saXN0W2tleV07XHJcblxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyhrZXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhczogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0Lmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGtleSBpbiB0aGlzLl9iZWZvcmVDYWxsYmFja3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzW2tleV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGtleSBpbiB0aGlzLl9hZnRlckNhbGxiYWNrcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZnJvemVuID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGF0YS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICogRnJlZXplIHRoaXMgRGF0YSBjb21wb25lbnQsIHNvIG5vIGNoYW5nZXMgY2FuIGJlIHdyaXR0ZW4gdG8gaXQuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIGZyZWV6ZVxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZyZWV6ZVxyXG4gICAgKi9cclxuICAgIGZyZWV6ZToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJvemVuO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fZnJvemVuID0gKHZhbHVlKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBjb3VudDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0W2tleV0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzL0RhdGEuanMiLCJ2YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XHJcblxyXG52YXIgQ2FudmFzRmVhdHVyZXMgPSB7XHJcblxyXG4gICAgc3VwcG9ydE5ld0JsZW5kTW9kZXM6IGZhbHNlLFxyXG5cclxuICAgIHN1cHBvcnRJbnZlcnNlQWxwaGE6IGZhbHNlXHJcblxyXG59O1xyXG5cclxuZnVuY3Rpb24gY2hlY2tCbGVuZE1vZGUgKClcclxue1xyXG4gICAgdmFyIHBuZ0hlYWQgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBUUFBQUFCQVFNQUFBREQ4cDJPQUFBQUExQk1WRVgvJztcclxuICAgIHZhciBwbmdFbmQgPSAnQUFBQUNrbEVRVlFJMTJOZ0FBQUFBZ0FCNGlHOE13QUFBQUJKUlU1RXJrSmdnZz09JztcclxuXHJcbiAgICB2YXIgbWFnZW50YSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgbWFnZW50YS5zcmMgPSBwbmdIZWFkICsgJ0FQODA0T2E2JyArIHBuZ0VuZDtcclxuXHJcbiAgICB2YXIgeWVsbG93ID0gbmV3IEltYWdlKCk7XHJcbiAgICB5ZWxsb3cuc3JjID0gcG5nSGVhZCArICcvd0NLeHZSRicgKyBwbmdFbmQ7XHJcblxyXG4gICAgdmFyIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKHRoaXMsIDYsIDEpO1xyXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZShtYWdlbnRhLCAwLCAwKTtcclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHllbGxvdywgMiwgMCk7XHJcblxyXG4gICAgaWYgKCFjb250ZXh0LmdldEltYWdlRGF0YSgyLCAwLCAxLCAxKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgyLCAwLCAxLCAxKS5kYXRhO1xyXG5cclxuICAgIENhbnZhc1Bvb2wucmVtb3ZlKHRoaXMpO1xyXG5cclxuICAgIHJldHVybiAoZGF0YVswXSA9PT0gMjU1ICYmIGRhdGFbMV0gPT09IDAgJiYgZGF0YVsyXSA9PT0gMCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrSW52ZXJzZUFscGhhICgpXHJcbntcclxuICAgIHZhciBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZSh0aGlzLCAyLCAxKTtcclxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgxMCwgMjAsIDMwLCAwLjUpJztcclxuXHJcbiAgICAvLyAgRHJhdyBhIHNpbmdsZSBwaXhlbFxyXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcclxuXHJcbiAgICAvLyAgR2V0IHRoZSBjb2xvciB2YWx1ZXNcclxuICAgIHZhciBzMSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xyXG5cclxuICAgIGlmIChzMSA9PT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFBsb3QgdGhlbSB0byB4MlxyXG4gICAgY29udGV4dC5wdXRJbWFnZURhdGEoczEsIDEsIDApO1xyXG5cclxuICAgIC8vICBHZXQgdGhvc2UgdmFsdWVzXHJcbiAgICB2YXIgczIgPSBjb250ZXh0LmdldEltYWdlRGF0YSgxLCAwLCAxLCAxKTtcclxuXHJcbiAgICAvLyAgQ29tcGFyZSBhbmQgcmV0dXJuXHJcbiAgICByZXR1cm4gKHMyLmRhdGFbMF0gPT09IHMxLmRhdGFbMF0gJiYgczIuZGF0YVsxXSA9PT0gczEuZGF0YVsxXSAmJiBzMi5kYXRhWzJdID09PSBzMS5kYXRhWzJdICYmIHMyLmRhdGFbM10gPT09IHMxLmRhdGFbM10pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIGlmIChkb2N1bWVudCAhPT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIENhbnZhc0ZlYXR1cmVzLnN1cHBvcnROZXdCbGVuZE1vZGVzID0gY2hlY2tCbGVuZE1vZGUoKTtcclxuICAgICAgICBDYW52YXNGZWF0dXJlcy5zdXBwb3J0SW52ZXJzZUFscGhhID0gY2hlY2tJbnZlcnNlQWxwaGEoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQ2FudmFzRmVhdHVyZXM7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvQ2FudmFzRmVhdHVyZXMuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9DYW52YXNGZWF0dXJlcy5qcyIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcclxudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcclxudmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzUG9vbCcpO1xyXG5cclxudmFyIEZlYXR1cmVzID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbnZhcyAtIElzIGNhbnZhcyBhdmFpbGFibGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY2FudmFzOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gY2FudmFzQml0Qmx0U2hpZnQgLSBUcnVlIGlmIGNhbnZhcyBzdXBwb3J0cyBhICdjb3B5JyBiaXRibHQgb250byBpdHNlbGYgd2hlbiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiByZWdpb25zIG92ZXJsYXAuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY2FudmFzQml0Qmx0U2hpZnQ6IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2ViR0wgLSBJcyB3ZWJHTCBhdmFpbGFibGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgd2ViR0w6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZpbGUgLSBJcyBmaWxlIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBmaWxlOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBmaWxlU3lzdGVtIC0gSXMgZmlsZVN5c3RlbSBhdmFpbGFibGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZmlsZVN5c3RlbTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbG9jYWxTdG9yYWdlIC0gSXMgbG9jYWxTdG9yYWdlIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBsb2NhbFN0b3JhZ2U6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdvcmtlciAtIElzIHdvcmtlciBhdmFpbGFibGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgd29ya2VyOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBwb2ludGVyTG9jayAtIElzIFBvaW50ZXIgTG9jayBhdmFpbGFibGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgcG9pbnRlckxvY2s6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpYnJhdGlvbiAtIERvZXMgdGhlIGRldmljZSBzdXBwb3J0IHRoZSBWaWJyYXRpb24gQVBJP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHZpYnJhdGlvbjogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZ2V0VXNlck1lZGlhIC0gRG9lcyB0aGUgZGV2aWNlIHN1cHBvcnQgdGhlIGdldFVzZXJNZWRpYSBBUEk/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZ2V0VXNlck1lZGlhOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiAtIElzIHRoZSBkZXZpY2UgYmlnIG9yIGxpdHRsZSBlbmRpYW4/IChvbmx5IGRldGVjdGVkIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFR5cGVkQXJyYXlzKVxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGxpdHRsZUVuZGlhbjogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3VwcG9ydDMyYml0IC0gRG9lcyB0aGUgZGV2aWNlIGNvbnRleHQgc3VwcG9ydCAzMmJpdCBwaXhlbCBtYW5pcHVsYXRpb24gdXNpbmcgYXJyYXkgYnVmZmVyIHZpZXdzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHN1cHBvcnQzMmJpdDogZmFsc2VcclxuXHJcbn07XHJcblxyXG4vKipcclxuKiBDaGVjayBMaXR0bGUgb3IgQmlnIEVuZGlhbiBzeXN0ZW0uXHJcbipcclxuKiBAYXV0aG9yIE1hdHQgRGVzTGF1cmllcnMgKEBtYXR0ZGVzbClcclxuKi9cclxuZnVuY3Rpb24gY2hlY2tJc0xpdHRsZUVuZGlhbiAoKVxyXG57XHJcbiAgICB2YXIgYSA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcclxuICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoYSk7XHJcbiAgICB2YXIgYyA9IG5ldyBVaW50MzJBcnJheShhKTtcclxuXHJcbiAgICBiWzBdID0gMHhhMTtcclxuICAgIGJbMV0gPSAweGIyO1xyXG4gICAgYlsyXSA9IDB4YzM7XHJcbiAgICBiWzNdID0gMHhkNDtcclxuXHJcbiAgICBpZiAoY1swXSA9PT0gMHhkNGMzYjJhMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY1swXSA9PT0gMHhhMWIyYzNkNClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIENvdWxkIG5vdCBkZXRlcm1pbmUgZW5kaWFubmVzc1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIEZlYXR1cmVzLmNhbnZhcyA9ICEhd2luZG93WydDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQnXSB8fCBPUy5jb2Nvb25KUztcclxuXHJcbiAgICB0cnlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5sb2NhbFN0b3JhZ2UgPSAhIWxvY2FsU3RvcmFnZS5nZXRJdGVtO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKVxyXG4gICAge1xyXG4gICAgICAgIEZlYXR1cmVzLmxvY2FsU3RvcmFnZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIEZlYXR1cmVzLmZpbGUgPSAhIXdpbmRvd1snRmlsZSddICYmICEhd2luZG93WydGaWxlUmVhZGVyJ10gJiYgISF3aW5kb3dbJ0ZpbGVMaXN0J10gJiYgISF3aW5kb3dbJ0Jsb2InXTtcclxuICAgIEZlYXR1cmVzLmZpbGVTeXN0ZW0gPSAhIXdpbmRvd1sncmVxdWVzdEZpbGVTeXN0ZW0nXTtcclxuXHJcbiAgICB2YXIgaXNVaW50OCA9IGZhbHNlO1xyXG5cclxuICAgIHZhciB0ZXN0V2ViR0wgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh3aW5kb3dbJ1dlYkdMUmVuZGVyaW5nQ29udGV4dCddKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHJ5XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZVdlYkdMKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChPUy5jb2Nvb25KUylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc2NyZWVuY2FudmFzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzMkQgPSBDYW52YXNQb29sLmNyZWF0ZTJEKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjdHgyRCA9IGNhbnZhczJELmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIENhbid0IGJlIGRvbmUgb24gYSB3ZWJnbCBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBjdHgyRC5jcmVhdGVJbWFnZURhdGEoMSwgMSk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgKiBUZXN0IHRvIHNlZSBpZiBJbWFnZURhdGEgdXNlcyBDYW52YXNQaXhlbEFycmF5IG9yIFVpbnQ4Q2xhbXBlZEFycmF5LlxyXG4gICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgKiBAYXV0aG9yIE1hdHQgRGVzTGF1cmllcnMgKEBtYXR0ZGVzbClcclxuICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpc1VpbnQ4ID0gaW1hZ2UuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgIENhbnZhc1Bvb2wucmVtb3ZlKGNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICBDYW52YXNQb29sLnJlbW92ZShjYW52YXMyRCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjdHggIT09IG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBGZWF0dXJlcy53ZWJHTCA9IHRydWU7Ly90ZXN0V2ViR0woKTtcclxuXHJcbiAgICBGZWF0dXJlcy53b3JrZXIgPSAhIXdpbmRvd1snV29ya2VyJ107XHJcblxyXG4gICAgRmVhdHVyZXMucG9pbnRlckxvY2sgPSAncG9pbnRlckxvY2tFbGVtZW50JyBpbiBkb2N1bWVudCB8fCAnbW96UG9pbnRlckxvY2tFbGVtZW50JyBpbiBkb2N1bWVudCB8fCAnd2Via2l0UG9pbnRlckxvY2tFbGVtZW50JyBpbiBkb2N1bWVudDtcclxuXHJcbiAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5vR2V0VXNlck1lZGlhO1xyXG5cclxuICAgIHdpbmRvdy5VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XHJcblxyXG4gICAgRmVhdHVyZXMuZ2V0VXNlck1lZGlhID0gRmVhdHVyZXMuZ2V0VXNlck1lZGlhICYmICEhbmF2aWdhdG9yLmdldFVzZXJNZWRpYSAmJiAhIXdpbmRvdy5VUkw7XHJcblxyXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgZmlyZWZveCAoPCAyMSkgYXBwYXJlbnRseSBjbGFpbSBzdXBwb3J0IGJ1dCB1c2VyIG1lZGlhIGRvZXMgbm90IGFjdHVhbGx5IHdvcmtcclxuICAgIGlmIChCcm93c2VyLmZpcmVmb3ggJiYgQnJvd3Nlci5maXJlZm94VmVyc2lvbiA8IDIxKVxyXG4gICAge1xyXG4gICAgICAgIEZlYXR1cmVzLmdldFVzZXJNZWRpYSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4Y2x1ZGVzIGlPUyB2ZXJzaW9ucyBhcyB0aGV5IGdlbmVyYWxseSB3cmFwIFVJV2ViVmlldyAoZWcuIFNhZmFyaSBXZWJLaXQpIGFuZCBpdFxyXG4gICAgLy8gaXMgc2FmZXIgdG8gbm90IHRyeSBhbmQgdXNlIHRoZSBmYXN0IGNvcHktb3ZlciBtZXRob2QuXHJcbiAgICBpZiAoIU9TLmlPUyAmJiAoQnJvd3Nlci5pZSB8fCBCcm93c2VyLmZpcmVmb3ggfHwgQnJvd3Nlci5jaHJvbWUpKVxyXG4gICAge1xyXG4gICAgICAgIEZlYXR1cmVzLmNhbnZhc0JpdEJsdFNoaWZ0ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBLbm93biBub3QgdG8gd29ya1xyXG4gICAgaWYgKEJyb3dzZXIuc2FmYXJpIHx8IEJyb3dzZXIubW9iaWxlU2FmYXJpKVxyXG4gICAge1xyXG4gICAgICAgIEZlYXR1cmVzLmNhbnZhc0JpdEJsdFNoaWZ0ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbmF2aWdhdG9yLnZpYnJhdGUgPSBuYXZpZ2F0b3IudmlicmF0ZSB8fCBuYXZpZ2F0b3Iud2Via2l0VmlicmF0ZSB8fCBuYXZpZ2F0b3IubW96VmlicmF0ZSB8fCBuYXZpZ2F0b3IubXNWaWJyYXRlO1xyXG5cclxuICAgIGlmIChuYXZpZ2F0b3IudmlicmF0ZSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy52aWJyYXRpb24gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKVxyXG4gICAge1xyXG4gICAgICAgIEZlYXR1cmVzLmxpdHRsZUVuZGlhbiA9IGNoZWNrSXNMaXR0bGVFbmRpYW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBGZWF0dXJlcy5zdXBwb3J0MzJiaXQgPSAoXHJcbiAgICAgICAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICBGZWF0dXJlcy5saXR0bGVFbmRpYW4gIT09IG51bGwgJiZcclxuICAgICAgICBpc1VpbnQ4XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBGZWF0dXJlcztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9GZWF0dXJlcy5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL0ZlYXR1cmVzLmpzIiwidmFyIEFkZFRvRE9NID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCwgb3ZlcmZsb3dIaWRkZW4pXHJcbntcclxuICAgIGlmIChvdmVyZmxvd0hpZGRlbiA9PT0gdW5kZWZpbmVkKSB7IG92ZXJmbG93SGlkZGVuID0gdHJ1ZTsgfVxyXG5cclxuICAgIHZhciB0YXJnZXQ7XHJcblxyXG4gICAgaWYgKHBhcmVudClcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHBhcmVudCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSG9wZWZ1bGx5IGFuIGVsZW1lbnQgSURcclxuICAgICAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmVudCA9PT0gJ29iamVjdCcgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFF1aWNrIHRlc3QgZm9yIGEgSFRNTGVsZW1lbnRcclxuICAgICAgICAgICAgdGFyZ2V0ID0gcGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAgRmFsbGJhY2ssIGNvdmVycyBhbiBpbnZhbGlkIElEIGFuZCBhIG5vbiBIVE1MZWxlbWVudCBvYmplY3RcclxuICAgIGlmICghdGFyZ2V0KVxyXG4gICAge1xyXG4gICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmJvZHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG92ZXJmbG93SGlkZGVuICYmIHRhcmdldC5zdHlsZSlcclxuICAgIHtcclxuICAgICAgICB0YXJnZXQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgIH1cclxuXHJcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZFRvRE9NO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kb20vQWRkVG9ET00uanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBPUyA9IHJlcXVpcmUoJy4uL2RldmljZS9PUycpO1xyXG5cclxudmFyIGlzQm9vdGVkID0gZmFsc2U7XHJcblxyXG52YXIgRE9NQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaylcclxue1xyXG4gICAgaWYgKGlzQm9vdGVkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKVxyXG4gICAge1xyXG4gICAgICAgIGlzQm9vdGVkID0gdHJ1ZTtcclxuICAgICAgICBcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNoZWNrID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpc0Jvb3RlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgY2hlY2ssIHRydWUpO1xyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjaGVjaywgdHJ1ZSk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBjaGVjaywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghZG9jdW1lbnQuYm9keSlcclxuICAgIHtcclxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjaGVjaywgMjApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoT1MuY29yZG92YSAmJiAhT1MuY29jb29uSlMpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFJlZi4gaHR0cDovL2RvY3MucGhvbmVnYXAuY29tL2VuLzMuNS4wL2NvcmRvdmFfZXZlbnRzX2V2ZW50cy5tZC5odG1sI2RldmljZXJlYWR5XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBjaGVjaywgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjaGVjaywgdHJ1ZSk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBjaGVjaywgdHJ1ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERPTUNvbnRlbnRMb2FkZWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9ET01Db250ZW50TG9hZGVkLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kb20vRE9NQ29udGVudExvYWRlZC5qcyIsInZhciBQYXJzZVhNTCA9IGZ1bmN0aW9uIChkYXRhKVxyXG57XHJcbiAgICB2YXIgeG1sID0gJyc7XHJcblxyXG4gICAgdHJ5XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHdpbmRvd1snRE9NUGFyc2VyJ10pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZG9tcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xyXG4gICAgICAgICAgICB4bWwgPSBkb21wYXJzZXIucGFyc2VGcm9tU3RyaW5nKGRhdGEsICd0ZXh0L3htbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4bWwgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xyXG4gICAgICAgICAgICB4bWwubG9hZFhNTChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSlcclxuICAgIHtcclxuICAgICAgICB4bWwgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgheG1sIHx8ICF4bWwuZG9jdW1lbnRFbGVtZW50IHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKS5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHhtbDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFyc2VYTUw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9QYXJzZVhNTC5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIE5PT1AgPSByZXF1aXJlKCcuLi91dGlscy9OT09QJyk7XHJcblxyXG4vKipcclxuKiBBYnN0cmFjdHMgYXdheSB0aGUgdXNlIG9mIFJBRiBvciBzZXRUaW1lT3V0IGZvciB0aGUgY29yZSBnYW1lIHVwZGF0ZSBsb29wLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZVNldFRpbWVPdXQ9ZmFsc2VdIC0gVGVsbCBQaGFzZXIgdG8gdXNlIHNldFRpbWVPdXQgZXZlbiBpZiByYWYgaXMgYXZhaWxhYmxlLlxyXG4qL1xyXG52YXIgUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNSdW5uaW5nIC0gdHJ1ZSBpZiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaXMgcnVubmluZywgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5jYWxsYmFjayA9IE5PT1A7XHJcblxyXG4gICAgdGhpcy50aWNrID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpc1NldFRpbWVPdXQgIC0gVHJ1ZSBpZiB0aGUgYnJvd3NlciBpcyB1c2luZyBzZXRUaW1lb3V0IGluc3RlYWQgb2YgckFmLlxyXG4gICAgKi9cclxuICAgIHRoaXMuaXNTZXRUaW1lT3V0ID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lT3V0SUQgLSBUaGUgY2FsbGJhY2sgc2V0VGltZW91dCBvciByQWYgY2FsbGJhY2sgSUQgdXNlZCB3aGVuIGNhbGxpbmcgY2FuY2VsLlxyXG4gICAgKi9cclxuICAgIHRoaXMudGltZU91dElEID0gbnVsbDtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIC8vICB0aW1lc3RhbXAgPSBET01IaWdoUmVzVGltZVN0YW1wXHJcbiAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICh0aW1lc3RhbXApXHJcbiAgICB7XHJcbiAgICAgICAgX3RoaXMudGljayA9IHRpbWVzdGFtcDtcclxuXHJcbiAgICAgICAgX3RoaXMudGltZU91dElEID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcclxuXHJcbiAgICAgICAgX3RoaXMuY2FsbGJhY2sodGltZXN0YW1wKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN0ZXBUaW1lb3V0ID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZCA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIF90aGlzLnRpY2sgPSBkO1xyXG5cclxuICAgICAgICBfdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cuc2V0VGltZW91dChzdGVwVGltZW91dCwgX3RoaXMudGltZVRvQ2FsbCk7XHJcblxyXG4gICAgICAgIF90aGlzLmNhbGxiYWNrKGQpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN0ZXAgPSBzdGVwO1xyXG4gICAgdGhpcy5zdGVwVGltZW91dCA9IHN0ZXBUaW1lb3V0O1xyXG59O1xyXG5cclxuUmVxdWVzdEFuaW1hdGlvbkZyYW1lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuXHJcblJlcXVlc3RBbmltYXRpb25GcmFtZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFN0YXJ0cyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHJ1bm5pbmcgb3Igc2V0VGltZW91dCBpZiB1bmF2YWlsYWJsZSBpbiBicm93c2VyXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZSNzdGFydFxyXG4gICAgKi9cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGZvcmNlU2V0VGltZU91dClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG4gICAgICAgIHRoaXMuaXNTZXRUaW1lT3V0ID0gZm9yY2VTZXRUaW1lT3V0O1xyXG5cclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XHJcblxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRoaXMudGltZU91dElEID0gKGZvcmNlU2V0VGltZU91dCkgPyB3aW5kb3cuc2V0VGltZW91dChfdGhpcy5zdGVwVGltZW91dCwgMCkgOiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnN0ZXApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogU3RvcHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tIHJ1bm5pbmcuXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZSNzdG9wXHJcbiAgICAqL1xyXG4gICAgc3RvcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc1NldFRpbWVPdXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lT3V0SUQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy50aW1lT3V0SUQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IE5PT1A7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RvbS9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ2YXIgRVZFTlRfQ09OU1QgPSB7XHJcblxyXG4gICAgRElTUEFUQ0hFUl9JRExFOiAwLFxyXG4gICAgRElTUEFUQ0hFUl9ESVNQQVRDSElORzogMSxcclxuICAgIERJU1BBVENIRVJfUkVNT1ZJTkc6IDIsXHJcbiAgICBESVNQQVRDSEVSX0RFU1RST1lFRDogMyxcclxuXHJcbiAgICBMSVNURU5FUl9QRU5ESU5HOiA0LFxyXG4gICAgTElTVEVORVJfQUNUSVZFOiA1LFxyXG4gICAgTElTVEVORVJfUkVNT1ZJTkc6IDZcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVWRU5UX0NPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ldmVudHMvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgR2V0Qml0bWFwVGV4dFNpemUgPSBmdW5jdGlvbiAoc3JjKVxyXG57XHJcbiAgICB2YXIgdGV4dCA9IHNyYy50ZXh0O1xyXG4gICAgdmFyIHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcclxuXHJcbiAgICB2YXIgYnggPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgdmFyIGJ5ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIHZhciBidyA9IDA7XHJcbiAgICB2YXIgYmggPSAwO1xyXG4gICAgXHJcbiAgICB2YXIgY2hhcnMgPSBzcmMuZm9udERhdGEuY2hhcnM7XHJcbiAgICB2YXIgbGluZUhlaWdodCA9IHNyYy5mb250RGF0YS5saW5lSGVpZ2h0O1xyXG5cclxuICAgIHZhciB4QWR2YW5jZSA9IDA7XHJcbiAgICB2YXIgeUFkdmFuY2UgPSAwO1xyXG5cclxuICAgIHZhciBpbmRleENvdW50ID0gMDtcclxuICAgIHZhciBjaGFyQ29kZSA9IDA7XHJcblxyXG4gICAgdmFyIGdseXBoID0gbnVsbDtcclxuICAgIHZhciBnbHlwaFcgPSAwO1xyXG4gICAgdmFyIGdseXBoSCA9IDA7XHJcblxyXG4gICAgdmFyIHggPSAwO1xyXG4gICAgdmFyIHkgPSAwO1xyXG5cclxuICAgIHZhciBsYXN0R2x5cGggPSBudWxsO1xyXG4gICAgdmFyIGxhc3RDaGFyQ29kZSA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRleHRMZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xyXG5cclxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IDEwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeEFkdmFuY2UgPSAwO1xyXG4gICAgICAgICAgICBpbmRleENvdW50ID0gMDtcclxuICAgICAgICAgICAgeUFkdmFuY2UgKz0gbGluZUhlaWdodDtcclxuICAgICAgICAgICAgbGFzdEdseXBoID0gbnVsbDtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbHlwaCA9IGNoYXJzW2NoYXJDb2RlXTtcclxuXHJcbiAgICAgICAgaWYgKCFnbHlwaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGhXID0gZ2x5cGgud2lkdGg7XHJcbiAgICAgICAgZ2x5cGhIID0gZ2x5cGguaGVpZ2h0O1xyXG5cclxuICAgICAgICB4ID0gaW5kZXhDb3VudCArIGdseXBoLnhPZmZzZXQgKyB4QWR2YW5jZTtcclxuICAgICAgICB5ID0gZ2x5cGgueU9mZnNldCArIHlBZHZhbmNlO1xyXG5cclxuICAgICAgICBpZiAobGFzdEdseXBoICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGtlcm5pbmdPZmZzZXQgPSBnbHlwaC5rZXJuaW5nW2xhc3RDaGFyQ29kZV07XHJcbiAgICAgICAgICAgIHggKz0gKGtlcm5pbmdPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBrZXJuaW5nT2Zmc2V0IDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChieCA+IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBieCA9IHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYnkgPiB5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYnkgPSB5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGd3ID0geCArIGdseXBoVyAtIGJ4O1xyXG4gICAgICAgIHZhciBnaCA9IHkgKyBnbHlwaEggLSBieTtcclxuXHJcbiAgICAgICAgaWYgKGJ3IDwgZ3cpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBidyA9IGd3O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoYmggPCBnaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJoID0gZ2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4QWR2YW5jZSArPSBnbHlwaC54QWR2YW5jZTtcclxuICAgICAgICBpbmRleENvdW50ICs9IDE7XHJcbiAgICAgICAgbGFzdEdseXBoID0gZ2x5cGg7XHJcbiAgICAgICAgbGFzdENoYXJDb2RlID0gY2hhckNvZGU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNjYWxlID0gKHNyYy5mb250U2l6ZSAvIHNyYy5mb250RGF0YS5zaXplKTtcclxuICAgIHZhciBzeCA9IHNjYWxlICogc3JjLnNjYWxlWDtcclxuICAgIHZhciBzeSA9IHNjYWxlICogc3JjLnNjYWxlWTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxvY2FsOiB7XHJcbiAgICAgICAgICAgIHg6IGJ4ICogc2NhbGUsXHJcbiAgICAgICAgICAgIHk6IGJ5ICogc2NhbGUsXHJcbiAgICAgICAgICAgIHdpZHRoOiBidyAqIHNjYWxlLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJoICogc2NhbGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdsb2JhbDoge1xyXG4gICAgICAgICAgICB4OiBzcmMueCArIChieCAqIHN4KSxcclxuICAgICAgICAgICAgeTogc3JjLnkgKyAoYnkgKiBzeSksXHJcbiAgICAgICAgICAgIHdpZHRoOiBidyAqIHN4LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJoICogc3lcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRCaXRtYXBUZXh0U2l6ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9HZXRCaXRtYXBUZXh0U2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cycpO1xyXG52YXIgUmVuZGVyID0gcmVxdWlyZSgnLi9EeW5hbWljQml0bWFwVGV4dFJlbmRlcicpO1xyXG52YXIgR2V0Qml0bWFwVGV4dFNpemUgPSByZXF1aXJlKCcuLi9HZXRCaXRtYXBUZXh0U2l6ZScpO1xyXG5cclxudmFyIER5bmFtaWNCaXRtYXBUZXh0ID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuT3JpZ2luLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcclxuICAgICAgICBDb21wb25lbnRzLlRleHR1cmUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIFJlbmRlclxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIER5bmFtaWNCaXRtYXBUZXh0IChzdGF0ZSwgeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkgeyB0ZXh0ID0gJyc7IH1cclxuICAgICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7IHNpemUgPSAzMjsgfVxyXG4gICAgICAgIGlmIChhbGlnbiA9PT0gdW5kZWZpbmVkKSB7IGFsaWduID0gJ2xlZnQnOyB9XHJcblxyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZm9udERhdGEgPSB0aGlzLnN0YXRlLnN5cy5jYWNoZS5iaXRtYXBGb250LmdldChmb250KTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuXHJcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IHNpemU7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGxheUNhbGxiYWNrO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRleHR1cmUoZm9udCk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RGlzcGxheUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5Q2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZvbnRTaXplOiBmdW5jdGlvbiAoc2l6ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gc2l6ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHQ6IGZ1bmN0aW9uICh0ZXh0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyB7XHJcbiAgICAvLyAgICAgbG9jYWw6IHtcclxuICAgIC8vICAgICAgICAgeCxcclxuICAgIC8vICAgICAgICAgeSxcclxuICAgIC8vICAgICAgICAgd2lkdGgsXHJcbiAgICAvLyAgICAgICAgIGhlaWdodFxyXG4gICAgLy8gICAgIH0sXHJcbiAgICAvLyAgICAgZ2xvYmFsOiB7XHJcbiAgICAvLyAgICAgICAgIHgsXHJcbiAgICAvLyAgICAgICAgIHksXHJcbiAgICAvLyAgICAgICAgIHdpZHRoLFxyXG4gICAgLy8gICAgICAgICBoZWlnaHRcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgZ2V0VGV4dEJvdW5kczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgbG9jYWwgPSB0aGUgQml0bWFwVGV4dCBiYXNlZCBvbiBmb250U2l6ZSBhbmQgMHgwIGNvb3Jkc1xyXG4gICAgICAgIC8vICBnbG9iYWwgPSB0aGUgQml0bWFwVGV4dCwgdGFraW5nIGludG8gYWNjb3VudCBzY2FsZSBhbmQgd29ybGQgcG9zaXRpb25cclxuXHJcbiAgICAgICAgcmV0dXJuIEdldEJpdG1hcFRleHRTaXplKHRoaXMpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IER5bmFtaWNCaXRtYXBUZXh0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dC5qcyIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIFJlbmRlciA9IHJlcXVpcmUoJy4vQml0bWFwVGV4dFJlbmRlcicpO1xyXG52YXIgR2V0Qml0bWFwVGV4dFNpemUgPSByZXF1aXJlKCcuLi9HZXRCaXRtYXBUZXh0U2l6ZScpO1xyXG5cclxudmFyIEJpdG1hcFRleHQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIE1peGluczogW1xyXG4gICAgICAgIENvbXBvbmVudHMuQWxwaGEsXHJcbiAgICAgICAgQ29tcG9uZW50cy5CbGVuZE1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXHJcbiAgICAgICAgQ29tcG9uZW50cy5TaXplLFxyXG4gICAgICAgIENvbXBvbmVudHMuVGV4dHVyZSxcclxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcclxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXHJcbiAgICAgICAgUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQml0bWFwVGV4dCAoc3RhdGUsIHgsIHksIGZvbnQsIHRleHQsIHNpemUsIGFsaWduKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHsgdGV4dCA9ICcnOyB9XHJcbiAgICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkgeyBzaXplID0gMzI7IH1cclxuICAgICAgICBpZiAoYWxpZ24gPT09IHVuZGVmaW5lZCkgeyBhbGlnbiA9ICdsZWZ0JzsgfVxyXG5cclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUpO1xyXG5cclxuICAgICAgICB0aGlzLmZvbnREYXRhID0gdGhpcy5zdGF0ZS5zeXMuY2FjaGUuYml0bWFwRm9udC5nZXQoZm9udCk7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcblxyXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBzaXplO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRleHR1cmUoZm9udCk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Rm9udFNpemU6IGZ1bmN0aW9uIChzaXplKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBzaXplO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dDogZnVuY3Rpb24gKHRleHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHtcclxuICAgIC8vICAgICBsb2NhbDoge1xyXG4gICAgLy8gICAgICAgICB4LFxyXG4gICAgLy8gICAgICAgICB5LFxyXG4gICAgLy8gICAgICAgICB3aWR0aCxcclxuICAgIC8vICAgICAgICAgaGVpZ2h0XHJcbiAgICAvLyAgICAgfSxcclxuICAgIC8vICAgICBnbG9iYWw6IHtcclxuICAgIC8vICAgICAgICAgeCxcclxuICAgIC8vICAgICAgICAgeSxcclxuICAgIC8vICAgICAgICAgd2lkdGgsXHJcbiAgICAvLyAgICAgICAgIGhlaWdodFxyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxuXHJcbiAgICBnZXRUZXh0Qm91bmRzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBsb2NhbCA9IHRoZSBCaXRtYXBUZXh0IGJhc2VkIG9uIGZvbnRTaXplIGFuZCAweDAgY29vcmRzXHJcbiAgICAgICAgLy8gIGdsb2JhbCA9IHRoZSBCaXRtYXBUZXh0LCB0YWtpbmcgaW50byBhY2NvdW50IHNjYWxlIGFuZCB3b3JsZCBwb3NpdGlvblxyXG5cclxuICAgICAgICByZXR1cm4gR2V0Qml0bWFwVGV4dFNpemUodGhpcyk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQml0bWFwVGV4dDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dC5qcyIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzJyk7XHJcbnZhciBCbGl0dGVyUmVuZGVyID0gcmVxdWlyZSgnLi9CbGl0dGVyUmVuZGVyJyk7XHJcbnZhciBCb2IgPSByZXF1aXJlKCcuL0JvYicpO1xyXG5cclxuLyoqXHJcbiogQSBCbGl0dGVyIEdhbWUgT2JqZWN0LlxyXG4qXHJcbiogVGhlIEJsaXR0ZXIgR2FtZSBPYmplY3QgaXMgYSBzcGVjaWFsIHR5cGUgb2YgQ29udGFpbmVyLCB0aGF0IGNvbnRhaW5zIEJsaXR0ZXIuQm9iIG9iamVjdHMuXHJcbiogVGhlc2Ugb2JqZWN0cyBjYW4gYmUgdGhvdWdodCBvZiBhcyBqdXN0IHRleHR1cmUgZnJhbWVzIHdpdGggYSBwb3NpdGlvbiBhbmQgbm90aGluZyBtb3JlLlxyXG4qIEJvYnMgZG9uJ3QgaGF2ZSBhbnkgdXBkYXRlIG1ldGhvZHMsIG9yIHRoZSBhYmlsaXR5IHRvIGhhdmUgY2hpbGRyZW4sIG9yIGFueSBraW5kIG9mIHNwZWNpYWwgZWZmZWN0cy5cclxuKiBUaGV5IGFyZSBlc3NlbnRpYWxseSBqdXN0IHN1cGVyLWZhc3QgdGV4dHVyZSBmcmFtZSByZW5kZXJlcnMsIGFuZCB0aGUgQmxpdHRlciBvYmplY3QgY3JlYXRlcyBhbmQgbWFuYWdlcyB0aGVtLlxyXG4qXHJcbiogQGNsYXNzIEJsaXR0ZXJcclxuKiBAZXh0ZW5kcyBQaGFzZXIuR2FtZU9iamVjdFxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBJbWFnZS4gVGhlIGNvb3JkaW5hdGUgaXMgcmVsYXRpdmUgdG8gYW55IHBhcmVudCBjb250YWluZXIgdGhpcyBJbWFnZSBtYXkgYmUgaW4uXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgSW1hZ2UuIFRoZSBjb29yZGluYXRlIGlzIHJlbGF0aXZlIHRvIGFueSBwYXJlbnQgY29udGFpbmVyIHRoaXMgSW1hZ2UgbWF5IGJlIGluLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBba2V5XSAtIFRoZSB0ZXh0dXJlIHVzZWQgYnkgdGhlIEltYWdlIGR1cmluZyByZW5kZXJpbmcuIEl0IGNhbiBiZSBhIHN0cmluZyB3aGljaCBpcyBhIHJlZmVyZW5jZSB0byB0aGUgQ2FjaGUgZW50cnksIG9yIGFuIGluc3RhbmNlIG9mIGEgUmVuZGVyVGV4dHVyZSwgQml0bWFwRGF0YSBvciBQSVhJLlRleHR1cmUuXHJcbiogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbZnJhbWVdIC0gSWYgdGhpcyBJbWFnZSBpcyB1c2luZyBwYXJ0IG9mIGEgc3ByaXRlIHNoZWV0IG9yIHRleHR1cmUgYXRsYXMgeW91IGNhbiBzcGVjaWZ5IHRoZSBleGFjdCBmcmFtZSB0byB1c2UgYnkgZ2l2aW5nIGEgc3RyaW5nIG9yIG51bWVyaWMgaW5kZXguXHJcbiovXHJcblxyXG52YXIgQmxpdHRlciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBCbGl0dGVyUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQmxpdHRlciAoc3RhdGUsIHgsIHksIHRleHR1cmUsIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZSh0ZXh0dXJlLCBmcmFtZSk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBDb21wb25lbnRzLkNoaWxkcmVuKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLnJlbmRlckxpc3QgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgZnJhbWUgTVVTVCBiZSBwYXJ0IG9mIHRoZSBCbGl0dGVyIHRleHR1cmVcclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKHgsIHksIGZyYW1lLCB2aXNpYmxlLCBpbmRleClcclxuICAgIHtcclxuICAgICAgICBpZiAoZnJhbWUgPT09IHVuZGVmaW5lZCkgeyBmcmFtZSA9IHRoaXMuZnJhbWU7IH1cclxuICAgICAgICBpZiAodmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB7IHZpc2libGUgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZyYW1lID09PSAnc3RyaW5nJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZyYW1lID0gdGhpcy50ZXh0dXJlLmdldChmcmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYm9iID0gbmV3IEJvYih0aGlzLCB4LCB5LCBmcmFtZSwgdmlzaWJsZSk7XHJcblxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uYWRkQXQoYm9iLCBpbmRleCwgZmFsc2UpO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJvYjtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIGZyYW1lIE1VU1QgYmUgcGFydCBvZiB0aGUgQmxpdHRlciB0ZXh0dXJlXHJcbiAgICBjcmVhdGVGcm9tQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgcXVhbnRpdHksIGZyYW1lLCB2aXNpYmxlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBib2JzID0gdGhpcy5jcmVhdGVNdWx0aXBsZShxdWFudGl0eSwgZnJhbWUsIHZpc2libGUpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvYnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYm9iID0gYm9ic1tpXTtcclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgYm9iLCBpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBib2JzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgZnJhbWUgTVVTVCBiZSBwYXJ0IG9mIHRoZSBCbGl0dGVyIHRleHR1cmVcclxuICAgIGNyZWF0ZU11bHRpcGxlOiBmdW5jdGlvbiAocXVhbnRpdHksIGZyYW1lLCB2aXNpYmxlKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChmcmFtZSA9PT0gdW5kZWZpbmVkKSB7IGZyYW1lID0gdGhpcy5mcmFtZTsgfVxyXG4gICAgICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHsgdmlzaWJsZSA9IHRydWU7IH1cclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyYW1lKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZyYW1lID0gWyBmcmFtZSBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJvYnMgPSBbXTtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICBmcmFtZS5mb3JFYWNoKGZ1bmN0aW9uIChzaW5nbGVGcmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVhbnRpdHk7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYm9icy5wdXNoKF90aGlzLmNyZWF0ZSgwLCAwLCBzaW5nbGVGcmFtZSwgdmlzaWJsZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBib2JzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjaGlsZENhblJlbmRlcjogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoY2hpbGQudmlzaWJsZSAmJiBjaGlsZC5hbHBoYSA+IDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSZW5kZXJMaXN0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJMaXN0ID0gdGhpcy5jaGlsZHJlbi5saXN0LmZpbHRlcih0aGlzLmNoaWxkQ2FuUmVuZGVyLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyTGlzdDtcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5yZW1vdmVBbGwoKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCbGl0dGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlci5qcyIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzJyk7XHJcbnZhciBDb250YWluZXJSZW5kZXIgPSByZXF1aXJlKCcuL0NvbnRhaW5lclJlbmRlcicpO1xyXG5cclxudmFyIENvbnRhaW5lciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIENvbnRhaW5lclJlbmRlclxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIENvbnRhaW5lciAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHN0YXRlKTtcclxuXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBDb21wb25lbnRzLkNoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5lcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qcyIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIFJlbmRlciA9IHJlcXVpcmUoJy4vR3JhcGhpY3NSZW5kZXInKTtcclxudmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi9Db21tYW5kcycpO1xyXG52YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcclxuXHJcbnZhciBHcmFwaGljcyA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcclxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXHJcbiAgICAgICAgUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR3JhcGhpY3MgKHN0YXRlLCB4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcblxyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlciA9IFtdO1xyXG4gICAgfSxcclxuXHJcbiAgICBhcmM6IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5BUkMsXHJcbiAgICAgICAgICAgIHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2VcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBsaW5lU3R5bGU6IGZ1bmN0aW9uIChsaW5lV2lkdGgsIGNvbG9yLCBhbHBoYSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuTElORV9TVFlMRSxcclxuICAgICAgICAgICAgbGluZVdpZHRoLCBjb2xvciwgYWxwaGFcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaWxsU3R5bGU6IGZ1bmN0aW9uIChjb2xvciwgYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHsgYWxwaGEgPSAxOyB9XHJcblxyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5GSUxMX1NUWUxFLFxyXG4gICAgICAgICAgICBjb2xvciwgYWxwaGFcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBiZWdpblBhdGg6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLkJFR0lOX1BBVEhcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLkNMT1NFX1BBVEhcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaWxsUGF0aDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9QQVRIXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3Ryb2tlUGF0aDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuU1RST0tFX1BBVEhcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaWxsQ2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNQVRIX0NPTlNULlBJMik7XHJcbiAgICAgICAgdGhpcy5maWxsUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbGxSZWN0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9SRUNULFxyXG4gICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmlsbFRyaWFuZ2xlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9UUklBTkdMRSxcclxuICAgICAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MlxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0cm9rZUNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHJhZGl1cylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuYXJjKHgsIHksIHJhZGl1cywgMCwgTUFUSF9DT05TVC5QSTIpO1xyXG4gICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5zdHJva2VQYXRoKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0cm9rZVJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5saW5lVG8oeCArIHdpZHRoLCB5KTtcclxuICAgICAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMubGluZVRvKHgsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMubGluZVRvKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0cm9rZVRyaWFuZ2xlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuU1RST0tFX1RSSUFOR0xFLFxyXG4gICAgICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgbGluZVRvOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuTElORV9UTyxcclxuICAgICAgICAgICAgeCwgeVxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLk1PVkVfVE8sXHJcbiAgICAgICAgICAgIHgsIHlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaGljcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3MuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzLmpzIiwiXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIEltYWdlUmVuZGVyID0gcmVxdWlyZSgnLi9JbWFnZVJlbmRlcicpO1xyXG5cclxudmFyIEltYWdlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuR2V0Qm91bmRzLFxyXG4gICAgICAgIENvbXBvbmVudHMuT3JpZ2luLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2NhbGVNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcclxuICAgICAgICBDb21wb25lbnRzLlRleHR1cmUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIEltYWdlUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gSW1hZ2UgKHN0YXRlLCB4LCB5LCB0ZXh0dXJlLCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRleHR1cmUodGV4dHVyZSwgZnJhbWUpO1xyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5zZXRTaXplVG9GcmFtZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0T3JpZ2luVG9DZW50ZXIoKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlLmpzIiwiXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIFNwcml0ZVJlbmRlciA9IHJlcXVpcmUoJy4vU3ByaXRlUmVuZGVyJyk7XHJcblxyXG52YXIgU3ByaXRlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuR2V0Qm91bmRzLFxyXG4gICAgICAgIENvbXBvbmVudHMuT3JpZ2luLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2NhbGVNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcclxuICAgICAgICBDb21wb25lbnRzLlRleHR1cmUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIFNwcml0ZVJlbmRlclxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFNwcml0ZSAoc3RhdGUsIHgsIHksIHRleHR1cmUsIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZSh0ZXh0dXJlLCBmcmFtZSk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgICAgICB0aGlzLnNldFNpemVUb0ZyYW1lKCk7XHJcbiAgICAgICAgdGhpcy5zZXRPcmlnaW5Ub0NlbnRlcigpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZS5qcyIsInZhciBDaXJjbGUgPSBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxyXG57XHJcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSAwOyB9XHJcbiAgICBpZiAocmFkaXVzID09PSB1bmRlZmluZWQpIHsgcmFkaXVzID0gMDsgfVxyXG5cclxuICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgdGhpcy55ID0geTtcclxuXHJcbiAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XHJcbiAgICB0aGlzLl9kaWFtZXRlciA9IHJhZGl1cyAqIDI7XHJcbn07XHJcblxyXG5DaXJjbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlO1xyXG5cclxuQ2lyY2xlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHksIHJhZGl1cylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xyXG4gICAgICAgIHRoaXMuX2RpYW1ldGVyID0gcmFkaXVzICogMjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEVtcHR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldFRvKDAsIDAsIDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fcmFkaXVzIDw9IDApO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENpcmNsZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICByYWRpdXM6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9kaWFtZXRlciA9IHZhbHVlICogMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkaWFtZXRlcjoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlhbWV0ZXI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9kaWFtZXRlciA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9yYWRpdXMgPSB2YWx1ZSAqIDAuNTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBsZWZ0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggLSB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZSArIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByaWdodDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWUgLSB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9wOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgLSB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZSArIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b206IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlIC0gdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFbGxpcHNlID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbntcclxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cclxuICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7IHdpZHRoID0gMDsgfVxyXG4gICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IDA7IH1cclxuXHJcbiAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG59O1xyXG5cclxuRWxsaXBzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbGxpcHNlO1xyXG5cclxuRWxsaXBzZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc2V0VG86IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRFbXB0eTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRUbygwLCAwLCAwLCAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IHdpZHRoOyB9XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBBS0EgU2VtaSBNaW5vciBBeGlzXHJcbiAgICBnZXRNaW5vclJhZGl1czogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpIC8gMjtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEFLQSBTZW1pIE1ham9yIEF4aXNcclxuICAgIGdldE1ham9yUmFkaXVzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVsbGlwc2UucHJvdG90eXBlLCB7XHJcblxyXG4gICAgbGVmdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMucmlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy54KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB2YWx1ZSAtIHRoaXMueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMuYm90dG9tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gKHRoaXMuYm90dG9tIC0gdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLnkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdmFsdWUgLSB0aGlzLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVsbGlwc2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9FbGxpcHNlLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UG9pbnQgPSByZXF1aXJlKCcuL0dldFBvaW50Jyk7XHJcblxyXG4vKipcclxuKiBDYWxjdWxhdGUgYW5kIHJldHVybiB0aGUgYW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSBjdXJ2ZXMgdGFuZ2VudCBiYXNlZCBvbiB0aW1lLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRBbmdsZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbdD0wXSAtIFRoZSBgdGAgKHRpbWUpIHZhbHVlIGF0IHdoaWNoIHRvIGZpbmQgdGhlIGFuZ2xlLiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB0aGUgbGluZSBhdCB0aGUgc3BlY2lmaWVkIGB0YCB0aW1lIHZhbHVlIGFsb25nIHRoZSBjdXJ2ZS4gVGhlIHZhbHVlIGlzIGluIHJhZGlhbnMuXHJcbiovXHJcbnZhciBHZXRBbmdsZSA9IGZ1bmN0aW9uIChjdXJ2ZSwgdClcclxue1xyXG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgeyB0ID0gMDsgfVxyXG5cclxuICAgIEdldFBvaW50KGN1cnZlLCB0IC0gMC4wMSwgY3VydmUuX3RlbXAxKTtcclxuICAgIEdldFBvaW50KGN1cnZlLCB0ICsgMC4wMSwgY3VydmUuX3RlbXAyKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMihjdXJ2ZS5fdGVtcDIueSAtIGN1cnZlLl90ZW1wMS55LCBjdXJ2ZS5fdGVtcDIueCAtIGN1cnZlLl90ZW1wMS54KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0QW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRBbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL0dldEFuZ2xlLmpzIiwidmFyIFBvaW50VG9MaW5lID0gZnVuY3Rpb24gKHBvaW50LCBsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gKChwb2ludC54IC0gbGluZS54MSkgKiAobGluZS55MiAtIGxpbmUueTEpID09PSAobGluZS54MiAtIGxpbmUueDEpICogKHBvaW50LnkgLSBsaW5lLnkxKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50VG9MaW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGVUb1JlY3RhbmdsZSA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIpXHJcbntcclxuICAgIGlmIChyZWN0QS53aWR0aCA8PSAwIHx8IHJlY3RBLmhlaWdodCA8PSAwIHx8IHJlY3RCLndpZHRoIDw9IDAgfHwgcmVjdEIuaGVpZ2h0IDw9IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAhKHJlY3RBLnJpZ2h0IDwgcmVjdEIueCB8fCByZWN0QS5ib3R0b20gPCByZWN0Qi55IHx8IHJlY3RBLnggPiByZWN0Qi5yaWdodCB8fCByZWN0QS55ID4gcmVjdEIuYm90dG9tKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlVG9SZWN0YW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBEZWZpbmVzIGEgTGluZSBzZWdtZW50LCBhIHBhcnQgb2YgYSBsaW5lIGJldHdlZW4gdHdvIGVuZHBvaW50c1xyXG5cclxudmFyIExpbmUgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbntcclxuICAgIGlmICh4MSA9PT0gdW5kZWZpbmVkKSB7IHgxID0gMDsgfVxyXG4gICAgaWYgKHkxID09PSB1bmRlZmluZWQpIHsgeTEgPSAwOyB9XHJcbiAgICBpZiAoeDIgPT09IHVuZGVmaW5lZCkgeyB4MiA9IDA7IH1cclxuICAgIGlmICh5MiA9PT0gdW5kZWZpbmVkKSB7IHkyID0gMDsgfVxyXG5cclxuICAgIHRoaXMueDEgPSB4MTtcclxuXHJcbiAgICB0aGlzLnkxID0geTE7XHJcblxyXG4gICAgdGhpcy54MiA9IHgyO1xyXG5cclxuICAgIHRoaXMueTIgPSB5MjtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZTtcclxuXHJcbkxpbmUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldFRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHgxID09PSB1bmRlZmluZWQpIHsgeDEgPSAwOyB9XHJcbiAgICAgICAgaWYgKHkxID09PSB1bmRlZmluZWQpIHsgeTEgPSAwOyB9XHJcbiAgICAgICAgaWYgKHgyID09PSB1bmRlZmluZWQpIHsgeDIgPSAwOyB9XHJcbiAgICAgICAgaWYgKHkyID09PSB1bmRlZmluZWQpIHsgeTIgPSAwOyB9XHJcblxyXG4gICAgICAgIHRoaXMueDEgPSB4MTtcclxuICAgICAgICB0aGlzLnkxID0geTE7XHJcblxyXG4gICAgICAgIHRoaXMueDIgPSB4MjtcclxuICAgICAgICB0aGlzLnkyID0geTI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKExpbmUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgbGVmdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy54MSwgdGhpcy54Mik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy54MSA8PSB0aGlzLngyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLngyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByaWdodDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy54MSwgdGhpcy54Mik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy54MSA+IHRoaXMueDIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueDEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueDIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy55MSwgdGhpcy55Mik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy55MSA8PSB0aGlzLnkyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b206IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMueTEsIHRoaXMueTIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueTEgPiB0aGlzLnkyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBXcmFwID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9XcmFwJyk7XHJcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxuXHJcbnZhciBOb3JtYWxBbmdsZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICB2YXIgYW5nbGUgPSBBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVO1xyXG5cclxuICAgIHJldHVybiBXcmFwKGFuZ2xlLCAtTWF0aC5QSSwgTWF0aC5QSSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbEFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanMiLCJ2YXIgR2V0TWFnbml0dWRlID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChwb2ludC54ICogcG9pbnQueCkgKyAocG9pbnQueSAqIHBvaW50LnkpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0TWFnbml0dWRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0dldE1hZ25pdHVkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRNYWduaXR1ZGVTcSA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIChwb2ludC54ICogcG9pbnQueCkgKyAocG9pbnQueSAqIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRNYWduaXR1ZGVTcTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9HZXRNYWduaXR1ZGVTcS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNdWx0aXBseSA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcclxue1xyXG4gICAgcG9pbnQueCAqPSB4O1xyXG4gICAgcG9pbnQueSAqPSB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTXVsdGlwbHk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvTXVsdGlwbHkuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TWFnbml0dWRlID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGUnKTtcclxuXHJcbnZhciBOb3JtYWxpemUgPSBmdW5jdGlvbiAocG9pbnQpXHJcbntcclxuICAgIGlmIChwb2ludC54ICE9PSAwICYmIHBvaW50LnkgIT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG0gPSBHZXRNYWduaXR1ZGUocG9pbnQpO1xyXG5cclxuICAgICAgICBwb2ludC54IC89IG07XHJcbiAgICAgICAgcG9pbnQueSAvPSBtO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsaXplO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L05vcm1hbGl6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvTm9ybWFsaXplLmpzIiwiLyoqXHJcbiogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuUG9seWdvbiNjb250YWluc1xyXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdG8gdGVzdC5cclxuKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHBvbHlnb24sIG90aGVyd2lzZSBmYWxzZS5cclxuKi9cclxudmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKHBvbHlnb24sIHgsIHkpXHJcbntcclxuICAgIC8vICBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbCBieSBKb25hcyBSYW9uaSBTb2FyZXMgU2lsdmFcclxuXHJcbiAgICB2YXIgaW5zaWRlID0gZmFsc2U7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IC0xLCBqID0gcG9seWdvbi5wb2ludHMubGVuZ3RoIC0gMTsgKytpIDwgcG9seWdvbi5wb2ludHMubGVuZ3RoOyBqID0gaSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaXggPSBwb2x5Z29uLnBvaW50c1tpXS54O1xyXG4gICAgICAgIHZhciBpeSA9IHBvbHlnb24ucG9pbnRzW2ldLnk7XHJcblxyXG4gICAgICAgIHZhciBqeCA9IHBvbHlnb24ucG9pbnRzW2pdLng7XHJcbiAgICAgICAgdmFyIGp5ID0gcG9seWdvbi5wb2ludHNbal0ueTtcclxuXHJcbiAgICAgICAgaWYgKCgoaXkgPD0geSAmJiB5IDwgankpIHx8IChqeSA8PSB5ICYmIHkgPCBpeSkpICYmICh4IDwgKGp4IC0gaXgpICogKHkgLSBpeSkgLyAoankgLSBpeSkgKyBpeCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5zaWRlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWlucztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzKVxyXG57XHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFyZWEgLSBUaGUgYXJlYSBvZiB0aGlzIFBvbHlnb24uXHJcbiAgICAqL1xyXG4gICAgdGhpcy5hcmVhID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHthcnJheX0gcG9pbnRzIC0gQW4gYXJyYXkgb2YgbnVtYmVyIHBhaXIgb2JqZWN0cyB0aGF0IG1ha2UgdXAgdGhpcyBwb2x5Z29uLiBJLmUuIFsge3gseX0sIHt4LHl9LCB7eCx5fSBdXHJcbiAgICAqL1xyXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcclxuXHJcbiAgICBpZiAocG9pbnRzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0VG8ocG9pbnRzKTtcclxuICAgIH1cclxufTtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWdvbjtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGlzIFBvbHlnb24gdG8gdGhlIGdpdmVuIHBvaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcG9pbnRzIGNhbiBiZSBzZXQgZnJvbSBhIHZhcmlldHkgb2YgZm9ybWF0czpcclxuICAgICAqXHJcbiAgICAgKiAtIEFuIGFycmF5IG9mIFBvaW50IG9iamVjdHM6IGBbbmV3IFBoYXNlci5Qb2ludCh4MSwgeTEpLCAuLi5dYFxyXG4gICAgICogLSBBbiBhcnJheSBvZiBvYmplY3RzIHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzOiBgW29iajEsIG9iajIsIC4uLl1gXHJcbiAgICAgKiAtIEFuIGFycmF5IG9mIHBhaXJlZCBudW1iZXJzIHRoYXQgcmVwcmVzZW50IHBvaW50IGNvb3JkaW5hdGVzOiBgW3gxLHkxLCB4Mix5MiwgLi4uXWBcclxuICAgICAqIC0gQW4gYXJyYXkgb2YgYXJyYXlzIHdpdGggdHdvIGVsZW1lbnRzIHJlcHJlc2VudGluZyB4L3kgY29vcmRpbmF0ZXM6IGBbW3gxLCB5MV0sIFt4MiwgeTJdLCAuLi5dYFxyXG4gICAgICpcclxuICAgICAqIGBzZXRUb2AgbWF5IGFsc28gYmUgY2FsbGVkIHdpdGhvdXQgYW55IGFyZ3VtZW50cyB0byByZW1vdmUgYWxsIHBvaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIFBoYXNlci5Qb2x5Z29uI3NldFRvXHJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5Qb2ludFtdfG51bWJlcltdfC4uLlBoYXNlci5Qb2ludHwuLi5udW1iZXJ9IHBvaW50cyAtIFRoZSBwb2ludHMgdG8gc2V0LlxyXG4gICAgICogQHJldHVybiB7UGhhc2VyLlBvbHlnb259IFRoaXMgUG9seWdvbiBvYmplY3RcclxuICAgICAqL1xyXG4gICAgc2V0VG86IGZ1bmN0aW9uIChwb2ludHMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hcmVhID0gMDtcclxuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGVudHJ5O1xyXG4gICAgICAgIHZhciB5MCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdmFyIHA7XHJcblxyXG4gICAgICAgIC8vICBUaGUgcG9pbnRzIGFyZ3VtZW50IGlzIGFuIGFycmF5LCBzbyBpdGVyYXRlIHRocm91Z2ggaXRcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHAgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRzW2ldID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcC54ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIEFuIGFycmF5IG9mIGFycmF5cz9cclxuICAgICAgICAgICAgICAgIHAueCA9IHBvaW50c1tpXVswXTtcclxuICAgICAgICAgICAgICAgIHAueSA9IHBvaW50c1tpXVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHAueCA9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2ldLnk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2gocCk7XHJcblxyXG4gICAgICAgICAgICAvLyAgTG93ZXN0IGJvdW5kYXJ5XHJcbiAgICAgICAgICAgIGlmIChwLnkgPCB5MClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgeTAgPSBwLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQXJlYSh5MCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFyZWEgb2YgdGhlIFBvbHlnb24uIFRoaXMgaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9wZXJ0eSBQb2x5Z29uLmFyZWFcclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIFBoYXNlci5Qb2x5Z29uI2NhbGN1bGF0ZUFyZWFcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTAgLSBUaGUgbG93ZXN0IGJvdW5kYXJ5XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhcmVhIG9mIHRoZSBQb2x5Z29uLlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVBcmVhOiBmdW5jdGlvbiAoeTApXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA8IDMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFyZWEgPSAwO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJlYTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgIHZhciBwMTtcclxuICAgICAgICB2YXIgcDI7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoIC0gMTsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcDEgPSB0aGlzLnBvaW50c1tpXTtcclxuICAgICAgICAgICAgcDIgPSB0aGlzLnBvaW50c1tpICsgMV07XHJcblxyXG4gICAgICAgICAgICBzdW0gKz0gKHAyLnggLSBwMS54KSAqIChwMS55ICsgcDIueSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwMSA9IHRoaXMucG9pbnRzWzBdO1xyXG4gICAgICAgIHAyID0gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAgIHN1bSArPSAocDEueCAtIHAyLngpICogKHAyLnkgKyBwMS55KTtcclxuXHJcbiAgICAgICAgdGhpcy5hcmVhID0gLXN1bSAqIDAuNTtcclxuXHJcbiAgICAgICAgLy8gdmFyIHAxO1xyXG4gICAgICAgIC8vIHZhciBwMjtcclxuICAgICAgICAvLyB2YXIgYXZnSGVpZ2h0O1xyXG4gICAgICAgIC8vIHZhciB3aWR0aDtcclxuXHJcbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgcDEgPSB0aGlzLnBvaW50c1tpXTtcclxuXHJcbiAgICAgICAgLy8gICAgIGlmIChpID09PSBsZW4gLSAxKVxyXG4gICAgICAgIC8vICAgICB7XHJcbiAgICAgICAgLy8gICAgICAgICBwMiA9IHRoaXMucG9pbnRzWzBdO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gICAgIGVsc2VcclxuICAgICAgICAvLyAgICAge1xyXG4gICAgICAgIC8vICAgICAgICAgcDIgPSB0aGlzLnBvaW50c1tpICsgMV07XHJcbiAgICAgICAgLy8gICAgIH1cclxuXHJcbiAgICAgICAgLy8gICAgIGF2Z0hlaWdodCA9ICgocDEueSAtIHkwKSArIChwMi55IC0geTApKSAvIDI7XHJcbiAgICAgICAgLy8gICAgIHdpZHRoID0gcDEueCAtIHAyLng7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuYXJlYSArPSBhdmdIZWlnaHQgKiB3aWR0aDtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvbHlnb24vUG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWlucyA9IGZ1bmN0aW9uIChyZWN0LCB4LCB5KVxyXG57XHJcbiAgICBpZiAocmVjdC53aWR0aCA8PSAwIHx8IHJlY3QuaGVpZ2h0IDw9IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAocmVjdC54IDw9IHggJiYgcmVjdC54ICsgcmVjdC53aWR0aCA+PSB4ICYmIHJlY3QueSA8PSB5ICYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID49IHkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWlucztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBBZGRzIHRoZSBzb3VyY2UgYW5kIGJhY2tkcm9wIGNvbG9ycyB0b2dldGhlciBhbmQgcmV0dXJucyB0aGUgdmFsdWUsIHVwIHRvIGEgbWF4aW11bSBvZiAyNTUuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kQWRkXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIEFkZCA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5taW4oMjU1LCBhICsgYik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9BZGQuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBEYXJrZW5zIHRoZSBiYWNrZHJvcCBjb2xvciB0byByZWZsZWN0IHRoZSBzb3VyY2UgY29sb3IuXHJcbiogUGFpbnRpbmcgd2l0aCB3aGl0ZSBwcm9kdWNlcyBubyBjaGFuZ2UuIFxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZENvbG9yQnVyblxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBDb2xvckJ1cm4gPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiID09PSAwKSA/IGIgOiBNYXRoLm1heCgwLCAoMjU1IC0gKCgyNTUgLSBhKSA8PCA4KSAvIGIpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29sb3JCdXJuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0NvbG9yQnVybi5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEJyaWdodGVucyB0aGUgYmFja2Ryb3AgY29sb3IgdG8gcmVmbGVjdCB0aGUgc291cmNlIGNvbG9yLiBcclxuKiBQYWludGluZyB3aXRoIGJsYWNrIHByb2R1Y2VzIG5vIGNoYW5nZS5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRDb2xvckRvZGdlXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIENvbG9yRG9kZ2UgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiID09PSAyNTUpID8gYiA6IE1hdGgubWluKDI1NSwgKChhIDw8IDgpIC8gKDI1NSAtIGIpKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yRG9kZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvQ29sb3JEb2RnZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFNlbGVjdHMgdGhlIGRhcmtlciBvZiB0aGUgYmFja2Ryb3AgYW5kIHNvdXJjZSBjb2xvcnMuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kRGFya2VuXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIERhcmtlbiA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGIgPiBhKSA/IGEgOiBiO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXJrZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvRGFya2VuLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU2VsZWN0cyB0aGUgbGlnaHRlciBvZiB0aGUgYmFja2Ryb3AgYW5kIHNvdXJjZSBjb2xvcnMuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kTGlnaHRlblxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBMaWdodGVuID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoYiA+IGEpID8gYiA6IGE7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0ZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGlnaHRlbi5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdWJ0cmFjdCA9IHJlcXVpcmUoJy4vU3VidHJhY3QnKTtcclxuXHJcbi8qKlxyXG4qIEFuIGFsaWFzIGZvciBibGVuZFN1YnRyYWN0LCBpdCBzaW1wbHkgc3VtcyB0aGUgdmFsdWVzIG9mIHRoZSB0d28gY29sb3JzIGFuZCBzdWJ0cmFjdHMgMjU1LlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZExpbmVhckJ1cm5cclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgTGluZWFyQnVybiA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gU3VidHJhY3QoYSwgYik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhckJ1cm47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyQnVybi5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyQnVybi5qcyIsInZhciBBZGQgPSByZXF1aXJlKCcuL0FkZCcpO1xyXG5cclxuLyoqXHJcbiogQW4gYWxpYXMgZm9yIGJsZW5kQWRkLCBpdCBzaW1wbHkgc3VtcyB0aGUgdmFsdWVzIG9mIHRoZSB0d28gY29sb3JzLlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZExpbmVhckRvZGdlXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIExpbmVhckRvZGdlID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBBZGQoYSwgYik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhckRvZGdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckRvZGdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaW5lYXJEb2RnZS5qcyIsIi8qKlxyXG4qIE11bHRpcGxpZXMgb3Igc2NyZWVucyB0aGUgY29sb3JzLCBkZXBlbmRpbmcgb24gdGhlIGJhY2tkcm9wIGNvbG9yLlxyXG4qIFNvdXJjZSBjb2xvcnMgb3ZlcmxheSB0aGUgYmFja2Ryb3Agd2hpbGUgcHJlc2VydmluZyBpdHMgaGlnaGxpZ2h0cyBhbmQgc2hhZG93cy4gXHJcbiogVGhlIGJhY2tkcm9wIGNvbG9yIGlzIG5vdCByZXBsYWNlZCwgYnV0IGlzIG1peGVkIHdpdGggdGhlIHNvdXJjZSBjb2xvciB0byByZWZsZWN0IHRoZSBsaWdodG5lc3Mgb3IgZGFya25lc3Mgb2YgdGhlIGJhY2tkcm9wLlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZE92ZXJsYXlcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgT3ZlcmxheSA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGIgPCAxMjgpID8gKDIgKiBhICogYiAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSBhKSAqICgyNTUgLSBiKSAvIDI1NSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvT3ZlcmxheS5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFJlZmxlY3QgYmxlbmQgbW9kZS4gVGhpcyBtb2RlIGlzIHVzZWZ1bCB3aGVuIGFkZGluZyBzaGluaW5nIG9iamVjdHMgb3IgbGlnaHQgem9uZXMgdG8gaW1hZ2VzLiBcclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRSZWZsZWN0XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIFJlZmxlY3QgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiID09PSAyNTUpID8gYiA6IE1hdGgubWluKDI1NSwgKGEgKiBhIC8gKDI1NSAtIGIpKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvUmVmbGVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENvbWJpbmVzIHRoZSBzb3VyY2UgYW5kIGJhY2tkcm9wIGNvbG9ycyBhbmQgcmV0dXJucyB0aGVpciB2YWx1ZSBtaW51cyAyNTUuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kU3VidHJhY3RcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgU3VidHJhY3QgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGEgKyBiIC0gMjU1KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3VidHJhY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvU3VidHJhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29sb3JCdXJuID0gcmVxdWlyZSgnLi9Db2xvckJ1cm4nKTtcclxudmFyIENvbG9yRG9kZ2UgPSByZXF1aXJlKCcuL0NvbG9yRG9kZ2UnKTtcclxuXHJcbi8qKlxyXG4qIFRoaXMgYmxlbmQgbW9kZSBjb21iaW5lcyBDb2xvciBEb2RnZSBhbmQgQ29sb3IgQnVybiAocmVzY2FsZWQgc28gdGhhdCBuZXV0cmFsIGNvbG9ycyBiZWNvbWUgbWlkZGxlIGdyYXkpLlxyXG4qIERvZGdlIGFwcGxpZXMgd2hlbiB2YWx1ZXMgaW4gdGhlIHRvcCBsYXllciBhcmUgbGlnaHRlciB0aGFuIG1pZGRsZSBncmF5LCBhbmQgYnVybiB0byBkYXJrZXIgdmFsdWVzLlxyXG4qIFRoZSBtaWRkbGUgZ3JheSBpcyB0aGUgbmV1dHJhbCBjb2xvci4gV2hlbiBjb2xvciBpcyBsaWdodGVyIHRoYW4gdGhpcywgdGhpcyBlZmZlY3RpdmVseSBtb3ZlcyB0aGUgd2hpdGUgcG9pbnQgb2YgdGhlIGJvdHRvbSBcclxuKiBsYXllciBkb3duIGJ5IHR3aWNlIHRoZSBkaWZmZXJlbmNlOyB3aGVuIGl0IGlzIGRhcmtlciwgdGhlIGJsYWNrIHBvaW50IGlzIG1vdmVkIHVwIGJ5IHR3aWNlIHRoZSBkaWZmZXJlbmNlLiBUaGUgcGVyY2VpdmVkIGNvbnRyYXN0IGluY3JlYXNlcy5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRWaXZpZExpZ2h0XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIFZpdmlkTGlnaHQgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiIDwgMTI4KSA/IENvbG9yQnVybihhLCAyICogYikgOiBDb2xvckRvZGdlKGEsICgyICogKGIgLSAxMjgpKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZpdmlkTGlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvVml2aWRMaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvVml2aWRMaWdodC5qcyIsIi8qKlxyXG4qIFJldHVybiBhIHN0cmluZyBjb250YWluaW5nIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBjb2xvciBjb21wb25lbnQuXHJcbipcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGNvbG9yIC0gVGhlIGNvbG9yIGNoYW5uZWwgdG8gZ2V0IHRoZSBoZXggdmFsdWUgZm9yLCBtdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUuXHJcbiogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyBvZiBsZW5ndGggMiBjaGFyYWN0ZXJzLCBpLmUuIDI1NSA9IGZmLCAxMDAgPSA2NC5cclxuKi9cclxudmFyIENvbXBvbmVudFRvSGV4ID0gZnVuY3Rpb24gKGNvbG9yKVxyXG57XHJcbiAgICB2YXIgaGV4ID0gY29sb3IudG9TdHJpbmcoMTYpO1xyXG5cclxuICAgIHJldHVybiAoaGV4Lmxlbmd0aCA9PT0gMSkgPyAnMCcgKyBoZXggOiBoZXg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudFRvSGV4O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9Db21wb25lbnRUb0hleC5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBHaXZlbiBhbiBhbHBoYSBhbmQgMyBjb2xvciB2YWx1ZXMgdGhpcyB3aWxsIHJldHVybiBhbiBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uIG9mIGl0LlxyXG4gKlxyXG4gKiBAbWV0aG9kIGdldENvbG9yMzJcclxuICogQHBhcmFtIHtpbnRlZ2VyfSByIC0gVGhlIHJlZCBjb2xvciBjb21wb25lbnQgaW4gdGhlIHJhbmdlIDAgLSAyNTUuXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZyAtIFRoZSBncmVlbiBjb2xvciBjb21wb25lbnQgaW4gdGhlIHJhbmdlIDAgLSAyNTUuXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBibHVlIGNvbG9yIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cclxuICogQHJldHVybiB7aW50ZWdlcn0gQSBuYXRpdmUgY29sb3IgdmFsdWUgaW50ZWdlciAoZm9ybWF0OiAweFJSR0dCQikuXHJcbiAqL1xyXG52YXIgR2V0Q29sb3IzMiA9IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcclxue1xyXG4gICAgcmV0dXJuIGFscGhhIDw8IDI0IHwgcmVkIDw8IDE2IHwgZ3JlZW4gPDwgOCB8IGJsdWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldENvbG9yMzI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL0dldENvbG9yMzIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0Q29sb3IgPSByZXF1aXJlKCcuL0dldENvbG9yJyk7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYW4gSFNWIChodWUsIHNhdHVyYXRpb24gYW5kIHZhbHVlKSBjb2xvciB2YWx1ZSB0byBSR0IuXHJcbiAqIENvbnZlcnNpb24gZm9ybXVsYSBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2NvbG9yX3NwYWNlLlxyXG4gKiBBc3N1bWVzIEhTViB2YWx1ZXMgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAxXSBhbmQgcmV0dXJucyByLCBnIGFuZCBiIHZhbHVlcyBpbiB0aGUgc2V0IFswLCAyNTVdLlxyXG4gKiBCYXNlZCBvbiBjb2RlIGJ5IE1pY2hhZWwgSmFja3NvbiAoaHR0cHM6Ly9naXRodWIuY29tL21qaWphY2tzb24pXHJcbiAqXHJcbiAqIEBtZXRob2QgZnJvbUhTVlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaCAtIFRoZSBodWUsIGluIHRoZSByYW5nZSAwIC0gMS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHMgLSBUaGUgc2F0dXJhdGlvbiwgaW4gdGhlIHJhbmdlIDAgLSAxLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdiAtIFRoZSB2YWx1ZSwgaW4gdGhlIHJhbmdlIDAgLSAxLlxyXG4gKiBAcmV0dXJuIHtCYXNlQ29sb3J9IFRoaXNcclxuICovXHJcbnZhciBIU1ZUb1JHQiA9IGZ1bmN0aW9uIChoLCBzLCB2KVxyXG57XHJcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7IHMgPSAxOyB9XHJcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7IHYgPSAxOyB9XHJcblxyXG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcclxuICAgIHZhciBmID0gaCAqIDYgLSBpO1xyXG5cclxuICAgIHZhciBwID0gTWF0aC5mbG9vcigodiAqICgxIC0gcykpICogMjU1KTtcclxuICAgIHZhciBxID0gTWF0aC5mbG9vcigodiAqICgxIC0gZiAqIHMpKSAqIDI1NSk7XHJcbiAgICB2YXIgdCA9IE1hdGguZmxvb3IoKHYgKiAoMSAtICgxIC0gZikgKiBzKSkgKiAyNTUpO1xyXG5cclxuICAgIHYgPSBNYXRoLmZsb29yKHYgKj0gMjU1KTtcclxuXHJcbiAgICB2YXIgb3V0cHV0ID0geyByOiB2LCBnOiB2LCBiOiB2LCBjb2xvcjogMCB9O1xyXG5cclxuICAgIHZhciByID0gaSAlIDY7XHJcblxyXG4gICAgaWYgKHIgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LmcgPSB0O1xyXG4gICAgICAgIG91dHB1dC5iID0gcDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHIgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LnIgPSBxO1xyXG4gICAgICAgIG91dHB1dC5iID0gcDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHIgPT09IDIpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LnIgPSBwO1xyXG4gICAgICAgIG91dHB1dC5iID0gdDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHIgPT09IDMpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LnIgPSBwO1xyXG4gICAgICAgIG91dHB1dC5nID0gcTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHIgPT09IDQpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LnIgPSB0O1xyXG4gICAgICAgIG91dHB1dC5nID0gcDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHIgPT09IDUpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LmcgPSBwO1xyXG4gICAgICAgIG91dHB1dC5iID0gcTtcclxuICAgIH1cclxuXHJcbiAgICBvdXRwdXQuY29sb3IgPSBHZXRDb2xvcihvdXRwdXQuciwgb3V0cHV0LmcsIG91dHB1dC5iKTtcclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIU1ZUb1JHQjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvSFNWVG9SR0IuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9IU1ZUb1JHQi5qcyIsInZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3InKTtcclxuXHJcbi8qKlxyXG4qIENvbnZlcnRzIGEgaGV4IHN0cmluZyBpbnRvIGEgUGhhc2VyIENvbG9yIG9iamVjdC5cclxuKlxyXG4qIFRoZSBoZXggc3RyaW5nIGNhbiBzdXBwbGllZCBhcyBgJyMwMDMzZmYnYCBvciB0aGUgc2hvcnQtaGFuZCBmb3JtYXQgb2YgYCcjMDNmJ2A7IGl0IGNhbiBiZWdpbiB3aXRoIGFuIG9wdGlvbmFsIFwiI1wiIG9yIFwiMHhcIiwgb3IgYmUgdW5wcmVmaXhlZC4gICAgXHJcbipcclxuKiBBbiBhbHBoYSBjaGFubmVsIGlzIF9ub3RfIHN1cHBvcnRlZC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkNvbG9yLmhleFRvQ29sb3JcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtzdHJpbmd9IGhleCAtIFRoZSBjb2xvciBzdHJpbmcgaW4gYSBoZXggZm9ybWF0LlxyXG4qIEBwYXJhbSB7b2JqZWN0fSBbb3V0XSAtIEFuIG9iamVjdCBpbnRvIHdoaWNoIDMgcHJvcGVydGllcyB3aWxsIGJlIGNyZWF0ZWQgb3Igc2V0OiByLCBnIGFuZCBiLiBJZiBub3QgcHJvdmlkZWQgYSBuZXcgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC5cclxuKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSByZWQsIGdyZWVuIGFuZCBibHVlIHZhbHVlcyBzZXQgaW4gdGhlIHIsIGcgYW5kIGIgcHJvcGVydGllcy5cclxuKi9cclxudmFyIEhleFN0cmluZ1RvQ29sb3IgPSBmdW5jdGlvbiAoaGV4KVxyXG57XHJcbiAgICB2YXIgY29sb3IgPSBuZXcgQ29sb3IoKTtcclxuXHJcbiAgICAvLyBFeHBhbmQgc2hvcnRoYW5kIGZvcm0gKGUuZy4gXCIwM0ZcIikgdG8gZnVsbCBmb3JtIChlLmcuIFwiMDAzM0ZGXCIpXHJcbiAgICBoZXggPSBoZXgucmVwbGFjZSgvXig/OiN8MHgpPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaSwgZnVuY3Rpb24obSwgciwgZywgYikge1xyXG4gICAgICAgIHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gL14oPzojfDB4KT8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xyXG5cclxuICAgIGlmIChyZXN1bHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHIgPSBwYXJzZUludChyZXN1bHRbMV0sIDE2KTtcclxuICAgICAgICB2YXIgZyA9IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpO1xyXG4gICAgICAgIHZhciBiID0gcGFyc2VJbnQocmVzdWx0WzNdLCAxNik7XHJcblxyXG4gICAgICAgIGNvbG9yLnNldFRvKHIsIGcsIGIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb2xvcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSGV4U3RyaW5nVG9Db2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvSGV4U3RyaW5nVG9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2NvbG9yL0hleFN0cmluZ1RvQ29sb3IuanMiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9IdWVUb0NvbXBvbmVudC5qcyIsIi8qKlxyXG4qIENvbnZlcnRzIGEgaHVlIHRvIGFuIFJHQiBjb2xvci5cclxuKiBCYXNlZCBvbiBjb2RlIGJ5IE1pY2hhZWwgSmFja3NvbiAoaHR0cHM6Ly9naXRodWIuY29tL21qaWphY2tzb24pXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmh1ZVRvQ29sb3JcclxuKiBAcGFyYW0ge251bWJlcn0gcFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBxXHJcbiogQHBhcmFtIHtudW1iZXJ9IHRcclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjb2xvciBjb21wb25lbnQgdmFsdWUuXHJcbiovXHJcbnZhciBIdWVUb0NvbXBvbmVudCA9IGZ1bmN0aW9uIChwLCBxLCB0KVxyXG57XHJcbiAgICBpZiAodCA8IDApXHJcbiAgICB7XHJcbiAgICAgICAgdCArPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0ID4gMSlcclxuICAgIHtcclxuICAgICAgICB0IC09IDE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHQgPCAxIC8gNilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodCA8IDEgLyAyKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0IDwgMiAvIDMpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydCA9IEh1ZVRvQ29tcG9uZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9IdWVUb0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3InKTtcclxudmFyIEludGVnZXJUb1JHQiA9IHJlcXVpcmUoJy4vSW50ZWdlclRvUkdCJyk7XHJcblxyXG52YXIgSW50ZWdlclRvQ29sb3IgPSBmdW5jdGlvbiAoaW5wdXQpXHJcbntcclxuICAgIHZhciByZ2IgPSBJbnRlZ2VyVG9SR0IoaW5wdXQpO1xyXG5cclxuICAgIHJldHVybiBuZXcgQ29sb3IocmdiLnIsIHJnYi5nLCByZ2IuYiwgcmdiLmEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnRlZ2VyVG9Db2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvSW50ZWdlclRvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9JbnRlZ2VyVG9Db2xvci5qcyIsIi8qKlxyXG4qIFJldHVybiB0aGUgY29tcG9uZW50IHBhcnRzIG9mIGEgY29sb3IgYXMgYW4gT2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgYWxwaGEsIHJlZCwgZ3JlZW4sIGJsdWUuXHJcbipcclxuKiBBbHBoYSB3aWxsIG9ubHkgYmUgc2V0IGlmIGl0IGV4aXN0IGluIHRoZSBnaXZlbiBjb2xvciAoMHhBQVJSR0dCQilcclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkNvbG9yLmdldFJHQlxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge251bWJlcn0gY29sb3IgLSBDb2xvciBpbiBSR0IgKDB4UlJHR0JCKSBvciBBUkdCIGZvcm1hdCAoMHhBQVJSR0dCQikuXHJcbiogQHJldHVybiB7b2JqZWN0fSBBbiBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzOiBhbHBoYSwgcmVkLCBncmVlbiwgYmx1ZSAoYWxzbyByLCBnLCBiIGFuZCBhKS4gQWxwaGEgd2lsbCBvbmx5IGJlIHByZXNlbnQgaWYgYSBjb2xvciB2YWx1ZSA+IDE2Nzc3MjE1IHdhcyBnaXZlbi5cclxuKi9cclxudmFyIEludGVnZXJUb1JHQiA9IGZ1bmN0aW9uIChjb2xvcilcclxue1xyXG4gICAgaWYgKGNvbG9yID4gMTY3NzcyMTUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRoZSBjb2xvciB2YWx1ZSBoYXMgYW4gYWxwaGEgY29tcG9uZW50XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYTogY29sb3IgPj4+IDI0LFxyXG4gICAgICAgICAgICByOiBjb2xvciA+PiAxNiAmIDB4RkYsXHJcbiAgICAgICAgICAgIGc6IGNvbG9yID4+IDggJiAweEZGLFxyXG4gICAgICAgICAgICBiOiBjb2xvciAmIDB4RkZcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGE6IDI1NSxcclxuICAgICAgICAgICAgcjogY29sb3IgPj4gMTYgJiAweEZGLFxyXG4gICAgICAgICAgICBnOiBjb2xvciA+PiA4ICYgMHhGRixcclxuICAgICAgICAgICAgYjogY29sb3IgJiAweEZGXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW50ZWdlclRvUkdCO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9JbnRlZ2VyVG9SR0IuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29sb3IgPSByZXF1aXJlKCcuL0NvbG9yJyk7XHJcblxyXG4vKipcclxuKiBDb252ZXJ0cyBhIENTUyAnd2ViJyBzdHJpbmcgaW50byBhIFBoYXNlciBDb2xvciBvYmplY3QuXHJcbipcclxuKiBUaGUgd2ViIHN0cmluZyBjYW4gYmUgaW4gdGhlIGZvcm1hdCBgJ3JnYihyLGcsYiknYCBvciBgJ3JnYmEocixnLGIsYSknYCB3aGVyZSByL2cvYiBhcmUgaW4gdGhlIHJhbmdlIFswLi4yNTVdIGFuZCBhIGlzIGluIHRoZSByYW5nZSBbMC4uMV0uXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5Db2xvci53ZWJUb0NvbG9yXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7c3RyaW5nfSB3ZWIgLSBUaGUgY29sb3Igc3RyaW5nIGluIENTUyAnd2ViJyBmb3JtYXQuXHJcbiogQHBhcmFtIHtvYmplY3R9IFtvdXRdIC0gQW4gb2JqZWN0IGludG8gd2hpY2ggNCBwcm9wZXJ0aWVzIHdpbGwgYmUgY3JlYXRlZDogciwgZywgYiBhbmQgYS4gSWYgbm90IHByb3ZpZGVkIGEgbmV3IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgcmVkLCBncmVlbiwgYmx1ZSBhbmQgYWxwaGEgdmFsdWVzIHNldCBpbiB0aGUgciwgZywgYiBhbmQgYSBwcm9wZXJ0aWVzLlxyXG4qL1xyXG52YXIgUkdCU3RyaW5nVG9Db2xvciA9IGZ1bmN0aW9uIChyZ2IpXHJcbntcclxuICAgIHZhciBjb2xvciA9IG5ldyBDb2xvcigpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSAvXnJnYmE/XFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooPzosXFxzKihcXGQrKD86XFwuXFxkKyk/KSk/XFxzKlxcKSQvLmV4ZWMocmdiLnRvTG93ZXJDYXNlKCkpO1xyXG5cclxuICAgIGlmIChyZXN1bHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHIgPSBwYXJzZUludChyZXN1bHRbMV0sIDEwKTtcclxuICAgICAgICB2YXIgZyA9IHBhcnNlSW50KHJlc3VsdFsyXSwgMTApO1xyXG4gICAgICAgIHZhciBiID0gcGFyc2VJbnQocmVzdWx0WzNdLCAxMCk7XHJcbiAgICAgICAgdmFyIGEgPSAocmVzdWx0WzRdICE9PSB1bmRlZmluZWQpID8gcGFyc2VGbG9hdChyZXN1bHRbNF0pIDogMTtcclxuXHJcbiAgICAgICAgY29sb3Iuc2V0VG8ociwgZywgYiwgYSAqIDI1NSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbG9yO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSR0JTdHJpbmdUb0NvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9SR0JTdHJpbmdUb0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvY29sb3IvUkdCU3RyaW5nVG9Db2xvci5qcyIsInZhciBSR0JTdHJpbmdUb0NvbG9yID0gcmVxdWlyZSgnLi9SR0JTdHJpbmdUb0NvbG9yJyk7XHJcbnZhciBIZXhTdHJpbmdUb0NvbG9yID0gcmVxdWlyZSgnLi9IZXhTdHJpbmdUb0NvbG9yJyk7XHJcbnZhciBJbnRlZ2VyVG9Db2xvciA9IHJlcXVpcmUoJy4vSW50ZWdlclRvQ29sb3InKTtcclxuXHJcbnZhciBWYWx1ZVRvQ29sb3IgPSBmdW5jdGlvbiAoaW5wdXQpXHJcbntcclxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgMykudG9Mb3dlckNhc2UoKSA9PT0gJ3JnYicpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUkdCU3RyaW5nVG9Db2xvcihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBIZXhTdHJpbmdUb0NvbG9yKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBJbnRlZ2VyVG9Db2xvcihpbnB1dCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZhbHVlVG9Db2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvVmFsdWVUb0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvY29sb3IvVmFsdWVUb0NvbG9yLmpzIiwidmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcclxudmFyIEtleUNvZGVzID0gcmVxdWlyZSgnLi9rZXlzL0tleUNvZGVzJyk7XHJcbnZhciBLZXkgPSByZXF1aXJlKCcuL2tleXMvS2V5Jyk7XHJcbnZhciBLZXlDb21ibyA9IHJlcXVpcmUoJy4vY29tYm8vS2V5Q29tYm8nKTtcclxudmFyIFByb2Nlc3NLZXlDb21ibyA9IHJlcXVpcmUoJy4vY29tYm8vUHJvY2Vzc0tleUNvbWJvJyk7XHJcbnZhciBQcm9jZXNzS2V5RG93biA9IHJlcXVpcmUoJy4va2V5cy9Qcm9jZXNzS2V5RG93bicpO1xyXG52YXIgUHJvY2Vzc0tleVVwID0gcmVxdWlyZSgnLi9rZXlzL1Byb2Nlc3NLZXlVcCcpO1xyXG5cclxuLyoqXHJcbiogVGhlIEtleWJvYXJkIGNsYXNzIG1vbml0b3JzIGtleWJvYXJkIGlucHV0IGFuZCBkaXNwYXRjaGVzIGtleWJvYXJkIGV2ZW50cy5cclxuKlxyXG4qIF9Ob3RlXzogbWFueSBrZXlib2FyZHMgYXJlIHVuYWJsZSB0byBwcm9jZXNzIGNlcnRhaW4gY29tYmluYXRpb25zIG9mIGtleXMgZHVlIHRvIGhhcmR3YXJlIGxpbWl0YXRpb25zIGtub3duIGFzIGdob3N0aW5nLlxyXG4qIFNlZSBodHRwOi8vd3d3Lmh0bWw1Z2FtZWRldnMuY29tL3RvcGljLzQ4NzYtaW1wb3NzaWJsZS10by11c2UtbW9yZS10aGFuLTIta2V5Ym9hcmQtaW5wdXQtYnV0dG9ucy1hdC10aGUtc2FtZS10aW1lLyBmb3IgbW9yZSBkZXRhaWxzLlxyXG4qXHJcbiogQWxzbyBwbGVhc2UgYmUgYXdhcmUgdGhhdCBjZXJ0YWluIGJyb3dzZXIgZXh0ZW5zaW9ucyBjYW4gZGlzYWJsZSBvciBvdmVycmlkZSBQaGFzZXIga2V5Ym9hcmQgaGFuZGxpbmcuXHJcbiogRm9yIGV4YW1wbGUgdGhlIENocm9tZSBleHRlbnNpb24gdmltaXVtIGlzIGtub3duIHRvIGRpc2FibGUgUGhhc2VyIGZyb20gdXNpbmcgdGhlIEQga2V5LiBBbmQgdGhlcmUgYXJlIG90aGVycy5cclxuKiBTbyBwbGVhc2UgY2hlY2sgeW91ciBleHRlbnNpb25zIGJlZm9yZSBvcGVuaW5nIFBoYXNlciBpc3N1ZXMuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLktleWJvYXJkXHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxyXG4qL1xyXG52YXIgS2V5Ym9hcmRNYW5hZ2VyID0gZnVuY3Rpb24gKGlucHV0TWFuYWdlcilcclxue1xyXG4gICAgdGhpcy5tYW5hZ2VyID0gaW5wdXRNYW5hZ2VyO1xyXG5cclxuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMudGFyZ2V0O1xyXG5cclxuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG5cclxuICAgIHRoaXMua2V5cyA9IFtdO1xyXG5cclxuICAgIHRoaXMuY29tYm9zID0gW107XHJcblxyXG4gICAgdGhpcy5jYXB0dXJlcyA9IFtdO1xyXG5cclxuICAgIC8vICAgU3RhbmRhcmQgRklGTyBxdWV1ZVxyXG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG5cclxuICAgIHRoaXMua2V5SGFuZGxlcjtcclxufTtcclxuXHJcbktleWJvYXJkTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXlib2FyZE1hbmFnZXI7XHJcblxyXG5LZXlib2FyZE1hbmFnZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgQm9vdCBoYW5kbGVyIGlzIGNhbGxlZCBieSBQaGFzZXIuR2FtZSB3aGVuIGl0IGZpcnN0IHN0YXJ0cyB1cC5cclxuICAgICogVGhlIHJlbmRlcmVyIGlzIGF2YWlsYWJsZSBieSBub3cuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLklucHV0LktleWJvYXJkTWFuYWdlciNib290XHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgYm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5tYW5hZ2VyLmdhbWVDb25maWc7XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGNvbmZpZy5pbnB1dEtleWJvYXJkO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gY29uZmlnLmlucHV0S2V5Ym9hcmRFdmVudFRhcmdldDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0TGlzdGVuZXJzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7XHJcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gdGhpcy5jYXB0dXJlcztcclxuXHJcbiAgICAgICAgdmFyIGtleUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHRlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBldmVudCBhbHJlYWR5IGhhbmRsZWRcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcXVldWUucHVzaChldmVudCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2FwdHVyZXNbZXZlbnQua2V5Q29kZV0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmtleUhhbmRsZXIgPSBrZXlIYW5kbGVyO1xyXG5cclxuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5SGFuZGxlciwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywga2V5SGFuZGxlciwgZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wTGlzdGVuZXJzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5rZXlIYW5kbGVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgNCBob3RrZXlzIGZvciBVcCwgRG93biwgTGVmdCBhbmQgUmlnaHQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLktleWJvYXJkI2NyZWF0ZUN1cnNvcktleXNcclxuICAgICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzOiBgdXBgLCBgZG93bmAsIGBsZWZ0YCBhbmQgYHJpZ2h0YCBvZiB7QGxpbmsgUGhhc2VyLktleX0gb2JqZWN0cy5cclxuICAgICovXHJcbiAgICBjcmVhdGVDdXJzb3JLZXlzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZEtleXMoe1xyXG4gICAgICAgICAgICB1cDogS2V5Q29kZXMuVVAsXHJcbiAgICAgICAgICAgIGRvd246IEtleUNvZGVzLkRPV04sXHJcbiAgICAgICAgICAgIGxlZnQ6IEtleUNvZGVzLkxFRlQsXHJcbiAgICAgICAgICAgIHJpZ2h0OiBLZXlDb2Rlcy5SSUdIVFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQSBwcmFjdGljYWwgd2F5IHRvIGNyZWF0ZSBhbiBvYmplY3QgY29udGFpbmluZyB1c2VyIHNlbGVjdGVkIGhvdGtleXMuXHJcbiAgICAqXHJcbiAgICAqIEZvciBleGFtcGxlLFxyXG4gICAgKlxyXG4gICAgKiAgICAgYWRkS2V5cyggeyAndXAnOiBQaGFzZXIuS2V5Q29kZS5XLCAnZG93bic6IFBoYXNlci5LZXlDb2RlLlMsICdsZWZ0JzogUGhhc2VyLktleUNvZGUuQSwgJ3JpZ2h0JzogUGhhc2VyLktleUNvZGUuRCB9ICk7XHJcbiAgICAqXHJcbiAgICAqIHdvdWxkIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIChgdXBgLCBgZG93bmAsIGBsZWZ0YCBhbmQgYHJpZ2h0YCkgcmVmZXJyaW5nIHRvIHtAbGluayBQaGFzZXIuS2V5fSBvYmplY3QuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLktleWJvYXJkI2FkZEtleXNcclxuICAgICogQHBhcmFtIHtvYmplY3R9IGtleXMgLSBBIGtleSBtYXBwaW5nIG9iamVjdCwgaS5lLiBgeyAndXAnOiBQaGFzZXIuS2V5Q29kZS5XLCAnZG93bic6IFBoYXNlci5LZXlDb2RlLlMgfWAgb3IgYHsgJ3VwJzogNTIsICdkb3duJzogNTMgfWAuXHJcbiAgICAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgbWFwcGVkIHRvIHtAbGluayBQaGFzZXIuS2V5fSB2YWx1ZXMuXHJcbiAgICAqL1xyXG4gICAgYWRkS2V5czogZnVuY3Rpb24gKGtleXMpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4ga2V5cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gdGhpcy5hZGRLZXkoa2V5c1trZXldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBJZiB5b3UgbmVlZCBtb3JlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgYSBLZXkgeW91IGNhbiBjcmVhdGUgYSBuZXcgUGhhc2VyLktleSBvYmplY3QgdmlhIHRoaXMgbWV0aG9kLlxyXG4gICAgKiBUaGUgS2V5IG9iamVjdCBjYW4gdGhlbiBiZSBwb2xsZWQsIGhhdmUgZXZlbnRzIGF0dGFjaGVkIHRvIGl0LCBldGMuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLktleWJvYXJkI2FkZEtleVxyXG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IGtleWNvZGUgLSBUaGUge0BsaW5rIFBoYXNlci5LZXlDb2RlIGtleWNvZGV9IG9mIHRoZSBrZXkuXHJcbiAgICAqIEByZXR1cm4ge1BoYXNlci5LZXl9IFRoZSBLZXkgb2JqZWN0IHdoaWNoIHlvdSBjYW4gc3RvcmUgbG9jYWxseSBhbmQgcmVmZXJlbmNlIGRpcmVjdGx5LlxyXG4gICAgKi9cclxuICAgIGFkZEtleTogZnVuY3Rpb24gKGtleUNvZGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XHJcblxyXG4gICAgICAgIGlmICgha2V5c1trZXlDb2RlXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleXNba2V5Q29kZV0gPSBuZXcgS2V5KGtleUNvZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVzW2tleUNvZGVdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBrZXlzW2tleUNvZGVdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmVtb3ZlcyBhIEtleSBvYmplY3QgZnJvbSB0aGUgS2V5Ym9hcmQgbWFuYWdlci5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuS2V5Ym9hcmQjcmVtb3ZlS2V5XHJcbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0ga2V5Y29kZSAtIFRoZSB7QGxpbmsgUGhhc2VyLktleUNvZGUga2V5Y29kZX0gb2YgdGhlIGtleSB0byByZW1vdmUuXHJcbiAgICAqL1xyXG4gICAgcmVtb3ZlS2V5OiBmdW5jdGlvbiAoa2V5Q29kZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5rZXlzW2tleUNvZGVdKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlzW2tleUNvZGVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVzW2tleUNvZGVdID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRLZXlDYXB0dXJlOiBmdW5jdGlvbiAoa2V5Q29kZXMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleUNvZGVzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleUNvZGVzID0gWyBrZXlDb2RlcyBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlDb2Rlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZXNba2V5Q29kZXNbaV1dID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUtleUNhcHR1cmU6IGZ1bmN0aW9uIChrZXlDb2RlcylcclxuICAgIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5Q29kZXMgPSBbIGtleUNvZGVzIF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvZGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlc1trZXlDb2Rlc1tpXV0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUNvbWJvOiBmdW5jdGlvbiAoa2V5cywgY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgS2V5Q29tYm8odGhpcywga2V5cywgY29uZmlnKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L0tleWJvYXJkRXZlbnRcclxuICAgIC8vICB0eXBlID0gJ2tleWRvd24nLCAna2V5dXAnXHJcbiAgICAvLyAga2V5Q29kZSA9IGludGVnZXJcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQ2xlYXJzIHRoZSBxdWV1ZSBhcnJheSwgYW5kIGFsc28gbWVhbnMgd2UgZG9uJ3Qgd29yayBvbiBhcnJheSBkYXRhIHRoYXQgY291bGQgcG90ZW50aWFsbHlcclxuICAgICAgICAvLyAgYmUgbW9kaWZpZWQgZHVyaW5nIHRoZSBwcm9jZXNzaW5nIHBoYXNlXHJcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZS5zcGxpY2UoMCwgdGhpcy5xdWV1ZS5sZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcclxuICAgICAgICB2YXIgc2luZ2xlS2V5O1xyXG5cclxuICAgICAgICAvLyAgUHJvY2VzcyB0aGUgZXZlbnQgcXVldWUsIGRpc3BhdGNoaW5nIGFsbCBvZiB0aGUgZXZlbnRzIHRoYXQgaGF2ZSBzdG9yZWQgdXBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gcXVldWVbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuS0VZX0RPV05fRVZFTlQoZXZlbnQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVLZXkgPSBFdmVudC5fRE9XTltldmVudC5rZXlDb2RlXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlS2V5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBzaW5nbGVLZXkoZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5c1tldmVudC5rZXlDb2RlXSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9jZXNzS2V5RG93bihrZXlzW2V2ZW50LmtleUNvZGVdLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuS0VZX1VQX0VWRU5UKGV2ZW50KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2luZ2xlS2V5ID0gRXZlbnQuX1VQW2V2ZW50LmtleUNvZGVdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVLZXkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IHNpbmdsZUtleShldmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChrZXlzW2V2ZW50LmtleUNvZGVdKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb2Nlc3NLZXlVcChrZXlzW2V2ZW50LmtleUNvZGVdLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBLZXlib2FyZE1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL0tleWJvYXJkTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2lucHV0L2tleWJvYXJkL0tleWJvYXJkTWFuYWdlci5qcyIsInZhciBHZXRPYmplY3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL29iamVjdC9HZXRPYmplY3RWYWx1ZScpO1xyXG52YXIgUmVzZXRLZXlDb21ibyA9IHJlcXVpcmUoJy4vUmVzZXRLZXlDb21ibycpO1xyXG52YXIgUHJvY2Vzc0tleUNvbWJvID0gcmVxdWlyZSgnLi9Qcm9jZXNzS2V5Q29tYm8nKTtcclxudmFyIEtleUNvbWJvTWF0Y2hFdmVudCA9IHJlcXVpcmUoJy4vS2V5Q29tYm9NYXRjaEV2ZW50Jyk7XHJcblxyXG4vLyAgS2V5cyBjYW4gYmUgZWl0aGVyOlxyXG4vL1xyXG4vLyAgQSBzdHJpbmcgKEFUQVJJKVxyXG4vLyAgQW4gYXJyYXkgb2YgZWl0aGVyIGludGVnZXJzIChrZXkgY29kZXMpIG9yIHN0cmluZ3MsIG9yIGEgbWl4dHVyZSBvZiBib3RoXHJcbi8vICBBbiBhcnJheSBvZiBvYmplY3RzIChzdWNoIGFzIEtleSBvYmplY3RzKSB3aXRoIGEgcHVibGljICdrZXlDb2RlJyBwcm9wZXJ0eVxyXG5cclxudmFyIEtleUNvbWJvID0gZnVuY3Rpb24gKGtleWJvYXJkTWFuYWdlciwga2V5cywgY29uZmlnKVxyXG57XHJcbiAgICBpZiAoY29uZmlnID09PSB1bmRlZmluZWQpIHsgY29uZmlnID0ge307IH1cclxuXHJcbiAgICAvLyAgQ2FuJ3QgaGF2ZSBhIHplcm8gb3Igc2luZ2xlIGxlbmd0aCBjb21ibyAoc3RyaW5nIG9yIGFycmF5IGJhc2VkKVxyXG4gICAgaWYgKGtleXMubGVuZ3RoIDwgMilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0ga2V5Ym9hcmRNYW5hZ2VyO1xyXG5cclxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5rZXlDb2RlcyA9IFtdO1xyXG5cclxuICAgIC8vICBpZiAna2V5cycgaXMgYSBzdHJpbmcgd2UgbmVlZCB0byBnZXQgdGhlIGtleWNvZGUgb2YgZWFjaCBjaGFyYWN0ZXIgaW4gaXRcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNoYXIgPSBrZXlzW2ldO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNoYXIgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlDb2Rlcy5wdXNoKGNoYXIudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoYXIgPT09ICdudW1iZXInKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlDb2Rlcy5wdXNoKGNoYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGFyLmhhc093blByb3BlcnR5KCdrZXlDb2RlJykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmtleUNvZGVzLnB1c2goY2hhci5rZXlDb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFRoZSBjdXJyZW50IGtleUNvZGUgdGhlIGNvbWJvIGlzIHdhaXRpbmcgZm9yXHJcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmtleUNvZGVzWzBdO1xyXG5cclxuICAgIC8vICBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUga2V5IGJlaW5nIHdhaXRlZCBmb3IgaW4gdGhlICdrZXlzJyBzdHJpbmdcclxuICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cclxuICAgIC8vICBUaGUgbGVuZ3RoIG9mIHRoaXMgY29tYm8gKGluIGtleWNvZGVzKVxyXG4gICAgdGhpcy5zaXplID0gdGhpcy5rZXlDb2Rlcy5sZW5ndGg7XHJcblxyXG4gICAgLy8gIFRoZSB0aW1lIHRoZSBwcmV2aW91cyBrZXkgaW4gdGhlIGNvbWJvIHdhcyBtYXRjaGVkXHJcbiAgICB0aGlzLnRpbWVMYXN0TWF0Y2hlZCA9IDA7XHJcblxyXG4gICAgLy8gIEhhcyB0aGlzIEtleSBDb21ibyBiZWVuIG1hdGNoZWQgeWV0P1xyXG4gICAgdGhpcy5tYXRjaGVkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gIFRoZSB0aW1lIHRoZSBlbnRpcmUgY29tYm8gd2FzIG1hdGNoZWRcclxuICAgIHRoaXMudGltZU1hdGNoZWQgPSAwO1xyXG5cclxuICAgIC8vICBDdXN0b20gb3B0aW9ucyAuLi5cclxuXHJcbiAgICAvLyAgSWYgdGhleSBwcmVzcyB0aGUgd3Jvbmcga2V5IGRvIHdlIHJlc2V0IHRoZSBjb21ibz9cclxuICAgIHRoaXMucmVzZXRPbldyb25nS2V5ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmVzZXRPbldyb25nS2V5JywgdHJ1ZSk7XHJcblxyXG4gICAgLy8gIFRoZSBtYXggZGVsYXkgaW4gbXMgYmV0d2VlbiBlYWNoIGtleSBwcmVzcy4gQWJvdmUgdGhpcyB0aGUgY29tYm8gaXMgcmVzZXQuIDAgbWVhbnMgZGlzYWJsZWQuXHJcbiAgICB0aGlzLm1heEtleURlbGF5ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnbWF4S2V5RGVsYXknLCAwKTtcclxuXHJcbiAgICAvLyAgSWYgcHJldmlvdXNseSBtYXRjaGVkIGFuZCB0aGV5IHByZXNzIEtleSAxIGFnYWluLCB3aWxsIGl0IHJlc2V0P1xyXG4gICAgdGhpcy5yZXNldE9uTWF0Y2ggPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXNldE9uTWF0Y2gnLCBmYWxzZSk7XHJcblxyXG4gICAgLy8gIElmIHRoZSBjb21ibyBtYXRjaGVzLCB3aWxsIGl0IGRlbGV0ZSBpdHNlbGY/XHJcbiAgICB0aGlzLmRlbGV0ZU9uTWF0Y2ggPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdkZWxldGVPbk1hdGNoJywgZmFsc2UpO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgdmFyIG9uS2V5RG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKF90aGlzLm1hdGNoZWQgfHwgIV90aGlzLmVuYWJsZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWF0Y2hlZCA9IFByb2Nlc3NLZXlDb21ibyhldmVudC5kYXRhLCBfdGhpcyk7XHJcblxyXG4gICAgICAgIGlmIChtYXRjaGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3RoaXMubWFuYWdlci5ldmVudHMuZGlzcGF0Y2gobmV3IEtleUNvbWJvTWF0Y2hFdmVudChfdGhpcywgZXZlbnQpKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5yZXNldE9uTWF0Y2gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFJlc2V0S2V5Q29tYm8oX3RoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmRlbGV0ZU9uTWF0Y2gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5vbktleURvd24gPSBvbktleURvd25IYW5kbGVyO1xyXG5cclxuICAgIHRoaXMubWFuYWdlci5ldmVudHMub24oJ0tFWV9ET1dOX0VWRU5UJywgb25LZXlEb3duSGFuZGxlcik7XHJcbn07XHJcblxyXG5LZXlDb21iby5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXlDb21ibztcclxuXHJcbktleUNvbWJvLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMua2V5Q29kZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmV2ZW50cy5vZmYoJ0tFWV9ET1dOJywgdGhpcy5vbktleURvd24pO1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhLZXlDb21iby5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBwcm9ncmVzczoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICAvLyAgSG93IGZhciBjb21wbGV0ZSBpcyB0aGlzIGNvbWJvPyBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCAvIHRoaXMuc2l6ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleUNvbWJvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9jb21iby9LZXlDb21iby5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2lucHV0L2tleWJvYXJkL2NvbWJvL0tleUNvbWJvLmpzIiwidmFyIEFkdmFuY2VLZXlDb21ibyA9IHJlcXVpcmUoJy4vQWR2YW5jZUtleUNvbWJvJyk7XHJcblxyXG52YXIgUHJvY2Vzc0tleUNvbWJvID0gZnVuY3Rpb24gKGV2ZW50LCBjb21ibylcclxue1xyXG4gICAgaWYgKGNvbWJvLm1hdGNoZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbWJvTWF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgdmFyIGtleU1hdGNoZWQgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gY29tYm8uY3VycmVudClcclxuICAgIHtcclxuICAgICAgICAvLyAgS2V5IHdhcyBjb3JyZWN0XHJcblxyXG4gICAgICAgIGlmIChjb21iby5pbmRleCA+IDAgJiYgY29tYm8ubWF4S2V5RGVsYXkgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFdlIGhhdmUgdG8gY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWxheSBiZXR3ZWVuXHJcbiAgICAgICAgICAgIC8vICB0aGUgbmV3IGtleSBhbmQgdGhlIG9sZCBvbmUgd2FzIHRvbyBsb25nIChpZiBlbmFibGVkKVxyXG5cclxuICAgICAgICAgICAgdmFyIHRpbWVMaW1pdCA9IGNvbWJvLnRpbWVMYXN0TWF0Y2hlZCArIGNvbWJvLm1heEtleURlbGF5O1xyXG5cclxuICAgICAgICAgICAgLy8gIENoZWNrIGlmIHRoZXkgcHJlc3NlZCBpdCBpbiB0aW1lIG9yIG5vdFxyXG4gICAgICAgICAgICBpZiAoZXZlbnQudGltZVN0YW1wIDw9IHRpbWVMaW1pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5TWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb21ib01hdGNoZWQgPSBBZHZhbmNlS2V5Q29tYm8oZXZlbnQsIGNvbWJvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXlNYXRjaGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vICBXZSBkb24ndCBjaGVjayB0aGUgdGltZSBmb3IgdGhlIGZpcnN0IGtleSBwcmVzc2VkLCBzbyBqdXN0IGFkdmFuY2UgaXRcclxuICAgICAgICAgICAgY29tYm9NYXRjaGVkID0gQWR2YW5jZUtleUNvbWJvKGV2ZW50LCBjb21ibyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgha2V5TWF0Y2hlZCAmJiBjb21iby5yZXNldE9uV3JvbmdLZXkpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFdyb25nIGtleSB3YXMgcHJlc3NlZFxyXG4gICAgICAgIGNvbWJvLmluZGV4ID0gMDtcclxuICAgICAgICBjb21iby5jdXJyZW50ID0gY29tYm8ua2V5Q29kZXNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbWJvTWF0Y2hlZClcclxuICAgIHtcclxuICAgICAgICBjb21iby50aW1lTGFzdE1hdGNoZWQgPSBldmVudC50aW1lU3RhbXA7XHJcbiAgICAgICAgY29tYm8ubWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgY29tYm8udGltZU1hdGNoZWQgPSBldmVudC50aW1lU3RhbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbWJvTWF0Y2hlZDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc0tleUNvbWJvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9jb21iby9Qcm9jZXNzS2V5Q29tYm8uanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbnB1dC9rZXlib2FyZC9jb21iby9Qcm9jZXNzS2V5Q29tYm8uanMiLCIvLyAgQSBnZW5lcmljIEtleSBvYmplY3Qgd2hpY2ggY2FuIGJlIHBhc3NlZCB0byB0aGUgUHJvY2VzcyBmdW5jdGlvbnMgKGFuZCBzbyBvbilcclxuXHJcbi8vICBrZXljb2RlIG11c3QgYmUgYW4gaW50ZWdlclxyXG5cclxudmFyIEtleSA9IGZ1bmN0aW9uIChrZXlDb2RlKVxyXG57XHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBrZXlDb2RlIC0gVGhlIGtleWNvZGUgb2YgdGhpcyBrZXkuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5rZXlDb2RlID0ga2V5Q29kZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtLZXlib2FyZEV2ZW50fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIERPTSBldmVudC5cclxuICAgICovXHJcbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcHJldmVudERlZmF1bHQgLSBTaG91bGQgdGhpcyBLZXkgcHJldmVudCBldmVudCBwcm9wYWdhdGlvbj9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVkIC0gQ2FuIHRoaXMgS2V5IGJlIHByb2Nlc3NlZD9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRG93biAtIFRoZSBcImRvd25cIiBzdGF0ZSBvZiB0aGUga2V5LiBUaGlzIHdpbGwgcmVtYWluIGB0cnVlYCBmb3IgYXMgbG9uZyBhcyB0aGUga2V5Ym9hcmQgdGhpbmtzIHRoaXMga2V5IGlzIGhlbGQgZG93bi5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzVXAgLSBUaGUgXCJ1cFwiIHN0YXRlIG9mIHRoZSBrZXkuIFRoaXMgd2lsbCByZW1haW4gYHRydWVgIGZvciBhcyBsb25nIGFzIHRoZSBrZXlib2FyZCB0aGlua3MgdGhpcyBrZXkgaXMgdXAuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5pc1VwID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhbHRLZXkgLSBUaGUgZG93biBzdGF0ZSBvZiB0aGUgQUxUIGtleSwgaWYgcHJlc3NlZCBhdCB0aGUgc2FtZSB0aW1lIGFzIHRoaXMga2V5LlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMuYWx0S2V5ID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY3RybEtleSAtIFRoZSBkb3duIHN0YXRlIG9mIHRoZSBDVFJMIGtleSwgaWYgcHJlc3NlZCBhdCB0aGUgc2FtZSB0aW1lIGFzIHRoaXMga2V5LlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMuY3RybEtleSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNoaWZ0S2V5IC0gVGhlIGRvd24gc3RhdGUgb2YgdGhlIFNISUZUIGtleSwgaWYgcHJlc3NlZCBhdCB0aGUgc2FtZSB0aW1lIGFzIHRoaXMga2V5LlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMuc2hpZnRLZXkgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiBvZiB0aGUgbW9kaWZpZXIga2V5LiAwIGZvciBzdGFuZGFyZCAob3IgdW5rbm93biksIDEgZm9yIGxlZnQsIDIgZm9yIHJpZ2h0LCAzIGZvciBudW1wYWQuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5sb2NhdGlvbiA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lRG93biAtIFRoZSB0aW1lc3RhbXAgd2hlbiB0aGUga2V5IHdhcyBsYXN0IHByZXNzZWQgZG93bi4gVGhpcyBpcyBiYXNlZCBvbiBHYW1lLnRpbWUubm93LlxyXG4gICAgKi9cclxuICAgIHRoaXMudGltZURvd24gPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBJZiB0aGUga2V5IGlzIGRvd24gdGhpcyB2YWx1ZSBob2xkcyB0aGUgZHVyYXRpb24gb2YgdGhhdCBrZXkgcHJlc3MgYW5kIGlzIGNvbnN0YW50bHkgdXBkYXRlZC5cclxuICAgICogSWYgdGhlIGtleSBpcyB1cCBpdCBob2xkcyB0aGUgZHVyYXRpb24gb2YgdGhlIHByZXZpb3VzIGRvd24gc2Vzc2lvbi5cclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhpcyBrZXkgaGFzIGJlZW4gaGVsZCBkb3duIGZvci5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVVcCAtIFRoZSB0aW1lc3RhbXAgd2hlbiB0aGUga2V5IHdhcyBsYXN0IHJlbGVhc2VkLiBUaGlzIGlzIGJhc2VkIG9uIEdhbWUudGltZS5ub3cuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy50aW1lVXAgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcmVwZWF0cyAtIElmIGEga2V5IGlzIGhlbGQgZG93biB0aGlzIGhvbGRzIGRvd24gdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IGhhcyAncmVwZWF0ZWQnLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMucmVwZWF0cyA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IF9qdXN0RG93biAtIFRydWUgaWYgdGhlIGtleSBoYXMganVzdCBiZWVuIHByZXNzZWQgKE5PVEU6IHJlcXVpcmVzIHRvIGJlIHJlc2V0LCBzZWUganVzdERvd24gZ2V0dGVyKVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fanVzdERvd24gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gX2p1c3RVcCAtIFRydWUgaWYgdGhlIGtleSBoYXMganVzdCBiZWVuIHByZXNzZWQgKE5PVEU6IHJlcXVpcmVzIHRvIGJlIHJlc2V0LCBzZWUganVzdERvd24gZ2V0dGVyKVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fanVzdFVwID0gZmFsc2U7XHJcbn07XHJcblxyXG5LZXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBLZXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2tleXMvS2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFhIUlNldHRpbmdzID0gcmVxdWlyZSgnLi9YSFJTZXR0aW5ncycpO1xyXG5cclxuLy8gIFRha2VzIHR3byBYSFIgT2JqZWN0cyBhbmQgY3JlYXRlcyBhIG5ldyBvYmplY3RcclxuXHJcbi8vICBUaGUgbmV3IG9iamVjdCBpcyBiYXNlZCBvbiBnbG9iYWwgaW5pdGlhbGx5LCBidXQgYW55IHNldHRpbmcgaW5cclxuLy8gIGxvY2FsIG92ZXJyaWRlcyB0aGUgZ2xvYmFsIHZhbHVlLlxyXG5cclxudmFyIE1lcmdlWEhSU2V0dGluZ3MgPSBmdW5jdGlvbiAoZ2xvYmFsLCBsb2NhbClcclxue1xyXG4gICAgdmFyIG91dHB1dCA9IChnbG9iYWwgPT09IHVuZGVmaW5lZCkgPyBYSFJTZXR0aW5ncygpIDogT2JqZWN0LmFzc2lnbihnbG9iYWwpO1xyXG5cclxuICAgIGlmIChsb2NhbClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBzZXR0aW5nIGluIGxvY2FsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGxvY2FsW3NldHRpbmddICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dFtzZXR0aW5nXSA9IGxvY2FsW3NldHRpbmddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVhIUlNldHRpbmdzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9NZXJnZVhIUlNldHRpbmdzLmpzIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG5cclxudmFyIEpTT05GaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLmpzb25cXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF1cmwpXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aCArIGtleSArICcuanNvbic7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBGaWxlLmNhbGwodGhpcywgJ2pzb24nLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncyk7XHJcbn07XHJcblxyXG5KU09ORmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcclxuSlNPTkZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSlNPTkZpbGU7XHJcblxyXG5KU09ORmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IEpTT04ucGFyc2UodGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0KTtcclxuXHJcbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICBjYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSlNPTkZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvSlNPTkZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL0pTT05GaWxlLmpzIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG52YXIgUGFyc2VYTUwgPSByZXF1aXJlKCcuLi8uLi9kb20vUGFyc2VYTUwnKTtcclxuXHJcbnZhciBYTUxGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLnhtbFxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy54bWwnO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmlsZS5jYWxsKHRoaXMsICd4bWwnLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncyk7XHJcbn07XHJcblxyXG5YTUxGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5YTUxGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhNTEZpbGU7XHJcblxyXG5YTUxGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gUGFyc2VYTUwodGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0KTtcclxuXHJcbiAgICBpZiAodGhpcy5kYXRhID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWE1MRmlsZTogSW52YWxpZCBYTUwnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICBjYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWE1MRmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzIiwidmFyIEZhY3RvcmlhbCA9IHJlcXVpcmUoJy4vRmFjdG9yaWFsJyk7XHJcblxyXG52YXIgQmVybnN0ZWluID0gZnVuY3Rpb24gKG4sIGkpXHJcbntcclxuICAgIHJldHVybiBGYWN0b3JpYWwobikgLyBGYWN0b3JpYWwoaSkgLyBGYWN0b3JpYWwobiAtIGkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCZXJuc3RlaW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQmVybnN0ZWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9CZXJuc3RlaW4uanMiLCJ2YXIgQ2F0bXVsbFJvbSA9IGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgdClcclxue1xyXG4gICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41LCB2MSA9IChwMyAtIHAxKSAqIDAuNSwgdDIgPSB0ICogdCwgdDMgPSB0ICogdDI7XHJcblxyXG4gICAgcmV0dXJuICgyICogcDEgLSAyICogcDIgKyB2MCArIHYxKSAqIHQzICsgKC0zICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYXRtdWxsUm9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0NhdG11bGxSb20uanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBGb3JjZSBhIHZhbHVlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBieSBjbGFtcGluZyBpdCB0byB0aGUgcmFuZ2UgYG1pbmAsIGBtYXhgLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuTWF0aCNjbGFtcFxyXG4qIEBwYXJhbSB7ZmxvYXR9IHYgLSBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZC5cclxuKiBAcGFyYW0ge2Zsb2F0fSBtaW4gLSBUaGUgbWluaW11bSBib3VuZHMuXHJcbiogQHBhcmFtIHtmbG9hdH0gbWF4IC0gVGhlIG1heGltdW0gYm91bmRzLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGNsYW1wZWQgdmFsdWUuXHJcbiovXHJcbnZhciBDbGFtcCA9IGZ1bmN0aW9uICh2LCBtaW4sIG1heClcclxue1xyXG4gICAgaWYgKHYgPCBtaW4pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG1pbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1heCA8IHYpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG1heDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xhbXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQ2xhbXAuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmFjdG9yaWFsID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlcyA9IHZhbHVlO1xyXG5cclxuICAgIHdoaWxlICgtLXZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJlcyAqPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3JpYWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRmFjdG9yaWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpbmVhciA9IGZ1bmN0aW9uIChwMCwgcDEsIHQpXHJcbntcclxuICAgIHJldHVybiAocDEgLSBwMCkgKiB0ICsgcDA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9MaW5lYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm91bmRBd2F5RnJvbVplcm8gPSBmdW5jdGlvbiAodmFsdWUpXHJcbntcclxuICAgIC8vIFwiT3Bwb3NpdGVcIiBvZiB0cnVuY2F0ZS5cclxuICAgIHJldHVybiAodmFsdWUgPiAwKSA/IE1hdGguY2VpbCh2YWx1ZSkgOiBNYXRoLmZsb29yKHZhbHVlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm91bmRBd2F5RnJvbVplcm87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvUm91bmRBd2F5RnJvbVplcm8uanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTm9ybWFsaXplID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICBhbmdsZSA9IGFuZ2xlICUgKDIgKiBNYXRoLlBJKTtcclxuXHJcbiAgICBpZiAoYW5nbGUgPj0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlICsgMiAqIE1hdGguUEk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbGl6ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9Ob3JtYWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWF0aFdyYXAgPSByZXF1aXJlKCcuLi9XcmFwJyk7XHJcblxyXG52YXIgV3JhcCA9IGZ1bmN0aW9uIChhbmdsZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGhXcmFwKGFuZ2xlLCAtTWF0aC5QSSwgTWF0aC5QSSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvV3JhcC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvYW5nbGUvV3JhcC5qcyIsInZhciBXcmFwID0gcmVxdWlyZSgnLi4vV3JhcCcpO1xyXG5cclxudmFyIFdyYXBEZWdyZWVzID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICByZXR1cm4gV3JhcChhbmdsZSwgLTE4MCwgMTgwKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV3JhcERlZ3JlZXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL1dyYXBEZWdyZWVzLmpzIiwidmFyIERpc3RhbmNlQmV0d2VlbiA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Milcclxue1xyXG4gICAgdmFyIGR4ID0geDEgLSB4MjtcclxuICAgIHZhciBkeSA9IHkxIC0geTI7XHJcblxyXG4gICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlQmV0d2VlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZUJldHdlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGluZWFyID0gcmVxdWlyZSgnLi4vTGluZWFyJyk7XHJcblxyXG52YXIgTGluZWFySW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2LCBrKVxyXG57XHJcbiAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcclxuICAgIHZhciBmID0gbSAqIGs7XHJcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XHJcblxyXG4gICAgaWYgKGsgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBMaW5lYXIodlswXSwgdlsxXSwgZik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGsgPiAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBMaW5lYXIodlttXSwgdlttIC0gMV0sIG0gLSBmKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTGluZWFyKHZbaV0sIHZbKGkgKyAxID4gbSkgPyBtIDogaSArIDFdLCBmIC0gaSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhckludGVycG9sYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0xpbmVhckludGVycG9sYXRpb24uanMiLCIvKipcclxuKiBDaGVja3MgaWYgdGhlIGdpdmVuIGRpbWVuc2lvbnMgbWFrZSBhIHBvd2VyIG9mIHR3byB0ZXh0dXJlLlxyXG4qIFxyXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjaXNQb3dlck9mVHdvXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHRvIGNoZWNrLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IHRvIGNoZWNrLlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGEgcG93ZXIgb2YgdHdvLlxyXG4qL1xyXG52YXIgSXNTaXplUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICByZXR1cm4gKHdpZHRoID4gMCAmJiAod2lkdGggJiAod2lkdGggLSAxKSkgPT09IDAgJiYgaGVpZ2h0ID4gMCAmJiAoaGVpZ2h0ICYgKGhlaWdodCAtIDEpKSA9PT0gMCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElzU2l6ZVBvd2VyT2ZUd287XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuV29ybGRgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHRoZSB3b3JsZCBjb21wb3NpdGUuXHJcbiogQSBgTWF0dGVyLldvcmxkYCBpcyBhIGBNYXR0ZXIuQ29tcG9zaXRlYCBib2R5LCB3aGljaCBpcyBhIGNvbGxlY3Rpb24gb2YgYE1hdHRlci5Cb2R5YCwgYE1hdHRlci5Db25zdHJhaW50YCBhbmQgb3RoZXIgYE1hdHRlci5Db21wb3NpdGVgLlxyXG4qIEEgYE1hdHRlci5Xb3JsZGAgaGFzIGEgZmV3IGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbmNsdWRpbmcgYGdyYXZpdHlgIGFuZCBgYm91bmRzYC5cclxuKiBJdCBpcyBpbXBvcnRhbnQgdG8gdXNlIHRoZSBmdW5jdGlvbnMgaW4gdGhlIGBNYXR0ZXIuQ29tcG9zaXRlYCBtb2R1bGUgdG8gbW9kaWZ5IHRoZSB3b3JsZCBjb21wb3NpdGUsIHJhdGhlciB0aGFuIGRpcmVjdGx5IG1vZGlmeWluZyBpdHMgcHJvcGVydGllcy5cclxuKiBUaGVyZSBhcmUgYWxzbyBhIGZldyBtZXRob2RzIGhlcmUgdGhhdCBhbGlhcyB0aG9zZSBpbiBgTWF0dGVyLkNvbXBvc2l0ZWAgZm9yIGVhc2llciByZWFkYWJpbGl0eS5cclxuKlxyXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXHJcbipcclxuKiBAY2xhc3MgV29ybGRcclxuKiBAZXh0ZW5kcyBDb21wb3NpdGVcclxuKi9cclxuXHJcbnZhciBXb3JsZCA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXb3JsZDtcclxuXHJcbnZhciBDb21wb3NpdGUgPSByZXF1aXJlKCcuL0NvbXBvc2l0ZScpO1xyXG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnQvQ29uc3RyYWludCcpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgd29ybGQgY29tcG9zaXRlLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cclxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7d29ybGR9IEEgbmV3IHdvcmxkXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgY29tcG9zaXRlID0gQ29tcG9zaXRlLmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIGxhYmVsOiAnV29ybGQnLFxyXG4gICAgICAgICAgICBncmF2aXR5OiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMSxcclxuICAgICAgICAgICAgICAgIHNjYWxlOiAwLjAwMVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBib3VuZHM6IHsgXHJcbiAgICAgICAgICAgICAgICBtaW46IHsgeDogLUluZmluaXR5LCB5OiAtSW5maW5pdHkgfSwgXHJcbiAgICAgICAgICAgICAgICBtYXg6IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5IH0gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKGNvbXBvc2l0ZSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdyYXZpdHkgdG8gYXBwbHkgb24gdGhlIHdvcmxkLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XHJcbiAgICAgKiBAdHlwZSBvYmplY3RcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdyYXZpdHkgeCBjb21wb25lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHkueFxyXG4gICAgICogQHR5cGUgb2JqZWN0XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBncmF2aXR5IHkgY29tcG9uZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5LnlcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ3Jhdml0eSBzY2FsZSBmYWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHkuc2NhbGVcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICogQGRlZmF1bHQgMC4wMDFcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgQm91bmRzYCBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSB3b3JsZCBib3VuZHMgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGJvdW5kc1xyXG4gICAgICogQHR5cGUgYm91bmRzXHJcbiAgICAgKiBAZGVmYXVsdCB7IG1pbjogeyB4OiAtSW5maW5pdHksIHk6IC1JbmZpbml0eSB9LCBtYXg6IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5IH0gfVxyXG4gICAgICovXHJcblxyXG4gICAgLy8gV29ybGQgaXMgYSBDb21wb3NpdGUgYm9keVxyXG4gICAgLy8gc2VlIHNyYy9tb2R1bGUvT3V0cm8uanMgZm9yIHRoZXNlIGFsaWFzZXM6XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQW4gYWxpYXMgZm9yIENvbXBvc2l0ZS5jbGVhclxyXG4gICAgICogQG1ldGhvZCBjbGVhclxyXG4gICAgICogQHBhcmFtIHt3b3JsZH0gd29ybGRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFN0YXRpY1xyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhbGlhcyBmb3IgQ29tcG9zaXRlLmFkZFxyXG4gICAgICogQG1ldGhvZCBhZGRDb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7d29ybGR9IHdvcmxkXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcmV0dXJuIHt3b3JsZH0gVGhlIG9yaWdpbmFsIHdvcmxkIHdpdGggdGhlIG9iamVjdHMgZnJvbSBjb21wb3NpdGUgYWRkZWRcclxuICAgICAqL1xyXG4gICAgXHJcbiAgICAgLyoqXHJcbiAgICAgICogQW4gYWxpYXMgZm9yIENvbXBvc2l0ZS5hZGRCb2R5XHJcbiAgICAgICogQG1ldGhvZCBhZGRCb2R5XHJcbiAgICAgICogQHBhcmFtIHt3b3JsZH0gd29ybGRcclxuICAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAgKiBAcmV0dXJuIHt3b3JsZH0gVGhlIG9yaWdpbmFsIHdvcmxkIHdpdGggdGhlIGJvZHkgYWRkZWRcclxuICAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgICogQW4gYWxpYXMgZm9yIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50XHJcbiAgICAgICogQG1ldGhvZCBhZGRDb25zdHJhaW50XHJcbiAgICAgICogQHBhcmFtIHt3b3JsZH0gd29ybGRcclxuICAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcclxuICAgICAgKiBAcmV0dXJuIHt3b3JsZH0gVGhlIG9yaWdpbmFsIHdvcmxkIHdpdGggdGhlIGNvbnN0cmFpbnQgYWRkZWRcclxuICAgICAgKi9cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvV29ybGQuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9ib2R5L1dvcmxkLmpzIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuQ29udGFjdGAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgY29sbGlzaW9uIGNvbnRhY3RzLlxyXG4qXHJcbiogQGNsYXNzIENvbnRhY3RcclxuKi9cclxuXHJcbnZhciBDb250YWN0ID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3Q7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbnRhY3QuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHt2ZXJ0ZXh9IHZlcnRleFxyXG4gICAgICogQHJldHVybiB7Y29udGFjdH0gQSBuZXcgY29udGFjdFxyXG4gICAgICovXHJcbiAgICBDb250YWN0LmNyZWF0ZSA9IGZ1bmN0aW9uKHZlcnRleCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBDb250YWN0LmlkKHZlcnRleCksXHJcbiAgICAgICAgICAgIHZlcnRleDogdmVydGV4LFxyXG4gICAgICAgICAgICBub3JtYWxJbXB1bHNlOiAwLFxyXG4gICAgICAgICAgICB0YW5nZW50SW1wdWxzZTogMFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIGNvbnRhY3QgaWQuXHJcbiAgICAgKiBAbWV0aG9kIGlkXHJcbiAgICAgKiBAcGFyYW0ge3ZlcnRleH0gdmVydGV4XHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFVuaXF1ZSBjb250YWN0SURcclxuICAgICAqL1xyXG4gICAgQ29udGFjdC5pZCA9IGZ1bmN0aW9uKHZlcnRleCkge1xyXG4gICAgICAgIHJldHVybiB2ZXJ0ZXguYm9keS5pZCArICdfJyArIHZlcnRleC5pbmRleDtcclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vQ29udGFjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlBhaXJzYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gcGFpciBzZXRzLlxyXG4qXHJcbiogQGNsYXNzIFBhaXJzXHJcbiovXHJcblxyXG52YXIgUGFpcnMgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFpcnM7XHJcblxyXG52YXIgUGFpciA9IHJlcXVpcmUoJy4vUGFpcicpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuICAgIFxyXG4gICAgdmFyIF9wYWlyTWF4SWRsZUxpZmUgPSAxMDAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYWlycyBzdHJ1Y3R1cmUuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4ge3BhaXJzfSBBIG5ldyBwYWlycyBzdHJ1Y3R1cmVcclxuICAgICAqL1xyXG4gICAgUGFpcnMuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKHsgXHJcbiAgICAgICAgICAgIHRhYmxlOiB7fSxcclxuICAgICAgICAgICAgbGlzdDogW10sXHJcbiAgICAgICAgICAgIGNvbGxpc2lvblN0YXJ0OiBbXSxcclxuICAgICAgICAgICAgY29sbGlzaW9uQWN0aXZlOiBbXSxcclxuICAgICAgICAgICAgY29sbGlzaW9uRW5kOiBbXVxyXG4gICAgICAgIH0sIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgcGFpcnMgZ2l2ZW4gYSBsaXN0IG9mIGNvbGxpc2lvbnMuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhaXJzXHJcbiAgICAgKiBAcGFyYW0ge2NvbGxpc2lvbltdfSBjb2xsaXNpb25zXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXHJcbiAgICAgKi9cclxuICAgIFBhaXJzLnVwZGF0ZSA9IGZ1bmN0aW9uKHBhaXJzLCBjb2xsaXNpb25zLCB0aW1lc3RhbXApIHtcclxuICAgICAgICB2YXIgcGFpcnNMaXN0ID0gcGFpcnMubGlzdCxcclxuICAgICAgICAgICAgcGFpcnNUYWJsZSA9IHBhaXJzLnRhYmxlLFxyXG4gICAgICAgICAgICBjb2xsaXNpb25TdGFydCA9IHBhaXJzLmNvbGxpc2lvblN0YXJ0LFxyXG4gICAgICAgICAgICBjb2xsaXNpb25FbmQgPSBwYWlycy5jb2xsaXNpb25FbmQsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkFjdGl2ZSA9IHBhaXJzLmNvbGxpc2lvbkFjdGl2ZSxcclxuICAgICAgICAgICAgYWN0aXZlUGFpcklkcyA9IFtdLFxyXG4gICAgICAgICAgICBjb2xsaXNpb24sXHJcbiAgICAgICAgICAgIHBhaXJJZCxcclxuICAgICAgICAgICAgcGFpcixcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgLy8gY2xlYXIgY29sbGlzaW9uIHN0YXRlIGFycmF5cywgYnV0IG1haW50YWluIG9sZCByZWZlcmVuY2VcclxuICAgICAgICBjb2xsaXNpb25TdGFydC5sZW5ndGggPSAwO1xyXG4gICAgICAgIGNvbGxpc2lvbkVuZC5sZW5ndGggPSAwO1xyXG4gICAgICAgIGNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sbGlzaW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBjb2xsaXNpb25zW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbi5jb2xsaWRlZCkge1xyXG4gICAgICAgICAgICAgICAgcGFpcklkID0gUGFpci5pZChjb2xsaXNpb24uYm9keUEsIGNvbGxpc2lvbi5ib2R5Qik7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVQYWlySWRzLnB1c2gocGFpcklkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwYWlyID0gcGFpcnNUYWJsZVtwYWlySWRdO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAocGFpcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhaXIgYWxyZWFkeSBleGlzdHMgKGJ1dCBtYXkgb3IgbWF5IG5vdCBiZSBhY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXIuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFpciBleGlzdHMgYW5kIGlzIGFjdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25BY3RpdmUucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWlyIGV4aXN0cyBidXQgd2FzIGluYWN0aXZlLCBzbyBhIGNvbGxpc2lvbiBoYXMganVzdCBzdGFydGVkIGFnYWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvblN0YXJ0LnB1c2gocGFpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhaXJcclxuICAgICAgICAgICAgICAgICAgICBQYWlyLnVwZGF0ZShwYWlyLCBjb2xsaXNpb24sIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhaXIgZGlkIG5vdCBleGlzdCwgY3JlYXRlIGEgbmV3IHBhaXJcclxuICAgICAgICAgICAgICAgICAgICBwYWlyID0gUGFpci5jcmVhdGUoY29sbGlzaW9uLCB0aW1lc3RhbXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXJzVGFibGVbcGFpcklkXSA9IHBhaXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdGhlIG5ldyBwYWlyXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uU3RhcnQucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWlyc0xpc3QucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZGVhY3RpdmF0ZSBwcmV2aW91c2x5IGFjdGl2ZSBwYWlycyB0aGF0IGFyZSBub3cgaW5hY3RpdmVcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnNMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc0xpc3RbaV07XHJcbiAgICAgICAgICAgIGlmIChwYWlyLmlzQWN0aXZlICYmIENvbW1vbi5pbmRleE9mKGFjdGl2ZVBhaXJJZHMsIHBhaXIuaWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgUGFpci5zZXRBY3RpdmUocGFpciwgZmFsc2UsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25FbmQucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgYW5kIHJlbW92ZXMgcGFpcnMgdGhhdCBoYXZlIGJlZW4gaW5hY3RpdmUgZm9yIGEgc2V0IGFtb3VudCBvZiB0aW1lLlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVPbGRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYWlyc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxyXG4gICAgICovXHJcbiAgICBQYWlycy5yZW1vdmVPbGQgPSBmdW5jdGlvbihwYWlycywgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgdmFyIHBhaXJzTGlzdCA9IHBhaXJzLmxpc3QsXHJcbiAgICAgICAgICAgIHBhaXJzVGFibGUgPSBwYWlycy50YWJsZSxcclxuICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlID0gW10sXHJcbiAgICAgICAgICAgIHBhaXIsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbixcclxuICAgICAgICAgICAgcGFpckluZGV4LFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnNMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc0xpc3RbaV07XHJcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gbmV2ZXIgcmVtb3ZlIHNsZWVwaW5nIHBhaXJzXHJcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb24uYm9keUEuaXNTbGVlcGluZyB8fCBjb2xsaXNpb24uYm9keUIuaXNTbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgcGFpci50aW1lVXBkYXRlZCA9IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBwYWlyIGlzIGluYWN0aXZlIGZvciB0b28gbG9uZywgbWFyayBpdCB0byBiZSByZW1vdmVkXHJcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgLSBwYWlyLnRpbWVVcGRhdGVkID4gX3BhaXJNYXhJZGxlTGlmZSkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBtYXJrZWQgcGFpcnNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5kZXhlc1RvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXJJbmRleCA9IGluZGV4ZXNUb1JlbW92ZVtpXSAtIGk7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc0xpc3RbcGFpckluZGV4XTtcclxuICAgICAgICAgICAgZGVsZXRlIHBhaXJzVGFibGVbcGFpci5pZF07XHJcbiAgICAgICAgICAgIHBhaXJzTGlzdC5zcGxpY2UocGFpckluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBnaXZlbiBwYWlycyBzdHJ1Y3R1cmUuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgKiBAcGFyYW0ge3BhaXJzfSBwYWlyc1xyXG4gICAgICogQHJldHVybiB7cGFpcnN9IHBhaXJzXHJcbiAgICAgKi9cclxuICAgIFBhaXJzLmNsZWFyID0gZnVuY3Rpb24ocGFpcnMpIHtcclxuICAgICAgICBwYWlycy50YWJsZSA9IHt9O1xyXG4gICAgICAgIHBhaXJzLmxpc3QubGVuZ3RoID0gMDtcclxuICAgICAgICBwYWlycy5jb2xsaXNpb25TdGFydC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHBhaXJzLmNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIHBhaXJzLmNvbGxpc2lvbkVuZC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJldHVybiBwYWlycztcclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUGFpcnMuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUGFpcnMuanMiLCIvKipcclxuKiBUaGUgYE1hdHRlci5SZXNvbHZlcmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIHJlc29sdmluZyBjb2xsaXNpb24gcGFpcnMuXHJcbipcclxuKiBAY2xhc3MgUmVzb2x2ZXJcclxuKi9cclxuXHJcbnZhciBSZXNvbHZlciA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXNvbHZlcjtcclxuXHJcbnZhciBWZXJ0aWNlcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlcnRpY2VzJyk7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICBSZXNvbHZlci5fcmVzdGluZ1RocmVzaCA9IDQ7XHJcbiAgICBSZXNvbHZlci5fcmVzdGluZ1RocmVzaFRhbmdlbnQgPSA2O1xyXG4gICAgUmVzb2x2ZXIuX3Bvc2l0aW9uRGFtcGVuID0gMC45O1xyXG4gICAgUmVzb2x2ZXIuX3Bvc2l0aW9uV2FybWluZyA9IDAuODtcclxuICAgIFJlc29sdmVyLl9mcmljdGlvbk5vcm1hbE11bHRpcGxpZXIgPSA1O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGFyZSBwYWlycyBmb3IgcG9zaXRpb24gc29sdmluZy5cclxuICAgICAqIEBtZXRob2QgcHJlU29sdmVQb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXHJcbiAgICAgKi9cclxuICAgIFJlc29sdmVyLnByZVNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihwYWlycykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBwYWlyLFxyXG4gICAgICAgICAgICBhY3RpdmVDb3VudDtcclxuXHJcbiAgICAgICAgLy8gZmluZCB0b3RhbCBjb250YWN0cyBvbiBlYWNoIGJvZHlcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBhY3RpdmVDb3VudCA9IHBhaXIuYWN0aXZlQ29udGFjdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBwYWlyLmNvbGxpc2lvbi5wYXJlbnRBLnRvdGFsQ29udGFjdHMgKz0gYWN0aXZlQ291bnQ7XHJcbiAgICAgICAgICAgIHBhaXIuY29sbGlzaW9uLnBhcmVudEIudG90YWxDb250YWN0cyArPSBhY3RpdmVDb3VudDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZCBhIHNvbHV0aW9uIGZvciBwYWlyIHBvc2l0aW9ucy5cclxuICAgICAqIEBtZXRob2Qgc29sdmVQb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlXHJcbiAgICAgKi9cclxuICAgIFJlc29sdmVyLnNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihwYWlycywgdGltZVNjYWxlKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIHBhaXIsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbixcclxuICAgICAgICAgICAgYm9keUEsXHJcbiAgICAgICAgICAgIGJvZHlCLFxyXG4gICAgICAgICAgICBub3JtYWwsXHJcbiAgICAgICAgICAgIGJvZHlCdG9BLFxyXG4gICAgICAgICAgICBjb250YWN0U2hhcmUsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZSxcclxuICAgICAgICAgICAgY29udGFjdENvdW50ID0ge30sXHJcbiAgICAgICAgICAgIHRlbXBBID0gVmVjdG9yLl90ZW1wWzBdLFxyXG4gICAgICAgICAgICB0ZW1wQiA9IFZlY3Rvci5fdGVtcFsxXSxcclxuICAgICAgICAgICAgdGVtcEMgPSBWZWN0b3IuX3RlbXBbMl0sXHJcbiAgICAgICAgICAgIHRlbXBEID0gVmVjdG9yLl90ZW1wWzNdO1xyXG5cclxuICAgICAgICAvLyBmaW5kIGltcHVsc2VzIHJlcXVpcmVkIHRvIHJlc29sdmUgcGVuZXRyYXRpb25cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlIHx8IHBhaXIuaXNTZW5zb3IpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xyXG4gICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBO1xyXG4gICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5wYXJlbnRCO1xyXG4gICAgICAgICAgICBub3JtYWwgPSBjb2xsaXNpb24ubm9ybWFsO1xyXG5cclxuICAgICAgICAgICAgLy8gZ2V0IGN1cnJlbnQgc2VwYXJhdGlvbiBiZXR3ZWVuIGJvZHkgZWRnZXMgaW52b2x2ZWQgaW4gY29sbGlzaW9uXHJcbiAgICAgICAgICAgIGJvZHlCdG9BID0gVmVjdG9yLnN1YihWZWN0b3IuYWRkKGJvZHlCLnBvc2l0aW9uSW1wdWxzZSwgYm9keUIucG9zaXRpb24sIHRlbXBBKSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3Rvci5hZGQoYm9keUEucG9zaXRpb25JbXB1bHNlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3Rvci5zdWIoYm9keUIucG9zaXRpb24sIGNvbGxpc2lvbi5wZW5ldHJhdGlvbiwgdGVtcEIpLCB0ZW1wQyksIHRlbXBEKTtcclxuXHJcbiAgICAgICAgICAgIHBhaXIuc2VwYXJhdGlvbiA9IFZlY3Rvci5kb3Qobm9ybWFsLCBib2R5QnRvQSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvciB8fCBwYWlyLnNlcGFyYXRpb24gPCAwKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcclxuICAgICAgICAgICAgYm9keUEgPSBjb2xsaXNpb24ucGFyZW50QTtcclxuICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QjtcclxuICAgICAgICAgICAgbm9ybWFsID0gY29sbGlzaW9uLm5vcm1hbDtcclxuICAgICAgICAgICAgcG9zaXRpb25JbXB1bHNlID0gKHBhaXIuc2VwYXJhdGlvbiAtIHBhaXIuc2xvcCkgKiB0aW1lU2NhbGU7XHJcblxyXG4gICAgICAgICAgICBpZiAoYm9keUEuaXNTdGF0aWMgfHwgYm9keUIuaXNTdGF0aWMpXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkltcHVsc2UgKj0gMjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICghKGJvZHlBLmlzU3RhdGljIHx8IGJvZHlBLmlzU2xlZXBpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWN0U2hhcmUgPSBSZXNvbHZlci5fcG9zaXRpb25EYW1wZW4gLyBib2R5QS50b3RhbENvbnRhY3RzO1xyXG4gICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25JbXB1bHNlLnggKz0gbm9ybWFsLnggKiBwb3NpdGlvbkltcHVsc2UgKiBjb250YWN0U2hhcmU7XHJcbiAgICAgICAgICAgICAgICBib2R5QS5wb3NpdGlvbkltcHVsc2UueSArPSBub3JtYWwueSAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCEoYm9keUIuaXNTdGF0aWMgfHwgYm9keUIuaXNTbGVlcGluZykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhY3RTaGFyZSA9IFJlc29sdmVyLl9wb3NpdGlvbkRhbXBlbiAvIGJvZHlCLnRvdGFsQ29udGFjdHM7XHJcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvbkltcHVsc2UueCAtPSBub3JtYWwueCAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcclxuICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uSW1wdWxzZS55IC09IG5vcm1hbC55ICogcG9zaXRpb25JbXB1bHNlICogY29udGFjdFNoYXJlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHBvc2l0aW9uIHJlc29sdXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIHBvc3RTb2x2ZVBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKi9cclxuICAgIFJlc29sdmVyLnBvc3RTb2x2ZVBvc2l0aW9uID0gZnVuY3Rpb24oYm9kaWVzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyByZXNldCBjb250YWN0IGNvdW50XHJcbiAgICAgICAgICAgIGJvZHkudG90YWxDb250YWN0cyA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoYm9keS5wb3NpdGlvbkltcHVsc2UueCAhPT0gMCB8fCBib2R5LnBvc2l0aW9uSW1wdWxzZS55ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYm9keSBnZW9tZXRyeVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBib2R5LnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBib2R5LnBvc2l0aW9uSW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IGJvZHkucG9zaXRpb25JbXB1bHNlLng7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi55ICs9IGJvZHkucG9zaXRpb25JbXB1bHNlLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgYm9keSB3aXRob3V0IGNoYW5naW5nIHZlbG9jaXR5XHJcbiAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ICs9IGJvZHkucG9zaXRpb25JbXB1bHNlLng7XHJcbiAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ICs9IGJvZHkucG9zaXRpb25JbXB1bHNlLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFZlY3Rvci5kb3QoYm9keS5wb3NpdGlvbkltcHVsc2UsIGJvZHkudmVsb2NpdHkpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGNhY2hlZCBpbXB1bHNlIGlmIHRoZSBib2R5IGhhcyB2ZWxvY2l0eSBhbG9uZyBpdFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkucG9zaXRpb25JbXB1bHNlLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkucG9zaXRpb25JbXB1bHNlLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3YXJtIHRoZSBuZXh0IGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkucG9zaXRpb25JbXB1bHNlLnggKj0gUmVzb2x2ZXIuX3Bvc2l0aW9uV2FybWluZztcclxuICAgICAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uSW1wdWxzZS55ICo9IFJlc29sdmVyLl9wb3NpdGlvbldhcm1pbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGFyZSBwYWlycyBmb3IgdmVsb2NpdHkgc29sdmluZy5cclxuICAgICAqIEBtZXRob2QgcHJlU29sdmVWZWxvY2l0eVxyXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXHJcbiAgICAgKi9cclxuICAgIFJlc29sdmVyLnByZVNvbHZlVmVsb2NpdHkgPSBmdW5jdGlvbihwYWlycykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBwYWlyLFxyXG4gICAgICAgICAgICBjb250YWN0cyxcclxuICAgICAgICAgICAgY29sbGlzaW9uLFxyXG4gICAgICAgICAgICBib2R5QSxcclxuICAgICAgICAgICAgYm9keUIsXHJcbiAgICAgICAgICAgIG5vcm1hbCxcclxuICAgICAgICAgICAgdGFuZ2VudCxcclxuICAgICAgICAgICAgY29udGFjdCxcclxuICAgICAgICAgICAgY29udGFjdFZlcnRleCxcclxuICAgICAgICAgICAgbm9ybWFsSW1wdWxzZSxcclxuICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UsXHJcbiAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgaW1wdWxzZSA9IFZlY3Rvci5fdGVtcFswXSxcclxuICAgICAgICAgICAgdGVtcEEgPSBWZWN0b3IuX3RlbXBbMV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSB8fCBwYWlyLmlzU2Vuc29yKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb250YWN0cyA9IHBhaXIuYWN0aXZlQ29udGFjdHM7XHJcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xyXG4gICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBO1xyXG4gICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5wYXJlbnRCO1xyXG4gICAgICAgICAgICBub3JtYWwgPSBjb2xsaXNpb24ubm9ybWFsO1xyXG4gICAgICAgICAgICB0YW5nZW50ID0gY29sbGlzaW9uLnRhbmdlbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyByZXNvbHZlIGVhY2ggY29udGFjdFxyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29udGFjdHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhY3QgPSBjb250YWN0c1tqXTtcclxuICAgICAgICAgICAgICAgIGNvbnRhY3RWZXJ0ZXggPSBjb250YWN0LnZlcnRleDtcclxuICAgICAgICAgICAgICAgIG5vcm1hbEltcHVsc2UgPSBjb250YWN0Lm5vcm1hbEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSA9IGNvbnRhY3QudGFuZ2VudEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbEltcHVsc2UgIT09IDAgfHwgdGFuZ2VudEltcHVsc2UgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0b3RhbCBpbXB1bHNlIGZyb20gY29udGFjdFxyXG4gICAgICAgICAgICAgICAgICAgIGltcHVsc2UueCA9IChub3JtYWwueCAqIG5vcm1hbEltcHVsc2UpICsgKHRhbmdlbnQueCAqIHRhbmdlbnRJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnkgPSAobm9ybWFsLnkgKiBub3JtYWxJbXB1bHNlKSArICh0YW5nZW50LnkgKiB0YW5nZW50SW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgaW1wdWxzZSBmcm9tIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShib2R5QS5pc1N0YXRpYyB8fCBib2R5QS5pc1NsZWVwaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBWZWN0b3Iuc3ViKGNvbnRhY3RWZXJ0ZXgsIGJvZHlBLnBvc2l0aW9uLCB0ZW1wQSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi54ICs9IGltcHVsc2UueCAqIGJvZHlBLmludmVyc2VNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5wb3NpdGlvblByZXYueSArPSBpbXB1bHNlLnkgKiBib2R5QS5pbnZlcnNlTWFzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEuYW5nbGVQcmV2ICs9IFZlY3Rvci5jcm9zcyhvZmZzZXQsIGltcHVsc2UpICogYm9keUEuaW52ZXJzZUluZXJ0aWE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShib2R5Qi5pc1N0YXRpYyB8fCBib2R5Qi5pc1NsZWVwaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBWZWN0b3Iuc3ViKGNvbnRhY3RWZXJ0ZXgsIGJvZHlCLnBvc2l0aW9uLCB0ZW1wQSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi54IC09IGltcHVsc2UueCAqIGJvZHlCLmludmVyc2VNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvblByZXYueSAtPSBpbXB1bHNlLnkgKiBib2R5Qi5pbnZlcnNlTWFzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuYW5nbGVQcmV2IC09IFZlY3Rvci5jcm9zcyhvZmZzZXQsIGltcHVsc2UpICogYm9keUIuaW52ZXJzZUluZXJ0aWE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgYSBzb2x1dGlvbiBmb3IgcGFpciB2ZWxvY2l0aWVzLlxyXG4gICAgICogQG1ldGhvZCBzb2x2ZVZlbG9jaXR5XHJcbiAgICAgKiBAcGFyYW0ge3BhaXJbXX0gcGFpcnNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcclxuICAgICAqL1xyXG4gICAgUmVzb2x2ZXIuc29sdmVWZWxvY2l0eSA9IGZ1bmN0aW9uKHBhaXJzLCB0aW1lU2NhbGUpIHtcclxuICAgICAgICB2YXIgdGltZVNjYWxlU3F1YXJlZCA9IHRpbWVTY2FsZSAqIHRpbWVTY2FsZSxcclxuICAgICAgICAgICAgaW1wdWxzZSA9IFZlY3Rvci5fdGVtcFswXSxcclxuICAgICAgICAgICAgdGVtcEEgPSBWZWN0b3IuX3RlbXBbMV0sXHJcbiAgICAgICAgICAgIHRlbXBCID0gVmVjdG9yLl90ZW1wWzJdLFxyXG4gICAgICAgICAgICB0ZW1wQyA9IFZlY3Rvci5fdGVtcFszXSxcclxuICAgICAgICAgICAgdGVtcEQgPSBWZWN0b3IuX3RlbXBbNF0sXHJcbiAgICAgICAgICAgIHRlbXBFID0gVmVjdG9yLl90ZW1wWzVdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSB8fCBwYWlyLmlzU2Vuc29yKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb24sXHJcbiAgICAgICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBLFxyXG4gICAgICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QixcclxuICAgICAgICAgICAgICAgIG5vcm1hbCA9IGNvbGxpc2lvbi5ub3JtYWwsXHJcbiAgICAgICAgICAgICAgICB0YW5nZW50ID0gY29sbGlzaW9uLnRhbmdlbnQsXHJcbiAgICAgICAgICAgICAgICBjb250YWN0cyA9IHBhaXIuYWN0aXZlQ29udGFjdHMsXHJcbiAgICAgICAgICAgICAgICBjb250YWN0U2hhcmUgPSAxIC8gY29udGFjdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gdXBkYXRlIGJvZHkgdmVsb2NpdGllc1xyXG4gICAgICAgICAgICBib2R5QS52ZWxvY2l0eS54ID0gYm9keUEucG9zaXRpb24ueCAtIGJvZHlBLnBvc2l0aW9uUHJldi54O1xyXG4gICAgICAgICAgICBib2R5QS52ZWxvY2l0eS55ID0gYm9keUEucG9zaXRpb24ueSAtIGJvZHlBLnBvc2l0aW9uUHJldi55O1xyXG4gICAgICAgICAgICBib2R5Qi52ZWxvY2l0eS54ID0gYm9keUIucG9zaXRpb24ueCAtIGJvZHlCLnBvc2l0aW9uUHJldi54O1xyXG4gICAgICAgICAgICBib2R5Qi52ZWxvY2l0eS55ID0gYm9keUIucG9zaXRpb24ueSAtIGJvZHlCLnBvc2l0aW9uUHJldi55O1xyXG4gICAgICAgICAgICBib2R5QS5hbmd1bGFyVmVsb2NpdHkgPSBib2R5QS5hbmdsZSAtIGJvZHlBLmFuZ2xlUHJldjtcclxuICAgICAgICAgICAgYm9keUIuYW5ndWxhclZlbG9jaXR5ID0gYm9keUIuYW5nbGUgLSBib2R5Qi5hbmdsZVByZXY7XHJcblxyXG4gICAgICAgICAgICAvLyByZXNvbHZlIGVhY2ggY29udGFjdFxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbnRhY3RzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IGNvbnRhY3RzW2pdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RWZXJ0ZXggPSBjb250YWN0LnZlcnRleCxcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRBID0gVmVjdG9yLnN1Yihjb250YWN0VmVydGV4LCBib2R5QS5wb3NpdGlvbiwgdGVtcEEpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEIgPSBWZWN0b3Iuc3ViKGNvbnRhY3RWZXJ0ZXgsIGJvZHlCLnBvc2l0aW9uLCB0ZW1wQiksXHJcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHlQb2ludEEgPSBWZWN0b3IuYWRkKGJvZHlBLnZlbG9jaXR5LCBWZWN0b3IubXVsdChWZWN0b3IucGVycChvZmZzZXRBKSwgYm9keUEuYW5ndWxhclZlbG9jaXR5KSwgdGVtcEMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCID0gVmVjdG9yLmFkZChib2R5Qi52ZWxvY2l0eSwgVmVjdG9yLm11bHQoVmVjdG9yLnBlcnAob2Zmc2V0QiksIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSksIHRlbXBEKSwgXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVWZWxvY2l0eSA9IFZlY3Rvci5zdWIodmVsb2NpdHlQb2ludEEsIHZlbG9jaXR5UG9pbnRCLCB0ZW1wRSksXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsVmVsb2NpdHkgPSBWZWN0b3IuZG90KG5vcm1hbCwgcmVsYXRpdmVWZWxvY2l0eSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRhbmdlbnRWZWxvY2l0eSA9IFZlY3Rvci5kb3QodGFuZ2VudCwgcmVsYXRpdmVWZWxvY2l0eSksXHJcbiAgICAgICAgICAgICAgICAgICAgdGFuZ2VudFNwZWVkID0gTWF0aC5hYnModGFuZ2VudFZlbG9jaXR5KSxcclxuICAgICAgICAgICAgICAgICAgICB0YW5nZW50VmVsb2NpdHlEaXJlY3Rpb24gPSBDb21tb24uc2lnbih0YW5nZW50VmVsb2NpdHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJhdyBpbXB1bHNlc1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEltcHVsc2UgPSAoMSArIHBhaXIucmVzdGl0dXRpb24pICogbm9ybWFsVmVsb2NpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsRm9yY2UgPSBDb21tb24uY2xhbXAocGFpci5zZXBhcmF0aW9uICsgbm9ybWFsVmVsb2NpdHksIDAsIDEpICogUmVzb2x2ZXIuX2ZyaWN0aW9uTm9ybWFsTXVsdGlwbGllcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb3Vsb21iIGZyaWN0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgdGFuZ2VudEltcHVsc2UgPSB0YW5nZW50VmVsb2NpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4RnJpY3Rpb24gPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGFuZ2VudFNwZWVkID4gcGFpci5mcmljdGlvbiAqIHBhaXIuZnJpY3Rpb25TdGF0aWMgKiBub3JtYWxGb3JjZSAqIHRpbWVTY2FsZVNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhGcmljdGlvbiA9IHRhbmdlbnRTcGVlZDtcclxuICAgICAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSA9IENvbW1vbi5jbGFtcChcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpci5mcmljdGlvbiAqIHRhbmdlbnRWZWxvY2l0eURpcmVjdGlvbiAqIHRpbWVTY2FsZVNxdWFyZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC1tYXhGcmljdGlvbiwgbWF4RnJpY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIG1vZGlmeSBpbXB1bHNlcyBhY2NvdW50aW5nIGZvciBtYXNzLCBpbmVydGlhIGFuZCBvZmZzZXRcclxuICAgICAgICAgICAgICAgIHZhciBvQWNOID0gVmVjdG9yLmNyb3NzKG9mZnNldEEsIG5vcm1hbCksXHJcbiAgICAgICAgICAgICAgICAgICAgb0JjTiA9IFZlY3Rvci5jcm9zcyhvZmZzZXRCLCBub3JtYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlID0gY29udGFjdFNoYXJlIC8gKGJvZHlBLmludmVyc2VNYXNzICsgYm9keUIuaW52ZXJzZU1hc3MgKyBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIG9BY04gKiBvQWNOICArIGJvZHlCLmludmVyc2VJbmVydGlhICogb0JjTiAqIG9CY04pO1xyXG5cclxuICAgICAgICAgICAgICAgIG5vcm1hbEltcHVsc2UgKj0gc2hhcmU7XHJcbiAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSAqPSBzaGFyZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgaGlnaCB2ZWxvY2l0eSBhbmQgcmVzdGluZyBjb2xsaXNpb25zIHNlcGFyYXRlbHlcclxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxWZWxvY2l0eSA8IDAgJiYgbm9ybWFsVmVsb2NpdHkgKiBub3JtYWxWZWxvY2l0eSA+IFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoICogdGltZVNjYWxlU3F1YXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZ2ggbm9ybWFsIHZlbG9jaXR5IHNvIGNsZWFyIGNhY2hlZCBjb250YWN0IG5vcm1hbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC5ub3JtYWxJbXB1bHNlID0gMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc29sdmUgcmVzdGluZyBjb2xsaXNpb24gY29uc3RyYWludHMgdXNpbmcgRXJpbiBDYXR0bydzIG1ldGhvZCAoR0RDMDgpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW1wdWxzZSBjb25zdHJhaW50IHRlbmRzIHRvIDBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdE5vcm1hbEltcHVsc2UgPSBjb250YWN0Lm5vcm1hbEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC5ub3JtYWxJbXB1bHNlID0gTWF0aC5taW4oY29udGFjdC5ub3JtYWxJbXB1bHNlICsgbm9ybWFsSW1wdWxzZSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsSW1wdWxzZSA9IGNvbnRhY3Qubm9ybWFsSW1wdWxzZSAtIGNvbnRhY3ROb3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBoaWdoIHZlbG9jaXR5IGFuZCByZXN0aW5nIGNvbGxpc2lvbnMgc2VwYXJhdGVseVxyXG4gICAgICAgICAgICAgICAgaWYgKHRhbmdlbnRWZWxvY2l0eSAqIHRhbmdlbnRWZWxvY2l0eSA+IFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoVGFuZ2VudCAqIHRpbWVTY2FsZVNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBoaWdoIHRhbmdlbnQgdmVsb2NpdHkgc28gY2xlYXIgY2FjaGVkIGNvbnRhY3QgdGFuZ2VudCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC50YW5nZW50SW1wdWxzZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbHZlIHJlc3RpbmcgY29sbGlzaW9uIGNvbnN0cmFpbnRzIHVzaW5nIEVyaW4gQ2F0dG8ncyBtZXRob2QgKEdEQzA4KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhbmdlbnQgaW1wdWxzZSB0ZW5kcyB0byAtdGFuZ2VudFNwZWVkIG9yICt0YW5nZW50U3BlZWRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdFRhbmdlbnRJbXB1bHNlID0gY29udGFjdC50YW5nZW50SW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0LnRhbmdlbnRJbXB1bHNlID0gQ29tbW9uLmNsYW1wKGNvbnRhY3QudGFuZ2VudEltcHVsc2UgKyB0YW5nZW50SW1wdWxzZSwgLW1heEZyaWN0aW9uLCBtYXhGcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UgPSBjb250YWN0LnRhbmdlbnRJbXB1bHNlIC0gY29udGFjdFRhbmdlbnRJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRvdGFsIGltcHVsc2UgZnJvbSBjb250YWN0XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlLnggPSAobm9ybWFsLnggKiBub3JtYWxJbXB1bHNlKSArICh0YW5nZW50LnggKiB0YW5nZW50SW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlLnkgPSAobm9ybWFsLnkgKiBub3JtYWxJbXB1bHNlKSArICh0YW5nZW50LnkgKiB0YW5nZW50SW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IGltcHVsc2UgZnJvbSBjb250YWN0XHJcbiAgICAgICAgICAgICAgICBpZiAoIShib2R5QS5pc1N0YXRpYyB8fCBib2R5QS5pc1NsZWVwaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi54ICs9IGltcHVsc2UueCAqIGJvZHlBLmludmVyc2VNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi55ICs9IGltcHVsc2UueSAqIGJvZHlBLmludmVyc2VNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLmFuZ2xlUHJldiArPSBWZWN0b3IuY3Jvc3Mob2Zmc2V0QSwgaW1wdWxzZSkgKiBib2R5QS5pbnZlcnNlSW5lcnRpYTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIShib2R5Qi5pc1N0YXRpYyB8fCBib2R5Qi5pc1NsZWVwaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi54IC09IGltcHVsc2UueCAqIGJvZHlCLmludmVyc2VNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi55IC09IGltcHVsc2UueSAqIGJvZHlCLmludmVyc2VNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLmFuZ2xlUHJldiAtPSBWZWN0b3IuY3Jvc3Mob2Zmc2V0QiwgaW1wdWxzZSkgKiBib2R5Qi5pbnZlcnNlSW5lcnRpYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUmVzb2x2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUmVzb2x2ZXIuanMiLCIvKipcclxuKiBUaGUgYE1hdHRlci5FbmdpbmVgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGVuZ2luZXMuXHJcbiogQW4gZW5naW5lIGlzIGEgY29udHJvbGxlciB0aGF0IG1hbmFnZXMgdXBkYXRpbmcgdGhlIHNpbXVsYXRpb24gb2YgdGhlIHdvcmxkLlxyXG4qIFNlZSBgTWF0dGVyLlJ1bm5lcmAgZm9yIGFuIG9wdGlvbmFsIGdhbWUgbG9vcCB1dGlsaXR5LlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuKlxyXG4qIEBjbGFzcyBFbmdpbmVcclxuKi9cclxuXHJcbnZhciBFbmdpbmUgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRW5naW5lO1xyXG5cclxudmFyIFdvcmxkID0gcmVxdWlyZSgnLi4vYm9keS9Xb3JsZCcpO1xyXG52YXIgU2xlZXBpbmcgPSByZXF1aXJlKCcuL1NsZWVwaW5nJyk7XHJcbnZhciBSZXNvbHZlciA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9SZXNvbHZlcicpO1xyXG52YXIgUmVuZGVyID0gcmVxdWlyZSgnLi4vcmVuZGVyL1JlbmRlcicpO1xyXG52YXIgUGFpcnMgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUGFpcnMnKTtcclxudmFyIE1ldHJpY3MgPSByZXF1aXJlKCcuL01ldHJpY3MnKTtcclxudmFyIEdyaWQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vR3JpZCcpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZSgnLi9FdmVudHMnKTtcclxudmFyIENvbXBvc2l0ZSA9IHJlcXVpcmUoJy4uL2JvZHkvQ29tcG9zaXRlJyk7XHJcbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludC9Db25zdHJhaW50Jyk7XHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuL0NvbW1vbicpO1xyXG52YXIgQm9keSA9IHJlcXVpcmUoJy4uL2JvZHkvQm9keScpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBlbmdpbmUuIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxyXG4gICAgICogQWxsIHByb3BlcnRpZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgYW5kIG1hbnkgYXJlIHByZS1jYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gb3RoZXIgcHJvcGVydGllcy5cclxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHJldHVybiB7ZW5naW5lfSBlbmdpbmVcclxuICAgICAqL1xyXG4gICAgRW5naW5lLmNyZWF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgICAgICAvLyBvcHRpb25zIG1heSBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IChhbmQgb25seSkgYXJndW1lbnRcclxuICAgICAgICBvcHRpb25zID0gQ29tbW9uLmlzRWxlbWVudChlbGVtZW50KSA/IG9wdGlvbnMgOiBlbGVtZW50O1xyXG4gICAgICAgIGVsZW1lbnQgPSBDb21tb24uaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IG51bGw7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgIGlmIChlbGVtZW50IHx8IG9wdGlvbnMucmVuZGVyKSB7XHJcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdFbmdpbmUuY3JlYXRlOiBlbmdpbmUucmVuZGVyIGlzIGRlcHJlY2F0ZWQgKHNlZSBkb2NzKScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbkl0ZXJhdGlvbnM6IDYsXHJcbiAgICAgICAgICAgIHZlbG9jaXR5SXRlcmF0aW9uczogNCxcclxuICAgICAgICAgICAgY29uc3RyYWludEl0ZXJhdGlvbnM6IDIsXHJcbiAgICAgICAgICAgIGVuYWJsZVNsZWVwaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgZXZlbnRzOiBbXSxcclxuICAgICAgICAgICAgcGx1Z2luOiB7fSxcclxuICAgICAgICAgICAgdGltaW5nOiB7XHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IDAsXHJcbiAgICAgICAgICAgICAgICB0aW1lU2NhbGU6IDFcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYnJvYWRwaGFzZToge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogR3JpZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGVuZ2luZSA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyBAZGVwcmVjYXRlZFxyXG4gICAgICAgIGlmIChlbGVtZW50IHx8IGVuZ2luZS5yZW5kZXIpIHtcclxuICAgICAgICAgICAgdmFyIHJlbmRlckRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFJlbmRlclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZW5naW5lLnJlbmRlciA9IENvbW1vbi5leHRlbmQocmVuZGVyRGVmYXVsdHMsIGVuZ2luZS5yZW5kZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQGRlcHJlY2F0ZWRcclxuICAgICAgICBpZiAoZW5naW5lLnJlbmRlciAmJiBlbmdpbmUucmVuZGVyLmNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgZW5naW5lLnJlbmRlciA9IGVuZ2luZS5yZW5kZXIuY29udHJvbGxlci5jcmVhdGUoZW5naW5lLnJlbmRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBAZGVwcmVjYXRlZFxyXG4gICAgICAgIGlmIChlbmdpbmUucmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGVuZ2luZS5yZW5kZXIuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZW5naW5lLndvcmxkID0gb3B0aW9ucy53b3JsZCB8fCBXb3JsZC5jcmVhdGUoZW5naW5lLndvcmxkKTtcclxuICAgICAgICBlbmdpbmUucGFpcnMgPSBQYWlycy5jcmVhdGUoKTtcclxuICAgICAgICBlbmdpbmUuYnJvYWRwaGFzZSA9IGVuZ2luZS5icm9hZHBoYXNlLmNvbnRyb2xsZXIuY3JlYXRlKGVuZ2luZS5icm9hZHBoYXNlKTtcclxuICAgICAgICBlbmdpbmUubWV0cmljcyA9IGVuZ2luZS5tZXRyaWNzIHx8IHsgZXh0ZW5kZWQ6IGZhbHNlIH07XHJcblxyXG4gICAgICAgIC8vIEBpZiBERUJVR1xyXG4gICAgICAgIGVuZ2luZS5tZXRyaWNzID0gTWV0cmljcy5jcmVhdGUoZW5naW5lLm1ldHJpY3MpO1xyXG4gICAgICAgIC8vIEBlbmRpZlxyXG5cclxuICAgICAgICByZXR1cm4gZW5naW5lO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBzaW11bGF0aW9uIGZvcndhcmQgaW4gdGltZSBieSBgZGVsdGFgIG1zLlxyXG4gICAgICogVGhlIGBjb3JyZWN0aW9uYCBhcmd1bWVudCBpcyBhbiBvcHRpb25hbCBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgdGltZSBjb3JyZWN0aW9uIGZhY3RvciB0byBhcHBseSB0byB0aGUgdXBkYXRlLlxyXG4gICAgICogVGhpcyBjYW4gaGVscCBpbXByb3ZlIHRoZSBhY2N1cmFjeSBvZiB0aGUgc2ltdWxhdGlvbiBpbiBjYXNlcyB3aGVyZSBgZGVsdGFgIGlzIGNoYW5naW5nIGJldHdlZW4gdXBkYXRlcy5cclxuICAgICAqIFRoZSB2YWx1ZSBvZiBgY29ycmVjdGlvbmAgaXMgZGVmaW5lZCBhcyBgZGVsdGEgLyBsYXN0RGVsdGFgLCBpLmUuIHRoZSBwZXJjZW50YWdlIGNoYW5nZSBvZiBgZGVsdGFgIG92ZXIgdGhlIGxhc3Qgc3RlcC5cclxuICAgICAqIFRoZXJlZm9yZSB0aGUgdmFsdWUgaXMgYWx3YXlzIGAxYCAobm8gY29ycmVjdGlvbikgd2hlbiBgZGVsdGFgIGNvbnN0YW50IChvciB3aGVuIG5vIGNvcnJlY3Rpb24gaXMgZGVzaXJlZCwgd2hpY2ggaXMgdGhlIGRlZmF1bHQpLlxyXG4gICAgICogU2VlIHRoZSBwYXBlciBvbiA8YSBocmVmPVwiaHR0cDovL2xvbmVzb2NrLm5ldC9hcnRpY2xlL3ZlcmxldC5odG1sXCI+VGltZSBDb3JyZWN0ZWQgVmVybGV0PC9hPiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUcmlnZ2VycyBgYmVmb3JlVXBkYXRlYCBhbmQgYGFmdGVyVXBkYXRlYCBldmVudHMuXHJcbiAgICAgKiBUcmlnZ2VycyBgY29sbGlzaW9uU3RhcnRgLCBgY29sbGlzaW9uQWN0aXZlYCBhbmQgYGNvbGxpc2lvbkVuZGAgZXZlbnRzLlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsdGE9MTYuNjY2XVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb3JyZWN0aW9uPTFdXHJcbiAgICAgKi9cclxuICAgIEVuZ2luZS51cGRhdGUgPSBmdW5jdGlvbihlbmdpbmUsIGRlbHRhLCBjb3JyZWN0aW9uKSB7XHJcbiAgICAgICAgZGVsdGEgPSBkZWx0YSB8fCAxMDAwIC8gNjA7XHJcbiAgICAgICAgY29ycmVjdGlvbiA9IGNvcnJlY3Rpb24gfHwgMTtcclxuXHJcbiAgICAgICAgdmFyIHdvcmxkID0gZW5naW5lLndvcmxkLFxyXG4gICAgICAgICAgICB0aW1pbmcgPSBlbmdpbmUudGltaW5nLFxyXG4gICAgICAgICAgICBicm9hZHBoYXNlID0gZW5naW5lLmJyb2FkcGhhc2UsXHJcbiAgICAgICAgICAgIGJyb2FkcGhhc2VQYWlycyA9IFtdLFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICAvLyBpbmNyZW1lbnQgdGltZXN0YW1wXHJcbiAgICAgICAgdGltaW5nLnRpbWVzdGFtcCArPSBkZWx0YSAqIHRpbWluZy50aW1lU2NhbGU7XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBldmVudCBvYmplY3RcclxuICAgICAgICB2YXIgZXZlbnQgPSB7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltaW5nLnRpbWVzdGFtcFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2JlZm9yZVVwZGF0ZScsIGV2ZW50KTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IGxpc3RzIG9mIGFsbCBib2RpZXMgYW5kIGNvbnN0cmFpbnRzLCBubyBtYXR0ZXIgd2hhdCBjb21wb3NpdGVzIHRoZXkgYXJlIGluXHJcbiAgICAgICAgdmFyIGFsbEJvZGllcyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMod29ybGQpLFxyXG4gICAgICAgICAgICBhbGxDb25zdHJhaW50cyA9IENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyh3b3JsZCk7XHJcblxyXG4gICAgICAgIC8vIEBpZiBERUJVR1xyXG4gICAgICAgIC8vIHJlc2V0IG1ldHJpY3MgbG9nZ2luZ1xyXG4gICAgICAgIE1ldHJpY3MucmVzZXQoZW5naW5lLm1ldHJpY3MpO1xyXG4gICAgICAgIC8vIEBlbmRpZlxyXG5cclxuICAgICAgICAvLyBpZiBzbGVlcGluZyBlbmFibGVkLCBjYWxsIHRoZSBzbGVlcGluZyBjb250cm9sbGVyXHJcbiAgICAgICAgaWYgKGVuZ2luZS5lbmFibGVTbGVlcGluZylcclxuICAgICAgICAgICAgU2xlZXBpbmcudXBkYXRlKGFsbEJvZGllcywgdGltaW5nLnRpbWVTY2FsZSk7XHJcblxyXG4gICAgICAgIC8vIGFwcGxpZXMgZ3Jhdml0eSB0byBhbGwgYm9kaWVzXHJcbiAgICAgICAgX2JvZGllc0FwcGx5R3Jhdml0eShhbGxCb2RpZXMsIHdvcmxkLmdyYXZpdHkpO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgYWxsIGJvZHkgcG9zaXRpb24gYW5kIHJvdGF0aW9uIGJ5IGludGVncmF0aW9uXHJcbiAgICAgICAgX2JvZGllc1VwZGF0ZShhbGxCb2RpZXMsIGRlbHRhLCB0aW1pbmcudGltZVNjYWxlLCBjb3JyZWN0aW9uLCB3b3JsZC5ib3VuZHMpO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgYWxsIGNvbnN0cmFpbnRzXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZ2luZS5jb25zdHJhaW50SXRlcmF0aW9uczsgaSsrKSB7XHJcbiAgICAgICAgICAgIENvbnN0cmFpbnQuc29sdmVBbGwoYWxsQ29uc3RyYWludHMsIHRpbWluZy50aW1lU2NhbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDb25zdHJhaW50LnBvc3RTb2x2ZUFsbChhbGxCb2RpZXMpO1xyXG5cclxuICAgICAgICAvLyBicm9hZHBoYXNlIHBhc3M6IGZpbmQgcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlyc1xyXG4gICAgICAgIGlmIChicm9hZHBoYXNlLmNvbnRyb2xsZXIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHdvcmxkIGlzIGRpcnR5LCB3ZSBtdXN0IGZsdXNoIHRoZSB3aG9sZSBncmlkXHJcbiAgICAgICAgICAgIGlmICh3b3JsZC5pc01vZGlmaWVkKVxyXG4gICAgICAgICAgICAgICAgYnJvYWRwaGFzZS5jb250cm9sbGVyLmNsZWFyKGJyb2FkcGhhc2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBncmlkIGJ1Y2tldHMgYmFzZWQgb24gY3VycmVudCBib2RpZXNcclxuICAgICAgICAgICAgYnJvYWRwaGFzZS5jb250cm9sbGVyLnVwZGF0ZShicm9hZHBoYXNlLCBhbGxCb2RpZXMsIGVuZ2luZSwgd29ybGQuaXNNb2RpZmllZCk7XHJcbiAgICAgICAgICAgIGJyb2FkcGhhc2VQYWlycyA9IGJyb2FkcGhhc2UucGFpcnNMaXN0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBubyBicm9hZHBoYXNlIHNldCwgd2UganVzdCBwYXNzIGFsbCBib2RpZXNcclxuICAgICAgICAgICAgYnJvYWRwaGFzZVBhaXJzID0gYWxsQm9kaWVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2xlYXIgYWxsIGNvbXBvc2l0ZSBtb2RpZmllZCBmbGFnc1xyXG4gICAgICAgIGlmICh3b3JsZC5pc01vZGlmaWVkKSB7XHJcbiAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZCh3b3JsZCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG5hcnJvd3BoYXNlIHBhc3M6IGZpbmQgYWN0dWFsIGNvbGxpc2lvbnMsIHRoZW4gY3JlYXRlIG9yIHVwZGF0ZSBjb2xsaXNpb24gcGFpcnNcclxuICAgICAgICB2YXIgY29sbGlzaW9ucyA9IGJyb2FkcGhhc2UuZGV0ZWN0b3IoYnJvYWRwaGFzZVBhaXJzLCBlbmdpbmUpO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgY29sbGlzaW9uIHBhaXJzXHJcbiAgICAgICAgdmFyIHBhaXJzID0gZW5naW5lLnBhaXJzLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSB0aW1pbmcudGltZXN0YW1wO1xyXG4gICAgICAgIFBhaXJzLnVwZGF0ZShwYWlycywgY29sbGlzaW9ucywgdGltZXN0YW1wKTtcclxuICAgICAgICBQYWlycy5yZW1vdmVPbGQocGFpcnMsIHRpbWVzdGFtcCk7XHJcblxyXG4gICAgICAgIC8vIHdha2UgdXAgYm9kaWVzIGludm9sdmVkIGluIGNvbGxpc2lvbnNcclxuICAgICAgICBpZiAoZW5naW5lLmVuYWJsZVNsZWVwaW5nKVxyXG4gICAgICAgICAgICBTbGVlcGluZy5hZnRlckNvbGxpc2lvbnMocGFpcnMubGlzdCwgdGltaW5nLnRpbWVTY2FsZSk7XHJcblxyXG4gICAgICAgIC8vIHRyaWdnZXIgY29sbGlzaW9uIGV2ZW50c1xyXG4gICAgICAgIGlmIChwYWlycy5jb2xsaXNpb25TdGFydC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdjb2xsaXNpb25TdGFydCcsIHsgcGFpcnM6IHBhaXJzLmNvbGxpc2lvblN0YXJ0IH0pO1xyXG5cclxuICAgICAgICAvLyBpdGVyYXRpdmVseSByZXNvbHZlIHBvc2l0aW9uIGJldHdlZW4gY29sbGlzaW9uc1xyXG4gICAgICAgIFJlc29sdmVyLnByZVNvbHZlUG9zaXRpb24ocGFpcnMubGlzdCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZ2luZS5wb3NpdGlvbkl0ZXJhdGlvbnM7IGkrKykge1xyXG4gICAgICAgICAgICBSZXNvbHZlci5zb2x2ZVBvc2l0aW9uKHBhaXJzLmxpc3QsIHRpbWluZy50aW1lU2NhbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBSZXNvbHZlci5wb3N0U29sdmVQb3NpdGlvbihhbGxCb2RpZXMpO1xyXG5cclxuICAgICAgICAvLyBpdGVyYXRpdmVseSByZXNvbHZlIHZlbG9jaXR5IGJldHdlZW4gY29sbGlzaW9uc1xyXG4gICAgICAgIFJlc29sdmVyLnByZVNvbHZlVmVsb2NpdHkocGFpcnMubGlzdCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZ2luZS52ZWxvY2l0eUl0ZXJhdGlvbnM7IGkrKykge1xyXG4gICAgICAgICAgICBSZXNvbHZlci5zb2x2ZVZlbG9jaXR5KHBhaXJzLmxpc3QsIHRpbWluZy50aW1lU2NhbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdHJpZ2dlciBjb2xsaXNpb24gZXZlbnRzXHJcbiAgICAgICAgaWYgKHBhaXJzLmNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdjb2xsaXNpb25BY3RpdmUnLCB7IHBhaXJzOiBwYWlycy5jb2xsaXNpb25BY3RpdmUgfSk7XHJcblxyXG4gICAgICAgIGlmIChwYWlycy5jb2xsaXNpb25FbmQubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnY29sbGlzaW9uRW5kJywgeyBwYWlyczogcGFpcnMuY29sbGlzaW9uRW5kIH0pO1xyXG5cclxuICAgICAgICAvLyBAaWYgREVCVUdcclxuICAgICAgICAvLyB1cGRhdGUgbWV0cmljcyBsb2dcclxuICAgICAgICBNZXRyaWNzLnVwZGF0ZShlbmdpbmUubWV0cmljcywgZW5naW5lKTtcclxuICAgICAgICAvLyBAZW5kaWZcclxuXHJcbiAgICAgICAgLy8gY2xlYXIgZm9yY2UgYnVmZmVyc1xyXG4gICAgICAgIF9ib2RpZXNDbGVhckZvcmNlcyhhbGxCb2RpZXMpO1xyXG5cclxuICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdhZnRlclVwZGF0ZScsIGV2ZW50KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVuZ2luZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogTWVyZ2VzIHR3byBlbmdpbmVzIGJ5IGtlZXBpbmcgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYGVuZ2luZUFgIGJ1dCByZXBsYWNpbmcgdGhlIHdvcmxkIHdpdGggdGhlIG9uZSBmcm9tIGBlbmdpbmVCYC5cclxuICAgICAqIEBtZXRob2QgbWVyZ2VcclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVBXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lQlxyXG4gICAgICovXHJcbiAgICBFbmdpbmUubWVyZ2UgPSBmdW5jdGlvbihlbmdpbmVBLCBlbmdpbmVCKSB7XHJcbiAgICAgICAgQ29tbW9uLmV4dGVuZChlbmdpbmVBLCBlbmdpbmVCKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZW5naW5lQi53b3JsZCkge1xyXG4gICAgICAgICAgICBlbmdpbmVBLndvcmxkID0gZW5naW5lQi53b3JsZDtcclxuXHJcbiAgICAgICAgICAgIEVuZ2luZS5jbGVhcihlbmdpbmVBKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBib2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGVuZ2luZUEud29ybGQpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGJvZHkuaWQgPSBDb21tb24ubmV4dElkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBlbmdpbmUgaW5jbHVkaW5nIHRoZSB3b3JsZCwgcGFpcnMgYW5kIGJyb2FkcGhhc2UuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKi9cclxuICAgIEVuZ2luZS5jbGVhciA9IGZ1bmN0aW9uKGVuZ2luZSkge1xyXG4gICAgICAgIHZhciB3b3JsZCA9IGVuZ2luZS53b3JsZDtcclxuICAgICAgICBcclxuICAgICAgICBQYWlycy5jbGVhcihlbmdpbmUucGFpcnMpO1xyXG5cclxuICAgICAgICB2YXIgYnJvYWRwaGFzZSA9IGVuZ2luZS5icm9hZHBoYXNlO1xyXG4gICAgICAgIGlmIChicm9hZHBoYXNlLmNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgdmFyIGJvZGllcyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMod29ybGQpO1xyXG4gICAgICAgICAgICBicm9hZHBoYXNlLmNvbnRyb2xsZXIuY2xlYXIoYnJvYWRwaGFzZSk7XHJcbiAgICAgICAgICAgIGJyb2FkcGhhc2UuY29udHJvbGxlci51cGRhdGUoYnJvYWRwaGFzZSwgYm9kaWVzLCBlbmdpbmUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBaZXJvZXMgdGhlIGBib2R5LmZvcmNlYCBhbmQgYGJvZHkudG9ycXVlYCBmb3JjZSBidWZmZXJzLlxyXG4gICAgICogQG1ldGhvZCBib2RpZXNDbGVhckZvcmNlc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqL1xyXG4gICAgdmFyIF9ib2RpZXNDbGVhckZvcmNlcyA9IGZ1bmN0aW9uKGJvZGllcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVzZXQgZm9yY2UgYnVmZmVyc1xyXG4gICAgICAgICAgICBib2R5LmZvcmNlLnggPSAwO1xyXG4gICAgICAgICAgICBib2R5LmZvcmNlLnkgPSAwO1xyXG4gICAgICAgICAgICBib2R5LnRvcnF1ZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5cyBhIG1hc3MgZGVwZW5kYW50IGZvcmNlIHRvIGFsbCBnaXZlbiBib2RpZXMuXHJcbiAgICAgKiBAbWV0aG9kIGJvZGllc0FwcGx5R3Jhdml0eVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBncmF2aXR5XHJcbiAgICAgKi9cclxuICAgIHZhciBfYm9kaWVzQXBwbHlHcmF2aXR5ID0gZnVuY3Rpb24oYm9kaWVzLCBncmF2aXR5KSB7XHJcbiAgICAgICAgdmFyIGdyYXZpdHlTY2FsZSA9IHR5cGVvZiBncmF2aXR5LnNjYWxlICE9PSAndW5kZWZpbmVkJyA/IGdyYXZpdHkuc2NhbGUgOiAwLjAwMTtcclxuXHJcbiAgICAgICAgaWYgKChncmF2aXR5LnggPT09IDAgJiYgZ3Jhdml0eS55ID09PSAwKSB8fCBncmF2aXR5U2NhbGUgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChib2R5LmlzU3RhdGljIHx8IGJvZHkuaXNTbGVlcGluZylcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gYXBwbHkgZ3Jhdml0eVxyXG4gICAgICAgICAgICBib2R5LmZvcmNlLnkgKz0gYm9keS5tYXNzICogZ3Jhdml0eS55ICogZ3Jhdml0eVNjYWxlO1xyXG4gICAgICAgICAgICBib2R5LmZvcmNlLnggKz0gYm9keS5tYXNzICogZ3Jhdml0eS54ICogZ3Jhdml0eVNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseXMgYEJvZHkudXBkYXRlYCB0byBhbGwgZ2l2ZW4gYGJvZGllc2AuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUFsbFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgXHJcbiAgICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgZWxhcHNlZCBiZXR3ZWVuIHVwZGF0ZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3JyZWN0aW9uIFxyXG4gICAgICogVGhlIFZlcmxldCBjb3JyZWN0aW9uIGZhY3RvciAoZGVsdGFUaW1lIC8gbGFzdERlbHRhVGltZSlcclxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSB3b3JsZEJvdW5kc1xyXG4gICAgICovXHJcbiAgICB2YXIgX2JvZGllc1VwZGF0ZSA9IGZ1bmN0aW9uKGJvZGllcywgZGVsdGFUaW1lLCB0aW1lU2NhbGUsIGNvcnJlY3Rpb24sIHdvcmxkQm91bmRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoYm9keS5pc1N0YXRpYyB8fCBib2R5LmlzU2xlZXBpbmcpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIEJvZHkudXBkYXRlKGJvZHksIGRlbHRhVGltZSwgdGltZVNjYWxlLCBjb3JyZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYWxpYXMgZm9yIGBSdW5uZXIucnVuYCwgc2VlIGBNYXR0ZXIuUnVubmVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqIEBtZXRob2QgcnVuXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQganVzdCBiZWZvcmUgYW4gdXBkYXRlXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBiZWZvcmVVcGRhdGVcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCBhZnRlciBlbmdpbmUgdXBkYXRlIGFuZCBhbGwgY29sbGlzaW9uIGV2ZW50c1xyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYWZ0ZXJVcGRhdGVcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCBhZnRlciBlbmdpbmUgdXBkYXRlLCBwcm92aWRlcyBhIGxpc3Qgb2YgYWxsIHBhaXJzIHRoYXQgaGF2ZSBzdGFydGVkIHRvIGNvbGxpZGUgaW4gdGhlIGN1cnJlbnQgdGljayAoaWYgYW55KVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY29sbGlzaW9uU3RhcnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQucGFpcnMgTGlzdCBvZiBhZmZlY3RlZCBwYWlyc1xyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCBhZnRlciBlbmdpbmUgdXBkYXRlLCBwcm92aWRlcyBhIGxpc3Qgb2YgYWxsIHBhaXJzIHRoYXQgYXJlIGNvbGxpZGluZyBpbiB0aGUgY3VycmVudCB0aWNrIChpZiBhbnkpXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBjb2xsaXNpb25BY3RpdmVcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQucGFpcnMgTGlzdCBvZiBhZmZlY3RlZCBwYWlyc1xyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCBhZnRlciBlbmdpbmUgdXBkYXRlLCBwcm92aWRlcyBhIGxpc3Qgb2YgYWxsIHBhaXJzIHRoYXQgaGF2ZSBlbmRlZCBjb2xsaXNpb24gaW4gdGhlIGN1cnJlbnQgdGljayAoaWYgYW55KVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY29sbGlzaW9uRW5kXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnBhaXJzIExpc3Qgb2YgYWZmZWN0ZWQgcGFpcnNcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW50ZWdlciBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHBvc2l0aW9uIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBlYWNoIHVwZGF0ZS5cclxuICAgICAqIFRoZSBoaWdoZXIgdGhlIHZhbHVlLCB0aGUgaGlnaGVyIHF1YWxpdHkgdGhlIHNpbXVsYXRpb24gd2lsbCBiZSBhdCB0aGUgZXhwZW5zZSBvZiBwZXJmb3JtYW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25JdGVyYXRpb25zXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDZcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW50ZWdlciBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHZlbG9jaXR5IGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBlYWNoIHVwZGF0ZS5cclxuICAgICAqIFRoZSBoaWdoZXIgdGhlIHZhbHVlLCB0aGUgaGlnaGVyIHF1YWxpdHkgdGhlIHNpbXVsYXRpb24gd2lsbCBiZSBhdCB0aGUgZXhwZW5zZSBvZiBwZXJmb3JtYW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgdmVsb2NpdHlJdGVyYXRpb25zXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDRcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW50ZWdlciBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIGNvbnN0cmFpbnQgaXRlcmF0aW9ucyB0byBwZXJmb3JtIGVhY2ggdXBkYXRlLlxyXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUsIHRoZSBoaWdoZXIgcXVhbGl0eSB0aGUgc2ltdWxhdGlvbiB3aWxsIGJlIGF0IHRoZSBleHBlbnNlIG9mIHBlcmZvcm1hbmNlLlxyXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDJgIGlzIHVzdWFsbHkgdmVyeSBhZGVxdWF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludEl0ZXJhdGlvbnNcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdGhhdCBzcGVjaWZpZXMgd2hldGhlciB0aGUgZW5naW5lIHNob3VsZCBhbGxvdyBzbGVlcGluZyB2aWEgdGhlIGBNYXR0ZXIuU2xlZXBpbmdgIG1vZHVsZS5cclxuICAgICAqIFNsZWVwaW5nIGNhbiBpbXByb3ZlIHN0YWJpbGl0eSBhbmQgcGVyZm9ybWFuY2UsIGJ1dCBvZnRlbiBhdCB0aGUgZXhwZW5zZSBvZiBhY2N1cmFjeS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlU2xlZXBpbmdcclxuICAgICAqIEB0eXBlIGJvb2xlYW5cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgcHJvcGVydGllcyByZWdhcmRpbmcgdGhlIHRpbWluZyBzeXN0ZW1zIG9mIHRoZSBlbmdpbmUuIFxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB0aW1pbmdcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBnbG9iYWwgc2NhbGluZyBmYWN0b3Igb2YgdGltZSBmb3IgYWxsIGJvZGllcy5cclxuICAgICAqIEEgdmFsdWUgb2YgYDBgIGZyZWV6ZXMgdGhlIHNpbXVsYXRpb24uXHJcbiAgICAgKiBBIHZhbHVlIG9mIGAwLjFgIGdpdmVzIGEgc2xvdy1tb3Rpb24gZWZmZWN0LlxyXG4gICAgICogQSB2YWx1ZSBvZiBgMS4yYCBnaXZlcyBhIHNwZWVkLXVwIGVmZmVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgdGltaW5nLnRpbWVTY2FsZVxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIGN1cnJlbnQgc2ltdWxhdGlvbi10aW1lIGluIG1pbGxpc2Vjb25kcyBzdGFydGluZyBmcm9tIGAwYC4gXHJcbiAgICAgKiBJdCBpcyBpbmNyZW1lbnRlZCBvbiBldmVyeSBgRW5naW5lLnVwZGF0ZWAgYnkgdGhlIGdpdmVuIGBkZWx0YWAgYXJndW1lbnQuIFxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB0aW1pbmcudGltZXN0YW1wXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW5zdGFuY2Ugb2YgYSBgUmVuZGVyYCBjb250cm9sbGVyLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGBNYXR0ZXIuUmVuZGVyYCBpbnN0YW5jZSBjcmVhdGVkIGJ5IGBFbmdpbmUuY3JlYXRlYC5cclxuICAgICAqIE9uZSBtYXkgYWxzbyBkZXZlbG9wIGEgY3VzdG9tIHJlbmRlcmVyIG1vZHVsZSBiYXNlZCBvbiBgTWF0dGVyLlJlbmRlcmAgYW5kIHBhc3MgYW4gaW5zdGFuY2Ugb2YgaXQgdG8gYEVuZ2luZS5jcmVhdGVgIHZpYSBgb3B0aW9ucy5yZW5kZXJgLlxyXG4gICAgICpcclxuICAgICAqIEEgbWluaW1hbCBjdXN0b20gcmVuZGVyZXIgb2JqZWN0IG11c3QgZGVmaW5lIGF0IGxlYXN0IHRocmVlIGZ1bmN0aW9uczogYGNyZWF0ZWAsIGBjbGVhcmAgYW5kIGB3b3JsZGAgKHNlZSBgTWF0dGVyLlJlbmRlcmApLlxyXG4gICAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBpbnN0ZWFkIHBhc3MgdGhlIF9tb2R1bGVfIHJlZmVyZW5jZSB2aWEgYG9wdGlvbnMucmVuZGVyLmNvbnRyb2xsZXJgIGFuZCBgRW5naW5lLmNyZWF0ZWAgd2lsbCBpbnN0YW50aWF0ZSBvbmUgZm9yIHlvdS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyXHJcbiAgICAgKiBAdHlwZSByZW5kZXJcclxuICAgICAqIEBkZXByZWNhdGVkIHNlZSBEZW1vLmpzIGZvciBhbiBleGFtcGxlIG9mIGNyZWF0aW5nIGEgcmVuZGVyZXJcclxuICAgICAqIEBkZWZhdWx0IGEgTWF0dGVyLlJlbmRlciBpbnN0YW5jZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiBhIGJyb2FkcGhhc2UgY29udHJvbGxlci4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBgTWF0dGVyLkdyaWRgIGluc3RhbmNlIGNyZWF0ZWQgYnkgYEVuZ2luZS5jcmVhdGVgLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBicm9hZHBoYXNlXHJcbiAgICAgKiBAdHlwZSBncmlkXHJcbiAgICAgKiBAZGVmYXVsdCBhIE1hdHRlci5HcmlkIGluc3RhbmNlXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYFdvcmxkYCBjb21wb3NpdGUgb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGFsbCBzaW11bGF0ZWQgYm9kaWVzIGFuZCBjb25zdHJhaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgd29ybGRcclxuICAgICAqIEB0eXBlIHdvcmxkXHJcbiAgICAgKiBAZGVmYXVsdCBhIE1hdHRlci5Xb3JsZCBpbnN0YW5jZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvYmplY3QgcmVzZXJ2ZWQgZm9yIHN0b3JpbmcgcGx1Z2luLXNwZWNpZmljIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHBsdWdpblxyXG4gICAgICogQHR5cGUge31cclxuICAgICAqL1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9FbmdpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL0VuZ2luZS5qcyIsIi8vIEBpZiBERUJVR1xyXG4vKipcclxuKiBfSW50ZXJuYWwgQ2xhc3NfLCBub3QgZ2VuZXJhbGx5IHVzZWQgb3V0c2lkZSBvZiB0aGUgZW5naW5lJ3MgaW50ZXJuYWxzLlxyXG4qXHJcbiovXHJcblxyXG52YXIgTWV0cmljcyA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXRyaWNzO1xyXG5cclxudmFyIENvbXBvc2l0ZSA9IHJlcXVpcmUoJy4uL2JvZHkvQ29tcG9zaXRlJyk7XHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuL0NvbW1vbicpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBtZXRyaWNzLlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHttZXRyaWNzfSBBIG5ldyBtZXRyaWNzXHJcbiAgICAgKi9cclxuICAgIE1ldHJpY3MuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcclxuICAgICAgICAgICAgZXh0ZW5kZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBuYXJyb3dEZXRlY3Rpb25zOiAwLFxyXG4gICAgICAgICAgICBuYXJyb3dwaGFzZVRlc3RzOiAwLFxyXG4gICAgICAgICAgICBuYXJyb3dSZXVzZTogMCxcclxuICAgICAgICAgICAgbmFycm93UmV1c2VDb3VudDogMCxcclxuICAgICAgICAgICAgbWlkcGhhc2VUZXN0czogMCxcclxuICAgICAgICAgICAgYnJvYWRwaGFzZVRlc3RzOiAwLFxyXG4gICAgICAgICAgICBuYXJyb3dFZmY6IDAuMDAwMSxcclxuICAgICAgICAgICAgbWlkRWZmOiAwLjAwMDEsXHJcbiAgICAgICAgICAgIGJyb2FkRWZmOiAwLjAwMDEsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbnM6IDAsXHJcbiAgICAgICAgICAgIGJ1Y2tldHM6IDAsXHJcbiAgICAgICAgICAgIGJvZGllczogMCxcclxuICAgICAgICAgICAgcGFpcnM6IDBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgZmFsc2UsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBtZXRyaWNzLlxyXG4gICAgICogQG1ldGhvZCByZXNldFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7bWV0cmljc30gbWV0cmljc1xyXG4gICAgICovXHJcbiAgICBNZXRyaWNzLnJlc2V0ID0gZnVuY3Rpb24obWV0cmljcykge1xyXG4gICAgICAgIGlmIChtZXRyaWNzLmV4dGVuZGVkKSB7XHJcbiAgICAgICAgICAgIG1ldHJpY3MubmFycm93RGV0ZWN0aW9ucyA9IDA7XHJcbiAgICAgICAgICAgIG1ldHJpY3MubmFycm93cGhhc2VUZXN0cyA9IDA7XHJcbiAgICAgICAgICAgIG1ldHJpY3MubmFycm93UmV1c2UgPSAwO1xyXG4gICAgICAgICAgICBtZXRyaWNzLm5hcnJvd1JldXNlQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBtZXRyaWNzLm1pZHBoYXNlVGVzdHMgPSAwO1xyXG4gICAgICAgICAgICBtZXRyaWNzLmJyb2FkcGhhc2VUZXN0cyA9IDA7XHJcbiAgICAgICAgICAgIG1ldHJpY3MubmFycm93RWZmID0gMDtcclxuICAgICAgICAgICAgbWV0cmljcy5taWRFZmYgPSAwO1xyXG4gICAgICAgICAgICBtZXRyaWNzLmJyb2FkRWZmID0gMDtcclxuICAgICAgICAgICAgbWV0cmljcy5jb2xsaXNpb25zID0gMDtcclxuICAgICAgICAgICAgbWV0cmljcy5idWNrZXRzID0gMDtcclxuICAgICAgICAgICAgbWV0cmljcy5wYWlycyA9IDA7XHJcbiAgICAgICAgICAgIG1ldHJpY3MuYm9kaWVzID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBtZXRyaWNzLlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge21ldHJpY3N9IG1ldHJpY3NcclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcclxuICAgICAqL1xyXG4gICAgTWV0cmljcy51cGRhdGUgPSBmdW5jdGlvbihtZXRyaWNzLCBlbmdpbmUpIHtcclxuICAgICAgICBpZiAobWV0cmljcy5leHRlbmRlZCkge1xyXG4gICAgICAgICAgICB2YXIgd29ybGQgPSBlbmdpbmUud29ybGQsXHJcbiAgICAgICAgICAgICAgICBib2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKTtcclxuXHJcbiAgICAgICAgICAgIG1ldHJpY3MuY29sbGlzaW9ucyA9IG1ldHJpY3MubmFycm93RGV0ZWN0aW9ucztcclxuICAgICAgICAgICAgbWV0cmljcy5wYWlycyA9IGVuZ2luZS5wYWlycy5saXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgbWV0cmljcy5ib2RpZXMgPSBib2RpZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBtZXRyaWNzLm1pZEVmZiA9IChtZXRyaWNzLm5hcnJvd0RldGVjdGlvbnMgLyAobWV0cmljcy5taWRwaGFzZVRlc3RzIHx8IDEpKS50b0ZpeGVkKDIpO1xyXG4gICAgICAgICAgICBtZXRyaWNzLm5hcnJvd0VmZiA9IChtZXRyaWNzLm5hcnJvd0RldGVjdGlvbnMgLyAobWV0cmljcy5uYXJyb3dwaGFzZVRlc3RzIHx8IDEpKS50b0ZpeGVkKDIpO1xyXG4gICAgICAgICAgICBtZXRyaWNzLmJyb2FkRWZmID0gKDEgLSAobWV0cmljcy5icm9hZHBoYXNlVGVzdHMgLyAoYm9kaWVzLmxlbmd0aCB8fCAxKSkpLnRvRml4ZWQoMik7XHJcbiAgICAgICAgICAgIG1ldHJpY3MubmFycm93UmV1c2UgPSAobWV0cmljcy5uYXJyb3dSZXVzZUNvdW50IC8gKG1ldHJpY3MubmFycm93cGhhc2VUZXN0cyB8fCAxKSkudG9GaXhlZCgyKTtcclxuICAgICAgICAgICAgLy92YXIgYnJvYWRwaGFzZSA9IGVuZ2luZS5icm9hZHBoYXNlW2VuZ2luZS5icm9hZHBoYXNlLmN1cnJlbnRdO1xyXG4gICAgICAgICAgICAvL2lmIChicm9hZHBoYXNlLmluc3RhbmNlKVxyXG4gICAgICAgICAgICAvLyAgICBtZXRyaWNzLmJ1Y2tldHMgPSBDb21tb24ua2V5cyhicm9hZHBoYXNlLmluc3RhbmNlLmJ1Y2tldHMpLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuLy8gQGVuZGlmXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvTWV0cmljcy5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvTWV0cmljcy5qcyIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlBsdWdpbmAgbW9kdWxlIGNvbnRhaW5zIGZ1bmN0aW9ucyBmb3IgcmVnaXN0ZXJpbmcgYW5kIGluc3RhbGxpbmcgcGx1Z2lucyBvbiBtb2R1bGVzLlxyXG4qXHJcbiogQGNsYXNzIFBsdWdpblxyXG4qL1xyXG5cclxudmFyIFBsdWdpbiA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQbHVnaW47XHJcblxyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICBQbHVnaW4uX3JlZ2lzdHJ5ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBwbHVnaW4gb2JqZWN0IHNvIGl0IGNhbiBiZSByZXNvbHZlZCBsYXRlciBieSBuYW1lLlxyXG4gICAgICogQG1ldGhvZCByZWdpc3RlclxyXG4gICAgICogQHBhcmFtIHBsdWdpbiB7fSBUaGUgcGx1Z2luIHRvIHJlZ2lzdGVyLlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcGx1Z2luLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4ucmVnaXN0ZXIgPSBmdW5jdGlvbihwbHVnaW4pIHtcclxuICAgICAgICBpZiAoIVBsdWdpbi5pc1BsdWdpbihwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4ucmVnaXN0ZXI6JywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbiksICdkb2VzIG5vdCBpbXBsZW1lbnQgYWxsIHJlcXVpcmVkIGZpZWxkcy4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwbHVnaW4ubmFtZSBpbiBQbHVnaW4uX3JlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgIHZhciByZWdpc3RlcmVkID0gUGx1Z2luLl9yZWdpc3RyeVtwbHVnaW4ubmFtZV0sXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5WZXJzaW9uID0gUGx1Z2luLnZlcnNpb25QYXJzZShwbHVnaW4udmVyc2lvbikubnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZFZlcnNpb24gPSBQbHVnaW4udmVyc2lvblBhcnNlKHJlZ2lzdGVyZWQudmVyc2lvbikubnVtYmVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBsdWdpblZlcnNpb24gPiByZWdpc3RlcmVkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5yZWdpc3RlcjonLCBQbHVnaW4udG9TdHJpbmcocmVnaXN0ZXJlZCksICd3YXMgdXBncmFkZWQgdG8nLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSk7XHJcbiAgICAgICAgICAgICAgICBQbHVnaW4uX3JlZ2lzdHJ5W3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVnaW5WZXJzaW9uIDwgcmVnaXN0ZXJlZFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4ucmVnaXN0ZXI6JywgUGx1Z2luLnRvU3RyaW5nKHJlZ2lzdGVyZWQpLCAnY2FuIG5vdCBiZSBkb3duZ3JhZGVkIHRvJywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbiAhPT0gcmVnaXN0ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5yZWdpc3RlcjonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2lzIGFscmVhZHkgcmVnaXN0ZXJlZCB0byBkaWZmZXJlbnQgcGx1Z2luIG9iamVjdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgUGx1Z2luLl9yZWdpc3RyeVtwbHVnaW4ubmFtZV0gPSBwbHVnaW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGx1Z2luO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVzIGEgZGVwZW5kZW5jeSB0byBhIHBsdWdpbiBvYmplY3QgZnJvbSB0aGUgcmVnaXN0cnkgaWYgaXQgZXhpc3RzLiBcclxuICAgICAqIFRoZSBgZGVwZW5kZW5jeWAgbWF5IGNvbnRhaW4gYSB2ZXJzaW9uLCBidXQgb25seSB0aGUgbmFtZSBtYXR0ZXJzIHdoZW4gcmVzb2x2aW5nLlxyXG4gICAgICogQG1ldGhvZCByZXNvbHZlXHJcbiAgICAgKiBAcGFyYW0gZGVwZW5kZW5jeSB7c3RyaW5nfSBUaGUgZGVwZW5kZW5jeS5cclxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHBsdWdpbiBpZiByZXNvbHZlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4ucmVzb2x2ZSA9IGZ1bmN0aW9uKGRlcGVuZGVuY3kpIHtcclxuICAgICAgICByZXR1cm4gUGx1Z2luLl9yZWdpc3RyeVtQbHVnaW4uZGVwZW5kZW5jeVBhcnNlKGRlcGVuZGVuY3kpLm5hbWVdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcmV0dHkgcHJpbnRlZCBwbHVnaW4gbmFtZSBhbmQgdmVyc2lvbi5cclxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcclxuICAgICAqIEBwYXJhbSBwbHVnaW4ge30gVGhlIHBsdWdpbi5cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUHJldHR5IHByaW50ZWQgcGx1Z2luIG5hbWUgYW5kIHZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIFBsdWdpbi50b1N0cmluZyA9IGZ1bmN0aW9uKHBsdWdpbikge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJyA/IHBsdWdpbiA6IChwbHVnaW4ubmFtZSB8fCAnYW5vbnltb3VzJykgKyAnQCcgKyAocGx1Z2luLnZlcnNpb24gfHwgcGx1Z2luLnJhbmdlIHx8ICcwLjAuMCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgbWVldHMgdGhlIG1pbmltdW0gc3RhbmRhcmQgdG8gYmUgY29uc2lkZXJlZCBhIHBsdWdpbi5cclxuICAgICAqIFRoaXMgbWVhbnMgaXQgbXVzdCBkZWZpbmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogLSBgbmFtZWBcclxuICAgICAqIC0gYHZlcnNpb25gXHJcbiAgICAgKiAtIGBpbnN0YWxsYFxyXG4gICAgICogQG1ldGhvZCBpc1BsdWdpblxyXG4gICAgICogQHBhcmFtIG9iaiB7fSBUaGUgb2JqIHRvIHRlc3QuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBjYW4gYmUgY29uc2lkZXJlZCBhIHBsdWdpbiBvdGhlcndpc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgUGx1Z2luLmlzUGx1Z2luID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmoubmFtZSAmJiBvYmoudmVyc2lvbiAmJiBvYmouaW5zdGFsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhIHBsdWdpbiB3aXRoIHRoZSBnaXZlbiBgbmFtZWAgYmVlbiBpbnN0YWxsZWQgb24gYG1vZHVsZWAuXHJcbiAgICAgKiBAbWV0aG9kIGlzVXNlZFxyXG4gICAgICogQHBhcmFtIG1vZHVsZSB7fSBUaGUgbW9kdWxlLlxyXG4gICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIHBsdWdpbiBuYW1lLlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGEgcGx1Z2luIHdpdGggdGhlIGdpdmVuIGBuYW1lYCBiZWVuIGluc3RhbGxlZCBvbiBgbW9kdWxlYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIFBsdWdpbi5pc1VzZWQgPSBmdW5jdGlvbihtb2R1bGUsIG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbW9kdWxlLnVzZWQuaW5kZXhPZihuYW1lKSA+IC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGBwbHVnaW4uZm9yYCBpcyBhcHBsaWNhYmxlIHRvIGBtb2R1bGVgIGJ5IGNvbXBhcmluZyBhZ2FpbnN0IGBtb2R1bGUubmFtZWAgYW5kIGBtb2R1bGUudmVyc2lvbmAuXHJcbiAgICAgKiBJZiBgcGx1Z2luLmZvcmAgaXMgbm90IHNwZWNpZmllZCB0aGVuIGl0IGlzIGFzc3VtZWQgdG8gYmUgYXBwbGljYWJsZS5cclxuICAgICAqIFRoZSB2YWx1ZSBvZiBgcGx1Z2luLmZvcmAgaXMgYSBzdHJpbmcgb2YgdGhlIGZvcm1hdCBgJ21vZHVsZS1uYW1lJ2Agb3IgYCdtb2R1bGUtbmFtZUB2ZXJzaW9uJ2AuXHJcbiAgICAgKiBAbWV0aG9kIGlzRm9yXHJcbiAgICAgKiBAcGFyYW0gcGx1Z2luIHt9IFRoZSBwbHVnaW4uXHJcbiAgICAgKiBAcGFyYW0gbW9kdWxlIHt9IFRoZSBtb2R1bGUuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgYHBsdWdpbi5mb3JgIGlzIGFwcGxpY2FibGUgdG8gYG1vZHVsZWAsIG90aGVyd2lzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4uaXNGb3IgPSBmdW5jdGlvbihwbHVnaW4sIG1vZHVsZSkge1xyXG4gICAgICAgIHZhciBwYXJzZWQgPSBwbHVnaW4uZm9yICYmIFBsdWdpbi5kZXBlbmRlbmN5UGFyc2UocGx1Z2luLmZvcik7XHJcbiAgICAgICAgcmV0dXJuICFwbHVnaW4uZm9yIHx8IChtb2R1bGUubmFtZSA9PT0gcGFyc2VkLm5hbWUgJiYgUGx1Z2luLnZlcnNpb25TYXRpc2ZpZXMobW9kdWxlLnZlcnNpb24sIHBhcnNlZC5yYW5nZSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbGxzIHRoZSBwbHVnaW5zIGJ5IGNhbGxpbmcgYHBsdWdpbi5pbnN0YWxsYCBvbiBlYWNoIHBsdWdpbiBzcGVjaWZpZWQgaW4gYHBsdWdpbnNgIGlmIHBhc3NlZCwgb3RoZXJ3aXNlIGBtb2R1bGUudXNlc2AuXHJcbiAgICAgKiBGb3IgaW5zdGFsbGluZyBwbHVnaW5zIG9uIGBNYXR0ZXJgIHNlZSB0aGUgY29udmVuaWVuY2UgZnVuY3Rpb24gYE1hdHRlci51c2VgLlxyXG4gICAgICogUGx1Z2lucyBtYXkgYmUgc3BlY2lmaWVkIGVpdGhlciBieSB0aGVpciBuYW1lIG9yIGEgcmVmZXJlbmNlIHRvIHRoZSBwbHVnaW4gb2JqZWN0LlxyXG4gICAgICogUGx1Z2lucyB0aGVtc2VsdmVzIG1heSBzcGVjaWZ5IGZ1cnRoZXIgZGVwZW5kZW5jaWVzLCBidXQgZWFjaCBwbHVnaW4gaXMgaW5zdGFsbGVkIG9ubHkgb25jZS5cclxuICAgICAqIE9yZGVyIGlzIGltcG9ydGFudCwgYSB0b3BvbG9naWNhbCBzb3J0IGlzIHBlcmZvcm1lZCB0byBmaW5kIHRoZSBiZXN0IHJlc3VsdGluZyBvcmRlciBvZiBpbnN0YWxsYXRpb24uXHJcbiAgICAgKiBUaGlzIHNvcnRpbmcgYXR0ZW1wdHMgdG8gc2F0aXNmeSBldmVyeSBkZXBlbmRlbmN5J3MgcmVxdWVzdGVkIG9yZGVyaW5nLCBidXQgbWF5IG5vdCBiZSBleGFjdCBpbiBhbGwgY2FzZXMuXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGxvZ3MgdGhlIHJlc3VsdGluZyBzdGF0dXMgb2YgZWFjaCBkZXBlbmRlbmN5IGluIHRoZSBjb25zb2xlLCBhbG9uZyB3aXRoIGFueSB3YXJuaW5ncy5cclxuICAgICAqIC0gQSBncmVlbiB0aWNrIOKchSBpbmRpY2F0ZXMgYSBkZXBlbmRlbmN5IHdhcyByZXNvbHZlZCBhbmQgaW5zdGFsbGVkLlxyXG4gICAgICogLSBBbiBvcmFuZ2UgZGlhbW9uZCDwn5S2IGluZGljYXRlcyBhIGRlcGVuZGVuY3kgd2FzIHJlc29sdmVkIGJ1dCBhIHdhcm5pbmcgd2FzIHRocm93biBmb3IgaXQgb3Igb25lIGlmIGl0cyBkZXBlbmRlbmNpZXMuXHJcbiAgICAgKiAtIEEgcmVkIGNyb3NzIOKdjCBpbmRpY2F0ZXMgYSBkZXBlbmRlbmN5IGNvdWxkIG5vdCBiZSByZXNvbHZlZC5cclxuICAgICAqIEF2b2lkIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBtb2R1bGUgdW5sZXNzIHlvdSBpbnRlbmQgdG8gbWFudWFsbHkgY29udHJvbCBpbnN0YWxsYXRpb24gb3JkZXIuXHJcbiAgICAgKiBAbWV0aG9kIHVzZVxyXG4gICAgICogQHBhcmFtIG1vZHVsZSB7fSBUaGUgbW9kdWxlIGluc3RhbGwgcGx1Z2lucyBvbi5cclxuICAgICAqIEBwYXJhbSBbcGx1Z2lucz1tb2R1bGUudXNlc10ge30gVGhlIHBsdWdpbnMgdG8gaW5zdGFsbCBvbiBtb2R1bGUgKG9wdGlvbmFsLCBkZWZhdWx0cyB0byBgbW9kdWxlLnVzZXNgKS5cclxuICAgICAqL1xyXG4gICAgUGx1Z2luLnVzZSA9IGZ1bmN0aW9uKG1vZHVsZSwgcGx1Z2lucykge1xyXG4gICAgICAgIG1vZHVsZS51c2VzID0gKG1vZHVsZS51c2VzIHx8IFtdKS5jb25jYXQocGx1Z2lucyB8fCBbXSk7XHJcblxyXG4gICAgICAgIGlmIChtb2R1bGUudXNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi51c2U6JywgUGx1Z2luLnRvU3RyaW5nKG1vZHVsZSksICdkb2VzIG5vdCBzcGVjaWZ5IGFueSBkZXBlbmRlbmNpZXMgdG8gaW5zdGFsbC4nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFBsdWdpbi5kZXBlbmRlbmNpZXMobW9kdWxlKSxcclxuICAgICAgICAgICAgc29ydGVkRGVwZW5kZW5jaWVzID0gQ29tbW9uLnRvcG9sb2dpY2FsU29ydChkZXBlbmRlbmNpZXMpLFxyXG4gICAgICAgICAgICBzdGF0dXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKHNvcnRlZERlcGVuZGVuY2llc1tpXSA9PT0gbW9kdWxlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gUGx1Z2luLnJlc29sdmUoc29ydGVkRGVwZW5kZW5jaWVzW2ldKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcGx1Z2luKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMucHVzaCgn4p2MICcgKyBzb3J0ZWREZXBlbmRlbmNpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChQbHVnaW4uaXNVc2VkKG1vZHVsZSwgcGx1Z2luLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFQbHVnaW4uaXNGb3IocGx1Z2luLCBtb2R1bGUpKSB7XHJcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnVzZTonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2lzIGZvcicsIHBsdWdpbi5mb3IsICdidXQgaW5zdGFsbGVkIG9uJywgUGx1Z2luLnRvU3RyaW5nKG1vZHVsZSkgKyAnLicpO1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luLl93YXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocGx1Z2luLmluc3RhbGwpIHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKG1vZHVsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnVzZTonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2RvZXMgbm90IHNwZWNpZnkgYW4gaW5zdGFsbCBmdW5jdGlvbi4nKTtcclxuICAgICAgICAgICAgICAgIHBsdWdpbi5fd2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHBsdWdpbi5fd2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMucHVzaCgn8J+UtiAnICsgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpbi5fd2FybmVkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLnB1c2goJ+KchSAnICsgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtb2R1bGUudXNlZC5wdXNoKHBsdWdpbi5uYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdGF0dXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBDb21tb24uaW5mbyhzdGF0dXMuam9pbignICAnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IGZpbmRzIGFsbCBvZiBhIG1vZHVsZSdzIGRlcGVuZGVuY2llcyBhbmQgcmV0dXJucyBhIGZsYXQgZGVwZW5kZW5jeSBncmFwaC5cclxuICAgICAqIEBtZXRob2QgZGVwZW5kZW5jaWVzXHJcbiAgICAgKiBAcGFyYW0gbW9kdWxlIHt9IFRoZSBtb2R1bGUuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgZGVwZW5kZW5jeSBncmFwaC5cclxuICAgICAqL1xyXG4gICAgUGx1Z2luLmRlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKG1vZHVsZSwgdHJhY2tlZCkge1xyXG4gICAgICAgIHZhciBwYXJzZWRCYXNlID0gUGx1Z2luLmRlcGVuZGVuY3lQYXJzZShtb2R1bGUpLFxyXG4gICAgICAgICAgICBuYW1lID0gcGFyc2VkQmFzZS5uYW1lO1xyXG5cclxuICAgICAgICB0cmFja2VkID0gdHJhY2tlZCB8fCB7fTtcclxuXHJcbiAgICAgICAgaWYgKG5hbWUgaW4gdHJhY2tlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtb2R1bGUgPSBQbHVnaW4ucmVzb2x2ZShtb2R1bGUpIHx8IG1vZHVsZTtcclxuXHJcbiAgICAgICAgdHJhY2tlZFtuYW1lXSA9IENvbW1vbi5tYXAobW9kdWxlLnVzZXMgfHwgW10sIGZ1bmN0aW9uKGRlcGVuZGVuY3kpIHtcclxuICAgICAgICAgICAgaWYgKFBsdWdpbi5pc1BsdWdpbihkZXBlbmRlbmN5KSkge1xyXG4gICAgICAgICAgICAgICAgUGx1Z2luLnJlZ2lzdGVyKGRlcGVuZGVuY3kpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gUGx1Z2luLmRlcGVuZGVuY3lQYXJzZShkZXBlbmRlbmN5KSxcclxuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gUGx1Z2luLnJlc29sdmUoZGVwZW5kZW5jeSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgJiYgIVBsdWdpbi52ZXJzaW9uU2F0aXNmaWVzKHJlc29sdmVkLnZlcnNpb24sIHBhcnNlZC5yYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKFxyXG4gICAgICAgICAgICAgICAgICAgICdQbHVnaW4uZGVwZW5kZW5jaWVzOicsIFBsdWdpbi50b1N0cmluZyhyZXNvbHZlZCksICdkb2VzIG5vdCBzYXRpc2Z5JyxcclxuICAgICAgICAgICAgICAgICAgICBQbHVnaW4udG9TdHJpbmcocGFyc2VkKSwgJ3VzZWQgYnknLCBQbHVnaW4udG9TdHJpbmcocGFyc2VkQmFzZSkgKyAnLidcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQuX3dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBtb2R1bGUuX3dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybihcclxuICAgICAgICAgICAgICAgICAgICAnUGx1Z2luLmRlcGVuZGVuY2llczonLCBQbHVnaW4udG9TdHJpbmcoZGVwZW5kZW5jeSksICd1c2VkIGJ5JyxcclxuICAgICAgICAgICAgICAgICAgICBQbHVnaW4udG9TdHJpbmcocGFyc2VkQmFzZSksICdjb3VsZCBub3QgYmUgcmVzb2x2ZWQuJ1xyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtb2R1bGUuX3dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQubmFtZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja2VkW25hbWVdLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIFBsdWdpbi5kZXBlbmRlbmNpZXModHJhY2tlZFtuYW1lXVtpXSwgdHJhY2tlZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJhY2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBkZXBlbmRlbmN5IHN0cmluZyBpbnRvIGl0cyBjb21wb25lbnRzLlxyXG4gICAgICogVGhlIGBkZXBlbmRlbmN5YCBpcyBhIHN0cmluZyBvZiB0aGUgZm9ybWF0IGAnbW9kdWxlLW5hbWUnYCBvciBgJ21vZHVsZS1uYW1lQHZlcnNpb24nYC5cclxuICAgICAqIFNlZSBkb2N1bWVudGF0aW9uIGZvciBgUGx1Z2luLnZlcnNpb25QYXJzZWAgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIGZvcm1hdC5cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGFsc28gaGFuZGxlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBhbHJlYWR5IHJlc29sdmVkIChlLmcuIGEgbW9kdWxlIG9iamVjdCkuXHJcbiAgICAgKiBAbWV0aG9kIGRlcGVuZGVuY3lQYXJzZVxyXG4gICAgICogQHBhcmFtIGRlcGVuZGVuY3kge3N0cmluZ30gVGhlIGRlcGVuZGVuY3kgb2YgdGhlIGZvcm1hdCBgJ21vZHVsZS1uYW1lJ2Agb3IgYCdtb2R1bGUtbmFtZUB2ZXJzaW9uJ2AuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBkZXBlbmRlbmN5IHBhcnNlZCBpbnRvIGl0cyBjb21wb25lbnRzLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4uZGVwZW5kZW5jeVBhcnNlID0gZnVuY3Rpb24oZGVwZW5kZW5jeSkge1xyXG4gICAgICAgIGlmIChDb21tb24uaXNTdHJpbmcoZGVwZW5kZW5jeSkpIHtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSAvXltcXHctXSsoQChcXCp8W1xcXn5dP1xcZCtcXC5cXGQrXFwuXFxkKygtWzAtOUEtWmEtei1dKyk/KSk/JC87XHJcblxyXG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4udGVzdChkZXBlbmRlbmN5KSkge1xyXG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5kZXBlbmRlbmN5UGFyc2U6JywgZGVwZW5kZW5jeSwgJ2lzIG5vdCBhIHZhbGlkIGRlcGVuZGVuY3kgc3RyaW5nLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogZGVwZW5kZW5jeS5zcGxpdCgnQCcpWzBdLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGRlcGVuZGVuY3kuc3BsaXQoJ0AnKVsxXSB8fCAnKidcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5hbWU6IGRlcGVuZGVuY3kubmFtZSxcclxuICAgICAgICAgICAgcmFuZ2U6IGRlcGVuZGVuY3kucmFuZ2UgfHwgZGVwZW5kZW5jeS52ZXJzaW9uXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSB2ZXJzaW9uIHN0cmluZyBpbnRvIGl0cyBjb21wb25lbnRzLiAgXHJcbiAgICAgKiBWZXJzaW9ucyBhcmUgc3RyaWN0bHkgb2YgdGhlIGZvcm1hdCBgeC55LnpgIChhcyBpbiBbc2VtdmVyXShodHRwOi8vc2VtdmVyLm9yZy8pKS5cclxuICAgICAqIFZlcnNpb25zIG1heSBvcHRpb25hbGx5IGhhdmUgYSBwcmVyZWxlYXNlIHRhZyBpbiB0aGUgZm9ybWF0IGB4Lnkuei1hbHBoYWAuXHJcbiAgICAgKiBSYW5nZXMgYXJlIGEgc3RyaWN0IHN1YnNldCBvZiBbbnBtIHJhbmdlc10oaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9taXNjL3NlbXZlciNhZHZhbmNlZC1yYW5nZS1zeW50YXgpLlxyXG4gICAgICogT25seSB0aGUgZm9sbG93aW5nIHJhbmdlIHR5cGVzIGFyZSBzdXBwb3J0ZWQ6XHJcbiAgICAgKiAtIFRpbGRlIHJhbmdlcyBlLmcuIGB+MS4yLjNgXHJcbiAgICAgKiAtIENhcmV0IHJhbmdlcyBlLmcuIGBeMS4yLjNgXHJcbiAgICAgKiAtIEV4YWN0IHZlcnNpb24gZS5nLiBgMS4yLjNgXHJcbiAgICAgKiAtIEFueSB2ZXJzaW9uIGAqYFxyXG4gICAgICogQG1ldGhvZCB2ZXJzaW9uUGFyc2VcclxuICAgICAqIEBwYXJhbSByYW5nZSB7c3RyaW5nfSBUaGUgdmVyc2lvbiBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSB2ZXJzaW9uIHJhbmdlIHBhcnNlZCBpbnRvIGl0cyBjb21wb25lbnRzLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4udmVyc2lvblBhcnNlID0gZnVuY3Rpb24ocmFuZ2UpIHtcclxuICAgICAgICB2YXIgcGF0dGVybiA9IC9eXFwqfFtcXF5+XT9cXGQrXFwuXFxkK1xcLlxcZCsoLVswLTlBLVphLXotXSspPyQvO1xyXG5cclxuICAgICAgICBpZiAoIXBhdHRlcm4udGVzdChyYW5nZSkpIHtcclxuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi52ZXJzaW9uUGFyc2U6JywgcmFuZ2UsICdpcyBub3QgYSB2YWxpZCB2ZXJzaW9uIG9yIHJhbmdlLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gcmFuZ2Uuc3BsaXQoJy0nKTtcclxuICAgICAgICByYW5nZSA9IGlkZW50aWZpZXJzWzBdO1xyXG5cclxuICAgICAgICB2YXIgaXNSYW5nZSA9IGlzTmFOKE51bWJlcihyYW5nZVswXSkpLFxyXG4gICAgICAgICAgICB2ZXJzaW9uID0gaXNSYW5nZSA/IHJhbmdlLnN1YnN0cigxKSA6IHJhbmdlLFxyXG4gICAgICAgICAgICBwYXJ0cyA9IENvbW1vbi5tYXAodmVyc2lvbi5zcGxpdCgnLicpLCBmdW5jdGlvbihwYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHBhcnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXNSYW5nZTogaXNSYW5nZSxcclxuICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcclxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxyXG4gICAgICAgICAgICBvcGVyYXRvcjogaXNSYW5nZSA/IHJhbmdlWzBdIDogJycsXHJcbiAgICAgICAgICAgIHBhcnRzOiBwYXJ0cyxcclxuICAgICAgICAgICAgcHJlcmVsZWFzZTogaWRlbnRpZmllcnNbMV0sXHJcbiAgICAgICAgICAgIG51bWJlcjogcGFydHNbMF0gKiAxZTggKyBwYXJ0c1sxXSAqIDFlNCArIHBhcnRzWzJdXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBgdmVyc2lvbmAgc2F0aXNmaWVzIHRoZSBnaXZlbiBgcmFuZ2VgLlxyXG4gICAgICogU2VlIGRvY3VtZW50YXRpb24gZm9yIGBQbHVnaW4udmVyc2lvblBhcnNlYCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgZm9ybWF0LlxyXG4gICAgICogSWYgYSB2ZXJzaW9uIG9yIHJhbmdlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gYW55IHZlcnNpb24gKGAqYCkgaXMgYXNzdW1lZCB0byBzYXRpc2Z5LlxyXG4gICAgICogQG1ldGhvZCB2ZXJzaW9uU2F0aXNmaWVzXHJcbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB7c3RyaW5nfSBUaGUgdmVyc2lvbiBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gcmFuZ2Uge3N0cmluZ30gVGhlIHJhbmdlIHN0cmluZy5cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBgdmVyc2lvbmAgc2F0aXNmaWVzIGByYW5nZWAsIG90aGVyd2lzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4udmVyc2lvblNhdGlzZmllcyA9IGZ1bmN0aW9uKHZlcnNpb24sIHJhbmdlKSB7XHJcbiAgICAgICAgcmFuZ2UgPSByYW5nZSB8fCAnKic7XHJcblxyXG4gICAgICAgIHZhciByYW5nZVBhcnNlZCA9IFBsdWdpbi52ZXJzaW9uUGFyc2UocmFuZ2UpLFxyXG4gICAgICAgICAgICByYW5nZVBhcnRzID0gcmFuZ2VQYXJzZWQucGFydHMsXHJcbiAgICAgICAgICAgIHZlcnNpb25QYXJzZWQgPSBQbHVnaW4udmVyc2lvblBhcnNlKHZlcnNpb24pLFxyXG4gICAgICAgICAgICB2ZXJzaW9uUGFydHMgPSB2ZXJzaW9uUGFyc2VkLnBhcnRzO1xyXG5cclxuICAgICAgICBpZiAocmFuZ2VQYXJzZWQuaXNSYW5nZSkge1xyXG4gICAgICAgICAgICBpZiAocmFuZ2VQYXJzZWQub3BlcmF0b3IgPT09ICcqJyB8fCB2ZXJzaW9uID09PSAnKicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmFuZ2VQYXJzZWQub3BlcmF0b3IgPT09ICd+Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25QYXJ0c1swXSA9PT0gcmFuZ2VQYXJ0c1swXSAmJiB2ZXJzaW9uUGFydHNbMV0gPT09IHJhbmdlUGFydHNbMV0gJiYgdmVyc2lvblBhcnRzWzJdID49IHJhbmdlUGFydHNbMl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyYW5nZVBhcnNlZC5vcGVyYXRvciA9PT0gJ14nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VQYXJ0c1swXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvblBhcnRzWzBdID09PSByYW5nZVBhcnRzWzBdICYmIHZlcnNpb25QYXJzZWQubnVtYmVyID49IHJhbmdlUGFyc2VkLm51bWJlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VQYXJ0c1sxXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvblBhcnRzWzFdID09PSByYW5nZVBhcnRzWzFdICYmIHZlcnNpb25QYXJ0c1syXSA+PSByYW5nZVBhcnRzWzJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uUGFydHNbMl0gPT09IHJhbmdlUGFydHNbMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2ZXJzaW9uID09PSByYW5nZSB8fCB2ZXJzaW9uID09PSAnKic7XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9QbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL1BsdWdpbi5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgZGVjb21wOiBwb2x5Z29uRGVjb21wLFxyXG4gICAgcXVpY2tEZWNvbXA6IHBvbHlnb25RdWlja0RlY29tcCxcclxuICAgIGlzU2ltcGxlOiBwb2x5Z29uSXNTaW1wbGUsXHJcbiAgICByZW1vdmVDb2xsaW5lYXJQb2ludHM6IHBvbHlnb25SZW1vdmVDb2xsaW5lYXJQb2ludHMsXHJcbiAgICBtYWtlQ0NXOiBwb2x5Z29uTWFrZUNDV1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHR3byBsaW5lcy5cclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGxpbmVJbnRcclxuICogQHBhcmFtICB7QXJyYXl9ICBsMSAgICAgICAgICBMaW5lIHZlY3RvciAxXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHByZWNpc2lvbiAgIFByZWNpc2lvbiB0byB1c2Ugd2hlbiBjaGVja2luZyBpZiB0aGUgbGluZXMgYXJlIHBhcmFsbGVsXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgVGhlIGludGVyc2VjdGlvbiBwb2ludC5cclxuICovXHJcbmZ1bmN0aW9uIGxpbmVJbnQobDEsbDIscHJlY2lzaW9uKXtcclxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xyXG4gICAgdmFyIGkgPSBbMCwwXTsgLy8gcG9pbnRcclxuICAgIHZhciBhMSwgYjEsIGMxLCBhMiwgYjIsIGMyLCBkZXQ7IC8vIHNjYWxhcnNcclxuICAgIGExID0gbDFbMV1bMV0gLSBsMVswXVsxXTtcclxuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcclxuICAgIGMxID0gYTEgKiBsMVswXVswXSArIGIxICogbDFbMF1bMV07XHJcbiAgICBhMiA9IGwyWzFdWzFdIC0gbDJbMF1bMV07XHJcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XHJcbiAgICBjMiA9IGEyICogbDJbMF1bMF0gKyBiMiAqIGwyWzBdWzFdO1xyXG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyKmIxO1xyXG4gICAgaWYgKCFzY2FsYXJfZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcclxuICAgICAgICBpWzBdID0gKGIyICogYzEgLSBiMSAqIGMyKSAvIGRldDtcclxuICAgICAgICBpWzFdID0gKGExICogYzIgLSBhMiAqIGMxKSAvIGRldDtcclxuICAgIH1cclxuICAgIHJldHVybiBpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdHMuXHJcbiAqIEBtZXRob2Qgc2VnbWVudHNJbnRlcnNlY3RcclxuICogQHBhcmFtIHtBcnJheX0gcDEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxyXG4gKiBAcGFyYW0ge0FycmF5fSBwMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxyXG4gKiBAcGFyYW0ge0FycmF5fSBxMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxyXG4gKiBAcGFyYW0ge0FycmF5fSBxMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cclxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBsaW5lU2VnbWVudHNJbnRlcnNlY3QocDEsIHAyLCBxMSwgcTIpe1xyXG5cdHZhciBkeCA9IHAyWzBdIC0gcDFbMF07XHJcblx0dmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcclxuXHR2YXIgZGEgPSBxMlswXSAtIHExWzBdO1xyXG5cdHZhciBkYiA9IHEyWzFdIC0gcTFbMV07XHJcblxyXG5cdC8vIHNlZ21lbnRzIGFyZSBwYXJhbGxlbFxyXG5cdGlmKChkYSpkeSAtIGRiKmR4KSA9PT0gMCl7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHR2YXIgcyA9IChkeCAqIChxMVsxXSAtIHAxWzFdKSArIGR5ICogKHAxWzBdIC0gcTFbMF0pKSAvIChkYSAqIGR5IC0gZGIgKiBkeCk7XHJcblx0dmFyIHQgPSAoZGEgKiAocDFbMV0gLSBxMVsxXSkgKyBkYiAqIChxMVswXSAtIHAxWzBdKSkgLyAoZGIgKiBkeCAtIGRhICogZHkpO1xyXG5cclxuXHRyZXR1cm4gKHM+PTAgJiYgczw9MSAmJiB0Pj0wICYmIHQ8PTEpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBhcmVhIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgZ2l2ZW4gcG9pbnRzLiBOb3RlIHRoYXQgdGhlIGFyZWEgd2lsbCBiZSBuZWdhdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBub3QgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBhcmVhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAqIEBwYXJhbSAge0FycmF5fSBjXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLGIsYyl7XHJcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pKihjWzFdIC0gYVsxXSkpLSgoY1swXSAtIGFbMF0pKihiWzFdIC0gYVsxXSkpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNMZWZ0KGEsYixjKXtcclxuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSxiLGMpID4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNMZWZ0T24oYSxiLGMpIHtcclxuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPj0gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNSaWdodChhLGIsYykge1xyXG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA8IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzUmlnaHRPbihhLGIsYykge1xyXG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA8PSAwO1xyXG59XHJcblxyXG52YXIgdG1wUG9pbnQxID0gW10sXHJcbiAgICB0bXBQb2ludDIgPSBbXTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxyXG4gKiBAbWV0aG9kIGNvbGxpbmVhclxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt0aHJlc2hvbGRBbmdsZT0wXSBUaHJlc2hvbGQgYW5nbGUgdG8gdXNlIHdoZW4gY29tcGFyaW5nIHRoZSB2ZWN0b3JzLiBUaGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgcmVzdWx0aW5nIHZlY3RvcnMgaXMgbGVzcyB0aGFuIHRoaXMgdmFsdWUuIFVzZSB6ZXJvIGZvciBtYXggcHJlY2lzaW9uLlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gY29sbGluZWFyKGEsYixjLHRocmVzaG9sZEFuZ2xlKSB7XHJcbiAgICBpZighdGhyZXNob2xkQW5nbGUpe1xyXG4gICAgICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPT09IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBhYiA9IHRtcFBvaW50MSxcclxuICAgICAgICAgICAgYmMgPSB0bXBQb2ludDI7XHJcblxyXG4gICAgICAgIGFiWzBdID0gYlswXS1hWzBdO1xyXG4gICAgICAgIGFiWzFdID0gYlsxXS1hWzFdO1xyXG4gICAgICAgIGJjWzBdID0gY1swXS1iWzBdO1xyXG4gICAgICAgIGJjWzFdID0gY1sxXS1iWzFdO1xyXG5cclxuICAgICAgICB2YXIgZG90ID0gYWJbMF0qYmNbMF0gKyBhYlsxXSpiY1sxXSxcclxuICAgICAgICAgICAgbWFnQSA9IE1hdGguc3FydChhYlswXSphYlswXSArIGFiWzFdKmFiWzFdKSxcclxuICAgICAgICAgICAgbWFnQiA9IE1hdGguc3FydChiY1swXSpiY1swXSArIGJjWzFdKmJjWzFdKSxcclxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoZG90LyhtYWdBKm1hZ0IpKTtcclxuICAgICAgICByZXR1cm4gYW5nbGUgPCB0aHJlc2hvbGRBbmdsZTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc3FkaXN0KGEsYil7XHJcbiAgICB2YXIgZHggPSBiWzBdIC0gYVswXTtcclxuICAgIHZhciBkeSA9IGJbMV0gLSBhWzFdO1xyXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgdmVydGV4IGF0IHBvc2l0aW9uIGkuIEl0IGRvZXMgbm90IG1hdHRlciBpZiBpIGlzIG91dCBvZiBib3VuZHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGN5Y2xlLlxyXG4gKiBAbWV0aG9kIGF0XHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25BdChwb2x5Z29uLCBpKXtcclxuICAgIHZhciBzID0gcG9seWdvbi5sZW5ndGg7XHJcbiAgICByZXR1cm4gcG9seWdvbltpIDwgMCA/IGkgJSBzICsgcyA6IGkgJSBzXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFyIHRoZSBwb2x5Z29uIGRhdGFcclxuICogQG1ldGhvZCBjbGVhclxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25DbGVhcihwb2x5Z29uKXtcclxuICAgIHBvbHlnb24ubGVuZ3RoID0gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGVuZCBwb2ludHMgXCJmcm9tXCIgdG8gXCJ0b1wiLTEgZnJvbSBhbiBvdGhlciBwb2x5Z29uIFwicG9seVwiIG9udG8gdGhpcyBvbmUuXHJcbiAqIEBtZXRob2QgYXBwZW5kXHJcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seSBUaGUgcG9seWdvbiB0byBnZXQgcG9pbnRzIGZyb20uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSAgZnJvbSBUaGUgdmVydGV4IGluZGV4IGluIFwicG9seVwiLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gIHRvIFRoZSBlbmQgdmVydGV4IGluZGV4IGluIFwicG9seVwiLiBOb3RlIHRoYXQgdGhpcyB2ZXJ0ZXggaXMgTk9UIGluY2x1ZGVkIHdoZW4gYXBwZW5kaW5nLlxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25BcHBlbmQocG9seWdvbiwgcG9seSwgZnJvbSwgdG8pe1xyXG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XHJcbiAgICAgICAgcG9seWdvbi5wdXNoKHBvbHlbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogTWFrZSBzdXJlIHRoYXQgdGhlIHBvbHlnb24gdmVydGljZXMgYXJlIG9yZGVyZWQgY291bnRlci1jbG9ja3dpc2UuXHJcbiAqIEBtZXRob2QgbWFrZUNDV1xyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbk1ha2VDQ1cocG9seWdvbil7XHJcbiAgICB2YXIgYnIgPSAwLFxyXG4gICAgICAgIHYgPSBwb2x5Z29uO1xyXG5cclxuICAgIC8vIGZpbmQgYm90dG9tIHJpZ2h0IHBvaW50XHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAodltpXVsxXSA8IHZbYnJdWzFdIHx8ICh2W2ldWzFdID09PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XHJcbiAgICAgICAgICAgIGJyID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV2ZXJzZSBwb2x5IGlmIGNsb2Nrd2lzZVxyXG4gICAgaWYgKCFpc0xlZnQocG9seWdvbkF0KHBvbHlnb24sIGJyIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBiciksIHBvbHlnb25BdChwb2x5Z29uLCBiciArIDEpKSkge1xyXG4gICAgICAgIHBvbHlnb25SZXZlcnNlKHBvbHlnb24pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV2ZXJzZSB0aGUgdmVydGljZXMgaW4gdGhlIHBvbHlnb25cclxuICogQG1ldGhvZCByZXZlcnNlXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKXtcclxuICAgIHZhciB0bXAgPSBbXTtcclxuICAgIHZhciBOID0gcG9seWdvbi5sZW5ndGg7XHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgdG1wLnB1c2gocG9seWdvbi5wb3AoKSk7XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcblx0XHRwb2x5Z29uW2ldID0gdG1wW2ldO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYSBwb2ludCBpbiB0aGUgcG9seWdvbiBpcyBhIHJlZmxleCBwb2ludFxyXG4gKiBAbWV0aG9kIGlzUmVmbGV4XHJcbiAqIEBwYXJhbSAge051bWJlcn0gIGlcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25Jc1JlZmxleChwb2x5Z29uLCBpKXtcclxuICAgIHJldHVybiBpc1JpZ2h0KHBvbHlnb25BdChwb2x5Z29uLCBpIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSk7XHJcbn1cclxuXHJcbnZhciB0bXBMaW5lMT1bXSxcclxuICAgIHRtcExpbmUyPVtdO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcclxuICogQG1ldGhvZCBjYW5TZWVcclxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkNhblNlZShwb2x5Z29uLCBhLGIpIHtcclxuICAgIHZhciBwLCBkaXN0LCBsMT10bXBMaW5lMSwgbDI9dG1wTGluZTI7XHJcblxyXG4gICAgaWYgKGlzTGVmdE9uKHBvbHlnb25BdChwb2x5Z29uLCBhICsgMSksIHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKSAmJiBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHlnb24sIGEgLSAxKSwgcG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZGlzdCA9IHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gcG9seWdvbi5sZW5ndGg7ICsraSkgeyAvLyBmb3IgZWFjaCBlZGdlXHJcbiAgICAgICAgaWYgKChpICsgMSkgJSBwb2x5Z29uLmxlbmd0aCA9PT0gYSB8fCBpID09PSBhKXsgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYiksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSkpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxyXG4gICAgICAgICAgICBsMVswXSA9IHBvbHlnb25BdChwb2x5Z29uLCBhKTtcclxuICAgICAgICAgICAgbDFbMV0gPSBwb2x5Z29uQXQocG9seWdvbiwgYik7XHJcbiAgICAgICAgICAgIGwyWzBdID0gcG9seWdvbkF0KHBvbHlnb24sIGkpO1xyXG4gICAgICAgICAgICBsMlsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSk7XHJcbiAgICAgICAgICAgIHAgPSBsaW5lSW50KGwxLGwyKTtcclxuICAgICAgICAgICAgaWYgKHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHApIDwgZGlzdCkgeyAvLyBpZiBlZGdlIGlzIGJsb2NraW5nIHZpc2liaWxpdHkgdG8gYlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogQ29weSB0aGUgcG9seWdvbiBmcm9tIHZlcnRleCBpIHRvIHZlcnRleCBqLlxyXG4gKiBAbWV0aG9kIGNvcHlcclxuICogQHBhcmFtICB7TnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge051bWJlcn0galxyXG4gKiBAcGFyYW0gIHtQb2x5Z29ufSBbdGFyZ2V0UG9seV0gICBPcHRpb25hbCB0YXJnZXQgcG9seWdvbiB0byBzYXZlIGluLlxyXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSAgICAgICAgICAgICAgICBUaGUgcmVzdWx0aW5nIGNvcHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uQ29weShwb2x5Z29uLCBpLGosdGFyZ2V0UG9seSl7XHJcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgfHwgW107XHJcbiAgICBwb2x5Z29uQ2xlYXIocCk7XHJcbiAgICBpZiAoaSA8IGopIHtcclxuICAgICAgICAvLyBJbnNlcnQgYWxsIHZlcnRpY2VzIGZyb20gaSB0byBqXHJcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8PWo7IGsrKyl7XHJcbiAgICAgICAgICAgIHAucHVzaChwb2x5Z29uW2tdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIDAgdG8galxyXG4gICAgICAgIGZvcih2YXIgaz0wOyBrPD1qOyBrKyspe1xyXG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgaSB0byBlbmRcclxuICAgICAgICBmb3IodmFyIGs9aTsgazxwb2x5Z29uLmxlbmd0aDsgaysrKXtcclxuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBjb252ZXggcGllY2VzLiBSZXR1cm5zIGEgbGlzdCBvZiBlZGdlcyBbW3AxLHAyXSxbcDIscDNdLC4uLl0gdGhhdCBjdXRzIHRoZSBwb2x5Z29uLlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBhbGdvcml0aG0gaGFzIGNvbXBsZXhpdHkgTyhOXjQpIGFuZCB3aWxsIGJlIHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtYW55IHZlcnRpY2VzLlxyXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pIHtcclxuICAgIHZhciBtaW49W10sIHRtcDE9W10sIHRtcDI9W10sIHRtcFBvbHkgPSBbXTtcclxuICAgIHZhciBuRGlhZ3MgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seWdvbiwgaSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5Z29uLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbkNhblNlZShwb2x5Z29uLCBpLCBqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcDEgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaSwgaiwgdG1wUG9seSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcDIgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaiwgaSwgdG1wUG9seSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgazx0bXAyLmxlbmd0aDsgaysrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMS5wdXNoKHRtcDJba10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcDEubGVuZ3RoIDwgbkRpYWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHRtcDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5EaWFncyA9IHRtcDEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChbcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaildKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1pbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBvbmUgb3IgbW9yZSBjb252ZXggc3ViLVBvbHlnb25zLlxyXG4gKiBAbWV0aG9kIGRlY29tcFxyXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb3IgUG9seWdvbiBvYmplY3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkRlY29tcChwb2x5Z29uKXtcclxuICAgIHZhciBlZGdlcyA9IHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uKTtcclxuICAgIGlmKGVkZ2VzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgIHJldHVybiBwb2x5Z29uU2xpY2UocG9seWdvbiwgZWRnZXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW3BvbHlnb25dO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2xpY2VzIHRoZSBwb2x5Z29uIGdpdmVuIG9uZSBvciBtb3JlIGN1dCBlZGdlcy4gSWYgZ2l2ZW4gb25lLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHR3byBwb2x5Z29ucyAoZmFsc2Ugb24gZmFpbHVyZSkuIElmIG1hbnksIGFuIGFycmF5IG9mIHBvbHlnb25zLlxyXG4gKiBAbWV0aG9kIHNsaWNlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGN1dEVkZ2VzIEEgbGlzdCBvZiBlZGdlcywgYXMgcmV0dXJuZWQgYnkgLmdldEN1dEVkZ2VzKClcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uU2xpY2UocG9seWdvbiwgY3V0RWRnZXMpe1xyXG4gICAgaWYoY3V0RWRnZXMubGVuZ3RoID09PSAwKXtcclxuXHRcdHJldHVybiBbcG9seWdvbl07XHJcbiAgICB9XHJcbiAgICBpZihjdXRFZGdlcyBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzLmxlbmd0aCAmJiBjdXRFZGdlc1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzWzBdLmxlbmd0aD09PTIgJiYgY3V0RWRnZXNbMF1bMF0gaW5zdGFuY2VvZiBBcnJheSl7XHJcblxyXG4gICAgICAgIHZhciBwb2x5cyA9IFtwb2x5Z29uXTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8Y3V0RWRnZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzW2ldO1xyXG4gICAgICAgICAgICAvLyBDdXQgYWxsIHBvbHlzXHJcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBvbHlzLmxlbmd0aDsgaisrKXtcclxuICAgICAgICAgICAgICAgIHZhciBwb2x5ID0gcG9seXNbal07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcG9seWdvblNsaWNlKHBvbHksIGN1dEVkZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYocmVzdWx0KXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBwb2x5ISBDdXQgYW5kIHF1aXRcclxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5zcGxpY2UoaiwxKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKHJlc3VsdFswXSxyZXN1bHRbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcG9seXM7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBXYXMgZ2l2ZW4gb25lIGVkZ2VcclxuICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzO1xyXG4gICAgICAgIHZhciBpID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMF0pO1xyXG4gICAgICAgIHZhciBqID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMV0pO1xyXG5cclxuICAgICAgICBpZihpICE9PSAtMSAmJiBqICE9PSAtMSl7XHJcbiAgICAgICAgICAgIHJldHVybiBbcG9seWdvbkNvcHkocG9seWdvbiwgaSxqKSxcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQ29weShwb2x5Z29uLCBqLGkpXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHRoYXQgdGhlIGxpbmUgc2VnbWVudHMgb2YgdGhpcyBwb2x5Z29uIGRvIG5vdCBpbnRlcnNlY3QgZWFjaCBvdGhlci5cclxuICogQG1ldGhvZCBpc1NpbXBsZVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiB2ZXJ0aWNlcyBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEB0b2RvIFNob3VsZCBpdCBjaGVjayBhbGwgc2VnbWVudHMgd2l0aCBhbGwgb3RoZXJzP1xyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbklzU2ltcGxlKHBvbHlnb24pe1xyXG4gICAgdmFyIHBhdGggPSBwb2x5Z29uLCBpO1xyXG4gICAgLy8gQ2hlY2tcclxuICAgIGZvcihpPTA7IGk8cGF0aC5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICBmb3IodmFyIGo9MDsgajxpLTE7IGorKyl7XHJcbiAgICAgICAgICAgIGlmKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoW2ldLCBwYXRoW2krMV0sIHBhdGhbal0sIHBhdGhbaisxXSApKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayB0aGUgc2VnbWVudCBiZXR3ZWVuIHRoZSBsYXN0IGFuZCB0aGUgZmlyc3QgcG9pbnQgdG8gYWxsIG90aGVyc1xyXG4gICAgZm9yKGk9MTsgaTxwYXRoLmxlbmd0aC0yOyBpKyspe1xyXG4gICAgICAgIGlmKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoW2ldLCBwYXRoW2krMV0gKSl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50KHAxLCBwMiwgcTEsIHEyLCBkZWx0YSl7XHJcblx0ZGVsdGEgPSBkZWx0YSB8fCAwO1xyXG5cdHZhciBhMSA9IHAyWzFdIC0gcDFbMV07XHJcblx0dmFyIGIxID0gcDFbMF0gLSBwMlswXTtcclxuXHR2YXIgYzEgPSAoYTEgKiBwMVswXSkgKyAoYjEgKiBwMVsxXSk7XHJcblx0dmFyIGEyID0gcTJbMV0gLSBxMVsxXTtcclxuXHR2YXIgYjIgPSBxMVswXSAtIHEyWzBdO1xyXG5cdHZhciBjMiA9IChhMiAqIHExWzBdKSArIChiMiAqIHExWzFdKTtcclxuXHR2YXIgZGV0ID0gKGExICogYjIpIC0gKGEyICogYjEpO1xyXG5cclxuXHRpZighc2NhbGFyX2VxKGRldCwwLGRlbHRhKSl7XHJcblx0XHRyZXR1cm4gWygoYjIgKiBjMSkgLSAoYjEgKiBjMikpIC8gZGV0LCAoKGExICogYzIpIC0gKGEyICogYzEpKSAvIGRldF07XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBbMCwwXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFF1aWNrbHkgZGVjb21wb3NlIHRoZSBQb2x5Z29uIGludG8gY29udmV4IHN1Yi1wb2x5Z29ucy5cclxuICogQG1ldGhvZCBxdWlja0RlY29tcFxyXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XHJcbiAqIEBwYXJhbSAge0FycmF5fSBbcmVmbGV4VmVydGljZXNdXHJcbiAqIEBwYXJhbSAge0FycmF5fSBbc3RlaW5lclBvaW50c11cclxuICogQHBhcmFtICB7TnVtYmVyfSBbZGVsdGFdXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW21heGxldmVsXVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtsZXZlbF1cclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uUXVpY2tEZWNvbXAocG9seWdvbiwgcmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpe1xyXG4gICAgbWF4bGV2ZWwgPSBtYXhsZXZlbCB8fCAxMDA7XHJcbiAgICBsZXZlbCA9IGxldmVsIHx8IDA7XHJcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDI1O1xyXG4gICAgcmVzdWx0ID0gdHlwZW9mKHJlc3VsdCkhPT1cInVuZGVmaW5lZFwiID8gcmVzdWx0IDogW107XHJcbiAgICByZWZsZXhWZXJ0aWNlcyA9IHJlZmxleFZlcnRpY2VzIHx8IFtdO1xyXG4gICAgc3RlaW5lclBvaW50cyA9IHN0ZWluZXJQb2ludHMgfHwgW107XHJcblxyXG4gICAgdmFyIHVwcGVySW50PVswLDBdLCBsb3dlckludD1bMCwwXSwgcD1bMCwwXTsgLy8gUG9pbnRzXHJcbiAgICB2YXIgdXBwZXJEaXN0PTAsIGxvd2VyRGlzdD0wLCBkPTAsIGNsb3Nlc3REaXN0PTA7IC8vIHNjYWxhcnNcclxuICAgIHZhciB1cHBlckluZGV4PTAsIGxvd2VySW5kZXg9MCwgY2xvc2VzdEluZGV4PTA7IC8vIEludGVnZXJzXHJcbiAgICB2YXIgbG93ZXJQb2x5PVtdLCB1cHBlclBvbHk9W107IC8vIHBvbHlnb25zXHJcbiAgICB2YXIgcG9seSA9IHBvbHlnb24sXHJcbiAgICAgICAgdiA9IHBvbHlnb247XHJcblxyXG4gICAgaWYodi5sZW5ndGggPCAzKXtcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgbGV2ZWwrKztcclxuICAgIGlmKGxldmVsID4gbWF4bGV2ZWwpe1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcInF1aWNrRGVjb21wOiBtYXggbGV2ZWwgKFwiK21heGxldmVsK1wiKSByZWFjaGVkLlwiKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seSwgaSkpIHtcclxuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5W2ldKTtcclxuICAgICAgICAgICAgdXBwZXJEaXN0ID0gbG93ZXJEaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvbHlnb24ubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpKSB7IC8vIGlmIGxpbmUgaW50ZXJzZWN0cyB3aXRoIGFuIGVkZ2VcclxuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpOyAvLyBmaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSaWdodChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHApKSB7IC8vIG1ha2Ugc3VyZSBpdCdzIGluc2lkZSB0aGUgcG9seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlbaV0sIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGxvd2VyRGlzdCkgeyAvLyBrZWVwIG9ubHkgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckRpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbnQgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGogKyAxKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSwgcG9seWdvbkF0KHBvbHksIGogKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seVtpXSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgdXBwZXJEaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckRpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbnQgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB2ZXJ0aWNlcyB0byBjb25uZWN0IHRvLCBjaG9vc2UgYSBwb2ludCBpbiB0aGUgbWlkZGxlXHJcbiAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID09PSAodXBwZXJJbmRleCArIDEpICUgcG9seWdvbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDE6IFZlcnRleChcIitpK1wiKSwgbG93ZXJJbmRleChcIitsb3dlckluZGV4K1wiKSwgdXBwZXJJbmRleChcIit1cHBlckluZGV4K1wiKSwgcG9seS5zaXplKFwiK3BvbHlnb24ubGVuZ3RoK1wiKVwiKTtcclxuICAgICAgICAgICAgICAgIHBbMF0gPSAobG93ZXJJbnRbMF0gKyB1cHBlckludFswXSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgcFsxXSA9IChsb3dlckludFsxXSArIHVwcGVySW50WzFdKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBzdGVpbmVyUG9pbnRzLnB1c2gocCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCB1cHBlckluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LCBpLCB1cHBlckluZGV4KzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ICE9PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5lbmQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGxvd2VySW5kZXgscG9seS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSwwLGkrMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5lbmQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LGkscG9seS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIHVwcGVySW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwwLHVwcGVySW5kZXgrMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5iZWdpbigpICsgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGxvd2VySW5kZXgsaSsxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIHRoZSB0cmlhbmdsZVxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMjogVmVydGV4KFwiK2krXCIpLCBjbG9zZXN0SW5kZXgoXCIrY2xvc2VzdEluZGV4K1wiKSwgcG9seS5zaXplKFwiK3BvbHlnb24ubGVuZ3RoK1wiKVxcblwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCA+IHVwcGVySW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ICs9IHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHVwcGVySW5kZXggPCBsb3dlckluZGV4KXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gaiAlIHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpIDwgY2xvc2VzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksaSxjbG9zZXN0SW5kZXgrMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGNsb3Nlc3RJbmRleCx2Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LDAsaSsxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLHYubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksMCxjbG9zZXN0SW5kZXgrMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksY2xvc2VzdEluZGV4LGkrMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNvbHZlIHNtYWxsZXN0IHBvbHkgZmlyc3RcclxuICAgICAgICAgICAgaWYgKGxvd2VyUG9seS5sZW5ndGggPCB1cHBlclBvbHkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcclxuICAgICAgICAgICAgICAgIHBvbHlnb25RdWlja0RlY29tcCh1cHBlclBvbHkscmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKHVwcGVyUG9seSxyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQucHVzaChwb2x5Z29uKTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGNvbGxpbmVhciBwb2ludHMgaW4gdGhlIHBvbHlnb24uXHJcbiAqIEBtZXRob2QgcmVtb3ZlQ29sbGluZWFyUG9pbnRzXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVtb3ZlZFxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyhwb2x5Z29uLCBwcmVjaXNpb24pe1xyXG4gICAgdmFyIG51bSA9IDA7XHJcbiAgICBmb3IodmFyIGk9cG9seWdvbi5sZW5ndGgtMTsgcG9seWdvbi5sZW5ndGg+MyAmJiBpPj0wOyAtLWkpe1xyXG4gICAgICAgIGlmKGNvbGxpbmVhcihwb2x5Z29uQXQocG9seWdvbiwgaS0xKSxwb2x5Z29uQXQocG9seWdvbiwgaSkscG9seWdvbkF0KHBvbHlnb24sIGkrMSkscHJlY2lzaW9uKSl7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWlkZGxlIHBvaW50XHJcbiAgICAgICAgICAgIHBvbHlnb24uc3BsaWNlKGklcG9seWdvbi5sZW5ndGgsMSk7XHJcbiAgICAgICAgICAgIG51bSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudW07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0d28gc2NhbGFycyBhcmUgZXF1YWxcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGVxXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGJcclxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gc2NhbGFyX2VxKGEsYixwcmVjaXNpb24pe1xyXG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XHJcbiAgICByZXR1cm4gTWF0aC5hYnMoYS1iKSA8IHByZWNpc2lvbjtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL3BvbHktZGVjb21wL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENyZWF0ZVRleHR1cmUyREltYWdlID0gZnVuY3Rpb24gKGdsLCBwaXhlbHMsIGZpbHRlciwgbWlwTGV2ZWxzKVxyXG57XHJcbiAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgIG1pcExldmVscyA9IG1pcExldmVscyB8fCAwO1xyXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlcik7XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyKTtcclxuICAgIGdsLnRleEltYWdlMkQoXHJcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcclxuICAgICAgICBtaXBMZXZlbHMsXHJcbiAgICAgICAgZ2wuUkdCQSxcclxuICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsXHJcbiAgICAgICAgcGl4ZWxzXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVRleHR1cmUyREltYWdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy90ZXh0dXJlL0NyZWF0ZVRleHR1cmUyREltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxudmFyIEdhbWVPYmplY3RGYWN0b3J5ID0gcmVxdWlyZSgnLi9zeXN0ZW1zL0dhbWVPYmplY3RGYWN0b3J5Jyk7XHJcbnZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xyXG52YXIgU3RhdGVNYW5hZ2VyID0gcmVxdWlyZSgnLi9zeXN0ZW1zL1N0YXRlTWFuYWdlcicpO1xyXG52YXIgTG9hZGVyID0gcmVxdWlyZSgnLi9zeXN0ZW1zL0xvYWRlcicpO1xyXG52YXIgVXBkYXRlTWFuYWdlciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9VcGRhdGVNYW5hZ2VyJyk7XHJcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzJyk7XHJcbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoJy4vU2V0dGluZ3MnKTtcclxudmFyIFJUcmVlID0gcmVxdWlyZSgnLi4vc3RydWN0cy9SVHJlZScpO1xyXG52YXIgQ2FtZXJhTWFuYWdlciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9DYW1lcmFNYW5hZ2VyJyk7XHJcblxyXG52YXIgU3lzdGVtcyA9IGZ1bmN0aW9uIChzdGF0ZSwgY29uZmlnKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5nYW1lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHJcbiAgICB0aGlzLnNldHRpbmdzID0gU2V0dGluZ3MuY3JlYXRlKGNvbmZpZyk7XHJcblxyXG4gICAgdGhpcy54ID0gdGhpcy5zZXR0aW5ncy54O1xyXG4gICAgdGhpcy55ID0gdGhpcy5zZXR0aW5ncy55O1xyXG4gICAgdGhpcy53aWR0aCA9IHRoaXMuc2V0dGluZ3Mud2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuc2V0dGluZ3MuaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMubWFzayA9IG51bGw7XHJcbiAgICB0aGlzLmNhbnZhcztcclxuICAgIHRoaXMuY29udGV4dDtcclxuXHJcbiAgICAvLyAgQ09SRSBTWVNURU1TIC8gUFJPUEVSVElFU1xyXG5cclxuICAgIHRoaXMuY2FjaGU7XHJcbiAgICB0aGlzLnRleHR1cmVzO1xyXG5cclxuICAgIC8vICBSZWZlcmVuY2UgdG8gU3RhdGUgc3BlY2lmaWMgbWFuYWdlcnMgKEZhY3RvcnksIFR3ZWVucywgTG9hZGVyLCBQaHlzaWNzLCBldGMpXHJcbiAgICB0aGlzLmFkZDtcclxuICAgIHRoaXMubWFrZTtcclxuICAgIHRoaXMubG9hZDtcclxuICAgIHRoaXMuZXZlbnRzO1xyXG4gICAgdGhpcy51cGRhdGVzO1xyXG4gICAgdGhpcy50cmVlO1xyXG4gICAgdGhpcy5zdGF0ZU1hbmFnZXI7XHJcblxyXG4gICAgLy8gIFN0YXRlIHByb3BlcnRpZXNcclxuICAgIHRoaXMuY2FtZXJhcztcclxuICAgIHRoaXMuY2hpbGRyZW47XHJcbiAgICB0aGlzLmNvbG9yO1xyXG4gICAgdGhpcy5kYXRhO1xyXG4gICAgLy8gdGhpcy5mYm87XHJcbiAgICB0aGlzLnRpbWU7XHJcbiAgICB0aGlzLnRyYW5zZm9ybTtcclxufTtcclxuXHJcblN5c3RlbXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3lzdGVtcztcclxuXHJcblN5c3RlbXMucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChnYW1lKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdTdGF0ZS5TeXN0ZW1zLmluaXQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICAgICAgU2V0dGluZ3MuaW5pdCh0aGlzLnNldHRpbmdzLCB0aGlzLmdhbWUuY29uZmlnKTtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuc2V0dGluZ3Mud2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnNldHRpbmdzLmhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuZ2FtZS5jYWNoZTtcclxuICAgICAgICB0aGlzLnRleHR1cmVzID0gdGhpcy5nYW1lLnRleHR1cmVzO1xyXG5cclxuICAgICAgICAvLyAgU3RhdGUgc3BlY2lmaWMgbWFuYWdlcnMgKEZhY3RvcnksIFR3ZWVucywgTG9hZGVyLCBQaHlzaWNzLCBldGMpXHJcblxyXG4gICAgICAgIHRoaXMudHJlZSA9IFJUcmVlKDE2KTtcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuICAgICAgICB0aGlzLmFkZCA9IG5ldyBHYW1lT2JqZWN0RmFjdG9yeSh0aGlzLnN0YXRlKTtcclxuICAgICAgICB0aGlzLm1ha2UgPSBuZXcgR2FtZU9iamVjdENyZWF0b3IodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVzID0gbmV3IFVwZGF0ZU1hbmFnZXIodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5sb2FkID0gbmV3IExvYWRlcih0aGlzLnN0YXRlKTtcclxuICAgICAgICB0aGlzLnN0YXRlTWFuYWdlciA9IG5ldyBTdGF0ZU1hbmFnZXIodGhpcy5zdGF0ZSwgZ2FtZSk7XHJcbiAgICAgICAgdGhpcy5jYW1lcmFzID0gbmV3IENhbWVyYU1hbmFnZXIodGhpcy5zdGF0ZSk7XHJcblxyXG4gICAgICAgIC8vICBTdGF0ZSBzcGVjaWZpYyBwcm9wZXJ0aWVzICh0cmFuc2Zvcm0sIGRhdGEsIGNoaWxkcmVuLCBldGMpXHJcblxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgQ29tcG9uZW50LkNoaWxkcmVuKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgQ29tcG9uZW50LkNvbG9yKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBDb21wb25lbnQuRGF0YSh0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbmplY3QoKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5qZWN0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBEZWZhdWx0cyBwcm9wZXJ0aWVzIGluamVjdGVkIGludG8gdGhlIFN0YXRlXHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUuZ2FtZSA9IHRoaXMuZ2FtZTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5ldmVudHMgPSB0aGlzLmV2ZW50cztcclxuICAgICAgICB0aGlzLnN0YXRlLmFkZCA9IHRoaXMuYWRkO1xyXG4gICAgICAgIHRoaXMuc3RhdGUubG9hZCA9IHRoaXMubG9hZDtcclxuICAgICAgICB0aGlzLnN0YXRlLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICAgICAgICB0aGlzLnN0YXRlLmNvbG9yID0gdGhpcy5jb2xvcjtcclxuICAgICAgICB0aGlzLnN0YXRlLmRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zdGF0ZSA9IHRoaXMuc3RhdGVNYW5hZ2VyO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLmNhbWVyYXMgPSB0aGlzLmNhbWVyYXM7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUuY2FjaGUgPSB0aGlzLmdhbWUuY2FjaGU7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dCA9IHRoaXMuZ2FtZS5pbnB1dDtcclxuICAgICAgICB0aGlzLnN0YXRlLnRleHR1cmVzID0gdGhpcy5nYW1lLnRleHR1cmVzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIGp1c3Qgb25jZSBwZXIgZnJhbWUsIHJlZ2FyZGxlc3Mgb2Ygc3BlZWRcclxuICAgIGJlZ2luOiBmdW5jdGlvbiAodGltZXN0YW1wLCBmcmFtZURlbHRhKVxyXG4gICAge1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUG90ZW50aWFsbHkgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHBlciBmcmFtZSAob24gc3VwZXItZmFzdCBzeXN0ZW1zKVxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAodGltZXN0ZXAsIHBoeXNpY3NTdGVwKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhcy51cGRhdGUodGltZXN0ZXApO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZS5jYWxsKHRoaXMuc3RhdGUsIHRpbWVzdGVwLCBwaHlzaWNzU3RlcCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKGludGVycG9sYXRpb24sIHJlbmRlcmVyKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy52aXNpYmxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYW1lcmFzLnJlbmRlcihyZW5kZXJlciwgdGhpcy5jaGlsZHJlbiwgaW50ZXJwb2xhdGlvbik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5c3RlbXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1N5c3RlbXMuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9TeXN0ZW1zLmpzIiwiLyoqXHJcbiogQ3JlYXRlIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcmFuZ2Ugb2YgbnVtYmVycyAodXN1YWxseSBpbnRlZ2VycyksIGJldHdlZW4sIGFuZCBpbmNsdXNpdmUgb2YsXHJcbiogdGhlIGdpdmVuIGBzdGFydGAgYW5kIGBlbmRgIGFyZ3VtZW50cy4gRm9yIGV4YW1wbGU6XHJcbipcclxuKiBgdmFyIGFycmF5ID0gbnVtYmVyQXJyYXkoMiwgNCk7IC8vIGFycmF5ID0gWzIsIDMsIDRdYFxyXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgwLCA5KTsgLy8gYXJyYXkgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV1gXHJcbiogXHJcbiogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBudW1iZXJBcnJheVN0ZXAoc3RhcnQsIGVuZCwgMSlgLlxyXG4qIFxyXG4qIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgcHJlZml4IGFuZCAvIG9yIHN1ZmZpeCBzdHJpbmcuIElmIGdpdmVuIHRoZSBhcnJheSB3aWxsIGNvbnRhaW5cclxuKiBzdHJpbmdzLCBub3QgaW50ZWdlcnMuIEZvciBleGFtcGxlOlxyXG4qIFxyXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgxLCA0LCAnTGV2ZWwgJyk7IC8vIGFycmF5ID0gW1wiTGV2ZWwgMVwiLCBcIkxldmVsIDJcIiwgXCJMZXZlbCAzXCIsIFwiTGV2ZWwgNFwiXWBcclxuKiBgdmFyIGFycmF5ID0gbnVtYmVyQXJyYXkoNSwgNywgJ0hELScsICcucG5nJyk7IC8vIGFycmF5ID0gW1wiSEQtNS5wbmdcIiwgXCJIRC02LnBuZ1wiLCBcIkhELTcucG5nXCJdYFxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQXJyYXlVdGlscyNudW1iZXJBcnJheVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFRoZSBtaW5pbXVtIHZhbHVlIHRoZSBhcnJheSBzdGFydHMgd2l0aC5cclxuKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gVGhlIG1heGltdW0gdmFsdWUgdGhlIGFycmF5IGNvbnRhaW5zLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSAtIE9wdGlvbmFsIHByZWZpeCB0byBwbGFjZSBiZWZvcmUgdGhlIG51bWJlci4gSWYgcHJvdmlkZWQgdGhlIGFycmF5IHdpbGwgY29udGFpbiBzdHJpbmdzLCBub3QgaW50ZWdlcnMuXHJcbiogQHBhcmFtIHtzdHJpbmd9IFtzdWZmaXhdIC0gT3B0aW9uYWwgc3VmZml4IHRvIHBsYWNlIGFmdGVyIHRoZSBudW1iZXIuIElmIHByb3ZpZGVkIHRoZSBhcnJheSB3aWxsIGNvbnRhaW4gc3RyaW5ncywgbm90IGludGVnZXJzLlxyXG4qIEByZXR1cm4ge251bWJlcltdfHN0cmluZ1tdfSBUaGUgYXJyYXkgb2YgbnVtYmVyIHZhbHVlcywgb3Igc3RyaW5ncyBpZiBhIHByZWZpeCBvciBzdWZmaXggd2FzIHByb3ZpZGVkLlxyXG4qL1xyXG52YXIgTnVtYmVyQXJyYXkgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcHJlZml4LCBzdWZmaXgpXHJcbntcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHByZWZpeCB8fCBzdWZmaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gKHByZWZpeCkgPyBwcmVmaXggKyBpLnRvU3RyaW5nKCkgOiBpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3VmZml4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkuY29uY2F0KHN1ZmZpeCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJBcnJheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgVGhpcyBpcyBmcm9tIHRoZSBxdWlja3NlbGVjdCBucG0gcGFja2FnZTogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcXVpY2tzZWxlY3RcclxuLy8gIENvZGVkIGJ5IGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9+bW91cm5lciAoVmxhZGltaXIgQWdhZm9ua2luKVxyXG5cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxveWQlRTIlODAlOTNSaXZlc3RfYWxnb3JpdGhtXHJcblxyXG4vLyBGbG95ZC1SaXZlc3Qgc2VsZWN0aW9uIGFsZ29yaXRobTpcclxuLy8gUmVhcnJhbmdlIGl0ZW1zIHNvIHRoYXQgYWxsIGl0ZW1zIGluIHRoZSBbbGVmdCwga10gcmFuZ2UgYXJlIHNtYWxsZXIgdGhhbiBhbGwgaXRlbXMgaW4gKGssIHJpZ2h0XTtcclxuLy8gVGhlIGstdGggZWxlbWVudCB3aWxsIGhhdmUgdGhlIChrIC0gbGVmdCArIDEpdGggc21hbGxlc3QgdmFsdWUgaW4gW2xlZnQsIHJpZ2h0XVxyXG5cclxudmFyIFF1aWNrU2VsZWN0ID0gZnVuY3Rpb24gKGFyciwgaywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpXHJcbntcclxuICAgIGxlZnQgPSBsZWZ0IHx8IDA7XHJcbiAgICByaWdodCA9IHJpZ2h0IHx8IChhcnIubGVuZ3RoIC0gMSk7XHJcbiAgICBjb21wYXJlID0gY29tcGFyZSB8fCBkZWZhdWx0Q29tcGFyZTtcclxuXHJcbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XHJcbiAgICAgICAgICAgIHZhciBtID0gayAtIGxlZnQgKyAxO1xyXG4gICAgICAgICAgICB2YXIgeiA9IE1hdGgubG9nKG4pO1xyXG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XHJcbiAgICAgICAgICAgIHZhciBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcclxuICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xyXG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcclxuXHJcbiAgICAgICAgICAgIFF1aWNrU2VsZWN0KGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHQgPSBhcnJba107XHJcbiAgICAgICAgdmFyIGkgPSBsZWZ0O1xyXG4gICAgICAgIHZhciBqID0gcmlnaHQ7XHJcblxyXG4gICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBrKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW3JpZ2h0XSwgdCkgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlIChpIDwgailcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcclxuXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgai0tO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2ldLCB0KSA8IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2pdLCB0KSA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGotLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW2xlZnRdLCB0KSA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGogPD0gaylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBqICsgMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChrIDw9IGopXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByaWdodCA9IGogLSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHN3YXAgKGFyciwgaSwgailcclxue1xyXG4gICAgdmFyIHRtcCA9IGFycltpXTtcclxuICAgIGFycltpXSA9IGFycltqXTtcclxuICAgIGFycltqXSA9IHRtcDtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUgKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBRdWlja1NlbGVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvUXVpY2tTZWxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUmVtb3ZlcyBhIHNpbmdsZSBpdGVtIGZyb20gYW4gYXJyYXkgYW5kIHJldHVybnMgaXRcclxuLy8gIHdpdGhvdXQgY3JlYXRpbmcgZ2MgKGxpa2UgdGhlIG5hdGl2ZSBzcGxpY2UgZG9lcylcclxuLy8gIEJhc2VkIG9uIGNvZGUgYnkgTWlrZSBSZWluc3RlaW5cclxuXHJcbnZhciBTcGxpY2VPbmUgPSBmdW5jdGlvbiAoYXJyYXksIGluZGV4KVxyXG57XHJcbiAgICBpZiAoaW5kZXggPj0gYXJyYXkubGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoIC0gMTtcclxuXHJcbiAgICB2YXIgaXRlbSA9IGFycmF5W2luZGV4XTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPCBsZW47IGkrKylcclxuICAgIHtcclxuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgKyAxXTtcclxuICAgIH1cclxuXHJcbiAgICBhcnJheS5sZW5ndGggPSBsZW47XHJcblxyXG4gICAgcmV0dXJuIGl0ZW07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwbGljZU9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvU3BsaWNlT25lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldENlbnRlclggPSByZXF1aXJlKCcuL1NldENlbnRlclgnKTtcclxudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuL1NldENlbnRlclknKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBjZW50ZXIgeCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGAoeCAtIG9mZnNldFgpICsgKHdpZHRoIC8gMilgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGNlbnRlclhcclxuKi9cclxuXHJcbnZhciBDZW50ZXJPbiA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB4LCB5KVxyXG57XHJcbiAgICBTZXRDZW50ZXJYKGdhbWVPYmplY3QsIHgpO1xyXG5cclxuICAgIHJldHVybiBTZXRDZW50ZXJZKGdhbWVPYmplY3QsIHkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYm91bmRzL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYm91bmRzL0NlbnRlck9uLmpzIiwiLyoqXHJcbiogVGhpcyBpcyBhIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgalF1ZXJ5LmlzUGxhaW5PYmplY3QuXHJcbiogQSBwbGFpbiBvYmplY3QgaXMgYW4gb2JqZWN0IHdob3NlIGludGVybmFsIGNsYXNzIHByb3BlcnR5IGlzIFtvYmplY3QgT2JqZWN0XS5cclxuKiBAbWV0aG9kIFBoYXNlci5VdGlscy5pc1BsYWluT2JqZWN0XHJcbiogQHBhcmFtIHtvYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cclxuKiBAcmV0dXJuIHtib29sZWFufSAtIHRydWUgaWYgdGhlIG9iamVjdCBpcyBwbGFpbiwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4qL1xyXG52YXIgSXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIChvYmopXHJcbntcclxuICAgIC8vIE5vdCBwbGFpbiBvYmplY3RzOlxyXG4gICAgLy8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxyXG4gICAgLy8gLSBET00gbm9kZXNcclxuICAgIC8vIC0gd2luZG93XHJcbiAgICBpZiAodHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IG9iaiA9PT0gb2JqLndpbmRvdylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3VwcG9ydDogRmlyZWZveCA8MjBcclxuICAgIC8vIFRoZSB0cnkvY2F0Y2ggc3VwcHJlc3NlcyBleGNlcHRpb25zIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYWNjZXNzXHJcbiAgICAvLyB0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IG9mIGNlcnRhaW4gaG9zdCBvYmplY3RzLCBpZS4gfHdpbmRvdy5sb2NhdGlvbnxcclxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTgxNDYyMlxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmICEoe30pLmhhc093blByb3BlcnR5LmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIGZ1bmN0aW9uIGhhc24ndCByZXR1cm5lZCBhbHJlYWR5LCB3ZSdyZSBjb25maWRlbnQgdGhhdFxyXG4gICAgLy8gfG9ianwgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZWQgYnkge30gb3IgY29uc3RydWN0ZWQgd2l0aCBuZXcgT2JqZWN0XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXNQbGFpbk9iamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvb2JqZWN0L0lzUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQ29uZmlnID0gcmVxdWlyZSgnLi9Db25maWcnKTtcclxudmFyIERlYnVnSGVhZGVyID0gcmVxdWlyZSgnLi9EZWJ1Z0hlYWRlcicpO1xyXG52YXIgRGV2aWNlID0gcmVxdWlyZSgnLi4vZGV2aWNlJyk7XHJcblxyXG52YXIgQWRkVG9ET00gPSByZXF1aXJlKCcuLi9kb20vQWRkVG9ET00nKTtcclxudmFyIERPTUNvbnRlbnRMb2FkZWQgPSByZXF1aXJlKCcuLi9kb20vRE9NQ29udGVudExvYWRlZCcpO1xyXG5cclxudmFyIE1haW5Mb29wID0gcmVxdWlyZSgnLi9NYWluTG9vcCcpO1xyXG52YXIgQ3JlYXRlUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NyZWF0ZVJlbmRlcmVyJyk7XHJcbnZhciBHbG9iYWxJbnB1dE1hbmFnZXIgPSByZXF1aXJlKCcuLi9pbnB1dC9HbG9iYWxJbnB1dE1hbmFnZXInKTtcclxudmFyIEdsb2JhbFN0YXRlTWFuYWdlciA9IHJlcXVpcmUoJy4uL3N0YXRlL0dsb2JhbFN0YXRlTWFuYWdlcicpO1xyXG52YXIgVGV4dHVyZU1hbmFnZXIgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlcicpO1xyXG52YXIgRGF0YSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvRGF0YScpO1xyXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZS9DYWNoZScpO1xyXG5cclxudmFyIEdhbWUgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcoY29uZmlnKTtcclxuXHJcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcclxuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5pc0Jvb3RlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuVGV4dHVyZU1hbmFnZXJ9IHRleHR1cmVzIC0gUmVmZXJlbmNlIHRvIHRoZSBQaGFzZXIgVGV4dHVyZSBNYW5hZ2VyLlxyXG4gICAgKi9cclxuICAgIHRoaXMudGV4dHVyZXMgPSBuZXcgVGV4dHVyZU1hbmFnZXIodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkNhY2hlfSBjYWNoZSAtIFJlZmVyZW5jZSB0byB0aGUgYXNzZXRzIGNhY2hlLlxyXG4gICAgKi9cclxuICAgIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGUoKTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuRGF0YX0gcmVnaXN0cnkgLSBHYW1lIHdpZGUgZGF0YSBzdG9yZS5cclxuICAgICovXHJcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gbmV3IERhdGEodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLklucHV0fSBpbnB1dCAtIFJlZmVyZW5jZSB0byB0aGUgaW5wdXQgbWFuYWdlclxyXG4gICAgKi9cclxuICAgIHRoaXMuaW5wdXQgPSBuZXcgR2xvYmFsSW5wdXRNYW5hZ2VyKHRoaXMsIHRoaXMuY29uZmlnKTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuR2xvYmFsU3RhdGVNYW5hZ2VyfSBzdGF0ZSAtIFRoZSBTdGF0ZU1hbmFnZXIuIFBoYXNlciBpbnN0YW5jZSBzcGVjaWZpYy5cclxuICAgICovXHJcbiAgICB0aGlzLnN0YXRlID0gbmV3IEdsb2JhbFN0YXRlTWFuYWdlcih0aGlzLCB0aGlzLmNvbmZpZy5zdGF0ZUNvbmZpZyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkRldmljZX0gZGV2aWNlIC0gQ29udGFpbnMgZGV2aWNlIGluZm9ybWF0aW9uIGFuZCBjYXBhYmlsaXRpZXMgKHNpbmdsZXRvbilcclxuICAgICovXHJcbiAgICB0aGlzLmRldmljZSA9IERldmljZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuTWFpbkxvb3B9IG1haW5sb29wIC0gTWFpbiBMb29wIGhhbmRsZXIuXHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICovXHJcbiAgICB0aGlzLm1haW5sb29wID0gbmV3IE1haW5Mb29wKHRoaXMsIHRoaXMuY29uZmlnLmZwcyk7XHJcblxyXG4gICAgLy8gIFdhaXQgZm9yIHRoZSBET00gUmVhZHkgZXZlbnQsIHRoZW4gY2FsbCBib290LlxyXG4gICAgRE9NQ29udGVudExvYWRlZCh0aGlzLmJvb3QuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgLy8gIEZvciBkZWJ1Z2dpbmcgb25seVxyXG4gICAgd2luZG93LmdhbWUgPSB0aGlzO1xyXG59O1xyXG5cclxuR2FtZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHYW1lO1xyXG5cclxuR2FtZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmlzQm9vdGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcucHJlQm9vdCgpO1xyXG5cclxuICAgICAgICBEZWJ1Z0hlYWRlcih0aGlzKTtcclxuXHJcbiAgICAgICAgQ3JlYXRlUmVuZGVyZXIodGhpcyk7XHJcblxyXG4gICAgICAgIEFkZFRvRE9NKHRoaXMuY2FudmFzLCB0aGlzLmNvbmZpZy5wYXJlbnQpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLmJvb3QoKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbnB1dC5ib290KCk7XHJcblxyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcucG9zdEJvb3QoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tYWlubG9vcC5zdGFydCgpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYm9vdC9HYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYm9vdC9HYW1lLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQWRkRXZlbnRMaXN0ZW5lcjogcmVxdWlyZSgnLi9BZGRFdmVudExpc3RlbmVyJyksXHJcbiAgICBBZGRUb0RPTTogcmVxdWlyZSgnLi9BZGRUb0RPTScpLFxyXG4gICAgQ2FudmFzSW50ZXJwb2xhdGlvbjogcmVxdWlyZSgnLi9DYW52YXNJbnRlcnBvbGF0aW9uJyksXHJcbiAgICBDYW52YXNQb29sOiByZXF1aXJlKCcuL0NhbnZhc1Bvb2wnKSxcclxuICAgIERPTUNvbnRlbnRMb2FkZWQ6IHJlcXVpcmUoJy4vRE9NQ29udGVudExvYWRlZCcpLFxyXG4gICAgUGFyc2VYTUw6IHJlcXVpcmUoJy4vUGFyc2VYTUwnKSxcclxuICAgIFJlbW92ZUV2ZW50TGlzdGVuZXI6IHJlcXVpcmUoJy4vUmVtb3ZlRXZlbnRMaXN0ZW5lcicpLFxyXG4gICAgUmVtb3ZlRnJvbURPTTogcmVxdWlyZSgnLi9SZW1vdmVGcm9tRE9NJyksXHJcbiAgICBSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHJlcXVpcmUoJy4vUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyksXHJcbiAgICBUb3VjaEFjdGlvbjogcmVxdWlyZSgnLi9Ub3VjaEFjdGlvbicpLFxyXG4gICAgVXNlclNlbGVjdDogcmVxdWlyZSgnLi9Vc2VyU2VsZWN0JylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RvbS9pbmRleC5qcyIsIi8vICBSZXF1aXJlZCwgYnV0IGRvbid0IG5lZWQgUGhhc2VyIGxldmVsIGV4cG9ydHNcclxuLy8gIChtYXliZSB0aGVzZSBzaG91bGQgYmUgUGhhc2VyIGV4cG9ydCBsZXZlbD8pXHJcblxyXG5yZXF1aXJlKCcuL2JsaXR0ZXIvQmxpdHRlckZhY3RvcnknKTtcclxucmVxdWlyZSgnLi9jb250YWluZXIvQ29udGFpbmVyRmFjdG9yeScpO1xyXG5yZXF1aXJlKCcuL2ltYWdlL0ltYWdlRmFjdG9yeScpO1xyXG5yZXF1aXJlKCcuL3Nwcml0ZS9TcHJpdGVGYWN0b3J5Jyk7XHJcbnJlcXVpcmUoJy4vYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dEZhY3RvcnknKTtcclxucmVxdWlyZSgnLi9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5Jyk7XHJcbnJlcXVpcmUoJy4vZ3JhcGhpY3MvR3JhcGhpY3NGYWN0b3J5Jyk7XHJcblxyXG4vLyAgUGhhc2VyLkdhbWVPYmplY3RzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBGYWN0b3J5OiByZXF1aXJlKCcuL0ZhY3RvcnlDb250YWluZXInKSxcclxuXHJcbiAgICBCaXRtYXBUZXh0OiByZXF1aXJlKCcuL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHQnKSxcclxuICAgIER5bmFtaWNCaXRtYXBUZXh0OiByZXF1aXJlKCcuL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dCcpLFxyXG4gICAgQmxpdHRlcjogcmVxdWlyZSgnLi9ibGl0dGVyL0JsaXR0ZXInKSxcclxuICAgIENvbnRhaW5lcjogcmVxdWlyZSgnLi9jb250YWluZXIvQ29udGFpbmVyJyksXHJcbiAgICBJbWFnZTogcmVxdWlyZSgnLi9pbWFnZS9JbWFnZScpLFxyXG4gICAgU3ByaXRlOiByZXF1aXJlKCcuL3Nwcml0ZS9TcHJpdGUnKSxcclxuICAgIEdyYXBoaWNzOiByZXF1aXJlKCcuL2dyYXBoaWNzL0dyYXBoaWNzLmpzJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvaW5kZXguanMiLCIvLyAgUGhhc2VyLkdlb21cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXHJcbiAgICBDaXJjbGU6IHJlcXVpcmUoJy4vY2lyY2xlJyksXHJcbiAgICBFbGxpcHNlOiByZXF1aXJlKCcuL2VsbGlwc2UnKSxcclxuICAgIEhlcm1pdGU6IHJlcXVpcmUoJy4vaGVybWl0ZScpLFxyXG4gICAgSW50ZXJzZWN0czogcmVxdWlyZSgnLi9pbnRlcnNlY3RzJyksXHJcbiAgICBMaW5lOiByZXF1aXJlKCcuL2xpbmUnKSxcclxuICAgIFBvaW50OiByZXF1aXJlKCcuL3BvaW50JyksXHJcbiAgICBQb2x5Z29uOiByZXF1aXJlKCcuL3BvbHlnb24nKSxcclxuICAgIFJlY3RhbmdsZTogcmVxdWlyZSgnLi9yZWN0YW5nbGUnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW5kZXguanMiLCIvLyAgUGhhc2VyLkdyYXBoaWNzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBCbGVuZE1vZGVzOiByZXF1aXJlKCcuL2JsZW5kbW9kZXMnKSxcclxuICAgIENvbG9yOiByZXF1aXJlKCcuL2NvbG9yJylcclxuICBcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9pbmRleC5qcyIsIi8vICBQaGFzZXIuSW5wdXRcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEtleWJvYXJkOiByZXF1aXJlKCcuL2tleWJvYXJkJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5wdXQvaW5kZXguanMiLCIvLyAgUGhhc2VyLlBoeXNpY3NcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgUG9seURlY29tcDogcmVxdWlyZSgnLi9wb2x5LWRlY29tcC8nKSxcclxuICAgIE1hdHRlckpTOiByZXF1aXJlKCcuL21hdHRlci1qcy9tb2R1bGUvbWFpbicpXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL2luZGV4LmpzIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcG9seWZpbGxzL2luZGV4LmpzIiwicmVxdWlyZSgnLi9BcnJheS5mb3JFYWNoJyk7XHJcbnJlcXVpcmUoJy4vQXJyYXkuaXNBcnJheScpO1xyXG5yZXF1aXJlKCcuL0F1ZGlvQ29udGV4dE1vbmtleVBhdGNoJyk7XHJcbnJlcXVpcmUoJy4vY29uc29sZScpO1xyXG5yZXF1aXJlKCcuL0Z1bmN0aW9uLmJpbmQnKTtcclxucmVxdWlyZSgnLi9NYXRoLnRydW5jJyk7XHJcbnJlcXVpcmUoJy4vcGVyZm9ybWFuY2Uubm93Jyk7XHJcbnJlcXVpcmUoJy4vcmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XHJcbnJlcXVpcmUoJy4vVWludDMyQXJyYXknKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5Tb3VuZFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgRHluYW1pYzogcmVxdWlyZSgnLi9keW5hbWljJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NvdW5kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc291bmQvaW5kZXguanMiLCIvLyAgUGhhc2VyLlV0aWxzLkFsaWduXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbkJvdHRvbUNlbnRlcjogcmVxdWlyZSgnLi9JbkJvdHRvbUNlbnRlcicpLFxyXG4gICAgSW5Cb3R0b21MZWZ0OiByZXF1aXJlKCcuL0luQm90dG9tTGVmdCcpLFxyXG4gICAgSW5Cb3R0b21SaWdodDogcmVxdWlyZSgnLi9JbkJvdHRvbVJpZ2h0JyksXHJcbiAgICBJbkNlbnRlcjogcmVxdWlyZSgnLi9JbkNlbnRlcicpLFxyXG4gICAgSW5MZWZ0Q2VudGVyOiByZXF1aXJlKCcuL0luTGVmdENlbnRlcicpLFxyXG4gICAgSW5SaWdodENlbnRlcjogcmVxdWlyZSgnLi9JblJpZ2h0Q2VudGVyJyksXHJcbiAgICBJblRvcENlbnRlcjogcmVxdWlyZSgnLi9JblRvcENlbnRlcicpLFxyXG4gICAgSW5Ub3BMZWZ0OiByZXF1aXJlKCcuL0luVG9wTGVmdCcpLFxyXG4gICAgSW5Ub3BSaWdodDogcmVxdWlyZSgnLi9JblRvcFJpZ2h0JyksXHJcbiAgICBUb0JvdHRvbUNlbnRlcjogcmVxdWlyZSgnLi9Ub0JvdHRvbUNlbnRlcicpLFxyXG4gICAgVG9Cb3R0b21MZWZ0OiByZXF1aXJlKCcuL1RvQm90dG9tTGVmdCcpLFxyXG4gICAgVG9Cb3R0b21SaWdodDogcmVxdWlyZSgnLi9Ub0JvdHRvbVJpZ2h0JyksXHJcbiAgICBUb0xlZnRCb3R0b206IHJlcXVpcmUoJy4vVG9MZWZ0Qm90dG9tJyksXHJcbiAgICBUb0xlZnRDZW50ZXI6IHJlcXVpcmUoJy4vVG9MZWZ0Q2VudGVyJyksXHJcbiAgICBUb0xlZnRUb3A6IHJlcXVpcmUoJy4vVG9MZWZ0VG9wJyksXHJcbiAgICBUb1JpZ2h0Qm90dG9tOiByZXF1aXJlKCcuL1RvUmlnaHRCb3R0b20nKSxcclxuICAgIFRvUmlnaHRDZW50ZXI6IHJlcXVpcmUoJy4vVG9SaWdodENlbnRlcicpLFxyXG4gICAgVG9SaWdodFRvcDogcmVxdWlyZSgnLi9Ub1JpZ2h0VG9wJyksXHJcbiAgICBUb1RvcENlbnRlcjogcmVxdWlyZSgnLi9Ub1RvcENlbnRlcicpLFxyXG4gICAgVG9Ub3BMZWZ0OiByZXF1aXJlKCcuL1RvVG9wTGVmdCcpLFxyXG4gICAgVG9Ub3BSaWdodDogcmVxdWlyZSgnLi9Ub1RvcFJpZ2h0JylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYWxpZ24vaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBGaW5kQ2xvc2VzdEluU29ydGVkOiByZXF1aXJlKCcuL0ZpbmRDbG9zZXN0SW5Tb3J0ZWQnKSxcclxuICAgIEdldFJhbmRvbUVsZW1lbnQ6IHJlcXVpcmUoJy4vR2V0UmFuZG9tRWxlbWVudCcpLFxyXG4gICAgTnVtYmVyQXJyYXk6IHJlcXVpcmUoJy4vTnVtYmVyQXJyYXknKSxcclxuICAgIE51bWJlckFycmF5U3RlcDogcmVxdWlyZSgnLi9OdW1iZXJBcnJheVN0ZXAnKSxcclxuICAgIFF1aWNrU2VsZWN0OiByZXF1aXJlKCcuL1F1aWNrU2VsZWN0JyksXHJcbiAgICBSZW1vdmVSYW5kb21FbGVtZW50OiByZXF1aXJlKCcuL1JlbW92ZVJhbmRvbUVsZW1lbnQnKSxcclxuICAgIFJvdGF0ZUxlZnQ6IHJlcXVpcmUoJy4vUm90YXRlTGVmdCcpLFxyXG4gICAgUm90YXRlUmlnaHQ6IHJlcXVpcmUoJy4vUm90YXRlUmlnaHQnKSxcclxuICAgIFNodWZmbGU6IHJlcXVpcmUoJy4vU2h1ZmZsZScpLFxyXG4gICAgU3BsaWNlT25lOiByZXF1aXJlKCcuL1NwbGljZU9uZScpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FycmF5L2luZGV4LmpzIiwiLy8gIFBoYXNlci5VdGlscy5Cb3VuZHNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIENlbnRlck9uOiByZXF1aXJlKCcuL0NlbnRlck9uJyksXHJcbiAgICBHZXRCb3R0b206IHJlcXVpcmUoJy4vR2V0Qm90dG9tJyksXHJcbiAgICBHZXRDZW50ZXJYOiByZXF1aXJlKCcuL0dldENlbnRlclgnKSxcclxuICAgIEdldENlbnRlclk6IHJlcXVpcmUoJy4vR2V0Q2VudGVyWScpLFxyXG4gICAgR2V0TGVmdDogcmVxdWlyZSgnLi9HZXRMZWZ0JyksXHJcbiAgICBHZXRPZmZzZXRYOiByZXF1aXJlKCcuL0dldE9mZnNldFgnKSxcclxuICAgIEdldE9mZnNldFk6IHJlcXVpcmUoJy4vR2V0T2Zmc2V0WScpLFxyXG4gICAgR2V0UmlnaHQ6IHJlcXVpcmUoJy4vR2V0UmlnaHQnKSxcclxuICAgIEdldFRvcDogcmVxdWlyZSgnLi9HZXRUb3AnKSxcclxuICAgIFNldEJvdHRvbTogcmVxdWlyZSgnLi9TZXRCb3R0b20nKSxcclxuICAgIFNldENlbnRlclg6IHJlcXVpcmUoJy4vU2V0Q2VudGVyWCcpLFxyXG4gICAgU2V0Q2VudGVyWTogcmVxdWlyZSgnLi9TZXRDZW50ZXJZJyksXHJcbiAgICBTZXRMZWZ0OiByZXF1aXJlKCcuL1NldExlZnQnKSxcclxuICAgIFNldFJpZ2h0OiByZXF1aXJlKCcuL1NldFJpZ2h0JyksXHJcbiAgICBTZXRUb3A6IHJlcXVpcmUoJy4vU2V0VG9wJylcclxuICAgIFxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9ib3VuZHMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBFeHRlbmQ6IHJlcXVpcmUoJy4vRXh0ZW5kJyksXHJcbiAgICBJc1BsYWluT2JqZWN0OiByZXF1aXJlKCcuL0lzUGxhaW5PYmplY3QnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvb2JqZWN0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvb2JqZWN0L2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgUGFkOiByZXF1aXJlKCcuL1BhZCcpLFxyXG4gICAgUmV2ZXJzZTogcmVxdWlyZSgnLi9SZXZlcnNlJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL3N0cmluZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL3N0cmluZy9pbmRleC5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBNQVRIID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgTk9PUCA9IHJlcXVpcmUoJy4uL3V0aWxzL05PT1AnKTtcclxudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldE9iamVjdFZhbHVlJyk7XHJcbnZhciBWYWx1ZVRvQ29sb3IgPSByZXF1aXJlKCcuLi9ncmFwaGljcy9jb2xvci9WYWx1ZVRvQ29sb3InKTtcclxuXHJcbnZhciBkZWZhdWx0QmFubmVyQ29sb3IgPSBbXHJcbiAgICAnI2ZmMDAwMCcsXHJcbiAgICAnI2ZmZmYwMCcsXHJcbiAgICAnIzAwZmYwMCcsXHJcbiAgICAnIzAwZmZmZicsXHJcbiAgICAnIzAwMDAwMCdcclxuXTtcclxuXHJcbnZhciBkZWZhdWx0QmFubmVyVGV4dENvbG9yID0gJyNmZmZmZmYnO1xyXG5cclxudmFyIENvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkgeyBjb25maWcgPSB7fTsgfVxyXG5cclxuICAgIHRoaXMud2lkdGggPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd3aWR0aCcsIDEwMjQpO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdoZWlnaHQnLCA3NjgpO1xyXG4gICAgdGhpcy56b29tID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnem9vbScsIDEpO1xyXG5cclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3Jlc29sdXRpb24nLCAxKTtcclxuXHJcbiAgICB0aGlzLnJlbmRlclR5cGUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd0eXBlJywgQ09OU1QuQVVUTyk7XHJcblxyXG4gICAgdGhpcy5wYXJlbnQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdwYXJlbnQnLCBudWxsKTtcclxuICAgIHRoaXMuY2FudmFzID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2FudmFzJywgbnVsbCk7XHJcbiAgICB0aGlzLmNhbnZhc1N0eWxlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2FudmFzU3R5bGUnLCBudWxsKTtcclxuXHJcbiAgICB0aGlzLnN0YXRlQ29uZmlnID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnc3RhdGUnLCBudWxsKTtcclxuXHJcbiAgICB0aGlzLnNlZWQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdzZWVkJywgWyAoRGF0ZS5ub3coKSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCkgXSk7XHJcblxyXG4gICAgTUFUSC5STkQuaW5pdCh0aGlzLnNlZWQpO1xyXG5cclxuICAgIHRoaXMuZ2FtZVRpdGxlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndGl0bGUnLCAnJyk7XHJcbiAgICB0aGlzLmdhbWVVUkwgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd1cmwnLCAnaHR0cDovL3BoYXNlci5pbycpO1xyXG4gICAgdGhpcy5nYW1lVmVyc2lvbiA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3ZlcnNpb24nLCAnJyk7XHJcblxyXG4gICAgLy8gIElucHV0XHJcbiAgICB0aGlzLmlucHV0S2V5Ym9hcmQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdpbnB1dC5rZXlib2FyZCcsIHRydWUpO1xyXG4gICAgdGhpcy5pbnB1dEtleWJvYXJkRXZlbnRUYXJnZXQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdpbnB1dC5rZXlib2FyZC50YXJnZXQnLCB3aW5kb3cpO1xyXG5cclxuICAgIC8vICBJZiB5b3UgZG86IHsgYmFubmVyOiBmYWxzZSB9IGl0IHdvbid0IGRpc3BsYXkgYW55IGJhbm5lciBhdCBhbGxcclxuICAgIHRoaXMuaGlkZUJhbm5lciA9IChHZXRPYmplY3RWYWx1ZShjb25maWcsICdiYW5uZXInLCBudWxsKSA9PT0gZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuaGlkZVBoYXNlciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Jhbm5lci5oaWRlUGhhc2VyJywgZmFsc2UpO1xyXG4gICAgdGhpcy5iYW5uZXJUZXh0Q29sb3IgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdiYW5uZXIudGV4dCcsIGRlZmF1bHRCYW5uZXJUZXh0Q29sb3IpO1xyXG4gICAgdGhpcy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdiYW5uZXIuYmFja2dyb3VuZCcsIGRlZmF1bHRCYW5uZXJDb2xvcik7XHJcbiAgIFxyXG4gICAgdGhpcy5mcHMgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdmcHMnLCA2MCk7XHJcbiAgICB0aGlzLmZvcmNlU2V0VGltZU91dCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2ZvcmNlU2V0VGltZU91dCcsIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLnBpeGVsQXJ0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncGl4ZWxBcnQnLCBmYWxzZSk7XHJcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndHJhbnNwYXJlbnQnLCBmYWxzZSk7XHJcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2xlYXJCZWZvcmVSZW5kZXInLCB0cnVlKTtcclxuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gVmFsdWVUb0NvbG9yKEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2JhY2tncm91bmRDb2xvcicsIDApKTtcclxuICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gVmFsdWVUb0NvbG9yKEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3ByZXNlcnZlRHJhd2luZ0J1ZmZlcicsIGZhbHNlKSk7XHJcblxyXG4gICAgLy8gIENhbGxiYWNrc1xyXG4gICAgdGhpcy5wcmVCb290ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2FsbGJhY2tzLnByZUJvb3QnLCBOT09QKTtcclxuICAgIHRoaXMucG9zdEJvb3QgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdjYWxsYmFja3MucG9zdEJvb3QnLCBOT09QKTtcclxuXHJcbiAgICAvLyAgRGVmYXVsdCAvIE1pc3NpbmcgSW1hZ2VzXHJcbiAgICB0aGlzLmRlZmF1bHRJbWFnZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2ltYWdlcy5kZWZhdWx0JywgJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0FRTUFBQUJKdE9pM0FBQUFBMUJNVkVYLy8vK254QnZJQUFBQUFYUlNUbE1BUU9iWVpnQUFBQlZKUkVGVWVGN053SUVBQUFBQWdLRDlxZGVvY0FNQW9BQUJtM0RrY0FBQUFBQkpSVTVFcmtKZ2dnPT0nKTtcclxuICAgIHRoaXMubWlzc2luZ0ltYWdlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnaW1hZ2VzLm1pc3NpbmcnLCAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FJQUFBRDhHTzJqQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFKOUpSRUZVZU5xMDFzc093eUFNUkZHNDZ2Ly9NdDFFU21naCtERm1FMkdQT0JBUktiMk5Wam8rMTdQWExEOGExK3BsNStBK3dTZ0Z5Z3ltV1lIQmIwRnRzS2hKRGRabG5jRzJJeko0YXlvTUR2MjB3VG1TTXpDbEVnYldZTlRBa1EwWitPSitBL2VXbkFhUjkrb3hDRjRPczBIOGh0c01VcCtwd2NnQkJpTU5uQXdGOEdxSWdMMmhBemFHRkZnWmF1RFBLQUJtb3daNEdMMzY5LzByd0FDcDJ5QS90dG12c1FBQUFBQkpSVTVFcmtKZ2dnPT0nKTtcclxufTtcclxuXHJcbkNvbmZpZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25maWc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbmZpZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYm9vdC9Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ib290L0NvbmZpZy5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vZG9tL0NhbnZhc1Bvb2wnKTtcclxudmFyIEZlYXR1cmVzID0gcmVxdWlyZSgnLi4vZGV2aWNlL0ZlYXR1cmVzJyk7XHJcbnZhciBDYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL2NhbnZhcy9DYW52YXNSZW5kZXJlcicpO1xyXG52YXIgV2ViR0xSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXInKTtcclxudmFyIENhbnZhc0ludGVycG9sYXRpb24gPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzSW50ZXJwb2xhdGlvbicpO1xyXG5cclxuLyoqXHJcbiogQ2hlY2tzIGlmIHRoZSBkZXZpY2UgaXMgY2FwYWJsZSBvZiB1c2luZyB0aGUgcmVxdWVzdGVkIHJlbmRlcmVyIGFuZCBzZXRzIGl0IHVwIG9yIGFuIGFsdGVybmF0aXZlIGlmIG5vdC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkdhbWUjc2V0VXBSZW5kZXJlclxyXG4qIEBwcm90ZWN0ZWRcclxuKi9cclxudmFyIENyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24gKGdhbWUpXHJcbntcclxuICAgIHZhciBjb25maWcgPSBnYW1lLmNvbmZpZztcclxuXHJcbiAgICAvLyAgR2FtZSBlaXRoZXIgcmVxdWVzdGVkIENhbnZhcyxcclxuICAgIC8vICBvciByZXF1ZXN0ZWQgQVVUTyBvciBXRUJHTCBidXQgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGl0LCBzbyBmYWxsIGJhY2sgdG8gQ2FudmFzXHJcbiAgICBpZiAoY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULkNBTlZBUyB8fCAoY29uZmlnLnJlbmRlclR5cGUgIT09IENPTlNULkNBTlZBUyAmJiAhRmVhdHVyZXMud2ViR0wpKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChGZWF0dXJlcy5jYW52YXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVGhleSByZXF1ZXN0ZWQgQ2FudmFzIGFuZCB0aGVpciBicm93c2VyIHN1cHBvcnRzIGl0XHJcbiAgICAgICAgICAgIGNvbmZpZy5yZW5kZXJUeXBlID0gQ09OU1QuQ0FOVkFTO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgQ2FudmFzIG9yIFdlYkdMIGNvbnRleHQsIGFib3J0aW5nLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgR2FtZSByZXF1ZXN0ZWQgV2ViR0wgYW5kIGJyb3dzZXIgc2F5cyBpdCBzdXBwb3J0cyBpdFxyXG4gICAgICAgIGNvbmZpZy5yZW5kZXJUeXBlID0gQ09OU1QuV0VCR0w7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIERvZXMgdGhlIGdhbWUgY29uZmlnIHByb3ZpZGUgaXRzIG93biBjYW52YXMgZWxlbWVudCB0byB1c2U/XHJcbiAgICBpZiAoY29uZmlnLmNhbnZhcylcclxuICAgIHtcclxuICAgICAgICBnYW1lLmNhbnZhcyA9IGNvbmZpZy5jYW52YXM7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZS5jYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZShnYW1lLCBjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQsIGNvbmZpZy5yZW5kZXJUeXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRG9lcyB0aGUgZ2FtZSBjb25maWcgcHJvdmlkZSBzb21lIGNhbnZhcyBjc3Mgc3R5bGVzIHRvIHVzZT9cclxuICAgIGlmIChjb25maWcuY2FudmFzU3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZS5jYW52YXMuc3R5bGUgPSBjb25maWcuY2FudmFzU3R5bGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFBpeGVsIEFydCBtb2RlP1xyXG4gICAgaWYgKGNvbmZpZy5waXhlbEFydClcclxuICAgIHtcclxuICAgICAgICBDYW52YXNJbnRlcnBvbGF0aW9uLnNldENyaXNwKGdhbWUuY2FudmFzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgWm9vbWVkP1xyXG4gICAgaWYgKGNvbmZpZy56b29tICE9PSAxKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWUuY2FudmFzLnN0eWxlLndpZHRoID0gKGNvbmZpZy53aWR0aCAqIGNvbmZpZy56b29tKS50b1N0cmluZygpICsgJ3B4JztcclxuICAgICAgICBnYW1lLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAoY29uZmlnLmhlaWdodCAqIGNvbmZpZy56b29tKS50b1N0cmluZygpICsgJ3B4JztcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQ3JlYXRlIHRoZSByZW5kZXJlclxyXG4gICAgaWYgKGNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5XRUJHTClcclxuICAgIHtcclxuICAgICAgICBnYW1lLnJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoZ2FtZSk7XHJcbiAgICAgICAgZ2FtZS5jb250ZXh0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBnYW1lLnJlbmRlcmVyID0gbmV3IENhbnZhc1JlbmRlcmVyKGdhbWUpO1xyXG4gICAgICAgIGdhbWUuY29udGV4dCA9IGdhbWUucmVuZGVyZXIuZ2FtZUNvbnRleHQ7XHJcblxyXG4gICAgICAgIC8vICBkZWJ1Z1xyXG4gICAgICAgIGdhbWUuY2FudmFzLmlkID0gJ2dhbWUnO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYm9vdC9DcmVhdGVSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2Jvb3QvQ3JlYXRlUmVuZGVyZXIuanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgQ0hFQ0tTVU0gPSByZXF1aXJlKCcuLi9jaGVja3N1bScpO1xyXG5cclxudmFyIERlYnVnSGVhZGVyID0gZnVuY3Rpb24gKGdhbWUpXHJcbntcclxuICAgIHZhciBjb25maWcgPSBnYW1lLmNvbmZpZztcclxuXHJcbiAgICBpZiAoY29uZmlnLmhpZGVCYW5uZXIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZW5kZXJUeXBlID0gKGNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5DQU5WQVMpID8gJ0NhbnZhcycgOiAnV2ViR0wnO1xyXG5cclxuICAgIHZhciBpZSA9IGZhbHNlO1xyXG5cclxuICAgIGlmICghaWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGMgPSAnJztcclxuICAgICAgICB2YXIgYXJncyA9IFtjXTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmJhbm5lckJhY2tncm91bmRDb2xvcikpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbGFzdENvbG9yO1xyXG5cclxuICAgICAgICAgICAgY29uZmlnLmJhbm5lckJhY2tncm91bmRDb2xvci5mb3JFYWNoKGZ1bmN0aW9uKGNvbG9yKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYyA9IGMuY29uY2F0KCclYyAnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2JhY2tncm91bmQ6ICcgKyBjb2xvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgbGFzdENvbG9yID0gY29sb3I7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vICBpbmplY3QgdGhlIHRleHQgY29sb3JcclxuICAgICAgICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdID0gJ2NvbG9yOiAnICsgY29uZmlnLmJhbm5lclRleHRDb2xvciArICc7IGJhY2tncm91bmQ6ICcgKyBsYXN0Q29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnJWMgJyk7XHJcblxyXG4gICAgICAgICAgICBhcmdzLnB1c2goJ2NvbG9yOiAnICsgY29uZmlnLmJhbm5lclRleHRDb2xvciArICc7IGJhY2tncm91bmQ6ICcgKyBjb25maWcuYmFubmVyQmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBVUkwgbGluayBiYWNrZ3JvdW5kIGNvbG9yIChhbHdheXMgd2hpdGUpXHJcbiAgICAgICAgYXJncy5wdXNoKCdiYWNrZ3JvdW5kOiAjZmZmJyk7XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuZ2FtZVRpdGxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYyA9IGMuY29uY2F0KGNvbmZpZy5nYW1lVGl0bGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5nYW1lVmVyc2lvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYyA9IGMuY29uY2F0KCcgdicgKyBjb25maWcuZ2FtZVZlcnNpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5oaWRlUGhhc2VyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjID0gYy5jb25jYXQoJyAvICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZy5oaWRlUGhhc2VyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYyA9IGMuY29uY2F0KCdQaGFzZXIgdicgKyBDT05TVC5WRVJTSU9OICsgJyAoJyArIHJlbmRlclR5cGUgKyAnKScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYyA9IGMuY29uY2F0KCcgJWMgJyArIGNvbmZpZy5nYW1lVVJMKTtcclxuXHJcbiAgICAgICAgLy8gIEluamVjdCB0aGUgbmV3IHN0cmluZyBiYWNrIGludG8gdGhlIGFyZ3MgYXJyYXlcclxuICAgICAgICBhcmdzWzBdID0gYztcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh3aW5kb3dbJ2NvbnNvbGUnXSlcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnUGhhc2VyIHYnICsgQ09OU1QuVkVSU0lPTiArICcgLyBodHRwOi8vcGhhc2VyLmlvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gS2VlcCB0aGlzIGR1cmluZyBkZXYgYnVpbGQgb25seVxyXG4gICAgY29uc29sZS5sb2coQ0hFQ0tTVU0uYnVpbGQpO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGVidWdIZWFkZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2Jvb3QvRGVidWdIZWFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ib290L0RlYnVnSGVhZGVyLmpzIiwidmFyIFJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoJy4uL2RvbS9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcclxuXHJcbi8vIE15IHRoYW5rcyB0byBJc2FhYyBTdWtpbiBmb3IgY3JlYXRpbmcgTWFpbkxvb3AuanMsIG9uIHdoaWNoIGxvdHMgb2YgdGhpcyBpcyBiYXNlZC5cclxuXHJcbnZhciBNYWluTG9vcCA9IGZ1bmN0aW9uIChnYW1lLCBmcmFtZXJhdGUpXHJcbntcclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZX0gcmFmIC0gQXV0b21hdGljYWxseSBoYW5kbGVzIHRoZSBjb3JlIGdhbWUgbG9vcCB2aWEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG9yIHNldFRpbWVvdXRcclxuICAgICogQHByb3RlY3RlZFxyXG4gICAgKi9cclxuICAgIHRoaXMucmFmID0gbmV3IFJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZXN0ZXAgLSBUaGUgYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdG8gc2ltdWxhdGUgZWFjaCB0aW1lIHVwZGF0ZSgpIHJ1bnMuXHJcbiAgICAqL1xyXG4gICAgdGhpcy50aW1lc3RlcCA9IDEwMDAgLyBmcmFtZXJhdGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaHlzaWNzU3RlcCAtIDEgLyBmcmFtZXJhdGUuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5waHlzaWNzU3RlcCA9IDEgLyBmcmFtZXJhdGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmFtZURlbHRhIC0gVGhlIGN1bXVsYXRpdmUgYW1vdW50IG9mIGluLWFwcCB0aW1lIHRoYXQgaGFzbid0IGJlZW4gc2ltdWxhdGVkIHlldC5cclxuICAgICovXHJcbiAgICB0aGlzLmZyYW1lRGVsdGEgPSAwO1xyXG5cclxuICAgIHRoaXMuZGlzY2FyZGVkVGltZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzIG9mIHRoZSBsYXN0IHRpbWUgdGhlIG1haW4gbG9vcCB3YXMgcnVuLlxyXG4gICAgKiBVc2VkIHRvIGNvbXB1dGUgdGhlIHRpbWUgZWxhcHNlZCBiZXR3ZWVuIGZyYW1lcy5cclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RGcmFtZVRpbWVNc1xyXG4gICAgKi9cclxuICAgIHRoaXMubGFzdEZyYW1lVGltZU1zID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGZwcyAtIEFuIGV4cG9uZW50aWFsIG1vdmluZyBhdmVyYWdlIG9mIHRoZSBmcmFtZXMgcGVyIHNlY29uZC5cclxuICAgICovXHJcbiAgICB0aGlzLmZwcyA9IDYwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gbGFzdEZwc1VwZGF0ZSAtIFRoZSB0aW1lc3RhbXAgKGluIG1pbGxpc2Vjb25kcykgb2YgdGhlIGxhc3QgdGltZSB0aGUgYGZwc2AgbW92aW5nIGF2ZXJhZ2Ugd2FzIHVwZGF0ZWQuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGZyYW1lc1RoaXNTZWNvbmQgLSBUaGUgbnVtYmVyIG9mIGZyYW1lcyBkZWxpdmVyZWQgaW4gdGhlIGN1cnJlbnQgc2Vjb25kLlxyXG4gICAgKi9cclxuICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBudW1VcGRhdGVTdGVwcyAtIFRoZSBudW1iZXIgb2YgdGltZXMgdXBkYXRlKCkgaXMgY2FsbGVkIGluIGEgZ2l2ZW4gZnJhbWUuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5udW1VcGRhdGVTdGVwcyA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyB0aGF0IG11c3QgcGFzcyBzaW5jZSB0aGUgbGFzdCBmcmFtZSB3YXMgZXhlY3V0ZWRcclxuICAgICogYmVmb3JlIGFub3RoZXIgZnJhbWUgY2FuIGJlIGV4ZWN1dGVkLlxyXG4gICAgKiBUaGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBjYXBzIHRoZSBGUFMgKHRoZSBkZWZhdWx0IG9mIHplcm8gbWVhbnMgdGhlcmUgaXMgbm8gY2FwKVxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluRnJhbWVEZWxheVxyXG4gICAgKi9cclxuICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcnVubmluZyAtIFdoZXRoZXIgdGhlIG1haW4gbG9vcCBpcyBydW5uaW5nLlxyXG4gICAgKi9cclxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogYHRydWVgIGlmIGBNYWluTG9vcC5zdGFydCgpYCBoYXMgYmVlbiBjYWxsZWQgYW5kIHRoZSBtb3N0IHJlY2VudCB0aW1lIGl0XHJcbiAgICAgKiB3YXMgY2FsbGVkIGhhcyBub3QgYmVlbiBmb2xsb3dlZCBieSBhIGNhbGwgdG8gYE1haW5Mb29wLnN0b3AoKWAuIFRoaXMgaXNcclxuICAgICAqIGRpZmZlcmVudCB0aGFuIGBydW5uaW5nYCBiZWNhdXNlIHRoZXJlIGlzIGEgZGVsYXkgb2YgYSBmZXcgbWlsbGlzZWNvbmRzXHJcbiAgICAgKiBhZnRlciBgTWFpbkxvb3Auc3RhcnQoKWAgaXMgY2FsbGVkIGJlZm9yZSB0aGUgYXBwbGljYXRpb24gaXMgY29uc2lkZXJlZFxyXG4gICAgICogXCJydW5uaW5nLlwiIFRoaXMgZGVsYXkgaXMgZHVlIHRvIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGZyYW1lLlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0YXJ0ZWRcclxuICAgICovXHJcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIHNpbXVsYXRpb24gaGFzIGZhbGxlbiB0b28gZmFyIGJlaGluZCByZWFsIHRpbWUuXHJcbiAgICAgKiBTcGVjaWZpY2FsbHksIGBwYW5pY2Agd2lsbCBiZSBzZXQgdG8gYHRydWVgIGlmIHRvbyBtYW55IHVwZGF0ZXMgb2NjdXIgaW5cclxuICAgICAqIG9uZSBmcmFtZS4gVGhpcyBpcyBvbmx5IHJlbGV2YW50IGluc2lkZSBvZiBhbmltYXRlKCksIGJ1dCBhIHJlZmVyZW5jZSBpc1xyXG4gICAgICogaGVsZCBleHRlcm5hbGx5IHNvIHRoYXQgdGhpcyB2YXJpYWJsZSBpcyBub3QgbWFya2VkIGZvciBnYXJiYWdlXHJcbiAgICAgKiBjb2xsZWN0aW9uIGV2ZXJ5IHRpbWUgdGhlIG1haW4gbG9vcCBydW5zLlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhbmljIC0gV2hldGhlciB0aGUgc2ltdWxhdGlvbiBoYXMgZmFsbGVuIHRvbyBmYXIgYmVoaW5kIHJlYWwgdGltZS5cclxuICAgICovXHJcbiAgICB0aGlzLnBhbmljID0gZmFsc2U7XHJcbn07XHJcblxyXG5NYWluTG9vcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYWluTG9vcDtcclxuXHJcbk1haW5Mb29wLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRNYXhGUFM6IGZ1bmN0aW9uIChmcHMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGZwcyA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAxMDAwIC8gZnBzO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TWF4RlBTOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxMDAwIC8gdGhpcy5taW5GcmFtZURlbGF5O1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldEZyYW1lRGVsdGE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG9sZEZyYW1lRGVsdGEgPSB0aGlzLmZyYW1lRGVsdGE7XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiBvbGRGcmFtZURlbHRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5zdGFydGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZU1zID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICB0aGlzLmZyYW1lc1RoaXNTZWNvbmQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnJhZi5zdGFydCh0aGlzLnN0ZXAuYmluZCh0aGlzKSwgdGhpcy5nYW1lLmNvbmZpZy5mb3JjZVNldFRpbWVPdXQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgdGltZXN0YW1wID0gRE9NSGlnaFJlc1RpbWVTdGFtcFxyXG4gICAgLy8gYWN0aXZlID0gYXJyYXkgY29udGFpbmluZzogKHsgaW5kZXg6IGksIHN0YXRlOiBzdGF0ZSB9KVxyXG5cclxuICAgIHN0ZXA6IGZ1bmN0aW9uICh0aW1lc3RhbXApXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuZ2FtZS5zdGF0ZS5hY3RpdmU7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nYW1lLnJlbmRlcmVyO1xyXG5cclxuICAgICAgICB2YXIgbGVuID0gYWN0aXZlLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gVGhyb3R0bGUgdGhlIGZyYW1lIHJhdGUgKGlmIG1pbkZyYW1lRGVsYXkgaXMgc2V0IHRvIGEgbm9uLXplcm8gdmFsdWUgYnlcclxuICAgICAgICAvLyBgTWFpbkxvb3Auc2V0TWF4QWxsb3dlZEZQUygpYCkuXHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCB8fCB0aW1lc3RhbXAgPCB0aGlzLmxhc3RGcmFtZVRpbWVNcyArIHRoaXMubWluRnJhbWVEZWxheSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZyYW1lRGVsdGEgaXMgdGhlIGN1bXVsYXRpdmUgYW1vdW50IG9mIGluLWFwcCB0aW1lIHRoYXQgaGFzbid0IGJlZW5cclxuICAgICAgICAvLyBzaW11bGF0ZWQgeWV0LiBBZGQgdGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgZnJhbWUuIFdlIG5lZWQgdG8gdHJhY2sgdG90YWxcclxuICAgICAgICAvLyBub3QteWV0LXNpbXVsYXRlZCB0aW1lIChhcyBvcHBvc2VkIHRvIGp1c3QgdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGVcclxuICAgICAgICAvLyBsYXN0IGZyYW1lKSBiZWNhdXNlIG5vdCBhbGwgYWN0dWFsbHkgZWxhcHNlZCB0aW1lIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgICAgICAvLyBzaW11bGF0ZWQgZWFjaCBmcmFtZS4gU2VlIHRoZSBjb21tZW50cyBiZWxvdyBmb3IgZGV0YWlscy5cclxuICAgICAgICB0aGlzLmZyYW1lRGVsdGEgKz0gdGltZXN0YW1wIC0gdGhpcy5sYXN0RnJhbWVUaW1lTXM7XHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lTXMgPSB0aW1lc3RhbXA7XHJcblxyXG4gICAgICAgIC8vICBHbG9iYWwgTWFuYWdlcnMgKFRpbWUsIElucHV0LCBldGMpXHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZS5pbnB1dC51cGRhdGUodGltZXN0YW1wLCB0aGlzLmZyYW1lRGVsdGEpO1xyXG5cclxuICAgICAgICAvLyAgUnVuIGFueSB1cGRhdGVzIHRoYXQgYXJlIG5vdCBkZXBlbmRlbnQgb24gdGltZSBpbiB0aGUgc2ltdWxhdGlvbi5cclxuICAgICAgICAvLyAgSGVyZSB3ZSdsbCBuZWVkIHRvIHJ1biB0aGluZ3MgbGlrZSB0d2Vlbi51cGRhdGUsIGlucHV0LnVwZGF0ZSwgZXRjLlxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWN0aXZlW2ldLnN0YXRlLnN5cy5iZWdpbih0aW1lc3RhbXAsIHRoaXMuZnJhbWVEZWx0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGVzdGltYXRlIG9mIHRoZSBmcmFtZSByYXRlLCBgZnBzYC4gRXZlcnkgc2Vjb25kLCB0aGUgbnVtYmVyXHJcbiAgICAgICAgLy8gb2YgZnJhbWVzIHRoYXQgb2NjdXJyZWQgaW4gdGhhdCBzZWNvbmQgYXJlIGluY2x1ZGVkIGluIGFuIGV4cG9uZW50aWFsXHJcbiAgICAgICAgLy8gbW92aW5nIGF2ZXJhZ2Ugb2YgYWxsIGZyYW1lcyBwZXIgc2Vjb25kLCB3aXRoIGFuIGFscGhhIG9mIDAuMjUuIFRoaXNcclxuICAgICAgICAvLyBtZWFucyB0aGF0IG1vcmUgcmVjZW50IHNlY29uZHMgYWZmZWN0IHRoZSBlc3RpbWF0ZWQgZnJhbWUgcmF0ZSBtb3JlIHRoYW5cclxuICAgICAgICAvLyBvbGRlciBzZWNvbmRzLlxyXG4gICAgICAgIGlmICh0aW1lc3RhbXAgPiB0aGlzLmxhc3RGcHNVcGRhdGUgKyAxMDAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbmV3IGV4cG9uZW50aWFsIG1vdmluZyBhdmVyYWdlIHdpdGggYW4gYWxwaGEgb2YgMC4yNS5cclxuICAgICAgICAgICAgLy8gVXNpbmcgY29uc3RhbnRzIGlubGluZSBpcyBva2F5IGhlcmUuXHJcbiAgICAgICAgICAgIHRoaXMuZnBzID0gMC4yNSAqIHRoaXMuZnJhbWVzVGhpc1NlY29uZCArIDAuNzUgKiB0aGlzLmZwcztcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgdGhpcy5mcmFtZXNUaGlzU2Vjb25kID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCsrO1xyXG5cclxuICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhbWVEZWx0YSA+PSB0aGlzLnRpbWVzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVbaV0uc3RhdGUuc3lzLnVwZGF0ZSh0aGlzLnRpbWVzdGVwLCB0aGlzLnBoeXNpY3NTdGVwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5mcmFtZURlbHRhIC09IHRoaXMudGltZXN0ZXA7XHJcblxyXG4gICAgICAgICAgICBpZiAoKyt0aGlzLm51bVVwZGF0ZVN0ZXBzID49IDI0MClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYW5pYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFJlbmRlclxyXG5cclxuICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbiA9IHRoaXMuZnJhbWVEZWx0YSAvIHRoaXMudGltZXN0ZXA7XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnByZVJlbmRlcigpO1xyXG5cclxuICAgICAgICAvLyAgVGhpcyB1c2VzIGFjdGl2ZS5sZW5ndGgsIGluIGNhc2Ugc3RhdGUudXBkYXRlIHJlbW92ZWQgdGhlIHN0YXRlIGZyb20gdGhlIGFjdGl2ZSBsaXN0XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVtpXS5zdGF0ZS5zeXMucmVuZGVyKGludGVycG9sYXRpb24sIHJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnBvc3RSZW5kZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucGFuaWMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHBhdHRlcm4gaW50cm9kdWNlcyBub24tZGV0ZXJtaW5pc3RpYyBiZWhhdmlvciwgYnV0IGluIHRoaXMgY2FzZVxyXG4gICAgICAgICAgICAvLyBpdCdzIGJldHRlciB0aGFuIHRoZSBhbHRlcm5hdGl2ZSAodGhlIGFwcGxpY2F0aW9uIHdvdWxkIGxvb2sgbGlrZSBpdFxyXG4gICAgICAgICAgICAvLyB3YXMgcnVubmluZyB2ZXJ5IHF1aWNrbHkgdW50aWwgdGhlIHNpbXVsYXRpb24gY2F1Z2h0IHVwIHRvIHJlYWxcclxuICAgICAgICAgICAgLy8gdGltZSkuXHJcbiAgICAgICAgICAgIHRoaXMuZGlzY2FyZGVkVGltZSA9IE1hdGgucm91bmQodGhpcy5yZXNldEZyYW1lRGVsdGEoKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ01haW4gbG9vcCBwYW5pY2tlZCwgdGFiIHByb2JhYmx5IHB1dCBpbiB0aGUgYmFja2dyb3VuZC4gRGlzY2FyZGluZyAnICsgZGlzY2FyZGVkVGltZSArICdtcycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wYW5pYyA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1haW5Mb29wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ib290L01haW5Mb29wLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYm9vdC9NYWluTG9vcC5qcyIsInZhciBDYWNoZUVudHJ5ID0gcmVxdWlyZSgnLi9DYWNoZUVudHJ5Jyk7XHJcbnZhciBFdmVudHMgPSByZXF1aXJlKCcuL2V2ZW50cycpO1xyXG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xyXG5cclxudmFyIEJhc2VDYWNoZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuZW50cmllcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxufTtcclxuXHJcbkJhc2VDYWNoZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCYXNlQ2FjaGU7XHJcblxyXG5CYXNlQ2FjaGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGtleSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmVudHJpZXMuc2V0KGtleSwgZGF0YSk7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudHMuQ0FDSEVfQUREX0VWRU5UKHRoaXMsIGtleSwgZGF0YSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXM6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5oYXMoa2V5KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMuZ2V0KGtleSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmdldChrZXkpO1xyXG5cclxuICAgICAgICBpZiAoZW50cnkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmVudHJpZXMuZGVsZXRlKGtleSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnRzLkNBQ0hFX1JFTU9WRV9FVkVOVCh0aGlzLCBrZXksIGVudHJ5LmRhdGEpKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlQ2FjaGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NhY2hlL0Jhc2VDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NhY2hlL0Jhc2VDYWNoZS5qcyIsInZhciBCYXNlQ2FjaGUgPSByZXF1aXJlKCcuL0Jhc2VDYWNoZScpO1xyXG5cclxudmFyIENhY2hlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5zb3VuZCA9IG5ldyBCYXNlQ2FjaGUoKTtcclxuICAgIHRoaXMudmlkZW8gPSBuZXcgQmFzZUNhY2hlKCk7XHJcbiAgICB0aGlzLnRleHQgPSBuZXcgQmFzZUNhY2hlKCk7XHJcbiAgICB0aGlzLmpzb24gPSBuZXcgQmFzZUNhY2hlKCk7XHJcbiAgICB0aGlzLnhtbCA9IG5ldyBCYXNlQ2FjaGUoKTtcclxuICAgIHRoaXMucGh5c2ljcyA9IG5ldyBCYXNlQ2FjaGUoKTtcclxuICAgIHRoaXMudGlsZW1hcCA9IG5ldyBCYXNlQ2FjaGUoKTtcclxuICAgIHRoaXMuYmluYXJ5ID0gbmV3IEJhc2VDYWNoZSgpO1xyXG4gICAgdGhpcy5iaXRtYXBGb250ID0gbmV3IEJhc2VDYWNoZSgpO1xyXG4gICAgdGhpcy5zaGFkZXIgPSBuZXcgQmFzZUNhY2hlKCk7XHJcblxyXG4gICAgdGhpcy5jdXN0b20gPSB7fTtcclxufTtcclxuXHJcbkNhY2hlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhY2hlO1xyXG5cclxuQ2FjaGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8vICBBZGQgeW91ciBvd24gY3VzdG9tIENhY2hlIGVudHJ5LCBhdmFpbGFibGUgdW5kZXIgQ2FjaGUuY3VzdG9tLmtleVxyXG4gICAgYWRkQ3VzdG9tOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5jdXN0b20uaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tW2tleV0gPSBuZXcgQmFzZUNhY2hlKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY2FjaGUvQ2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jYWNoZS9DYWNoZS5qcyIsInZhciBDYWNoZUVudHJ5ID0gZnVuY3Rpb24gKGtleSwgdXJsLCBkYXRhKVxyXG57XHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuXHJcbiAgICB0aGlzLnVybCA9IHVybDtcclxuXHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG59O1xyXG5cclxuQ2FjaGVFbnRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYWNoZUVudHJ5O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZUVudHJ5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jYWNoZS9DYWNoZUVudHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgQ2FjaGVBZGRFdmVudCA9IGZ1bmN0aW9uIChjYWNoZSwga2V5LCBkYXRhKVxyXG57XHJcbiAgICBFdmVudC5jYWxsKHRoaXMsICdDQUNIRV9BRERfRVZFTlQnKTtcclxuXHJcbiAgICB0aGlzLmNhY2hlID0gY2FjaGU7XHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbn07XHJcblxyXG5DYWNoZUFkZEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuQ2FjaGVBZGRFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYWNoZUFkZEV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZUFkZEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jYWNoZS9ldmVudHMvQ2FjaGVBZGRFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NhY2hlL2V2ZW50cy9DYWNoZUFkZEV2ZW50LmpzIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgQ2FjaGVSZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChjYWNoZSwga2V5LCBkYXRhKVxyXG57XHJcbiAgICBFdmVudC5jYWxsKHRoaXMsICdDQUNIRV9BRERfRVZFTlQnKTtcclxuXHJcbiAgICB0aGlzLmNhY2hlID0gY2FjaGU7XHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbn07XHJcblxyXG5DYWNoZVJlbW92ZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuQ2FjaGVSZW1vdmVFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYWNoZVJlbW92ZUV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZVJlbW92ZUV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jYWNoZS9ldmVudHMvQ2FjaGVSZW1vdmVFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NhY2hlL2V2ZW50cy9DYWNoZVJlbW92ZUV2ZW50LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ0FDSEVfQUREX0VWRU5UOiByZXF1aXJlKCcuL0NhY2hlQWRkRXZlbnQnKSxcclxuICAgIENBQ0hFX1JFTU9WRV9FVkVOVDogcmVxdWlyZSgnLi9DYWNoZVJlbW92ZUV2ZW50JylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NhY2hlL2V2ZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NhY2hlL2V2ZW50cy9pbmRleC5qcyIsInZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xyXG5cclxudmFyIENhbWVyYSA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMuc2Nyb2xsWCA9IDAuMDtcclxuICAgIHRoaXMuc2Nyb2xsWSA9IDAuMDtcclxuICAgIHRoaXMuem9vbSA9IDEuMDtcclxuICAgIHRoaXMucm90YXRpb24gPSAwLjA7XHJcbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoMSwgMCwgMCwgMSwgMCwgMCk7XHJcblxyXG4gICAgLy8gc2hha2VcclxuICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSAwLjA7XHJcbiAgICB0aGlzLl9zaGFrZUludGVuc2l0eSA9IDAuMDtcclxuICAgIHRoaXMuX3NoYWtlT2Zmc2V0WCA9IDAuMDtcclxuICAgIHRoaXMuX3NoYWtlT2Zmc2V0WSA9IDAuMDtcclxuXHJcbiAgICAvLyBmYWRlXHJcbiAgICB0aGlzLl9mYWRlRHVyYXRpb24gPSAwLjA7XHJcbiAgICB0aGlzLl9mYWRlUmVkID0gMC4wO1xyXG4gICAgdGhpcy5fZmFkZUdyZWVuID0gMC4wO1xyXG4gICAgdGhpcy5fZmFkZUJsdWUgPSAwLjA7XHJcbiAgICB0aGlzLl9mYWRlQWxwaGEgPSAwLjA7XHJcblxyXG4gICAgLy8gZmxhc2hcclxuICAgIHRoaXMuX2ZsYXNoRHVyYXRpb24gPSAwLjA7XHJcbiAgICB0aGlzLl9mbGFzaFJlZCA9IDEuMDtcclxuICAgIHRoaXMuX2ZsYXNoR3JlZW4gPSAxLjA7XHJcbiAgICB0aGlzLl9mbGFzaEJsdWUgPSAxLjA7XHJcbiAgICB0aGlzLl9mbGFzaEFscGhhID0gMC4wO1xyXG5cclxuICAgIC8vIG9yaWdpblxyXG4gICAgdGhpcy5fZm9sbG93ID0gbnVsbDtcclxufTtcclxuXHJcbkNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW1lcmE7XHJcblxyXG5DYW1lcmEucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldFZpZXdwb3J0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkZWx0YSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5fZmxhc2hBbHBoYSA+IDAuMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZsYXNoQWxwaGEgLT0gZGVsdGEgLyB0aGlzLl9mbGFzaER1cmF0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZsYXNoQWxwaGEgPCAwLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZsYXNoQWxwaGEgPSAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mYWRlQWxwaGEgPiAwLjAgJiYgdGhpcy5fZmFkZUFscGhhIDwgMS4wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fZmFkZUFscGhhICs9IGRlbHRhIC8gdGhpcy5fZmFkZUR1cmF0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZhZGVBbHBoYSA+PSAxLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZhZGVBbHBoYSA9IDEuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3NoYWtlRHVyYXRpb24gPiAwLjApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaW50ZW5zaXR5ID0gdGhpcy5fc2hha2VJbnRlbnNpdHk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uIC09IGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NoYWtlRHVyYXRpb24gPD0gMC4wKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFggPSAwLjA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFkgPSAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFggPSAoTWF0aC5yYW5kb20oKSAqIGludGVuc2l0eSAqIHRoaXMud2lkdGggKiAyIC0gaW50ZW5zaXR5ICogdGhpcy53aWR0aCkgKiB0aGlzLnpvb207XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFkgPSAoTWF0aC5yYW5kb20oKSAqIGludGVuc2l0eSAqIHRoaXMuaGVpZ2h0ICogMiAtIGludGVuc2l0eSAqIHRoaXMuaGVpZ2h0KSAqIHRoaXMuem9vbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRGb2xsb3c6IGZ1bmN0aW9uIChnYW1lT2JqZWN0T3JQb2ludClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5fZm9sbG93ICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wRm9sbG93KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9mb2xsb3cgPSBnYW1lT2JqZWN0T3JQb2ludDtcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcEZvbGxvdzogZnVuY3Rpb24gKCkgXHJcbiAgICB7XHJcbiAgICAgICAgLyogZG8gdW5mb2xsb3cgd29yayBoZXJlICovXHJcbiAgICAgICAgdGhpcy5fZm9sbG93ID0gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgZmxhc2g6IGZ1bmN0aW9uIChkdXJhdGlvbiwgcmVkLCBncmVlbiwgYmx1ZSwgZm9yY2UpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFmb3JjZSAmJiB0aGlzLl9mbGFzaEFscGhhID4gMC4wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlZCA9PT0gdW5kZWZpbmVkKSB7IHJlZCA9IDEuMDsgfVxyXG4gICAgICAgIGlmIChncmVlbiA9PT0gdW5kZWZpbmVkKSB7IGdyZWVuID0gMS4wOyB9XHJcbiAgICAgICAgaWYgKGJsdWUgPT09IHVuZGVmaW5lZCkgeyBibHVlID0gMS4wOyB9XHJcblxyXG4gICAgICAgIHRoaXMuX2ZsYXNoUmVkID0gcmVkO1xyXG4gICAgICAgIHRoaXMuX2ZsYXNoR3JlZW4gPSBncmVlbjtcclxuICAgICAgICB0aGlzLl9mbGFzaEJsdWUgPSBibHVlO1xyXG5cclxuICAgICAgICBpZiAoZHVyYXRpb24gPD0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gTnVtYmVyLk1JTl9WQUxVRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2ZsYXNoRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB0aGlzLl9mbGFzaEFscGhhID0gMS4wO1xyXG4gICAgfSxcclxuXHJcbiAgICBmYWRlOiBmdW5jdGlvbiAoZHVyYXRpb24sIHJlZCwgZ3JlZW4sIGJsdWUsIGZvcmNlKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyZWQgPT09IHVuZGVmaW5lZCkgeyByZWQgPSAwLjA7IH1cclxuICAgICAgICBpZiAoZ3JlZW4gPT09IHVuZGVmaW5lZCkgeyBncmVlbiA9IDAuMDsgfVxyXG4gICAgICAgIGlmIChibHVlID09PSB1bmRlZmluZWQpIHsgYmx1ZSA9IDAuMDsgfVxyXG5cclxuICAgICAgICBpZiAoIWZvcmNlICYmIHRoaXMuX2ZhZGVBbHBoYSA+IDAuMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2ZhZGVSZWQgPSByZWQ7XHJcbiAgICAgICAgdGhpcy5fZmFkZUdyZWVuID0gZ3JlZW47XHJcbiAgICAgICAgdGhpcy5fZmFkZUJsdWUgPSBibHVlO1xyXG5cclxuICAgICAgICBpZiAoZHVyYXRpb24gPD0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gTnVtYmVyLk1JTl9WQUxVRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2ZhZGVEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX2ZhZGVBbHBoYSA9IE51bWJlci5NSU5fVkFMVUU7XHJcbiAgICB9LFxyXG5cclxuICAgIHNoYWtlOiBmdW5jdGlvbiAoZHVyYXRpb24sIGludGVuc2l0eSwgZm9yY2UpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGludGVuc2l0eSA9PT0gdW5kZWZpbmVkKSB7IGludGVuc2l0eSA9IDAuMDU7IH1cclxuXHJcbiAgICAgICAgaWYgKCFmb3JjZSAmJiAodGhpcy5fc2hha2VPZmZzZXRYICE9PSAwLjAgfHwgdGhpcy5fc2hha2VPZmZzZXRZICE9PSAwLjApKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc2hha2VEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX3NoYWtlSW50ZW5zaXR5ID0gaW50ZW5zaXR5O1xyXG4gICAgICAgIHRoaXMuX3NoYWtlT2Zmc2V0WCA9IDA7XHJcbiAgICAgICAgdGhpcy5fc2hha2VPZmZzZXRZID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgcHJlUmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB6b29tID0gdGhpcy56b29tO1xyXG4gICAgICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuICAgICAgICB2YXIgb3JpZ2luWCA9IHdpZHRoIC8gMjtcclxuICAgICAgICB2YXIgb3JpZ2luWSA9IGhlaWdodCAvIDI7XHJcbiAgICAgICAgdmFyIGZvbGxvdyA9IHRoaXMuX2ZvbGxvdztcclxuXHJcbiAgICAgICAgaWYgKGZvbGxvdyAhPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3JpZ2luWCA9IGZvbGxvdy54O1xyXG4gICAgICAgICAgICBvcmlnaW5ZID0gZm9sbG93Lnk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFggPSBvcmlnaW5YIC0gd2lkdGggKiAwLjU7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsWSA9IG9yaWdpblkgLSBoZWlnaHQgKiAwLjU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXRyaXgubG9hZElkZW50aXR5KCk7XHJcbiAgICAgICAgbWF0cml4LnRyYW5zbGF0ZSh0aGlzLnggKyBvcmlnaW5YLCB0aGlzLnkgKyBvcmlnaW5ZKTtcclxuICAgICAgICBtYXRyaXgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgIG1hdHJpeC5zY2FsZSh6b29tLCB6b29tKTtcclxuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKC1vcmlnaW5YLCAtb3JpZ2luWSk7XHJcbiAgICAgICAgbWF0cml4LnRyYW5zbGF0ZSh0aGlzLl9zaGFrZU9mZnNldFgsIHRoaXMuX3NoYWtlT2Zmc2V0WSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbWVyYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY2FtZXJhL0NhbWVyYS5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NhbWVyYS9DYW1lcmEuanMiLCJ2YXIgQ0hFQ0tTVU0gPSB7XG5idWlsZDogJ2ExMjY0YmUwLTA4ZDQtMTFlNy1hYzBjLThiYmVlMWMzZjExYydcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENIRUNLU1VNO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NoZWNrc3VtLmpzXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYW1wID0gcmVxdWlyZSgnLi4vbWF0aC9DbGFtcCcpO1xyXG5cclxuLy8gIEFscGhhIENvbXBvbmVudFxyXG5cclxuLy8gIGJpdG1hc2sgZmxhZyBmb3IgR2FtZU9iamVjdC5yZW5kZXJNYXNrXHJcbnZhciBfRkxBRyA9IDI7IC8vIDAwMTBcclxuXHJcbnZhciBBbHBoYSA9IHtcclxuXHJcbiAgICBfYWxwaGE6IDEsXHJcblxyXG4gICAgYWxwaGE6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSBDbGFtcCh2YWx1ZSwgMCwgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWxwaGEgPT09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgJj0gfl9GTEFHO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyB8PSBfRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbHBoYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9BbHBoYS5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvQWxwaGEuanMiLCJ2YXIgQmxlbmRNb2RlcyA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL0JsZW5kTW9kZXMnKTtcclxuXHJcbi8vICBCbGVuZE1vZGUgQ29tcG9uZW50XHJcblxyXG52YXIgQmxlbmRNb2RlID0ge1xyXG5cclxuICAgIF9ibGVuZE1vZGU6IEJsZW5kTW9kZXMuTk9STUFMLFxyXG5cclxuICAgIGJsZW5kTW9kZToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsdWUgfCAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kTW9kZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJsZW5kTW9kZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9CbGVuZE1vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzL0JsZW5kTW9kZS5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFRoZSBDaGlsZHJlbiBDb21wb25lbnQgZmVhdHVyZXMgcXVpY2sgYWNjZXNzIHRvIEdyb3VwIHNvcnRpbmcgcmVsYXRlZCBtZXRob2RzLlxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcbnZhciBDaGlsZHJlbiA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xyXG5cclxuICAgIC8vICBUaGUgb2JqZWN0cyB0aGF0IGJlbG9uZyB0byB0aGlzIGNvbGxlY3Rpb24uXHJcbiAgICAvLyAgVGhlIGVxdWl2YWxlbnQgb2YgdGhlIG9sZCBgU3ByaXRlLmNoaWxkcmVuYCBhcnJheS5cclxuICAgIHRoaXMubGlzdCA9IFtdO1xyXG5cclxuICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG59O1xyXG5cclxuQ2hpbGRyZW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2hpbGRyZW47XHJcblxyXG5DaGlsZHJlbi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLT4nLCB0aGlzLmdhbWVPYmplY3QsICdhZGRzIG5ldyBjaGlsZDonLCBjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2hpbGRyZW4uYWRkIDEnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZC5wYXJlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2hpbGRyZW4uYWRkIDInKTtcclxuICAgICAgICAgICAgY2hpbGQucGFyZW50LmNoaWxkcmVuLnJlbW92ZShjaGlsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzLmdhbWVPYmplY3Q7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdC5wdXNoKGNoaWxkKTtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJzwtLS0gZW5kJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXQ6IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxpc3QubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGNoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDw9IHRoaXMubGlzdC5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQuY2hpbGRyZW4ucmVtb3ZlKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGlzdC5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZE11bHRpcGxlOiBmdW5jdGlvbiAoY2hpbGRyZW4pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEF0OiBmdW5jdGlvbiAoaW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtpbmRleF07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFJldHVybiAtMSBpZiBnaXZlbiBjaGlsZCBpc24ndCBhIGNoaWxkIG9mIHRoaXMgcGFyZW50XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5pbmRleE9mKGNoaWxkKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgdGhlIGZpcnN0IGl0ZW0gZnJvbSB0aGUgc2V0IGJhc2VkIG9uIHRoZSBwcm9wZXJ0eSBzdHJpY3RseSBlcXVhbGluZyB0aGUgdmFsdWUgZ2l2ZW4uXHJcbiAgICAqIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkFycmF5U2V0I2dldEJ5S2V5XHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSBwcm9wZXJ0eSB0byBjaGVjayBhZ2FpbnN0IHRoZSB2YWx1ZS5cclxuICAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrIGlmIHRoZSBwcm9wZXJ0eSBzdHJpY3RseSBlcXVhbHMuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGl0ZW0gdGhhdCB3YXMgZm91bmQsIG9yIG51bGwgaWYgbm90aGluZyBtYXRjaGVkLlxyXG4gICAgKi9cclxuICAgIGdldEJ5S2V5OiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdFtpXVtwcm9wZXJ0eV0gPT09IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNlYXJjaGVzIHRoZSBHcm91cCBmb3IgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGEgY2hpbGQgd2l0aCB0aGUgYG5hbWVgXHJcbiAgICAqIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBnaXZlbiBhcmd1bWVudC4gU2hvdWxkIG1vcmUgdGhhbiBvbmUgY2hpbGQgaGF2ZVxyXG4gICAgKiB0aGUgc2FtZSBuYW1lIG9ubHkgdGhlIGZpcnN0IGluc3RhbmNlIGlzIHJldHVybmVkLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNnZXRCeU5hbWVcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSB0byBzZWFyY2ggZm9yLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBmaXJzdCBjaGlsZCB3aXRoIGEgbWF0Y2hpbmcgbmFtZSwgb3IgbnVsbCBpZiBub25lIHdlcmUgZm91bmQuXHJcbiAgICAqL1xyXG4gICAgZ2V0QnlOYW1lOiBmdW5jdGlvbiAobmFtZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCeUtleSgnbmFtZScsIG5hbWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBjaGlsZCBmcm9tIHRoZSBncm91cC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjZ2V0UmFuZG9tXHJcbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0SW5kZXg9MF0gLSBPZmZzZXQgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIGdyb3VwIChsb3dlc3QgY2hpbGQpLlxyXG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGg9KHRvIHRvcCldIC0gUmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiB2YWx1ZXMgeW91IHdhbnQgdG8gcmFuZG9tbHkgc2VsZWN0IGZyb20uXHJcbiAgICAqIEByZXR1cm4ge2FueX0gQSByYW5kb20gY2hpbGQgb2YgdGhpcyBHcm91cC5cclxuICAgICovXHJcbiAgICBnZXRSYW5kb206IGZ1bmN0aW9uIChzdGFydEluZGV4LCBsZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCkgeyBzdGFydEluZGV4ID0gMDsgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XHJcblxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IDAgfHwgbGVuZ3RoID4gdGhpcy5saXN0Lmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJhbmRvbUluZGV4ID0gc3RhcnRJbmRleCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RbcmFuZG9tSW5kZXhdO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRGaXJzdDogZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCkgeyBzdGFydEluZGV4ID0gMDsgfVxyXG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IGVuZEluZGV4ID0gdGhpcy5saXN0Lmxlbmd0aDsgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmxpc3RbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hpbGRbcHJvcGVydHldID09PSB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYWxsIGNoaWxkcmVuIGluIHRoaXMgR3JvdXAuXHJcbiAgICAqXHJcbiAgICAqIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IGEgbWF0Y2hpbmcgY3JpdGVyaWEgdXNpbmcgdGhlIGBwcm9wZXJ0eWAgYW5kIGB2YWx1ZWAgYXJndW1lbnRzLlxyXG4gICAgKlxyXG4gICAgKiBGb3IgZXhhbXBsZTogYGdldEFsbCgnZXhpc3RzJywgdHJ1ZSlgIHdvdWxkIHJldHVybiBvbmx5IGNoaWxkcmVuIHRoYXQgaGF2ZSB0aGVpciBleGlzdHMgcHJvcGVydHkgc2V0LlxyXG4gICAgKlxyXG4gICAgKiBPcHRpb25hbGx5IHlvdSBjYW4gc3BlY2lmeSBhIHN0YXJ0IGFuZCBlbmQgaW5kZXguIEZvciBleGFtcGxlIGlmIHRoaXMgR3JvdXAgaGFkIDEwMCBjaGlsZHJlbixcclxuICAgICogYW5kIHlvdSBzZXQgYHN0YXJ0SW5kZXhgIHRvIDAgYW5kIGBlbmRJbmRleGAgdG8gNTAsIGl0IHdvdWxkIHJldHVybiBtYXRjaGVzIGZyb20gb25seVxyXG4gICAgKiB0aGUgZmlyc3QgNTAgY2hpbGRyZW4gaW4gdGhlIEdyb3VwLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNnZXRBbGxcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBBbiBvcHRpb25hbCBwcm9wZXJ0eSB0byB0ZXN0IGFnYWluc3QgdGhlIHZhbHVlIGFyZ3VtZW50LlxyXG4gICAgKiBAcGFyYW0ge2FueX0gW3ZhbHVlXSAtIElmIHByb3BlcnR5IGlzIHNldCB0aGVuIENoaWxkLnByb3BlcnR5IG11c3Qgc3RyaWN0bHkgZXF1YWwgdGhpcyB2YWx1ZSB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0cy5cclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnRJbmRleD0wXSAtIFRoZSBmaXJzdCBjaGlsZCBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGZyb20uXHJcbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZEluZGV4XSAtIFRoZSBsYXN0IGNoaWxkIGluZGV4IHRvIHNlYXJjaCB1cCB1bnRpbC5cclxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBleGlzdGluZyBjaGlsZCBvZiB0aGlzIEdyb3VwLlxyXG4gICAgKi9cclxuICAgIGdldEFsbDogZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCkgeyBzdGFydEluZGV4ID0gMDsgfVxyXG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IGVuZEluZGV4ID0gdGhpcy5saXN0Lmxlbmd0aDsgfVxyXG5cclxuICAgICAgICB2YXIgb3V0cHV0ID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMubGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkW3Byb3BlcnR5XSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSxcclxuXHJcbiAgICBzd2FwOiBmdW5jdGlvbiAoY2hpbGQxLCBjaGlsZDIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNoaWxkMSA9PT0gY2hpbGQyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGluZGV4MSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQxKTtcclxuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5nZXRJbmRleChjaGlsZDIpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXgxIDwgMCB8fCBpbmRleDIgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZHJlbi5zd2FwOiBTdXBwbGllZCBvYmplY3RzIG11c3QgYmUgY2hpbGRyZW4gb2YgdGhlIHNhbWUgcGFyZW50Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxpc3RbaW5kZXgxXSA9IGNoaWxkMjtcclxuICAgICAgICB0aGlzLmxpc3RbaW5kZXgyXSA9IGNoaWxkMTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gICB3YXMgc2V0SW5kZXhcclxuICAgIG1vdmVUbzogZnVuY3Rpb24gKGNoaWxkLCBpbmRleClcclxuICAgIHtcclxuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5nZXRJbmRleChjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxpc3QubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZHJlbi5tb3ZlVG86IFRoZSBzdXBwbGllZCBpbmRleCBpcyBvdXQgb2YgYm91bmRzJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgUmVtb3ZlXHJcbiAgICAgICAgdGhpcy5saXN0LnNwbGljZShjdXJyZW50SW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAvLyAgQWRkIGluIG5ldyBsb2NhdGlvblxyXG4gICAgICAgIHRoaXMubGlzdC5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxpc3QuaW5kZXhPZihjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVBdDogZnVuY3Rpb24gKGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMubGlzdFtpbmRleF07XHJcblxyXG4gICAgICAgIGlmIChjaGlsZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQmV0d2VlbjogZnVuY3Rpb24gKGJlZ2luSW5kZXgsIGVuZEluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChiZWdpbkluZGV4ID09PSB1bmRlZmluZWQpIHsgYmVnaW5JbmRleCA9IDA7IH1cclxuICAgICAgICBpZiAoZW5kSW5kZXggPT09IHVuZGVmaW5lZCkgeyBlbmRJbmRleCA9IHRoaXMubGlzdC5sZW5ndGg7IH1cclxuXHJcbiAgICAgICAgdmFyIHJhbmdlID0gZW5kSW5kZXggLSBiZWdpbkluZGV4O1xyXG5cclxuICAgICAgICBpZiAocmFuZ2UgPiAwICYmIHJhbmdlIDw9IGVuZEluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLmxpc3Quc3BsaWNlKGJlZ2luSW5kZXgsIHJhbmdlKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFtpXS5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyYW5nZSA9PT0gMCAmJiB0aGlzLmxpc3QubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLnJlbW92ZUJldHdlZW46IFJhbmdlIEVycm9yLCBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJlbW92ZXMgYWxsIHRoZSBpdGVtcy5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjcmVtb3ZlQWxsXHJcbiAgICAqL1xyXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5saXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRoaXMubGlzdFtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENoZWNrIHRvIHNlZSBpZiB0aGUgZ2l2ZW4gY2hpbGQgaXMgYSBjaGlsZCBvZiB0aGlzIG9iamVjdCwgYXQgYW55IGRlcHRoIChyZWN1cnNpdmVseSBzY2FucyB1cCB0aGUgdHJlZSlcclxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFjaGlsZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zKGNoaWxkLnBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQnJpbmdzIHRoZSBnaXZlbiBjaGlsZCB0byB0aGUgdG9wIG9mIHRoaXMgZ3JvdXAgc28gaXQgcmVuZGVycyBhYm92ZSBhbGwgb3RoZXIgY2hpbGRyZW4uXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI2JyaW5nVG9Ub3BcclxuICAgICogQHBhcmFtIHthbnl9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIGJyaW5nIHRvIHRoZSB0b3Agb2YgdGhpcyBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgYnJpbmdUb1RvcDogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMgJiYgdGhpcy5nZXRJbmRleChjaGlsZCkgPCB0aGlzLmxpc3QubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTZW5kcyB0aGUgZ2l2ZW4gY2hpbGQgdG8gdGhlIGJvdHRvbSBvZiB0aGlzIGdyb3VwIHNvIGl0IHJlbmRlcnMgYmVsb3cgYWxsIG90aGVyIGNoaWxkcmVuLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNzZW5kVG9CYWNrXHJcbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBzZW5kIHRvIHRoZSBib3R0b20gb2YgdGhpcyBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMgJiYgdGhpcy5nZXRJbmRleChjaGlsZCkgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEF0KGNoaWxkLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIE1vdmVzIHRoZSBnaXZlbiBjaGlsZCB1cCBvbmUgcGxhY2UgaW4gdGhpcyBncm91cCB1bmxlc3MgaXQncyBhbHJlYWR5IGF0IHRoZSB0b3AuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI21vdmVVcFxyXG4gICAgKiBAcGFyYW0ge2FueX0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gbW92ZSB1cCBpbiB0aGUgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGNoaWxkIHRoYXQgd2FzIG1vdmVkLlxyXG4gICAgKi9cclxuICAgIG1vdmVVcDogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRJbmRleChjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChhICE9PSAtMSAmJiBhIDwgdGhpcy5saXN0Lmxlbmd0aCAtIDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0QXQoYSArIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3dhcChjaGlsZCwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIE1vdmVzIHRoZSBnaXZlbiBjaGlsZCBkb3duIG9uZSBwbGFjZSBpbiB0aGlzIGdyb3VwIHVubGVzcyBpdCdzIGFscmVhZHkgYXQgdGhlIGJvdHRvbS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjbW92ZURvd25cclxuICAgICogQHBhcmFtIHthbnl9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIG1vdmUgZG93biBpbiB0aGUgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGNoaWxkIHRoYXQgd2FzIG1vdmVkLlxyXG4gICAgKi9cclxuICAgIG1vdmVEb3duOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldEluZGV4KGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGEgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmdldEF0KGEgLSAxKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN3YXAoY2hpbGQsIGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXZlcnNlcyBhbGwgY2hpbGRyZW4gaW4gdGhpcyBncm91cC5cclxuICAgICpcclxuICAgICogVGhpcyBvcGVyYXRpb24gYXBwbGllcyBvbmx5IHRvIGltbWVkaWF0ZSBjaGlsZHJlbiBhbmQgZG9lcyBub3QgcHJvcGFnYXRlIHRvIHN1Ymdyb3Vwcy5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjcmV2ZXJzZVxyXG4gICAgKi9cclxuICAgIHJldmVyc2U6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5saXN0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNodWZmbGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGlzdC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmxpc3RbaV07XHJcbiAgICAgICAgICAgIHRoaXMubGlzdFtpXSA9IHRoaXMubGlzdFtqXTtcclxuICAgICAgICAgICAgdGhpcy5saXN0W2pdID0gdGVtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmVwbGFjZXMgYSBjaGlsZCBvZiB0aGlzIEdyb3VwIHdpdGggdGhlIGdpdmVuIG5ld0NoaWxkLiBUaGUgbmV3Q2hpbGQgY2Fubm90IGJlIGEgbWVtYmVyIG9mIHRoaXMgR3JvdXAuXHJcbiAgICAqXHJcbiAgICAqIElmIGBHcm91cC5lbmFibGVCb2R5YCBpcyBzZXQsIHRoZW4gYSBwaHlzaWNzIGJvZHkgd2lsbCBiZSBjcmVhdGVkIG9uIHRoZSBvYmplY3QsIHNvIGxvbmcgYXMgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXHJcbiAgICAqXHJcbiAgICAqIElmIGBHcm91cC5pbnB1dEVuYWJsZUNoaWxkcmVuYCBpcyBzZXQsIHRoZW4gYW4gSW5wdXQgSGFuZGxlciB3aWxsIGJlIGNyZWF0ZWQgb24gdGhlIG9iamVjdCwgc28gbG9uZyBhcyBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjcmVwbGFjZVxyXG4gICAgKiBAcGFyYW0ge2FueX0gb2xkQ2hpbGQgLSBUaGUgY2hpbGQgaW4gdGhpcyBncm91cCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQuXHJcbiAgICAqIEBwYXJhbSB7YW55fSBuZXdDaGlsZCAtIFRoZSBjaGlsZCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoaXMgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gUmV0dXJucyB0aGUgb2xkQ2hpbGQgdGhhdCB3YXMgcmVwbGFjZWQgd2l0aGluIHRoaXMgZ3JvdXAuXHJcbiAgICAqL1xyXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKG9sZENoaWxkLCBuZXdDaGlsZClcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KG9sZENoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLnBhcmVudC5yZW1vdmUobmV3Q2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShvbGRDaGlsZCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZEF0KG5ld0NoaWxkLCBpbmRleCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb2xkQ2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU3dhcHMgYSBjaGlsZCBmcm9tIGFub3RoZXIgcGFyZW50LCB3aXRoIG9uZSBmcm9tIHRoaXMgcGFyZW50LlxyXG4gICAgLy8gIGNoaWxkMSA9IHRoZSBjaGlsZCBvZiBUSElTIHBhcmVudFxyXG4gICAgLy8gIGNoaWxkMiA9IHRoZSBjaGlsZCBvZiB0aGUgT1RIRVIgcGFyZW50XHJcbiAgICBleGNoYW5nZTogZnVuY3Rpb24gKGNoaWxkMSwgY2hpbGQyKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjaGlsZDEgPT09IGNoaWxkMiB8fCBjaGlsZDEucGFyZW50ID09PSBjaGlsZDIucGFyZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBhcmVudENoaWxkcmVuID0gY2hpbGQyLnBhcmVudC5jaGlsZHJlbjtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4MSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQxKTtcclxuICAgICAgICB2YXIgaW5kZXgyID0gcGFyZW50Q2hpbGRyZW4uZ2V0SW5kZXgoY2hpbGQyKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4MSA8IDAgfHwgaW5kZXgyIDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGRyZW4uc3dhcDogU3VwcGxpZWQgb2JqZWN0cyBtdXN0IGJlIGNoaWxkcmVuIG9mIHBhcmVudHMnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVtb3ZlKGNoaWxkMSk7XHJcblxyXG4gICAgICAgIHBhcmVudENoaWxkcmVuLnJlbW92ZShjaGlsZDIpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEF0KGNoaWxkMiwgaW5kZXgxKTtcclxuXHJcbiAgICAgICAgcGFyZW50Q2hpbGRyZW4uYWRkQXQoY2hpbGQxLCBpbmRleDIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQ2hlY2tzIGZvciB0aGUgaXRlbSB3aXRoaW4gdGhpcyBsaXN0LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5BcnJheVNldCNleGlzdHNcclxuICAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIGxpc3QgaW5kZXggZm9yLlxyXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluIHRoZSBsaXN0LCBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICAqL1xyXG4gICAgZXhpc3RzOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxpc3QuaW5kZXhPZihjaGlsZCkgPiAtMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBga2V5YCB0byB0aGUgZ2l2ZW4gdmFsdWUgb24gYWxsIG1lbWJlcnMgb2YgdGhpcyBsaXN0LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5BcnJheVNldCNzZXRBbGxcclxuICAgICogQHBhcmFtIHthbnl9IGtleSAtIFRoZSBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB0byBzZXQuXHJcbiAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvLlxyXG4gICAgKi9cclxuICAgIHNldEFsbDogZnVuY3Rpb24gKGtleSwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXN0W2ldKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RbaV1ba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUGFzc2VzIGFsbCBjaGlsZHJlbiB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgZWFjaFxyXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgICogQHBhcmFtIHsuLi4qfSBbYXJndW1lbnRzXSAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBhZnRlciB0aGUgY2hpbGQuXHJcbiAgICAqL1xyXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhcmdzID0gWyBudWxsIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJnc1swXSA9IHRoaXMubGlzdFtpXTtcclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogTW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBHcm91cCB0byB0aGUgR3JvdXAgZ2l2ZW4uXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI21vdmVBbGxcclxuICAgICogQHBhcmFtIHtQaGFzZXIuR3JvdXB9IGdyb3VwIC0gVGhlIG5ldyBHcm91cCB0byB3aGljaCB0aGUgY2hpbGRyZW4gd2lsbCBiZSBtb3ZlZCB0by5cclxuICAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50PWZhbHNlXSAtIElmIHRydWUgdGhlIGNoaWxkcmVuIHdpbGwgbm90IGRpc3BhdGNoIHRoZSBgb25BZGRlZFRvR3JvdXBgIGV2ZW50IGZvciB0aGUgbmV3IEdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuR3JvdXB9IFRoZSBHcm91cCB0byB3aGljaCBhbGwgdGhlIGNoaWxkcmVuIHdlcmUgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgcmVwYXJlbnQ6IGZ1bmN0aW9uIChuZXdQYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG5ld1BhcmVudCAhPT0gdGhpcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnJlbW92ZSh0aGlzLmxpc3RbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5hZGQoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3UGFyZW50O1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoaWxkcmVuLnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIGFuZCByZXNldHMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5BcnJheVNldCNmaXJzdFxyXG4gICAgKiBAcHJvcGVydHkge2FueX0gZmlyc3RcclxuICAgICovXHJcbiAgICBsZW5ndGg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gYW5kIHJlc2V0cyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydC5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLkFycmF5U2V0I2ZpcnN0XHJcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBmaXJzdFxyXG4gICAgKi9cclxuICAgIGZpcnN0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0WzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0aGUgbGFzdCBpdGVtIGFuZCByZXNldHMgdGhlIGN1cnNvciB0byB0aGUgZW5kLlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuQXJyYXlTZXQjbGFzdFxyXG4gICAgKiBAcHJvcGVydHkge2FueX0gbGFzdFxyXG4gICAgKi9cclxuICAgIGxhc3Q6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5saXN0Lmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFt0aGlzLnBvc2l0aW9uXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIG5leHQgaXRlbSAoYmFzZWQgb24gdGhlIGN1cnNvcikgYW5kIGFkdmFuY2VzIHRoZSBjdXJzb3IuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5BcnJheVNldCNuZXh0XHJcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBuZXh0XHJcbiAgICAqL1xyXG4gICAgbmV4dDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA8IHRoaXMubGlzdC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24rKztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W3RoaXMucG9zaXRpb25dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0aGUgcHJldmlvdXMgaXRlbSAoYmFzZWQgb24gdGhlIGN1cnNvcikgYW5kIHJldHJlYXRzIHRoZSBjdXJzb3IuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5BcnJheVNldCNwcmV2aW91c1xyXG4gICAgKiBAcHJvcGVydHkge2FueX0gcHJldmlvdXNcclxuICAgICovXHJcbiAgICBwcmV2aW91czoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24tLTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W3RoaXMucG9zaXRpb25dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENoaWxkcmVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL0NoaWxkcmVuLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogVGhlIENvbG9yIENvbXBvbmVudCBhbGxvd3MgeW91IHRvIGNvbnRyb2wgdGhlIGFscGhhLCBibGVuZCBtb2RlLCB0aW50IGFuZCBiYWNrZ3JvdW5kIGNvbG9yXHJcbiogb2YgYSBHYW1lIE9iamVjdC5cclxuKlxyXG4qIEBjbGFzc1xyXG4qL1xyXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxue1xyXG4gICAgdGhpcy5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdDtcclxuXHJcbiAgICB0aGlzLnN0YXRlID0gZ2FtZU9iamVjdC5zdGF0ZTtcclxuXHJcbiAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX2FscGhhID0gMTtcclxuICAgIHRoaXMuX3dvcmxkQWxwaGEgPSAxO1xyXG5cclxuICAgIHRoaXMuX2JsZW5kTW9kZSA9IDA7XHJcblxyXG4gICAgdGhpcy5fdGludCA9IHsgdG9wTGVmdDogMHhmZmZmZmYsIHRvcFJpZ2h0OiAweGZmZmZmZiwgYm90dG9tTGVmdDogMHhmZmZmZmYsIGJvdHRvbVJpZ2h0OiAweGZmZmZmZiB9O1xyXG4gICAgdGhpcy5fZ2xUaW50ID0geyB0b3BMZWZ0OiAxNjc3NzIxNSwgdG9wUmlnaHQ6IDE2Nzc3MjE1LCBib3R0b21MZWZ0OiAxNjc3NzIxNSwgYm90dG9tUmlnaHQ6IDE2Nzc3MjE1IH07XHJcbiAgICB0aGlzLl9oYXNUaW50ID0gZmFsc2U7XHJcblxyXG4gICAgLy8gIEJldHdlZW4gMCBhbmQgMjU1XHJcbiAgICB0aGlzLl9yID0gMDtcclxuICAgIHRoaXMuX2cgPSAwO1xyXG4gICAgdGhpcy5fYiA9IDA7XHJcblxyXG4gICAgLy8gIEJldHdlZW4gMCBhbmQgMVxyXG4gICAgdGhpcy5fYSA9IDE7XHJcblxyXG4gICAgLy8gIFN0cmluZyB2ZXJzaW9uIG9mIFJHQkFcclxuICAgIHRoaXMuX3JnYmEgPSAnJztcclxuXHJcbiAgICAvLyAgMzItYml0IHZlcnNpb24gb2YgQVJHQlxyXG4gICAgdGhpcy5fZ2xCZyA9IDA7XHJcblxyXG4gICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IGZhbHNlO1xyXG59O1xyXG5cclxuQ29sb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29sb3I7XHJcblxyXG5Db2xvci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc2V0QmFja2dyb3VuZDogZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyZWQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZ2xCZyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9yID0gcmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9nID0gKGdyZWVuKSA/IGdyZWVuIDogMDtcclxuICAgICAgICAgICAgdGhpcy5fYiA9IChibHVlKSA/IGJsdWUgOiAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hID0gKGFscGhhKSA/IGFscGhhIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhclRpbnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zZXRUaW50KDB4ZmZmZmZmKTtcclxuXHJcbiAgICAgICAgdGhpcy5faGFzVGludCA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUaW50OiBmdW5jdGlvbiAodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0b3BSaWdodCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdG9wUmlnaHQgPSB0b3BMZWZ0O1xyXG4gICAgICAgICAgICBib3R0b21MZWZ0ID0gdG9wTGVmdDtcclxuICAgICAgICAgICAgYm90dG9tUmlnaHQgPSB0b3BMZWZ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50aW50VG9wTGVmdCA9IHRvcExlZnQ7XHJcbiAgICAgICAgdGhpcy50aW50VG9wUmlnaHQgPSB0b3BSaWdodDtcclxuICAgICAgICB0aGlzLnRpbnRCb3R0b21MZWZ0ID0gYm90dG9tTGVmdDtcclxuICAgICAgICB0aGlzLnRpbnRCb3R0b21SaWdodCA9IGJvdHRvbVJpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLl9oYXNUaW50ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYWxsZWQgYnkgdGhlIERpcnR5IE1hbmFnZXJcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5faGFzQmFja2dyb3VuZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JnYmEgPSAncmdiYSgnICsgdGhpcy5fciArICcsJyArIHRoaXMuX2cgKyAnLCcgKyB0aGlzLl9iICsgJywnICsgdGhpcy5fYSArICcpJztcclxuICAgICAgICAgICAgdGhpcy5fZ2xCZyA9IHRoaXMuZ2V0Q29sb3IzMih0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0aGlzLl9hKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBUaW50IG11bHRzP1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q29sb3I6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlID4+IDE2KSArICh2YWx1ZSAmIDB4ZmYwMCkgKyAoKHZhbHVlICYgMHhmZikgPDwgMTYpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDb2xvcjMyOiBmdW5jdGlvbiAociwgZywgYiwgYSlcclxuICAgIHtcclxuICAgICAgICBhICo9IDI1NTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgoYSA8PCAyNCkgfCAoYiA8PCAxNikgfCAoZyA8PCA4KSB8IHIpID4+PiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGludCA9IFtdO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbG9yLnByb3RvdHlwZSwge1xyXG5cclxuICAgIGRpcnR5OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXJ0eTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXJ0eSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3lzLnVwZGF0ZXMuYWRkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRpbnRUb3BMZWZ0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW50LnRvcExlZnQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl90aW50LnRvcExlZnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZ2xUaW50LnRvcExlZnQgPSB0aGlzLmdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdGludFRvcFJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW50LnRvcFJpZ2h0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fdGludC50b3BSaWdodCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9nbFRpbnQudG9wUmlnaHQgPSB0aGlzLmdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdGludEJvdHRvbUxlZnQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQuYm90dG9tTGVmdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbnQuYm90dG9tTGVmdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9nbFRpbnQuYm90dG9tTGVmdCA9IHRoaXMuZ2V0Q29sb3IodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0aW50Qm90dG9tUmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQuYm90dG9tUmlnaHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl90aW50LmJvdHRvbVJpZ2h0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsVGludC5ib3R0b21SaWdodCA9IHRoaXMuZ2V0Q29sb3IodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0aW50OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW50O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRUaW50KHZhbHVlLCB2YWx1ZSwgdmFsdWUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbHBoYToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2FscGhhKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbHBoYSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBibGVuZE1vZGU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JsZW5kTW9kZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYmxlbmRNb2RlICYmIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kTW9kZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB3b3JsZEFscGhhOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdhbWVPYmplY3QucGFyZW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JsZEFscGhhID0gdGhpcy5fYWxwaGEgKiB0aGlzLmdhbWVPYmplY3QucGFyZW50LmNvbG9yLndvcmxkQWxwaGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93b3JsZEFscGhhO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fd29ybGRBbHBoYSA9IHRoaXMuX2FscGhhICogdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYmFja2dyb3VuZEFscGhhOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9hKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmVkOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yID0gdmFsdWUgfCAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdyZWVuOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nID0gdmFsdWUgfCAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJsdWU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2I7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2IgPSB2YWx1ZSB8IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRCb3VuZHMgPSB7XHJcblxyXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbiAob3V0cHV0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTsgfVxyXG5cclxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuXHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLmRpc3BsYXlXaWR0aDtcclxuICAgICAgICB2YXIgaCA9IHRoaXMuZGlzcGxheUhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJvdGF0aW9uO1xyXG5cclxuICAgICAgICB2YXIgd2N0ID0gdyAqIE1hdGguY29zKHIpO1xyXG4gICAgICAgIHZhciBoY3QgPSBoICogTWF0aC5jb3Mocik7XHJcblxyXG4gICAgICAgIHZhciB3c3QgPSB3ICogTWF0aC5zaW4ocik7XHJcbiAgICAgICAgdmFyIGhzdCA9IGggKiBNYXRoLnNpbihyKTtcclxuXHJcbiAgICAgICAgdmFyIHhNaW4gPSB4O1xyXG4gICAgICAgIHZhciB4TWF4ID0geDtcclxuICAgICAgICB2YXIgeU1pbiA9IHk7XHJcbiAgICAgICAgdmFyIHlNYXggPSB5O1xyXG5cclxuICAgICAgICBpZiAociA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAociA8IDEuNTcwNzk2MzI2Nzk0ODk2NilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gMCA8IHRoZXRhIDwgOTBcclxuICAgICAgICAgICAgICAgIHlNYXggPSB5ICsgaGN0ICsgd3N0O1xyXG4gICAgICAgICAgICAgICAgeE1pbiA9IHggLSBoc3Q7XHJcbiAgICAgICAgICAgICAgICB4TWF4ID0geCArIHdjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIDkwIDw9IHRoZXRhIDw9IDE4MFxyXG4gICAgICAgICAgICAgICAgeU1pbiA9IHkgKyBoY3Q7XHJcbiAgICAgICAgICAgICAgICB5TWF4ID0geSArIHdzdDtcclxuICAgICAgICAgICAgICAgIHhNaW4gPSB4IC0gaHN0ICsgd2N0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHIgPiAtMS41NzA3OTYzMjY3OTQ4OTY2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gLTkwIDwgdGhldGEgPD0gMFxyXG4gICAgICAgICAgICB5TWluID0geSArIHdzdDtcclxuICAgICAgICAgICAgeU1heCA9IHkgKyBoY3Q7XHJcbiAgICAgICAgICAgIHhNYXggPSB4ICsgd2N0IC0gaHN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAtMTgwIDw9IHRoZXRhIDw9IC05MFxyXG4gICAgICAgICAgICB5TWluID0geSArIHdzdCArIGhjdDtcclxuICAgICAgICAgICAgeE1pbiA9IHggKyB3Y3Q7XHJcbiAgICAgICAgICAgIHhNYXggPSB4IC0gaHN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3V0cHV0LnggPSB4TWluO1xyXG4gICAgICAgIG91dHB1dC55ID0geU1pbjtcclxuICAgICAgICBvdXRwdXQud2lkdGggPSB4TWF4IC0geE1pbjtcclxuICAgICAgICBvdXRwdXQuaGVpZ2h0ID0geU1heCAtIHlNaW47XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEJvdW5kcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9HZXRCb3VuZHMuanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgT3JpZ2luIENvbXBvbmVudFxyXG4vLyAgVmFsdWVzIGFyZSBnaXZlbiBpbiBwaXhlbHMsIG5vdCBwZXJjZW50XHJcblxyXG52YXIgT3JpZ2luID0ge1xyXG5cclxuICAgIG9yaWdpblg6IDAsXHJcbiAgICBvcmlnaW5ZOiAwLFxyXG5cclxuICAgIHNldE9yaWdpbjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy5vcmlnaW5YID0geDtcclxuICAgICAgICB0aGlzLm9yaWdpblkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0T3JpZ2luVG9DZW50ZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gdGhpcy5mcmFtZS5jZW50ZXJYO1xyXG4gICAgICAgIHRoaXMub3JpZ2luWSA9IHRoaXMuZnJhbWUuY2VudGVyWTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9yaWdpbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9PcmlnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2NhbGVNb2RlcyA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL1NjYWxlTW9kZXMnKTtcclxuXHJcbi8vICBTY2FsZU1vZGUgQ29tcG9uZW50XHJcblxyXG52YXIgU2NhbGVNb2RlID0ge1xyXG5cclxuICAgIF9zY2FsZU1vZGU6IFNjYWxlTW9kZXMuREVGQVVMVCxcclxuXHJcbiAgICBzY2FsZU1vZGU6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlTW9kZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gU2NhbGVNb2Rlcy5MSU5FQVIgfHwgdmFsdWUgPT09IFNjYWxlTW9kZXMuTkVBUkVTVClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2NhbGVNb2RlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NhbGVNb2RlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL1NjYWxlTW9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvU2NhbGVNb2RlLmpzIiwidmFyIFNpemUgPSB7XHJcblxyXG4gICAgd2lkdGg6IDAsXHJcbiAgICBoZWlnaHQ6IDAsXHJcblxyXG4gICAgZGlzcGxheVdpZHRoOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlWCAqIHRoaXMuZnJhbWUucmVhbFdpZHRoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSB2YWx1ZSAvIHRoaXMuZnJhbWUucmVhbFdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BsYXlIZWlnaHQ6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVZICogdGhpcy5mcmFtZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSB2YWx1ZSAvIHRoaXMuZnJhbWUucmVhbEhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaXplVG9GcmFtZTogZnVuY3Rpb24gKGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChmcmFtZSA9PT0gdW5kZWZpbmVkKSB7IGZyYW1lID0gdGhpcy5mcmFtZTsgfVxyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gZnJhbWUucmVhbFdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZnJhbWUucmVhbEhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaXplO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL1NpemUuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgVGV4dHVyZSBDb21wb25lbnRcclxuXHJcbi8vICBiaXRtYXNrIGZsYWcgZm9yIEdhbWVPYmplY3QucmVuZGVyTWFza1xyXG52YXIgX0ZMQUcgPSA4OyAvLyAxMDAwXHJcblxyXG52YXIgVGV4dHVyZSA9IHtcclxuXHJcbiAgICB0ZXh0dXJlOiBudWxsLFxyXG4gICAgZnJhbWU6IG51bGwsXHJcblxyXG4gICAgc2V0VGV4dHVyZTogZnVuY3Rpb24gKGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5zdGF0ZS5zeXMudGV4dHVyZXMuZ2V0KGtleSk7XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLnRleHR1cmUuZ2V0KGZyYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmZyYW1lLmN1dFdpZHRoIHx8ICF0aGlzLmZyYW1lLmN1dEhlaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgJj0gfl9GTEFHO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzIHw9IF9GTEFHO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoJ29yaWdpblgnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIERlZmF1bHQgb3JpZ2luIHRvIHRoZSBjZW50ZXJcclxuICAgICAgICAgICAgICAgIHZhciB3ID0gTWF0aC5mbG9vcih0aGlzLmZyYW1lLnJlYWxXaWR0aCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGggPSBNYXRoLmZsb29yKHRoaXMuZnJhbWUucmVhbEhlaWdodCAvIDIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3JpZ2luKHcsIGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvVGV4dHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgV3JhcEFuZ2xlID0gcmVxdWlyZSgnLi4vbWF0aC9hbmdsZS9XcmFwJyk7XHJcbnZhciBXcmFwQW5nbGVEZWdyZWVzID0gcmVxdWlyZSgnLi4vbWF0aC9hbmdsZS9XcmFwRGVncmVlcycpO1xyXG5cclxuLy8gIGdsb2JhbCBiaXRtYXNrIGZsYWcgZm9yIEdhbWVPYmplY3QucmVuZGVyTWFzayAodXNlZCBieSBTY2FsZSlcclxudmFyIF9GTEFHID0gNDsgLy8gMDEwMFxyXG5cclxuLy8gIFRyYW5zZm9ybSBDb21wb25lbnRcclxuXHJcbnZhciBUcmFuc2Zvcm0gPSB7XHJcblxyXG4gICAgLy8gIFwicHJpdmF0ZVwiIHByb3BlcnRpZXNcclxuICAgIF9zY2FsZVg6IDEsXHJcbiAgICBfc2NhbGVZOiAxLFxyXG4gICAgX3JvdGF0aW9uOiAwLFxyXG5cclxuICAgIHg6IDAsXHJcbiAgICB5OiAwLFxyXG4gICAgejogMCxcclxuXHJcbiAgICBzY2FsZVg6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlWDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlWCA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NjYWxlWCA9PT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyAmPSB+X0ZMQUc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzIHw9IF9GTEFHO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGVZOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZVkgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZVkgPT09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgJj0gfl9GTEFHO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyB8PSBfRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFuZ2xlOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBXcmFwQW5nbGVEZWdyZWVzKHRoaXMuX3JvdGF0aW9uICogTUFUSF9DT05TVC5SQURfVE9fREVHKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICB2YWx1ZSBpcyBpbiBkZWdyZWVzXHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSBXcmFwQW5nbGVEZWdyZWVzKHZhbHVlKSAqIE1BVEhfQ09OU1QuREVHX1RPX1JBRDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0aW9uOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICB2YWx1ZSBpcyBpbiByYWRpYW5zXHJcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uID0gV3JhcEFuZ2xlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSb3RhdGlvbjogZnVuY3Rpb24gKHJhZGlhbnMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHJhZGlhbnMgPT09IHVuZGVmaW5lZCkgeyByYWRpYW5zID0gMDsgfVxyXG5cclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcmFkaWFucztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAxOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnNjYWxlWCA9ICh4ID8geCA6IDAuMCk7XHJcbiAgICAgICAgdGhpcy5zY2FsZVkgPSAoeSA/IHkgOiAwLjApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9UcmFuc2Zvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzL1RyYW5zZm9ybS5qcyIsIlxyXG4vLyAgVmlzaWJsZSBDb21wb25lbnRcclxuXHJcbi8vICBiaXRtYXNrIGZsYWcgZm9yIEdhbWVPYmplY3QucmVuZGVyTWFza1xyXG52YXIgX0ZMQUcgPSAxOyAvLyAwMDAxXHJcblxyXG52YXIgVmlzaWJsZSA9IHtcclxuXHJcbiAgICBfdmlzaWJsZTogdHJ1ZSxcclxuXHJcbiAgICB2aXNpYmxlOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgfD0gX0ZMQUc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzICY9IH5fRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWaXNpYmxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL1Zpc2libGUuanNcbi8vIG1vZHVsZSBpZCA9IDIwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcblxyXG52YXIgQXVkaW8gPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXVkaW9EYXRhIC0gQXJlIEF1ZGlvIHRhZ3MgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGF1ZGlvRGF0YTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2ViQXVkaW8gLSBJcyB0aGUgV2ViQXVkaW8gQVBJIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJBdWRpbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2dnIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgb2dnIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG9nZzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B1cyAtIENhbiB0aGlzIGRldmljZSBwbGF5IG9wdXMgZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgb3B1czogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXAzIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgbXAzIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG1wMzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2F2IC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgd2F2IGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdhdjogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENhbiB0aGlzIGRldmljZSBwbGF5IG00YSBmaWxlcz9cclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtNGEgLSBUcnVlIGlmIHRoaXMgZGV2aWNlIGNhbiBwbGF5IG00YSBmaWxlcy5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtNGE6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlYm0gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSB3ZWJtIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdlYm06IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGRvbGJ5IC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgRUMtMyBEb2xieSBEaWdpdGFsIFBsdXMgZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZG9sYnk6IGZhbHNlXHJcblxyXG59O1xyXG5cclxuZnVuY3Rpb24gaW5pdCAoKVxyXG57XHJcbiAgICBBdWRpby5hdWRpb0RhdGEgPSAhISh3aW5kb3dbJ0F1ZGlvJ10pO1xyXG4gICAgQXVkaW8ud2ViQXVkaW8gPSAhISh3aW5kb3dbJ0F1ZGlvQ29udGV4dCddIHx8IHdpbmRvd1snd2Via2l0QXVkaW9Db250ZXh0J10pO1xyXG5cclxuICAgIHZhciBhdWRpb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSAhIWF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZTtcclxuXHJcbiAgICB0cnlcclxuICAgIHtcclxuICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF1ZGlvLm9nZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwib3B1c1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSB8fCBhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL29wdXM7JykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXVkaW8ub3B1cyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWc7JykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXVkaW8ubXAzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIE1pbWV0eXBlcyBhY2NlcHRlZDpcclxuICAgICAgICAgICAgLy8gIGRldmVsb3Blci5tb3ppbGxhLm9yZy9Fbi9NZWRpYV9mb3JtYXRzX3N1cHBvcnRlZF9ieV90aGVfYXVkaW9fYW5kX3ZpZGVvX2VsZW1lbnRzXHJcbiAgICAgICAgICAgIC8vICBiaXQubHkvaXBob25lb3Njb2RlY3NcclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vd2F2OyBjb2RlY3M9XCIxXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdWRpby53YXYgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby94LW00YTsnKSB8fCBhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdWRpby5tNGEgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF1ZGlvLndlYm0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9tcDQ7Y29kZWNzPVwiZWMtM1wiJykgIT09ICcnKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQnJvd3Nlci5lZGdlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEF1ZGlvLmRvbGJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJyb3dzZXIuc2FmYXJpICYmIEJyb3dzZXIuc2FmYXJpVmVyc2lvbiA+PSA5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoL01hYyBPUyBYIChcXGQrKV8oXFxkKykvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ham9yID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5vciA9IHBhcnNlSW50KFJlZ0V4cC4kMiwgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYWpvciA9PT0gMTAgJiYgbWlub3IgPj0gMTEpIHx8IG1ham9yID4gMTApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1ZGlvLmRvbGJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBOb3RoaW5nIHRvIGRvIGhlcmVcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQXVkaW87XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvQXVkaW8uanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvQXVkaW8uanMiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcblxyXG52YXIgRnVsbHNjcmVlbiA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhdmFpbGFibGUgLSBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgdGhlIEZ1bGwgU2NyZWVuIEFQST9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBhdmFpbGFibGU6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gcmVxdWVzdCAtIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBGdWxsIFNjcmVlbiBBUEkgdGhpcyBob2xkcyB0aGUgY2FsbCB5b3UgbmVlZCB0byB1c2UgdG8gYWN0aXZhdGUgaXQuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgcmVxdWVzdDogJycsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjYW5jZWwgLSBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgRnVsbCBTY3JlZW4gQVBJIHRoaXMgaG9sZHMgdGhlIGNhbGwgeW91IG5lZWQgdG8gdXNlIHRvIGNhbmNlbCBpdC5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjYW5jZWw6ICcnLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGtleWJvYXJkIC0gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGFjY2VzcyB0byB0aGUgS2V5Ym9hcmQgZHVyaW5nIEZ1bGwgU2NyZWVuIG1vZGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAga2V5Ym9hcmQ6IGZhbHNlXHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiogQ2hlY2tzIGZvciBzdXBwb3J0IG9mIHRoZSBGdWxsIFNjcmVlbiBBUEkuXHJcbiovXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgdmFyIGZzID0gW1xyXG4gICAgICAgICdyZXF1ZXN0RnVsbHNjcmVlbicsXHJcbiAgICAgICAgJ3JlcXVlc3RGdWxsU2NyZWVuJyxcclxuICAgICAgICAnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICd3ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ21zUmVxdWVzdEZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICdtc1JlcXVlc3RGdWxsU2NyZWVuJyxcclxuICAgICAgICAnbW96UmVxdWVzdEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICdtb3pSZXF1ZXN0RnVsbHNjcmVlbidcclxuICAgIF07XHJcblxyXG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChlbGVtZW50W2ZzW2ldXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZ1bGxzY3JlZW4uYXZhaWxhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgRnVsbHNjcmVlbi5yZXF1ZXN0ID0gZnNbaV07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2ZzID0gW1xyXG4gICAgICAgICdjYW5jZWxGdWxsU2NyZWVuJyxcclxuICAgICAgICAnZXhpdEZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICd3ZWJraXRDYW5jZWxGdWxsU2NyZWVuJyxcclxuICAgICAgICAnd2Via2l0RXhpdEZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICdtc0NhbmNlbEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICdtc0V4aXRGdWxsc2NyZWVuJyxcclxuICAgICAgICAnbW96Q2FuY2VsRnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ21vekV4aXRGdWxsc2NyZWVuJ1xyXG4gICAgXTtcclxuXHJcbiAgICBpZiAoRnVsbHNjcmVlbi5hdmFpbGFibGUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnRbY2ZzW2ldXSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRnVsbHNjcmVlbi5jYW5jZWwgPSBjZnNbaV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAgS2V5Ym9hcmQgSW5wdXQ/XHJcbiAgICBpZiAod2luZG93WydFbGVtZW50J10gJiYgRWxlbWVudFsnQUxMT1dfS0VZQk9BUkRfSU5QVVQnXSlcclxuICAgIHtcclxuICAgICAgICBGdWxsc2NyZWVuLmtleWJvYXJkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gRnVsbHNjcmVlbjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9GdWxsc2NyZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL0Z1bGxzY3JlZW4uanMiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcblxyXG52YXIgSW5wdXQgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdG91Y2ggLSBJcyB0b3VjaCBhdmFpbGFibGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdG91Y2g6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1zcG9pbnRlciAtIElzIG1zcG9pbnRlciBhdmFpbGFibGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbXNwb2ludGVyOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHs/c3RyaW5nfSB3aGVlbFR5cGUgLSBUaGUgbmV3ZXN0IHR5cGUgb2YgV2hlZWwvU2Nyb2xsIGV2ZW50IHN1cHBvcnRlZDogJ3doZWVsJywgJ21vdXNld2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICovXHJcbiAgICB3aGVlbEV2ZW50OiBudWxsXHJcbiAgICBcclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCAod2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID49IDEpKVxyXG4gICAge1xyXG4gICAgICAgIElucHV0LnRvdWNoID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkIHx8IHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQpXHJcbiAgICB7XHJcbiAgICAgICAgSW5wdXQubXNwb2ludGVyID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIU9TLmNvY29vbkpTKVxyXG4gICAge1xyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWxcclxuICAgICAgICBpZiAoJ29ud2hlZWwnIGluIHdpbmRvdyB8fCAoQnJvd3Nlci5pZSAmJiAnV2hlZWxFdmVudCcgaW4gd2luZG93KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIERPTTMgV2hlZWwgRXZlbnQ6IEZGIDE3KywgSUUgOSssIENocm9tZSAzMSssIFNhZmFyaSA3K1xyXG4gICAgICAgICAgICBJbnB1dC53aGVlbEV2ZW50ID0gJ3doZWVsJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ29ubW91c2V3aGVlbCcgaW4gd2luZG93KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gTm9uLUZGIGxlZ2FjeTogSUUgNi05LCBDaHJvbWUgMS0zMSwgU2FmYXJpIDUtNy5cclxuICAgICAgICAgICAgSW5wdXQud2hlZWxFdmVudCA9ICdtb3VzZXdoZWVsJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoQnJvd3Nlci5maXJlZm94ICYmICdNb3VzZVNjcm9sbEV2ZW50JyBpbiB3aW5kb3cpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBGRiBwcmlvciB0byAxNy4gVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgc2NydWJiZWQuXHJcbiAgICAgICAgICAgIElucHV0LndoZWVsRXZlbnQgPSAnRE9NTW91c2VTY3JvbGwnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gSW5wdXQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvSW5wdXQuanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvSW5wdXQuanMiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcblxyXG52YXIgVmlkZW8gPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2dnVmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBvZ2cgdmlkZW8gZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgb2dnVmlkZW86IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGgyNjRWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IGgyNjQgbXA0IHZpZGVvIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGgyNjRWaWRlbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXA0VmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBoMjY0IG1wNCB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtcDRWaWRlbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2VibVZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgd2VibSB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJtVmlkZW86IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZwOVZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgdnA5IHZpZGVvIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHZwOVZpZGVvOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBobHNWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IGhscyB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBobHNWaWRlbzogZmFsc2VcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIHZhciB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgdmFyIHJlc3VsdCA9ICEhdmlkZW9FbGVtZW50LmNhblBsYXlUeXBlO1xyXG5cclxuICAgIHRyeVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby9vZ2c7IGNvZGVjcz1cInRoZW9yYVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmlkZW8ub2dnVmlkZW8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IFF1aWNrVGltZSwgdGhpcyB2YWx1ZSB3aWxsIGJlIGB1bmRlZmluZWRgLiBnaXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvaXNzdWVzLzU0NlxyXG4gICAgICAgICAgICAgICAgVmlkZW8uaDI2NFZpZGVvID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIFZpZGVvLm1wNFZpZGVvID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5jYW5QbGF5VHlwZSgndmlkZW8vd2VibTsgY29kZWNzPVwidnA4LCB2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZpZGVvLndlYm1WaWRlbyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGUoJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZwOVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmlkZW8udnA5VmlkZW8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCdhcHBsaWNhdGlvbi94LW1wZWdVUkw7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWaWRlby5obHNWaWRlbyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSlcclxuICAgIHtcclxuICAgICAgICAvLyAgTm90aGluZyB0byBkb1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBWaWRlbztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9WaWRlby5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9WaWRlby5qcyIsIi8vICBUaGlzIHNpbmdsZXRvbiBpcyBpbnN0YW50aWF0ZWQgYXMgc29vbiBhcyBQaGFzZXIgbG9hZHMsXHJcbi8vICBiZWZvcmUgYSBQaGFzZXIuR2FtZSBpbnN0YW5jZSBoYXMgZXZlbiBiZWVuIGNyZWF0ZWQuXHJcbi8vICBXaGljaCBtZWFucyBhbGwgaW5zdGFuY2VzIG9mIFBoYXNlciBHYW1lcyBjYW4gc2hhcmUgaXQsXHJcbi8vICB3aXRob3V0IGhhdmluZyB0byByZS1wb2xsIHRoZSBkZXZpY2UgYWxsIG92ZXIgYWdhaW5cclxuXHJcbnZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcclxudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcclxudmFyIEZlYXR1cmVzID0gcmVxdWlyZSgnLi9GZWF0dXJlcycpO1xyXG52YXIgSW5wdXQgPSByZXF1aXJlKCcuL0lucHV0Jyk7XHJcbnZhciBBdWRpbyA9IHJlcXVpcmUoJy4vQXVkaW8nKTtcclxudmFyIFZpZGVvID0gcmVxdWlyZSgnLi9WaWRlbycpO1xyXG52YXIgRnVsbHNjcmVlbiA9IHJlcXVpcmUoJy4vRnVsbHNjcmVlbicpO1xyXG52YXIgQ2FudmFzRmVhdHVyZXMgPSByZXF1aXJlKCcuL0NhbnZhc0ZlYXR1cmVzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBPUzogT1MsXHJcbiAgICBCcm93c2VyOiBCcm93c2VyLFxyXG4gICAgRmVhdHVyZXM6IEZlYXR1cmVzLFxyXG4gICAgSW5wdXQ6IElucHV0LFxyXG4gICAgQXVkaW86IEF1ZGlvLFxyXG4gICAgVmlkZW86IFZpZGVvLFxyXG4gICAgRnVsbHNjcmVlbjogRnVsbHNjcmVlbixcclxuICAgIENhbnZhc0ZlYXR1cmVzOiBDYW52YXNGZWF0dXJlc1xyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL2luZGV4LmpzIiwidmFyIEFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpXHJcbntcclxuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpIHsgdXNlQ2FwdHVyZSA9IGZhbHNlOyB9XHJcblxyXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkRXZlbnRMaXN0ZW5lcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL0FkZEV2ZW50TGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcilcclxue1xyXG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL1JlbW92ZUV2ZW50TGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVtb3ZlRnJvbURPTSA9IGZ1bmN0aW9uIChlbGVtZW50KVxyXG57XHJcbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKVxyXG4gICAge1xyXG4gICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlRnJvbURPTTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL1JlbW92ZUZyb21ET00uanNcbi8vIG1vZHVsZSBpZCA9IDIwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBTZXRzIHRoZSB0b3VjaC1hY3Rpb24gcHJvcGVydHkgb24gdGhlIGNhbnZhcyBzdHlsZS4gQ2FuIGJlIHVzZWQgdG8gZGlzYWJsZSBkZWZhdWx0IGJyb3dzZXIgdG91Y2ggYWN0aW9ucy5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkNhbnZhcy5Ub3VjaEFjdGlvblxyXG4qIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgdG8gc2V0IHRoZSB0b3VjaCBhY3Rpb24gb24uXHJcbiogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV0gLSBUaGUgdG91Y2ggYWN0aW9uIHRvIHNldC4gRGVmYXVsdHMgdG8gJ25vbmUnLlxyXG4qIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBUaGUgc291cmNlIGNhbnZhcy5cclxuKi9cclxudmFyIFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gKGNhbnZhcywgdmFsdWUpXHJcbntcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IHZhbHVlID0gJ25vbmUnOyB9XHJcblxyXG4gICAgY2FudmFzLnN0eWxlWydtc1RvdWNoQWN0aW9uJ10gPSB2YWx1ZTtcclxuICAgIGNhbnZhcy5zdHlsZVsnbXMtdG91Y2gtYWN0aW9uJ10gPSB2YWx1ZTtcclxuICAgIGNhbnZhcy5zdHlsZVsndG91Y2gtYWN0aW9uJ10gPSB2YWx1ZTtcclxuXHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb3VjaEFjdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL1RvdWNoQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU2V0cyB0aGUgdXNlci1zZWxlY3QgcHJvcGVydHkgb24gdGhlIGNhbnZhcyBzdHlsZS4gQ2FuIGJlIHVzZWQgdG8gZGlzYWJsZSBkZWZhdWx0IGJyb3dzZXIgc2VsZWN0aW9uIGFjdGlvbnMuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5DYW52YXMuc2V0VXNlclNlbGVjdFxyXG4qIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgdG8gc2V0IHRoZSB0b3VjaCBhY3Rpb24gb24uXHJcbiogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV0gLSBUaGUgdG91Y2ggYWN0aW9uIHRvIHNldC4gRGVmYXVsdHMgdG8gJ25vbmUnLlxyXG4qIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBUaGUgc291cmNlIGNhbnZhcy5cclxuKi9cclxudmFyIFVzZXJTZWxlY3QgPSBmdW5jdGlvbiAoY2FudmFzLCB2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHsgdmFsdWUgPSAnbm9uZSc7IH1cclxuXHJcbiAgICB2YXIgdmVuZG9ycyA9IFtcclxuICAgICAgICAnLXdlYmtpdC0nLFxyXG4gICAgICAgICcta2h0bWwtJyxcclxuICAgICAgICAnLW1vei0nLFxyXG4gICAgICAgICctbXMtJyxcclxuICAgICAgICAnJ1xyXG4gICAgXTtcclxuXHJcbiAgICB2ZW5kb3JzLmZvckVhY2goZnVuY3Rpb24gKHZlbmRvcilcclxuICAgIHtcclxuICAgICAgICBjYW52YXMuc3R5bGVbdmVuZG9yICsgJ3VzZXItc2VsZWN0J10gPSB2YWx1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNhbnZhcy5zdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSB2YWx1ZTtcclxuICAgIGNhbnZhcy5zdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLCAwLCAwLCAwKSc7XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXNlclNlbGVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL1VzZXJTZWxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi9FdmVudExpc3RlbmVyJyk7XHJcblxyXG52YXIgRXZlbnRCaW5kaW5nID0gZnVuY3Rpb24gKGRpc3BhdGNoZXIsIHR5cGUpXHJcbntcclxuICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfSURMRTtcclxuICAgIHRoaXMuYWN0aXZlID0gW107XHJcbn07XHJcblxyXG5FdmVudEJpbmRpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXZlbnRCaW5kaW5nO1xyXG5cclxuRXZlbnRCaW5kaW5nLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICB0b3RhbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgdG90YWwgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLnN0YXRlICE9PSBDT05TVC5MSVNURU5FUl9SRU1PVklORylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdG90YWwrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjaylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhczogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5nZXQoY2FsbGJhY2spKTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHByaW9yaXR5LCBvbmNlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuZ2V0KGNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgaWYgKCFsaXN0ZW5lcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGUgbGlzdGVuZXIgZG9lc24ndCBleGlzdCwgc28gY3JlYXRlIG9uZVxyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IEV2ZW50TGlzdGVuZXIodGhpcy50eXBlLCBjYWxsYmFjaywgcHJpb3JpdHksIG9uY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgTGlzdGVuZXIgYWxyZWFkeSBleGlzdHMsIGFib3J0XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVGhlIERpc3BhdGNoZXIgaXNuJ3QgZG9pbmcgYW55dGhpbmcsIHNvIHdlIGRvbid0IG5lZWQgYSBwZW5kaW5nIHN0YXRlXHJcbiAgICAgICAgICAgIGxpc3RlbmVyLnN0YXRlID0gQ09OU1QuTElTVEVORVJfQUNUSVZFO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUucHVzaChsaXN0ZW5lcik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zb3J0KHRoaXMuc29ydEhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0RJU1BBVENISU5HKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEFkZCBpdCB0byB0aGUgbGlzdCwgYnV0IGtlZXAgdGhlIHN0YXRlIGFzIHBlbmRpbmcuXHJcbiAgICAgICAgICAgIC8vICBUaGUgY2FsbCB0byAndGlkeScgd2lsbCBzb3J0IGl0IG91dCBhdCB0aGUgZW5kIG9mIHRoZSBkaXNwYXRjaC5cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzb3J0SGFuZGxlcjogZnVuY3Rpb24gKGxpc3RlbmVyQSwgbGlzdGVuZXJCKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChsaXN0ZW5lckIucHJpb3JpdHkgPCBsaXN0ZW5lckEucHJpb3JpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxpc3RlbmVyQi5wcmlvcml0eSA+IGxpc3RlbmVyQS5wcmlvcml0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVGhlIERpc3BhdGNoZXIgaXNuJ3QgZG9pbmcgYW55dGhpbmcsIHNvIHdlIGNhbiByZW1vdmUgcmlnaHQgYXdheVxyXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0SW5kZXgoY2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgaWYgKGkgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0RJU1BBVENISU5HKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRoZSBEaXNwYXRjaGVyIGlzIHdvcmtpbmcsIHNvIHdlIGZsYWcgdGhlIGxpc3RlbmVyIGZvciByZW1vdmFsIGF0IHRoZSBlbmRcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5nZXQoY2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5zdGF0ZSA9IENPTlNULkxJU1RFTkVSX1JFTU9WSU5HO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yOiBGYWlsZWQgdG8gZXhlY3V0ZSBcXCdFdmVudERpc3BhdGNoZXIuZGlzcGF0Y2hcXCcgb24gXFwnJyArIHRoaXMudHlwZSArICdcXCc6IFRoZSBldmVudCBpcyBhbHJlYWR5IGJlaW5nIGRpc3BhdGNoZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGlzIHdhcyBhIHZhbGlkIGRpc3BhdGNoIGNhbGwsIHdlIGp1c3QgaGFkIG5vdGhpbmcgdG8gZG8gLi4uXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5ESVNQQVRDSEVSX0RJU1BBVENISU5HO1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXI7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMuYWN0aXZlW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnN0YXRlICE9PSBDT05TVC5MSVNURU5FUl9BQ1RJVkUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMuZGlzcGF0Y2hlciwgZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gIEhhcyB0aGUgY2FsbGJhY2sgY2hhbmdlZCB0aGUgc3RhdGUgb2YgdGhpcyBiaW5kaW5nP1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFl1cCEgTGV0J3MgYnJlYWsgb3V0XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIFdhcyBpdCBhICdvbmNlJyBsaXN0ZW5lcj9cclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9uY2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnN0YXRlID0gQ09OU1QuTElTVEVORVJfUkVNT1ZJTkc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vICBIYXMgdGhlIGV2ZW50IGJlZW4gaGFsdGVkIGJ5IHRoZSBjYWxsYmFjaz9cclxuICAgICAgICAgICAgaWYgKCFldmVudC5fcHJvcGFnYXRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgQnJlYWsgb3V0LCBhIGxpc3RlbmVyIGhhcyBjYWxsZWQgRXZlbnQuc3RvcFByb3BhZ2F0aW9uXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIERpc3BhdGNoIG92ZXIsIG9yIGFib3J0ZWRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9SRU1PVklORylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsKCk7XHJcblxyXG4gICAgICAgICAgICAvLyAgQWxsIGRvbmUsIHRpZHkgdGhlIGxpc3QgaW4gY2FzZSB0aGVyZSB3ZXJlIGFueSBwZW5kaW5nIGV2ZW50cyBhZGRlZFxyXG4gICAgICAgICAgICB0aGlzLnRpZHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9ERVNUUk9ZRUQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIuZGVsZXRlKHRoaXMudHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBBbGwgZG9uZSwganVzdCBwdXJnZSB0aGUgbGlzdFxyXG4gICAgICAgICAgICB0aGlzLnRpZHkoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5ESVNQQVRDSEVSX0lETEU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUmVtb3ZlcyBhbGwgbGlzdGVuZXJzXHJcbiAgICAvLyAgSWYgdGhpcyBpcyBjdXJyZW50bHkgYmVpbmcgZGlzcGF0Y2hlZCB0aGVuIGRvbid0IHJlbW92ZSAncGVuZGluZycgbGlzdGVuZXJzXHJcbiAgICAvLyAgKGkuZS4gb25lcyB0aGF0IHdlcmUgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaCksIG9ubHkgYWN0aXZlIG9uZXNcclxuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9JRExFKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgIT09IENPTlNULkxJU1RFTkVSX1BFTkRJTkcpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5ESVNQQVRDSEVSX0lETEU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB0aWR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBOb3RoaW5nIHRvIGRvIC4uLlxyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGggPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYWRkZWQgPSAwO1xyXG5cclxuICAgICAgICB2YXIgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgIGRvXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IENPTlNULkxJU1RFTkVSX1JFTU9WSU5HKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IENPTlNULkxJU1RFTkVSX1BFTkRJTkcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlW2ldLnN0YXRlID09PSBDT05TVC5MSVNURU5FUl9BQ1RJVkU7XHJcbiAgICAgICAgICAgICAgICBhZGRlZCsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpID49IDApO1xyXG5cclxuICAgICAgICBpZiAoYWRkZWQgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUuc29ydCh0aGlzLnNvcnRIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJyc7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfREVTVFJPWUVEO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRCaW5kaW5nO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ldmVudHMvRXZlbnRCaW5kaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZXZlbnRzL0V2ZW50QmluZGluZy5qcyIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSlcclxue1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcclxuICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXHJcbiAgICAgICAgb25jZTogb25jZSxcclxuICAgICAgICBzdGF0ZTogQ09OU1QuTElTVEVORVJfUEVORElOR1xyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZXZlbnRzL0V2ZW50TGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ldmVudHMvRXZlbnRMaXN0ZW5lci5qcyIsImZ1bmN0aW9uIGdldFZhbHVlIChub2RlLCBhdHRyaWJ1dGUpXHJcbntcclxuICAgIHJldHVybiBwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpLCAxMCk7XHJcbn1cclxuXHJcbnZhciBQYXJzZVhNTEJpdG1hcEZvbnQgPSBmdW5jdGlvbiAoeG1sLCB4U3BhY2luZywgeVNwYWNpbmcsIGZyYW1lKVxyXG57XHJcbiAgICBpZiAoeFNwYWNpbmcgPT09IHVuZGVmaW5lZCkgeyB4U3BhY2luZyA9IDA7IH1cclxuICAgIGlmICh5U3BhY2luZyA9PT0gdW5kZWZpbmVkKSB7IHlTcGFjaW5nID0gMDsgfVxyXG5cclxuICAgIHZhciBkYXRhID0ge307XHJcbiAgICB2YXIgaW5mbyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpWzBdO1xyXG4gICAgdmFyIGNvbW1vbiA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY29tbW9uJylbMF07XHJcblxyXG4gICAgZGF0YS5mb250ID0gaW5mby5nZXRBdHRyaWJ1dGUoJ2ZhY2UnKTtcclxuICAgIGRhdGEuc2l6ZSA9IGdldFZhbHVlKGluZm8sICdzaXplJyk7XHJcbiAgICBkYXRhLmxpbmVIZWlnaHQgPSBnZXRWYWx1ZShjb21tb24sICdsaW5lSGVpZ2h0JykgKyB5U3BhY2luZztcclxuICAgIGRhdGEuY2hhcnMgPSB7fTtcclxuXHJcbiAgICB2YXIgbGV0dGVycyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2hhcicpO1xyXG5cclxuICAgIHZhciB4ID0gKGZyYW1lKSA/IGZyYW1lLnggOiAwO1xyXG4gICAgdmFyIHkgPSAoZnJhbWUpID8gZnJhbWUueSA6IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXR0ZXJzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBub2RlID0gbGV0dGVyc1tpXTtcclxuXHJcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gZ2V0VmFsdWUobm9kZSwgJ2lkJyk7XHJcbiAgICAgICAgdmFyIGd3ID0gZ2V0VmFsdWUobm9kZSwgJ3dpZHRoJyk7XHJcbiAgICAgICAgdmFyIGdoID0gZ2V0VmFsdWUobm9kZSwgJ2hlaWdodCcpO1xyXG5cclxuICAgICAgICBkYXRhLmNoYXJzW2NoYXJDb2RlXSA9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4OiB4ICsgZ2V0VmFsdWUobm9kZSwgJ3gnKSxcclxuICAgICAgICAgICAgeTogeSArIGdldFZhbHVlKG5vZGUsICd5JyksXHJcbiAgICAgICAgICAgIHdpZHRoOiBndyxcclxuICAgICAgICAgICAgaGVpZ2h0OiBnaCxcclxuICAgICAgICAgICAgY2VudGVyWDogTWF0aC5mbG9vcihndyAvIDIpLFxyXG4gICAgICAgICAgICBjZW50ZXJZOiBNYXRoLmZsb29yKGdoIC8gMiksXHJcbiAgICAgICAgICAgIHhPZmZzZXQ6IGdldFZhbHVlKG5vZGUsICd4b2Zmc2V0JyksXHJcbiAgICAgICAgICAgIHlPZmZzZXQ6IGdldFZhbHVlKG5vZGUsICd5b2Zmc2V0JyksXHJcbiAgICAgICAgICAgIHhBZHZhbmNlOiBnZXRWYWx1ZShub2RlLCAneGFkdmFuY2UnKSArIHhTcGFjaW5nLFxyXG4gICAgICAgICAgICBrZXJuaW5nOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtlcm5pbmdzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdrZXJuaW5nJyk7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGtlcm5pbmdzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBrZXJuID0ga2VybmluZ3NbaV07XHJcblxyXG4gICAgICAgIHZhciBmaXJzdCA9IGdldFZhbHVlKGtlcm4sICdmaXJzdCcpO1xyXG4gICAgICAgIHZhciBzZWNvbmQgPSBnZXRWYWx1ZShrZXJuLCAnc2Vjb25kJyk7XHJcbiAgICAgICAgdmFyIGFtb3VudCA9IGdldFZhbHVlKGtlcm4sICdhbW91bnQnKTtcclxuXHJcbiAgICAgICAgZGF0YS5jaGFyc1tzZWNvbmRdLmtlcm5pbmdbZmlyc3RdID0gYW1vdW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZVhNTEJpdG1hcEZvbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvUGFyc2VYTUxCaXRtYXBGb250LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIER5bmFtaWNCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgdmFyIHRleHQgPSBzcmMudGV4dDtcclxuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncyB8fCB0ZXh0TGVuZ3RoID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHRleHR1cmVGcmFtZSA9IHNyYy5mcmFtZTtcclxuXHJcbiAgICB2YXIgZGlzcGxheUNhbGxiYWNrID0gc3JjLmRpc3BsYXlDYWxsYmFjaztcclxuXHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWTtcclxuXHJcbiAgICB2YXIgY2hhcnMgPSBzcmMuZm9udERhdGEuY2hhcnM7XHJcbiAgICB2YXIgbGluZUhlaWdodCA9IHNyYy5mb250RGF0YS5saW5lSGVpZ2h0O1xyXG5cclxuICAgIHZhciB4QWR2YW5jZSA9IDA7XHJcbiAgICB2YXIgeUFkdmFuY2UgPSAwO1xyXG5cclxuICAgIHZhciBpbmRleENvdW50ID0gMDtcclxuICAgIHZhciBjaGFyQ29kZSA9IDA7XHJcblxyXG4gICAgdmFyIGdseXBoID0gbnVsbDtcclxuICAgIHZhciBnbHlwaFggPSAwO1xyXG4gICAgdmFyIGdseXBoWSA9IDA7XHJcbiAgICB2YXIgZ2x5cGhXID0gMDtcclxuICAgIHZhciBnbHlwaEggPSAwO1xyXG5cclxuICAgIHZhciB4ID0gMDtcclxuICAgIHZhciB5ID0gMDtcclxuXHJcbiAgICB2YXIgbGFzdEdseXBoID0gbnVsbDtcclxuICAgIHZhciBsYXN0Q2hhckNvZGUgPSAwO1xyXG5cclxuICAgIHZhciBjdHggPSByZW5kZXJlci5jdXJyZW50Q29udGV4dDtcclxuICAgIHZhciBpbWFnZSA9IHNyYy5mcmFtZS5zb3VyY2UuaW1hZ2U7XHJcblxyXG4gICAgdmFyIHRleHR1cmVYID0gdGV4dHVyZUZyYW1lLmN1dFg7XHJcbiAgICB2YXIgdGV4dHVyZVkgPSB0ZXh0dXJlRnJhbWUuY3V0WTtcclxuXHJcbiAgICB2YXIgcm90YXRpb24gPSAwO1xyXG4gICAgdmFyIHNjYWxlID0gKHNyYy5mb250U2l6ZSAvIHNyYy5mb250RGF0YS5zaXplKTtcclxuXHJcbiAgICAvLyAgQmxlbmQgTW9kZVxyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgIT09IHNyYy5ibGVuZE1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSA9IHNyYy5ibGVuZE1vZGU7XHJcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHJlbmRlcmVyLmJsZW5kTW9kZXNbc3JjLmJsZW5kTW9kZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFscGhhXHJcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudEFscGhhICE9PSBzcmMuYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudEFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHNyYy5hbHBoYTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgU21vb3RoaW5nXHJcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSAhPT0gc3JjLnNjYWxlTW9kZSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50U2NhbGVNb2RlID0gc3JjLnNjYWxlTW9kZTtcclxuICAgIH1cclxuXHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZShzcmMueCwgc3JjLnkpO1xyXG4gICAgY3R4LnJvdGF0ZShzcmMucm90YXRpb24pO1xyXG4gICAgY3R4LnNjYWxlKHNyYy5zY2FsZVgsIHNyYy5zY2FsZVkpO1xyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0TGVuZ3RoOyArK2luZGV4KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBSZXNldCB0aGUgc2NhbGUgKGluIGNhc2UgdGhlIGNhbGxiYWNrIGNoYW5nZWQgaXQpXHJcbiAgICAgICAgc2NhbGUgPSAoc3JjLmZvbnRTaXplIC8gc3JjLmZvbnREYXRhLnNpemUpO1xyXG4gICAgICAgIHJvdGF0aW9uID0gMDtcclxuXHJcbiAgICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xyXG5cclxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IDEwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeEFkdmFuY2UgPSAwO1xyXG4gICAgICAgICAgICBpbmRleENvdW50ID0gMDtcclxuICAgICAgICAgICAgeUFkdmFuY2UgKz0gbGluZUhlaWdodDtcclxuICAgICAgICAgICAgbGFzdEdseXBoID0gbnVsbDtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbHlwaCA9IGNoYXJzW2NoYXJDb2RlXTtcclxuXHJcbiAgICAgICAgaWYgKCFnbHlwaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGhYID0gdGV4dHVyZVggKyBnbHlwaC54O1xyXG4gICAgICAgIGdseXBoWSA9IHRleHR1cmVZICsgZ2x5cGgueTtcclxuXHJcbiAgICAgICAgZ2x5cGhXID0gZ2x5cGgud2lkdGg7XHJcbiAgICAgICAgZ2x5cGhIID0gZ2x5cGguaGVpZ2h0O1xyXG5cclxuICAgICAgICB4ID0gaW5kZXhDb3VudCArIGdseXBoLnhPZmZzZXQgKyB4QWR2YW5jZTtcclxuICAgICAgICB5ID0gZ2x5cGgueU9mZnNldCArIHlBZHZhbmNlO1xyXG5cclxuICAgICAgICBpZiAobGFzdEdseXBoICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGtlcm5pbmdPZmZzZXQgPSBnbHlwaC5rZXJuaW5nW2xhc3RDaGFyQ29kZV07XHJcbiAgICAgICAgICAgIHggKz0gKGtlcm5pbmdPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBrZXJuaW5nT2Zmc2V0IDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaXNwbGF5Q2FsbGJhY2spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gZGlzcGxheUNhbGxiYWNrKHsgaW5kZXg6IGluZGV4LCBjaGFyQ29kZTogY2hhckNvZGUsIHg6IHgsIHk6IHksIHNjYWxlOiBzY2FsZSwgcm90YXRpb246IDAgfSk7XHJcblxyXG4gICAgICAgICAgICB4ID0gb3V0cHV0Lng7XHJcbiAgICAgICAgICAgIHkgPSBvdXRwdXQueTtcclxuICAgICAgICAgICAgc2NhbGUgPSBvdXRwdXQuc2NhbGU7XHJcbiAgICAgICAgICAgIHJvdGF0aW9uID0gb3V0cHV0LnJvdGF0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCAqPSBzY2FsZTtcclxuICAgICAgICB5ICo9IHNjYWxlO1xyXG5cclxuICAgICAgICB4IC09IGNhbWVyYVNjcm9sbFg7XHJcbiAgICAgICAgeSAtPSBjYW1lcmFTY3JvbGxZO1xyXG5cclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XHJcbiAgICAgICAgY3R4LnJvdGF0ZShyb3RhdGlvbik7XHJcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XHJcblxyXG4gICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDI1NSwwLDAuMiknO1xyXG4gICAgICAgIC8vIGN0eC5maWxsUmVjdCgwLCAwLCBnbHlwaFcsIGdseXBoSCk7XHJcblxyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGdseXBoWCwgZ2x5cGhZLCBnbHlwaFcsIGdseXBoSCwgMCwgMCwgZ2x5cGhXLCBnbHlwaEgpO1xyXG5cclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHhBZHZhbmNlICs9IGdseXBoLnhBZHZhbmNlO1xyXG4gICAgICAgIGluZGV4Q291bnQgKz0gMTtcclxuICAgICAgICBsYXN0R2x5cGggPSBnbHlwaDtcclxuICAgICAgICBsYXN0Q2hhckNvZGUgPSBjaGFyQ29kZTtcclxuICAgIH1cclxuXHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEeW5hbWljQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCaXRtYXBUZXh0ID0gcmVxdWlyZSgnLi9EeW5hbWljQml0bWFwVGV4dCcpO1xyXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL0ZhY3RvcnlDb250YWluZXInKTtcclxuXHJcbnZhciBEeW5hbWljQml0bWFwVGV4dEZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAnZHluYW1pY0JpdG1hcFRleHQnLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIGZvbnQsIHRleHQsIHNpemUsIGFsaWduKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNoaWxkcmVuLmFkZChuZXcgQml0bWFwVGV4dCh0aGlzLnN0YXRlLCB4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbikpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlOiBmdW5jdGlvbiAoeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaXRtYXBUZXh0KHRoaXMuc3RhdGUsIHgsIHksIGZvbnQsIHRleHQsIHNpemUsIGFsaWduKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0RmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dEZhY3RvcnkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vRHluYW1pY0JpdG1hcFRleHRDYW52YXNSZW5kZXJlcicpLFxyXG4gICAgcmVuZGVyV2ViR0w6IHJlcXVpcmUoJy4vRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dFJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dFJlbmRlci5qcyIsInZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xyXG52YXIgdGVtcE1hdHJpeCA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKTtcclxudmFyIHRlbXBNYXRyaXhDaGFyID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG5cclxudmFyIER5bmFtaWNCaXRtYXBUZXh0V2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGlzcGxheUNhbGxiYWNrID0gc3JjLmRpc3BsYXlDYWxsYmFjaztcclxuICAgIHZhciB0ZXh0dXJlRnJhbWUgPSBzcmMuZnJhbWU7XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWTtcclxuICAgIHZhciB0ZXh0ID0gc3JjLnRleHQ7XHJcbiAgICB2YXIgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xyXG4gICAgdmFyIGNoYXJzID0gc3JjLmZvbnREYXRhLmNoYXJzO1xyXG4gICAgdmFyIGxpbmVIZWlnaHQgPSBzcmMuZm9udERhdGEubGluZUhlaWdodDtcclxuICAgIHZhciBibGl0dGVyQmF0Y2ggPSByZW5kZXJlci5ibGl0dGVyQmF0Y2g7XHJcbiAgICB2YXIgYWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IGJsaXR0ZXJCYXRjaC52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgdmFyIHZlcnRleEJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XHJcbiAgICB2YXIgc3JjWCA9IHNyYy54OyBcclxuICAgIHZhciBzcmNZID0gc3JjLnk7XHJcbiAgICB2YXIgdGV4dHVyZURhdGEgPSBzcmMudGV4dHVyZS5zb3VyY2VbdGV4dHVyZUZyYW1lLnNvdXJjZUluZGV4XTtcclxuICAgIHZhciB0ZXh0dXJlWCA9IHRleHR1cmVGcmFtZS5jdXRYO1xyXG4gICAgdmFyIHRleHR1cmVZID0gdGV4dHVyZUZyYW1lLmN1dFk7XHJcbiAgICB2YXIgdGV4dHVyZVdpZHRoID0gdGV4dHVyZURhdGEud2lkdGg7XHJcbiAgICB2YXIgdGV4dHVyZUhlaWdodCA9IHRleHR1cmVEYXRhLmhlaWdodDtcclxuICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZURhdGEuZ2xUZXh0dXJlO1xyXG4gICAgdmFyIHhBZHZhbmNlID0gMDtcclxuICAgIHZhciB5QWR2YW5jZSA9IDA7XHJcbiAgICB2YXIgaW5kZXhDb3VudCA9IDA7XHJcbiAgICB2YXIgY2hhckNvZGUgPSAwO1xyXG4gICAgdmFyIGdseXBoID0gbnVsbDtcclxuICAgIHZhciBnbHlwaFggPSAwO1xyXG4gICAgdmFyIGdseXBoWSA9IDA7XHJcbiAgICB2YXIgZ2x5cGhXID0gMDtcclxuICAgIHZhciBnbHlwaEggPSAwO1xyXG4gICAgdmFyIHggPSAwO1xyXG4gICAgdmFyIHkgPSAwO1xyXG4gICAgdmFyIHh3ID0gMDtcclxuICAgIHZhciB5aCA9IDA7XHJcbiAgICB2YXIgdHggPSAwO1xyXG4gICAgdmFyIHR5ID0gMDtcclxuICAgIHZhciB0eHcgPSAwO1xyXG4gICAgdmFyIHR5aCA9IDA7XHJcbiAgICB2YXIgdW1pbiA9IDA7XHJcbiAgICB2YXIgdW1heCA9IDA7XHJcbiAgICB2YXIgdm1pbiA9IDA7XHJcbiAgICB2YXIgdm1heCA9IDA7XHJcbiAgICB2YXIgbGFzdEdseXBoID0gbnVsbDtcclxuICAgIHZhciBsYXN0Q2hhckNvZGUgPSAwO1xyXG4gICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgIHZhciBjYW1lcmFNYXRyaXggPSBjYW1lcmEubWF0cml4Lm1hdHJpeDtcclxuICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgdmFyIHNjYWxlID0gKHNyYy5mb250U2l6ZSAvIHNyYy5mb250RGF0YS5zaXplKTtcclxuICAgIHZhciB1dGEsIHV0YiwgdXRjLCB1dGQsIHV0ZSwgdXRmO1xyXG4gICAgdmFyIHRlbXBNYXRyaXhDaGFyTWF0cml4ID0gdGVtcE1hdHJpeENoYXIubWF0cml4O1xyXG5cclxuICAgIHRlbXBNYXRyaXguYXBwbHlJVFJTKFxyXG4gICAgICAgIHNyYy54IC0gY2FtZXJhU2Nyb2xsWCwgc3JjLnkgLSBjYW1lcmFTY3JvbGxZLCBcclxuICAgICAgICAtc3JjLnJvdGF0aW9uLCBcclxuICAgICAgICBzcmMuc2NhbGVYLCBzcmMuc2NhbGVZXHJcbiAgICApO1xyXG5cclxuICAgIHNyYSA9IHRlbXBNYXRyaXhNYXRyaXhbMF07XHJcbiAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xyXG4gICAgc3JjID0gdGVtcE1hdHJpeE1hdHJpeFsyXTtcclxuICAgIHNyZCA9IHRlbXBNYXRyaXhNYXRyaXhbM107XHJcbiAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xyXG4gICAgc3JmID0gdGVtcE1hdHJpeE1hdHJpeFs1XTtcclxuXHJcbiAgICBjbWEgPSBjYW1lcmFNYXRyaXhbMF07XHJcbiAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICBjbWMgPSBjYW1lcmFNYXRyaXhbMl07XHJcbiAgICBjbWQgPSBjYW1lcmFNYXRyaXhbM107XHJcbiAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICBjbWYgPSBjYW1lcmFNYXRyaXhbNV07XHJcblxyXG4gICAgbXZhID0gc3JhICogY21hICsgc3JiICogY21jO1xyXG4gICAgbXZiID0gc3JhICogY21iICsgc3JiICogY21kO1xyXG4gICAgbXZjID0gc3JjICogY21hICsgc3JkICogY21jO1xyXG4gICAgbXZkID0gc3JjICogY21iICsgc3JkICogY21kO1xyXG4gICAgbXZlID0gc3JlICogY21hICsgc3JmICogY21jICsgY21lO1xyXG4gICAgbXZmID0gc3JlICogY21iICsgc3JmICogY21kICsgY21mO1xyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0TGVuZ3RoOyArK2luZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IDEwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeEFkdmFuY2UgPSAwO1xyXG4gICAgICAgICAgICBpbmRleENvdW50ID0gMDtcclxuICAgICAgICAgICAgeUFkdmFuY2UgKz0gbGluZUhlaWdodDtcclxuICAgICAgICAgICAgbGFzdEdseXBoID0gbnVsbDtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbHlwaCA9IGNoYXJzW2NoYXJDb2RlXTtcclxuICAgICAgICBpZiAoIWdseXBoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbHlwaFggPSB0ZXh0dXJlWCArIGdseXBoLng7XHJcbiAgICAgICAgZ2x5cGhZID0gdGV4dHVyZVkgKyBnbHlwaC55O1xyXG4gICAgICAgIGdseXBoVyA9IGdseXBoLndpZHRoO1xyXG4gICAgICAgIGdseXBoSCA9IGdseXBoLmhlaWdodDtcclxuICAgICAgICB4ID0gKGluZGV4Q291bnQgKyBnbHlwaC54T2Zmc2V0ICsgeEFkdmFuY2UpICogc2NhbGU7XHJcbiAgICAgICAgeSA9IChnbHlwaC55T2Zmc2V0ICsgeUFkdmFuY2UpICogc2NhbGU7XHJcblxyXG4gICAgICAgIGlmIChsYXN0R2x5cGggIT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIga2VybmluZ09mZnNldCA9IGdseXBoLmtlcm5pbmdbbGFzdENoYXJDb2RlXTtcclxuICAgICAgICAgICAgeCArPSAoa2VybmluZ09mZnNldCAhPT0gdW5kZWZpbmVkKSA/IGtlcm5pbmdPZmZzZXQgOiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRpc3BsYXlDYWxsYmFjaylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBkaXNwbGF5Q2FsbGJhY2soeyBpbmRleDogaW5kZXgsIGNoYXJDb2RlOiBjaGFyQ29kZSwgeDogeCwgeTogeSwgc2NhbGU6IHNjYWxlLCByb3RhdGlvbjogMCB9KTtcclxuXHJcbiAgICAgICAgICAgIHggPSBvdXRwdXQueDtcclxuICAgICAgICAgICAgeSA9IG91dHB1dC55O1xyXG4gICAgICAgICAgICBzY2FsZSA9IG91dHB1dC5zY2FsZTtcclxuICAgICAgICAgICAgcm90YXRpb24gPSBvdXRwdXQucm90YXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0ZW1wTWF0cml4Q2hhci5hcHBseUlUUlMoXHJcbiAgICAgICAgICAgIHgsIHksXHJcbiAgICAgICAgICAgIC1yb3RhdGlvbixcclxuICAgICAgICAgICAgc2NhbGUsIHNjYWxlXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdXRhID0gdGVtcE1hdHJpeENoYXJNYXRyaXhbMF07XHJcbiAgICAgICAgdXRiID0gdGVtcE1hdHJpeENoYXJNYXRyaXhbMV07XHJcbiAgICAgICAgdXRjID0gdGVtcE1hdHJpeENoYXJNYXRyaXhbMl07XHJcbiAgICAgICAgdXRkID0gdGVtcE1hdHJpeENoYXJNYXRyaXhbM107XHJcbiAgICAgICAgdXRlID0gdGVtcE1hdHJpeENoYXJNYXRyaXhbNF07XHJcbiAgICAgICAgdXRmID0gdGVtcE1hdHJpeENoYXJNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIHNyYSA9IHV0YSAqIG12YSArIHV0YiAqIG12YztcclxuICAgICAgICBzcmIgPSB1dGEgKiBtdmIgKyB1dGIgKiBtdmQ7XHJcbiAgICAgICAgc3JjID0gdXRjICogbXZhICsgdXRkICogbXZjO1xyXG4gICAgICAgIHNyZCA9IHV0YyAqIG12YiArIHV0ZCAqIG12ZDtcclxuICAgICAgICBzcmUgPSB1dGUgKiBtdmEgKyB1dGYgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgc3JmID0gdXRlICogbXZiICsgdXRmICogbXZkICsgbXZmO1xyXG5cclxuICAgICAgICB4dyA9IGdseXBoVztcclxuICAgICAgICB5aCA9IGdseXBoSDtcclxuICAgICAgICB0eDAgPSBzcmU7XHJcbiAgICAgICAgdHkwID0gc3JmO1xyXG4gICAgICAgIHR4MSA9IHloICogc3JjICsgc3JlO1xyXG4gICAgICAgIHR5MSA9IHloICogc3JkICsgc3JmO1xyXG4gICAgICAgIHR4MiA9IHh3ICogc3JhICsgeWggKiBzcmMgKyBzcmU7XHJcbiAgICAgICAgdHkyID0geHcgKiBzcmIgKyB5aCAqIHNyZCArIHNyZjtcclxuICAgICAgICB0eDMgPSB4dyAqIHNyYSArIHNyZTtcclxuICAgICAgICB0eTMgPSB4dyAqIHNyYiArIHNyZjtcclxuICAgICAgICB1bWluID0gZ2x5cGhYIC8gdGV4dHVyZVdpZHRoO1xyXG4gICAgICAgIHVtYXggPSAoZ2x5cGhYICsgZ2x5cGhXKSAvIHRleHR1cmVXaWR0aDtcclxuICAgICAgICB2bWluID0gZ2x5cGhZIC8gdGV4dHVyZUhlaWdodDtcclxuICAgICAgICB2bWF4ID0gKGdseXBoWSArIGdseXBoSCkgLyB0ZXh0dXJlSGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoYmxpdHRlckJhdGNoLmVsZW1lbnRDb3VudCA+PSBibGl0dGVyQmF0Y2gubWF4UGFydGljbGVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmxpdHRlckJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXJlci5zZXRCYXRjaChibGl0dGVyQmF0Y2gsIHRleHR1cmUpO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjApO1xyXG4gICAgICAgIGJsaXR0ZXJCYXRjaC5lbGVtZW50Q291bnQgKz0gNjtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWluO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWluO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtYXg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWF4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWluO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgeEFkdmFuY2UgKz0gZ2x5cGgueEFkdmFuY2U7XHJcbiAgICAgICAgaW5kZXhDb3VudCArPSAxO1xyXG4gICAgICAgIGxhc3RHbHlwaCA9IGdseXBoO1xyXG4gICAgICAgIGxhc3RDaGFyQ29kZSA9IGNoYXJDb2RlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEeW5hbWljQml0bWFwVGV4dFdlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dFdlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzIiwidmFyIEJpdG1hcFRleHRDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICB2YXIgdGV4dCA9IHNyYy50ZXh0O1xyXG4gICAgdmFyIHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzIHx8IHRleHRMZW5ndGggPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgdGV4dHVyZUZyYW1lID0gc3JjLmZyYW1lO1xyXG5cclxuICAgIHZhciBjYW1lcmFTY3JvbGxYID0gY2FtZXJhLnNjcm9sbFg7XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWSA9IGNhbWVyYS5zY3JvbGxZO1xyXG5cclxuICAgIHZhciBjaGFycyA9IHNyYy5mb250RGF0YS5jaGFycztcclxuICAgIHZhciBsaW5lSGVpZ2h0ID0gc3JjLmZvbnREYXRhLmxpbmVIZWlnaHQ7XHJcblxyXG4gICAgdmFyIHhBZHZhbmNlID0gMDtcclxuICAgIHZhciB5QWR2YW5jZSA9IDA7XHJcblxyXG4gICAgdmFyIGluZGV4Q291bnQgPSAwO1xyXG4gICAgdmFyIGNoYXJDb2RlID0gMDtcclxuXHJcbiAgICB2YXIgZ2x5cGggPSBudWxsO1xyXG4gICAgdmFyIGdseXBoWCA9IDA7XHJcbiAgICB2YXIgZ2x5cGhZID0gMDtcclxuICAgIHZhciBnbHlwaFcgPSAwO1xyXG4gICAgdmFyIGdseXBoSCA9IDA7XHJcblxyXG4gICAgdmFyIHggPSAwO1xyXG4gICAgdmFyIHkgPSAwO1xyXG5cclxuICAgIHZhciBsYXN0R2x5cGggPSBudWxsO1xyXG4gICAgdmFyIGxhc3RDaGFyQ29kZSA9IDA7XHJcblxyXG4gICAgdmFyIGN0eCA9IHJlbmRlcmVyLmN1cnJlbnRDb250ZXh0O1xyXG4gICAgdmFyIGltYWdlID0gc3JjLmZyYW1lLnNvdXJjZS5pbWFnZTtcclxuXHJcbiAgICB2YXIgdGV4dHVyZVggPSB0ZXh0dXJlRnJhbWUuY3V0WDtcclxuICAgIHZhciB0ZXh0dXJlWSA9IHRleHR1cmVGcmFtZS5jdXRZO1xyXG5cclxuICAgIHZhciByb3RhdGlvbiA9IDA7XHJcbiAgICB2YXIgc2NhbGUgPSAoc3JjLmZvbnRTaXplIC8gc3JjLmZvbnREYXRhLnNpemUpO1xyXG5cclxuICAgIC8vICBCbGVuZCBNb2RlXHJcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSAhPT0gc3JjLmJsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlID0gc3JjLmJsZW5kTW9kZTtcclxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gcmVuZGVyZXIuYmxlbmRNb2Rlc1tzcmMuYmxlbmRNb2RlXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQWxwaGFcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QWxwaGEgIT09IHNyYy5hbHBoYSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50QWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTbW9vdGhpbmdcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50U2NhbGVNb2RlICE9PSBzcmMuc2NhbGVNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgPSBzcmMuc2NhbGVNb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKHNyYy54IC0gY2FtZXJhU2Nyb2xsWCwgc3JjLnkgLSBjYW1lcmFTY3JvbGxZKTtcclxuICAgIGN0eC5yb3RhdGUoc3JjLnJvdGF0aW9uKTtcclxuICAgIGN0eC5zY2FsZShzcmMuc2NhbGVYLCBzcmMuc2NhbGVZKTtcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGV4dExlbmd0aDsgKytpbmRleClcclxuICAgIHtcclxuXHJcbiAgICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xyXG5cclxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IDEwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeEFkdmFuY2UgPSAwO1xyXG4gICAgICAgICAgICBpbmRleENvdW50ID0gMDtcclxuICAgICAgICAgICAgeUFkdmFuY2UgKz0gbGluZUhlaWdodDtcclxuICAgICAgICAgICAgbGFzdEdseXBoID0gbnVsbDtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbHlwaCA9IGNoYXJzW2NoYXJDb2RlXTtcclxuXHJcbiAgICAgICAgaWYgKCFnbHlwaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGhYID0gdGV4dHVyZVggKyBnbHlwaC54O1xyXG4gICAgICAgIGdseXBoWSA9IHRleHR1cmVZICsgZ2x5cGgueTtcclxuXHJcbiAgICAgICAgZ2x5cGhXID0gZ2x5cGgud2lkdGg7XHJcbiAgICAgICAgZ2x5cGhIID0gZ2x5cGguaGVpZ2h0O1xyXG5cclxuICAgICAgICB4ID0gaW5kZXhDb3VudCArIGdseXBoLnhPZmZzZXQgKyB4QWR2YW5jZTtcclxuICAgICAgICB5ID0gZ2x5cGgueU9mZnNldCArIHlBZHZhbmNlO1xyXG5cclxuICAgICAgICBpZiAobGFzdEdseXBoICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGtlcm5pbmdPZmZzZXQgPSBnbHlwaC5rZXJuaW5nW2xhc3RDaGFyQ29kZV07XHJcbiAgICAgICAgICAgIHggKz0gKGtlcm5pbmdPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBrZXJuaW5nT2Zmc2V0IDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggKj0gc2NhbGU7XHJcbiAgICAgICAgeSAqPSBzY2FsZTtcclxuXHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGdseXBoWCwgZ2x5cGhZLCBnbHlwaFcsIGdseXBoSCwgMCwgMCwgZ2x5cGhXLCBnbHlwaEgpO1xyXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgeEFkdmFuY2UgKz0gZ2x5cGgueEFkdmFuY2U7XHJcbiAgICAgICAgaW5kZXhDb3VudCArPSAxO1xyXG4gICAgICAgIGxhc3RHbHlwaCA9IGdseXBoO1xyXG4gICAgICAgIGxhc3RDaGFyQ29kZSA9IGNoYXJDb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpdG1hcFRleHRDYW52YXNSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJpdG1hcFRleHQgPSByZXF1aXJlKCcuL0JpdG1hcFRleHQnKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgQml0bWFwVGV4dEZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAnYml0bWFwVGV4dCcsXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY2hpbGRyZW4uYWRkKG5ldyBCaXRtYXBUZXh0KHRoaXMuc3RhdGUsIHgsIHksIGZvbnQsIHRleHQsIHNpemUsIGFsaWduKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2U6IGZ1bmN0aW9uICh4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpdG1hcFRleHQodGhpcy5zdGF0ZSwgeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihCaXRtYXBUZXh0RmFjdG9yeSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dEZhY3RvcnkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyJyksXHJcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9CaXRtYXBUZXh0V2ViR0xSZW5kZXJlcicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0UmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dFJlbmRlci5qcyIsInZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xyXG52YXIgdGVtcE1hdHJpeCA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKTtcclxuXHJcbnZhciBCaXRtYXBUZXh0V2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGV4dHVyZUZyYW1lID0gc3JjLmZyYW1lO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFggPSBjYW1lcmEuc2Nyb2xsWDtcclxuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFk7XHJcbiAgICB2YXIgdGV4dCA9IHNyYy50ZXh0O1xyXG4gICAgdmFyIHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcclxuICAgIHZhciBjaGFycyA9IHNyYy5mb250RGF0YS5jaGFycztcclxuICAgIHZhciBsaW5lSGVpZ2h0ID0gc3JjLmZvbnREYXRhLmxpbmVIZWlnaHQ7XHJcbiAgICB2YXIgYmxpdHRlckJhdGNoID0gcmVuZGVyZXIuYmxpdHRlckJhdGNoO1xyXG4gICAgdmFyIGFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBibGl0dGVyQmF0Y2gudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgIHZhciB2ZXJ0ZXhCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgdmFyIHNyY1ggPSBzcmMueDsgXHJcbiAgICB2YXIgc3JjWSA9IHNyYy55O1xyXG4gICAgdmFyIHRleHR1cmVEYXRhID0gc3JjLnRleHR1cmUuc291cmNlW3RleHR1cmVGcmFtZS5zb3VyY2VJbmRleF07XHJcbiAgICB2YXIgdGV4dHVyZVggPSB0ZXh0dXJlRnJhbWUuY3V0WDtcclxuICAgIHZhciB0ZXh0dXJlWSA9IHRleHR1cmVGcmFtZS5jdXRZO1xyXG4gICAgdmFyIHRleHR1cmVXaWR0aCA9IHRleHR1cmVEYXRhLndpZHRoO1xyXG4gICAgdmFyIHRleHR1cmVIZWlnaHQgPSB0ZXh0dXJlRGF0YS5oZWlnaHQ7XHJcbiAgICB2YXIgdGV4dHVyZSA9IHRleHR1cmVEYXRhLmdsVGV4dHVyZTtcclxuICAgIHZhciB4QWR2YW5jZSA9IDA7XHJcbiAgICB2YXIgeUFkdmFuY2UgPSAwO1xyXG4gICAgdmFyIGluZGV4Q291bnQgPSAwO1xyXG4gICAgdmFyIGNoYXJDb2RlID0gMDtcclxuICAgIHZhciBnbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgZ2x5cGhYID0gMDtcclxuICAgIHZhciBnbHlwaFkgPSAwO1xyXG4gICAgdmFyIGdseXBoVyA9IDA7XHJcbiAgICB2YXIgZ2x5cGhIID0gMDtcclxuICAgIHZhciB4ID0gMDtcclxuICAgIHZhciB5ID0gMDtcclxuICAgIHZhciB4dyA9IDA7XHJcbiAgICB2YXIgeWggPSAwO1xyXG4gICAgdmFyIHR4ID0gMDtcclxuICAgIHZhciB0eSA9IDA7XHJcbiAgICB2YXIgdHh3ID0gMDtcclxuICAgIHZhciB0eWggPSAwO1xyXG4gICAgdmFyIHVtaW4gPSAwO1xyXG4gICAgdmFyIHVtYXggPSAwO1xyXG4gICAgdmFyIHZtaW4gPSAwO1xyXG4gICAgdmFyIHZtYXggPSAwO1xyXG4gICAgdmFyIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgbGFzdENoYXJDb2RlID0gMDtcclxuICAgIHZhciB0ZW1wTWF0cml4TWF0cml4ID0gdGVtcE1hdHJpeC5tYXRyaXg7XHJcbiAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICB2YXIgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZiwgdHgwLCB0eTAsIHR4MSwgdHkxLCB0eDIsIHR5MiwgdHgzLCB0eTM7XHJcbiAgICB2YXIgc3JhLCBzcmIsIHNyYywgc3JkLCBzcmUsIHNyZiwgY21hLCBjbWIsIGNtYywgY21kLCBjbWUsIGNtZjtcclxuICAgIHZhciBzY2FsZSA9IChzcmMuZm9udFNpemUgLyBzcmMuZm9udERhdGEuc2l6ZSk7XHJcblxyXG4gICAgdGVtcE1hdHJpeC5hcHBseUlUUlMoXHJcbiAgICAgICAgc3JjLnggLSBjYW1lcmFTY3JvbGxYLCBzcmMueSAtIGNhbWVyYVNjcm9sbFksIFxyXG4gICAgICAgIC1zcmMucm90YXRpb24sIFxyXG4gICAgICAgIHNyYy5zY2FsZVgsIHNyYy5zY2FsZVlcclxuICAgICk7XHJcblxyXG4gICAgc3JhID0gdGVtcE1hdHJpeE1hdHJpeFswXTtcclxuICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XHJcbiAgICBzcmMgPSB0ZW1wTWF0cml4TWF0cml4WzJdO1xyXG4gICAgc3JkID0gdGVtcE1hdHJpeE1hdHJpeFszXTtcclxuICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XHJcbiAgICBzcmYgPSB0ZW1wTWF0cml4TWF0cml4WzVdO1xyXG5cclxuICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgIGNtYiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgIGNtYyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgIGNtZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgIGNtZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuXHJcbiAgICBtdmEgPSBzcmEgKiBjbWEgKyBzcmIgKiBjbWM7XHJcbiAgICBtdmIgPSBzcmEgKiBjbWIgKyBzcmIgKiBjbWQ7XHJcbiAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XHJcbiAgICBtdmQgPSBzcmMgKiBjbWIgKyBzcmQgKiBjbWQ7XHJcbiAgICBtdmUgPSBzcmUgKiBjbWEgKyBzcmYgKiBjbWMgKyBjbWU7XHJcbiAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7XHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRleHRMZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xyXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gMTApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4QWR2YW5jZSA9IDA7XHJcbiAgICAgICAgICAgIGluZGV4Q291bnQgPSAwO1xyXG4gICAgICAgICAgICB5QWR2YW5jZSArPSBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgICBsYXN0R2x5cGggPSBudWxsO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdseXBoID0gY2hhcnNbY2hhckNvZGVdO1xyXG4gICAgICAgIGlmICghZ2x5cGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdseXBoWCA9IHRleHR1cmVYICsgZ2x5cGgueDtcclxuICAgICAgICBnbHlwaFkgPSB0ZXh0dXJlWSArIGdseXBoLnk7XHJcbiAgICAgICAgZ2x5cGhXID0gZ2x5cGgud2lkdGg7XHJcbiAgICAgICAgZ2x5cGhIID0gZ2x5cGguaGVpZ2h0O1xyXG4gICAgICAgIHggPSAoaW5kZXhDb3VudCArIGdseXBoLnhPZmZzZXQgKyB4QWR2YW5jZSkgKiBzY2FsZTtcclxuICAgICAgICB5ID0gKGdseXBoLnlPZmZzZXQgKyB5QWR2YW5jZSkgKiBzY2FsZTtcclxuXHJcbiAgICAgICAgaWYgKGxhc3RHbHlwaCAhPT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBrZXJuaW5nT2Zmc2V0ID0gZ2x5cGgua2VybmluZ1tsYXN0Q2hhckNvZGVdO1xyXG4gICAgICAgICAgICB4ICs9IChrZXJuaW5nT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8ga2VybmluZ09mZnNldCA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4dyA9IHggKyBnbHlwaFcgKiBzY2FsZTtcclxuICAgICAgICB5aCA9IHkgKyBnbHlwaEggKiBzY2FsZTtcclxuICAgICAgICB0eDAgPSB4ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTAgPSB4ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDEgPSB4ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkxID0geCAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MiA9IHh3ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkyID0geHcgKiBtdmIgKyB5aCAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDMgPSB4dyAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkzID0geHcgKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG4gICAgICAgIHVtaW4gPSBnbHlwaFggLyB0ZXh0dXJlV2lkdGg7XHJcbiAgICAgICAgdW1heCA9IChnbHlwaFggKyBnbHlwaFcpIC8gdGV4dHVyZVdpZHRoO1xyXG4gICAgICAgIHZtaW4gPSBnbHlwaFkgLyB0ZXh0dXJlSGVpZ2h0O1xyXG4gICAgICAgIHZtYXggPSAoZ2x5cGhZICsgZ2x5cGhIKSAvIHRleHR1cmVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChibGl0dGVyQmF0Y2guZWxlbWVudENvdW50ID49IGJsaXR0ZXJCYXRjaC5tYXhQYXJ0aWNsZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBibGl0dGVyQmF0Y2guZmx1c2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnNldEJhdGNoKGJsaXR0ZXJCYXRjaCwgdGV4dHVyZSk7XHJcbiAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyMCk7XHJcbiAgICAgICAgYmxpdHRlckJhdGNoLmVsZW1lbnRDb3VudCArPSA2O1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWF4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWF4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtYXg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB4QWR2YW5jZSArPSBnbHlwaC54QWR2YW5jZTtcclxuICAgICAgICBpbmRleENvdW50ICs9IDE7XHJcbiAgICAgICAgbGFzdEdseXBoID0gZ2x5cGg7XHJcbiAgICAgICAgbGFzdENoYXJDb2RlID0gY2hhckNvZGU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpdG1hcFRleHRXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0V2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzIiwiXHJcbnZhciBCbGl0dGVyQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxpc3QgPSBzcmMuZ2V0UmVuZGVyTGlzdCgpO1xyXG5cclxuICAgIHJlbmRlcmVyLnNldEJsZW5kTW9kZShzcmMuYmxlbmRNb2RlKTtcclxuXHJcbiAgICB2YXIgY2EgPSByZW5kZXJlci5jdXJyZW50QWxwaGE7XHJcblxyXG4gICAgLy8gIFJlbmRlciBib2JzXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJvYiA9IGxpc3RbaV07XHJcblxyXG4gICAgICAgIGlmIChjYSAhPT0gYm9iLmFscGhhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2EgPSByZW5kZXJlci5zZXRBbHBoYShib2IuYWxwaGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVuZGVyZXIuYmxpdEltYWdlKGJvYi54LCBib2IueSwgYm9iLmZyYW1lLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCbGl0dGVyQ2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlckNhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBCbGl0dGVyID0gcmVxdWlyZSgnLi9CbGl0dGVyJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIEJsaXR0ZXJGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ2JsaXR0ZXInLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUsIHBhcmVudClcclxuICAgIHtcclxuICAgICAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHsgcGFyZW50ID0gdGhpcy5zdGF0ZTsgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmFkZChuZXcgQmxpdHRlcih0aGlzLnN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2U6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmxpdHRlcih0aGlzLnN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoQmxpdHRlckZhY3RvcnkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyRmFjdG9yeS5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9CbGl0dGVyQ2FudmFzUmVuZGVyZXInKSxcclxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL0JsaXR0ZXJXZWJHTFJlbmRlcmVyJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlclJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlclJlbmRlci5qcyIsInZhciBCbGl0dGVyV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGlzdCA9IHNyYy5nZXRSZW5kZXJMaXN0KCk7XHJcbiAgICB2YXIgYmxpdHRlckJhdGNoID0gcmVuZGVyZXIuYmxpdHRlckJhdGNoO1xyXG4gICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgdmFyIGEgPSBjYW1lcmFNYXRyaXhbMF07XHJcbiAgICB2YXIgYiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgIHZhciBjID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgdmFyIGQgPSBjYW1lcmFNYXRyaXhbM107XHJcbiAgICB2YXIgZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgIHZhciBmID0gY2FtZXJhTWF0cml4WzVdO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFggPSBjYW1lcmEuc2Nyb2xsWDtcclxuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFk7XHJcblxyXG4gICAgLy8gIFJlbmRlciBib2JzXHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgYm9iID0gbGlzdFtpXTtcclxuICAgICAgICB2YXIgZnJhbWUgPSBib2IuZnJhbWU7XHJcbiAgICAgICAgdmFyIGFscGhhID0gYm9iLmFscGhhO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gYmxpdHRlckJhdGNoLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciB1dnMgPSBmcmFtZS51dnM7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGZyYW1lLmhlaWdodDtcclxuICAgICAgICB2YXIgeCA9IGJvYi54ICsgZnJhbWUueCAtIGNhbWVyYVNjcm9sbFg7XHJcbiAgICAgICAgdmFyIHkgPSBib2IueSArIGZyYW1lLnkgLSBjYW1lcmFTY3JvbGxZO1xyXG4gICAgICAgIHZhciB4dyA9IHggKyB3aWR0aDtcclxuICAgICAgICB2YXIgeWggPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgIHZhciB0eCA9IHggKiBhICsgeSAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB0eSA9IHggKiBiICsgeSAqIGQgKyBmO1xyXG4gICAgICAgIHZhciB0eHcgPSB4dyAqIGEgKyB5aCAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB0eWggPSB4dyAqIGIgKyB5aCAqIGQgKyBmO1xyXG5cclxuICAgICAgICBpZiAoYmxpdHRlckJhdGNoLmVsZW1lbnRDb3VudCA+PSBibGl0dGVyQmF0Y2gubWF4UGFydGljbGVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmxpdHRlckJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXJlci5zZXRCYXRjaChibGl0dGVyQmF0Y2gsIGZyYW1lLnRleHR1cmUuc291cmNlW2ZyYW1lLnNvdXJjZUluZGV4XS5nbFRleHR1cmUpO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjApO1xyXG4gICAgICAgIGJsaXR0ZXJCYXRjaC5lbGVtZW50Q291bnQgKz0gNjtcclxuICAgICAgICB4ICs9IGZyYW1lLng7XHJcbiAgICAgICAgeSArPSBmcmFtZS55O1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHloO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eHc7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHh3O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCbGl0dGVyV2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCb2IgPSBmdW5jdGlvbiAoYmxpdHRlciwgeCwgeSwgZnJhbWUsIHZpc2libGUpXHJcbntcclxuICAgIHRoaXMucGFyZW50ID0gYmxpdHRlcjtcclxuXHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcclxuICAgIHRoaXMuZGF0YSA9IHt9O1xyXG5cclxuICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgdGhpcy5fYWxwaGEgPSAxO1xyXG59O1xyXG5cclxuQm9iLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvYjtcclxuXHJcbkJvYi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICh4LCB5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZnJhbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJvYi5wcm90b3R5cGUsIHtcclxuXHJcbiAgICB2aXNpYmxlOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGE6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm9iO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JvYi5qc1xuLy8gbW9kdWxlIGlkID0gMjI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ29udGFpbmVyQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFJlbmRlciBjaGlsZHJlblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBzcmMuY2hpbGRyZW4ubGlzdFtpXTtcclxuXHJcbiAgICAgICAgY2hpbGQucmVuZGVyQ2FudmFzKHJlbmRlcmVyLCBjaGlsZCwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5lckNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENvbnRhaW5lciA9IHJlcXVpcmUoJy4vQ29udGFpbmVyJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIENvbnRhaW5lckZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAnY29udGFpbmVyJyxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChwYXJlbnQsIHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7IHBhcmVudCA9IHRoaXMuc3RhdGU7IH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5hZGQobmV3IENvbnRhaW5lcih0aGlzLnN0YXRlLCBwYXJlbnQsIHgsIHkpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKHBhcmVudCwgeCwgeSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbnRhaW5lcih0aGlzLnN0YXRlLCBwYXJlbnQsIHgsIHkpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihDb250YWluZXJGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lckZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDIyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyRmFjdG9yeS5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9Db250YWluZXJDYW52YXNSZW5kZXJlcicpLFxyXG4gICAgcmVuZGVyV2ViR0w6IHJlcXVpcmUoJy4vQ29udGFpbmVyV2ViR0xSZW5kZXJlcicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lclJlbmRlci5qcyIsIlxyXG52YXIgQ29udGFpbmVyV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgUmVuZGVyIGNoaWxkcmVuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyYy5jaGlsZHJlbi5saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IHNyYy5jaGlsZHJlbi5saXN0W2ldO1xyXG5cclxuICAgICAgICBjaGlsZC5yZW5kZXJXZWJHTChyZW5kZXJlciwgY2hpbGQsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluZXJXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcclxudmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcblxyXG52YXIgR3JhcGhpY3NDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWTtcclxuICAgIHZhciBzcmNYID0gc3JjLng7XHJcbiAgICB2YXIgc3JjWSA9IHNyYy55O1xyXG4gICAgdmFyIHNyY1NjYWxlWCA9IHNyYy5zY2FsZVg7XHJcbiAgICB2YXIgc3JjU2NhbGVZID0gc3JjLnNjYWxlWTtcclxuICAgIHZhciBzcmNSb3RhdGlvbiA9IHNyYy5yb3RhdGlvbjtcclxuICAgIHZhciBjb21tYW5kQnVmZmVyID0gc3JjLmNvbW1hbmRCdWZmZXI7XHJcbiAgICB2YXIgY3R4ID0gcmVuZGVyZXIuY3VycmVudENvbnRleHQ7XHJcbiAgICB2YXIgdmFsdWU7XHJcbiAgICB2YXIgbGluZUFscGhhID0gMS4wO1xyXG4gICAgdmFyIGZpbGxBbHBoYSA9IDEuMDtcclxuICAgIHZhciBsaW5lQ29sb3IgPSAwO1xyXG4gICAgdmFyIGZpbGxDb2xvciA9IDA7XHJcbiAgICB2YXIgbGluZVdpZHRoID0gMS4wO1xyXG4gICAgdmFyIHJlZCA9IDA7XHJcbiAgICB2YXIgZ3JlZW4gPSAwO1xyXG4gICAgdmFyIGJsdWUgPSAwO1xyXG5cclxuICAgIC8vICBCbGVuZCBNb2RlXHJcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSAhPT0gc3JjLmJsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlID0gc3JjLmJsZW5kTW9kZTtcclxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gcmVuZGVyZXIuYmxlbmRNb2Rlc1tzcmMuYmxlbmRNb2RlXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQWxwaGFcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QWxwaGEgIT09IHNyYy5hbHBoYSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50QWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTbW9vdGhpbmdcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50U2NhbGVNb2RlICE9PSBzcmMuc2NhbGVNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgPSBzcmMuc2NhbGVNb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKHNyY1ggLSBjYW1lcmFTY3JvbGxYLCBzcmNZIC0gY2FtZXJhU2Nyb2xsWSk7XHJcbiAgICBjdHgucm90YXRlKHNyY1JvdGF0aW9uKTtcclxuICAgIGN0eC5zY2FsZShzcmNTY2FsZVgsIHNyY1NjYWxlWSk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gJyNmZmYnO1xyXG4gICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gY29tbWFuZEJ1ZmZlci5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyArK2luZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjb21tYW5kSUQgPSBjb21tYW5kQnVmZmVyW2luZGV4XTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChjb21tYW5kSUQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkFSQzpcclxuICAgICAgICAgICAgICAgIGN0eC5hcmMoXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgM10sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDRdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyA1XSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgNl1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkxJTkVfU1RZTEU6XHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV07XHJcbiAgICAgICAgICAgICAgICBsaW5lQ29sb3IgPSBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl07XHJcbiAgICAgICAgICAgICAgICBsaW5lQWxwaGEgPSBjb21tYW5kQnVmZmVyW2luZGV4ICsgM107XHJcbiAgICAgICAgICAgICAgICByZWQgPSAoKGxpbmVDb2xvciAmIDB4RkYwMDAwKSA+Pj4gMTYpO1xyXG4gICAgICAgICAgICAgICAgZ3JlZW4gPSAoKGxpbmVDb2xvciAmIDB4RkYwMCkgPj4+IDgpO1xyXG4gICAgICAgICAgICAgICAgYmx1ZSA9IChsaW5lQ29sb3IgJiAweEZGKTtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByZWQgKyAnLCcgKyBncmVlbiArICcsJyArIGJsdWUgKyAnLCcgKyBsaW5lQWxwaGEgKyAnKSc7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1NUWUxFOlxyXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yID0gY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgICAgZmlsbEFscGhhID0gY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdO1xyXG4gICAgICAgICAgICAgICAgcmVkID0gKChmaWxsQ29sb3IgJiAweEZGMDAwMCkgPj4+IDE2KTtcclxuICAgICAgICAgICAgICAgIGdyZWVuID0gKChmaWxsQ29sb3IgJiAweEZGMDApID4+PiA4KTtcclxuICAgICAgICAgICAgICAgIGJsdWUgPSAoZmlsbENvbG9yICYgMHhGRik7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoJyArIHJlZCArICcsJyArIGdyZWVuICsgJywnICsgYmx1ZSArICcsJyArIGZpbGxBbHBoYSArICcpJztcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQkVHSU5fUEFUSDpcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5DTE9TRV9QQVRIOlxyXG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkZJTExfUEFUSDpcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuU1RST0tFX1BBVEg6XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9SRUNUOlxyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDNdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyA0XVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9UUklBTkdMRTpcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjb21tYW5kQnVmZmVyW2luZGV4ICsgM10sIGNvbW1hbmRCdWZmZXJbaW5kZXggKyA0XSk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyA1XSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDZdKTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuU1RST0tFX1RSSUFOR0xFOlxyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXSk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyAzXSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDRdKTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDVdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgNl0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXSk7XHJcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkxJTkVfVE86XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLk1PVkVfVE86XHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUGhhc2VyOiBJbnZhbGlkIEdyYXBoaWNzIENvbW1hbmQgSUQgJyArIGNvbW1hbmRJRCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NDYW52YXNSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzQ2FudmFzUmVuZGVyZXIuanMiLCJ2YXIgR3JhcGhpY3MgPSByZXF1aXJlKCcuL0dyYXBoaWNzJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIEdyYXBoaWNzRmFjdG9yeSA9IHtcclxuXHJcbiAgICBLRVk6ICdncmFwaGljcycsXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoeCwgeSwgZ3JvdXApXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQpIHsgZ3JvdXAgPSB0aGlzLnN0YXRlOyB9XHJcblxyXG4gICAgICAgIHJldHVybiBncm91cC5jaGlsZHJlbi5hZGQobmV3IEdyYXBoaWNzKHRoaXMuc3RhdGUsIHgsIHkpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFwaGljcyh0aGlzLnN0YXRlLCB4LCB5KTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoR3JhcGhpY3NGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NGYWN0b3J5LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgcmVuZGVyQ2FudmFzOiByZXF1aXJlKCcuL0dyYXBoaWNzQ2FudmFzUmVuZGVyZXInKSxcclxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL0dyYXBoaWNzV2ViR0xSZW5kZXJlcicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc1JlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzUmVuZGVyLmpzIiwidmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi9Db21tYW5kcycpO1xyXG52YXIgVHJhbnNmb3JtTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXgnKTtcclxudmFyIHBhdGhBcnJheSA9IFtdO1xyXG52YXIgY29zID0gTWF0aC5jb3M7XHJcbnZhciBzaW4gPSBNYXRoLnNpbjtcclxudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XHJcbnZhciB0ZW1wTWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG5cclxudmFyIFBvaW50ID0gZnVuY3Rpb24gKHgsIHkpXHJcbntcclxuICAgIHRoaXMueCA9IHg7XHJcbiAgICB0aGlzLnkgPSB5O1xyXG59O1xyXG5cclxudmFyIFBhdGggPSBmdW5jdGlvbiAoeCwgeSlcclxue1xyXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcclxuICAgIHRoaXMucG9pbnRzTGVuZ3RoID0gMTtcclxuICAgIHRoaXMucG9pbnRzWzBdID0gbmV3IFBvaW50KHgsIHkpO1xyXG59O1xyXG5cclxudmFyIEdyYXBoaWNzV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2hhcGVCYXRjaCA9IHJlbmRlcmVyLnNoYXBlQmF0Y2g7XHJcbiAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHNoYXBlQmF0Y2gudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgIHZhciB2ZXJ0ZXhCdWZmZXJVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWTtcclxuICAgIGNvbnN0IHNyY1ggPSBzcmMueCAtIGNhbWVyYVNjcm9sbFg7XHJcbiAgICBjb25zdCBzcmNZID0gc3JjLnkgLSBjYW1lcmFTY3JvbGxZO1xyXG4gICAgY29uc3Qgc3JjU2NhbGVYID0gc3JjLnNjYWxlWDtcclxuICAgIGNvbnN0IHNyY1NjYWxlWSA9IHNyYy5zY2FsZVk7XHJcbiAgICBjb25zdCBzcmNSb3RhdGlvbiA9IC1zcmMucm90YXRpb247XHJcbiAgICB2YXIgY29tbWFuZEJ1ZmZlciA9IHNyYy5jb21tYW5kQnVmZmVyO1xyXG4gICAgdmFyIHZhbHVlO1xyXG4gICAgdmFyIGxpbmVBbHBoYSA9IDEuMDtcclxuICAgIHZhciBmaWxsQWxwaGEgPSAxLjA7XHJcbiAgICB2YXIgbGluZUNvbG9yID0gMDtcclxuICAgIHZhciBmaWxsQ29sb3IgPSAwO1xyXG4gICAgdmFyIGxpbmVXaWR0aCA9IDEuMDtcclxuICAgIHZhciBjYW1lcmFNYXRyaXggPSBjYW1lcmEubWF0cml4Lm1hdHJpeDtcclxuICAgIHZhciBsYXN0UGF0aCA9IG51bGw7XHJcbiAgICB2YXIgaXRlcmF0aW9uID0gMDtcclxuICAgIHZhciBpdGVyU3RlcCA9IDAuMDE7XHJcbiAgICB2YXIgdHggPSAwO1xyXG4gICAgdmFyIHR5ID0gMDtcclxuICAgIHZhciB0YSA9IDA7XHJcbiAgICB2YXIgeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZTtcclxuICAgIHZhciB3aWR0aCwgaGVpZ2h0LCB0eHcsIHR5aDtcclxuICAgIHZhciB2ZXJ0ZXhDb3VudCA9IHNoYXBlQmF0Y2gudmVydGV4Q291bnQ7XHJcbiAgICB2YXIgcG9seWdvbiA9IFtdO1xyXG4gICAgdmFyIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTI7XHJcbiAgICB2YXIgdHgwLCB0eTAsIHR4MSwgdHkxLCB0eDIsIHR5MjtcclxuICAgIHZhciB2MCwgdjEsIHYyO1xyXG4gICAgdmFyIHBvbHlnb25JbmRleDtcclxuICAgIHZhciBwYXRoO1xyXG4gICAgdmFyIHBhdGhMZW5ndGg7XHJcbiAgICB2YXIgcG9pbnQ7XHJcbiAgICB2YXIgbWF4VmVydGljZXMgPSBzaGFwZUJhdGNoLm1heFZlcnRpY2VzO1xyXG4gICAgdmFyIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVk7XHJcbiAgICB2YXIgdGVtcE1hdHJpeE1hdHJpeCA9IHRlbXBNYXRyaXgubWF0cml4O1xyXG4gICAgdmFyIHNyYSwgc3JiLCBzcmMsIHNyZCwgc3JlLCBzcmYsIGNtYSwgY21iLCBjbWMsIGNtZCwgY21lLCBjbWY7XHJcbiAgICB2YXIgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZjtcclxuXHJcbiAgICB0ZW1wTWF0cml4LmFwcGx5SVRSUyhzcmNYLCBzcmNZLCBzcmNSb3RhdGlvbiwgc3JjU2NhbGVYLCBzcmNTY2FsZVkpO1xyXG5cclxuICAgIHNyYSA9IHRlbXBNYXRyaXhNYXRyaXhbMF07XHJcbiAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xyXG4gICAgc3JjID0gdGVtcE1hdHJpeE1hdHJpeFsyXTtcclxuICAgIHNyZCA9IHRlbXBNYXRyaXhNYXRyaXhbM107XHJcbiAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xyXG4gICAgc3JmID0gdGVtcE1hdHJpeE1hdHJpeFs1XTtcclxuXHJcbiAgICBjbWEgPSBjYW1lcmFNYXRyaXhbMF07XHJcbiAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICBjbWMgPSBjYW1lcmFNYXRyaXhbMl07XHJcbiAgICBjbWQgPSBjYW1lcmFNYXRyaXhbM107XHJcbiAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICBjbWYgPSBjYW1lcmFNYXRyaXhbNV07XHJcblxyXG4gICAgbXZhID0gc3JhICogY21hICsgc3JiICogY21jO1xyXG4gICAgbXZiID0gc3JhICogY21iICsgc3JiICogY21kO1xyXG4gICAgbXZjID0gc3JjICogY21hICsgc3JkICogY21jO1xyXG4gICAgbXZkID0gc3JjICogY21iICsgc3JkICogY21kO1xyXG4gICAgbXZlID0gc3JlICogY21hICsgc3JmICogY21jICsgY21lO1xyXG4gICAgbXZmID0gc3JlICogY21iICsgc3JmICogY21kICsgY21mO1xyXG5cclxuICAgIHJlbmRlcmVyLnNldEJhdGNoKHNoYXBlQmF0Y2gsIG51bGwpO1xyXG5cclxuICAgIGZvciAodmFyIGNtZEluZGV4ID0gMCwgY21kTGVuZ3RoID0gY29tbWFuZEJ1ZmZlci5sZW5ndGg7IGNtZEluZGV4IDwgY21kTGVuZ3RoOyArK2NtZEluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kQnVmZmVyW2NtZEluZGV4XTtcclxuXHJcbiAgICAgICAgc3dpdGNoKGNtZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQVJDOlxyXG4gICAgICAgICAgICAgICAgeCA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgIHkgPSBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl07XHJcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgM107XHJcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDRdO1xyXG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNV07XHJcbiAgICAgICAgICAgICAgICBhbnRpY2xvY2t3aXNlID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDZdO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0aW9uIDwgMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YSA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpICogaXRlcmF0aW9uICsgc3RhcnRBbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICB0eCA9IHggKyBjb3ModGEpICogcmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHR5ID0geSArIHNpbih0YSkgKiByYWRpdXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRpb24gPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBQYXRoKHR4LCB0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheS5wdXNoKGxhc3RQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBhdGgucG9pbnRzLnB1c2gobmV3IFBvaW50KHR4LCB0eSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0aW9uICs9IGl0ZXJTdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5MSU5FX1NUWUxFOlxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgICAgbGluZUNvbG9yID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdO1xyXG4gICAgICAgICAgICAgICAgbGluZUFscGhhID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDNdO1xyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1NUWUxFOlxyXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgICAgZmlsbEFscGhhID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdO1xyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5CRUdJTl9QQVRIOlxyXG4gICAgICAgICAgICAgICAgcGF0aEFycmF5Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQ0xPU0VfUEFUSDpcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0UGF0aCAhPT0gbnVsbCAmJiBsYXN0UGF0aC5wb2ludHMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RQb2ludCA9IGxhc3RQYXRoLnBvaW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aC5wb2ludHMucHVzaChmaXJzdFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBQYXRoKHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheS5wdXNoKGxhc3RQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1BBVEg6XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwYXRoQXJyYXlJbmRleCA9IDAsIHBhdGhBcnJheUxlbmd0aCA9IHBhdGhBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aEFycmF5SW5kZXggPCBwYXRoQXJyYXlMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgKytwYXRoQXJyYXlJbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZUJhdGNoLmFkZEZpbGxQYXRoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBQcm9wZXJ0aWVzICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogUmVjdGFuZ2xlIHByb3BlcnRpZXMgKi8gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheVtwYXRoQXJyYXlJbmRleF0ucG9pbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxBbHBoYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogVHJhbnNmb3JtICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmZcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLlNUUk9LRV9QQVRIOlxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcGF0aEFycmF5SW5kZXggPSAwLCBwYXRoQXJyYXlMZW5ndGggPSBwYXRoQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheUluZGV4IDwgcGF0aEFycmF5TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICsrcGF0aEFycmF5SW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBwYXRoQXJyYXlbcGF0aEFycmF5SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlQmF0Y2guYWRkU3Ryb2tlUGF0aChcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgUHJvcGVydGllcyAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlY3RhbmdsZSBwcm9wZXJ0aWVzICovIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnBvaW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVBbHBoYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogVHJhbnNmb3JtICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPT09IHRoaXMuX2xhc3RQYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9SRUNUOlxyXG4gICAgICAgICAgICAgICAgc2hhcGVCYXRjaC5hZGRGaWxsUmVjdChcclxuICAgICAgICAgICAgICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBQcm9wZXJ0aWVzICovXHJcbiAgICAgICAgICAgICAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIFJlY3RhbmdsZSBwcm9wZXJ0aWVzICovIFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSAtIGNhbWVyYVNjcm9sbFgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdIC0gY2FtZXJhU2Nyb2xsWSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgM10sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDRdLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICBmaWxsQWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgLyogVHJhbnNmb3JtICovXHJcbiAgICAgICAgICAgICAgICAgICAgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gNDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1RSSUFOR0xFOlxyXG4gICAgICAgICAgICAgICAgc2hhcGVCYXRjaC5hZGRGaWxsVHJpYW5nbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgUHJvcGVydGllcyAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAvKiBUcmlhbmdsZSBwcm9wZXJ0aWVzICovIFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSAtIGNhbWVyYVNjcm9sbFgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdIC0gY2FtZXJhU2Nyb2xsWSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgM10gLSBjYW1lcmFTY3JvbGxYLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA0XSAtIGNhbWVyYVNjcm9sbFksXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDVdIC0gY2FtZXJhU2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNl0gLSBjYW1lcmFTY3JvbGxZLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICBmaWxsQWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgLyogVHJhbnNmb3JtICovXHJcbiAgICAgICAgICAgICAgICAgICAgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TVFJPS0VfVFJJQU5HTEU6XHJcbiAgICAgICAgICAgICAgICBzaGFwZUJhdGNoLmFkZFN0cm9rZVRyaWFuZ2xlKFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IFByb3BlcnRpZXMgKi9cclxuICAgICAgICAgICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgLyogVHJpYW5nbGUgcHJvcGVydGllcyAqLyBcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV0gLSBjYW1lcmFTY3JvbGxYLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXSAtIGNhbWVyYVNjcm9sbFksXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDNdIC0gY2FtZXJhU2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0gLSBjYW1lcmFTY3JvbGxZLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA1XSAtIGNhbWVyYVNjcm9sbFgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDZdIC0gY2FtZXJhU2Nyb2xsWSxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZUNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVBbHBoYSxcclxuICAgICAgICAgICAgICAgICAgICAvKiBUcmFuc2Zvcm0gKi9cclxuICAgICAgICAgICAgICAgICAgICBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjbWRJbmRleCArPSA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTElORV9UTzpcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0UGF0aCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aC5wb2ludHMucHVzaChuZXcgUG9pbnQoY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBQYXRoKGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSwgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkucHVzaChsYXN0UGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbWRJbmRleCArPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLk1PVkVfVE86XHJcbiAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBQYXRoKGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSwgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdKTtcclxuICAgICAgICAgICAgICAgIHBhdGhBcnJheS5wdXNoKGxhc3RQYXRoKTtcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQaGFzZXI6IEludmFsaWQgR3JhcGhpY3MgQ29tbWFuZCBJRCAnICsgY21kKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwYXRoQXJyYXkubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc1dlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc1dlYkdMUmVuZGVyZXIuanMiLCJcclxudmFyIEltYWdlQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayA9PT0gdGhpcy5yZW5kZXJGbGFncylcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5kcmF3SW1hZ2Uoc3JjLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZUNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUNhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBJbWFnZSA9IHJlcXVpcmUoJy4vSW1hZ2UnKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgSW1hZ2VGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ2ltYWdlJyxcclxuXHJcbiAgICAvKipcclxuICAgICogQ3JlYXRlIGEgbmV3IGBJbWFnZWAgb2JqZWN0LlxyXG4gICAgKlxyXG4gICAgKiBBbiBJbWFnZSBpcyBhIGxpZ2h0LXdlaWdodCBvYmplY3QgeW91IGNhbiB1c2UgdG8gZGlzcGxheSBhbnl0aGluZyB0aGF0IGRvZXNuJ3QgbmVlZCBwaHlzaWNzIG9yIGFuaW1hdGlvbi5cclxuICAgICpcclxuICAgICogSXQgY2FuIHN0aWxsIHJvdGF0ZSwgc2NhbGUsIGNyb3AgYW5kIHJlY2VpdmUgaW5wdXQgZXZlbnRzLlxyXG4gICAgKiBUaGlzIG1ha2VzIGl0IHBlcmZlY3QgZm9yIGxvZ29zLCBiYWNrZ3JvdW5kcywgc2ltcGxlIGJ1dHRvbnMgYW5kIG90aGVyIG5vbi1TcHJpdGUgZ3JhcGhpY3MuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdhbWVPYmplY3QuRmFjdG9yeSNpbWFnZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBJbWFnZS4gVGhlIGNvb3JkaW5hdGUgaXMgcmVsYXRpdmUgdG8gYW55IHBhcmVudCBjb250YWluZXIgdGhpcyBJbWFnZSBtYXkgYmUgaW4uXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cclxuICAgICogQHBhcmFtIHtzdHJpbmd8UGhhc2VyLlJlbmRlclRleHR1cmV8UGhhc2VyLkJpdG1hcERhdGF8UGhhc2VyLlZpZGVvfFBJWEkuVGV4dHVyZX0gW2tleV0gLSBUaGUgaW1hZ2UgdXNlZCBhcyBhIHRleHR1cmUgYnkgdGhpcyBkaXNwbGF5IG9iamVjdCBkdXJpbmcgcmVuZGVyaW5nLiBJZiBhIHN0cmluZyBQaGFzZXIgd2lsbCBnZXQgZm9yIGFuIGVudHJ5IGluIHRoZSBJbWFnZSBDYWNoZS4gT3IgaXQgY2FuIGJlIGFuIGluc3RhbmNlIG9mIGEgUmVuZGVyVGV4dHVyZSwgQml0bWFwRGF0YSwgVmlkZW8gb3IgUElYSS5UZXh0dXJlLlxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtmcmFtZV0gLSBJZiBhIFRleHR1cmUgQXRsYXMgb3IgU3ByaXRlIFNoZWV0IGlzIHVzZWQgdGhpcyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIGZyYW1lIHRvIGJlIHVzZWQuIFVzZSBlaXRoZXIgYW4gaW50ZWdlciBmb3IgYSBGcmFtZSBJRCBvciBhIHN0cmluZyBmb3IgYSBmcmFtZSBuYW1lLlxyXG4gICAgKiBAcGFyYW0ge1BoYXNlci5Hcm91cH0gW2dyb3VwXSAtIE9wdGlvbmFsIEdyb3VwIHRvIGFkZCB0aGUgb2JqZWN0IHRvLiBJZiBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFdvcmxkIGdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuSW1hZ2V9IFRoZSBuZXdseSBjcmVhdGVkIEltYWdlIG9iamVjdC5cclxuICAgICovXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lLCBwYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7IHBhcmVudCA9IHRoaXMuc3RhdGU7IH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5hZGQobmV3IEltYWdlKHRoaXMuc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbWFnZSh0aGlzLnN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoSW1hZ2VGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VGYWN0b3J5LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgcmVuZGVyQ2FudmFzOiByZXF1aXJlKCcuL0ltYWdlQ2FudmFzUmVuZGVyZXInKSxcclxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL0ltYWdlV2ViR0xSZW5kZXJlcicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZVJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlUmVuZGVyLmpzIiwidmFyIEltYWdlV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlbmRlcmVyLnNwcml0ZUJhdGNoLmFkZFNwcml0ZShzcmMsIGNhbWVyYSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlV2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBTcHJpdGVDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrID09PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmRyYXdJbWFnZShzcmMsIGNhbWVyYSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgU3ByaXRlID0gcmVxdWlyZSgnLi9TcHJpdGUnKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgU3ByaXRlRmFjdG9yeSA9IHtcclxuXHJcbiAgICBLRVk6ICdzcHJpdGUnLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDcmVhdGUgYSBuZXcgU3ByaXRlIHdpdGggc3BlY2lmaWMgcG9zaXRpb24gYW5kIHNwcml0ZSBzaGVldCBrZXkuXHJcbiAgICAqXHJcbiAgICAqIEF0IGl0cyBtb3N0IGJhc2ljIGEgU3ByaXRlIGNvbnNpc3RzIG9mIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGFuZCBhIHRleHR1cmUgdGhhdCBpcyB1c2VkIHdoZW4gcmVuZGVyZWQuXHJcbiAgICAqIFRoZXkgYWxzbyBjb250YWluIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhbGxvd2luZyBmb3IgcGh5c2ljcyBtb3Rpb24gKHZpYSBTcHJpdGUuYm9keSksIGlucHV0IGhhbmRsaW5nICh2aWEgU3ByaXRlLmlucHV0KSxcclxuICAgICogZXZlbnRzICh2aWEgU3ByaXRlLmV2ZW50cyksIGFuaW1hdGlvbiAodmlhIFNwcml0ZS5hbmltYXRpb25zKSwgY2FtZXJhIGN1bGxpbmcgYW5kIG1vcmUuIFBsZWFzZSBzZWUgdGhlIEV4YW1wbGVzIGZvciB1c2UgY2FzZXMuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdhbWVPYmplY3QuRmFjdG9yeSNzcHJpdGVcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgc3ByaXRlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIHNwcml0ZSBtYXkgYmUgaW4uXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHNwcml0ZS4gVGhlIGNvb3JkaW5hdGUgaXMgcmVsYXRpdmUgdG8gYW55IHBhcmVudCBjb250YWluZXIgdGhpcyBzcHJpdGUgbWF5IGJlIGluLlxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ3xQaGFzZXIuUmVuZGVyVGV4dHVyZXxQaGFzZXIuQml0bWFwRGF0YXxQaGFzZXIuVmlkZW98UElYSS5UZXh0dXJlfSBba2V5XSAtIFRoZSBpbWFnZSB1c2VkIGFzIGEgdGV4dHVyZSBieSB0aGlzIGRpc3BsYXkgb2JqZWN0IGR1cmluZyByZW5kZXJpbmcuIElmIGEgc3RyaW5nIFBoYXNlciB3aWxsIGdldCBmb3IgYW4gZW50cnkgaW4gdGhlIEltYWdlIENhY2hlLiBPciBpdCBjYW4gYmUgYW4gaW5zdGFuY2Ugb2YgYSBSZW5kZXJUZXh0dXJlLCBCaXRtYXBEYXRhLCBWaWRlbyBvciBQSVhJLlRleHR1cmUuXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2ZyYW1lXSAtIElmIGEgVGV4dHVyZSBBdGxhcyBvciBTcHJpdGUgU2hlZXQgaXMgdXNlZCB0aGlzIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgZnJhbWUgdG8gYmUgdXNlZC4gVXNlIGVpdGhlciBhbiBpbnRlZ2VyIGZvciBhIEZyYW1lIElEIG9yIGEgc3RyaW5nIGZvciBhIGZyYW1lIG5hbWUuXHJcbiAgICAqIEBwYXJhbSB7UGhhc2VyLkdyb3VwfSBbZ3JvdXBdIC0gT3B0aW9uYWwgR3JvdXAgdG8gYWRkIHRoZSBvYmplY3QgdG8uIElmIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgV29ybGQgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge1BoYXNlci5TcHJpdGV9IFRoZSBuZXdseSBjcmVhdGVkIFNwcml0ZSBvYmplY3QuXHJcbiAgICAqL1xyXG4gICAgYWRkOiBmdW5jdGlvbiAoeCwgeSwga2V5LCBmcmFtZSwgZ3JvdXApXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQpIHsgZ3JvdXAgPSB0aGlzLnN0YXRlOyB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdJbWFnZUZhY3RvcnkuYWRkJywga2V5LCB4LCB5LCBmcmFtZSwgZ3JvdXApO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbnRvIFN0YXRlJywgdGhpcy5zdGF0ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBncm91cC5jaGlsZHJlbi5hZGQobmV3IFNwcml0ZSh0aGlzLnN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2U6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdJbWFnZUZhY3RvcnkubWFrZScsIGtleSwgeCwgeSwgZnJhbWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZSh0aGlzLnN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoU3ByaXRlRmFjdG9yeSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZUZhY3RvcnkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vU3ByaXRlQ2FudmFzUmVuZGVyZXInKSxcclxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL1Nwcml0ZVdlYkdMUmVuZGVyZXInKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZVJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVSZW5kZXIuanMiLCJ2YXIgU3ByaXRlV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlbmRlcmVyLnNwcml0ZUJhdGNoLmFkZFNwcml0ZShzcmMsIGNhbWVyYSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZVdlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEFyZWEgPSBmdW5jdGlvbiAoY2lyY2xlKVxyXG57XHJcbiAgICByZXR1cm4gKGNpcmNsZS5yYWRpdXMgPiAwKSA/IE1hdGguUEkgKiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cyA6IDA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0FyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDI0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2lyY3VtZmVyZW5jZSA9IGZ1bmN0aW9uIChjaXJjbGUpXHJcbntcclxuICAgIHJldHVybiAyICogKE1hdGguUEkgKiBjaXJjbGUucmFkaXVzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VtZmVyZW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ2lyY3VtZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFJldHVybnMgYSBQb2ludCBvYmplY3QgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgY2lyY3VtZmVyZW5jZSBvZiB0aGUgQ2lyY2xlIGJhc2VkIG9uIHRoZSBnaXZlbiBhbmdsZS5cclxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUuY2lyY3VtZmVyZW5jZVBvaW50XHJcbiogQHBhcmFtIHtQaGFzZXIuQ2lyY2xlfSBhIC0gVGhlIGZpcnN0IENpcmNsZSBvYmplY3QuXHJcbiogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIC0gVGhlIGFuZ2xlIGluIHJhZGlhbnMgKHVubGVzcyBhc0RlZ3JlZXMgaXMgdHJ1ZSkgdG8gcmV0dXJuIHRoZSBwb2ludCBmcm9tLlxyXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fSBbb3V0XSAtIEFuIG9wdGlvbmFsIFBvaW50IG9iamVjdCB0byBwdXQgdGhlIHJlc3VsdCBpbiB0by4gSWYgbm9uZSBzcGVjaWZpZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuUG9pbnR9IFRoZSBQb2ludCBvYmplY3QgaG9sZGluZyB0aGUgcmVzdWx0LlxyXG4qL1xyXG52YXIgQ2lyY3VtZmVyZW5jZVBvaW50ID0gZnVuY3Rpb24gKGNpcmNsZSwgYW5nbGUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgb3V0LnggPSBjaXJjbGUueCArIChjaXJjbGUucmFkaXVzICogTWF0aC5jb3MoYW5nbGUpKTtcclxuICAgIG91dC55ID0gY2lyY2xlLnkgKyAoY2lyY2xlLnJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VtZmVyZW5jZVBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9DaXJjdW1mZXJlbmNlUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDI0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2lyY2xlID0gcmVxdWlyZSgnLi9DaXJjbGUnKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXHJcbntcclxuICAgIHJldHVybiBuZXcgQ2lyY2xlKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLnJhZGl1cyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMjQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vY2lyY2xlL0Nsb25lLmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoY2lyY2xlLCBwb2ludClcclxue1xyXG4gICAgcmV0dXJuIENvbnRhaW5zKGNpcmNsZSwgcG9pbnQueCwgcG9pbnQueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDI0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChjaXJjbGUsIHJlY3QpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgQ29udGFpbnMoY2lyY2xlLCByZWN0LngsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QucmlnaHQsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QueCwgcmVjdC5ib3R0b20pICYmXHJcbiAgICAgICAgQ29udGFpbnMoY2lyY2xlLCByZWN0LnJpZ2h0LCByZWN0LmJvdHRvbSlcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnNSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9jaXJjbGUvQ29udGFpbnNSZWN0LmpzIiwiLyoqXHJcbiogQ29waWVzIHRoZSB4LCB5IGFuZCBkaWFtZXRlciBwcm9wZXJ0aWVzIGZyb20gYW55IGdpdmVuIG9iamVjdCB0byB0aGlzIENpcmNsZS5cclxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cclxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXHJcbiogQHJldHVybiB7Q2lyY2xlfSBUaGlzIENpcmNsZSBvYmplY3QuXHJcbiovXHJcbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLnJhZGl1cyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMjQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAoY2lyY2xlLCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgY2lyY2xlLnggPT09IHRvQ29tcGFyZS54ICYmXHJcbiAgICAgICAgY2lyY2xlLnkgPT09IHRvQ29tcGFyZS55ICYmXHJcbiAgICAgICAgY2lyY2xlLnJhZGl1cyA9PT0gdG9Db21wYXJlLnJhZGl1c1xyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDI1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi4vcmVjdGFuZ2xlL1JlY3RhbmdsZScpO1xyXG5cclxudmFyIEdldEJvdW5kcyA9IGZ1bmN0aW9uIChjaXJjbGUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBSZWN0YW5nbGUoKTsgfVxyXG5cclxuICAgIG91dC54ID0gY2lyY2xlLmxlZnQ7XHJcbiAgICBvdXQueSA9IGNpcmNsZS50b3A7XHJcbiAgICBvdXQud2lkdGggPSBjaXJjbGUuZGlhbWV0ZXI7XHJcbiAgICBvdXQuaGVpZ2h0ID0gY2lyY2xlLmRpYW1ldGVyO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEJvdW5kcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvR2V0Qm91bmRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9jaXJjbGUvR2V0Qm91bmRzLmpzIiwidmFyIE9mZnNldCA9IGZ1bmN0aW9uIChjaXJjbGUsIHgsIHkpXHJcbntcclxuICAgIGNpcmNsZS54ICs9IHg7XHJcbiAgICBjaXJjbGUueSArPSB5O1xyXG5cclxuICAgIHJldHVybiBjaXJjbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvT2Zmc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldFBvaW50ID0gZnVuY3Rpb24gKGNpcmNsZSwgcG9pbnQpXHJcbntcclxuICAgIGNpcmNsZS54ICs9IHBvaW50Lng7XHJcbiAgICBjaXJjbGUueSArPSBwb2ludC55O1xyXG5cclxuICAgIHJldHVybiBjaXJjbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9PZmZzZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG4vKipcclxuKiBSZXR1cm5zIGEgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIHJhbmRvbSBwb2ludCBmcm9tIGFueXdoZXJlIHdpdGhpbiB0aGlzIENpcmNsZS5cclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjcmFuZG9tXHJcbiogQHBhcmFtIHtQaGFzZXIuUG9pbnR8b2JqZWN0fSBbb3V0XSAtIEEgUGhhc2VyLlBvaW50LCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzLCB0aGF0IHRoZSB2YWx1ZXMgd2lsbCBiZSBzZXQgaW4uXHJcbiogICAgIElmIG5vIG9iamVjdCBpcyBwcm92aWRlZCBhIG5ldyBQaGFzZXIuUG9pbnQgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC4gSW4gaGlnaCBwZXJmb3JtYW5jZSBhcmVhcyBhdm9pZCB0aGlzIGJ5IHJlLXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuUG9pbnR9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSByYW5kb20gcG9pbnQgaW4gaXRzIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuXHJcbiovXHJcbnZhciBSYW5kb20gPSBmdW5jdGlvbiAoY2lyY2xlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgdmFyIHUgPSBNYXRoLnJhbmRvbSgpICsgTWF0aC5yYW5kb20oKTtcclxuICAgIHZhciByID0gKHUgPiAxKSA/IDIgLSB1IDogdTtcclxuICAgIHZhciB4ID0gciAqIE1hdGguY29zKHQpO1xyXG4gICAgdmFyIHkgPSByICogTWF0aC5zaW4odCk7XHJcblxyXG4gICAgb3V0LnggPSBjaXJjbGUueCArICh4ICogY2lyY2xlLnJhZGl1cyk7XHJcbiAgICBvdXQueSA9IGNpcmNsZS55ICsgKHkgKiBjaXJjbGUucmFkaXVzKTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vY2lyY2xlL1JhbmRvbS5qcyIsIi8vICBQaGFzZXIuR2VvbS5DaXJjbGVcclxuXHJcbnZhciBDaXJjbGUgPSByZXF1aXJlKCcuL0NpcmNsZScpO1xyXG5cclxuQ2lyY2xlLkFyZWEgPSByZXF1aXJlKCcuL0FyZWEnKTtcclxuQ2lyY2xlLkNpcmN1bWZlcmVuY2UgPSByZXF1aXJlKCcuL0NpcmN1bWZlcmVuY2UnKTtcclxuQ2lyY2xlLkNpcmN1bWZlcmVuY2VQb2ludCA9IHJlcXVpcmUoJy4vQ2lyY3VtZmVyZW5jZVBvaW50Jyk7XHJcbkNpcmNsZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuQ2lyY2xlLkNvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5DaXJjbGUuQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xyXG5DaXJjbGUuQ29udGFpbnNSZWN0ID0gcmVxdWlyZSgnLi9Db250YWluc1JlY3QnKTtcclxuQ2lyY2xlLkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xyXG5DaXJjbGUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcclxuQ2lyY2xlLkdldEJvdW5kcyA9IHJlcXVpcmUoJy4vR2V0Qm91bmRzJyk7XHJcbkNpcmNsZS5PZmZzZXQgPSByZXF1aXJlKCcuL09mZnNldCcpO1xyXG5DaXJjbGUuT2Zmc2V0UG9pbnQgPSByZXF1aXJlKCcuL09mZnNldFBvaW50Jyk7XHJcbkNpcmNsZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9jaXJjbGUvaW5kZXguanMiLCJ2YXIgQXJlYSA9IGZ1bmN0aW9uIChlbGxpcHNlKVxyXG57XHJcbiAgICBpZiAoZWxsaXBzZS5pc0VtcHR5KCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIHVuaXRzIHNxdWFyZWRcclxuICAgIHJldHVybiAoZWxsaXBzZS5nZXRNYWpvclJhZGl1cygpICogZWxsaXBzZS5nZXRNaW5vclJhZGl1cygpICogTWF0aC5QSSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9BcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVsbGlwc2UgPSByZXF1aXJlKCcuL0VsbGlwc2UnKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXHJcbntcclxuICAgIHJldHVybiBuZXcgRWxsaXBzZShzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDI1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvQ2xvbmUuanMiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgQ29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChlbGxpcHNlLCBwb2ludClcclxue1xyXG4gICAgcmV0dXJuIENvbnRhaW5zKGVsbGlwc2UsIHBvaW50LngsIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ29udGFpbnNQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMjU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9Db250YWluc1BvaW50LmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChlbGxpcHNlLCByZWN0KVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QueCwgcmVjdC55KSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QucmlnaHQsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhlbGxpcHNlLCByZWN0LngsIHJlY3QuYm90dG9tKSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNSZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ29udGFpbnNSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUmVjdC5qcyIsIi8qKlxyXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0VsbGlwc2V9IFRoaXMgQ2lyY2xlIG9iamVjdC5cclxuKi9cclxudmFyIENvcHlGcm9tID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdClcclxue1xyXG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0NvcHlGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFscyA9IGZ1bmN0aW9uIChlbGxpcHNlLCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgZWxsaXBzZS54ID09PSB0b0NvbXBhcmUueCAmJlxyXG4gICAgICAgIGVsbGlwc2UueSA9PT0gdG9Db21wYXJlLnkgJiZcclxuICAgICAgICBlbGxpcHNlLndpZHRoID09PSB0b0NvbXBhcmUud2lkdGggJiZcclxuICAgICAgICBlbGxpcHNlLmhlaWdodCA9PT0gdG9Db21wYXJlLmhlaWdodFxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4uL3JlY3RhbmdsZS9SZWN0YW5nbGUnKTtcclxuXHJcbnZhciBHZXRCb3VuZHMgPSBmdW5jdGlvbiAoZWxsaXBzZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFJlY3RhbmdsZSgpOyB9XHJcblxyXG4gICAgb3V0LnggPSBlbGxpcHNlLnggLSBlbGxpcHNlLndpZHRoO1xyXG4gICAgb3V0LnkgPSBlbGxpcHNlLnkgLSBlbGxpcHNlLmhlaWdodDtcclxuICAgIG91dC53aWR0aCA9IGVsbGlwc2Uud2lkdGg7XHJcbiAgICBvdXQuaGVpZ2h0ID0gZWxsaXBzZS5oZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qm91bmRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvR2V0Qm91bmRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9lbGxpcHNlL0dldEJvdW5kcy5qcyIsInZhciBPZmZzZXQgPSBmdW5jdGlvbiAoZWxsaXBzZSwgeCwgeSlcclxue1xyXG4gICAgZWxsaXBzZS54ICs9IHg7XHJcbiAgICBlbGxpcHNlLnkgKz0geTtcclxuXHJcbiAgICByZXR1cm4gZWxsaXBzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvT2Zmc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldFBvaW50ID0gZnVuY3Rpb24gKGVsbGlwc2UsIHBvaW50KVxyXG57XHJcbiAgICBlbGxpcHNlLnggKz0gcG9pbnQueDtcclxuICAgIGVsbGlwc2UueSArPSBwb2ludC55O1xyXG5cclxuICAgIHJldHVybiBlbGxpcHNlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL09mZnNldFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbnZhciBSYW5kb20gPSBmdW5jdGlvbiAoZWxsaXBzZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgcCA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcclxuICAgIHZhciBzID0gTWF0aC5zcXJ0KE1hdGgucmFuZG9tKCkpO1xyXG5cclxuICAgIG91dC54ID0gZWxsaXBzZS54ICsgKChzICogTWF0aC5jb3MocCkpICogZWxsaXBzZS53aWR0aCAvIDIpO1xyXG4gICAgb3V0LnkgPSBlbGxpcHNlLnkgKyAoKHMgKiBNYXRoLnNpbihwKSkgKiBlbGxpcHNlLmhlaWdodCAvIDIpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMjY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9SYW5kb20uanMiLCIvLyAgUGhhc2VyLkdlb20uRWxsaXBzZVxyXG5cclxudmFyIEVsbGlwc2UgPSByZXF1aXJlKCcuL0VsbGlwc2UnKTtcclxuXHJcbkVsbGlwc2UuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xyXG5FbGxpcHNlLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5FbGxpcHNlLkNvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5FbGxpcHNlLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcclxuRWxsaXBzZS5Db250YWluc1JlY3QgPSByZXF1aXJlKCcuL0NvbnRhaW5zUmVjdCcpO1xyXG5FbGxpcHNlLkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xyXG5FbGxpcHNlLkVxdWFscyA9IHJlcXVpcmUoJy4vRXF1YWxzJyk7XHJcbkVsbGlwc2UuR2V0Qm91bmRzID0gcmVxdWlyZSgnLi9HZXRCb3VuZHMnKTtcclxuRWxsaXBzZS5PZmZzZXQgPSByZXF1aXJlKCcuL09mZnNldCcpO1xyXG5FbGxpcHNlLk9mZnNldFBvaW50ID0gcmVxdWlyZSgnLi9PZmZzZXRQb2ludCcpO1xyXG5FbGxpcHNlLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVsbGlwc2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9pbmRleC5qcyIsInZhciBHZXRBbmdsZSA9IHJlcXVpcmUoJy4vR2V0QW5nbGUnKTtcclxudmFyIEZpbmRUID0gcmVxdWlyZSgnLi9GaW5kVCcpO1xyXG5cclxuLyoqXHJcbiogQ2FsY3VsYXRlIGFuZCByZXR1cm4gdGhlIGFuZ2xlLCBpbiByYWRpYW5zLCBvZiB0aGUgY3VydmVzIHRhbmdlbnQgYXQgdGhlIGdpdmVuIHBpeGVsIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZXMgbGVuZ3RoLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRBbmdsZVdpdGhEaXN0YW5jZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbZGlzdGFuY2U9MF0gLSBUaGUgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlIHRvIGdldCB0aGUgYW5nbGUgZnJvbSwgaW4gcGl4ZWxzLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGF0IHRoZSBzcGVjaWZpZWQgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlLiBUaGUgdmFsdWUgaXMgaW4gcmFkaWFucy5cclxuKi9cclxudmFyIEdldEFuZ2xlV2l0aERpc3RhbmNlID0gZnVuY3Rpb24gKGN1cnZlLCBkaXN0YW5jZSlcclxue1xyXG4gICAgaWYgKGRpc3RhbmNlID09PSB1bmRlZmluZWQpIHsgZGlzdGFuY2UgPSAwOyB9XHJcblxyXG4gICAgaWYgKGRpc3RhbmNlIDw9IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5fdjF5LCB0aGlzLl92MXgpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBHZXRBbmdsZShjdXJ2ZSwgRmluZFQoY3VydmUsIGRpc3RhbmNlKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEFuZ2xlV2l0aERpc3RhbmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0QW5nbGVXaXRoRGlzdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDI2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2hlcm1pdGUvR2V0QW5nbGVXaXRoRGlzdGFuY2UuanMiLCIvKipcclxuKiBHZXQgdGhlIGFuZ2xlIG9mIHRoZSBjdXJ2ZXMgZW50cnkgcG9pbnQuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldEVudHJ5VGFuZ2VudFxyXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fE9iamVjdH0gcG9pbnQgLSBUaGUgUGhhc2VyLlBvaW50IG9iamVjdCwgb3IgYW4gT2JqZWN0IHdpdGggcHVibGljIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMsIGluIHdoaWNoIHRoZSB0YW5nZW50IHZlY3RvciB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQuXHJcbiogQHJldHVybiB7UGhhc2VyLlBvaW50fSBBIFBvaW50IG9iamVjdCBjb250YWluaW5nIHRoZSB0YW5nZW50IHZlY3RvciBvZiB0aGlzIEhlcm1pdGUgY3VydmUuXHJcbiovXHJcbnZhciBHZXRFbnRyeVRhbmdlbnQgPSBmdW5jdGlvbiAoY3VydmUsIHBvaW50KVxyXG57XHJcbiAgICBwb2ludC54ID0gY3VydmUuX3YxeDtcclxuICAgIHBvaW50LnkgPSBjdXJ2ZS5fdjF5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0RW50cnlUYW5nZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0RW50cnlUYW5nZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxudmFyIEdldFBvaW50ID0gcmVxdWlyZSgnLi9HZXRQb2ludCcpO1xyXG52YXIgRmluZFQgPSByZXF1aXJlKCcuL0ZpbmRUJyk7XHJcblxyXG4vKipcclxuKiBHZXQgYSBwb2ludCBvbiB0aGUgY3VydmUgdXNpbmcgdGhlIGRpc3RhbmNlLCBpbiBwaXhlbHMsIGFsb25nIHRoZSBjdXJ2ZS5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZ2V0UG9pbnRXaXRoRGlzdGFuY2VcclxuKiBAcGFyYW0ge2ludGVnZXJ9IFtkaXN0YW5jZT0wXSAtIFRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgdG8gZ2V0IHRoZSBwb2ludCBmcm9tLCBnaXZlbiBpbiBwaXhlbHMuXHJcbiogQHBhcmFtIHtQaGFzZXIuUG9pbnR8T2JqZWN0fSBbcG9pbnRdIC0gQW4gb3B0aW9uYWwgUGhhc2VyLlBvaW50LCBvciBPYmplY3QgY29udGFpbmluZyBwdWJsaWMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy4gSWYgZ2l2ZW4gdGhlIHJlc3VsdGluZyB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIE9iamVjdHMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy4gSWYgb21pdHRlZCBhIG5ldyBQaGFzZXIuUG9pbnQgb2JqZWN0IGlzIGNyZWF0ZWQuXHJcbiogQHJldHVybiB7UGhhc2VyLlBvaW50fSBUaGUgcG9pbnQgb24gdGhlIGxpbmUgYXQgdGhlIHNwZWNpZmllZCAnZGlzdGFuY2UnIGFsb25nIHRoZSBjdXJ2ZS5cclxuKi9cclxudmFyIEdldFBvaW50V2l0aERpc3RhbmNlID0gZnVuY3Rpb24gKGN1cnZlLCBkaXN0YW5jZSwgb3V0KVxyXG57XHJcbiAgICBpZiAoZGlzdGFuY2UgPT09IHVuZGVmaW5lZCkgeyBkaXN0YW5jZSA9IDA7IH1cclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIGlmIChkaXN0YW5jZSA8PSAwKVxyXG4gICAge1xyXG4gICAgICAgIG91dC54ID0gdGhpcy5fcDF4O1xyXG4gICAgICAgIG91dC55ID0gdGhpcy5fcDF5O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIEdldFBvaW50KGN1cnZlLCBGaW5kVChjdXJ2ZSwgZGlzdGFuY2UpLCBvdXQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRQb2ludFdpdGhEaXN0YW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9oZXJtaXRlL0dldFBvaW50V2l0aERpc3RhbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL0dldFBvaW50V2l0aERpc3RhbmNlLmpzIiwiLyoqXHJcbiogR2V0IHRoZSBYIGNvbXBvbmVudCBvZiBhIHBvaW50IG9uIHRoZSBjdXJ2ZSBiYXNlZCBvbiB0aGUgYHRgICh0aW1lKSB2YWx1ZSwgd2hpY2ggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldFhcclxuKiBAcGFyYW0ge251bWJlcn0gW3Q9MF0gLSBUaGUgdGltZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgZnJvbSB3aGljaCB0byBleHRyYWN0IGEgcG9pbnQuIFRoaXMgaXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIHdoZXJlIDAgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlIGFuZCAxIHRoZSBlbmQuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgWCBjb21wb25lbnQgb2YgYSBwb2ludCBvbiB0aGUgY3VydmUgYmFzZWQgb24gdGhlIGB0YCAodGltZSkgdmFsdWUuXHJcbiovXHJcbnZhciBHZXRYID0gZnVuY3Rpb24gKGN1cnZlLCB0KVxyXG57XHJcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHQgPSAwO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0IDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHQgPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0MiA9IHQgKiB0O1xyXG4gICAgdmFyIHQzID0gdCAqIHQyO1xyXG5cclxuICAgIHJldHVybiAodDMgKiBjdXJ2ZS5fYXggKyB0MiAqIGN1cnZlLl9ieCArIHQgKiBjdXJ2ZS5fdjF4ICsgY3VydmUuX3AxeCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRYLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogR2V0IHRoZSBZIGNvbXBvbmVudCBvZiBhIHBvaW50IG9uIHRoZSBjdXJ2ZSBiYXNlZCBvbiB0aGUgYHRgICh0aW1lKSB2YWx1ZSwgd2hpY2ggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldFlcclxuKiBAcGFyYW0ge251bWJlcn0gW3Q9MF0gLSBUaGUgdGltZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgZnJvbSB3aGljaCB0byBleHRyYWN0IGEgcG9pbnQuIFRoaXMgaXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIHdoZXJlIDAgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlIGFuZCAxIHRoZSBlbmQuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgWSBjb21wb25lbnQgb2YgYSBwb2ludCBvbiB0aGUgY3VydmUgYmFzZWQgb24gdGhlIGB0YCAodGltZSkgdmFsdWUuXHJcbiovXHJcbnZhciBHZXRZID0gZnVuY3Rpb24gKGN1cnZlLCB0KVxyXG57XHJcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHQgPSAwO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0IDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHQgPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0MiA9IHQgKiB0O1xyXG4gICAgdmFyIHQzID0gdCAqIHQyO1xyXG5cclxuICAgIHJldHVybiAodDMgKiBjdXJ2ZS5fYXkgKyB0MiAqIGN1cnZlLl9ieSArIHQgKiBjdXJ2ZS5fdjF5ICsgY3VydmUuX3AxeSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRZLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGF1dGhvciAgICAgICBQZXRlIEJhcm9uIDxwZXRlQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogQSBkYXRhIHJlcHJlc2VudGF0aW9uIG9mIGEgSGVybWl0ZSBDdXJ2ZSAoc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfSGVybWl0ZV9zcGxpbmUpXHJcbiogXHJcbiogQSBIZXJtaXRlIGN1cnZlIGhhcyBhIHN0YXJ0IGFuZCBlbmQgcG9pbnQgYW5kIHRhbmdlbnQgdmVjdG9ycyBmb3IgYm90aCBvZiB0aGVtLlxyXG4qIFRoZSBjdXJ2ZSB3aWxsIGFsd2F5cyBwYXNzIHRocm91Z2ggdGhlIHR3byBjb250cm9sIHBvaW50cyBhbmQgdGhlIHNoYXBlIG9mIGl0IGlzIGNvbnRyb2xsZWRcclxuKiBieSB0aGUgbGVuZ3RoIGFuZCBkaXJlY3Rpb24gb2YgdGhlIHRhbmdlbnQgdmVjdG9ycy4gIEF0IHRoZSBjb250cm9sIHBvaW50cyB0aGUgY3VydmUgd2lsbFxyXG4qIGJlIGZhY2luZyBleGFjdGx5IGluIHRoZSB2ZWN0b3IgZGlyZWN0aW9uLlxyXG4qIFxyXG4qIEFzIHRoZXNlIGN1cnZlcyBjaGFuZ2Ugc3BlZWQgKHNwZWVkID0gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgc2VwYXJhdGVkIGJ5IGFuIGVxdWFsIGNoYW5nZSBpblxyXG4qICd0JyB2YWx1ZSAtIHNlZSBIZXJtaXRlLmdldFBvaW50KSB0aGlzIGNsYXNzIGF0dGVtcHRzIHRvIHJlZHVjZSB0aGUgdmFyaWF0aW9uIGJ5IHByZS1jYWxjdWxhdGluZ1xyXG4qIHRoZSBgYWNjdXJhY3lgIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlLiBUaGUgc3RyYWlnaHQtbGluZSBkaXN0YW5jZXMgdG8gdGhlc2UgcG9pbnRzIGFyZSBzdG9yZWRcclxuKiBpbiB0aGUgcHJpdmF0ZSAncG9pbnRzJyBhcnJheSwgYW5kIHRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZCBieSBIZXJtaXRlLmZpbmRUKCkgdG8gY29udmVydCBhIHBpeGVsXHJcbiogZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlIGludG8gYSAndGltZScgdmFsdWUuXHJcbiogXHJcbiogSGlnaGVyIGBhY2N1cmFjeWAgdmFsdWVzIHdpbGwgcmVzdWx0IGluIG1vcmUgZXZlbiBtb3ZlbWVudCwgYnV0IHJlcXVpcmUgbW9yZSBtZW1vcnkgZm9yIHRoZSBwb2ludHNcclxuKiBsaXN0LiA1IHdvcmtzLCBidXQgMTAgc2VlbXMgdG8gYmUgYW4gaWRlYWwgdmFsdWUgZm9yIHRoZSBsZW5ndGggb2YgY3VydmVzIGZvdW5kIGluIG1vc3QgZ2FtZXMgb25cclxuKiBhIGRlc2t0b3Agc2NyZWVuLiBJZiB5b3UgdXNlIHZlcnkgbG9uZyBjdXJ2ZXMgKG1vcmUgdGhhbiA0MDAgcGl4ZWxzKSB5b3UgbWF5IG5lZWQgdG8gaW5jcmVhc2VcclxuKiB0aGlzIHZhbHVlIGZ1cnRoZXIuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLkhlcm1pdGVcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge251bWJlcn0gcDF4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBwMXkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHAyeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHAyeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHYxeCAtIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHYxeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHYyeCAtIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB2MnkgLSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW2FjY3VyYWN5PTEwXSBUaGUgYW1vdW50IG9mIHBvaW50cyB0byBwcmUtY2FsY3VsYXRlIG9uIHRoZSBjdXJ2ZS5cclxuKi9cclxudmFyIEhlcm1pdGUgPSBmdW5jdGlvbiAocDF4LCBwMXksIHAyeCwgcDJ5LCB2MXgsIHYxeSwgdjJ4LCB2MnksIGFjY3VyYWN5KVxyXG57XHJcbiAgICBpZiAoYWNjdXJhY3kgPT09IHVuZGVmaW5lZCkgeyBhY2N1cmFjeSA9IDEwOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfYWNjdXJhY3kgLSBUaGUgYW1vdW50IG9mIHBvaW50cyB0byBwcmUtY2FsY3VsYXRlIG9uIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl9hY2N1cmFjeSA9IGFjY3VyYWN5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX3AxeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl9wMXggPSBwMXg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfcDF5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3AxeSA9IHAxeTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9wMnggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3AyeCA9IHAyeDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9wMnkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3AyeSA9IHAyeTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF92MXggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3YxeCA9IHYxeDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF92MXkgLSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3YxeSA9IHYxeTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF92MnggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl92MnggPSB2Mng7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjJ5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fdjJ5ID0gdjJ5O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHthcnJheX0gX3BvaW50cyAtIEEgbG9jYWwgYXJyYXkgb2YgY2FjaGVkIHBvaW50cy5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl9wb2ludHMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuUG9pbnR9IF90ZW1wMSAtIEEgbG9jYWwgY2FjaGVkIFBvaW50IG9iamVjdC5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl90ZW1wMSA9IG5ldyBQb2ludCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5Qb2ludH0gX3RlbXAyIC0gQSBsb2NhbCBjYWNoZWQgUG9pbnQgb2JqZWN0LlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3RlbXAyID0gbmV3IFBvaW50KCk7XHJcblxyXG4gICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG59O1xyXG5cclxuSGVybWl0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIZXJtaXRlO1xyXG5cclxuSGVybWl0ZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFBlcmZvcm1zIHRoZSBjdXJ2ZSBjYWxjdWxhdGlvbnMuXHJcbiAgICAqXHJcbiAgICAqIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgaWYgeW91IGNoYW5nZSBhbnkgb2YgdGhlIGN1cnZlcyBwdWJsaWMgcHJvcGVydGllcywgc3VjaCBhcyBgSGVybWl0ZS5wMXhgIG9yIGBIZXJtaXRlLnYyeWAuXHJcbiAgICAqXHJcbiAgICAqIElmIHlvdSBhZGp1c3QgYW55IG9mIHRoZSBpbnRlcm5hbCBwcml2YXRlIHZhbHVlcywgdGhlbiBjYWxsIHRoaXMgdG8gdXBkYXRlIHRoZSBwb2ludHMuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjcmVjYWxjdWxhdGVcclxuICAgICogQHJldHVybiB7UGhhc2VyLkhlcm1pdGV9IFRoaXMgb2JqZWN0LlxyXG4gICAgKi9cclxuICAgIHJlY2FsY3VsYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX2F4ID0gKDIgKiB0aGlzLl9wMXggLSAyICogdGhpcy5fcDJ4ICsgdGhpcy5fdjF4ICsgdGhpcy5fdjJ4KTtcclxuICAgICAgICB0aGlzLl9heSA9ICgyICogdGhpcy5fcDF5IC0gMiAqIHRoaXMuX3AyeSArIHRoaXMuX3YxeSArIHRoaXMuX3YyeSk7XHJcbiAgICAgICAgdGhpcy5fYnggPSAoLTMgKiB0aGlzLl9wMXggKyAzICogdGhpcy5fcDJ4IC0gMiAqIHRoaXMuX3YxeCAtIHRoaXMuX3YyeCk7XHJcbiAgICAgICAgdGhpcy5fYnkgPSAoLTMgKiB0aGlzLl9wMXkgKyAzICogdGhpcy5fcDJ5IC0gMiAqIHRoaXMuX3YxeSAtIHRoaXMuX3YyeSk7XHJcblxyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5jYWxjdWxhdGVFdmVuUG9pbnRzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQ2FsY3VsYXRlIGEgbnVtYmVyIG9mIHBvaW50cyBhbG9uZyB0aGUgY3VydmUsIGJhc2VkIG9uIGBIZXJtaXRlLmFjY3VyYWN5YCwgYW5kIHN0b3JlcyB0aGVtIGluIHRoZSBwcml2YXRlIGBfcG9pbnRzYCBhcnJheS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNjYWxjdWxhdGVFdmVuUG9pbnRzXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgY3VydmUgYXBwcm94aW1hdGVkIGFzIHN0cmFpZ2h0IGxpbmUgZGlzdGFuY2VzIGJldHdlZW4gdGhlIHBvaW50cy5cclxuICAgICovXHJcbiAgICBjYWxjdWxhdGVFdmVuUG9pbnRzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0b3RhbExlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuX3RlbXAxLnNldFRvKDAsIDApOyAgICAgICAgICAgICAgICAgICAgLy8gIHBudFxyXG4gICAgICAgIHRoaXMuX3RlbXAyLnNldFRvKHRoaXMuX3AxeCwgdGhpcy5fcDF5KTsgICAgLy8gIGxhc3RQbnRcclxuXHJcbiAgICAgICAgdGhpcy5fcG9pbnRzWzBdID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy5fYWNjdXJhY3k7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0UG9pbnQoaSAvIHRoaXMuX2FjY3VyYWN5LCB0aGlzLl90ZW1wMSk7XHJcblxyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSB0aGlzLl90ZW1wMS5kaXN0YW5jZSh0aGlzLl90ZW1wMik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9wb2ludHNbaV0gPSB0b3RhbExlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5fdGVtcDIuY29weUZyb20odGhpcy5fdGVtcDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhlcm1pdGUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI2FjY3VyYWN5XHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhY2N1cmFjeSAtIFRoZSBhbW91bnQgb2YgcG9pbnRzIHRvIHByZS1jYWxjdWxhdGUgb24gdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIGFjY3VyYWN5OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY2N1cmFjeTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYWNjdXJhY3kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjY3VyYWN5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjcDF4XHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwMXggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cclxuICAgICovXHJcbiAgICBwMXg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3AxeDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcDF4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wMXggPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSNwMXlcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHAxeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHAxeToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcDF5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wMXkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3AxeSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3AyeFxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcDJ4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHAyeDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcDJ4O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wMngpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3AyeCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3AyeVxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcDJ5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHAyeToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcDJ5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wMnkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3AyeSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3YxeFxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjF4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHYxeDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdjF4O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92MXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3YxeCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3YxeVxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjF5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHYxeToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdjF5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92MXkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3YxeSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3YyeFxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjJ4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cclxuICAgICovXHJcbiAgICB2Mng6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YyeDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdjJ4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92MnggPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSN2MnlcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHYyeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCByZWNhbGN1bGF0ZSB0aGUgY3VydmUuXHJcbiAgICAqL1xyXG4gICAgdjJ5OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92Mnk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3YyeSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdjJ5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhlcm1pdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9IZXJtaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL0hlcm1pdGUuanMiLCIvLyAgUGhhc2VyLkdlb20uSGVybWl0ZVxyXG5cclxudmFyIEhlcm1pdGUgPSByZXF1aXJlKCcuL0hlcm1pdGUnKTtcclxuXHJcbkhlcm1pdGUuRmluZFQgPSByZXF1aXJlKCcuL0ZpbmRUJyk7XHJcbkhlcm1pdGUuR2V0QW5nbGUgPSByZXF1aXJlKCcuL0dldEFuZ2xlJyk7XHJcbkhlcm1pdGUuR2V0QW5nbGVXaXRoRGlzdGFuY2UgPSByZXF1aXJlKCcuL0dldEFuZ2xlV2l0aERpc3RhbmNlJyk7XHJcbkhlcm1pdGUuR2V0RW50cnlUYW5nZW50ID0gcmVxdWlyZSgnLi9HZXRFbnRyeVRhbmdlbnQnKTtcclxuSGVybWl0ZS5HZXRQb2ludCA9IHJlcXVpcmUoJy4vR2V0UG9pbnQnKTtcclxuSGVybWl0ZS5HZXRQb2ludFdpdGhEaXN0YW5jZSA9IHJlcXVpcmUoJy4vR2V0UG9pbnRXaXRoRGlzdGFuY2UnKTtcclxuSGVybWl0ZS5HZXRYID0gcmVxdWlyZSgnLi9HZXRYJyk7XHJcbkhlcm1pdGUuR2V0WSA9IHJlcXVpcmUoJy4vR2V0WScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIZXJtaXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2hlcm1pdGUvaW5kZXguanMiLCJ2YXIgRGlzdGFuY2VCZXR3ZWVuID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZUJldHdlZW4nKTtcclxuXHJcbnZhciBDaXJjbGVUb0NpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGVBLCBjaXJjbGVCKVxyXG57XHJcbiAgICByZXR1cm4gKERpc3RhbmNlQmV0d2VlbihjaXJjbGVBLngsIGNpcmNsZUEueSwgY2lyY2xlQi54LCBjaXJjbGVCLnkpIDw9IChjaXJjbGVBLnJhZGl1cyArIGNpcmNsZUIucmFkaXVzKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZVRvQ2lyY2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanMiLCJ2YXIgQ2lyY2xlVG9SZWN0YW5nbGUgPSBmdW5jdGlvbiAoY2lyY2xlLCByZWN0KVxyXG57XHJcbiAgICB2YXIgaGFsZldpZHRoID0gcmVjdC53aWR0aCAvIDI7XHJcbiAgICB2YXIgaGFsZkhlaWdodCA9IHJlY3QuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICB2YXIgY3ggPSBNYXRoLmFicyhjaXJjbGUueCAtIHJlY3QueCAtIGhhbGZXaWR0aCk7XHJcbiAgICB2YXIgeERpc3QgPSBoYWxmV2lkdGggKyBjaXJjbGUucmFkaXVzO1xyXG5cclxuICAgIGlmIChjeCA8PSBoYWxmV2lkdGggfHwgY3ggPiB4RGlzdClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGN5ID0gTWF0aC5hYnMoY2lyY2xlLnkgLSByZWN0LnkgLSBoYWxmSGVpZ2h0KTtcclxuICAgIHZhciB5RGlzdCA9IGhhbGZIZWlnaHQgKyBjaXJjbGUucmFkaXVzO1xyXG5cclxuICAgIGlmIChjeSA8PSBoYWxmSGVpZ2h0IHx8IGN5ID4geURpc3QpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4Q29ybmVyRGlzdCA9IGN4IC0gaGFsZldpZHRoO1xyXG4gICAgdmFyIHlDb3JuZXJEaXN0ID0gY3kgLSBoYWxmSGVpZ2h0O1xyXG4gICAgdmFyIHhDb3JuZXJEaXN0U3EgPSB4Q29ybmVyRGlzdCAqIHhDb3JuZXJEaXN0O1xyXG4gICAgdmFyIHlDb3JuZXJEaXN0U3EgPSB5Q29ybmVyRGlzdCAqIHlDb3JuZXJEaXN0O1xyXG4gICAgdmFyIG1heENvcm5lckRpc3RTcSA9IGNpcmNsZS5yYWRpdXMgKiBjaXJjbGUucmFkaXVzO1xyXG5cclxuICAgIHJldHVybiAoeENvcm5lckRpc3RTcSArIHlDb3JuZXJEaXN0U3EgPD0gbWF4Q29ybmVyRGlzdFNxKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlVG9SZWN0YW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XHJcbnZhciBSZWN0YW5nbGVUb1JlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlVG9SZWN0YW5nbGUnKTtcclxuXHJcbnZhciBHZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBvdXRwdXQpXHJcbntcclxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSBuZXcgUmVjdGFuZ2xlKCk7IH1cclxuXHJcbiAgICBpZiAoUmVjdGFuZ2xlVG9SZWN0YW5nbGUocmVjdEEsIHJlY3RCKSlcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQueCA9IE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpO1xyXG4gICAgICAgIG91dHB1dC55ID0gTWF0aC5tYXgocmVjdEEueSwgcmVjdEIueSk7XHJcbiAgICAgICAgb3V0cHV0LndpZHRoID0gTWF0aC5taW4ocmVjdEEucmlnaHQsIHJlY3RCLnJpZ2h0KSAtIG91dHB1dC54O1xyXG4gICAgICAgIG91dHB1dC5oZWlnaHQgPSBNYXRoLm1pbihyZWN0QS5ib3R0b20sIHJlY3RCLmJvdHRvbSkgLSBvdXRwdXQueTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2ludGVyc2VjdHMvR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uLmpzIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbnZhciBMaW5lVG9MaW5lID0gZnVuY3Rpb24gKGxpbmUxLCBsaW5lMiwgYXNTZWdtZW50LCBvdXQpXHJcbntcclxuICAgIGlmIChhc1NlZ21lbnQgPT09IHVuZGVmaW5lZCkgeyBhc1NlZ21lbnQgPSB0cnVlOyB9XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgYSA9IGxpbmUxLngxO1xyXG4gICAgdmFyIGIgPSBsaW5lMS55MTtcclxuXHJcbiAgICB2YXIgZSA9IGxpbmUxLngyO1xyXG4gICAgdmFyIGYgPSBsaW5lMS55MjtcclxuXHJcbiAgICB2YXIgYTEgPSBiLnkgLSBhLnk7XHJcbiAgICB2YXIgYTIgPSBmLnkgLSBlLnk7XHJcbiAgICB2YXIgYjEgPSBhLnggLSBiLng7XHJcbiAgICB2YXIgYjIgPSBlLnggLSBmLng7XHJcbiAgICB2YXIgYzEgPSAoYi54ICogYS55KSAtIChhLnggKiBiLnkpO1xyXG4gICAgdmFyIGMyID0gKGYueCAqIGUueSkgLSAoZS54ICogZi55KTtcclxuICAgIHZhciBkZW5vbSA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcclxuXHJcbiAgICBpZiAoZGVub20gPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgb3V0LnggPSAoKGIxICogYzIpIC0gKGIyICogYzEpKSAvIGRlbm9tO1xyXG4gICAgb3V0LnkgPSAoKGEyICogYzEpIC0gKGExICogYzIpKSAvIGRlbm9tO1xyXG5cclxuICAgIGlmIChhc1NlZ21lbnQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHVjID0gKChmLnkgLSBlLnkpICogKGIueCAtIGEueCkgLSAoZi54IC0gZS54KSAqIChiLnkgLSBhLnkpKTtcclxuICAgICAgICB2YXIgdWEgPSAoKChmLnggLSBlLngpICogKGEueSAtIGUueSkpIC0gKGYueSAtIGUueSkgKiAoYS54IC0gZS54KSkgLyB1YztcclxuICAgICAgICB2YXIgdWIgPSAoKChiLnggLSBhLngpICogKGEueSAtIGUueSkpIC0gKChiLnkgLSBhLnkpICogKGEueCAtIGUueCkpKSAvIHVjO1xyXG5cclxuICAgICAgICBpZiAodWEgPj0gMCAmJiB1YSA8PSAxICYmIHViID49IDAgJiYgdWIgPD0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVG9MaW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9MaW5lLmpzIiwiLyoqXHJcbiogQ2hlY2tzIGZvciBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgTGluZSBhbmQgYSBSZWN0YW5nbGUgc2hhcGUsIG9yIGEgcmVjdGFuZ2xlLWxpa2VcclxuKiBvYmplY3QsIHdpdGggcHVibGljIGB4YCwgYHlgLCBgcmlnaHRgIGFuZCBgYm90dG9tYCBwcm9wZXJ0aWVzLCBzdWNoIGFzIGEgU3ByaXRlIG9yIEJvZHkuXHJcbipcclxuKiBBbiBpbnRlcnNlY3Rpb24gaXMgY29uc2lkZXJlZCB2YWxpZCBpZjpcclxuKlxyXG4qIFRoZSBsaW5lIHN0YXJ0cyB3aXRoaW4sIG9yIGVuZHMgd2l0aGluLCB0aGUgUmVjdGFuZ2xlLlxyXG4qIFRoZSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyBvbmUgb2YgdGhlIDQgcmVjdGFuZ2xlIGVkZ2VzLlxyXG4qXHJcbiogVGhlIGZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBmdW5jdGlvbiByZWN0YW5nbGVzIGFyZSBjb25zaWRlcmVkICdzb2xpZCcuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5MaW5lLmludGVyc2VjdHNSZWN0YW5nbGVcclxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBsaW5lIC0gVGhlIGxpbmUgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoLlxyXG4qIEBwYXJhbSB7UGhhc2VyLlJlY3RhbmdsZXxvYmplY3R9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlLCBvciByZWN0YW5nbGUtbGlrZSBvYmplY3QsIHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aC5cclxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBsaW5lIGludGVyc2VjdHMgd2l0aCB0aGUgcmVjdGFuZ2xlIGVkZ2VzLCBvciBzdGFydHMgb3IgZW5kcyB3aXRoaW4gdGhlIHJlY3RhbmdsZS5cclxuKi9cclxudmFyIExpbmVUb1JlY3RhbmdsZSA9IGZ1bmN0aW9uIChsaW5lLCByZWN0KVxyXG57XHJcbiAgICB2YXIgeDEgPSBsaW5lLngxO1xyXG4gICAgdmFyIHkxID0gbGluZS55MjtcclxuXHJcbiAgICB2YXIgeDIgPSBsaW5lLngyO1xyXG4gICAgdmFyIHkyID0gbGluZS55MjtcclxuXHJcbiAgICB2YXIgYngxID0gcmVjdC54O1xyXG4gICAgdmFyIGJ5MSA9IHJlY3QueTtcclxuICAgIHZhciBieDIgPSByZWN0LnJpZ2h0O1xyXG4gICAgdmFyIGJ5MiA9IHJlY3QuYm90dG9tO1xyXG5cclxuICAgIHZhciB0ID0gMDtcclxuXHJcbiAgICAvLyAgSWYgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgbGluZSBpcyBpbnNpZGUgdGhlIHJlY3QgdGhlbiB3ZSBhc3N1bWVcclxuICAgIC8vICBjb2xsaXNpb24sIGFzIHJlY3RzIGFyZSBzb2xpZCBmb3Igb3VyIHVzZS1jYXNlLlxyXG5cclxuICAgIGlmICgoeDEgPj0gYngxICYmIHgxIDw9IGJ4MiAmJiB5MSA+PSBieTEgJiYgeTEgPD0gYnkyKSB8fFxyXG4gICAgICAgICh4MiA+PSBieDEgJiYgeDIgPD0gYngyICYmIHkyID49IGJ5MSAmJiB5MiA8PSBieTIpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh4MSA8IGJ4MSAmJiB4MiA+PSBieDEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIExlZnQgZWRnZVxyXG4gICAgICAgIHQgPSB5MSArICh5MiAtIHkxKSAqIChieDEgLSB4MSkgLyAoeDIgLSB4MSk7XHJcblxyXG4gICAgICAgIGlmICh0ID4gYnkxICYmIHQgPD0gYnkyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoeDEgPiBieDIgJiYgeDIgPD0gYngyKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBSaWdodCBlZGdlXHJcbiAgICAgICAgdCA9IHkxICsgKHkyIC0geTEpICogKGJ4MiAtIHgxKSAvICh4MiAtIHgxKTtcclxuXHJcbiAgICAgICAgaWYgKHQgPj0gYnkxICYmIHQgPD0gYnkyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh5MSA8IGJ5MSAmJiB5MiA+PSBieTEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRvcCBlZGdlXHJcbiAgICAgICAgdCA9IHgxICsgKHgyIC0geDEpICogKGJ5MSAtIHkxKSAvICh5MiAtIHkxKTtcclxuXHJcbiAgICAgICAgaWYgKHQgPj0gYngxICYmIHQgPD0gYngyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoeTEgPiBieTIgJiYgeTIgPD0gYnkyKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBCb3R0b20gZWRnZVxyXG4gICAgICAgIHQgPSB4MSArICh4MiAtIHgxKSAqIChieTIgLSB5MSkgLyAoeTIgLSB5MSk7XHJcblxyXG4gICAgICAgIGlmICh0ID49IGJ4MSAmJiB0IDw9IGJ4MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVUb1JlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludFRvTGluZSA9IHJlcXVpcmUoJy4vUG9pbnRUb0xpbmUnKTtcclxuXHJcbnZhciBQb2ludFRvTGluZVNlZ21lbnQgPSBmdW5jdGlvbiAocG9pbnQsIGxpbmUpXHJcbntcclxuICAgIGlmICghUG9pbnRUb0xpbmUocG9pbnQsIGxpbmUpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeE1pbiA9IE1hdGgubWluKGxpbmUueDEsIGxpbmUueDIpO1xyXG4gICAgdmFyIHhNYXggPSBNYXRoLm1heChsaW5lLngxLCBsaW5lLngyKTtcclxuICAgIHZhciB5TWluID0gTWF0aC5taW4obGluZS55MSwgbGluZS55Mik7XHJcbiAgICB2YXIgeU1heCA9IE1hdGgubWF4KGxpbmUueTEsIGxpbmUueTIpO1xyXG5cclxuICAgIHJldHVybiAoKHBvaW50LnggPj0geE1pbiAmJiBwb2ludC54IDw9IHhNYXgpICYmIChwb2ludC55ID49IHlNaW4gJiYgcG9pbnQueSA8PSB5TWF4KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50VG9MaW5lU2VnbWVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lU2VnbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZVNlZ21lbnQuanMiLCJ2YXIgUmVjdGFuZ2xlVG9WYWx1ZXMgPSBmdW5jdGlvbiAocmVjdCwgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCB0b2xlcmFuY2UpXHJcbntcclxuICAgIGlmICh0b2xlcmFuY2UgPT09IHVuZGVmaW5lZCkgeyB0b2xlcmFuY2UgPSAwOyB9XHJcblxyXG4gICAgcmV0dXJuICEoXHJcbiAgICAgICAgbGVmdCA+IHJlY3QucmlnaHQgKyB0b2xlcmFuY2UgfHxcclxuICAgICAgICByaWdodCA8IHJlY3QubGVmdCAtIHRvbGVyYW5jZSB8fFxyXG4gICAgICAgIHRvcCA+IHJlY3QuYm90dG9tICsgdG9sZXJhbmNlIHx8XHJcbiAgICAgICAgYm90dG9tIDwgcmVjdC50b3AgLSB0b2xlcmFuY2VcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZVRvVmFsdWVzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9WYWx1ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2lyY2xlVG9DaXJjbGU6IHJlcXVpcmUoJy4vQ2lyY2xlVG9DaXJjbGUnKSxcclxuICAgIENpcmNsZVRvUmVjdGFuZ2xlOiByZXF1aXJlKCcuL0NpcmNsZVRvUmVjdGFuZ2xlJyksXHJcbiAgICBHZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb246IHJlcXVpcmUoJy4vR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uJyksXHJcbiAgICBMaW5lVG9MaW5lOiByZXF1aXJlKCcuL0xpbmVUb0xpbmUnKSxcclxuICAgIExpbmVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9MaW5lVG9SZWN0YW5nbGUnKSxcclxuICAgIFBvaW50VG9MaW5lOiByZXF1aXJlKCcuL1BvaW50VG9MaW5lJyksXHJcbiAgICBQb2ludFRvTGluZVNlZ21lbnQ6IHJlcXVpcmUoJy4vUG9pbnRUb0xpbmVTZWdtZW50JyksXHJcbiAgICBSZWN0YW5nbGVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9SZWN0YW5nbGVUb1JlY3RhbmdsZScpLFxyXG4gICAgUmVjdGFuZ2xlVG9WYWx1ZXM6IHJlcXVpcmUoJy4vUmVjdGFuZ2xlVG9WYWx1ZXMnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9pbnRlcnNlY3RzL2luZGV4LmpzIiwiXHJcbnZhciBDZW50ZXJPbiA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5KVxyXG57XHJcbiAgICB2YXIgdHggPSB4IC0gKChsaW5lLngxICsgbGluZS54MikgLyAyKTtcclxuICAgIHZhciB0eSA9IHkgLSAoKGxpbmUueTEgKyBsaW5lLnkyKSAvIDIpO1xyXG5cclxuICAgIGxpbmUueDEgKz0gdHg7XHJcbiAgICBsaW5lLnkxICs9IHR5O1xyXG5cclxuICAgIGxpbmUueDIgKz0gdHg7XHJcbiAgICBsaW5lLnkyICs9IHR5O1xyXG5cclxuICAgIHJldHVybiBsaW5lO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpbmUgPSByZXF1aXJlKCcuL0xpbmUnKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXHJcbntcclxuICAgIHJldHVybiBuZXcgTGluZShzb3VyY2UueDEsIHNvdXJjZS55MSwgc291cmNlLngyLCBzb3VyY2UueTIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAyODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL0Nsb25lLmpzIiwiLyoqXHJcbiogQ29waWVzIHRoZSB4LCB5IGFuZCBkaWFtZXRlciBwcm9wZXJ0aWVzIGZyb20gYW55IGdpdmVuIG9iamVjdCB0byB0aGlzIENpcmNsZS5cclxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cclxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXHJcbiogQHJldHVybiB7Q2lyY2xlfSBUaGlzIENpcmNsZSBvYmplY3QuXHJcbiovXHJcbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54MSwgc291cmNlLnkxLCBzb3VyY2UueDIsIHNvdXJjZS55Mik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDI4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKGxpbmUsIHRvQ29tcGFyZSlcclxue1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICBsaW5lLngxID09PSB0b0NvbXBhcmUueDEgJiZcclxuICAgICAgICBsaW5lLnkxID09PSB0b0NvbXBhcmUueTEgJiZcclxuICAgICAgICBsaW5lLngyID09PSB0b0NvbXBhcmUueDIgJiZcclxuICAgICAgICBsaW5lLnkyID09PSB0b0NvbXBhcmUueTJcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gMjg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgR2V0TWlkUG9pbnQgPSBmdW5jdGlvbiAobGluZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBvdXQueCA9IChsaW5lLngxICsgbGluZS54MikgLyAyO1xyXG4gICAgb3V0LnkgPSAobGluZS55MSArIGxpbmUueTIpIC8gMjtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRNaWRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0dldE1pZFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL0dldE1pZFBvaW50LmpzIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbnZhciBHZXROb3JtYWwgPSBmdW5jdGlvbiAobGluZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgYSA9IEFuZ2xlKGxpbmUpIC0gTUFUSF9DT05TVC5UQVU7XHJcblxyXG4gICAgb3V0LnggPSBNYXRoLmNvcyhhKTtcclxuICAgIG91dC55ID0gTWF0aC5zaW4oYSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Tm9ybWFsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvR2V0Tm9ybWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL0dldE5vcm1hbC5qcyIsIi8qKlxyXG4qIFVzaW5nIEJyZXNlbmhhbSdzIGxpbmUgYWxnb3JpdGhtIHRoaXMgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIGNvb3JkaW5hdGVzIG9uIHRoaXMgbGluZS5cclxuKiBUaGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIHJvdW5kZWQgYmVmb3JlIHRoaXMgcnVucyBhcyB0aGUgYWxnb3JpdGhtIHdvcmtzIG9uIGludGVnZXJzLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuTGluZSNjb29yZGluYXRlc09uTGluZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3RlcFJhdGU9MV0gLSBIb3cgbWFueSBzdGVwcyB3aWxsIHdlIHJldHVybj8gMSA9IGV2ZXJ5IGNvb3JkaW5hdGUgb24gdGhlIGxpbmUsIDIgPSBldmVyeSBvdGhlciBjb29yZGluYXRlLCBldGMuXHJcbiogQHBhcmFtIHthcnJheX0gW3Jlc3VsdHNdIC0gVGhlIGFycmF5IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLiBJZiBub3QgcHJvdmlkZWQgYSBuZXcgb25lIHdpbGwgYmUgZ2VuZXJhdGVkLlxyXG4qIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBjb29yZGluYXRlcy5cclxuKi9cclxudmFyIEdldFBvaW50c09uTGluZSA9IGZ1bmN0aW9uIChsaW5lLCBzdGVwUmF0ZSwgcmVzdWx0cylcclxue1xyXG4gICAgaWYgKHN0ZXBSYXRlID09PSB1bmRlZmluZWQpIHsgc3RlcFJhdGUgPSAxOyB9XHJcbiAgICBpZiAocmVzdWx0cyA9PT0gdW5kZWZpbmVkKSB7IHJlc3VsdHMgPSBbXTsgfVxyXG5cclxuICAgIHZhciB4MSA9IE1hdGgucm91bmQobGluZS54MSk7XHJcbiAgICB2YXIgeTEgPSBNYXRoLnJvdW5kKGxpbmUueTEpO1xyXG4gICAgdmFyIHgyID0gTWF0aC5yb3VuZChsaW5lLngyKTtcclxuICAgIHZhciB5MiA9IE1hdGgucm91bmQobGluZS55Mik7XHJcblxyXG4gICAgdmFyIGR4ID0gTWF0aC5hYnMoeDIgLSB4MSk7XHJcbiAgICB2YXIgZHkgPSBNYXRoLmFicyh5MiAtIHkxKTtcclxuICAgIHZhciBzeCA9ICh4MSA8IHgyKSA/IDEgOiAtMTtcclxuICAgIHZhciBzeSA9ICh5MSA8IHkyKSA/IDEgOiAtMTtcclxuICAgIHZhciBlcnIgPSBkeCAtIGR5O1xyXG5cclxuICAgIHJlc3VsdHMucHVzaChbIHgxLCB5MSBdKTtcclxuXHJcbiAgICB2YXIgaSA9IDE7XHJcblxyXG4gICAgd2hpbGUgKCEoKHgxID09PSB4MikgJiYgKHkxID09PSB5MikpKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBlMiA9IGVyciA8PCAxO1xyXG5cclxuICAgICAgICBpZiAoZTIgPiAtZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBlcnIgLT0gZHk7XHJcbiAgICAgICAgICAgIHgxICs9IHN4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGUyIDwgZHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBlcnIgKz0gZHg7XHJcbiAgICAgICAgICAgIHkxICs9IHN5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkgJSBzdGVwUmF0ZSA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChbIHgxLCB5MSBdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UG9pbnRzT25MaW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvR2V0UG9pbnRzT25MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEhlaWdodCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hYnMobGluZS55MSAtIGxpbmUueTIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIZWlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9IZWlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDI4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGVuZ3RoID0gZnVuY3Rpb24gKGxpbmUpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnNxcnQoKGxpbmUueDIgLSBsaW5lLngxKSAqIChsaW5lLngyIC0gbGluZS54MSkgKyAobGluZS55MiAtIGxpbmUueTEpICogKGxpbmUueTIgLSBsaW5lLnkxKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExlbmd0aDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0xlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XHJcblxyXG52YXIgTm9ybWFsWCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5jb3MoQW5nbGUobGluZSkgLSBNQVRIX0NPTlNULlRBVSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbFg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9Ob3JtYWxYLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL05vcm1hbFguanMiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcclxudmFyIEFuZ2xlID0gcmVxdWlyZSgnLi9BbmdsZScpO1xyXG5cclxudmFyIE5vcm1hbFkgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGguc2luKEFuZ2xlKGxpbmUpIC0gTUFUSF9DT05TVC5UQVUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTm9ybWFsWS5qc1xuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9Ob3JtYWxZLmpzIiwidmFyIFBlcnBTbG9wZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gLSgobGluZS54MiAtIGxpbmUueDEpIC8gKGxpbmUueTIgLSBsaW5lLnkxKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBlcnBTbG9wZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1BlcnBTbG9wZS5qc1xuLy8gbW9kdWxlIGlkID0gMjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGxpbmUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIHQgPSBNYXRoLnJhbmRvbSgpO1xyXG5cclxuICAgIG91dC54ID0gbGluZS54MSArIHQgKiAobGluZS54MiAtIGxpbmUueDEpO1xyXG4gICAgb3V0LnkgPSBsaW5lLnkxICsgdCAqIChsaW5lLnkyIC0gbGluZS55MSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL1JhbmRvbS5qcyIsInZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxudmFyIE5vcm1hbEFuZ2xlID0gcmVxdWlyZSgnLi9Ob3JtYWxBbmdsZScpO1xyXG5cclxuLyoqXHJcbiogUmV0dXJucyB0aGUgcmVmbGVjdGVkIGFuZ2xlIGJldHdlZW4gdHdvIGxpbmVzLlxyXG4qIFRoaXMgaXMgdGhlIG91dGdvaW5nIGFuZ2xlIGJhc2VkIG9uIHRoZSBhbmdsZSBvZiBMaW5lIDEgYW5kIHRoZSBub3JtYWxBbmdsZSBvZiBMaW5lIDIuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5MaW5lLnJlZmxlY3RcclxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBhIC0gVGhlIGJhc2UgbGluZS5cclxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBiIC0gVGhlIGxpbmUgdG8gYmUgcmVmbGVjdGVkIGZyb20gdGhlIGJhc2UgbGluZS5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWZsZWN0ZWQgYW5nbGUgaW4gcmFkaWFucy5cclxuKi9cclxudmFyIFJlZmxlY3RBbmdsZSA9IGZ1bmN0aW9uIChsaW5lQSwgbGluZUIpXHJcbntcclxuICAgIHJldHVybiAoMiAqIE5vcm1hbEFuZ2xlKGxpbmVCKSAtIE1hdGguUEkgLSBBbmdsZShsaW5lQSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0QW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9SZWZsZWN0QW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvUmVmbGVjdEFuZ2xlLmpzIiwidmFyIFJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xyXG5cclxudmFyIFJvdGF0ZSA9IGZ1bmN0aW9uIChsaW5lLCBhbmdsZSlcclxue1xyXG4gICAgdmFyIHggPSAobGluZS54MSArIGxpbmUueDIpIC8gMjtcclxuICAgIHZhciB5ID0gKGxpbmUueTEgKyBsaW5lLnkyKSAvIDI7XHJcblxyXG4gICAgcmV0dXJuIFJvdGF0ZUFyb3VuZFhZKGxpbmUsIHgsIHksIGFuZ2xlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUm90YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL1JvdGF0ZS5qcyIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcclxuXHJcbnZhciBSb3RhdGVBcm91bmRQb2ludCA9IGZ1bmN0aW9uIChsaW5lLCBwb2ludCwgYW5nbGUpXHJcbntcclxuICAgIHJldHVybiBSb3RhdGVBcm91bmRYWShsaW5lLCBwb2ludC54LCBwb2ludC55LCBhbmdsZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDI5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCJ2YXIgU2V0VG9BbmdsZSA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5LCBhbmdsZSwgbGVuZ3RoKVxyXG57XHJcbiAgICBsaW5lLngxID0geDtcclxuICAgIGxpbmUueTEgPSB5O1xyXG5cclxuICAgIGxpbmUueDIgPSB4ICsgKE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCk7XHJcbiAgICBsaW5lLnkyID0geSArIChNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGgpO1xyXG5cclxuICAgIHJldHVybiBsaW5lO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRUb0FuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvU2V0VG9BbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbG9wZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gKGxpbmUueTIgLSBsaW5lLnkxKSAvIChsaW5lLngyIC0gbGluZS54MSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNsb3BlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvU2xvcGUuanNcbi8vIG1vZHVsZSBpZCA9IDI5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgV2lkdGggPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKGxpbmUueDEgLSBsaW5lLngyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2lkdGg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9XaWR0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5MaW5lXHJcblxyXG52YXIgTGluZSA9IHJlcXVpcmUoJy4vTGluZScpO1xyXG5cclxuTGluZS5BbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxuTGluZS5DZW50ZXJPbiA9IHJlcXVpcmUoJy4vQ2VudGVyT24nKTtcclxuTGluZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuTGluZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcclxuTGluZS5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5MaW5lLkdldE1pZFBvaW50ID0gcmVxdWlyZSgnLi9HZXRNaWRQb2ludCcpO1xyXG5MaW5lLkdldE5vcm1hbCA9IHJlcXVpcmUoJy4vR2V0Tm9ybWFsJyk7XHJcbkxpbmUuR2V0UG9pbnRzT25MaW5lID0gcmVxdWlyZSgnLi9HZXRQb2ludHNPbkxpbmUnKTtcclxuTGluZS5IZWlnaHQgPSByZXF1aXJlKCcuL0hlaWdodCcpO1xyXG5MaW5lLkxlbmd0aCA9IHJlcXVpcmUoJy4vTGVuZ3RoJyk7XHJcbkxpbmUuTm9ybWFsQW5nbGUgPSByZXF1aXJlKCcuL05vcm1hbEFuZ2xlJyk7XHJcbkxpbmUuTm9ybWFsWCA9IHJlcXVpcmUoJy4vTm9ybWFsWCcpO1xyXG5MaW5lLk5vcm1hbFkgPSByZXF1aXJlKCcuL05vcm1hbFknKTtcclxuTGluZS5QZXJwU2xvcGUgPSByZXF1aXJlKCcuL1BlcnBTbG9wZScpO1xyXG5MaW5lLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XHJcbkxpbmUuUmVmbGVjdEFuZ2xlID0gcmVxdWlyZSgnLi9SZWZsZWN0QW5nbGUnKTtcclxuTGluZS5Sb3RhdGUgPSByZXF1aXJlKCcuL1JvdGF0ZScpO1xyXG5MaW5lLlJvdGF0ZUFyb3VuZFBvaW50ID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRQb2ludCcpO1xyXG5MaW5lLlJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xyXG5MaW5lLlNldFRvQW5nbGUgPSByZXF1aXJlKCcuL1NldFRvQW5nbGUnKTtcclxuTGluZS5TbG9wZSA9IHJlcXVpcmUoJy4vU2xvcGUnKTtcclxuTGluZS5XaWR0aCA9IHJlcXVpcmUoJy4vV2lkdGgnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL2luZGV4LmpzIiwidmFyIEFkZCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcclxue1xyXG4gICAgcG9pbnQueCArPSB4O1xyXG4gICAgcG9pbnQueSArPSB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0FkZC5qc1xuLy8gbW9kdWxlIGlkID0gMzAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZWlsID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oTWF0aC5jZWlsKHBvaW50LngpLCBNYXRoLmNlaWwocG9pbnQueSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZWlsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDMwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHNvdXJjZS54LCBzb3VyY2UueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9DbG9uZS5qcyIsIi8qKlxyXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxyXG4qL1xyXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxyXG57XHJcbiAgICByZXR1cm4gZGVzdC5zZXRUbyhzb3VyY2UueCwgc291cmNlLnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDcm9zcyA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qilcclxue1xyXG4gICAgcmV0dXJuICgocG9pbnRBLnggKiBwb2ludEIueSkgLSAocG9pbnRBLnkgKiBwb2ludEIueCkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcm9zcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Dcm9zcy5qc1xuLy8gbW9kdWxlIGlkID0gMzA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXZpZGUgPSBmdW5jdGlvbiAocG9pbnQsIHgsIHkpXHJcbntcclxuICAgIHBvaW50LnggLz0geDtcclxuICAgIHBvaW50LnkgLz0geTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpdmlkZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9EaXZpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKHBvaW50LCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAocG9pbnQueCA9PT0gdG9Db21wYXJlLnggJiYgcG9pbnQueSA9PT0gdG9Db21wYXJlLnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFcXVhbHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oTWF0aC5mbG9vcihwb2ludC54KSwgTWF0aC5mbG9vcihwb2ludC55KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0Zsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxudmFyIEdldENlbnRyb2lkID0gZnVuY3Rpb24gKHBvaW50cywgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldENlbnRyb2lkIHBvaW50cyBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGxlbiA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZXRDZW50cm9pZCBwb2ludHMgYXJyYXkgbXVzdCBub3QgYmUgZW1wdHknKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlbiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IHBvaW50c1swXS54O1xyXG4gICAgICAgIG91dC55ID0gcG9pbnRzWzBdLnk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dC54ICs9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICBvdXQueSArPSBwb2ludHNbaV0ueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG91dC54IC89IGxlbjtcclxuICAgICAgICBvdXQueSAvPSBsZW47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Q2VudHJvaWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvR2V0Q2VudHJvaWQuanNcbi8vIG1vZHVsZSBpZCA9IDMxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L0dldENlbnRyb2lkLmpzIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxudmFyIEludGVycG9sYXRlID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCB0LCBvdXQpXHJcbntcclxuICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHsgdCA9IDA7IH1cclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIG91dC54ID0gcG9pbnRBLnggKyAoKHBvaW50Qi54IC0gcG9pbnRBLngpICogdCk7XHJcbiAgICBvdXQueSA9IHBvaW50QS55ICsgKChwb2ludEIueSAtIHBvaW50QS55KSAqIHQpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludGVycG9sYXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0ludGVycG9sYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9JbnRlcnBvbGF0ZS5qcyIsIi8qKlxyXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxyXG4qL1xyXG52YXIgSW52ZXJ0ID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8ocG9pbnQueSwgcG9pbnQueCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludmVydDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9JbnZlcnQuanNcbi8vIG1vZHVsZSBpZCA9IDMxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgTmVnYXRpdmUgPSBmdW5jdGlvbiAocG9pbnQsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgcmV0dXJuIG91dC5zZXRUbygtcG9pbnQueCwgLXBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOZWdhdGl2ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9OZWdhdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvTmVnYXRpdmUuanMiLCJ2YXIgTm9ybWFsaXplUmlnaHRIYW5kID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8ocG9pbnQueSAqIC0xLCBwb2ludC54KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsaXplUmlnaHRIYW5kO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L05vcm1hbGl6ZVJpZ2h0SGFuZC5qc1xuLy8gbW9kdWxlIGlkID0gMzE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJwID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oLXBvaW50LnksIHBvaW50LngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1BlcnAuanNcbi8vIG1vZHVsZSBpZCA9IDMxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRG90ID0gcmVxdWlyZSgnLi9Eb3QnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG52YXIgR2V0TWFnbml0dWRlU3EgPSByZXF1aXJlKCcuL0dldE1hZ25pdHVkZVNxJyk7XHJcblxyXG52YXIgUHJvamVjdCA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qiwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgYW10ID0gRG90KHBvaW50QSwgcG9pbnRCKSAvIEdldE1hZ25pdHVkZVNxKHBvaW50Qik7XHJcblxyXG4gICAgaWYgKGFtdCAhPT0gMClcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IGFtdCAqIHBvaW50Qi54O1xyXG4gICAgICAgIG91dC55ID0gYW10ICogcG9pbnRCLnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Qcm9qZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9Qcm9qZWN0LmpzIiwidmFyIERvdCA9IHJlcXVpcmUoJy4vRG90Jyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcclxuXHJcbnZhciBQcm9qZWN0VW5pdCA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qiwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgYW10ID0gRG90KHBvaW50QSwgcG9pbnRCKTtcclxuXHJcbiAgICBpZiAoYW10ICE9PSAwKVxyXG4gICAge1xyXG4gICAgICAgIG91dC54ID0gYW10ICogcG9pbnRCLng7XHJcbiAgICAgICAgb3V0LnkgPSBhbXQgKiBwb2ludEIueTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0VW5pdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Qcm9qZWN0VW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gMzE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvUHJvamVjdFVuaXQuanMiLCJ2YXIgUlBlcnAgPSBmdW5jdGlvbiAocG9pbnQpXHJcbntcclxuICAgIHJldHVybiBwb2ludC5zZXRUbyhwb2ludC55LCAtcG9pbnQueCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJQZXJwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1JQZXJwLmpzXG4vLyBtb2R1bGUgaWQgPSAzMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vTm9ybWFsaXplJyk7XHJcbnZhciBNdWx0aXBseSA9IHJlcXVpcmUoJy4vTXVsdGlwbHknKTtcclxuXHJcbnZhciBTZXRNYWduaXR1ZGUgPSBmdW5jdGlvbiAocG9pbnQsIG1hZ25pdHVkZSlcclxue1xyXG4gICAgTm9ybWFsaXplKHBvaW50KTtcclxuXHJcbiAgICByZXR1cm4gTXVsdGlwbHkocG9pbnQsIG1hZ25pdHVkZSwgbWFnbml0dWRlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0TWFnbml0dWRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qc1xuLy8gbW9kdWxlIGlkID0gMzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvU2V0TWFnbml0dWRlLmpzIiwidmFyIFN1YnRyYWN0ID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5KVxyXG57XHJcbiAgICBwb2ludC54IC09IHg7XHJcbiAgICBwb2ludC55IC09IHk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdWJ0cmFjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9TdWJ0cmFjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5Qb2ludFxyXG5cclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxuUG9pbnQuQWRkID0gcmVxdWlyZSgnLi9BZGQnKTtcclxuUG9pbnQuQ2VpbCA9IHJlcXVpcmUoJy4vQ2VpbCcpO1xyXG5Qb2ludC5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuUG9pbnQuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcblBvaW50LkNyb3NzID0gcmVxdWlyZSgnLi9Dcm9zcycpO1xyXG5Qb2ludC5EaXZpZGUgPSByZXF1aXJlKCcuL0RpdmlkZScpO1xyXG5Qb2ludC5Eb3QgPSByZXF1aXJlKCcuL0RvdCcpO1xyXG5Qb2ludC5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5Qb2ludC5GbG9vciA9IHJlcXVpcmUoJy4vRmxvb3InKTtcclxuUG9pbnQuR2V0Q2VudHJvaWQgPSByZXF1aXJlKCcuL0dldENlbnRyb2lkJyk7XHJcblBvaW50LkdldE1hZ25pdHVkZSA9IHJlcXVpcmUoJy4vR2V0TWFnbml0dWRlJyk7XHJcblBvaW50LkdldE1hZ25pdHVkZVNxID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGVTcScpO1xyXG5Qb2ludC5JbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vSW50ZXJwb2xhdGUnKTtcclxuUG9pbnQuSW52ZXJ0ID0gcmVxdWlyZSgnLi9JbnZlcnQnKTtcclxuUG9pbnQuTXVsdGlwbHkgPSByZXF1aXJlKCcuL011bHRpcGx5Jyk7XHJcblBvaW50Lk5lZ2F0aXZlID0gcmVxdWlyZSgnLi9OZWdhdGl2ZScpO1xyXG5Qb2ludC5Ob3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xyXG5Qb2ludC5Ob3JtYWxpemVSaWdodEhhbmQgPSByZXF1aXJlKCcuL05vcm1hbGl6ZVJpZ2h0SGFuZCcpO1xyXG5Qb2ludC5QZXJwID0gcmVxdWlyZSgnLi9QZXJwJyk7XHJcblBvaW50LlByb2plY3QgPSByZXF1aXJlKCcuL1Byb2plY3QnKTtcclxuUG9pbnQuUHJvamVjdFVuaXQgPSByZXF1aXJlKCcuL1Byb2plY3RVbml0Jyk7XHJcblBvaW50LlJQZXJwID0gcmVxdWlyZSgnLi9SUGVycCcpO1xyXG5Qb2ludC5TZXRNYWduaXR1ZGUgPSByZXF1aXJlKCcuL1NldE1hZ25pdHVkZScpO1xyXG5Qb2ludC5TdWJ0cmFjdCA9IHJlcXVpcmUoJy4vU3VidHJhY3QnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L2luZGV4LmpzIiwidmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChwb2x5Z29uKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFBvbHlnb24ocG9seWdvbi5wb2ludHMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2x5Z29uL0Nsb25lLmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxuLyoqXHJcbiogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuUG9seWdvbiNjb250YWluc1xyXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdG8gdGVzdC5cclxuKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHBvbHlnb24sIG90aGVyd2lzZSBmYWxzZS5cclxuKi9cclxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocG9seWdvbiwgcG9pbnQpXHJcbntcclxuICAgIHJldHVybiBDb250YWlucyhwb2x5Z29uLCBwb2ludC54LCBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDMyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qcyIsIlxyXG52YXIgR2V0QUFCQiA9IGZ1bmN0aW9uIChwb2x5Z29uKVxyXG57XHJcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcclxuICAgIHZhciBtYXhYID0gLW1pblg7XHJcbiAgICB2YXIgbWF4WSA9IC1taW5ZO1xyXG4gICAgdmFyIHA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBwID0gcG9seWdvbi5wb2ludHNbaV07XHJcblxyXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBwLngpO1xyXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwLnkpO1xyXG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLngpO1xyXG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBwLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogbWluWCxcclxuICAgICAgICB5OiBtaW5ZLFxyXG4gICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcclxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBQUJCO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvbHlnb24vR2V0QUFCQi5qc1xuLy8gbW9kdWxlIGlkID0gMzI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBFeHBvcnQgdGhlIHBvaW50cyBhcyBhbiBhcnJheSBvZiBmbGF0IG51bWJlcnMsIGZvbGxvd2luZyB0aGUgc2VxdWVuY2UgWyB4LHksIHgseSwgeCx5IF1cclxuICpcclxuICogQG1ldGhvZCBQaGFzZXIuUG9seWdvbiN0b051bWJlckFycmF5XHJcbiAqIEBwYXJhbSB7YXJyYXl9IFtvdXRwdXRdIC0gVGhlIGFycmF5IHRvIGFwcGVuZCB0aGUgcG9pbnRzIHRvLiBJZiBub3Qgc3BlY2lmaWVkIGEgbmV3IGFycmF5IHdpbGwgYmUgY3JlYXRlZC5cclxuICogQHJldHVybiB7YXJyYXl9IFRoZSBmbGF0dGVuZWQgYXJyYXkuXHJcbiAqL1xyXG52YXIgR2V0TnVtYmVyQXJyYXkgPSBmdW5jdGlvbiAocG9seWdvbiwgb3V0cHV0KVxyXG57XHJcbiAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHsgb3V0cHV0ID0gW107IH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ucG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5wdXNoKHBvbHlnb24ucG9pbnRzW2ldLngpO1xyXG4gICAgICAgIG91dHB1dC5wdXNoKHBvbHlnb24ucG9pbnRzW2ldLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE51bWJlckFycmF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvbHlnb24vR2V0TnVtYmVyQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdlb20uUG9seWdvblxyXG5cclxudmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcclxuXHJcblBvbHlnb24uQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcblBvbHlnb24uQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblBvbHlnb24uQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xyXG5Qb2x5Z29uLkdldEFBQkIgPSByZXF1aXJlKCcuL0dldEFBQkInKTtcclxuUG9seWdvbi5HZXROdW1iZXJBcnJheSA9IHJlcXVpcmUoJy4vR2V0TnVtYmVyQXJyYXknKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2x5Z29uL2luZGV4LmpzIiwidmFyIEFyZWEgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmV0dXJuIHJlY3Qud2lkdGggKiByZWN0LmhlaWdodDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXJlYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQXJlYS5qc1xuLy8gbW9kdWxlIGlkID0gMzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZWlsID0gZnVuY3Rpb24gKHJlY3QpXHJcbntcclxuICAgIHJlY3QueCA9IE1hdGguY2VpbChyZWN0LngpO1xyXG4gICAgcmVjdC55ID0gTWF0aC5jZWlsKHJlY3QueSk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlaWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDMyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbEFsbCA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZWN0LnggPSBNYXRoLmNlaWwocmVjdC54KTtcclxuICAgIHJlY3QueSA9IE1hdGguY2VpbChyZWN0LnkpO1xyXG4gICAgcmVjdC53aWR0aCA9IE1hdGguY2VpbChyZWN0LndpZHRoKTtcclxuICAgIHJlY3QuaGVpZ2h0ID0gTWF0aC5jZWlsKHJlY3QuaGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VpbEFsbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQ2VpbEFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMzI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENlbnRlcnMgdGhpcyBSZWN0YW5nbGUgc28gdGhhdCB0aGUgY2VudGVyIGNvb3JkaW5hdGVzIG1hdGNoIHRoZSBnaXZlbiB4IGFuZCB5IHZhbHVlcy5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlJlY3RhbmdsZSNjZW50ZXJPblxyXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSB0byBwbGFjZSB0aGUgY2VudGVyIG9mIHRoZSBSZWN0YW5nbGUgYXQuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIHRvIHBsYWNlIHRoZSBjZW50ZXIgb2YgdGhlIFJlY3RhbmdsZSBhdC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuUmVjdGFuZ2xlfSBUaGlzIFJlY3RhbmdsZSBvYmplY3RcclxuKi9cclxudmFyIENlbnRlck9uID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIHJlY3QueCA9IHggLSAocmVjdC53aWR0aCAvIDIpO1xyXG4gICAgcmVjdC55ID0geSAtIChyZWN0LmhlaWdodCAvIDIpO1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQ2VudGVyT24uanNcbi8vIG1vZHVsZSBpZCA9IDMzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXHJcbntcclxuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvQ2xvbmUuanMiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgQ29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChyZWN0LCBwb2ludClcclxue1xyXG4gICAgcmV0dXJuIENvbnRhaW5zKHJlY3QsIHBvaW50LngsIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9Db250YWluc1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNQb2ludC5qcyIsIi8vICBDaGVja3MgaWYgcmVjdEIgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiByZWN0QVxyXG5cclxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIpXHJcbntcclxuICAgIC8vICBWb2x1bWUgY2hlY2sgKGlmIHJlY3RCIHZvbHVtZSA+IHJlY3RBIHRoZW4gcmVjdEEgY2Fubm90IGNvbnRhaW4gaXQpXHJcbiAgICBpZiAoKHJlY3RCLndpZHRoICogcmVjdEIuaGVpZ2h0KSA+IChyZWN0QS53aWR0aCAqIHJlY3RBLmhlaWdodCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgKHJlY3RCLnggPiByZWN0QS54ICYmIHJlY3RCLnggPCByZWN0QS5yaWdodCkgJiZcclxuICAgICAgICAocmVjdEIucmlnaHQgPiByZWN0QS54ICYmIHJlY3RCLnJpZ2h0IDwgcmVjdEEucmlnaHQpICYmXHJcbiAgICAgICAgKHJlY3RCLnkgPiByZWN0QS55ICYmIHJlY3RCLnkgPCByZWN0QS5ib3R0b20pICYmIFxyXG4gICAgICAgIChyZWN0Qi5ib3R0b20gPiByZWN0QS55ICYmIHJlY3RCLmJvdHRvbSA8IHJlY3RBLmJvdHRvbSlcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ29waWVzIHRoZSB4LCB5IGFuZCBkaWFtZXRlciBwcm9wZXJ0aWVzIGZyb20gYW55IGdpdmVuIG9iamVjdCB0byB0aGlzIENpcmNsZS5cclxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cclxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXHJcbiogQHJldHVybiB7Q2lyY2xlfSBUaGlzIENpcmNsZSBvYmplY3QuXHJcbiovXHJcbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NvcHlGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFscyA9IGZ1bmN0aW9uIChyZWN0LCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgcmVjdC54ID09PSB0b0NvbXBhcmUueCAmJlxyXG4gICAgICAgIHJlY3QueSA9PT0gdG9Db21wYXJlLnkgJiZcclxuICAgICAgICByZWN0LndpZHRoID09PSB0b0NvbXBhcmUud2lkdGggJiZcclxuICAgICAgICByZWN0LmhlaWdodCA9PT0gdG9Db21wYXJlLmhlaWdodFxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDMzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0QXNwZWN0UmF0aW8gPSByZXF1aXJlKCcuL0dldEFzcGVjdFJhdGlvJyk7XHJcblxyXG4vLyAgRml0cyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSBpbnRvIHRoZSBzb3VyY2UgcmVjdGFuZ2xlLlxyXG4vLyAgUHJlc2VydmVzIGFzcGVjdCByYXRpby5cclxuLy8gIFNjYWxlcyBhbmQgY2VudGVycyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSB0byB0aGUgc291cmNlIHJlY3RhbmdsZVxyXG5cclxudmFyIEZpdEluc2lkZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSlcclxue1xyXG4gICAgdmFyIHJhdGlvID0gR2V0QXNwZWN0UmF0aW8odGFyZ2V0KTtcclxuXHJcbiAgICBpZiAocmF0aW8gPCBHZXRBc3BlY3RSYXRpbyhzb3VyY2UpKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUYWxsZXIgdGhhbiBXaWRlXHJcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLmhlaWdodCAqIHJhdGlvLCBzb3VyY2UuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgV2lkZXIgdGhhbiBUYWxsXHJcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLndpZHRoLCBzb3VyY2Uud2lkdGggKiByYXRpbyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldC5zZXRQb3NpdGlvbihcclxuICAgICAgICAoc291cmNlLnJpZ2h0IC8gMikgLSAodGFyZ2V0LndpZHRoIC8gMiksXHJcbiAgICAgICAgKHNvdXJjZS5ib3R0b20gLyAyKSAtICh0YXJnZXQuaGVpZ2h0IC8gMilcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpdEluc2lkZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvRml0SW5zaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvRml0SW5zaWRlLmpzIiwidmFyIEdldEFzcGVjdFJhdGlvID0gcmVxdWlyZSgnLi9HZXRBc3BlY3RSYXRpbycpO1xyXG5cclxuLy8gIEZpdHMgdGhlIHRhcmdldCByZWN0YW5nbGUgYXJvdW5kIHRoZSBzb3VyY2UgcmVjdGFuZ2xlLlxyXG4vLyAgUHJlc2VydmVzIGFzcGVjdCByYXRpb24uXHJcbi8vICBTY2FsZXMgYW5kIGNlbnRlcnMgdGhlIHRhcmdldCByZWN0YW5nbGUgdG8gdGhlIHNvdXJjZSByZWN0YW5nbGVcclxuXHJcbnZhciBGaXRPdXRzaWRlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKVxyXG57XHJcbiAgICB2YXIgcmF0aW8gPSBHZXRBc3BlY3RSYXRpbyh0YXJnZXQpO1xyXG5cclxuICAgIGlmIChyYXRpbyA+IEdldEFzcGVjdFJhdGlvKHNvdXJjZSkpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFdpZGVyIHRoYW4gVGFsbFxyXG4gICAgICAgIHRhcmdldC5zZXRTaXplKHNvdXJjZS5oZWlnaHQgKiByYXRpbywgc291cmNlLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRhbGxlciB0aGFuIFdpZGVcclxuICAgICAgICB0YXJnZXQuc2V0U2l6ZShzb3VyY2Uud2lkdGgsIHNvdXJjZS53aWR0aCAqIHJhdGlvKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0LnNldFBvc2l0aW9uKFxyXG4gICAgICAgIChzb3VyY2UucmlnaHQgLyAyKSAtIHRhcmdldC53aWR0aCAvIDIsXHJcbiAgICAgICAgKHNvdXJjZS5ib3R0b20gLyAyKSAtIHRhcmdldC5oZWlnaHQgLyAyXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaXRPdXRzaWRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9GaXRPdXRzaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvRml0T3V0c2lkZS5qcyIsInZhciBGbG9vciA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZWN0LnggPSBNYXRoLmZsb29yKHJlY3QueCk7XHJcbiAgICByZWN0LnkgPSBNYXRoLmZsb29yKHJlY3QueSk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9GbG9vci5qc1xuLy8gbW9kdWxlIGlkID0gMzM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9vckFsbCA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZWN0LnggPSBNYXRoLmZsb29yKHJlY3QueCk7XHJcbiAgICByZWN0LnkgPSBNYXRoLmZsb29yKHJlY3QueSk7XHJcbiAgICByZWN0LndpZHRoID0gTWF0aC5mbG9vcihyZWN0LndpZHRoKTtcclxuICAgIHJlY3QuaGVpZ2h0ID0gTWF0aC5mbG9vcihyZWN0LmhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yQWxsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9GbG9vckFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMzM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGUgY2VudGVyIG9mIHRoZSBSZWN0YW5nbGUgb2JqZWN0LCBleHByZXNzZWQgYXMgYSBQb2ludCBvYmplY3QgXHJcblxyXG52YXIgR2V0Q2VudGVyID0gZnVuY3Rpb24gKHJlY3QsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgb3V0LnggPSByZWN0LnJpZ2h0IC8gMjtcclxuICAgIG91dC55ID0gcmVjdC5ib3R0b20gLyAyO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvR2V0Q2VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFRoZSBzaXplIG9mIHRoZSBSZWN0YW5nbGUgb2JqZWN0LCBleHByZXNzZWQgYXMgYSBQb2ludCBvYmplY3QgXHJcbi8vICB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllcy5cclxuXHJcbnZhciBHZXRTaXplID0gZnVuY3Rpb24gKHJlY3QsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgb3V0LnggPSByZWN0LndpZHRoO1xyXG4gICAgb3V0LnkgPSByZWN0LmhlaWdodDtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRTaXplO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9HZXRTaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEluY3JlYXNlcyB0aGUgc2l6ZSBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCBieSB0aGUgc3BlY2lmaWVkIGFtb3VudHMuXHJcbi8vICBUaGUgY2VudGVyIHBvaW50IG9mIHRoZSBSZWN0YW5nbGUgb2JqZWN0IHN0YXlzIHRoZSBzYW1lLCBhbmQgaXRzIHNpemUgaW5jcmVhc2VzIFxyXG4vLyAgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IGJ5IHRoZSB4IHZhbHVlLCBhbmQgdG8gdGhlIHRvcCBhbmQgdGhlIGJvdHRvbSBieSB0aGUgeSB2YWx1ZS5cclxuXHJcbnZhciBJbmZsYXRlID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIC8vICBHZXQgdGhlIGN1cnJlbnQgY2VudGVyXHJcbiAgICB2YXIgY3ggPSByZWN0LnggKyAocmVjdC53aWR0aCAvIDIpO1xyXG4gICAgdmFyIGN5ID0gcmVjdC55ICsgKHJlY3QuaGVpZ2h0IC8gMik7XHJcblxyXG4gICAgLy8gIEluZmxhdGVcclxuICAgIHJlY3Qud2lkdGggPSAyICogeDtcclxuICAgIHJlY3QuaGVpZ2h0ID0gMiAqIHk7XHJcblxyXG4gICAgcmVjdC54ID0geCAtIChyZWN0LndpZHRoIC8gMik7XHJcbiAgICByZWN0LnkgPSB5IC0gKHJlY3QuaGVpZ2h0IC8gMik7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluZmxhdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0luZmxhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgTWVyZ2VzIHRoZSB0YXJnZXQgUmVjdGFuZ2xlIHdpdGggYSBsaXN0IG9mIHBvaW50cy5cclxuLy8gIFRoZSBwb2ludHMgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllcy5cclxuXHJcbnZhciBNZXJnZVBvaW50cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHBvaW50cylcclxue1xyXG4gICAgdmFyIG1pblggPSB0YXJnZXQueDtcclxuICAgIHZhciBtYXhYID0gdGFyZ2V0LnJpZ2h0O1xyXG4gICAgdmFyIG1pblkgPSB0YXJnZXQueTtcclxuICAgIHZhciBtYXhZID0gdGFyZ2V0LmJvdHRvbTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcG9pbnRzW2ldLngpO1xyXG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwb2ludHNbaV0ueCk7XHJcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHBvaW50c1tpXS55KTtcclxuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcG9pbnRzW2ldLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHRhcmdldC54ID0gbWluWDtcclxuICAgIHRhcmdldC55ID0gbWluWTtcclxuICAgIHRhcmdldC53aWR0aCA9IG1heFggLSBtaW5YO1xyXG4gICAgdGFyZ2V0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmdlUG9pbnRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVBvaW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMzQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBNZXJnZXMgc291cmNlIHJlY3RhbmdsZSBpbnRvIHRhcmdldCByZWN0YW5nbGUgYW5kIHJldHVybnMgdGFyZ2V0XHJcbi8vICBOZWl0aGVyIHJlY3Qgc2hvdWxkIGhhdmUgbmVnYXRpdmUgd2lkdGhzIG9yIGhlaWdodHNcclxuXHJcbnZhciBNZXJnZVJlY3QgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpXHJcbntcclxuICAgIHZhciBtaW5YID0gTWF0aC5taW4odGFyZ2V0LngsIHNvdXJjZS54KTtcclxuICAgIHZhciBtYXhYID0gTWF0aC5tYXgodGFyZ2V0LnJpZ2h0LCBzb3VyY2UucmlnaHQpO1xyXG5cclxuICAgIHRhcmdldC54ID0gbWluWDtcclxuICAgIHRhcmdldC53aWR0aCA9IG1heFggLSBtaW5YO1xyXG5cclxuICAgIHZhciBtaW5ZID0gTWF0aC5taW4odGFyZ2V0LnksIHNvdXJjZS55KTtcclxuICAgIHZhciBtYXhZID0gTWF0aC5tYXgodGFyZ2V0LmJvdHRvbSwgc291cmNlLmJvdHRvbSk7XHJcblxyXG4gICAgdGFyZ2V0LnkgPSBtaW5ZO1xyXG4gICAgdGFyZ2V0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmdlUmVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBNZXJnZVhZID0gZnVuY3Rpb24gKHRhcmdldCwgeCwgeSlcclxue1xyXG4gICAgdmFyIG1pblggPSBNYXRoLm1pbih0YXJnZXQueCwgeCk7XHJcbiAgICB2YXIgbWF4WCA9IE1hdGgubWF4KHRhcmdldC5yaWdodCwgeCk7XHJcblxyXG4gICAgdGFyZ2V0LnggPSBtaW5YO1xyXG4gICAgdGFyZ2V0LndpZHRoID0gbWF4WCAtIG1pblg7XHJcblxyXG4gICAgdmFyIG1pblkgPSBNYXRoLm1pbih0YXJnZXQueSwgeSk7XHJcbiAgICB2YXIgbWF4WSA9IE1hdGgubWF4KHRhcmdldC5ib3R0b20sIHkpO1xyXG5cclxuICAgIHRhcmdldC55ID0gbWluWTtcclxuICAgIHRhcmdldC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVhZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVhZLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldCA9IGZ1bmN0aW9uIChyZWN0LCB4LCB5KVxyXG57XHJcbiAgICByZWN0LnggKz0geDtcclxuICAgIHJlY3QueSArPSB5O1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL09mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMzQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXRQb2ludCA9IGZ1bmN0aW9uIChyZWN0LCBwb2ludClcclxue1xyXG4gICAgcmVjdC54ICs9IHBvaW50Lng7XHJcbiAgICByZWN0LnkgKz0gcG9pbnQueTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0UG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL09mZnNldFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE92ZXJsYXBzID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qilcclxue1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICByZWN0QS54IDwgcmVjdEIucmlnaHQgJiYgXHJcbiAgICAgICAgcmVjdEEucmlnaHQgPiByZWN0Qi54ICYmIFxyXG4gICAgICAgIHJlY3RBLnkgPCByZWN0Qi5ib3R0b20gJiYgXHJcbiAgICAgICAgcmVjdEEuYm90dG9tID4gcmVjdEIueVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxhcHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL092ZXJsYXBzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBlcmltZXRlciA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZXR1cm4gMiAqIChyZWN0LndpZHRoICsgcmVjdC5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJpbWV0ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL1BlcmltZXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKHJlY3QsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgb3V0LnggPSByZWN0LnggKyAoTWF0aC5yYW5kb20oKSAqIHJlY3Qud2lkdGgpO1xyXG4gICAgb3V0LnkgPSByZWN0LnkgKyAoTWF0aC5yYW5kb20oKSAqIHJlY3QuaGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMzUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL1JhbmRvbS5qcyIsIi8qKlxyXG4qIFNjYWxlcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGlzIFJlY3RhbmdsZSBieSB0aGUgZ2l2ZW4gYW1vdW50cy5cclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5SZWN0YW5nbGUjc2NhbGVcclxuKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBhbW91bnQgdG8gc2NhbGUgdGhlIHdpZHRoIG9mIHRoZSBSZWN0YW5nbGUgYnkuIEEgdmFsdWUgb2YgMC41IHdvdWxkIHJlZHVjZSBieSBoYWxmLCBhIHZhbHVlIG9mIDIgd291bGQgZG91YmxlIHRoZSB3aWR0aCwgZXRjLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBUaGUgYW1vdW50IHRvIHNjYWxlIHRoZSBoZWlnaHQgb2YgdGhlIFJlY3RhbmdsZSBieS4gQSB2YWx1ZSBvZiAwLjUgd291bGQgcmVkdWNlIGJ5IGhhbGYsIGEgdmFsdWUgb2YgMiB3b3VsZCBkb3VibGUgdGhlIGhlaWdodCwgZXRjLlxyXG4qIEByZXR1cm4ge1BoYXNlci5SZWN0YW5nbGV9IFRoaXMgUmVjdGFuZ2xlIG9iamVjdFxyXG4qL1xyXG52YXIgU2NhbGUgPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcclxue1xyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgIHJlY3Qud2lkdGggKj0geDtcclxuICAgIHJlY3QuaGVpZ2h0ICo9IHk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9TY2FsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xyXG5cclxudmFyIFVuaW9uID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qiwgb3V0cHV0KVxyXG57XHJcbiAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHsgb3V0cHV0ID0gUmVjdGFuZ2xlKCk7IH1cclxuXHJcbiAgICB2YXIgeCA9IE1hdGgubWluKHJlY3RBLngsIHJlY3RCLngpO1xyXG4gICAgdmFyIHkgPSBNYXRoLm1pbihyZWN0QS55LCByZWN0Qi55KTtcclxuXHJcbiAgICByZXR1cm4gb3V0cHV0LnNldChcclxuICAgICAgICB4LFxyXG4gICAgICAgIHksXHJcbiAgICAgICAgTWF0aC5tYXgocmVjdEEucmlnaHQsIHJlY3RCLnJpZ2h0KSAtIHgsXHJcbiAgICAgICAgTWF0aC5tYXgocmVjdEEuYm90dG9tLCByZWN0Qi5ib3R0b20pIC0geVxyXG4gICAgKTtcclxuICAgIFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVbmlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvVW5pb24uanNcbi8vIG1vZHVsZSBpZCA9IDM1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3JlY3RhbmdsZS9Vbmlvbi5qcyIsIi8vICBQaGFzZXIuR2VvbS5SZWN0YW5nbGVcclxuXHJcbnZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xyXG5cclxuUmVjdGFuZ2xlLkFyZWEgPSByZXF1aXJlKCcuL0FyZWEnKTtcclxuUmVjdGFuZ2xlLkNlaWwgPSByZXF1aXJlKCcuL0NlaWwnKTtcclxuUmVjdGFuZ2xlLkNlaWxBbGwgPSByZXF1aXJlKCcuL0NlaWxBbGwnKTtcclxuUmVjdGFuZ2xlLkNlbnRlck9uID0gcmVxdWlyZSgnLi9DZW50ZXJPbicpO1xyXG5SZWN0YW5nbGUuQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcblJlY3RhbmdsZS5Db250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuUmVjdGFuZ2xlLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcclxuUmVjdGFuZ2xlLkNvbnRhaW5zUmVjdCA9IHJlcXVpcmUoJy4vQ29udGFpbnNSZWN0Jyk7XHJcblJlY3RhbmdsZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcclxuUmVjdGFuZ2xlLkVxdWFscyA9IHJlcXVpcmUoJy4vRXF1YWxzJyk7XHJcblJlY3RhbmdsZS5GaXRJbnNpZGUgPSByZXF1aXJlKCcuL0ZpdEluc2lkZScpO1xyXG5SZWN0YW5nbGUuRml0T3V0c2lkZSA9IHJlcXVpcmUoJy4vRml0T3V0c2lkZScpO1xyXG5SZWN0YW5nbGUuRmxvb3IgPSByZXF1aXJlKCcuL0Zsb29yJyk7XHJcblJlY3RhbmdsZS5GbG9vckFsbCA9IHJlcXVpcmUoJy4vRmxvb3JBbGwnKTtcclxuUmVjdGFuZ2xlLkdldEFzcGVjdFJhdGlvID0gcmVxdWlyZSgnLi9HZXRBc3BlY3RSYXRpbycpO1xyXG5SZWN0YW5nbGUuR2V0Q2VudGVyID0gcmVxdWlyZSgnLi9HZXRDZW50ZXInKTtcclxuUmVjdGFuZ2xlLkdldFNpemUgPSByZXF1aXJlKCcuL0dldFNpemUnKTtcclxuUmVjdGFuZ2xlLkluZmxhdGUgPSByZXF1aXJlKCcuL0luZmxhdGUnKTtcclxuUmVjdGFuZ2xlLk1lcmdlUG9pbnRzID0gcmVxdWlyZSgnLi9NZXJnZVBvaW50cycpO1xyXG5SZWN0YW5nbGUuTWVyZ2VSZWN0ID0gcmVxdWlyZSgnLi9NZXJnZVJlY3QnKTtcclxuUmVjdGFuZ2xlLk1lcmdlWFkgPSByZXF1aXJlKCcuL01lcmdlWFknKTtcclxuUmVjdGFuZ2xlLk9mZnNldCA9IHJlcXVpcmUoJy4vT2Zmc2V0Jyk7XHJcblJlY3RhbmdsZS5PZmZzZXRQb2ludCA9IHJlcXVpcmUoJy4vT2Zmc2V0UG9pbnQnKTtcclxuUmVjdGFuZ2xlLk92ZXJsYXBzID0gcmVxdWlyZSgnLi9PdmVybGFwcycpO1xyXG5SZWN0YW5nbGUuUGVyaW1ldGVyID0gcmVxdWlyZSgnLi9QZXJpbWV0ZXInKTtcclxuUmVjdGFuZ2xlLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XHJcblJlY3RhbmdsZS5TY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKTtcclxuUmVjdGFuZ2xlLlVuaW9uID0gcmVxdWlyZSgnLi9VbmlvbicpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvaW5kZXguanMiLCIvKipcclxuKiBUYWtlcyB0aGUgYXZlcmFnZSBvZiB0aGUgc291cmNlIGFuZCBiYWNrZHJvcCBjb2xvcnMuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kQXZlcmFnZVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBBdmVyYWdlID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoYSArIGIpIC8gMjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXZlcmFnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9BdmVyYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU3VidHJhY3RzIHRoZSBkYXJrZXIgb2YgdGhlIHR3byBjb25zdGl0dWVudCBjb2xvcnMgZnJvbSB0aGUgbGlnaHRlci5cclxuKiBcclxuKiBQYWludGluZyB3aXRoIHdoaXRlIGludmVydHMgdGhlIGJhY2tkcm9wIGNvbG9yOyBwYWludGluZyB3aXRoIGJsYWNrIHByb2R1Y2VzIG5vIGNoYW5nZS4gXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kRGlmZmVyZW5jZVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBEaWZmZXJlbmNlID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmFicyhhIC0gYik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpZmZlcmVuY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvRGlmZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMzU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFByb2R1Y2VzIGFuIGVmZmVjdCBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIERpZmZlcmVuY2UgbW9kZSwgYnV0IGxvd2VyIGluIGNvbnRyYXN0LiBcclxuKiBQYWludGluZyB3aXRoIHdoaXRlIGludmVydHMgdGhlIGJhY2tkcm9wIGNvbG9yOyBwYWludGluZyB3aXRoIGJsYWNrIHByb2R1Y2VzIG5vIGNoYW5nZS4gXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kRXhjbHVzaW9uXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIEV4Y2x1c2lvbiA9ICBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIGEgKyBiIC0gMiAqIGEgKiBiIC8gMjU1O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFeGNsdXNpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvRXhjbHVzaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlZmxlY3QgPSByZXF1aXJlKCcuL1JlZmxlY3QnKTtcclxuXHJcbi8qKlxyXG4qIEdsb3cgYmxlbmQgbW9kZS4gVGhpcyBtb2RlIGlzIGEgdmFyaWF0aW9uIG9mIHJlZmxlY3QgbW9kZSB3aXRoIHRoZSBzb3VyY2UgYW5kIGJhY2tkcm9wIGNvbG9ycyBzd2FwcGVkLlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZEdsb3dcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgR2xvdyA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gUmVmbGVjdChiLCBhKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2xvdztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9HbG93LmpzXG4vLyBtb2R1bGUgaWQgPSAzNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9HbG93LmpzIiwidmFyIE92ZXJsYXkgPSByZXF1aXJlKCcuL092ZXJsYXknKTtcclxuXHJcbi8qKlxyXG4qIE11bHRpcGxpZXMgb3Igc2NyZWVucyB0aGUgY29sb3JzLCBkZXBlbmRpbmcgb24gdGhlIHNvdXJjZSBjb2xvciB2YWx1ZS4gXHJcbiogXHJcbiogSWYgdGhlIHNvdXJjZSBjb2xvciBpcyBsaWdodGVyIHRoYW4gMC41LCB0aGUgYmFja2Ryb3AgaXMgbGlnaHRlbmVkLCBhcyBpZiBpdCB3ZXJlIHNjcmVlbmVkOyBcclxuKiB0aGlzIGlzIHVzZWZ1bCBmb3IgYWRkaW5nIGhpZ2hsaWdodHMgdG8gYSBzY2VuZS4gXHJcbiogXHJcbiogSWYgdGhlIHNvdXJjZSBjb2xvciBpcyBkYXJrZXIgdGhhbiAwLjUsIHRoZSBiYWNrZHJvcCBpcyBkYXJrZW5lZCwgYXMgaWYgaXQgd2VyZSBtdWx0aXBsaWVkOyBcclxuKiB0aGlzIGlzIHVzZWZ1bCBmb3IgYWRkaW5nIHNoYWRvd3MgdG8gYSBzY2VuZS4gXHJcbiogXHJcbiogVGhlIGRlZ3JlZSBvZiBsaWdodGVuaW5nIG9yIGRhcmtlbmluZyBpcyBwcm9wb3J0aW9uYWwgdG8gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGNvbG9yIGFuZCAwLjU7IFxyXG4qIGlmIGl0IGlzIGVxdWFsIHRvIDAuNSwgdGhlIGJhY2tkcm9wIGlzIHVuY2hhbmdlZC5cclxuKiBcclxuKiBQYWludGluZyB3aXRoIHB1cmUgYmxhY2sgb3Igd2hpdGUgcHJvZHVjZXMgcHVyZSBibGFjayBvciB3aGl0ZS4gVGhlIGVmZmVjdCBpcyBzaW1pbGFyIHRvIHNoaW5pbmcgYSBoYXJzaCBzcG90bGlnaHQgb24gdGhlIGJhY2tkcm9wLiBcclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRIYXJkTGlnaHRcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgSGFyZExpZ2h0ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBPdmVybGF5KGIsIGEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYXJkTGlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvSGFyZExpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9IYXJkTGlnaHQuanMiLCJ2YXIgVml2aWRMaWdodCA9IHJlcXVpcmUoJy4vVml2aWRMaWdodCcpO1xyXG5cclxuLyoqXHJcbiogUnVucyBibGVuZFZpdmlkTGlnaHQgb24gdGhlIHNvdXJjZSBhbmQgYmFja2Ryb3AgY29sb3JzLlxyXG4qIElmIHRoZSByZXN1bHRpbmcgY29sb3IgaXMgMTI4IG9yIG1vcmUsIGl0IHJlY2VpdmVzIGEgdmFsdWUgb2YgMjU1OyBpZiBsZXNzIHRoYW4gMTI4LCBhIHZhbHVlIG9mIDAuXHJcbiogVGhlcmVmb3JlLCBhbGwgYmxlbmRlZCBwaXhlbHMgaGF2ZSByZWQsIGdyZWVuLCBhbmQgYmx1ZSBjaGFubmVsIHZhbHVlcyBvZiBlaXRoZXIgMCBvciAyNTUuXHJcbiogVGhpcyBjaGFuZ2VzIGFsbCBwaXhlbHMgdG8gcHJpbWFyeSBhZGRpdGl2ZSBjb2xvcnMgKHJlZCwgZ3JlZW4sIG9yIGJsdWUpLCB3aGl0ZSwgb3IgYmxhY2suXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kSGFyZE1peFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBIYXJkTWl4ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoVml2aWRMaWdodChhLCBiKSA8IDEyOCkgPyAwIDogMjU1O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYXJkTWl4O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0hhcmRNaXguanNcbi8vIG1vZHVsZSBpZCA9IDM1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9ibGVuZG1vZGVzL0hhcmRNaXguanMiLCJ2YXIgTGluZWFyQnVybiA9IHJlcXVpcmUoJy4vTGluZWFyQnVybicpO1xyXG52YXIgTGluZWFyRG9kZ2UgPSByZXF1aXJlKCcuL0xpbmVhckRvZGdlJyk7XHJcblxyXG4vKipcclxuKiBUaGlzIGJsZW5kIG1vZGUgY29tYmluZXMgTGluZWFyIERvZGdlIGFuZCBMaW5lYXIgQnVybiAocmVzY2FsZWQgc28gdGhhdCBuZXV0cmFsIGNvbG9ycyBiZWNvbWUgbWlkZGxlIGdyYXkpLlxyXG4qIERvZGdlIGFwcGxpZXMgdG8gdmFsdWVzIG9mIHRvcCBsYXllciBsaWdodGVyIHRoYW4gbWlkZGxlIGdyYXksIGFuZCBidXJuIHRvIGRhcmtlciB2YWx1ZXMuXHJcbiogVGhlIGNhbGN1bGF0aW9uIHNpbXBsaWZpZXMgdG8gdGhlIHN1bSBvZiBib3R0b20gbGF5ZXIgYW5kIHR3aWNlIHRoZSB0b3AgbGF5ZXIsIHN1YnRyYWN0IDEyOC4gVGhlIGNvbnRyYXN0IGRlY3JlYXNlcy5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRMaW5lYXJMaWdodFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBMaW5lYXJMaWdodCA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGIgPCAxMjgpID8gTGluZWFyQnVybihhLCAyICogYikgOiBMaW5lYXJEb2RnZShhLCAoMiAqIChiIC0gMTI4KSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJMaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaW5lYXJMaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMzYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyTGlnaHQuanMiLCIvKipcclxuKiBNdWx0aXBsaWVzIHRoZSBiYWNrZHJvcCBhbmQgc291cmNlIGNvbG9yIHZhbHVlcy5cclxuKiBUaGUgcmVzdWx0IGNvbG9yIGlzIGFsd2F5cyBhdCBsZWFzdCBhcyBkYXJrIGFzIGVpdGhlciBvZiB0aGUgdHdvIGNvbnN0aXR1ZW50XHJcbiogY29sb3JzLiBNdWx0aXBseWluZyBhbnkgY29sb3Igd2l0aCBibGFjayBwcm9kdWNlcyBibGFjaztcclxuKiBtdWx0aXBseWluZyB3aXRoIHdoaXRlIGxlYXZlcyB0aGUgb3JpZ2luYWwgY29sb3IgdW5jaGFuZ2VkLlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZE11bHRpcGx5XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIE11bHRpcGx5ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoYSAqIGIpIC8gMjU1O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aXBseTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9NdWx0aXBseS5qc1xuLy8gbW9kdWxlIGlkID0gMzYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIE5lZ2F0aW9uIGJsZW5kIG1vZGUuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kTmVnYXRpb25cclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgTmVnYXRpb24gPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIDI1NSAtIE1hdGguYWJzKDI1NSAtIGEgLSBiKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTmVnYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTmVnYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBCbGVuZHMgdGhlIHNvdXJjZSBjb2xvciwgaWdub3JpbmcgdGhlIGJhY2tkcm9wLlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZE5vcm1hbFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBOb3JtYWwgPSBmdW5jdGlvbiAoYSlcclxue1xyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9Ob3JtYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBQaG9lbml4IGJsZW5kIG1vZGUuIFRoaXMgc3VidHJhY3RzIHRoZSBsaWdodGVyIGNvbG9yIGZyb20gdGhlIGRhcmtlciBjb2xvciwgYW5kIGFkZHMgMjU1LCBnaXZpbmcgYSBicmlnaHQgcmVzdWx0LlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZFBob2VuaXhcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgUGhvZW5peCA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5taW4oYSwgYikgLSBNYXRoLm1heChhLCBiKSArIDI1NTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGhvZW5peDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9QaG9lbml4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERhcmtlbiA9IHJlcXVpcmUoJy4vRGFya2VuJyk7XHJcbnZhciBMaWdodGVuID0gcmVxdWlyZSgnLi9MaWdodGVuJyk7XHJcblxyXG4vKipcclxuKiBJZiB0aGUgYmFja2Ryb3AgY29sb3IgKGxpZ2h0IHNvdXJjZSkgaXMgbGlnaHRlciB0aGFuIDUwJSwgdGhlIGJsZW5kRGFya2VuIG1vZGUgaXMgdXNlZCwgYW5kIGNvbG9ycyBsaWdodGVyIHRoYW4gdGhlIGJhY2tkcm9wIGNvbG9yIGRvIG5vdCBjaGFuZ2UuXHJcbiogSWYgdGhlIGJhY2tkcm9wIGNvbG9yIGlzIGRhcmtlciB0aGFuIDUwJSBncmF5LCBjb2xvcnMgbGlnaHRlciB0aGFuIHRoZSBibGVuZCBjb2xvciBhcmUgcmVwbGFjZWQsIGFuZCBjb2xvcnMgZGFya2VyIHRoYW4gdGhlIGJsZW5kIGNvbG9yIGRvIG5vdCBjaGFuZ2UuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kUGluTGlnaHRcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgUGluTGlnaHQgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiIDwgMTI4KSA/IERhcmtlbihhLCAyICogYikgOiBMaWdodGVuKGEsICgyICogKGIgLSAxMjgpKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBpbkxpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL1BpbkxpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9QaW5MaWdodC5qcyIsIi8qKlxyXG4qIE11bHRpcGxpZXMgdGhlIGNvbXBsZW1lbnRzIG9mIHRoZSBiYWNrZHJvcCBhbmQgc291cmNlIGNvbG9yIHZhbHVlcywgdGhlbiBjb21wbGVtZW50cyB0aGUgcmVzdWx0LlxyXG4qIFRoZSByZXN1bHQgY29sb3IgaXMgYWx3YXlzIGF0IGxlYXN0IGFzIGxpZ2h0IGFzIGVpdGhlciBvZiB0aGUgdHdvIGNvbnN0aXR1ZW50IGNvbG9ycy4gXHJcbiogU2NyZWVuaW5nIGFueSBjb2xvciB3aXRoIHdoaXRlIHByb2R1Y2VzIHdoaXRlOyBzY3JlZW5pbmcgd2l0aCBibGFjayBsZWF2ZXMgdGhlIG9yaWdpbmFsIGNvbG9yIHVuY2hhbmdlZC4gXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kU2NyZWVuXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIFNjcmVlbiA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gMjU1IC0gKCgoMjU1IC0gYSkgKiAoMjU1IC0gYikpID4+IDgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTY3JlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvU2NyZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogRGFya2VucyBvciBsaWdodGVucyB0aGUgY29sb3JzLCBkZXBlbmRpbmcgb24gdGhlIHNvdXJjZSBjb2xvciB2YWx1ZS4gXHJcbiogXHJcbiogSWYgdGhlIHNvdXJjZSBjb2xvciBpcyBsaWdodGVyIHRoYW4gMC41LCB0aGUgYmFja2Ryb3AgaXMgbGlnaHRlbmVkLCBhcyBpZiBpdCB3ZXJlIGRvZGdlZDsgXHJcbiogdGhpcyBpcyB1c2VmdWwgZm9yIGFkZGluZyBoaWdobGlnaHRzIHRvIGEgc2NlbmUuIFxyXG4qIFxyXG4qIElmIHRoZSBzb3VyY2UgY29sb3IgaXMgZGFya2VyIHRoYW4gMC41LCB0aGUgYmFja2Ryb3AgaXMgZGFya2VuZWQsIGFzIGlmIGl0IHdlcmUgYnVybmVkIGluLiBcclxuKiBUaGUgZGVncmVlIG9mIGxpZ2h0ZW5pbmcgb3IgZGFya2VuaW5nIGlzIHByb3BvcnRpb25hbCB0byB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgY29sb3IgYW5kIDAuNTsgXHJcbiogaWYgaXQgaXMgZXF1YWwgdG8gMC41LCB0aGUgYmFja2Ryb3AgaXMgdW5jaGFuZ2VkLlxyXG4qIFxyXG4qIFBhaW50aW5nIHdpdGggcHVyZSBibGFjayBvciB3aGl0ZSBwcm9kdWNlcyBhIGRpc3RpbmN0bHkgZGFya2VyIG9yIGxpZ2h0ZXIgYXJlYSwgYnV0IGRvZXMgbm90IHJlc3VsdCBpbiBwdXJlIGJsYWNrIG9yIHdoaXRlLiBcclxuKiBUaGUgZWZmZWN0IGlzIHNpbWlsYXIgdG8gc2hpbmluZyBhIGRpZmZ1c2VkIHNwb3RsaWdodCBvbiB0aGUgYmFja2Ryb3AuIFxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZFNvZnRMaWdodFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBTb2Z0TGlnaHQgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiIDwgMTI4KSA/ICgyICogKChhID4+IDEpICsgNjQpKSAqIChiIC8gMjU1KSA6IDI1NSAtICgyICogKDI1NSAtICgoYSA+PiAxKSArIDY0KSkgKiAoMjU1IC0gYikgLyAyNTUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTb2Z0TGlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvU29mdExpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HcmFwaGljcy5CbGVuZE1vZGVzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBBZGQ6IHJlcXVpcmUoJy4vQWRkJyksXHJcbiAgICBBdmVyYWdlOiByZXF1aXJlKCcuL0F2ZXJhZ2UnKSxcclxuICAgIENvbG9yQnVybjogcmVxdWlyZSgnLi9Db2xvckJ1cm4nKSxcclxuICAgIENvbG9yRG9kZ2U6IHJlcXVpcmUoJy4vQ29sb3JEb2RnZScpLFxyXG4gICAgRGFya2VuOiByZXF1aXJlKCcuL0RhcmtlbicpLFxyXG4gICAgRGlmZmVyZW5jZTogcmVxdWlyZSgnLi9EaWZmZXJlbmNlJyksXHJcbiAgICBFeGNsdXNpb246IHJlcXVpcmUoJy4vRXhjbHVzaW9uJyksXHJcbiAgICBHbG93OiByZXF1aXJlKCcuL0dsb3cnKSxcclxuICAgIEhhcmRMaWdodDogcmVxdWlyZSgnLi9IYXJkTGlnaHQnKSxcclxuICAgIEhhcmRNaXg6IHJlcXVpcmUoJy4vSGFyZE1peCcpLFxyXG4gICAgTGlnaHRlbjogcmVxdWlyZSgnLi9MaWdodGVuJyksXHJcbiAgICBMaW5lYXJCdXJuOiByZXF1aXJlKCcuL0xpbmVhckJ1cm4nKSxcclxuICAgIExpbmVhckRvZGdlOiByZXF1aXJlKCcuL0xpbmVhckRvZGdlJyksXHJcbiAgICBMaW5lYXJMaWdodDogcmVxdWlyZSgnLi9MaW5lYXJMaWdodCcpLFxyXG4gICAgTXVsdGlwbHk6IHJlcXVpcmUoJy4vTXVsdGlwbHknKSxcclxuICAgIE5lZ2F0aW9uOiByZXF1aXJlKCcuL05lZ2F0aW9uJyksXHJcbiAgICBOb3JtYWw6IHJlcXVpcmUoJy4vTm9ybWFsJyksXHJcbiAgICBPdmVybGF5OiByZXF1aXJlKCcuL092ZXJsYXknKSxcclxuICAgIFBob2VuaXg6IHJlcXVpcmUoJy4vUGhvZW5peCcpLFxyXG4gICAgUGluTGlnaHQ6IHJlcXVpcmUoJy4vUGluTGlnaHQnKSxcclxuICAgIFJlZmxlY3Q6IHJlcXVpcmUoJy4vUmVmbGVjdCcpLFxyXG4gICAgU2NyZWVuOiByZXF1aXJlKCcuL1NjcmVlbicpLFxyXG4gICAgU29mdExpZ2h0OiByZXF1aXJlKCcuL1NvZnRMaWdodCcpLFxyXG4gICAgU3VidHJhY3Q6IHJlcXVpcmUoJy4vU3VidHJhY3QnKSxcclxuICAgIFZpdmlkTGlnaHQ6IHJlcXVpcmUoJy4vVml2aWRMaWdodCcpXHJcbiAgICBcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvaW5kZXguanMiLCJ2YXIgQ29sb3IgPSByZXF1aXJlKCcuL0NvbG9yJyk7XHJcblxyXG52YXIgQ1NTTWFwID0ge1xyXG4gICAgYWxpY2VibHVlOiBbIDI0MCwgMjQ4LCAyNDUgXSxcclxuICAgIGFudGlxdWV3aGl0ZTogWyAyNTAsIDIzNSwgMjE1IF0sXHJcbiAgICBhcXVhOiBbIDAsIDI1NSwgMjU1IF0sXHJcbiAgICBhcXVhbWFyaW5lOiBbIDEyNywgMjU1LCAyMTIgXSxcclxuICAgIGF6dXJlOiBbIDI0MCwgMjU1LCAyNTUgXSxcclxuICAgIGJlaWdlOiBbIDI0NSwgMjQ1LCAyMjAgXSxcclxuICAgIGJpc3F1ZTogWyAyNTUsIDIyOCwgMTk2IF0sXHJcbiAgICBibGFjazogWyAwLCAwLCAwIF0sXHJcbiAgICBibGFuY2hlZGFsbW9uZDogWyAyNTUsIDIzNSwgMjA1IF0sXHJcbiAgICBibHVlOiBbIDAsIDAsIDI1NSBdLFxyXG4gICAgYmx1ZXZpb2xldDogWyAxMzgsIDQzLCAyMjYgXSxcclxuICAgIGJyb3duOiBbIDE2NSwgNDIsIDQyIF0sXHJcbiAgICBidXJseXdvb2Q6IFsgMjIyLCAxODQsIDM1IF0sXHJcbiAgICBjYWRldGJsdWU6IFsgOTUsIDE1OCwgMTYwIF0sXHJcbiAgICBjaGFydHJldXNlOiBbIDEyNywgMjU1LCAwIF0sXHJcbiAgICBjaG9jb2xhdGU6IFsgMjEwLCAxMDUsIDMwIF0sXHJcbiAgICBjb3JhbDogWyAyNTUsIDEyNywgODAgXSxcclxuICAgIGNvcm5mbG93ZXJibHVlOiBbIDEwMCwgMTQ5LCAyMzcgXSxcclxuICAgIGNvcm5zaWxrOiBbIDI1NSwgMjQ4LCAyMjAgXSxcclxuICAgIGNyaW1zb246IFsgMjIwLCAyMCwgNjAgXSxcclxuICAgIGRhcmtibHVlOiBbIDAsIDAsIDEzOSBdLFxyXG4gICAgZGFya2N5YW46IFsgMCwgMTM5LCAxMzkgXSxcclxuICAgIGRhcmtnb2xkZW5yb2Q6IFsgMTg0LCAxMzQsIDExIF0sXHJcbiAgICBkYXJrZ3JheTogWyAxNjksIDE2OSwgMTY5IF0sXHJcbiAgICBkYXJrZ3JlZW46IFsgMCwgMTAwLCAwIF0sXHJcbiAgICBkYXJrZ3JleTogWyAxNjksIDE2OSwgMTY5IF0sXHJcbiAgICBkYXJra2hha2k6IFsgMTg5LCAxODMsIDEwNyBdLFxyXG4gICAgZGFya21hZ2VudGE6IFsgMTM5LCAwLCAxMzkgXSxcclxuICAgIGRhcmtvbGl2ZWdyZWVuOiBbIDg1LCAxMDcsIDQ3IF0sXHJcbiAgICBkYXJrb3JhbmdlOiBbIDI1NSwgMTQwLCAwIF0sXHJcbiAgICBkYXJrb3JjaGlkOiBbIDE1MywgNTAsIDIwNCBdLFxyXG4gICAgZGFya3JlZDogWyAxMzksIDAsIDAgXSxcclxuICAgIGRhcmtzYWxtb246IFsgMjMzLCAxNTAsIDEyMiBdLFxyXG4gICAgZGFya3NlYWdyZWVuOiBbIDE0MywgMTg4LCAxNDMgXSxcclxuICAgIGRhcmtzbGF0ZWJsdWU6IFsgNzIsIDYxLCAxMzkgXSxcclxuICAgIGRhcmtzbGF0ZWdyYXk6IFsgNDcsIDc5LCA3OSBdLFxyXG4gICAgZGFya3NsYXRlZ3JleTogWyA0NywgNzksIDc5IF0sXHJcbiAgICBkYXJrdHVycXVvaXNlOiBbIDAsIDIwNiwgMjA5IF0sXHJcbiAgICBkYXJrdmlvbGV0OiBbIDE0OCwgMCwgMjExIF0sXHJcbiAgICBkZWVwcGluazogWyAyNTUsIDIwLCAxNDcgXSxcclxuICAgIGRlZXBza3libHVlOiBbIDAsIDE5MSwgMjU1IF0sXHJcbiAgICBkaW1ncmF5OiBbIDEwNSwgMTA1LCAxMDUgXSxcclxuICAgIGRpbWdyZXk6IFsgMTA1LCAxMDUsIDEwNSBdLFxyXG4gICAgZG9kZ2VyYmx1ZTogWyAzMCwgMTQ0LCAyNTUgXSxcclxuICAgIGZpcmVicmljazogWyAxNzgsIDM0LCAzNCBdLFxyXG4gICAgZmxvcmFsd2hpdGU6IFsgMjU1LCAyNTAsIDI0MCBdLFxyXG4gICAgZm9yZXN0Z3JlZW46IFsgMzQsIDEzOSwgMzQgXSxcclxuICAgIGZ1Y2hzaWE6IFsgMjU1LCAwLCAyNTUgXSxcclxuICAgIGdhaW5zYm9ybzogWyAyMjAsIDIyMCwgMjIwIF0sXHJcbiAgICBnaG9zdHdoaXRlOiBbIDI0OCwgMjQ4LCAyNTUgXSxcclxuICAgIGdvbGQ6IFsgMjU1LCAyMTUsIDAgXSxcclxuICAgIGdvbGRlbnJvZDogWyAyMTgsIDE2NSwgMzIgXSxcclxuICAgIGdyYXk6IFsgMTI4LCAxMjgsIDEyOCBdLFxyXG4gICAgZ3JlZW46IFsgMCwgMTI4LCAwIF0sXHJcbiAgICBncmVlbnllbGxvdzogWyAxNzMsIDI1NSwgNDcgXSxcclxuICAgIGdyZXk6IFsgMTI4LCAxMjgsIDEyOCBdLFxyXG4gICAgaG9uZXlkZXc6IFsgMjQwLCAyNTUsIDI0MCBdLFxyXG4gICAgaG90cGluazogWyAyNTUsIDEwNSwgMTgwIF0sXHJcbiAgICBpbmRpYW5yZWQ6IFsgMjA1LCA5MiwgOTIgXSxcclxuICAgIGluZGlnbzogWyA3NSwgMCwgMTMwIF0sXHJcbiAgICBpdm9yeTogWyAyNTUsIDI1NSwgMjQwIF0sXHJcbiAgICBraGFraTogWyAyNDAsIDIzMCwgMTQwIF0sXHJcbiAgICBsYXZlbmRlcjogWyAyMzAsIDIzMCwgMjUwIF0sXHJcbiAgICBsYXZlbmRlcmJsdXNoOiBbIDI1NSwgMjQwLCAyNDUgXSxcclxuICAgIGxhd25ncmVlbjogWyAxMjQsIDI1MiwgMCBdLFxyXG4gICAgbGVtb25jaGlmZm9uOiBbIDI1NSwgMjUwLCAyMDUgXSxcclxuICAgIGxpZ2h0Ymx1ZTogWyAxNzMsIDIxNiwgMjMwIF0sXHJcbiAgICBsaWdodGNvcmFsOiBbIDI0MCwgMTI4LCAxMjggXSxcclxuICAgIGxpZ2h0Y3lhbjogWyAyMjQsIDI1NSwgMjU1IF0sXHJcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogWyAyNTAsIDI1MCwgMjEwIF0sXHJcbiAgICBsaWdodGdyYXk6IFsgMjExLCAyMTEsIDIxMSBdLFxyXG4gICAgbGlnaHRncmVlbjogWyAxNDQsIDIzOCwgMTQ0IF0sXHJcbiAgICBsaWdodGdyZXk6IFsgMjExLCAyMTEsIDIxMSBdLFxyXG4gICAgbGlnaHRwaW5rOiBbIDI1NSwgMTgyLCAxOTMgXSxcclxuICAgIGxpZ2h0c2FsbW9uOiBbIDI1NSwgMTYwLCAxMjIgXSxcclxuICAgIGxpZ2h0c2VhZ3JlZW46IFsgMzIsIDE3OCwgMTcwIF0sXHJcbiAgICBsaWdodHNreWJsdWU6IFsgMTM1LCAyMDYsIDI1MCBdLFxyXG4gICAgbGlnaHRzbGF0ZWdyYXk6IFsgMTE5LCAxMzYsIDE1MyBdLFxyXG4gICAgbGlnaHRzbGF0ZWdyZXk6IFsgMTE5LCAxMzYsIDE1MyBdLFxyXG4gICAgbGlnaHRzdGVlbGJsdWU6IFsgMTc2LCAxOTYsIDIyMiBdLFxyXG4gICAgbGlnaHR5ZWxsb3c6IFsgMjU1LCAyNTUsIDIyNCBdLFxyXG4gICAgbGltZTogWyAwLCAyNTUsIDAgXSxcclxuICAgIGxpbWVncmVlbjogWyA1MCwgMjA1LCA1MCBdLFxyXG4gICAgbGluZW46IFsgMjUwLCAyNDAsIDIzMCBdLFxyXG4gICAgbWFyb29uOiBbIDEyOCwgMCwgMCBdLFxyXG4gICAgbWVkaXVtYXF1YW1hcmluZTogWyAxMDIsIDIwNSwgMTcwIF0sXHJcbiAgICBtZWRpdW1ibHVlOiBbIDAsIDAsIDIwNSBdLFxyXG4gICAgbWVkaXVtb3JjaGlkOiBbIDE4NiwgODUsIDIxMSBdLFxyXG4gICAgbWVkaXVtcHVycGxlOiBbIDE0NywgMTEyLCAyMTkgXSxcclxuICAgIG1lZGl1bXNlYWdyZWVuOiBbIDYwLCAxNzksIDExMyBdLFxyXG4gICAgbWVkaXVtc2xhdGVibHVlOiBbIDEyMywgMTA0LCAyMzggXSxcclxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiBbIDAsIDI1MCwgMTU0IF0sXHJcbiAgICBtZWRpdW10dXJxdW9pc2U6IFsgNzIsIDIwOSwgMjA0IF0sXHJcbiAgICBtZWRpdW12aW9sZXRyZWQ6IFsgMTk5LCAyMSwgMTMzIF0sXHJcbiAgICBtaWRuaWdodGJsdWU6IFsgMjUsIDI1LCAxMTIgXSxcclxuICAgIG1pbnRjcmVhbTogWyAyNDUsIDI1NSwgMjUwIF0sXHJcbiAgICBtaXN0eXJvc2U6IFsgMjU1LCAyMjgsIDIyNSBdLFxyXG4gICAgbW9jY2FzaW46IFsgMjU1LCAyMjgsIDE4MSBdLFxyXG4gICAgbmF2YWpvd2hpdGU6IFsgMjU1LCAyMjIsIDE3MyBdLFxyXG4gICAgbmF2eTogWyAwLCAwLCAxMjggXSxcclxuICAgIG9sZGxhY2U6IFsgMjUzLCAyNDUsIDIzMCBdLFxyXG4gICAgb2xpdmU6IFsgMTI4LCAxMjgsIDAgXSxcclxuICAgIG9saXZlZHJhYjogWyAxMDcsIDE0MiwgMzUgXSxcclxuICAgIG9yYW5nZTogWyAyNTUsIDE2NSwgMCBdLFxyXG4gICAgb3JhbmdlcmVkOiBbIDI1NSwgNjksIDAgXSxcclxuICAgIG9yY2hpZDogWyAyMTgsIDExMiwgMjE0IF0sXHJcbiAgICBwYWxlZ29sZGVucm9kOiBbIDIzOCwgMjMyLCAxNzAgXSxcclxuICAgIHBhbGVncmVlbjogWyAxNTIsIDI1MSwgMTUyIF0sXHJcbiAgICBwYWxldHVycXVvaXNlOiBbIDE3NSwgMjM4LCAyMzggXSxcclxuICAgIHBhbGV2aW9sZXRyZWQ6IFsgMjE5LCAxMTIsIDE0NyBdLFxyXG4gICAgcGFwYXlhd2hpcDogWyAyNTUsIDIzOSwgMjEzIF0sXHJcbiAgICBwZWFjaHB1ZmY6IFsgMjU1LCAyMTgsIDE4NSBdLFxyXG4gICAgcGVydTogWyAyMDUsIDEzMywgNjMgXSxcclxuICAgIHBpbms6IFsgMjU1LCAxOTIsIDIwMyBdLFxyXG4gICAgcGx1bTogWyAyMjEsIDE2MCwgMjIxIF0sXHJcbiAgICBwb3dkZXJibHVlOiBbIDE3NiwgMjI0LCAyMzAgXSxcclxuICAgIHB1cnBsZTogWyAxMjgsIDAsIDEyOCBdLFxyXG4gICAgcmViZWNjYXB1cnBsZTogWyAxMDIsIDUxLCAxNTMgXSxcclxuICAgIHJlZDogWyAyNTUsIDAsIDAgXSxcclxuICAgIHJvc3licm93bjogWyAxODgsIDE0MywgMTQzIF0sXHJcbiAgICByb3lhbGJsdWU6IFsgNjUsIDEwNSwgMjI1IF0sXHJcbiAgICBzYWRkbGVicm93bjogWyAxMzksIDY5LCAxOSBdLFxyXG4gICAgc2FsbW9uOiBbIDI1MCwgMTI4LCAxMTQgXSxcclxuICAgIHNhbmR5YnJvd246IFsgMjQ0LCAxNjQsIDk2IF0sXHJcbiAgICBzZWFncmVlbjogWyA0NiwgMTM5LCA4NyBdLFxyXG4gICAgc2Vhc2hlbGw6IFsgMjU1LCAyNDUsIDIzOCBdLFxyXG4gICAgc2llbm5hOiBbIDE2MCwgODIsIDQ1IF0sXHJcbiAgICBzaWx2ZXI6IFsgMTkyLCAxOTIsIDEyOSBdLFxyXG4gICAgc2t5Ymx1ZTogWyAxMzUsIDIwNiwgMjM1IF0sXHJcbiAgICBzbGF0ZWJsdWU6IFsgMTA2LCA5MCwgMjA1IF0sXHJcbiAgICBzbGF0ZWdyYXk6IFsgMTEyLCAxMjgsIDE0NCBdLFxyXG4gICAgc2xhdGVncmV5OiBbIDExMiwgMTI4LCAxNDQgXSxcclxuICAgIHNub3c6IFsgMjU1LCAyNTAsIDI1MCBdLFxyXG4gICAgc3ByaW5nZ3JlZW46IFsgMCwgMjU1LCAxMjcgXSxcclxuICAgIHN0ZWVsYmx1ZTogWyA3MCwgMTMwLCAxODAgXSxcclxuICAgIHRhbjogWyAyMTAsIDE4MCwgMTQwIF0sXHJcbiAgICB0ZWFsOiBbIDAsIDEyOCwgMTI4IF0sXHJcbiAgICB0aGlzdGxlOiBbIDIxNiwgMTkxLCAyMTYgXSxcclxuICAgIHRvbWF0bzogWyAyNTUsIDk5LCA3MSBdLFxyXG4gICAgdHVycXVvaXNlOiBbIDY0LCAyMjQsIDIwOCBdLFxyXG4gICAgdmlvbGV0OiBbIDIzOCwgMTMwLCAyMzggXSxcclxuICAgIHdoZWF0OiBbIDI0NSwgMjIyLCAxNzkgXSxcclxuICAgIHdoaXRlOiBbIDI1NSwgMjU1LCAyNTUgXSxcclxuICAgIHdoaXRlc21va2U6IFsgMjQ1LCAyNDUsIDI0NSBdLFxyXG4gICAgeWVsbG93OiBbIDI1NSwgMjU1LCAwIF0sXHJcbiAgICB5ZWxsb3dncmVlbjogWyAxNTQsIDIwNSwgNTAgXVxyXG59O1xyXG5cclxudmFyIENTU1RvQ29sb3IgPSBmdW5jdGlvbiAobmFtZSlcclxue1xyXG4gICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICB2YXIgY29sb3IgPSBuZXcgQ29sb3IoKTtcclxuICAgIHZhciBlbnRyeSA9IENTU01hcFtuYW1lXTtcclxuXHJcbiAgICBpZiAoZW50cnkpXHJcbiAgICB7XHJcbiAgICAgICAgY29sb3Iuc2V0VG8oZW50cnlbMF0sIGVudHJ5WzFdLCBlbnRyeVsyXSwgMjU1KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29sb3I7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENTU1RvQ29sb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL0NTU1RvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDM2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9DU1NUb0NvbG9yLmpzIiwidmFyIENvbG9yVG9SR0JBID0gZnVuY3Rpb24gKGNvbG9yKVxyXG57XHJcbiAgICB2YXIgb3V0cHV0ID0ge1xyXG4gICAgICAgIHI6IGNvbG9yID4+IDE2ICYgMHhGRixcclxuICAgICAgICBnOiBjb2xvciA+PiA4ICYgMHhGRixcclxuICAgICAgICBiOiBjb2xvciAmIDB4RkYsXHJcbiAgICAgICAgYTogMjU1XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChjb2xvciA+IDE2Nzc3MjE1KVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5hID0gY29sb3IgPj4+IDI0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yVG9SR0JBO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9Db2xvclRvUkdCQS5qc1xuLy8gbW9kdWxlIGlkID0gMzcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3InKTtcclxudmFyIEh1ZVRvQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9IdWVUb0NvbXBvbmVudCcpO1xyXG5cclxudmFyIEhTTFRvQ29sb3IgPSBmdW5jdGlvbiAoaCwgcywgbClcclxue1xyXG4gICAgLy8gYWNocm9tYXRpYyBieSBkZWZhdWx0XHJcbiAgICB2YXIgciA9IGw7XHJcbiAgICB2YXIgZyA9IGw7XHJcbiAgICB2YXIgYiA9IGw7XHJcblxyXG4gICAgaWYgKHMgIT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHEgPSAobCA8IDAuNSkgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XHJcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XHJcblxyXG4gICAgICAgIHIgPSBIdWVUb0NvbXBvbmVudChwLCBxLCBoICsgMSAvIDMpO1xyXG4gICAgICAgIGcgPSBIdWVUb0NvbXBvbmVudChwLCBxLCBoKTtcclxuICAgICAgICBiID0gSHVlVG9Db21wb25lbnQocCwgcSwgaCAtIDEgLyAzKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29sb3IgPSBuZXcgQ29sb3IoKTtcclxuXHJcbiAgICByZXR1cm4gY29sb3Iuc2V0R0xUbyhyLCBnLCBiLCAxKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSFNMVG9Db2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvSFNMVG9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMzcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2NvbG9yL0hTTFRvQ29sb3IuanMiLCJ2YXIgSFNWVG9SR0IgPSByZXF1aXJlKCcuL0hTVlRvUkdCJyk7XHJcblxyXG4vKipcclxuKiBHZXQgSFNWIGNvbG9yIHdoZWVsIHZhbHVlcyBpbiBhbiBhcnJheSB3aGljaCB3aWxsIGJlIDM2MCBlbGVtZW50cyBpbiBzaXplLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQ29sb3IuSFNWQ29sb3JXaGVlbFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge251bWJlcn0gW3M9MV0gLSBUaGUgc2F0dXJhdGlvbiwgaW4gdGhlIHJhbmdlIDAgLSAxLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbdj0xXSAtIFRoZSB2YWx1ZSwgaW4gdGhlIHJhbmdlIDAgLSAxLlxyXG4qIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIDM2MCBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBIU1YgY29sb3Igd2hlZWwuXHJcbiovXHJcbnZhciBIU1ZDb2xvcldoZWVsID0gZnVuY3Rpb24gKHMsIHYpXHJcbntcclxuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHsgcyA9IDE7IH1cclxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHsgdiA9IDE7IH1cclxuXHJcbiAgICB2YXIgY29sb3JzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPD0gMzU5OyBjKyspXHJcbiAgICB7XHJcbiAgICAgICAgY29sb3JzLnB1c2goSFNWVG9SR0IoYyAvIDM1OSwgcywgdikpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb2xvcnM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhTVkNvbG9yV2hlZWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL0hTVkNvbG9yV2hlZWwuanNcbi8vIG1vZHVsZSBpZCA9IDM3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9IU1ZDb2xvcldoZWVsLmpzIiwidmFyIExpbmVhciA9IHJlcXVpcmUoJy4uLy4uL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uJyk7XHJcblxyXG52YXIgUkdCV2l0aFJHQiA9IGZ1bmN0aW9uIChyMSwgZzEsIGIxLCByMiwgZzIsIGIyLCBsZW5ndGgsIGluZGV4KVxyXG57XHJcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsgbGVuZ3RoID0gMTAwOyB9XHJcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IDA7IH1cclxuXHJcbiAgICB2YXIgdCA9IGluZGV4IC8gbGVuZ3RoO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcjogTGluZWFyKHIxLCByMiwgdCksXHJcbiAgICAgICAgZzogTGluZWFyKGcxLCBnMiwgdCksXHJcbiAgICAgICAgYjogTGluZWFyKGIxLCBiMiwgdClcclxuICAgIH07XHJcbn07XHJcblxyXG52YXIgQ29sb3JXaXRoQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIsIGxlbmd0aCwgaW5kZXgpXHJcbntcclxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSAxMDA7IH1cclxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gMDsgfVxyXG5cclxuICAgIHJldHVybiBSR0JXaXRoUkdCKGNvbG9yMS5yLCBjb2xvcjEuZywgY29sb3IxLmIsIGNvbG9yMi5yLCBjb2xvcjIuZywgY29sb3IyLmIsIGxlbmd0aCwgaW5kZXgpO1xyXG59O1xyXG5cclxudmFyIENvbG9yV2l0aFJHQiA9IGZ1bmN0aW9uICAoY29sb3IsIHIsIGcsIGIsIGxlbmd0aCwgaW5kZXgpXHJcbntcclxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSAxMDA7IH1cclxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gMDsgfVxyXG5cclxuICAgIHJldHVybiBSR0JXaXRoUkdCKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIHIsIGcsIGIsIGxlbmd0aCwgaW5kZXgpO1xyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIFJHQldpdGhSR0I6IFJHQldpdGhSR0IsXHJcbiAgICBDb2xvcldpdGhSR0I6IENvbG9yV2l0aFJHQixcclxuICAgIENvbG9yV2l0aENvbG9yOiBDb2xvcldpdGhDb2xvclxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvSW50ZXJwb2xhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDM3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9JbnRlcnBvbGF0ZS5qcyIsIi8qKlxyXG4qIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU1YgKGh1ZSwgc2F0dXJhdGlvbiBhbmQgdmFsdWUpLlxyXG4qIENvbnZlcnNpb24gZm9ydW1sYSBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2NvbG9yX3NwYWNlLlxyXG4qIEFzc3VtZXMgUkdCIHZhbHVlcyBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV0gYW5kIHJldHVybnMgaCwgcyBhbmQgdiBpbiB0aGUgc2V0IFswLCAxXS5cclxuKiBCYXNlZCBvbiBjb2RlIGJ5IE1pY2hhZWwgSmFja3NvbiAoaHR0cHM6Ly9naXRodWIuY29tL21qaWphY2tzb24pXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLlJHQnRvSFNWXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7bnVtYmVyfSByIC0gVGhlIHJlZCBjb2xvciBjb21wb25lbnQsIGluIHRoZSByYW5nZSAwIC0gMjU1LlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBnIC0gVGhlIGdyZWVuIGNvbG9yIGNvbXBvbmVudCwgaW4gdGhlIHJhbmdlIDAgLSAyNTUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IGIgLSBUaGUgYmx1ZSBjb2xvciBjb21wb25lbnQsIGluIHRoZSByYW5nZSAwIC0gMjU1LlxyXG4qIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGh1ZSwgc2F0dXJhdGlvbiBhbmQgdmFsdWUgc2V0IGluIHRoZSBoLCBzIGFuZCB2IHByb3BlcnRpZXMuXHJcbiovXHJcbnZhciBSR0JUb0hTViA9IGZ1bmN0aW9uIChyLCBnLCBiKVxyXG57XHJcbiAgICByIC89IDI1NTtcclxuICAgIGcgLz0gMjU1O1xyXG4gICAgYiAvPSAyNTU7XHJcblxyXG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xyXG4gICAgdmFyIGQgPSBtYXggLSBtaW47XHJcblxyXG4gICAgLy8gYWNocm9tYXRpYyBieSBkZWZhdWx0XHJcbiAgICB2YXIgaCA9IDA7XHJcbiAgICB2YXIgcyA9IChtYXggPT09IDApID8gMCA6IGQgLyBtYXg7XHJcbiAgICB2YXIgdiA9IG1heDtcclxuXHJcbiAgICBpZiAobWF4ICE9PSBtaW4pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG1heCA9PT0gcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gZCArICgoZyA8IGIpID8gNiA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXggPT09IGcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXggPT09IGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaCAvPSA2O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGg6IGgsIHM6IHMsIHY6IHYgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUkdCVG9IU1Y7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL1JHQlRvSFNWLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbXBvbmVudFRvSGV4ID0gcmVxdWlyZSgnLi9Db21wb25lbnRUb0hleCcpO1xyXG5cclxudmFyIFJHQlRvU3RyaW5nID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEsIHByZWZpeClcclxue1xyXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgeyBhID0gMjU1OyB9XHJcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHsgcHJlZml4ID0gJyMnOyB9XHJcblxyXG4gICAgaWYgKHByZWZpeCA9PT0gJyMnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAnIycgKyAoKDEgPDwgMjQpICsgKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiKS50b1N0cmluZygxNikuc2xpY2UoMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICcweCcgKyBDb21wb25lbnRUb0hleChhKSArIENvbXBvbmVudFRvSGV4KHIpICsgQ29tcG9uZW50VG9IZXgoZykgKyBDb21wb25lbnRUb0hleChiKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUkdCVG9TdHJpbmc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL1JHQlRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvY29sb3IvUkdCVG9TdHJpbmcuanMiLCJ2YXIgQmV0d2VlbiA9IHJlcXVpcmUoJy4uLy4uL21hdGgvQmV0d2VlbicpO1xyXG5cclxudmFyIFJhbmRvbVJHQiA9IGZ1bmN0aW9uIChtaW4sIG1heClcclxue1xyXG4gICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7IG1pbiA9IDA7IH1cclxuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkgeyBtYXggPSAyNTU7IH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHI6IEJldHdlZW4obWluLCBtYXgpLFxyXG4gICAgICAgIGc6IEJldHdlZW4obWluLCBtYXgpLFxyXG4gICAgICAgIGI6IEJldHdlZW4obWluLCBtYXgpXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21SR0I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL1JhbmRvbVJHQi5qc1xuLy8gbW9kdWxlIGlkID0gMzc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2NvbG9yL1JhbmRvbVJHQi5qcyIsIi8vICBQaGFzZXIuR3JhcGhpY3MuQ29sb3JcclxuXHJcbnZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3InKTtcclxuXHJcbkNvbG9yLkNvbG9yVG9SR0JBID0gcmVxdWlyZSgnLi9Db2xvclRvUkdCQScpO1xyXG5Db2xvci5Db21wb25lbnRUb0hleCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50VG9IZXgnKTtcclxuQ29sb3IuQ1NTVG9Db2xvciA9IHJlcXVpcmUoJy4vQ1NTVG9Db2xvcicpO1xyXG5Db2xvci5HZXRDb2xvciA9IHJlcXVpcmUoJy4vR2V0Q29sb3InKTtcclxuQ29sb3IuR2V0Q29sb3IzMiA9IHJlcXVpcmUoJy4vR2V0Q29sb3IzMicpO1xyXG5Db2xvci5IZXhTdHJpbmdUb0NvbG9yID0gcmVxdWlyZSgnLi9IZXhTdHJpbmdUb0NvbG9yJyk7XHJcbkNvbG9yLkhTTFRvQ29sb3IgPSByZXF1aXJlKCcuL0hTTFRvQ29sb3InKTtcclxuQ29sb3IuSFNWQ29sb3JXaGVlbCA9IHJlcXVpcmUoJy4vSFNWQ29sb3JXaGVlbCcpO1xyXG5Db2xvci5IU1ZUb1JHQiA9IHJlcXVpcmUoJy4vSFNWVG9SR0InKTtcclxuQ29sb3IuSHVlVG9Db21wb25lbnQgPSByZXF1aXJlKCcuL0h1ZVRvQ29tcG9uZW50Jyk7XHJcbkNvbG9yLkludGVnZXJUb0NvbG9yID0gcmVxdWlyZSgnLi9JbnRlZ2VyVG9Db2xvcicpO1xyXG5Db2xvci5JbnRlZ2VyVG9SR0IgPSByZXF1aXJlKCcuL0ludGVnZXJUb1JHQicpO1xyXG5Db2xvci5JbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vSW50ZXJwb2xhdGUnKTtcclxuQ29sb3IuUmFuZG9tUkdCID0gcmVxdWlyZSgnLi9SYW5kb21SR0InKTtcclxuQ29sb3IuUkdCU3RyaW5nVG9Db2xvciA9IHJlcXVpcmUoJy4vUkdCU3RyaW5nVG9Db2xvcicpO1xyXG5Db2xvci5SR0JUb0hTViA9IHJlcXVpcmUoJy4vUkdCVG9IU1YnKTtcclxuQ29sb3IuUkdCVG9TdHJpbmcgPSByZXF1aXJlKCcuL1JHQlRvU3RyaW5nJyk7XHJcbkNvbG9yLlZhbHVlVG9Db2xvciA9IHJlcXVpcmUoJy4vVmFsdWVUb0NvbG9yJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2NvbG9yL2luZGV4LmpzIiwiLy8gIEdsb2JhbElucHV0TWFuYWdlclxyXG5cclxudmFyIEtleWJvYXJkID0gcmVxdWlyZSgnLi9rZXlib2FyZC9LZXlib2FyZE1hbmFnZXInKTtcclxuXHJcbnZhciBHbG9iYWxJbnB1dE1hbmFnZXIgPSBmdW5jdGlvbiAoZ2FtZSwgZ2FtZUNvbmZpZylcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICB0aGlzLmdhbWVDb25maWcgPSBnYW1lQ29uZmlnO1xyXG5cclxuICAgIHRoaXMua2V5Ym9hcmQgPSBuZXcgS2V5Ym9hcmQodGhpcyk7XHJcbn07XHJcblxyXG5HbG9iYWxJbnB1dE1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2xvYmFsSW5wdXRNYW5hZ2VyO1xyXG5cclxuR2xvYmFsSW5wdXRNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIEJvb3QgaGFuZGxlciBpcyBjYWxsZWQgYnkgUGhhc2VyLkdhbWUgd2hlbiBpdCBmaXJzdCBzdGFydHMgdXAuXHJcbiAgICAqIFRoZSByZW5kZXJlciBpcyBhdmFpbGFibGUgYnkgbm93LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5JbnB1dC5LZXlib2FyZE1hbmFnZXIjYm9vdFxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIGJvb3Q6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5rZXlib2FyZC5ib290KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmtleWJvYXJkLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2xvYmFsSW5wdXRNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9HbG9iYWxJbnB1dE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbnB1dC9HbG9iYWxJbnB1dE1hbmFnZXIuanMiLCIvLyAgUmV0dXJuIGJvb2xlYW4gKHRydWUgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBjb21ibywgZmFsc2UgaWYgbm90KVxyXG5cclxudmFyIEFkdmFuY2VLZXlDb21ibyA9IGZ1bmN0aW9uIChldmVudCwgY29tYm8pXHJcbntcclxuICAgIGNvbWJvLnRpbWVMYXN0TWF0Y2hlZCA9IGV2ZW50LnRpbWVTdGFtcDtcclxuICAgIGNvbWJvLmluZGV4Kys7XHJcblxyXG4gICAgaWYgKGNvbWJvLmluZGV4ID09PSBjb21iby5zaXplKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGNvbWJvLmN1cnJlbnQgPSBjb21iby5rZXlDb2Rlc1tjb21iby5pbmRleF07XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZHZhbmNlS2V5Q29tYm87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2NvbWJvL0FkdmFuY2VLZXlDb21iby5qc1xuLy8gbW9kdWxlIGlkID0gMzc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIEtleUNvbWJvTWF0Y2hFdmVudCA9IGZ1bmN0aW9uIChrZXlDb21ibywga2V5Ym9hcmRFdmVudClcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnS0VZX0NPTUJPX01BVENIX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy50YXJnZXQgPSBrZXlDb21ibztcclxuXHJcbiAgICB0aGlzLmRhdGEgPSBrZXlib2FyZEV2ZW50O1xyXG59O1xyXG5cclxuS2V5Q29tYm9NYXRjaEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuS2V5Q29tYm9NYXRjaEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleUNvbWJvTWF0Y2hFdmVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS2V5Q29tYm9NYXRjaEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9jb21iby9LZXlDb21ib01hdGNoRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDM4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbnB1dC9rZXlib2FyZC9jb21iby9LZXlDb21ib01hdGNoRXZlbnQuanMiLCJ2YXIgUmVzZXRLZXlDb21ibyA9IGZ1bmN0aW9uIChjb21ibylcclxue1xyXG4gICAgY29tYm8uY3VycmVudCA9IGNvbWJvLmtleUNvZGVzWzBdO1xyXG4gICAgY29tYm8uaW5kZXggPSAwO1xyXG4gICAgY29tYm8udGltZUxhc3RNYXRjaGVkID0gMDtcclxuICAgIGNvbWJvLm1hdGNoZWQgPSBmYWxzZTtcclxuICAgIGNvbWJvLnRpbWVNYXRjaGVkID0gMDtcclxuXHJcbiAgICByZXR1cm4gY29tYm87XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc2V0S2V5Q29tYm87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2NvbWJvL1Jlc2V0S2V5Q29tYm8uanNcbi8vIG1vZHVsZSBpZCA9IDM4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBLZXlEb3duRXZlbnQgPSBmdW5jdGlvbiAoa2V5Ym9hcmRFdmVudClcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnS0VZX0RPV05fRVZFTlQnKTtcclxuXHJcbiAgICB0aGlzLmRhdGEgPSBrZXlib2FyZEV2ZW50O1xyXG59O1xyXG5cclxuS2V5RG93bkV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuS2V5RG93bkV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleURvd25FdmVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS2V5RG93bkV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9ldmVudHMvS2V5RG93bkV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5wdXQva2V5Ym9hcmQvZXZlbnRzL0tleURvd25FdmVudC5qcyIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIEtleVVwRXZlbnQgPSBmdW5jdGlvbiAoa2V5Ym9hcmRFdmVudClcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnS0VZX1VQX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy5kYXRhID0ga2V5Ym9hcmRFdmVudDtcclxufTtcclxuXHJcbktleVVwRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUpO1xyXG5LZXlVcEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleVVwRXZlbnQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleVVwRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2V2ZW50cy9LZXlVcEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5wdXQva2V5Ym9hcmQvZXZlbnRzL0tleVVwRXZlbnQuanMiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxudmFyIEtleUNvZGVzID0gcmVxdWlyZSgnLi8uLi9rZXlzL0tleUNvZGVzJyk7XHJcblxyXG52YXIgZXZlbnRzID0ge1xyXG4gICAgS0VZX0RPV05fRVZFTlQ6IHJlcXVpcmUoJy4vS2V5RG93bkV2ZW50JyksXHJcbiAgICBLRVlfVVBfRVZFTlQ6IHJlcXVpcmUoJy4vS2V5VXBFdmVudCcpLFxyXG4gICAgX1VQOiBbXSxcclxuICAgIF9ET1dOOiBbXVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlS2V5RXZlbnQgKHR5cGUpXHJcbntcclxuICAgIHZhciBLZXlFdmVudCA9IGZ1bmN0aW9uIChrZXlib2FyZEV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IGtleWJvYXJkRXZlbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIEtleUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuICAgIEtleUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleUV2ZW50O1xyXG5cclxuICAgIHJldHVybiBLZXlFdmVudDtcclxufVxyXG5cclxuLy8gIEluamVjdCB0aGUgS2V5Q29kZSBldmVudHNcclxuXHJcbmZvciAodmFyIGNvZGUgaW4gS2V5Q29kZXMpXHJcbntcclxuICAgIC8vICBUaGUgS2V5IERvd24gRXZlbnQgVHlwZXNcclxuXHJcbiAgICB2YXIgZG93blR5cGUgPSAnS0VZX0RPV05fJyArIGNvZGU7XHJcbiAgICB2YXIgdXBUeXBlID0gJ0tFWV9VUF8nICsgY29kZTtcclxuXHJcbiAgICBldmVudHMuX0RPV05bS2V5Q29kZXNbY29kZV1dID0gY3JlYXRlS2V5RXZlbnQoZG93blR5cGUpO1xyXG4gICAgZXZlbnRzLl9VUFtLZXlDb2Rlc1tjb2RlXV0gPSBjcmVhdGVLZXlFdmVudCh1cFR5cGUpO1xyXG5cclxuICAgIC8vICBNb3JlIGZyaWVuZGx5IGFsaWFzZXMgdG8gdGhlIG1haW4gZXZlbnRzXHJcbiAgICBldmVudHNbZG93blR5cGVdID0gZXZlbnRzLl9ET1dOW0tleUNvZGVzW2NvZGVdXTtcclxuICAgIGV2ZW50c1t1cFR5cGVdID0gZXZlbnRzLl9VUFtLZXlDb2Rlc1tjb2RlXV07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXZlbnRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9ldmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbnB1dC9rZXlib2FyZC9ldmVudHMvaW5kZXguanMiLCIvLyAgUGhhc2VyLklucHV0LktleWJvYXJkXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBLZXlib2FyZE1hbmFnZXI6IHJlcXVpcmUoJy4vS2V5Ym9hcmRNYW5hZ2VyJyksXHJcblxyXG4gICAgS2V5OiByZXF1aXJlKCcuL2tleXMvS2V5JyksXHJcbiAgICBLZXlDb2RlczogcmVxdWlyZSgnLi9rZXlzL0tleUNvZGVzJyksXHJcblxyXG4gICAgS2V5Q29tYm86IHJlcXVpcmUoJy4vY29tYm8vS2V5Q29tYm8nKSxcclxuXHJcbiAgICBKdXN0RG93bjogcmVxdWlyZSgnLi9rZXlzL0p1c3REb3duJyksXHJcbiAgICBKdXN0VXA6IHJlcXVpcmUoJy4va2V5cy9KdXN0VXAnKSxcclxuICAgIERvd25EdXJhdGlvbjogcmVxdWlyZSgnLi9rZXlzL0Rvd25EdXJhdGlvbicpLFxyXG4gICAgVXBEdXJhdGlvbjogcmVxdWlyZSgnLi9rZXlzL1VwRHVyYXRpb24nKVxyXG4gICAgXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5wdXQva2V5Ym9hcmQvaW5kZXguanMiLCIvKipcclxuKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgS2V5IHdhcyBwcmVzc2VkIGRvd24gd2l0aGluIHRoZSBgZHVyYXRpb25gIHZhbHVlIGdpdmVuLCBvciBgZmFsc2VgIGlmIGl0IGVpdGhlciBpc24ndCBkb3duLFxyXG4qIG9yIHdhcyBwcmVzc2VkIGRvd24gbG9uZ2VyIGFnbyB0aGFuIHRoZW4gZ2l2ZW4gZHVyYXRpb24uXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuS2V5I2Rvd25EdXJhdGlvblxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249NTBdIC0gVGhlIGR1cmF0aW9uIHdpdGhpbiB3aGljaCB0aGUga2V5IGlzIGNvbnNpZGVyZWQgYXMgYmVpbmcganVzdCBwcmVzc2VkLiBHaXZlbiBpbiBtcy5cclxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBrZXkgd2FzIHByZXNzZWQgZG93biB3aXRoaW4gdGhlIGdpdmVuIGR1cmF0aW9uLlxyXG4qL1xyXG52YXIgRG93bkR1cmF0aW9uID0gZnVuY3Rpb24gKGtleSwgZHVyYXRpb24pXHJcbntcclxuICAgIGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7IGR1cmF0aW9uID0gNTA7IH1cclxuXHJcbiAgICByZXR1cm4gKGtleS5pc0Rvd24gJiYga2V5LmR1cmF0aW9uIDwgZHVyYXRpb24pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEb3duRHVyYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2tleXMvRG93bkR1cmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGp1c3REb3duIHZhbHVlIGFsbG93cyB5b3UgdG8gdGVzdCBpZiB0aGlzIEtleSBoYXMganVzdCBiZWVuIHByZXNzZWQgZG93biBvciBub3QuXHJcbiogV2hlbiB5b3UgY2hlY2sgdGhpcyB2YWx1ZSBpdCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgdGhlIEtleSBpcyBkb3duLCBvdGhlcndpc2UgYGZhbHNlYC5cclxuKiBZb3UgY2FuIG9ubHkgY2FsbCBqdXN0RG93biBvbmNlIHBlciBrZXkgcHJlc3MuIEl0IHdpbGwgb25seSByZXR1cm4gYHRydWVgIG9uY2UsIHVudGlsIHRoZSBLZXkgaXMgcmVsZWFzZWQgYW5kIHByZXNzZWQgZG93biBhZ2Fpbi5cclxuKiBUaGlzIGFsbG93cyB5b3UgdG8gdXNlIGl0IGluIHNpdHVhdGlvbnMgd2hlcmUgeW91IHdhbnQgdG8gY2hlY2sgaWYgdGhpcyBrZXkgaXMgZG93biB3aXRob3V0IHVzaW5nIGEgU2lnbmFsLCBzdWNoIGFzIGluIGEgY29yZSBnYW1lIGxvb3AuXHJcbiogXHJcbiogQHByb3BlcnR5IHtib29sZWFufSBqdXN0RG93blxyXG4qIEBtZW1iZXJvZiBQaGFzZXIuS2V5XHJcbiogQGRlZmF1bHQgZmFsc2VcclxuKi9cclxuXHJcbnZhciBKdXN0RG93biA9IGZ1bmN0aW9uIChrZXkpXHJcbntcclxuICAgIHZhciBjdXJyZW50ID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKGtleS5pc0Rvd24pXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVudCA9IGtleS5fanVzdERvd247XHJcbiAgICAgICAga2V5Ll9qdXN0RG93biA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjdXJyZW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKdXN0RG93bjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW5wdXQva2V5Ym9hcmQva2V5cy9KdXN0RG93bi5qc1xuLy8gbW9kdWxlIGlkID0gMzg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBqdXN0VXAgdmFsdWUgYWxsb3dzIHlvdSB0byB0ZXN0IGlmIHRoaXMgS2V5IGhhcyBqdXN0IGJlZW4gcmVsZWFzZWQgb3Igbm90LlxyXG4qIFdoZW4geW91IGNoZWNrIHRoaXMgdmFsdWUgaXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBLZXkgaXMgdXAsIG90aGVyd2lzZSBgZmFsc2VgLlxyXG4qIFlvdSBjYW4gb25seSBjYWxsIGp1c3RVcCBvbmNlIHBlciBrZXkgcmVsZWFzZS4gSXQgd2lsbCBvbmx5IHJldHVybiBgdHJ1ZWAgb25jZSwgdW50aWwgdGhlIEtleSBpcyBwcmVzc2VkIGRvd24gYW5kIHJlbGVhc2VkIGFnYWluLlxyXG4qIFRoaXMgYWxsb3dzIHlvdSB0byB1c2UgaXQgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3Ugd2FudCB0byBjaGVjayBpZiB0aGlzIGtleSBpcyB1cCB3aXRob3V0IHVzaW5nIGEgU2lnbmFsLCBzdWNoIGFzIGluIGEgY29yZSBnYW1lIGxvb3AuXHJcbiogXHJcbiogQHByb3BlcnR5IHtib29sZWFufSBqdXN0VXBcclxuKiBAbWVtYmVyb2YgUGhhc2VyLktleVxyXG4qIEBkZWZhdWx0IGZhbHNlXHJcbiovXHJcblxyXG52YXIgSnVzdFVwID0gZnVuY3Rpb24gKGtleSlcclxue1xyXG4gICAgdmFyIGN1cnJlbnQgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoa2V5LmlzRG93bilcclxuICAgIHtcclxuICAgICAgICBjdXJyZW50ID0ga2V5Ll9qdXN0VXA7XHJcbiAgICAgICAga2V5Ll9qdXN0VXAgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3VycmVudDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSnVzdFVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9rZXlzL0p1c3RVcC5qc1xuLy8gbW9kdWxlIGlkID0gMzg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgUHJvY2Vzc0tleURvd24gPSBmdW5jdGlvbiAoa2V5LCBldmVudClcclxue1xyXG4gICAga2V5Lm9yaWdpbmFsRXZlbnQgPSBldmVudDtcclxuXHJcbiAgICBpZiAoa2V5LnByZXZlbnREZWZhdWx0KVxyXG4gICAge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFrZXkuZW5hYmxlZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAga2V5LmFsdEtleSA9IGV2ZW50LmFsdEtleTtcclxuICAgIGtleS5jdHJsS2V5ID0gZXZlbnQuY3RybEtleTtcclxuICAgIGtleS5zaGlmdEtleSA9IGV2ZW50LnNoaWZ0S2V5O1xyXG4gICAga2V5LmxvY2F0aW9uID0gZXZlbnQubG9jYXRpb247XHJcblxyXG4gICAga2V5LmlzRG93biA9IHRydWU7XHJcbiAgICBrZXkuaXNVcCA9IGZhbHNlO1xyXG4gICAga2V5LnRpbWVEb3duID0gZXZlbnQudGltZVN0YW1wO1xyXG4gICAga2V5LmR1cmF0aW9uID0gMDtcclxuICAgIGtleS5yZXBlYXRzKys7XHJcblxyXG4gICAga2V5Ll9qdXN0RG93biA9IHRydWU7XHJcbiAgICBrZXkuX2p1c3RVcCA9IGZhbHNlO1xyXG5cclxuICAgIHJldHVybiBrZXk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NLZXlEb3duO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9rZXlzL1Byb2Nlc3NLZXlEb3duLmpzXG4vLyBtb2R1bGUgaWQgPSAzODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBQcm9jZXNzS2V5VXAgPSBmdW5jdGlvbiAoa2V5LCBldmVudClcclxue1xyXG4gICAga2V5Lm9yaWdpbmFsRXZlbnQgPSBldmVudDtcclxuXHJcbiAgICBpZiAoa2V5LnByZXZlbnREZWZhdWx0KVxyXG4gICAge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFrZXkuZW5hYmxlZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAga2V5LmlzRG93biA9IGZhbHNlO1xyXG4gICAga2V5LmlzVXAgPSB0cnVlO1xyXG4gICAga2V5LnRpbWVVcCA9IGV2ZW50LnRpbWVTdGFtcDtcclxuICAgIGtleS5kdXJhdGlvbiA9IGtleS50aW1lVXAgLSBrZXkudGltZURvd247XHJcbiAgICBrZXkucmVwZWF0cyA9IDA7XHJcblxyXG4gICAga2V5Ll9qdXN0RG93biA9IGZhbHNlO1xyXG4gICAga2V5Ll9qdXN0VXAgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiBrZXk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NLZXlVcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW5wdXQva2V5Ym9hcmQva2V5cy9Qcm9jZXNzS2V5VXAuanNcbi8vIG1vZHVsZSBpZCA9IDM5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgS2V5IHdhcyByZWxlYXNlZCB3aXRoaW4gdGhlIGBkdXJhdGlvbmAgdmFsdWUgZ2l2ZW4sIG9yIGBmYWxzZWAgaWYgaXQgZWl0aGVyIGlzbid0IHVwLFxyXG4qIG9yIHdhcyByZWxlYXNlZCBsb25nZXIgYWdvIHRoYW4gdGhlbiBnaXZlbiBkdXJhdGlvbi5cclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5LZXkjdXBEdXJhdGlvblxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249NTBdIC0gVGhlIGR1cmF0aW9uIHdpdGhpbiB3aGljaCB0aGUga2V5IGlzIGNvbnNpZGVyZWQgYXMgYmVpbmcganVzdCByZWxlYXNlZC4gR2l2ZW4gaW4gbXMuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUga2V5IHdhcyByZWxlYXNlZCB3aXRoaW4gdGhlIGdpdmVuIGR1cmF0aW9uLlxyXG4qL1xyXG52YXIgVXBEdXJhdGlvbiA9IGZ1bmN0aW9uIChrZXksIGR1cmF0aW9uKVxyXG57XHJcbiAgICBpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkgeyBkdXJhdGlvbiA9IDUwOyB9XHJcblxyXG4gICAgcmV0dXJuIChrZXkuaXNVcCAmJiBrZXkuZHVyYXRpb24gPCBkdXJhdGlvbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVwRHVyYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2tleXMvVXBEdXJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBTZXQgPSByZXF1aXJlKCcuLi9zdHJ1Y3RzL1NldCcpO1xyXG52YXIgWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL1hIUlNldHRpbmdzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnRzLycpO1xyXG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xyXG5cclxudmFyIEJhc2VMb2FkZXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvLyAgVG8gZmluaXNoIHRoZSBsb2FkZXIgLi4uXHJcbiAgICAvLyAgXHJcbiAgICAvLyAgMykgUHJvZ3Jlc3MgdXBkYXRlXHJcblxyXG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XHJcblxyXG4gICAgLy8gIE1vdmUgdG8gYSAnc2V0VVJMJyBtZXRob2Q/XHJcbiAgICB0aGlzLmJhc2VVUkwgPSAnJztcclxuICAgIHRoaXMucGF0aCA9ICcnO1xyXG5cclxuICAgIC8vICBSZWFkIGZyb20gR2FtZSAvIFN0YXRlIENvbmZpZ1xyXG4gICAgdGhpcy5lbmFibGVQYXJhbGxlbCA9IHRydWU7XHJcbiAgICB0aGlzLm1heFBhcmFsbGVsRG93bmxvYWRzID0gNDtcclxuXHJcbiAgICAvLyAgeGhyIHNwZWNpZmljIGdsb2JhbCBzZXR0aW5ncyAoY2FuIGJlIG92ZXJyaWRkZW4gb24gYSBwZXItZmlsZSBiYXNpcylcclxuICAgIHRoaXMueGhyID0gWEhSU2V0dGluZ3MoKTtcclxuXHJcbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMubGlzdCA9IG5ldyBTZXQoKTtcclxuICAgIHRoaXMuaW5mbGlnaHQgPSBuZXcgU2V0KCk7XHJcbiAgICB0aGlzLmZhaWxlZCA9IG5ldyBTZXQoKTtcclxuICAgIHRoaXMucXVldWUgPSBuZXcgU2V0KCk7XHJcbiAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfSURMRTtcclxufTtcclxuXHJcbkJhc2VMb2FkZXIucHJvdG90eXBlLmNvbnRydWN0b3IgPSBCYXNlTG9hZGVyO1xyXG5cclxuQmFzZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkRmlsZTogZnVuY3Rpb24gKGZpbGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVhZHkoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZpbGUucGF0aCA9IHRoaXMucGF0aDtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0LnNldChmaWxlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBJcyB0aGUgTG9hZGVyIGFjdGl2ZWx5IGxvYWRpbmcgKG9yIHByb2Nlc3NpbmcgbG9hZGVkIGZpbGVzKVxyXG4gICAgaXNMb2FkaW5nOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9MT0FESU5HIHx8IHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfUFJPQ0VTU0lORyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBJcyB0aGUgTG9hZGVyIHJlYWR5IHRvIHN0YXJ0IGEgbmV3IGxvYWQ/XHJcbiAgICBpc1JlYWR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9JRExFIHx8IHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfQ09NUExFVEUgfHwgdGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9GQUlMRUQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnN0YXRlLnNldHRpbmdzLmtleSwgJy0gQmFzZUxvYWRlciBzdGFydC4gRmlsZXMgdG8gbG9hZDonLCB0aGlzLmxpc3Quc2l6ZSk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5pc1JlYWR5KCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuTE9BREVSX1NUQVJUX0VWRU5UKHRoaXMpKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGlzdC5zaXplID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZExvYWRpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfTE9BRElORztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5mbGlnaHQuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5kZWJ1ZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NMb2FkUXVldWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVByb2dyZXNzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcHJvY2Vzc0xvYWRRdWV1ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnPT09PT09PT0gQmFzZUxvYWRlciBwcm9jZXNzTG9hZFF1ZXVlJyk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xpc3Qgc2l6ZScsIHRoaXMubGlzdC5zaXplKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmluZmxpZ2h0LnNpemUsICdpdGVtcyBzdGlsbCBpbiBmbGlnaHQuIENhbiBsb2FkIGFub3RoZXInLCAodGhpcy5tYXhQYXJhbGxlbERvd25sb2FkcyAtIHRoaXMuaW5mbGlnaHQuc2l6ZSkpO1xyXG5cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3QuZWFjaChmdW5jdGlvbiAoZmlsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChmaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX1BFTkRJTkcgJiYgX3RoaXMuaW5mbGlnaHQuc2l6ZSA8IF90aGlzLm1heFBhcmFsbGVsRG93bmxvYWRzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmZsaWdodC5zZXQoZmlsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3RoaXMubGlzdC5kZWxldGUoZmlsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9hZEZpbGUoZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbmZsaWdodC5zaXplID09PSBfdGhpcy5tYXhQYXJhbGxlbERvd25sb2FkcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRlbGxzIHRoZSBTZXQgaXRlcmF0b3IgdG8gYWJvcnRcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIHByaXZhdGVcclxuICAgIGxvYWRGaWxlOiBmdW5jdGlvbiAoZmlsZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnTE9BRElORycsIGZpbGUua2V5KTtcclxuXHJcbiAgICAgICAgLy8gIElmIHRoZSBmaWxlIGRvZXNuJ3QgaGF2ZSBpdHMgb3duIGNyb3NzT3JpZ2luIHNldCxcclxuICAgICAgICAvLyAgd2UnbGwgdXNlIHRoZSBMb2FkZXJzICh3aGljaCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdClcclxuICAgICAgICBpZiAoIWZpbGUuY3Jvc3NPcmlnaW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmaWxlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZpbGUubG9hZCh0aGlzLm5leHRGaWxlLmJpbmQodGhpcyksIHRoaXMuYmFzZVVSTCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG5leHRGaWxlOiBmdW5jdGlvbiAocHJldmlvdXNGaWxlLCBzdWNjZXNzKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMT0FERUQ6JywgcHJldmlvdXNGaWxlLnNyYywgc3VjY2Vzcyk7XHJcblxyXG4gICAgICAgIC8vICBNb3ZlIHRoZSBmaWxlIHRoYXQganVzdCBsb2FkZWQgZnJvbSB0aGUgaW5mbGlnaHQgbGlzdCB0byB0aGUgcXVldWUgb3IgZmFpbGVkIFNldFxyXG5cclxuICAgICAgICBpZiAoc3VjY2VzcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucXVldWUuc2V0KHByZXZpb3VzRmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkLnNldChwcmV2aW91c0ZpbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbmZsaWdodC5kZWxldGUocHJldmlvdXNGaWxlKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGlzdC5zaXplID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCduZXh0RmlsZSAtIHN0aWxsIHNvbWV0aGluZyBpbiB0aGUgbGlzdCcpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NMb2FkUXVldWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmZsaWdodC5zaXplID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ25leHRGaWxlIGNhbGxpbmcgZmluaXNoZWRMb2FkaW5nJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWRMb2FkaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBmaW5pc2hlZExvYWRpbmc6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLT4gQmFzZUxvYWRlci5maW5pc2hlZExvYWRpbmcgUFJPQ0VTU0lORycsIHRoaXMucXVldWUuc2l6ZSwgJ2ZpbGVzJyk7XHJcblxyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gQ09OU1QuTE9BREVSX1BST0NFU1NJTkc7XHJcblxyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xyXG5cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLnF1ZXVlLmVhY2goZnVuY3Rpb24gKGZpbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnJWMgQ2FsbGluZyBwcm9jZXNzIG9uICcgKyBmaWxlLmtleSwgJ2NvbG9yOiAjMDAwMDAwOyBiYWNrZ3JvdW5kOiAjZmZmZjAwOycpO1xyXG5cclxuICAgICAgICAgICAgZmlsZS5vblByb2Nlc3MoX3RoaXMucHJvY2Vzc1VwZGF0ZS5iaW5kKF90aGlzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgRmlsZSB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nXHJcbiAgICBwcm9jZXNzVXBkYXRlOiBmdW5jdGlvbiAoZmlsZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLT4gcHJvY2Vzc1VwZGF0ZScsIGZpbGUua2V5LCBmaWxlLnN0YXRlKTtcclxuXHJcbiAgICAgICAgLy8gIFRoaXMgZmlsZSBoYXMgZmFpbGVkIHRvIGxvYWQsIHNvIG1vdmUgaXQgdG8gdGhlIGZhaWxlZCBTZXRcclxuICAgICAgICBpZiAoZmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9FUlJPUkVEKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5mYWlsZWQuc2V0KGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpbGUubGlua0ZpbGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZGVsZXRlKGZpbGUubGlua0ZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVGcm9tUXVldWUoZmlsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgSWYgd2UgZ290IGhlcmUsIHRoZW4gdGhlIGZpbGUgbG9hZGVkXHJcblxyXG4gICAgICAgIC8vICBTcGVjaWFsIGhhbmRsaW5nIGZvciBtdWx0aS1wYXJ0IGZpbGVzXHJcblxyXG4gICAgICAgIGlmIChmaWxlLmxpbmtGaWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfQ09NUExFVEUgJiYgZmlsZS5saW5rRmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9DT01QTEVURSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFBhcnRuZXIgaGFzIGxvYWRlZCwgc28gYWRkIHRoZW0gYm90aCB0byBTdG9yYWdlXHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldCh7IHR5cGU6IGZpbGUubGlua1R5cGUsIGZpbGVBOiBmaWxlLCBmaWxlQjogZmlsZS5saW5rRmlsZSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRlbGV0ZShmaWxlLmxpbmtGaWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21RdWV1ZShmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tUXVldWUoZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVGcm9tUXVldWU6IGZ1bmN0aW9uIChmaWxlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucXVldWUuZGVsZXRlKGZpbGUpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5xdWV1ZS5zaXplID09PSAwICYmIHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfUFJPQ0VTU0lORylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBXZSd2ZSBwcm9jZXNzZWQgYWxsIHRoZSBmaWxlcyB3ZSBsb2FkZWRcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3NDb21wbGV0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnN0YXRlLnNldHRpbmdzLmtleSwgJy0gTG9hZGVyIENvbXBsZXRlLiBMb2FkZWQ6JywgdGhpcy5zdG9yYWdlLnNpemUsICdGYWlsZWQ6JywgdGhpcy5mYWlsZWQuc2l6ZSk7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuaW5mbGlnaHQuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnF1ZXVlLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NDYWxsYmFjaylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9DT01QTEVURTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IEV2ZW50LkxPQURFUl9DT01QTEVURV9FVkVOVCh0aGlzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubGlzdC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuaW5mbGlnaHQuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmZhaWxlZC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMucXVldWUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsKCdMT0FERVJfU1RBUlRfRVZFTlQnKTtcclxuICAgICAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGwoJ0xPQURFUl9DT01QTEVURV9FVkVOVCcpO1xyXG5cclxuICAgICAgICB0aGlzLnRhZyA9ICcnO1xyXG4gICAgICAgIHRoaXMucGF0aCA9ICcnO1xyXG4gICAgICAgIHRoaXMuYmFzZVVSTCA9ICcnO1xyXG5cclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9JRExFO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9ERVNUUk9ZRUQ7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlTG9hZGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvQmFzZUxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9CYXNlTG9hZGVyLmpzIiwidmFyIEdldFVSTCA9IGZ1bmN0aW9uIChmaWxlLCBiYXNlVVJMKVxyXG57XHJcbiAgICBpZiAoIWZpbGUudXJsKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmlsZS51cmwubWF0Y2goL14oPzpibG9iOnxkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98XFwvXFwvKS8pKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmaWxlLnVybDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYmFzZVVSTCArIGZpbGUudXJsO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRVUkw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9HZXRVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDM5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWVyZ2VYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vTWVyZ2VYSFJTZXR0aW5ncycpO1xyXG5cclxudmFyIFhIUkxvYWRlciA9IGZ1bmN0aW9uIChmaWxlLCBnbG9iYWxYSFJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGNvbmZpZyA9IE1lcmdlWEhSU2V0dGluZ3MoZ2xvYmFsWEhSU2V0dGluZ3MsIGZpbGUueGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbiAgICB4aHIub3BlbignR0VUJywgZmlsZS5zcmMsIGNvbmZpZy5hc3luYywgY29uZmlnLnVzZXIsIGNvbmZpZy5wYXNzd29yZCk7XHJcblxyXG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGZpbGUueGhyU2V0dGluZ3MucmVzcG9uc2VUeXBlO1xyXG4gICAgeGhyLnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcclxuXHJcbiAgICBpZiAoY29uZmlnLmhlYWRlciAmJiBjb25maWcuaGVhZGVyVmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoY29uZmlnLmhlYWRlciwgY29uZmlnLmhlYWRlclZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0LCB0aGUgeGhyLnJlc3BvbnNlIHByb3BlcnR5IHdpbGwgY29udGFpbiB0aGUgcmVxdWVzdGVkIGRhdGEgYXMgYSBET01TdHJpbmcsIEFycmF5QnVmZmVyLCBCbG9iLCBvciBEb2N1bWVudCAoZGVwZW5kaW5nIG9uIHdoYXQgd2FzIHNldCBmb3IgcmVzcG9uc2VUeXBlLilcclxuXHJcbiAgICB4aHIub25sb2FkID0gZmlsZS5vbkxvYWQuYmluZChmaWxlKTtcclxuICAgIHhoci5vbmVycm9yID0gZmlsZS5vbkVycm9yLmJpbmQoZmlsZSk7XHJcbiAgICB4aHIub25wcm9ncmVzcyA9IGZpbGUub25Qcm9ncmVzcy5iaW5kKGZpbGUpO1xyXG5cclxuICAgIC8vICBUaGlzIGlzIHRoZSBvbmx5IHN0YW5kYXJkIG1ldGhvZCwgdGhlIG9uZXMgYWJvdmUgYXJlIGJyb3dzZXIgYWRkaXRpb25zIChtYXliZSBub3QgdW5pdmVyc2FsPylcclxuICAgIC8vIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2VcclxuXHJcbiAgICB4aHIuc2VuZCgpO1xyXG5cclxuICAgIHJldHVybiB4aHI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL1hIUkxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9YSFJMb2FkZXIuanMiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBMb2FkZXJDb21wbGV0ZUV2ZW50ID0gZnVuY3Rpb24gKGxvYWRlcilcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnTE9BREVSX0NPTVBMRVRFX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XHJcbn07XHJcblxyXG5Mb2FkZXJDb21wbGV0ZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuTG9hZGVyQ29tcGxldGVFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXJDb21wbGV0ZUV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXJDb21wbGV0ZUV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDM5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanMiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBMb2FkZXJTdGFydEV2ZW50ID0gZnVuY3Rpb24gKGxvYWRlcilcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnTE9BREVSX1NUQVJUX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XHJcbn07XHJcblxyXG5Mb2FkZXJTdGFydEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuTG9hZGVyU3RhcnRFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXJTdGFydEV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXJTdGFydEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZXZlbnRzL0xvYWRlclN0YXJ0RXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDM5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZXZlbnRzL0xvYWRlclN0YXJ0RXZlbnQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBMT0FERVJfU1RBUlRfRVZFTlQ6IHJlcXVpcmUoJy4vTG9hZGVyU3RhcnRFdmVudCcpLFxyXG4gICAgTE9BREVSX0NPTVBMRVRFX0VWRU5UOiByZXF1aXJlKCcuL0xvYWRlckNvbXBsZXRlRXZlbnQnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2V2ZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9ldmVudHMvaW5kZXguanMiLCJ2YXIgSW1hZ2VGaWxlID0gcmVxdWlyZSgnLi9JbWFnZUZpbGUuanMnKTtcclxudmFyIEpTT05GaWxlID0gcmVxdWlyZSgnLi9KU09ORmlsZS5qcycpO1xyXG5cclxudmFyIEF0bGFzSlNPTkZpbGUgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMLCBhdGxhc1VSTCwgcGF0aCwgdGV4dHVyZVhoclNldHRpbmdzLCBhdGxhc1hoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2VGaWxlKGtleSwgdGV4dHVyZVVSTCwgcGF0aCwgdGV4dHVyZVhoclNldHRpbmdzKTtcclxuICAgIHZhciBkYXRhID0gbmV3IEpTT05GaWxlKGtleSwgYXRsYXNVUkwsIHBhdGgsIGF0bGFzWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIC8vICBMaW5rIHRoZW0gdG9nZXRoZXJcclxuICAgIGltYWdlLmxpbmtGaWxlID0gZGF0YTtcclxuICAgIGRhdGEubGlua0ZpbGUgPSBpbWFnZTtcclxuXHJcbiAgICAvLyAgU2V0IHRoZSB0eXBlXHJcbiAgICBpbWFnZS5saW5rVHlwZSA9ICdhdGxhc2pzb24nO1xyXG4gICAgZGF0YS5saW5rVHlwZSA9ICdhdGxhc2pzb24nO1xyXG5cclxuICAgIHJldHVybiB7IHRleHR1cmU6IGltYWdlLCBkYXRhOiBkYXRhIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF0bGFzSlNPTkZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qcyIsIlxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxuXHJcbnZhciBCaW5hcnlGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLmJpbmFyeVxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5iaW4nO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmlsZS5jYWxsKHRoaXMsICdiaW5hcnknLCBrZXksIHVybCwgJ2FycmF5YnVmZmVyJywgeGhyU2V0dGluZ3MpO1xyXG59O1xyXG5cclxuQmluYXJ5RmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcclxuQmluYXJ5RmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaW5hcnlGaWxlO1xyXG5cclxuQmluYXJ5RmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlO1xyXG5cclxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgIGNhbGxiYWNrKHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaW5hcnlGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDM5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUuanMiLCJ2YXIgSW1hZ2VGaWxlID0gcmVxdWlyZSgnLi9JbWFnZUZpbGUuanMnKTtcclxudmFyIFhNTEZpbGUgPSByZXF1aXJlKCcuL1hNTEZpbGUuanMnKTtcclxuXHJcbnZhciBCaXRtYXBGb250RmlsZSA9IGZ1bmN0aW9uIChrZXksIHRleHR1cmVVUkwsIHhtbFVSTCwgcGF0aCwgdGV4dHVyZVhoclNldHRpbmdzLCB4bWxYaHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlRmlsZShrZXksIHRleHR1cmVVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncyk7XHJcbiAgICB2YXIgZGF0YSA9IG5ldyBYTUxGaWxlKGtleSwgeG1sVVJMLCBwYXRoLCB4bWxYaHJTZXR0aW5ncyk7XHJcblxyXG4gICAgLy8gIExpbmsgdGhlbSB0b2dldGhlclxyXG4gICAgaW1hZ2UubGlua0ZpbGUgPSBkYXRhO1xyXG4gICAgZGF0YS5saW5rRmlsZSA9IGltYWdlO1xyXG5cclxuICAgIC8vICBTZXQgdGhlIHR5cGVcclxuICAgIGltYWdlLmxpbmtUeXBlID0gJ2JpdG1hcGZvbnQnO1xyXG4gICAgZGF0YS5saW5rVHlwZSA9ICdiaXRtYXBmb250JztcclxuXHJcbiAgICByZXR1cm4geyB0ZXh0dXJlOiBpbWFnZSwgZGF0YTogZGF0YSB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaXRtYXBGb250RmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaXRtYXBGb250RmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvQml0bWFwRm9udEZpbGUuanMiLCJcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcblxyXG52YXIgR0xTTEZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxyXG5cclxuICAgIGlmICgha2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIudGV4dFxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5nbHNsJztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIEZpbGUuY2FsbCh0aGlzLCAnZ2xzbCcsIGtleSwgdXJsLCAndGV4dCcsIHhoclNldHRpbmdzKTtcclxufTtcclxuXHJcbkdMU0xGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5HTFNMRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHTFNMRmlsZTtcclxuXHJcbkdMU0xGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gdGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0O1xyXG5cclxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgIGNhbGxiYWNrKHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHTFNMRmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9HTFNMRmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanMiLCJ2YXIgSW1hZ2VGaWxlID0gcmVxdWlyZSgnLi9JbWFnZUZpbGUuanMnKTtcclxuXHJcbi8vICBjb25maWcgY2FuIGluY2x1ZGU6IGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgbWFyZ2luLCBzcGFjaW5nXHJcblxyXG52YXIgU3ByaXRlU2hlZXQgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIGNvbmZpZywgcGF0aCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZUZpbGUoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzLCBjb25maWcpO1xyXG5cclxuICAgIC8vICBPdmVycmlkZSB0aGUgRmlsZSB0eXBlXHJcbiAgICBpbWFnZS50eXBlID0gJ3Nwcml0ZXNoZWV0JztcclxuXHJcbiAgICByZXR1cm4gaW1hZ2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZVNoZWV0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZmlsZXR5cGVzL1Nwcml0ZVNoZWV0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9TcHJpdGVTaGVldC5qcyIsIlxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxuXHJcbnZhciBUZXh0RmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHsgcGF0aCA9ICcnOyB9XHJcblxyXG4gICAgaWYgKCFrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci50ZXh0XFwnIGludmFsaWQga2V5IHByb3ZpZGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdXJsKVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLnRleHQnO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmlsZS5jYWxsKHRoaXMsICd0ZXh0Jywga2V5LCB1cmwsICd0ZXh0JywgeGhyU2V0dGluZ3MpO1xyXG59O1xyXG5cclxuVGV4dEZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XHJcblRleHRGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRGaWxlO1xyXG5cclxuVGV4dEZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcclxue1xyXG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICB0aGlzLmRhdGEgPSB0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQ7XHJcblxyXG4gICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgY2FsbGJhY2sodGhpcyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZmlsZXR5cGVzL1RleHRGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZS5qcyIsInZhciBBdmVyYWdlID0gZnVuY3Rpb24gKHZhbHVlcylcclxue1xyXG4gICAgdmFyIHN1bSA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgc3VtICs9ICgrdmFsdWVzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3VtIC8gdmFsdWVzLmxlbmd0aDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXZlcmFnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9BdmVyYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENlaWxUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgcGxhY2UsIGJhc2UpXHJcbntcclxuICAgIGlmIChwbGFjZSA9PT0gdW5kZWZpbmVkKSB7IHBsYWNlID0gMDsgfVxyXG4gICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkgeyBiYXNlID0gMTA7IH1cclxuXHJcbiAgICB2YXIgcCA9IE1hdGgucG93KGJhc2UsIC1wbGFjZSk7XHJcblxyXG4gICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSAqIHApIC8gcDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VpbFRvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0NlaWxUby5qc1xuLy8gbW9kdWxlIGlkID0gNDA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBEZWdUb1JhZCA9IGZ1bmN0aW9uIChkZWdyZWVzKVxyXG57XHJcbiAgICByZXR1cm4gZGVncmVlcyAqIENPTlNULkRFR19UT19SQUQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlZ1RvUmFkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0RlZ1RvUmFkLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9EZWdUb1JhZC5qcyIsInZhciBEaWZmZXJlbmNlID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmFicyhhIC0gYik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpZmZlcmVuY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRGlmZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gNDA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9hdEJldHdlZW4gPSBmdW5jdGlvbiAobWluLCBtYXgpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9hdEJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRmxvYXRCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yVG8gPSBmdW5jdGlvbiAodmFsdWUsIHBsYWNlLCBiYXNlKVxyXG57XHJcbiAgICBpZiAocGxhY2UgPT09IHVuZGVmaW5lZCkgeyBwbGFjZSA9IDA7IH1cclxuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHsgYmFzZSA9IDEwOyB9XHJcblxyXG4gICAgdmFyIHAgPSBNYXRoLnBvdyhiYXNlLCAtcGxhY2UpO1xyXG5cclxuICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlICogcCkgLyBwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9vclRvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0Zsb29yVG8uanNcbi8vIG1vZHVsZSBpZCA9IDQwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIE1heEFkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgYW1vdW50LCBtYXgpXHJcbntcclxuICAgIHJldHVybiBNYXRoLm1pbih2YWx1ZSArIGFtb3VudCwgbWF4KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWF4QWRkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL01heEFkZC5qc1xuLy8gbW9kdWxlIGlkID0gNDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNaW5TdWIgPSBmdW5jdGlvbiAodmFsdWUsIGFtb3VudCwgbWluKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWUgLSBhbW91bnQsIG1pbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1pblN1YjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9NaW5TdWIuanNcbi8vIG1vZHVsZSBpZCA9IDQxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGVyY2VudCA9IGZ1bmN0aW9uIChhLCBiLCBiYXNlKVxyXG57XHJcbiAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7IGJhc2UgPSAwOyB9XHJcblxyXG4gICAgaWYgKGEgPiBiIHx8IGJhc2UgPiBiKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYSA8IGJhc2UgfHwgYmFzZSA+IGEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIChhIC0gYmFzZSkgLyBiO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJjZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1BlcmNlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgUmFkVG9EZWcgPSBmdW5jdGlvbiAocmFkaWFucylcclxue1xyXG4gICAgcmV0dXJuIHJhZGlhbnMgKiBDT05TVC5SQURfVE9fREVHO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYWRUb0RlZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9SYWRUb0RlZy5qc1xuLy8gbW9kdWxlIGlkID0gNDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvUmFkVG9EZWcuanMiLCIvLyAgcCA9IFBvaW50IG9yIGFueSBvYmplY3Qgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXNcclxuXHJcbnZhciBSb3RhdGUgPSBmdW5jdGlvbiAocG9pbnQsIGFuZ2xlKVxyXG57XHJcbiAgICB2YXIgeCA9IHBvaW50Lng7XHJcbiAgICB2YXIgeSA9IHBvaW50Lnk7XHJcblxyXG4gICAgcG9pbnQueCA9ICh4ICogTWF0aC5jb3MoYW5nbGUpKSAtICh5ICogTWF0aC5zaW4oYW5nbGUpKTtcclxuICAgIHBvaW50LnkgPSAoeCAqIE1hdGguc2luKGFuZ2xlKSkgKyAoeSAqIE1hdGguY29zKGFuZ2xlKSk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvUm90YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIHAgPSBQb2ludCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXHJcblxyXG52YXIgUm90YXRlQXJvdW5kID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5LCBhbmdsZSlcclxue1xyXG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICB2YXIgdHggPSBwb2ludC54IC0geDtcclxuICAgIHZhciB0eSA9IHBvaW50LnkgLSB5O1xyXG5cclxuICAgIHBvaW50LnggPSB0eCAqIGMgLSB0eSAqIHMgKyB4O1xyXG4gICAgcG9pbnQueSA9IHR4ICogcyArIHR5ICogYyArIHk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvUm90YXRlQXJvdW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIHAgPSBQb2ludCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXHJcblxyXG52YXIgUm90YXRlQXJvdW5kRGlzdGFuY2UgPSBmdW5jdGlvbiAocG9pbnQsIHgsIHksIGFuZ2xlLCBkaXN0YW5jZSlcclxue1xyXG4gICAgdmFyIHQgPSBhbmdsZSArIE1hdGguYXRhbjIocG9pbnQueSAtIHksIHBvaW50LnggLSB4KTtcclxuXHJcbiAgICBwb2ludC54ID0geCArIChkaXN0YW5jZSAqIE1hdGguY29zKHQpKTtcclxuICAgIHBvaW50LnkgPSB5ICsgKGRpc3RhbmNlICogTWF0aC5zaW4odCkpO1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kRGlzdGFuY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvUm90YXRlQXJvdW5kRGlzdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm91bmRUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgcGxhY2UsIGJhc2UpXHJcbntcclxuICAgIGlmIChwbGFjZSA9PT0gdW5kZWZpbmVkKSB7IHBsYWNlID0gMDsgfVxyXG4gICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkgeyBiYXNlID0gMTA7IH1cclxuXHJcbiAgICB2YXIgcCA9IE1hdGgucG93KGJhc2UsIC1wbGFjZSk7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwKSAvIHA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kVG87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvUm91bmRUby5qc1xuLy8gbW9kdWxlIGlkID0gNDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgU2luQ29zVGFibGVHZW5lcmF0b3IgPSBmdW5jdGlvbiAobGVuZ3RoLCBzaW5BbXAsIGNvc0FtcCwgZnJlcXVlbmN5KVxyXG57XHJcbiAgICBpZiAoc2luQW1wID09PSB1bmRlZmluZWQpIHsgc2luQW1wID0gMTsgfVxyXG4gICAgaWYgKGNvc0FtcCA9PT0gdW5kZWZpbmVkKSB7IGNvc0FtcCA9IDE7IH1cclxuICAgIGlmIChmcmVxdWVuY3kgPT09IHVuZGVmaW5lZCkgeyBmcmVxdWVuY3kgPSAxOyB9XHJcblxyXG4gICAgZnJlcXVlbmN5ICo9IE1hdGguUEkgLyBsZW5ndGg7XHJcblxyXG4gICAgdmFyIGNvcyA9IFtdO1xyXG4gICAgdmFyIHNpbiA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbGVuZ3RoOyBjKyspXHJcbiAgICB7XHJcbiAgICAgICAgY29zQW1wIC09IHNpbkFtcCAqIGZyZXF1ZW5jeTtcclxuICAgICAgICBzaW5BbXAgKz0gY29zQW1wICogZnJlcXVlbmN5O1xyXG5cclxuICAgICAgICBjb3NbY10gPSBjb3NBbXA7XHJcbiAgICAgICAgc2luW2NdID0gc2luQW1wO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2luOiBzaW4sXHJcbiAgICAgICAgY29zOiBjb3MsXHJcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGhcclxuICAgIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNpbkNvc1RhYmxlR2VuZXJhdG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1NpbkNvc1RhYmxlR2VuZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0MThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNtb290aFN0ZXAgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpXHJcbntcclxuICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoeCAtIG1pbikgLyAobWF4IC0gbWluKSkpO1xyXG5cclxuICAgIHJldHVybiB4ICogeCAqICgzIC0gMiAqIHgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbW9vdGhTdGVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1Ntb290aFN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDQxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU21vb3RoZXJTdGVwID0gZnVuY3Rpb24gKHgsIG1pbiwgbWF4KVxyXG57XHJcbiAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHggLSBtaW4pIC8gKG1heCAtIG1pbikpKTtcclxuXHJcbiAgICByZXR1cm4geCAqIHggKiB4ICogKHggKiAoeCAqIDYgLSAxNSkgKyAxMCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNtb290aGVyU3RlcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9TbW9vdGhlclN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDQyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDaGVja3MgaWYgdHdvIHZhbHVlcyBhcmUgd2l0aGluIHRoZSBnaXZlbiB0b2xlcmFuY2Ugb2YgZWFjaCBvdGhlci5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjd2l0aGluXHJcbiogQHBhcmFtIHtudW1iZXJ9IGEgLSBUaGUgZmlyc3QgbnVtYmVyIHRvIGNoZWNrXHJcbiogQHBhcmFtIHtudW1iZXJ9IGIgLSBUaGUgc2Vjb25kIG51bWJlciB0byBjaGVja1xyXG4qIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgLSBUaGUgdG9sZXJhbmNlLiBBbnl0aGluZyBlcXVhbCB0byBvciBsZXNzIHRoYW4gdGhpcyBpcyBjb25zaWRlcmVkIHdpdGhpbiB0aGUgcmFuZ2UuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGlzIDw9IHRvbGVyYW5jZSBvZiBiLlxyXG4qIEBzZWUge0BsaW5rIFBoYXNlci5NYXRoLmZ1enp5RXF1YWx9XHJcbiovXHJcbnZhciBXaXRoaW4gPSBmdW5jdGlvbiAoYSwgYiwgdG9sZXJhbmNlKVxyXG57XHJcbiAgICByZXR1cm4gKE1hdGguYWJzKGEgLSBiKSA8PSB0b2xlcmFuY2UpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXaXRoaW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvV2l0aGluLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCZXR3ZWVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL0JldHdlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDQyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlblBvaW50cyA9IGZ1bmN0aW9uIChwb2ludDEsIHBvaW50Milcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIocG9pbnQyLnkgLSBwb2ludDEueSwgcG9pbnQyLnggLSBwb2ludDEueCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW5Qb2ludHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvQmV0d2VlblBvaW50cy5qc1xuLy8gbW9kdWxlIGlkID0gNDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZXR3ZWVuUG9pbnRzWSA9IGZ1bmN0aW9uIChwb2ludDEsIHBvaW50Milcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIocG9pbnQyLnggLSBwb2ludDEueCwgcG9pbnQyLnkgLSBwb2ludDEueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW5Qb2ludHNZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL0JldHdlZW5Qb2ludHNZLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW5ZID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih4MiAtIHgxLCB5MiAtIHkxKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV0d2Vlblk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvQmV0d2VlblkuanNcbi8vIG1vZHVsZSBpZCA9IDQyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTm9ybWFsaXplID0gcmVxdWlyZSgnLi9Ob3JtYWxpemUnKTtcclxuXHJcbnZhciBSZXZlcnNlID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICByZXR1cm4gTm9ybWFsaXplKGFuZ2xlICsgTWF0aC5QSSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJldmVyc2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvUmV2ZXJzZS5qc1xuLy8gbW9kdWxlIGlkID0gNDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvYW5nbGUvUmV2ZXJzZS5qcyIsInZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbi8qKlxyXG4qIFJvdGF0ZXMgY3VycmVudEFuZ2xlIHRvd2FyZHMgdGFyZ2V0QW5nbGUsIHRha2luZyB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZGlzdGFuY2UuXHJcbiogVGhlIGxlcnAgYXJndW1lbnQgaXMgdGhlIGFtb3VudCB0byByb3RhdGUgYnkgaW4gdGhpcyBjYWxsLlxyXG4qIFxyXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjcm90YXRlVG9BbmdsZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50QW5nbGUgLSBUaGUgY3VycmVudCBhbmdsZSwgaW4gcmFkaWFucy5cclxuKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0QW5nbGUgLSBUaGUgdGFyZ2V0IGFuZ2xlIHRvIHJvdGF0ZSB0bywgaW4gcmFkaWFucy5cclxuKiBAcGFyYW0ge251bWJlcn0gW2xlcnA9MC4wNV0gLSBUaGUgbGVycCB2YWx1ZSB0byBhZGQgdG8gdGhlIGN1cnJlbnQgYW5nbGUuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgYWRqdXN0ZWQgYW5nbGUuXHJcbiovXHJcbnZhciBSb3RhdGVUbyA9IGZ1bmN0aW9uIChjdXJyZW50QW5nbGUsIHRhcmdldEFuZ2xlLCBsZXJwKVxyXG57XHJcbiAgICBpZiAobGVycCA9PT0gdW5kZWZpbmVkKSB7IGxlcnAgPSAwLjA1OyB9XHJcblxyXG4gICAgaWYgKGN1cnJlbnRBbmdsZSA9PT0gdGFyZ2V0QW5nbGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRBbmdsZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTWF0aC5hYnModGFyZ2V0QW5nbGUgLSBjdXJyZW50QW5nbGUpIDw9IGxlcnAgfHwgTWF0aC5hYnModGFyZ2V0QW5nbGUgLSBjdXJyZW50QW5nbGUpID49IChNQVRIX0NPTlNULlBJMiAtIGxlcnApKVxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbnRBbmdsZSA9IHRhcmdldEFuZ2xlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmIChNYXRoLmFicyh0YXJnZXRBbmdsZSAtIGN1cnJlbnRBbmdsZSkgPiBNYXRoLlBJKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldEFuZ2xlIDwgY3VycmVudEFuZ2xlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRBbmdsZSArPSBNQVRIX0NPTlNULlBJMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldEFuZ2xlIC09IE1BVEhfQ09OU1QuUEkyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGFyZ2V0QW5nbGUgPiBjdXJyZW50QW5nbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdXJyZW50QW5nbGUgKz0gbGVycDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0QW5nbGUgPCBjdXJyZW50QW5nbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdXJyZW50QW5nbGUgLT0gbGVycDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGN1cnJlbnRBbmdsZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlVG87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvUm90YXRlVG8uanNcbi8vIG1vZHVsZSBpZCA9IDQyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL1JvdGF0ZVRvLmpzIiwiLyoqXHJcbiogR2V0cyB0aGUgc2hvcnRlc3QgYW5nbGUgYmV0d2VlbiBgYW5nbGUxYCBhbmQgYGFuZ2xlMmAuXHJcbiogQm90aCBhbmdsZXMgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgLTE4MCB0byAxODAsIHdoaWNoIGlzIHRoZSBzYW1lIGNsYW1wZWRcclxuKiByYW5nZSB0aGF0IGBzcHJpdGUuYW5nbGVgIHVzZXMsIHNvIHlvdSBjYW4gcGFzcyBpbiB0d28gc3ByaXRlIGFuZ2xlcyB0b1xyXG4qIHRoaXMgbWV0aG9kLCBhbmQgZ2V0IHRoZSBzaG9ydGVzdCBhbmdsZSBiYWNrIGJldHdlZW4gdGhlIHR3byBvZiB0aGVtLlxyXG4qXHJcbiogVGhlIGFuZ2xlIHJldHVybmVkIHdpbGwgYmUgaW4gdGhlIHNhbWUgcmFuZ2UuIElmIHRoZSByZXR1cm5lZCBhbmdsZSBpc1xyXG4qIGdyZWF0ZXIgdGhhbiAwIHRoZW4gaXQncyBhIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLCBpZiA8IDAgdGhlbiBpdCdzXHJcbiogYSBjbG9ja3dpc2Ugcm90YXRpb24uXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuTWF0aCNnZXRTaG9ydGVzdEFuZ2xlXHJcbiogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlMSAtIFRoZSBmaXJzdCBhbmdsZS4gSW4gdGhlIHJhbmdlIC0xODAgdG8gMTgwLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBhbmdsZTIgLSBUaGUgc2Vjb25kIGFuZ2xlLiBJbiB0aGUgcmFuZ2UgLTE4MCB0byAxODAuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgc2hvcnRlc3QgYW5nbGUsIGluIGRlZ3JlZXMuIElmIGdyZWF0ZXIgdGhhbiB6ZXJvIGl0J3MgYSBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbi5cclxuKi9cclxudmFyIFNob3J0ZXN0QmV0d2VlbiA9IGZ1bmN0aW9uIChhbmdsZTEsIGFuZ2xlMilcclxue1xyXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBhbmdsZTIgLSBhbmdsZTE7XHJcblxyXG4gICAgaWYgKGRpZmZlcmVuY2UgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRpbWVzID0gTWF0aC5mbG9vcigoZGlmZmVyZW5jZSAtICgtMTgwKSkgLyAzNjApO1xyXG5cclxuICAgIHJldHVybiBkaWZmZXJlbmNlIC0gKHRpbWVzICogMzYwKTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNob3J0ZXN0QmV0d2VlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9TaG9ydGVzdEJldHdlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDQyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBCZXR3ZWVuOiByZXF1aXJlKCcuL0JldHdlZW4nKSxcclxuICAgIEJldHdlZW5ZOiByZXF1aXJlKCcuL0JldHdlZW5ZJyksXHJcbiAgICBCZXR3ZWVuUG9pbnRzOiByZXF1aXJlKCcuL0JldHdlZW5Qb2ludHMnKSxcclxuICAgIEJldHdlZW5Qb2ludHNZOiByZXF1aXJlKCcuL0JldHdlZW5Qb2ludHNZJyksXHJcbiAgICBSZXZlcnNlOiByZXF1aXJlKCcuL1JldmVyc2UnKSxcclxuICAgIFJvdGF0ZVRvOiByZXF1aXJlKCcuL1JvdGF0ZVRvJyksXHJcbiAgICBTaG9ydGVzdEJldHdlZW46IHJlcXVpcmUoJy4vU2hvcnRlc3RCZXR3ZWVuJyksXHJcbiAgICBOb3JtYWxpemU6IHJlcXVpcmUoJy4vTm9ybWFsaXplJyksXHJcbiAgICBXcmFwOiByZXF1aXJlKCcuL1dyYXAnKSxcclxuICAgIFdyYXBEZWdyZWVzOiByZXF1aXJlKCcuL1dyYXBEZWdyZWVzJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL2luZGV4LmpzIiwidmFyIERpc3RhbmNlUG93ZXIgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHBvdylcclxue1xyXG4gICAgaWYgKHBvdyA9PT0gdW5kZWZpbmVkKSB7IHBvdyA9IDI7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIHBvdykgKyBNYXRoLnBvdyh5MiAtIHkxLCBwb3cpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VQb3dlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZVBvd2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Milcclxue1xyXG4gICAgdmFyIGR4ID0geDEgLSB4MjtcclxuICAgIHZhciBkeSA9IHkxIC0geTI7XHJcblxyXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZVNxdWFyZWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VTcXVhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQmV0d2VlbjogcmVxdWlyZSgnLi9EaXN0YW5jZUJldHdlZW4nKSxcclxuICAgIFBvd2VyOiByZXF1aXJlKCcuL0Rpc3RhbmNlUG93ZXInKSxcclxuICAgIFNxdWFyZWQ6IHJlcXVpcmUoJy4vRGlzdGFuY2VTcXVhcmVkJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2Rpc3RhbmNlL2luZGV4LmpzIiwiZnVuY3Rpb24gSW4gKHYsIG92ZXJzaG9vdClcclxue1xyXG4gICAgaWYgKG92ZXJzaG9vdCA9PT0gdW5kZWZpbmVkKSB7IG92ZXJzaG9vdCA9IDEuNzAxNTg7IH1cclxuXHJcbiAgICByZXR1cm4gdiAqIHYgKiAoKG92ZXJzaG9vdCArIDEpICogdiAtIG92ZXJzaG9vdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodiwgb3ZlcnNob290KVxyXG57XHJcbiAgICBpZiAob3ZlcnNob290ID09PSB1bmRlZmluZWQpIHsgb3ZlcnNob290ID0gMS43MDE1ODsgfVxyXG5cclxuICAgIHJldHVybiAtLXYgKiB2ICogKChvdmVyc2hvb3QgKyAxKSAqIHYgKyBvdmVyc2hvb3QpICsgMTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYsIG92ZXJzaG9vdClcclxue1xyXG4gICAgaWYgKG92ZXJzaG9vdCA9PT0gdW5kZWZpbmVkKSB7IG92ZXJzaG9vdCA9IDEuNzAxNTg7IH1cclxuXHJcbiAgICB2YXIgcyA9IG92ZXJzaG9vdCAqIDEuNTI1O1xyXG5cclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICh2ICogdiAqICgocyArIDEpICogdiAtIHMpKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogKCh2IC09IDIpICogdiAqICgocyArIDEpICogdiArIHMpICsgMik7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9CYWNrLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHYgPSAxIC0gdjtcclxuXHJcbiAgICBpZiAodiA8IDEgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gKDcuNTYyNSAqIHYgKiB2KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPCAyIC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiAodiAtPSAxLjUgLyAyLjc1KSAqIHYgKyAwLjc1KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPCAyLjUgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gKDcuNTYyNSAqICh2IC09IDIuMjUgLyAyLjc1KSAqIHYgKyAwLjkzNzUpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gKDcuNTYyNSAqICh2IC09IDIuNjI1IC8gMi43NSkgKiB2ICsgMC45ODQzNzUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIGlmICh2IDwgMSAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqIHYgKiB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA8IDIgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiA3LjU2MjUgKiAodiAtPSAxLjUgLyAyLjc1KSAqIHYgKyAwLjc1O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA8IDIuNSAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqICh2IC09IDIuMjUgLyAyLjc1KSAqIHYgKyAwLjkzNzU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqICh2IC09IDIuNjI1IC8gMi43NSkgKiB2ICsgMC45ODQzNzU7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICB2YXIgcmV2ZXJzZSA9IGZhbHNlO1xyXG5cclxuICAgIGlmICh2IDwgMC41KVxyXG4gICAge1xyXG4gICAgICAgIHYgPSAxIC0gKHYgKiAyKTtcclxuICAgICAgICByZXZlcnNlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2ID0gKHYgKiAyKSAtIDE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHYgPCAxIC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICB2ID0gNy41NjI1ICogdiAqIHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2IDwgMiAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgdiA9IDcuNTYyNSAqICh2IC09IDEuNSAvIDIuNzUpICogdiArIDAuNzU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2IDwgMi41IC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICB2ID0gNy41NjI1ICogKHYgLT0gMi4yNSAvIDIuNzUpICogdiArIDAuOTM3NTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2ID0gNy41NjI1ICogKHYgLT0gMi42MjUgLyAyLjc1KSAqIHYgKyAwLjk4NDM3NTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmV2ZXJzZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKDEgLSB2KSAqIDAuNTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdiAqIDAuNSArIDAuNTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0JvdW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gNDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdiAqIHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLXYgKiB2KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdiAqIHYpIC0gMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh2IC09IDIpICogdikgKyAxKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0NpcmN1bGFyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHJldHVybiB2ICogdiAqIHY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIC0tdiAqIHYgKiB2ICsgMTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogKCh2IC09IDIpICogdiAqIHYgKyAyKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0N1YmljLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYsIGFtcGxpdHVkZSwgcGVyaW9kKVxyXG57XHJcbiAgICBpZiAoYW1wbGl0dWRlID09PSB1bmRlZmluZWQpIHsgYW1wbGl0dWRlID0gMC4xOyB9XHJcbiAgICBpZiAocGVyaW9kID09PSB1bmRlZmluZWQpIHsgcGVyaW9kID0gMC4xOyB9XHJcblxyXG4gICAgaWYgKHYgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzID0gcGVyaW9kIC8gNDtcclxuXHJcbiAgICAgICAgaWYgKGFtcGxpdHVkZSA8IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbXBsaXR1ZGUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzID0gcGVyaW9kICogTWF0aC5hc2luKDEgLyBhbXBsaXR1ZGUpIC8gKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIDEwICogKHYgLT0gMSkpICogTWF0aC5zaW4oKHYgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwZXJpb2QpKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2LCBhbXBsaXR1ZGUsIHBlcmlvZClcclxue1xyXG4gICAgaWYgKGFtcGxpdHVkZSA9PT0gdW5kZWZpbmVkKSB7IGFtcGxpdHVkZSA9IDAuMTsgfVxyXG4gICAgaWYgKHBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7IHBlcmlvZCA9IDAuMTsgfVxyXG5cclxuICAgIGlmICh2ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgcyA9IHBlcmlvZCAvIDQ7XHJcblxyXG4gICAgICAgIGlmIChhbXBsaXR1ZGUgPCAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYW1wbGl0dWRlID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcyA9IHBlcmlvZCAqIE1hdGguYXNpbigxIC8gYW1wbGl0dWRlKSAvICgyICogTWF0aC5QSSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIC0xMCAqIHYpICogTWF0aC5zaW4oKHYgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwZXJpb2QpICsgMSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2LCBhbXBsaXR1ZGUsIHBlcmlvZClcclxue1xyXG4gICAgaWYgKGFtcGxpdHVkZSA9PT0gdW5kZWZpbmVkKSB7IGFtcGxpdHVkZSA9IDAuMTsgfVxyXG4gICAgaWYgKHBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7IHBlcmlvZCA9IDAuMTsgfVxyXG5cclxuICAgIGlmICh2ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgcyA9IHBlcmlvZCAvIDQ7XHJcblxyXG4gICAgICAgIGlmIChhbXBsaXR1ZGUgPCAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYW1wbGl0dWRlID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcyA9IHBlcmlvZCAqIE1hdGguYXNpbigxIC8gYW1wbGl0dWRlKSAvICgyICogTWF0aC5QSSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoYW1wbGl0dWRlICogTWF0aC5wb3coMiwgMTAgKiAodiAtPSAxKSkgKiBNYXRoLnNpbigodiAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHBlcmlvZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1wbGl0dWRlICogTWF0aC5wb3coMiwgLTEwICogKHYgLT0gMSkpICogTWF0aC5zaW4oKHYgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwZXJpb2QpICogMC41ICsgMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9FbGFzdGljLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqICh2IC0gMSkpIC0gMC4wMDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiB2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIDEwICogKHYgLSAxKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHYgLSAxKSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvRXhwby5qc1xuLy8gbW9kdWxlIGlkID0gNDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIExpbmVhciBFYXNpbmcgKG5vIHZhcmlhdGlvbikuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkVhc2luZy5MaW5lYXIjTm9uZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSB2IC0gVGhlIHZhbHVlIHRvIGJlIHR3ZWVuZWQuXHJcbiogQHJldHVybnMge251bWJlcn0gdi5cclxuKi9cclxudmFyIExpbmVhciA9IGZ1bmN0aW9uICh2KVxyXG57XHJcbiAgICByZXR1cm4gdjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZWFyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9MaW5lYXIuanNcbi8vIG1vZHVsZSBpZCA9IDQzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgcmV0dXJuIHYgKiB2O1xyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIHJldHVybiB2ICogKDIgLSB2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAtMC41ICogKC0tdiAqICh2IC0gMikgLSAxKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL1F1YWRyYXRpYy5qc1xuLy8gbW9kdWxlIGlkID0gNDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gdiAqIHYgKiB2ICogdjtcclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICByZXR1cm4gMSAtICgtLXYgKiB2ICogdiAqIHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogdiAqIHYgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gLTAuNSAqICgodiAtPSAyKSAqIHYgKiB2ICogdiAtIDIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvUXVhcnRpYy5qc1xuLy8gbW9kdWxlIGlkID0gNDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gdiAqIHYgKiB2ICogdiAqIHY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIC0tdiAqIHYgKiB2ICogdiAqIHYgKyAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogdiAqIHYgKiB2ICogdiAqIHY7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgodiAtPSAyKSAqIHYgKiB2ICogdiAqIHYgKyAyKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL1F1aW50aWMuanNcbi8vIG1vZHVsZSBpZCA9IDQ0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgaWYgKHYgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3ModiAqIE1hdGguUEkgLyAyKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICBpZiAodiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKHYgKiBNYXRoLlBJIC8gMik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAodiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIHYpKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL1NpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDQ0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBCYWNrOiByZXF1aXJlKCcuL0JhY2snKSxcclxuICAgIEJvdW5jZTogcmVxdWlyZSgnLi9Cb3VuY2UnKSxcclxuICAgIENpcmN1bGFyOiByZXF1aXJlKCcuL0NpcmN1bGFyJyksXHJcbiAgICBDdWJpYzogcmVxdWlyZSgnLi9DdWJpYycpLFxyXG4gICAgRWxhc3RpYzogcmVxdWlyZSgnLi9FbGFzdGljJyksXHJcbiAgICBFeHBvOiByZXF1aXJlKCcuL0V4cG8nKSxcclxuICAgIExpbmVhcjogcmVxdWlyZSgnLi9MaW5lYXInKSxcclxuICAgIFF1YWRyYXRpYzogcmVxdWlyZSgnLi9RdWFkcmF0aWMnKSxcclxuICAgIFF1YXJ0aWM6IHJlcXVpcmUoJy4vUXVhcnRpYycpLFxyXG4gICAgUXVpbnRpYzogcmVxdWlyZSgnLi9RdWludGljJyksXHJcbiAgICBTaW5lOiByZXF1aXJlKCcuL1NpbmUnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2Vhc2luZy9pbmRleC5qcyIsInZhciBDZWlsID0gZnVuY3Rpb24gKHZhbHVlLCBlcHNpbG9uKVxyXG57XHJcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKHZhbHVlIC0gZXBzaWxvbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlaWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvQ2VpbC5qc1xuLy8gbW9kdWxlIGlkID0gNDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbCA9IGZ1bmN0aW9uIChhLCBiLCBlcHNpbG9uKVxyXG57XHJcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgZXBzaWxvbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvRXF1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvb3IgPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUgKyBlcHNpbG9uKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmxvb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvRmxvb3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR3JlYXRlclRoYW4gPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIGEgPiBiIC0gZXBzaWxvbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JlYXRlclRoYW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvR3JlYXRlclRoYW4uanNcbi8vIG1vZHVsZSBpZCA9IDQ0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGVzc1RoYW4gPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIGEgPCBiICsgZXBzaWxvbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGVzc1RoYW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvTGVzc1RoYW4uanNcbi8vIG1vZHVsZSBpZCA9IDQ0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBDZWlsOiByZXF1aXJlKCcuL0NlaWwnKSxcclxuICAgIEVxdWFsOiByZXF1aXJlKCcuL0VxdWFsJyksXHJcbiAgICBGbG9vcjogcmVxdWlyZSgnLi9GbG9vcicpLFxyXG4gICAgR3JlYXRlclRoYW46IHJlcXVpcmUoJy4vR3JlYXRlclRoYW4nKSxcclxuICAgIExlc3NUaGFuOiByZXF1aXJlKCcuL0xlc3NUaGFuJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2Z1enp5L2luZGV4LmpzIiwidmFyIEJlcm5zdGVpbiA9IHJlcXVpcmUoJy4uL0Jlcm5zdGVpbicpO1xyXG5cclxudmFyIEJlemllckludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodiwgaylcclxue1xyXG4gICAgdmFyIGIgPSAwO1xyXG4gICAgdmFyIG4gPSB2Lmxlbmd0aCAtIDE7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGIgKz0gTWF0aC5wb3coMSAtIGssIG4gLSBpKSAqIE1hdGgucG93KGssIGkpICogdltpXSAqIEJlcm5zdGVpbihuLCBpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV6aWVySW50ZXJwb2xhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0JlemllckludGVycG9sYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDQ1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2ludGVycG9sYXRpb24vQmV6aWVySW50ZXJwb2xhdGlvbi5qcyIsInZhciBDYXRtdWxsUm9tID0gcmVxdWlyZSgnLi4vQ2F0bXVsbFJvbScpO1xyXG5cclxudmFyIENhdG11bGxSb21JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHYsIGspXHJcbntcclxuICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xyXG4gICAgdmFyIGYgPSBtICogaztcclxuICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcclxuXHJcbiAgICBpZiAodlswXSA9PT0gdlttXSlcclxuICAgIHtcclxuICAgICAgICBpZiAoayA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpID0gTWF0aC5mbG9vcihmID0gbSAqICgxICsgaykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIENhdG11bGxSb20odlsoaSAtIDEgKyBtKSAlIG1dLCB2W2ldLCB2WyhpICsgMSkgJSBtXSwgdlsoaSArIDIpICUgbV0sIGYgLSBpKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZiAoayA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdlswXSAtIChDYXRtdWxsUm9tKHZbMF0sIHZbMF0sIHZbMV0sIHZbMV0sIC1mKSAtIHZbMF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGsgPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZbbV0gLSAoQ2F0bXVsbFJvbSh2W21dLCB2W21dLCB2W20gLSAxXSwgdlttIC0gMV0sIGYgLSBtKSAtIHZbbV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIENhdG11bGxSb20odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2F0bXVsbFJvbUludGVycG9sYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW50ZXJwb2xhdGlvbi9DYXRtdWxsUm9tSW50ZXJwb2xhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9DYXRtdWxsUm9tSW50ZXJwb2xhdGlvbi5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEJlemllcjogcmVxdWlyZSgnLi9CZXppZXJJbnRlcnBvbGF0aW9uJyksXHJcbiAgICBDYXRtdWxsUm9tOiByZXF1aXJlKCcuL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uJyksXHJcbiAgICBMaW5lYXI6IHJlcXVpcmUoJy4vTGluZWFySW50ZXJwb2xhdGlvbicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2ludGVycG9sYXRpb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2ludGVycG9sYXRpb24vaW5kZXguanMiLCIvLyAgVGFrZXMgdmFsdWUgYW5kIHJldHVybnMgdGhlIG5lYXJlc3QgcG93ZXIgb2YgMlxyXG5cclxudmFyIEdldFBvd2VyT2ZUd28gPSBmdW5jdGlvbiAodmFsdWUpXHJcbntcclxuICAgIC8vICBNYXRoLmxvZygyKVxyXG4gICAgdmFyIGluZGV4ID0gTWF0aC5sb2codmFsdWUpIC8gMC42OTMxNDcxODA1NTk5NDUzO1xyXG5cclxuICAgIHJldHVybiAoMSA8PCBNYXRoLmNlaWwoaW5kZXgpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UG93ZXJPZlR3bztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9wb3cyL0dldFBvd2VyT2ZUd28uanNcbi8vIG1vZHVsZSBpZCA9IDQ1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgSXMgdmFsdWUgYSBwb3dlciBvZiAyP1xyXG5cclxudmFyIElzVmFsdWVQb3dlck9mVHdvID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICByZXR1cm4gKHZhbHVlID4gMCAmJiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJc1ZhbHVlUG93ZXJPZlR3bztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9wb3cyL0lzVmFsdWVQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9wb3cyL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydCA9IHtcclxuXHJcbiAgICBHZXROZXh0OiByZXF1aXJlKCcuL0dldFBvd2VyT2ZUd28nKSxcclxuICAgIElzU2l6ZTogcmVxdWlyZSgnLi9Jc1NpemVQb3dlck9mVHdvJyksXHJcbiAgICBJc1ZhbHVlOiByZXF1aXJlKCcuL0lzVmFsdWVQb3dlck9mVHdvJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcG93Mi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBjIC0gSW50ZXJuYWwgdmFyLlxyXG4qIEBwcml2YXRlXHJcbiovXHJcbnZhciBjID0gMTtcclxuXHJcbi8qKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBzMCAtIEludGVybmFsIHZhci5cclxuKiBAcHJpdmF0ZVxyXG4qL1xyXG52YXIgczAgPSAwO1xyXG5cclxuLyoqXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IHMxIC0gSW50ZXJuYWwgdmFyLlxyXG4qIEBwcml2YXRlXHJcbiovXHJcbnZhciBzMSA9IDA7XHJcblxyXG4vKipcclxuKiBAcHJvcGVydHkge251bWJlcn0gczIgLSBJbnRlcm5hbCB2YXIuXHJcbiogQHByaXZhdGVcclxuKi9cclxudmFyIHMyID0gMDtcclxuXHJcbi8qKlxyXG4qIEBwcm9wZXJ0eSB7QXJyYXl9IHNpZ24gLSBJbnRlcm5hbCB2YXIuXHJcbiogQHByaXZhdGVcclxuKi9cclxudmFyIHNpZ24gPSBbIC0xLCAxIF07XHJcblxyXG4vKipcclxuKiBQcml2YXRlIHJhbmRvbSBoZWxwZXIuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3JuZFxyXG4qIEBwcml2YXRlXHJcbiogQHJldHVybiB7bnVtYmVyfVxyXG4qL1xyXG52YXIgcm5kID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIHQgPSAyMDkxNjM5ICogczAgKyBjICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcclxuXHJcbiAgICBjID0gdCB8IDA7XHJcbiAgICBzMCA9IHMxO1xyXG4gICAgczEgPSBzMjtcclxuICAgIHMyID0gdCAtIGM7XHJcblxyXG4gICAgcmV0dXJuIHMyO1xyXG59O1xyXG5cclxuLyoqXHJcbiogSW50ZXJuYWwgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHNlZWQgaGFzaC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjaGFzaFxyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtIHthbnl9IGRhdGFcclxuKiBAcmV0dXJuIHtudW1iZXJ9IGhhc2hlZCB2YWx1ZS5cclxuKi9cclxudmFyIGhhc2ggPSBmdW5jdGlvbiAoZGF0YSlcclxue1xyXG4gICAgdmFyIGgsIGksIG47XHJcbiAgICBuID0gMHhlZmM4MjQ5ZDtcclxuICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xyXG4gICAgICAgIG4gPSBoID4+PiAwO1xyXG4gICAgICAgIGggLT0gbjtcclxuICAgICAgICBoICo9IG47XHJcbiAgICAgICAgbiA9IGggPj4+IDA7XHJcbiAgICAgICAgaCAtPSBuO1xyXG4gICAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOy8vIDJeMzJcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsvLyAyXi0zMlxyXG59O1xyXG5cclxuXHJcbnZhciBSYW5kb21EYXRhR2VuZXJhdG9yID0gZnVuY3Rpb24gKHNlZWRzKVxyXG57XHJcbiAgICBpZiAoc2VlZHMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5pbml0KHNlZWRzKTtcclxuICAgIH1cclxufTtcclxuXHJcblJhbmRvbURhdGFHZW5lcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFuZG9tRGF0YUdlbmVyYXRvcjtcclxuXHJcblJhbmRvbURhdGFHZW5lcmF0b3IucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChzZWVkcylcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNlZWRzID09PSAnc3RyaW5nJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUoc2VlZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNvdyhzZWVkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmVzZXQgdGhlIHNlZWQgb2YgdGhlIHJhbmRvbSBkYXRhIGdlbmVyYXRvci5cclxuICAgICpcclxuICAgICogX05vdGVfOiB0aGUgc2VlZCBhcnJheSBpcyBvbmx5IHByb2Nlc3NlZCB1cCB0byB0aGUgZmlyc3QgYHVuZGVmaW5lZGAgKG9yIGBudWxsYCkgdmFsdWUsIHNob3VsZCBzdWNoIGJlIHByZXNlbnQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijc293XHJcbiAgICAqIEBwYXJhbSB7YW55W119IHNlZWRzIC0gVGhlIGFycmF5IG9mIHNlZWRzOiB0aGUgYHRvU3RyaW5nKClgIG9mIGVhY2ggdmFsdWUgaXMgdXNlZC5cclxuICAgICovXHJcbiAgICBzb3c6IGZ1bmN0aW9uIChzZWVkcylcclxuICAgIHtcclxuICAgICAgICAvLyBBbHdheXMgcmVzZXQgdG8gZGVmYXVsdCBzZWVkXHJcbiAgICAgICAgczAgPSBoYXNoKCcgJyk7XHJcbiAgICAgICAgczEgPSBoYXNoKHMwKTtcclxuICAgICAgICBzMiA9IGhhc2goczEpO1xyXG4gICAgICAgIGMgPSAxO1xyXG5cclxuICAgICAgICBpZiAoIXNlZWRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgYW55IHNlZWRzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWVkcy5sZW5ndGggJiYgKHNlZWRzW2ldICE9IG51bGwpOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc2VlZCA9IHNlZWRzW2ldO1xyXG5cclxuICAgICAgICAgICAgczAgLT0gaGFzaChzZWVkKTtcclxuICAgICAgICAgICAgczAgKz0gfn4oczAgPCAwKTtcclxuICAgICAgICAgICAgczEgLT0gaGFzaChzZWVkKTtcclxuICAgICAgICAgICAgczEgKz0gfn4oczEgPCAwKTtcclxuICAgICAgICAgICAgczIgLT0gaGFzaChzZWVkKTtcclxuICAgICAgICAgICAgczIgKz0gfn4oczIgPCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMl4zMi5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNpbnRlZ2VyXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDJeMzIuXHJcbiAgICAqL1xyXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAyXjMyXHJcbiAgICAgICAgcmV0dXJuIHJuZCgpICogMHgxMDAwMDAwMDA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNmcmFjXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgKi9cclxuICAgIGZyYWM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gMl4tNTNcclxuICAgICAgICByZXR1cm4gcm5kKCkgKyAocm5kKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAwIGFuZCAyXjMyLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3JlYWxcclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIDAgYW5kIDJeMzIuXHJcbiAgICAqL1xyXG4gICAgcmVhbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKCkgKyB0aGlzLmZyYWMoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIGFuZCBpbmNsdWRpbmcgbWluIGFuZCBtYXguXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjaW50ZWdlckluUmFuZ2VcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICAgICovXHJcbiAgICBpbnRlZ2VySW5SYW5nZTogZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMucmVhbEluUmFuZ2UoMCwgbWF4IC0gbWluICsgMSkgKyBtaW4pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gYW5kIGluY2x1ZGluZyBtaW4gYW5kIG1heC5cclxuICAgICogVGhpcyBtZXRob2QgaXMgYW4gYWxpYXMgZm9yIFJhbmRvbURhdGFHZW5lcmF0b3IuaW50ZWdlckluUmFuZ2UuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjYmV0d2VlblxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxyXG4gICAgKi9cclxuICAgIGJldHdlZW46IGZ1bmN0aW9uIChtaW4sIG1heClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VySW5SYW5nZShtaW4sIG1heCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXguXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjcmVhbEluUmFuZ2VcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICAgICovXHJcbiAgICByZWFsSW5SYW5nZTogZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyYWMoKSAqIChtYXggLSBtaW4pICsgbWluO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIC0xIGFuZCAxLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI25vcm1hbFxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gLTEgYW5kIDEuXHJcbiAgICAqL1xyXG4gICAgbm9ybWFsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gKDIgKiB0aGlzLmZyYWMoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgdmFsaWQgUkZDNDEyMiB2ZXJzaW9uNCBJRCBoZXggc3RyaW5nIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTMwODM2OFxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3V1aWRcclxuICAgICogQHJldHVybiB7c3RyaW5nfSBBIHZhbGlkIFJGQzQxMjIgdmVyc2lvbjQgSUQgaGV4IHN0cmluZ1xyXG4gICAgKi9cclxuICAgIHV1aWQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSAnJztcclxuICAgICAgICB2YXIgYiA9ICcnO1xyXG5cclxuICAgICAgICBmb3IgKGIgPSBhID0gJyc7IGErKyA8IDM2OyBiICs9fmEgJSA1IHwgYSAqIDMmNCA/IChhXjE1ID8gOF50aGlzLmZyYWMoKSAqIChhXjIwID8gMTYgOiA0KSA6IDQpLnRvU3RyaW5nKDE2KSA6ICctJylcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gbWVtYmVyIG9mIGBhcnJheWAuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjcGlja1xyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEFuIEFycmF5IHRvIHBpY2sgYSByYW5kb20gbWVtYmVyIG9mLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IEEgcmFuZG9tIG1lbWJlciBvZiB0aGUgYXJyYXkuXHJcbiAgICAqL1xyXG4gICAgcGljazogZnVuY3Rpb24gKGFycmF5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBhcnJheVt0aGlzLmludGVnZXJJblJhbmdlKDAsIGFycmF5Lmxlbmd0aCAtIDEpXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSBzaWduIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsaWNhdGlvbiBvcGVyYXRvci5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNzaWduXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gLTEgb3IgKzEuXHJcbiAgICAqL1xyXG4gICAgc2lnbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5waWNrKHNpZ24pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBtZW1iZXIgb2YgYGFycmF5YCwgZmF2b3JpbmcgdGhlIGVhcmxpZXIgZW50cmllcy5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciN3ZWlnaHRlZFBpY2tcclxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBBbiBBcnJheSB0byBwaWNrIGEgcmFuZG9tIG1lbWJlciBvZi5cclxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBtZW1iZXIgb2YgdGhlIGFycmF5LlxyXG4gICAgKi9cclxuICAgIHdlaWdodGVkUGljazogZnVuY3Rpb24gKGFycmF5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBhcnJheVt+fihNYXRoLnBvdyh0aGlzLmZyYWMoKSwgMikgKiAoYXJyYXkubGVuZ3RoIC0gMSkgKyAwLjUpXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gdGltZXN0YW1wIGJldHdlZW4gbWluIGFuZCBtYXgsIG9yIGJldHdlZW4gdGhlIGJlZ2lubmluZyBvZiAyMDAwIGFuZCB0aGUgZW5kIG9mIDIwMjAgaWYgbWluIGFuZCBtYXggYXJlbid0IHNwZWNpZmllZC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciN0aW1lc3RhbXBcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSB0aW1lc3RhbXAgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICAgICovXHJcbiAgICB0aW1lc3RhbXA6IGZ1bmN0aW9uIChtaW4sIG1heClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFsSW5SYW5nZShtaW4gfHwgOTQ2Njg0ODAwMDAwLCBtYXggfHwgMTU3Nzg2MjAwMDAwMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGFuZ2xlIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2FuZ2xlXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxyXG4gICAgKi9cclxuICAgIGFuZ2xlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXJJblJhbmdlKC0xODAsIDE4MCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJvdGF0aW9uIGluIHJhZGlhbnMsIGJldHdlZW4gLTMuMTQxIGFuZCAzLjE0MVxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3JvdGF0aW9uXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gLTMuMTQxIGFuZCAzLjE0MVxyXG4gICAgKi9cclxuICAgIHJvdGF0aW9uOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWxJblJhbmdlKC0zLjE0MTU5MjY1MzU4OTc5MywgMy4xNDE1OTI2NTM1ODk3OTMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogR2V0cyBvciBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgZ2VuZXJhdG9yLiBUaGlzIGFsbG93cyB5b3UgdG8gcmV0YWluIHRoZSB2YWx1ZXNcclxuICAgICogdGhhdCB0aGUgZ2VuZXJhdG9yIGlzIHVzaW5nIGJldHdlZW4gZ2FtZXMsIGkuZS4gaW4gYSBnYW1lIHNhdmUgZmlsZS5cclxuICAgICpcclxuICAgICogVG8gc2VlZCB0aGlzIGdlbmVyYXRvciB3aXRoIGEgcHJldmlvdXNseSBzYXZlZCBzdGF0ZSB5b3UgY2FuIHBhc3MgaXQgYXMgdGhlXHJcbiAgICAqIGBzZWVkYCB2YWx1ZSBpbiB5b3VyIGdhbWUgY29uZmlnLCBvciBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5IGFmdGVyIFBoYXNlciBoYXMgYm9vdGVkLlxyXG4gICAgKlxyXG4gICAgKiBDYWxsIHRoaXMgbWV0aG9kIHdpdGggbm8gcGFyYW1ldGVycyB0byByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAgICAqXHJcbiAgICAqIElmIHByb3ZpZGluZyBhIHN0YXRlIGl0IHNob3VsZCBtYXRjaCB0aGUgc2FtZSBmb3JtYXQgdGhhdCB0aGlzIG1ldGhvZFxyXG4gICAgKiByZXR1cm5zLCB3aGljaCBpcyBhIHN0cmluZyB3aXRoIGEgaGVhZGVyIGAhcm5kYCBmb2xsb3dlZCBieSB0aGUgYGNgLFxyXG4gICAgKiBgczBgLCBgczFgIGFuZCBgczJgIHZhbHVlcyByZXNwZWN0aXZlbHksIGVhY2ggY29tbWEtZGVsaW1pdGVkLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3N0YXRlXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RhdGVdIC0gR2VuZXJhdG9yIHN0YXRlIHRvIGJlIHNldC5cclxuICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2VuZXJhdG9yLlxyXG4gICAgKi9cclxuICAgIHN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3N0cmluZycgJiYgc3RhdGUubWF0Y2goL14hcm5kLykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnNwbGl0KCcsJyk7XHJcblxyXG4gICAgICAgICAgICBjID0gcGFyc2VGbG9hdChzdGF0ZVsxXSk7XHJcbiAgICAgICAgICAgIHMwID0gcGFyc2VGbG9hdChzdGF0ZVsyXSk7XHJcbiAgICAgICAgICAgIHMxID0gcGFyc2VGbG9hdChzdGF0ZVszXSk7XHJcbiAgICAgICAgICAgIHMyID0gcGFyc2VGbG9hdChzdGF0ZVs0XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gWyAnIXJuZCcsIGMsIHMwLCBzMSwgczIgXS5qb2luKCcsJyk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21EYXRhR2VuZXJhdG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3JhbmRvbS1kYXRhLWdlbmVyYXRvci9SYW5kb21EYXRhR2VuZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNuYXBDZWlsID0gZnVuY3Rpb24gKHZhbHVlLCBnYXAsIHN0YXJ0KVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuXHJcbiAgICBpZiAoZ2FwID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZSAtPSBzdGFydDtcclxuICAgIHZhbHVlID0gZ2FwICogTWF0aC5jZWlsKHZhbHVlIC8gZ2FwKTtcclxuXHJcbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU25hcENlaWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvc25hcC9TbmFwQ2VpbC5qc1xuLy8gbW9kdWxlIGlkID0gNDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwRmxvb3IgPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXHJcbntcclxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxyXG5cclxuICAgIGlmIChnYXAgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlIC09IHN0YXJ0O1xyXG4gICAgdmFsdWUgPSBnYXAgKiBNYXRoLmZsb29yKHZhbHVlIC8gZ2FwKTtcclxuXHJcbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU25hcEZsb29yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3NuYXAvU25hcEZsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNuYXBUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgZ2FwLCBzdGFydClcclxue1xyXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XHJcblxyXG4gICAgaWYgKGdhcCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFsdWUgLT0gc3RhcnQ7XHJcbiAgICB2YWx1ZSA9IGdhcCAqIE1hdGgucm91bmQodmFsdWUgLyBnYXApO1xyXG5cclxuICAgIHJldHVybiBzdGFydCArIHZhbHVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbmFwVG87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvc25hcC9TbmFwVG8uanNcbi8vIG1vZHVsZSBpZCA9IDQ2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBDZWlsOiByZXF1aXJlKCcuL1NuYXBDZWlsJyksXHJcbiAgICBGbG9vcjogcmVxdWlyZSgnLi9TbmFwRmxvb3InKSxcclxuICAgIFRvOiByZXF1aXJlKCcuL1NuYXBUbycpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3NuYXAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL3NuYXAvaW5kZXguanMiLCIvKipcclxuKiBUaGUgYE1hdHRlci5RdWVyeWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIHBlcmZvcm1pbmcgY29sbGlzaW9uIHF1ZXJpZXMuXHJcbipcclxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxyXG4qXHJcbiogQGNsYXNzIFF1ZXJ5XHJcbiovXHJcblxyXG52YXIgUXVlcnkgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XHJcblxyXG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XHJcbnZhciBTQVQgPSByZXF1aXJlKCcuL1NBVCcpO1xyXG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcbnZhciBCb2RpZXMgPSByZXF1aXJlKCcuLi9mYWN0b3J5L0JvZGllcycpO1xyXG52YXIgVmVydGljZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FzdHMgYSByYXkgc2VnbWVudCBhZ2FpbnN0IGEgc2V0IG9mIGJvZGllcyBhbmQgcmV0dXJucyBhbGwgY29sbGlzaW9ucywgcmF5IHdpZHRoIGlzIG9wdGlvbmFsLiBJbnRlcnNlY3Rpb24gcG9pbnRzIGFyZSBub3QgcHJvdmlkZWQuXHJcbiAgICAgKiBAbWV0aG9kIHJheVxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHN0YXJ0UG9pbnRcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBlbmRQb2ludFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYXlXaWR0aF1cclxuICAgICAqIEByZXR1cm4ge29iamVjdFtdfSBDb2xsaXNpb25zXHJcbiAgICAgKi9cclxuICAgIFF1ZXJ5LnJheSA9IGZ1bmN0aW9uKGJvZGllcywgc3RhcnRQb2ludCwgZW5kUG9pbnQsIHJheVdpZHRoKSB7XHJcbiAgICAgICAgcmF5V2lkdGggPSByYXlXaWR0aCB8fCAxZS0xMDA7XHJcblxyXG4gICAgICAgIHZhciByYXlBbmdsZSA9IFZlY3Rvci5hbmdsZShzdGFydFBvaW50LCBlbmRQb2ludCksXHJcbiAgICAgICAgICAgIHJheUxlbmd0aCA9IFZlY3Rvci5tYWduaXR1ZGUoVmVjdG9yLnN1YihzdGFydFBvaW50LCBlbmRQb2ludCkpLFxyXG4gICAgICAgICAgICByYXlYID0gKGVuZFBvaW50LnggKyBzdGFydFBvaW50LngpICogMC41LFxyXG4gICAgICAgICAgICByYXlZID0gKGVuZFBvaW50LnkgKyBzdGFydFBvaW50LnkpICogMC41LFxyXG4gICAgICAgICAgICByYXkgPSBCb2RpZXMucmVjdGFuZ2xlKHJheVgsIHJheVksIHJheUxlbmd0aCwgcmF5V2lkdGgsIHsgYW5nbGU6IHJheUFuZ2xlIH0pLFxyXG4gICAgICAgICAgICBjb2xsaXNpb25zID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChCb3VuZHMub3ZlcmxhcHMoYm9keUEuYm91bmRzLCByYXkuYm91bmRzKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGJvZHlBLnBhcnRzLmxlbmd0aCA9PT0gMSA/IDAgOiAxOyBqIDwgYm9keUEucGFydHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHlBLnBhcnRzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQm91bmRzLm92ZXJsYXBzKHBhcnQuYm91bmRzLCByYXkuYm91bmRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uID0gU0FULmNvbGxpZGVzKHBhcnQsIHJheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb24uY29sbGlkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbi5ib2R5ID0gY29sbGlzaW9uLmJvZHlBID0gY29sbGlzaW9uLmJvZHlCID0gYm9keUE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25zLnB1c2goY29sbGlzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29sbGlzaW9ucztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBib2RpZXMgd2hvc2UgYm91bmRzIGFyZSBpbnNpZGUgKG9yIG91dHNpZGUgaWYgc2V0KSB0aGUgZ2l2ZW4gc2V0IG9mIGJvdW5kcywgZnJvbSB0aGUgZ2l2ZW4gc2V0IG9mIGJvZGllcy5cclxuICAgICAqIEBtZXRob2QgcmVnaW9uXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtvdXRzaWRlPWZhbHNlXVxyXG4gICAgICogQHJldHVybiB7Ym9keVtdfSBUaGUgYm9kaWVzIG1hdGNoaW5nIHRoZSBxdWVyeVxyXG4gICAgICovXHJcbiAgICBRdWVyeS5yZWdpb24gPSBmdW5jdGlvbihib2RpZXMsIGJvdW5kcywgb3V0c2lkZSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXHJcbiAgICAgICAgICAgICAgICBvdmVybGFwcyA9IEJvdW5kcy5vdmVybGFwcyhib2R5LmJvdW5kcywgYm91bmRzKTtcclxuICAgICAgICAgICAgaWYgKChvdmVybGFwcyAmJiAhb3V0c2lkZSkgfHwgKCFvdmVybGFwcyAmJiBvdXRzaWRlKSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJvZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBib2RpZXMgd2hvc2UgdmVydGljZXMgY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQsIGZyb20gdGhlIGdpdmVuIHNldCBvZiBib2RpZXMuXHJcbiAgICAgKiBAbWV0aG9kIHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcclxuICAgICAqIEByZXR1cm4ge2JvZHlbXX0gVGhlIGJvZGllcyBtYXRjaGluZyB0aGUgcXVlcnlcclxuICAgICAqL1xyXG4gICAgUXVlcnkucG9pbnQgPSBmdW5jdGlvbihib2RpZXMsIHBvaW50KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMoYm9keS5ib3VuZHMsIHBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGJvZHkucGFydHMubGVuZ3RoID09PSAxID8gMCA6IDE7IGogPCBib2R5LnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKHBhcnQuYm91bmRzLCBwb2ludClcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgVmVydGljZXMuY29udGFpbnMocGFydC52ZXJ0aWNlcywgcG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1F1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1F1ZXJ5LmpzIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuTW91c2VDb25zdHJhaW50YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgbW91c2UgY29uc3RyYWludHMuXHJcbiogTW91c2UgY29uc3RyYWludHMgYXJlIHVzZWQgZm9yIGFsbG93aW5nIHVzZXIgaW50ZXJhY3Rpb24sIHByb3ZpZGluZyB0aGUgYWJpbGl0eSB0byBtb3ZlIGJvZGllcyB2aWEgdGhlIG1vdXNlIG9yIHRvdWNoLlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuKlxyXG4qIEBjbGFzcyBNb3VzZUNvbnN0cmFpbnRcclxuKi9cclxuXHJcbnZhciBNb3VzZUNvbnN0cmFpbnQgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2VDb25zdHJhaW50O1xyXG5cclxudmFyIFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVydGljZXMnKTtcclxudmFyIFNsZWVwaW5nID0gcmVxdWlyZSgnLi4vY29yZS9TbGVlcGluZycpO1xyXG52YXIgTW91c2UgPSByZXF1aXJlKCcuLi9jb3JlL01vdXNlJyk7XHJcbnZhciBFdmVudHMgPSByZXF1aXJlKCcuLi9jb3JlL0V2ZW50cycpO1xyXG52YXIgRGV0ZWN0b3IgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vRGV0ZWN0b3InKTtcclxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcclxudmFyIENvbXBvc2l0ZSA9IHJlcXVpcmUoJy4uL2JvZHkvQ29tcG9zaXRlJyk7XHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1vdXNlIGNvbnN0cmFpbnQuXHJcbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxyXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7TW91c2VDb25zdHJhaW50fSBBIG5ldyBNb3VzZUNvbnN0cmFpbnRcclxuICAgICAqL1xyXG4gICAgTW91c2VDb25zdHJhaW50LmNyZWF0ZSA9IGZ1bmN0aW9uKGVuZ2luZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBtb3VzZSA9IChlbmdpbmUgPyBlbmdpbmUubW91c2UgOiBudWxsKSB8fCAob3B0aW9ucyA/IG9wdGlvbnMubW91c2UgOiBudWxsKTtcclxuXHJcbiAgICAgICAgaWYgKCFtb3VzZSkge1xyXG4gICAgICAgICAgICBpZiAoZW5naW5lICYmIGVuZ2luZS5yZW5kZXIgJiYgZW5naW5lLnJlbmRlci5jYW52YXMpIHtcclxuICAgICAgICAgICAgICAgIG1vdXNlID0gTW91c2UuY3JlYXRlKGVuZ2luZS5yZW5kZXIuY2FudmFzKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgbW91c2UgPSBNb3VzZS5jcmVhdGUob3B0aW9ucy5lbGVtZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vdXNlID0gTW91c2UuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignTW91c2VDb25zdHJhaW50LmNyZWF0ZTogb3B0aW9ucy5tb3VzZSB3YXMgdW5kZWZpbmVkLCBvcHRpb25zLmVsZW1lbnQgd2FzIHVuZGVmaW5lZCwgbWF5IG5vdCBmdW5jdGlvbiBhcyBleHBlY3RlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29uc3RyYWludCA9IENvbnN0cmFpbnQuY3JlYXRlKHsgXHJcbiAgICAgICAgICAgIGxhYmVsOiAnTW91c2UgQ29uc3RyYWludCcsXHJcbiAgICAgICAgICAgIHBvaW50QTogbW91c2UucG9zaXRpb24sXHJcbiAgICAgICAgICAgIHBvaW50QjogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgICAgIGxlbmd0aDogMC4wMSwgXHJcbiAgICAgICAgICAgIHN0aWZmbmVzczogMC4xLFxyXG4gICAgICAgICAgICBhbmd1bGFyU3RpZmZuZXNzOiAxLFxyXG4gICAgICAgICAgICByZW5kZXI6IHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiAnIzkwRUU5MCcsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdtb3VzZUNvbnN0cmFpbnQnLFxyXG4gICAgICAgICAgICBtb3VzZTogbW91c2UsXHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXHJcbiAgICAgICAgICAgIGJvZHk6IG51bGwsXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IGNvbnN0cmFpbnQsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IDB4MDAwMSxcclxuICAgICAgICAgICAgICAgIG1hc2s6IDB4RkZGRkZGRkYsXHJcbiAgICAgICAgICAgICAgICBncm91cDogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIG1vdXNlQ29uc3RyYWludCA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICBFdmVudHMub24oZW5naW5lLCAnYmVmb3JlVXBkYXRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGxCb2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGVuZ2luZS53b3JsZCk7XHJcbiAgICAgICAgICAgIE1vdXNlQ29uc3RyYWludC51cGRhdGUobW91c2VDb25zdHJhaW50LCBhbGxCb2RpZXMpO1xyXG4gICAgICAgICAgICBfdHJpZ2dlckV2ZW50cyhtb3VzZUNvbnN0cmFpbnQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbW91c2VDb25zdHJhaW50O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIG1vdXNlIGNvbnN0cmFpbnQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqIEBwYXJhbSB7TW91c2VDb25zdHJhaW50fSBtb3VzZUNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqL1xyXG4gICAgTW91c2VDb25zdHJhaW50LnVwZGF0ZSA9IGZ1bmN0aW9uKG1vdXNlQ29uc3RyYWludCwgYm9kaWVzKSB7XHJcbiAgICAgICAgdmFyIG1vdXNlID0gbW91c2VDb25zdHJhaW50Lm1vdXNlLFxyXG4gICAgICAgICAgICBjb25zdHJhaW50ID0gbW91c2VDb25zdHJhaW50LmNvbnN0cmFpbnQsXHJcbiAgICAgICAgICAgIGJvZHkgPSBtb3VzZUNvbnN0cmFpbnQuYm9keTtcclxuXHJcbiAgICAgICAgaWYgKG1vdXNlLmJ1dHRvbiA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQuYm9keUIpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKGJvZHkuYm91bmRzLCBtb3VzZS5wb3NpdGlvbikgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBEZXRlY3Rvci5jYW5Db2xsaWRlKGJvZHkuY29sbGlzaW9uRmlsdGVyLCBtb3VzZUNvbnN0cmFpbnQuY29sbGlzaW9uRmlsdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gYm9keS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBib2R5LnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmVydGljZXMuY29udGFpbnMocGFydC52ZXJ0aWNlcywgbW91c2UucG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEEgPSBtb3VzZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmJvZHlCID0gbW91c2VDb25zdHJhaW50LmJvZHkgPSBib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRCID0geyB4OiBtb3VzZS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvbi54LCB5OiBtb3VzZS5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvbi55IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5hbmdsZUIgPSBib2R5LmFuZ2xlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ3N0YXJ0ZHJhZycsIHsgbW91c2U6IG1vdXNlLCBib2R5OiBib2R5IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChjb25zdHJhaW50LmJvZHlCLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QSA9IG1vdXNlLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3RyYWludC5ib2R5QiA9IG1vdXNlQ29uc3RyYWludC5ib2R5ID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEIgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJvZHkpXHJcbiAgICAgICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdlbmRkcmFnJywgeyBtb3VzZTogbW91c2UsIGJvZHk6IGJvZHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIG1vdXNlIGNvbnN0cmFpbnQgZXZlbnRzLlxyXG4gICAgICogQG1ldGhvZCBfdHJpZ2dlckV2ZW50c1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlQ29uc3RyYWludFxyXG4gICAgICovXHJcbiAgICB2YXIgX3RyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihtb3VzZUNvbnN0cmFpbnQpIHtcclxuICAgICAgICB2YXIgbW91c2UgPSBtb3VzZUNvbnN0cmFpbnQubW91c2UsXHJcbiAgICAgICAgICAgIG1vdXNlRXZlbnRzID0gbW91c2Uuc291cmNlRXZlbnRzO1xyXG5cclxuICAgICAgICBpZiAobW91c2VFdmVudHMubW91c2Vtb3ZlKVxyXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdtb3VzZW1vdmUnLCB7IG1vdXNlOiBtb3VzZSB9KTtcclxuXHJcbiAgICAgICAgaWYgKG1vdXNlRXZlbnRzLm1vdXNlZG93bilcclxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIobW91c2VDb25zdHJhaW50LCAnbW91c2Vkb3duJywgeyBtb3VzZTogbW91c2UgfSk7XHJcblxyXG4gICAgICAgIGlmIChtb3VzZUV2ZW50cy5tb3VzZXVwKVxyXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdtb3VzZXVwJywgeyBtb3VzZTogbW91c2UgfSk7XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IHRoZSBtb3VzZSBzdGF0ZSByZWFkeSBmb3IgdGhlIG5leHQgc3RlcFxyXG4gICAgICAgIE1vdXNlLmNsZWFyU291cmNlRXZlbnRzKG1vdXNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICpcclxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBtb3VzZSBoYXMgbW92ZWQgKG9yIGEgdG91Y2ggbW92ZXMpIGR1cmluZyB0aGUgbGFzdCBzdGVwXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBtb3VzZW1vdmVcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge21vdXNlfSBldmVudC5tb3VzZSBUaGUgZW5naW5lJ3MgbW91c2UgaW5zdGFuY2VcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBtb3VzZSBpcyBkb3duIChvciBhIHRvdWNoIGhhcyBzdGFydGVkKSBkdXJpbmcgdGhlIGxhc3Qgc3RlcFxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgbW91c2Vkb3duXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHttb3VzZX0gZXZlbnQubW91c2UgVGhlIGVuZ2luZSdzIG1vdXNlIGluc3RhbmNlXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgd2hlbiB0aGUgbW91c2UgaXMgdXAgKG9yIGEgdG91Y2ggaGFzIGVuZGVkKSBkdXJpbmcgdGhlIGxhc3Qgc3RlcFxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgbW91c2V1cFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIGEgYm9keVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgc3RhcnRkcmFnXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHttb3VzZX0gZXZlbnQubW91c2UgVGhlIGVuZ2luZSdzIG1vdXNlIGluc3RhbmNlXHJcbiAgICAqIEBwYXJhbSB7Ym9keX0gZXZlbnQuYm9keSBUaGUgYm9keSBiZWluZyBkcmFnZ2VkXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBlbmRzIGRyYWdnaW5nIGEgYm9keVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgZW5kZHJhZ1xyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxyXG4gICAgKiBAcGFyYW0ge2JvZHl9IGV2ZW50LmJvZHkgVGhlIGJvZHkgdGhhdCBoYXMgc3RvcHBlZCBiZWluZyBkcmFnZ2VkXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgU3RyaW5nYCBkZW5vdGluZyB0aGUgdHlwZSBvZiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQGRlZmF1bHQgXCJjb25zdHJhaW50XCJcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYE1vdXNlYCBpbnN0YW5jZSBpbiB1c2UuIElmIG5vdCBzdXBwbGllZCBpbiBgTW91c2VDb25zdHJhaW50LmNyZWF0ZWAsIG9uZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IG1vdXNlXHJcbiAgICAgKiBAdHlwZSBtb3VzZVxyXG4gICAgICogQGRlZmF1bHQgbW91c2VcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBCb2R5YCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBtb3ZlZCBieSB0aGUgdXNlciwgb3IgYG51bGxgIGlmIG5vIGJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGJvZHlcclxuICAgICAqIEB0eXBlIGJvZHlcclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBDb25zdHJhaW50YCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIG1vdmUgdGhlIGJvZHkgZHVyaW5nIGludGVyYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBjb25zdHJhaW50XHJcbiAgICAgKiBAdHlwZSBjb25zdHJhaW50XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgc3BlY2lmaWVzIHRoZSBjb2xsaXNpb24gZmlsdGVyIHByb3BlcnRpZXMuXHJcbiAgICAgKiBUaGUgY29sbGlzaW9uIGZpbHRlciBhbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIHdoaWNoIHR5cGVzIG9mIGJvZHkgdGhpcyBtb3VzZSBjb25zdHJhaW50IGNhbiBpbnRlcmFjdCB3aXRoLlxyXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlclxyXG4gICAgICogQHR5cGUgb2JqZWN0XHJcbiAgICAgKi9cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbnN0cmFpbnQvTW91c2VDb25zdHJhaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0NjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvY29uc3RyYWludC9Nb3VzZUNvbnN0cmFpbnQuanMiLCIvKipcclxuKiBUaGUgYE1hdHRlcmAgbW9kdWxlIGlzIHRoZSB0b3AgbGV2ZWwgbmFtZXNwYWNlLiBJdCBhbHNvIGluY2x1ZGVzIGEgZnVuY3Rpb24gZm9yIGluc3RhbGxpbmcgcGx1Z2lucyBvbiB0b3Agb2YgdGhlIGxpYnJhcnkuXHJcbipcclxuKiBAY2xhc3MgTWF0dGVyXHJcbiovXHJcblxyXG52YXIgTWF0dGVyID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1hdHRlcjtcclxuXHJcbnZhciBQbHVnaW4gPSByZXF1aXJlKCcuL1BsdWdpbicpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaWJyYXJ5IG5hbWUuXHJcbiAgICAgKiBAcHJvcGVydHkgbmFtZVxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIubmFtZSA9ICdtYXR0ZXItanMnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxpYnJhcnkgdmVyc2lvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB2ZXJzaW9uXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIE1hdHRlci52ZXJzaW9uID0gJ0BAVkVSU0lPTkBAJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgbGlzdCBvZiBwbHVnaW4gZGVwZW5kZW5jaWVzIHRvIGJlIGluc3RhbGxlZC4gVGhlc2UgYXJlIG5vcm1hbGx5IHNldCBhbmQgaW5zdGFsbGVkIHRocm91Z2ggYE1hdHRlci51c2VgLlxyXG4gICAgICogQWx0ZXJuYXRpdmVseSB5b3UgbWF5IHNldCBgTWF0dGVyLnVzZXNgIG1hbnVhbGx5IGFuZCBpbnN0YWxsIHRoZW0gYnkgY2FsbGluZyBgUGx1Z2luLnVzZShNYXR0ZXIpYC5cclxuICAgICAqIEBwcm9wZXJ0eSB1c2VzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIE1hdHRlci51c2VzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGx1Z2lucyB0aGF0IGhhdmUgYmVlbiBpbnN0YWxsZWQgdGhyb3VnaCBgTWF0dGVyLlBsdWdpbi5pbnN0YWxsYC4gUmVhZCBvbmx5LlxyXG4gICAgICogQHByb3BlcnR5IHVzZWRcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIudXNlZCA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFsbHMgdGhlIGdpdmVuIHBsdWdpbnMgb24gdGhlIGBNYXR0ZXJgIG5hbWVzcGFjZS5cclxuICAgICAqIFRoaXMgaXMgYSBzaG9ydC1oYW5kIGZvciBgUGx1Z2luLnVzZWAsIHNlZSBpdCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqIENhbGwgdGhpcyBmdW5jdGlvbiBvbmNlIGF0IHRoZSBzdGFydCBvZiB5b3VyIGNvZGUsIHdpdGggYWxsIG9mIHRoZSBwbHVnaW5zIHlvdSB3aXNoIHRvIGluc3RhbGwgYXMgYXJndW1lbnRzLlxyXG4gICAgICogQXZvaWQgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzIHVubGVzcyB5b3UgaW50ZW5kIHRvIG1hbnVhbGx5IGNvbnRyb2wgaW5zdGFsbGF0aW9uIG9yZGVyLlxyXG4gICAgICogQG1ldGhvZCB1c2VcclxuICAgICAqIEBwYXJhbSAuLi5wbHVnaW4ge0Z1bmN0aW9ufSBUaGUgcGx1Z2luKHMpIHRvIGluc3RhbGwgb24gYGJhc2VgIChtdWx0aS1hcmd1bWVudCkuXHJcbiAgICAgKi9cclxuICAgIE1hdHRlci51c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBQbHVnaW4udXNlKE1hdHRlciwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhaW5zIGEgZnVuY3Rpb24gdG8gZXhjdXRlIGJlZm9yZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb24gdGhlIGdpdmVuIGBwYXRoYCByZWxhdGl2ZSB0byBgTWF0dGVyYC5cclxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxyXG4gICAgICogQG1ldGhvZCBiZWZvcmVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBNYXR0ZXJgXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGFpbiBiZWZvcmUgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGNoYWluZWQgZnVuY3Rpb24gdGhhdCByZXBsYWNlZCB0aGUgb3JpZ2luYWxcclxuICAgICAqL1xyXG4gICAgTWF0dGVyLmJlZm9yZSA9IGZ1bmN0aW9uKHBhdGgsIGZ1bmMpIHtcclxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eTWF0dGVyLi8sICcnKTtcclxuICAgICAgICByZXR1cm4gQ29tbW9uLmNoYWluUGF0aEJlZm9yZShNYXR0ZXIsIHBhdGgsIGZ1bmMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYWlucyBhIGZ1bmN0aW9uIHRvIGV4Y3V0ZSBhZnRlciB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb24gdGhlIGdpdmVuIGBwYXRoYCByZWxhdGl2ZSB0byBgTWF0dGVyYC5cclxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxyXG4gICAgICogQG1ldGhvZCBhZnRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYE1hdHRlcmBcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoYWluIGFmdGVyIHRoZSBvcmlnaW5hbFxyXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBjaGFpbmVkIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZWQgdGhlIG9yaWdpbmFsXHJcbiAgICAgKi9cclxuICAgIE1hdHRlci5hZnRlciA9IGZ1bmN0aW9uKHBhdGgsIGZ1bmMpIHtcclxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eTWF0dGVyLi8sICcnKTtcclxuICAgICAgICByZXR1cm4gQ29tbW9uLmNoYWluUGF0aEFmdGVyKE1hdHRlciwgcGF0aCwgZnVuYyk7XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9NYXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL01hdHRlci5qcyIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlJ1bm5lcmAgbW9kdWxlIGlzIGFuIG9wdGlvbmFsIHV0aWxpdHkgd2hpY2ggcHJvdmlkZXMgYSBnYW1lIGxvb3AsIFxyXG4qIHRoYXQgaGFuZGxlcyBjb250aW51b3VzbHkgdXBkYXRpbmcgYSBgTWF0dGVyLkVuZ2luZWAgZm9yIHlvdSB3aXRoaW4gYSBicm93c2VyLlxyXG4qIEl0IGlzIGludGVuZGVkIGZvciBkZXZlbG9wbWVudCBhbmQgZGVidWdnaW5nIHB1cnBvc2VzLCBidXQgbWF5IGFsc28gYmUgc3VpdGFibGUgZm9yIHNpbXBsZSBnYW1lcy5cclxuKiBJZiB5b3UgYXJlIHVzaW5nIHlvdXIgb3duIGdhbWUgbG9vcCBpbnN0ZWFkLCB0aGVuIHlvdSBkbyBub3QgbmVlZCB0aGUgYE1hdHRlci5SdW5uZXJgIG1vZHVsZS5cclxuKiBJbnN0ZWFkIGp1c3QgY2FsbCBgRW5naW5lLnVwZGF0ZShlbmdpbmUsIGRlbHRhKWAgaW4geW91ciBvd24gbG9vcC5cclxuKlxyXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXHJcbipcclxuKiBAY2xhc3MgUnVubmVyXHJcbiovXHJcblxyXG52YXIgUnVubmVyID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5lcjtcclxuXHJcbnZhciBFdmVudHMgPSByZXF1aXJlKCcuL0V2ZW50cycpO1xyXG52YXIgRW5naW5lID0gcmVxdWlyZSgnLi9FbmdpbmUnKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4vQ29tbW9uJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXHJcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuICAgXHJcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgICAgICAgdmFyIF9mcmFtZVRpbWVvdXQ7XHJcblxyXG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjayl7IFxyXG4gICAgICAgICAgICBfZnJhbWVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhDb21tb24ubm93KCkpOyBcclxuICAgICAgICAgICAgfSwgMTAwMCAvIDYwKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9mcmFtZVRpbWVvdXQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFJ1bm5lci4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgUnVubmVyLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIGZwczogNjAsXHJcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IDEsXHJcbiAgICAgICAgICAgIGRlbHRhU2FtcGxlU2l6ZTogNjAsXHJcbiAgICAgICAgICAgIGNvdW50ZXJUaW1lc3RhbXA6IDAsXHJcbiAgICAgICAgICAgIGZyYW1lQ291bnRlcjogMCxcclxuICAgICAgICAgICAgZGVsdGFIaXN0b3J5OiBbXSxcclxuICAgICAgICAgICAgdGltZVByZXY6IG51bGwsXHJcbiAgICAgICAgICAgIHRpbWVTY2FsZVByZXY6IDEsXHJcbiAgICAgICAgICAgIGZyYW1lUmVxdWVzdElkOiBudWxsLFxyXG4gICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBydW5uZXIgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgcnVubmVyLmRlbHRhID0gcnVubmVyLmRlbHRhIHx8IDEwMDAgLyBydW5uZXIuZnBzO1xyXG4gICAgICAgIHJ1bm5lci5kZWx0YU1pbiA9IHJ1bm5lci5kZWx0YU1pbiB8fCAxMDAwIC8gcnVubmVyLmZwcztcclxuICAgICAgICBydW5uZXIuZGVsdGFNYXggPSBydW5uZXIuZGVsdGFNYXggfHwgMTAwMCAvIChydW5uZXIuZnBzICogMC41KTtcclxuICAgICAgICBydW5uZXIuZnBzID0gMTAwMCAvIHJ1bm5lci5kZWx0YTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250aW51b3VzbHkgdGlja3MgYSBgTWF0dGVyLkVuZ2luZWAgYnkgY2FsbGluZyBgUnVubmVyLnRpY2tgIG9uIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBldmVudC5cclxuICAgICAqIEBtZXRob2QgcnVuXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKi9cclxuICAgIFJ1bm5lci5ydW4gPSBmdW5jdGlvbihydW5uZXIsIGVuZ2luZSkge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBydW5uZXIgaWYgZW5naW5lIGlzIGZpcnN0IGFyZ3VtZW50XHJcbiAgICAgICAgaWYgKHR5cGVvZiBydW5uZXIucG9zaXRpb25JdGVyYXRpb25zICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBlbmdpbmUgPSBydW5uZXI7XHJcbiAgICAgICAgICAgIHJ1bm5lciA9IFJ1bm5lci5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIChmdW5jdGlvbiByZW5kZXIodGltZSl7XHJcbiAgICAgICAgICAgIHJ1bm5lci5mcmFtZVJlcXVlc3RJZCA9IF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aW1lICYmIHJ1bm5lci5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBSdW5uZXIudGljayhydW5uZXIsIGVuZ2luZSwgdGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcnVubmVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZ2FtZSBsb29wIHV0aWxpdHkgdGhhdCB1cGRhdGVzIHRoZSBlbmdpbmUgYW5kIHJlbmRlcmVyIGJ5IG9uZSBzdGVwIChhICd0aWNrJykuXHJcbiAgICAgKiBGZWF0dXJlcyBkZWx0YSBzbW9vdGhpbmcsIHRpbWUgY29ycmVjdGlvbiBhbmQgZml4ZWQgb3IgZHluYW1pYyB0aW1pbmcuXHJcbiAgICAgKiBUcmlnZ2VycyBgYmVmb3JlVGlja2AsIGB0aWNrYCBhbmQgYGFmdGVyVGlja2AgZXZlbnRzIG9uIHRoZSBlbmdpbmUuXHJcbiAgICAgKiBDb25zaWRlciBqdXN0IGBFbmdpbmUudXBkYXRlKGVuZ2luZSwgZGVsdGEpYCBpZiB5b3UncmUgdXNpbmcgeW91ciBvd24gbG9vcC5cclxuICAgICAqIEBtZXRob2QgdGlja1xyXG4gICAgICogQHBhcmFtIHtydW5uZXJ9IHJ1bm5lclxyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcclxuICAgICAqL1xyXG4gICAgUnVubmVyLnRpY2sgPSBmdW5jdGlvbihydW5uZXIsIGVuZ2luZSwgdGltZSkge1xyXG4gICAgICAgIHZhciB0aW1pbmcgPSBlbmdpbmUudGltaW5nLFxyXG4gICAgICAgICAgICBjb3JyZWN0aW9uID0gMSxcclxuICAgICAgICAgICAgZGVsdGE7XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBldmVudCBvYmplY3RcclxuICAgICAgICB2YXIgZXZlbnQgPSB7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltaW5nLnRpbWVzdGFtcFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2JlZm9yZVRpY2snLCBldmVudCk7XHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYmVmb3JlVGljaycsIGV2ZW50KTsgLy8gQGRlcHJlY2F0ZWRcclxuXHJcbiAgICAgICAgaWYgKHJ1bm5lci5pc0ZpeGVkKSB7XHJcbiAgICAgICAgICAgIC8vIGZpeGVkIHRpbWVzdGVwXHJcbiAgICAgICAgICAgIGRlbHRhID0gcnVubmVyLmRlbHRhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgdGltZXN0ZXAgYmFzZWQgb24gd2FsbCBjbG9jayBiZXR3ZWVuIGNhbGxzXHJcbiAgICAgICAgICAgIGRlbHRhID0gKHRpbWUgLSBydW5uZXIudGltZVByZXYpIHx8IHJ1bm5lci5kZWx0YTtcclxuICAgICAgICAgICAgcnVubmVyLnRpbWVQcmV2ID0gdGltZTtcclxuXHJcbiAgICAgICAgICAgIC8vIG9wdGltaXN0aWNhbGx5IGZpbHRlciBkZWx0YSBvdmVyIGEgZmV3IGZyYW1lcywgdG8gaW1wcm92ZSBzdGFiaWxpdHlcclxuICAgICAgICAgICAgcnVubmVyLmRlbHRhSGlzdG9yeS5wdXNoKGRlbHRhKTtcclxuICAgICAgICAgICAgcnVubmVyLmRlbHRhSGlzdG9yeSA9IHJ1bm5lci5kZWx0YUhpc3Rvcnkuc2xpY2UoLXJ1bm5lci5kZWx0YVNhbXBsZVNpemUpO1xyXG4gICAgICAgICAgICBkZWx0YSA9IE1hdGgubWluLmFwcGx5KG51bGwsIHJ1bm5lci5kZWx0YUhpc3RvcnkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gbGltaXQgZGVsdGFcclxuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSA8IHJ1bm5lci5kZWx0YU1pbiA/IHJ1bm5lci5kZWx0YU1pbiA6IGRlbHRhO1xyXG4gICAgICAgICAgICBkZWx0YSA9IGRlbHRhID4gcnVubmVyLmRlbHRhTWF4ID8gcnVubmVyLmRlbHRhTWF4IDogZGVsdGE7XHJcblxyXG4gICAgICAgICAgICAvLyBjb3JyZWN0aW9uIGZvciBkZWx0YVxyXG4gICAgICAgICAgICBjb3JyZWN0aW9uID0gZGVsdGEgLyBydW5uZXIuZGVsdGE7XHJcblxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgZW5naW5lIHRpbWluZyBvYmplY3RcclxuICAgICAgICAgICAgcnVubmVyLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0aW1lIGNvcnJlY3Rpb24gZm9yIHRpbWUgc2NhbGluZ1xyXG4gICAgICAgIGlmIChydW5uZXIudGltZVNjYWxlUHJldiAhPT0gMClcclxuICAgICAgICAgICAgY29ycmVjdGlvbiAqPSB0aW1pbmcudGltZVNjYWxlIC8gcnVubmVyLnRpbWVTY2FsZVByZXY7XHJcblxyXG4gICAgICAgIGlmICh0aW1pbmcudGltZVNjYWxlID09PSAwKVxyXG4gICAgICAgICAgICBjb3JyZWN0aW9uID0gMDtcclxuXHJcbiAgICAgICAgcnVubmVyLnRpbWVTY2FsZVByZXYgPSB0aW1pbmcudGltZVNjYWxlO1xyXG4gICAgICAgIHJ1bm5lci5jb3JyZWN0aW9uID0gY29ycmVjdGlvbjtcclxuXHJcbiAgICAgICAgLy8gZnBzIGNvdW50ZXJcclxuICAgICAgICBydW5uZXIuZnJhbWVDb3VudGVyICs9IDE7XHJcbiAgICAgICAgaWYgKHRpbWUgLSBydW5uZXIuY291bnRlclRpbWVzdGFtcCA+PSAxMDAwKSB7XHJcbiAgICAgICAgICAgIHJ1bm5lci5mcHMgPSBydW5uZXIuZnJhbWVDb3VudGVyICogKCh0aW1lIC0gcnVubmVyLmNvdW50ZXJUaW1lc3RhbXApIC8gMTAwMCk7XHJcbiAgICAgICAgICAgIHJ1bm5lci5jb3VudGVyVGltZXN0YW1wID0gdGltZTtcclxuICAgICAgICAgICAgcnVubmVyLmZyYW1lQ291bnRlciA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBFdmVudHMudHJpZ2dlcihydW5uZXIsICd0aWNrJywgZXZlbnQpO1xyXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ3RpY2snLCBldmVudCk7IC8vIEBkZXByZWNhdGVkXHJcblxyXG4gICAgICAgIC8vIGlmIHdvcmxkIGhhcyBiZWVuIG1vZGlmaWVkLCBjbGVhciB0aGUgcmVuZGVyIHNjZW5lIGdyYXBoXHJcbiAgICAgICAgaWYgKGVuZ2luZS53b3JsZC5pc01vZGlmaWVkIFxyXG4gICAgICAgICAgICAmJiBlbmdpbmUucmVuZGVyXHJcbiAgICAgICAgICAgICYmIGVuZ2luZS5yZW5kZXIuY29udHJvbGxlclxyXG4gICAgICAgICAgICAmJiBlbmdpbmUucmVuZGVyLmNvbnRyb2xsZXIuY2xlYXIpIHtcclxuICAgICAgICAgICAgZW5naW5lLnJlbmRlci5jb250cm9sbGVyLmNsZWFyKGVuZ2luZS5yZW5kZXIpOyAvLyBAZGVwcmVjYXRlZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXBkYXRlXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYmVmb3JlVXBkYXRlJywgZXZlbnQpO1xyXG4gICAgICAgIEVuZ2luZS51cGRhdGUoZW5naW5lLCBkZWx0YSwgY29ycmVjdGlvbik7XHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYWZ0ZXJVcGRhdGUnLCBldmVudCk7XHJcblxyXG4gICAgICAgIC8vIHJlbmRlclxyXG4gICAgICAgIC8vIEBkZXByZWNhdGVkXHJcbiAgICAgICAgaWYgKGVuZ2luZS5yZW5kZXIgJiYgZW5naW5lLnJlbmRlci5jb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2JlZm9yZVJlbmRlcicsIGV2ZW50KTtcclxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYmVmb3JlUmVuZGVyJywgZXZlbnQpOyAvLyBAZGVwcmVjYXRlZFxyXG5cclxuICAgICAgICAgICAgZW5naW5lLnJlbmRlci5jb250cm9sbGVyLndvcmxkKGVuZ2luZS5yZW5kZXIpO1xyXG5cclxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYWZ0ZXJSZW5kZXInLCBldmVudCk7XHJcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2FmdGVyUmVuZGVyJywgZXZlbnQpOyAvLyBAZGVwcmVjYXRlZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYWZ0ZXJUaWNrJywgZXZlbnQpO1xyXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2FmdGVyVGljaycsIGV2ZW50KTsgLy8gQGRlcHJlY2F0ZWRcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmRzIGV4ZWN1dGlvbiBvZiBgUnVubmVyLnJ1bmAgb24gdGhlIGdpdmVuIGBydW5uZXJgLCBieSBjYW5jZWxpbmcgdGhlIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0IGV2ZW50IGxvb3AuXHJcbiAgICAgKiBJZiB5b3Ugd2lzaCB0byBvbmx5IHRlbXBvcmFyaWx5IHBhdXNlIHRoZSBlbmdpbmUsIHNlZSBgZW5naW5lLmVuYWJsZWRgIGluc3RlYWQuXHJcbiAgICAgKiBAbWV0aG9kIHN0b3BcclxuICAgICAqIEBwYXJhbSB7cnVubmVyfSBydW5uZXJcclxuICAgICAqL1xyXG4gICAgUnVubmVyLnN0b3AgPSBmdW5jdGlvbihydW5uZXIpIHtcclxuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUocnVubmVyLmZyYW1lUmVxdWVzdElkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBmb3IgYFJ1bm5lci5ydW5gLlxyXG4gICAgICogQG1ldGhvZCBzdGFydFxyXG4gICAgICogQHBhcmFtIHtydW5uZXJ9IHJ1bm5lclxyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxyXG4gICAgICovXHJcbiAgICBSdW5uZXIuc3RhcnQgPSBmdW5jdGlvbihydW5uZXIsIGVuZ2luZSkge1xyXG4gICAgICAgIFJ1bm5lci5ydW4ocnVubmVyLCBlbmdpbmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgRXZlbnRzIERvY3VtZW50YXRpb25cclxuICAgICpcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGF0IHRoZSBzdGFydCBvZiBhIHRpY2ssIGJlZm9yZSBhbnkgdXBkYXRlcyB0byB0aGUgZW5naW5lIG9yIHRpbWluZ1xyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYmVmb3JlVGlja1xyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGFmdGVyIGVuZ2luZSB0aW1pbmcgdXBkYXRlZCwgYnV0IGp1c3QgYmVmb3JlIHVwZGF0ZVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgdGlja1xyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGF0IHRoZSBlbmQgb2YgYSB0aWNrLCBhZnRlciBlbmdpbmUgdXBkYXRlIGFuZCBhZnRlciByZW5kZXJpbmdcclxuICAgICpcclxuICAgICogQGV2ZW50IGFmdGVyVGlja1xyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGJlZm9yZSB1cGRhdGVcclxuICAgICpcclxuICAgICogQGV2ZW50IGJlZm9yZVVwZGF0ZVxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGFmdGVyIHVwZGF0ZVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYWZ0ZXJVcGRhdGVcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCBiZWZvcmUgcmVuZGVyaW5nXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBiZWZvcmVSZW5kZXJcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCBhZnRlciByZW5kZXJpbmdcclxuICAgICpcclxuICAgICogQGV2ZW50IGFmdGVyUmVuZGVyXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgKi9cclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmbGFnIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHJ1bm5lciBpcyBydW5uaW5nIG9yIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlZFxyXG4gICAgICogQHR5cGUgYm9vbGVhblxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBCb29sZWFuYCB0aGF0IHNwZWNpZmllcyBpZiB0aGUgcnVubmVyIHNob3VsZCB1c2UgYSBmaXhlZCB0aW1lc3RlcCAob3RoZXJ3aXNlIGl0IGlzIHZhcmlhYmxlKS5cclxuICAgICAqIElmIHRpbWluZyBpcyBmaXhlZCwgdGhlbiB0aGUgYXBwYXJlbnQgc2ltdWxhdGlvbiBzcGVlZCB3aWxsIGNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGZyYW1lIHJhdGUgKGJ1dCBiZWhhdmlvdXIgd2lsbCBiZSBkZXRlcm1pbmlzdGljKS5cclxuICAgICAqIElmIHRoZSB0aW1pbmcgaXMgdmFyaWFibGUsIHRoZW4gdGhlIGFwcGFyZW50IHNpbXVsYXRpb24gc3BlZWQgd2lsbCBiZSBjb25zdGFudCAoYXBwcm94aW1hdGVseSwgYnV0IGF0IHRoZSBjb3N0IG9mIGRldGVybWluaW5pc20pLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBpc0ZpeGVkXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSB0aW1lIHN0ZXAgYmV0d2VlbiB1cGRhdGVzIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqIElmIGBlbmdpbmUudGltaW5nLmlzRml4ZWRgIGlzIHNldCB0byBgdHJ1ZWAsIHRoZW4gYGRlbHRhYCBpcyBmaXhlZC5cclxuICAgICAqIElmIGl0IGlzIGBmYWxzZWAsIHRoZW4gYGRlbHRhYCBjYW4gZHluYW1pY2FsbHkgY2hhbmdlIHRvIG1haW50YWluIHRoZSBjb3JyZWN0IGFwcGFyZW50IHNpbXVsYXRpb24gc3BlZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGRlbHRhXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDEwMDAgLyA2MFxyXG4gICAgICovXHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL1J1bm5lci5qc1xuLy8gbW9kdWxlIGlkID0gNDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvUnVubmVyLmpzIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuQ29tcG9zaXRlc2AgbW9kdWxlIGNvbnRhaW5zIGZhY3RvcnkgbWV0aG9kcyBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGJvZGllc1xyXG4qIHdpdGggY29tbW9ubHkgdXNlZCBjb25maWd1cmF0aW9ucyAoc3VjaCBhcyBzdGFja3MgYW5kIGNoYWlucykuXHJcbipcclxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxyXG4qXHJcbiogQGNsYXNzIENvbXBvc2l0ZXNcclxuKi9cclxuXHJcbnZhciBDb21wb3NpdGVzID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0ZXM7XHJcblxyXG52YXIgQ29tcG9zaXRlID0gcmVxdWlyZSgnLi4vYm9keS9Db21wb3NpdGUnKTtcclxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuLi9jb25zdHJhaW50L0NvbnN0cmFpbnQnKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcbnZhciBCb2R5ID0gcmVxdWlyZSgnLi4vYm9keS9Cb2R5Jyk7XHJcbnZhciBCb2RpZXMgPSByZXF1aXJlKCcuL0JvZGllcycpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIGJvZGllcyBjcmVhdGVkIGluIHRoZSBjYWxsYmFjayBpbiBhIGdyaWQgYXJyYW5nZW1lbnQuXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGJvZHkncyBib3VuZHMgdG8gcHJldmVudCBvdmVybGFwcy5cclxuICAgICAqIEBtZXRob2Qgc3RhY2tcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3NcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5HYXBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dHYXBcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIG9iamVjdHMgY3JlYXRlZCBpbiB0aGUgY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlcy5zdGFjayA9IGZ1bmN0aW9uKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHN0YWNrID0gQ29tcG9zaXRlLmNyZWF0ZSh7IGxhYmVsOiAnU3RhY2snIH0pLFxyXG4gICAgICAgICAgICB4ID0geHgsXHJcbiAgICAgICAgICAgIHkgPSB5eSxcclxuICAgICAgICAgICAgbGFzdEJvZHksXHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xyXG4gICAgICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IGNvbHVtbnM7IGNvbHVtbisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGNhbGxiYWNrKHgsIHksIGNvbHVtbiwgcm93LCBsYXN0Qm9keSwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5SGVpZ2h0ID0gYm9keS5ib3VuZHMubWF4LnkgLSBib2R5LmJvdW5kcy5taW4ueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keVdpZHRoID0gYm9keS5ib3VuZHMubWF4LnggLSBib2R5LmJvdW5kcy5taW4ueDsgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5SGVpZ2h0ID4gbWF4SGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBib2R5SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHkudHJhbnNsYXRlKGJvZHksIHsgeDogYm9keVdpZHRoICogMC41LCB5OiBib2R5SGVpZ2h0ICogMC41IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4ID0gYm9keS5ib3VuZHMubWF4LnggKyBjb2x1bW5HYXA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KHN0YWNrLCBib2R5KTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Qm9keSA9IGJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4ICs9IGNvbHVtbkdhcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgeSArPSBtYXhIZWlnaHQgKyByb3dHYXA7XHJcbiAgICAgICAgICAgIHggPSB4eDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdGFjaztcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQ2hhaW5zIGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSB0b2dldGhlciB1c2luZyBjb25zdHJhaW50cy5cclxuICAgICAqIEBtZXRob2QgY2hhaW5cclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4T2Zmc2V0QVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlPZmZzZXRBXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geE9mZnNldEJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5T2Zmc2V0QlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgb2JqZWN0cyBjaGFpbmVkIHRvZ2V0aGVyIHdpdGggY29uc3RyYWludHNcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlcy5jaGFpbiA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgeE9mZnNldEEsIHlPZmZzZXRBLCB4T2Zmc2V0QiwgeU9mZnNldEIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gY29tcG9zaXRlLmJvZGllcztcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSBib2RpZXNbaSAtIDFdLFxyXG4gICAgICAgICAgICAgICAgYm9keUIgPSBib2RpZXNbaV0sXHJcbiAgICAgICAgICAgICAgICBib2R5QUhlaWdodCA9IGJvZHlBLmJvdW5kcy5tYXgueSAtIGJvZHlBLmJvdW5kcy5taW4ueSxcclxuICAgICAgICAgICAgICAgIGJvZHlBV2lkdGggPSBib2R5QS5ib3VuZHMubWF4LnggLSBib2R5QS5ib3VuZHMubWluLngsIFxyXG4gICAgICAgICAgICAgICAgYm9keUJIZWlnaHQgPSBib2R5Qi5ib3VuZHMubWF4LnkgLSBib2R5Qi5ib3VuZHMubWluLnksXHJcbiAgICAgICAgICAgICAgICBib2R5QldpZHRoID0gYm9keUIuYm91bmRzLm1heC54IC0gYm9keUIuYm91bmRzLm1pbi54O1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgICAgICBib2R5QTogYm9keUEsXHJcbiAgICAgICAgICAgICAgICBwb2ludEE6IHsgeDogYm9keUFXaWR0aCAqIHhPZmZzZXRBLCB5OiBib2R5QUhlaWdodCAqIHlPZmZzZXRBIH0sXHJcbiAgICAgICAgICAgICAgICBib2R5QjogYm9keUIsXHJcbiAgICAgICAgICAgICAgICBwb2ludEI6IHsgeDogYm9keUJXaWR0aCAqIHhPZmZzZXRCLCB5OiBib2R5QkhlaWdodCAqIHlPZmZzZXRCIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoY29uc3RyYWludCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29tcG9zaXRlLmxhYmVsICs9ICcgQ2hhaW4nO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgYm9kaWVzIGluIHRoZSBjb21wb3NpdGUgd2l0aCBjb25zdHJhaW50cyBpbiBhIGdyaWQgcGF0dGVybiwgd2l0aCBvcHRpb25hbCBjcm9zcyBicmFjZXMuXHJcbiAgICAgKiBAbWV0aG9kIG1lc2hcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93c1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcm9zc0JyYWNlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgY29tcG9zaXRlIGNvbnRhaW5pbmcgb2JqZWN0cyBtZXNoZWQgdG9nZXRoZXIgd2l0aCBjb25zdHJhaW50c1xyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGVzLm1lc2ggPSBmdW5jdGlvbihjb21wb3NpdGUsIGNvbHVtbnMsIHJvd3MsIGNyb3NzQnJhY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gY29tcG9zaXRlLmJvZGllcyxcclxuICAgICAgICAgICAgcm93LFxyXG4gICAgICAgICAgICBjb2wsXHJcbiAgICAgICAgICAgIGJvZHlBLFxyXG4gICAgICAgICAgICBib2R5QixcclxuICAgICAgICAgICAgYm9keUM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbCA9IDE7IGNvbCA8IGNvbHVtbnM7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5QSA9IGJvZGllc1soY29sIC0gMSkgKyAocm93ICogY29sdW1ucyldO1xyXG4gICAgICAgICAgICAgICAgYm9keUIgPSBib2RpZXNbY29sICsgKHJvdyAqIGNvbHVtbnMpXTtcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IGJvZHlBOiBib2R5QSwgYm9keUI6IGJvZHlCIH0sIG9wdGlvbnMpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyb3cgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IGNvbHVtbnM7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEgPSBib2RpZXNbY29sICsgKChyb3cgLSAxKSAqIGNvbHVtbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QiA9IGJvZGllc1tjb2wgKyAocm93ICogY29sdW1ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IGJvZHlBOiBib2R5QSwgYm9keUI6IGJvZHlCIH0sIG9wdGlvbnMpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcm9zc0JyYWNlICYmIGNvbCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUMgPSBib2RpZXNbKGNvbCAtIDEpICsgKChyb3cgLSAxKSAqIGNvbHVtbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY29tcG9zaXRlLCBDb25zdHJhaW50LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgYm9keUE6IGJvZHlDLCBib2R5QjogYm9keUIgfSwgb3B0aW9ucykpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcm9zc0JyYWNlICYmIGNvbCA8IGNvbHVtbnMgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlDID0gYm9kaWVzWyhjb2wgKyAxKSArICgocm93IC0gMSkgKiBjb2x1bW5zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IGJvZHlBOiBib2R5QywgYm9keUI6IGJvZHlCIH0sIG9wdGlvbnMpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb21wb3NpdGUubGFiZWwgKz0gJyBNZXNoJztcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgYm9kaWVzIGNyZWF0ZWQgaW4gdGhlIGNhbGxiYWNrIGluIGEgcHlyYW1pZCBhcnJhbmdlbWVudC5cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgYm9keSdzIGJvdW5kcyB0byBwcmV2ZW50IG92ZXJsYXBzLlxyXG4gICAgICogQG1ldGhvZCBweXJhbWlkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5eVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uR2FwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93R2FwXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgY29udGFpbmluZyBvYmplY3RzIGNyZWF0ZWQgaW4gdGhlIGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZXMucHlyYW1pZCA9IGZ1bmN0aW9uKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbXBvc2l0ZXMuc3RhY2soeHgsIHl5LCBjb2x1bW5zLCByb3dzLCBjb2x1bW5HYXAsIHJvd0dhcCwgZnVuY3Rpb24oeCwgeSwgY29sdW1uLCByb3csIGxhc3RCb2R5LCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3R1YWxSb3dzID0gTWF0aC5taW4ocm93cywgTWF0aC5jZWlsKGNvbHVtbnMgLyAyKSksXHJcbiAgICAgICAgICAgICAgICBsYXN0Qm9keVdpZHRoID0gbGFzdEJvZHkgPyBsYXN0Qm9keS5ib3VuZHMubWF4LnggLSBsYXN0Qm9keS5ib3VuZHMubWluLnggOiAwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHJvdyA+IGFjdHVhbFJvd3MpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyByZXZlcnNlIHJvdyBvcmRlclxyXG4gICAgICAgICAgICByb3cgPSBhY3R1YWxSb3dzIC0gcm93O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcm93LFxyXG4gICAgICAgICAgICAgICAgZW5kID0gY29sdW1ucyAtIDEgLSByb3c7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29sdW1uIDwgc3RhcnQgfHwgY29sdW1uID4gZW5kKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gcmV0cm9hY3RpdmVseSBmaXggdGhlIGZpcnN0IGJvZHkncyBwb3NpdGlvbiwgc2luY2Ugd2lkdGggd2FzIHVua25vd25cclxuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIEJvZHkudHJhbnNsYXRlKGxhc3RCb2R5LCB7IHg6IChjb2x1bW4gKyAoY29sdW1ucyAlIDIgPT09IDEgPyAxIDogLTEpKSAqIGxhc3RCb2R5V2lkdGgsIHk6IDAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4T2Zmc2V0ID0gbGFzdEJvZHkgPyBjb2x1bW4gKiBsYXN0Qm9keVdpZHRoIDogMDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh4eCArIHhPZmZzZXQgKyBjb2x1bW4gKiBjb2x1bW5HYXAsIHksIGNvbHVtbiwgcm93LCBsYXN0Qm9keSwgaSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSB3aXRoIGEgTmV3dG9uJ3MgQ3JhZGxlIHNldHVwIG9mIGJvZGllcyBhbmQgY29uc3RyYWludHMuXHJcbiAgICAgKiBAbWV0aG9kIG5ld3RvbnNDcmFkbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgbmV3dG9uc0NyYWRsZSBib2R5XHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZXMubmV3dG9uc0NyYWRsZSA9IGZ1bmN0aW9uKHh4LCB5eSwgbnVtYmVyLCBzaXplLCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgbmV3dG9uc0NyYWRsZSA9IENvbXBvc2l0ZS5jcmVhdGUoeyBsYWJlbDogJ05ld3RvbnMgQ3JhZGxlJyB9KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXI7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IDEuOSxcclxuICAgICAgICAgICAgICAgIGNpcmNsZSA9IEJvZGllcy5jaXJjbGUoeHggKyBpICogKHNpemUgKiBzZXBhcmF0aW9uKSwgeXkgKyBsZW5ndGgsIHNpemUsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbmVydGlhOiBJbmZpbml0eSwgcmVzdGl0dXRpb246IDEsIGZyaWN0aW9uOiAwLCBmcmljdGlvbkFpcjogMC4wMDAxLCBzbG9wOiAxIH0pLFxyXG4gICAgICAgICAgICAgICAgY29uc3RyYWludCA9IENvbnN0cmFpbnQuY3JlYXRlKHsgcG9pbnRBOiB7IHg6IHh4ICsgaSAqIChzaXplICogc2VwYXJhdGlvbiksIHk6IHl5IH0sIGJvZHlCOiBjaXJjbGUgfSk7XHJcblxyXG4gICAgICAgICAgICBDb21wb3NpdGUuYWRkQm9keShuZXd0b25zQ3JhZGxlLCBjaXJjbGUpO1xyXG4gICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChuZXd0b25zQ3JhZGxlLCBjb25zdHJhaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXd0b25zQ3JhZGxlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIHdpdGggc2ltcGxlIGNhciBzZXR1cCBvZiBib2RpZXMgYW5kIGNvbnN0cmFpbnRzLlxyXG4gICAgICogQG1ldGhvZCBjYXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aGVlbFNpemVcclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIGNhciBib2R5XHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZXMuY2FyID0gZnVuY3Rpb24oeHgsIHl5LCB3aWR0aCwgaGVpZ2h0LCB3aGVlbFNpemUpIHtcclxuICAgICAgICB2YXIgZ3JvdXAgPSBCb2R5Lm5leHRHcm91cCh0cnVlKSxcclxuICAgICAgICAgICAgd2hlZWxCYXNlID0gLTIwLFxyXG4gICAgICAgICAgICB3aGVlbEFPZmZzZXQgPSAtd2lkdGggKiAwLjUgKyB3aGVlbEJhc2UsXHJcbiAgICAgICAgICAgIHdoZWVsQk9mZnNldCA9IHdpZHRoICogMC41IC0gd2hlZWxCYXNlLFxyXG4gICAgICAgICAgICB3aGVlbFlPZmZzZXQgPSAwO1xyXG4gICAgXHJcbiAgICAgICAgdmFyIGNhciA9IENvbXBvc2l0ZS5jcmVhdGUoeyBsYWJlbDogJ0NhcicgfSksXHJcbiAgICAgICAgICAgIGJvZHkgPSBCb2RpZXMudHJhcGV6b2lkKHh4LCB5eSwgd2lkdGgsIGhlaWdodCwgMC4zLCB7IFxyXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uRmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnJpY3Rpb246IDAuMDEsXHJcbiAgICAgICAgICAgICAgICBjaGFtZmVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAxMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgIHZhciB3aGVlbEEgPSBCb2RpZXMuY2lyY2xlKHh4ICsgd2hlZWxBT2Zmc2V0LCB5eSArIHdoZWVsWU9mZnNldCwgd2hlZWxTaXplLCB7IFxyXG4gICAgICAgICAgICBjb2xsaXNpb25GaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmcmljdGlvbjogMC44LFxyXG4gICAgICAgICAgICBkZW5zaXR5OiAwLjAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIHdoZWVsQiA9IEJvZGllcy5jaXJjbGUoeHggKyB3aGVlbEJPZmZzZXQsIHl5ICsgd2hlZWxZT2Zmc2V0LCB3aGVlbFNpemUsIHsgXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZyaWN0aW9uOiAwLjgsXHJcbiAgICAgICAgICAgIGRlbnNpdHk6IDAuMDFcclxuICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICB2YXIgYXhlbEEgPSBDb25zdHJhaW50LmNyZWF0ZSh7XHJcbiAgICAgICAgICAgIGJvZHlBOiBib2R5LFxyXG4gICAgICAgICAgICBwb2ludEE6IHsgeDogd2hlZWxBT2Zmc2V0LCB5OiB3aGVlbFlPZmZzZXQgfSxcclxuICAgICAgICAgICAgYm9keUI6IHdoZWVsQSxcclxuICAgICAgICAgICAgc3RpZmZuZXNzOiAwLjIsXHJcbiAgICAgICAgICAgIHJlbmRlcjoge1xyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIGF4ZWxCID0gQ29uc3RyYWludC5jcmVhdGUoe1xyXG4gICAgICAgICAgICBib2R5QTogYm9keSxcclxuICAgICAgICAgICAgcG9pbnRBOiB7IHg6IHdoZWVsQk9mZnNldCwgeTogd2hlZWxZT2Zmc2V0IH0sXHJcbiAgICAgICAgICAgIGJvZHlCOiB3aGVlbEIsXHJcbiAgICAgICAgICAgIHN0aWZmbmVzczogMC4yLFxyXG4gICAgICAgICAgICByZW5kZXI6IHtcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoY2FyLCBib2R5KTtcclxuICAgICAgICBDb21wb3NpdGUuYWRkQm9keShjYXIsIHdoZWVsQSk7XHJcbiAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoY2FyLCB3aGVlbEIpO1xyXG4gICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNhciwgYXhlbEEpO1xyXG4gICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNhciwgYXhlbEIpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzaW1wbGUgc29mdCBib2R5IGxpa2Ugb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCBzb2Z0Qm9keVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHh4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geXlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkdhcFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0dhcFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcm9zc0JyYWNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFydGljbGVSYWRpdXNcclxuICAgICAqIEBwYXJhbSB7fSBwYXJ0aWNsZU9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7fSBjb25zdHJhaW50T3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgc29mdEJvZHlcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlcy5zb2Z0Qm9keSA9IGZ1bmN0aW9uKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNyb3NzQnJhY2UsIHBhcnRpY2xlUmFkaXVzLCBwYXJ0aWNsZU9wdGlvbnMsIGNvbnN0cmFpbnRPcHRpb25zKSB7XHJcbiAgICAgICAgcGFydGljbGVPcHRpb25zID0gQ29tbW9uLmV4dGVuZCh7IGluZXJ0aWE6IEluZmluaXR5IH0sIHBhcnRpY2xlT3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3RyYWludE9wdGlvbnMgPSBDb21tb24uZXh0ZW5kKHsgc3RpZmZuZXNzOiAwLjQgfSwgY29uc3RyYWludE9wdGlvbnMpO1xyXG5cclxuICAgICAgICB2YXIgc29mdEJvZHkgPSBDb21wb3NpdGVzLnN0YWNrKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEJvZGllcy5jaXJjbGUoeCwgeSwgcGFydGljbGVSYWRpdXMsIHBhcnRpY2xlT3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIENvbXBvc2l0ZXMubWVzaChzb2Z0Qm9keSwgY29sdW1ucywgcm93cywgY3Jvc3NCcmFjZSwgY29uc3RyYWludE9wdGlvbnMpO1xyXG5cclxuICAgICAgICBzb2Z0Qm9keS5sYWJlbCA9ICdTb2Z0IEJvZHknO1xyXG5cclxuICAgICAgICByZXR1cm4gc29mdEJvZHk7XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvZmFjdG9yeS9Db21wb3NpdGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvZmFjdG9yeS9Db21wb3NpdGVzLmpzIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuU3ZnYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY29udmVydGluZyBTVkcgaW1hZ2VzIGludG8gYW4gYXJyYXkgb2YgdmVjdG9yIHBvaW50cy5cclxuKlxyXG4qIFRvIHVzZSB0aGlzIG1vZHVsZSB5b3UgYWxzbyBuZWVkIHRoZSBTVkdQYXRoU2VnIHBvbHlmaWxsOiBodHRwczovL2dpdGh1Yi5jb20vcHJvZ2Vycy9wYXRoc2VnXHJcbipcclxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxyXG4qXHJcbiogQGNsYXNzIFN2Z1xyXG4qL1xyXG5cclxudmFyIFN2ZyA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdmc7XHJcblxyXG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhbiBTVkcgcGF0aCBpbnRvIGFuIGFycmF5IG9mIHZlY3RvciBwb2ludHMuXHJcbiAgICAgKiBJZiB0aGUgaW5wdXQgcGF0aCBmb3JtcyBhIGNvbmNhdmUgc2hhcGUsIHlvdSBtdXN0IGRlY29tcG9zZSB0aGUgcmVzdWx0IGludG8gY29udmV4IHBhcnRzIGJlZm9yZSB1c2UuXHJcbiAgICAgKiBTZWUgYEJvZGllcy5mcm9tVmVydGljZXNgIHdoaWNoIHByb3ZpZGVzIHN1cHBvcnQgZm9yIHRoaXMuXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBub3QgZ3VhcmFudGVlZCB0byBzdXBwb3J0IGNvbXBsZXggcGF0aHMgKHN1Y2ggYXMgdGhvc2Ugd2l0aCBob2xlcykuXHJcbiAgICAgKiBAbWV0aG9kIHBhdGhUb1ZlcnRpY2VzXHJcbiAgICAgKiBAcGFyYW0ge1NWR1BhdGhFbGVtZW50fSBwYXRoXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NhbXBsZUxlbmd0aD0xNV1cclxuICAgICAqIEByZXR1cm4ge1ZlY3RvcltdfSBwb2ludHNcclxuICAgICAqL1xyXG4gICAgU3ZnLnBhdGhUb1ZlcnRpY2VzID0gZnVuY3Rpb24ocGF0aCwgc2FtcGxlTGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dvdXQvc3ZnLnRvcG9seS5qcy9ibG9iL21hc3Rlci9zdmcudG9wb2x5LmpzXHJcbiAgICAgICAgdmFyIGksIGlsLCB0b3RhbCwgcG9pbnQsIHNlZ21lbnQsIHNlZ21lbnRzLCBcclxuICAgICAgICAgICAgc2VnbWVudHNRdWV1ZSwgbGFzdFNlZ21lbnQsIFxyXG4gICAgICAgICAgICBsYXN0UG9pbnQsIHNlZ21lbnRJbmRleCwgcG9pbnRzID0gW10sXHJcbiAgICAgICAgICAgIGx4LCBseSwgbGVuZ3RoID0gMCwgeCA9IDAsIHkgPSAwO1xyXG5cclxuICAgICAgICBzYW1wbGVMZW5ndGggPSBzYW1wbGVMZW5ndGggfHwgMTU7XHJcblxyXG4gICAgICAgIHZhciBhZGRQb2ludCA9IGZ1bmN0aW9uKHB4LCBweSwgcGF0aFNlZ1R5cGUpIHtcclxuICAgICAgICAgICAgLy8gYWxsIG9kZC1udW1iZXJlZCBwYXRoIHR5cGVzIGFyZSByZWxhdGl2ZSBleGNlcHQgUEFUSFNFR19DTE9TRVBBVEggKDEpXHJcbiAgICAgICAgICAgIHZhciBpc1JlbGF0aXZlID0gcGF0aFNlZ1R5cGUgJSAyID09PSAxICYmIHBhdGhTZWdUeXBlID4gMTtcclxuXHJcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGxhc3QgcG9pbnQgZG9lc24ndCBlcXVhbCB0aGUgY3VycmVudCBwb2ludCBhZGQgdGhlIGN1cnJlbnQgcG9pbnRcclxuICAgICAgICAgICAgaWYgKCFsYXN0UG9pbnQgfHwgcHggIT0gbGFzdFBvaW50LnggfHwgcHkgIT0gbGFzdFBvaW50LnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0UG9pbnQgJiYgaXNSZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGx4ID0gbGFzdFBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgbHkgPSBsYXN0UG9pbnQueTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbHggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGx5ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogbHggKyBweCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBseSArIHB5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNldCBsYXN0IHBvaW50XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWxhdGl2ZSB8fCAhbGFzdFBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHggPSBseCArIHB4O1xyXG4gICAgICAgICAgICAgICAgeSA9IGx5ICsgcHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgYWRkU2VnbWVudFBvaW50ID0gZnVuY3Rpb24oc2VnbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgc2VnVHlwZSA9IHNlZ21lbnQucGF0aFNlZ1R5cGVBc0xldHRlci50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gc2tpcCBwYXRoIGVuZHNcclxuICAgICAgICAgICAgaWYgKHNlZ1R5cGUgPT09ICdaJykgXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBtYXAgc2VnbWVudCB0byB4IGFuZCB5XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2VnVHlwZSkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxyXG4gICAgICAgICAgICBjYXNlICdUJzpcclxuICAgICAgICAgICAgY2FzZSAnQyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1MnOlxyXG4gICAgICAgICAgICBjYXNlICdRJzpcclxuICAgICAgICAgICAgICAgIHggPSBzZWdtZW50Lng7XHJcbiAgICAgICAgICAgICAgICB5ID0gc2VnbWVudC55O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxyXG4gICAgICAgICAgICAgICAgeCA9IHNlZ21lbnQueDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdWJzpcclxuICAgICAgICAgICAgICAgIHkgPSBzZWdtZW50Lnk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYWRkUG9pbnQoeCwgeSwgc2VnbWVudC5wYXRoU2VnVHlwZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gZW5zdXJlIHBhdGggaXMgYWJzb2x1dGVcclxuICAgICAgICBfc3ZnUGF0aFRvQWJzb2x1dGUocGF0aCk7XHJcblxyXG4gICAgICAgIC8vIGdldCB0b3RhbCBsZW5ndGhcclxuICAgICAgICB0b3RhbCA9IHBhdGguZ2V0VG90YWxMZW5ndGgoKTtcclxuXHJcbiAgICAgICAgLy8gcXVldWUgc2VnbWVudHNcclxuICAgICAgICBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRoLnBhdGhTZWdMaXN0Lm51bWJlck9mSXRlbXM7IGkgKz0gMSlcclxuICAgICAgICAgICAgc2VnbWVudHMucHVzaChwYXRoLnBhdGhTZWdMaXN0LmdldEl0ZW0oaSkpO1xyXG5cclxuICAgICAgICBzZWdtZW50c1F1ZXVlID0gc2VnbWVudHMuY29uY2F0KCk7XHJcblxyXG4gICAgICAgIC8vIHNhbXBsZSB0aHJvdWdoIHBhdGhcclxuICAgICAgICB3aGlsZSAobGVuZ3RoIDwgdG90YWwpIHtcclxuICAgICAgICAgICAgLy8gZ2V0IHNlZ21lbnQgYXQgcG9zaXRpb25cclxuICAgICAgICAgICAgc2VnbWVudEluZGV4ID0gcGF0aC5nZXRQYXRoU2VnQXRMZW5ndGgobGVuZ3RoKTtcclxuICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRJbmRleF07XHJcblxyXG4gICAgICAgICAgICAvLyBuZXcgc2VnbWVudFxyXG4gICAgICAgICAgICBpZiAoc2VnbWVudCAhPSBsYXN0U2VnbWVudCkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHNlZ21lbnRzUXVldWUubGVuZ3RoICYmIHNlZ21lbnRzUXVldWVbMF0gIT0gc2VnbWVudClcclxuICAgICAgICAgICAgICAgICAgICBhZGRTZWdtZW50UG9pbnQoc2VnbWVudHNRdWV1ZS5zaGlmdCgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudCA9IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGFkZCBwb2ludHMgaW4gYmV0d2VlbiB3aGVuIGN1cnZpbmdcclxuICAgICAgICAgICAgLy8gVE9ETzogYWRhcHRpdmUgc2FtcGxpbmdcclxuICAgICAgICAgICAgc3dpdGNoIChzZWdtZW50LnBhdGhTZWdUeXBlQXNMZXR0ZXIudG9VcHBlckNhc2UoKSkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnQyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1QnOlxyXG4gICAgICAgICAgICBjYXNlICdTJzpcclxuICAgICAgICAgICAgY2FzZSAnUSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0EnOlxyXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwYXRoLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGFkZFBvaW50KHBvaW50LngsIHBvaW50LnksIDApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgYnkgc2FtcGxlIHZhbHVlXHJcbiAgICAgICAgICAgIGxlbmd0aCArPSBzYW1wbGVMZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHNlZ21lbnRzIG5vdCBwYXNzZWQgYnkgc2FtcGxpbmdcclxuICAgICAgICBmb3IgKGkgPSAwLCBpbCA9IHNlZ21lbnRzUXVldWUubGVuZ3RoOyBpIDwgaWw7ICsraSlcclxuICAgICAgICAgICAgYWRkU2VnbWVudFBvaW50KHNlZ21lbnRzUXVldWVbaV0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX3N2Z1BhdGhUb0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICAgIC8vIGh0dHA6Ly9waHJvZ3oubmV0L2NvbnZlcnQtc3ZnLXBhdGgtdG8tYWxsLWFic29sdXRlLWNvbW1hbmRzXHJcbiAgICAgICAgdmFyIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHNlZ3MgPSBwYXRoLnBhdGhTZWdMaXN0LFxyXG4gICAgICAgICAgICB4ID0gMCwgeSA9IDAsIGxlbiA9IHNlZ3MubnVtYmVyT2ZJdGVtcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vncy5nZXRJdGVtKGkpLFxyXG4gICAgICAgICAgICAgICAgc2VnVHlwZSA9IHNlZy5wYXRoU2VnVHlwZUFzTGV0dGVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKC9bTUxIVkNTUVRBXS8udGVzdChzZWdUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCd4JyBpbiBzZWcpIHggPSBzZWcueDtcclxuICAgICAgICAgICAgICAgIGlmICgneScgaW4gc2VnKSB5ID0gc2VnLnk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJ3gxJyBpbiBzZWcpIHgxID0geCArIHNlZy54MTtcclxuICAgICAgICAgICAgICAgIGlmICgneDInIGluIHNlZykgeDIgPSB4ICsgc2VnLngyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCd5MScgaW4gc2VnKSB5MSA9IHkgKyBzZWcueTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoJ3kyJyBpbiBzZWcpIHkyID0geSArIHNlZy55MjtcclxuICAgICAgICAgICAgICAgIGlmICgneCcgaW4gc2VnKSB4ICs9IHNlZy54O1xyXG4gICAgICAgICAgICAgICAgaWYgKCd5JyBpbiBzZWcpIHkgKz0gc2VnLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZWdUeXBlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdNb3ZldG9BYnMoeCwgeSksIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9BYnMoeCwgeSksIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzKHgpLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnTGluZXRvVmVydGljYWxBYnMoeSksIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYyc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMoeCwgeSwgeDEsIHkxLCB4MiwgeTIpLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoQWJzKHgsIHksIHgyLCB5MiksIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncSc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzKHgsIHksIHgxLCB5MSksIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzKHgsIHkpLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQXJjQWJzKHgsIHksIHNlZy5yMSwgc2VnLnIyLCBzZWcuYW5nbGUsIHNlZy5sYXJnZUFyY0ZsYWcsIHNlZy5zd2VlcEZsYWcpLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnWic6XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgwO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSB5MDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZWdUeXBlID09ICdNJyB8fCBzZWdUeXBlID09ICdtJykge1xyXG4gICAgICAgICAgICAgICAgeDAgPSB4O1xyXG4gICAgICAgICAgICAgICAgeTAgPSB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0pKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvU3ZnLmpzXG4vLyBtb2R1bGUgaWQgPSA0Njdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvU3ZnLmpzIiwidmFyIE1hdHRlciA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY29yZS9NYXR0ZXInKTtcclxuXHJcbk1hdHRlci5Cb2R5ID0gcmVxdWlyZSgnLi4vYm9keS9Cb2R5Jyk7XHJcbk1hdHRlci5Db21wb3NpdGUgPSByZXF1aXJlKCcuLi9ib2R5L0NvbXBvc2l0ZScpO1xyXG5NYXR0ZXIuV29ybGQgPSByZXF1aXJlKCcuLi9ib2R5L1dvcmxkJyk7XHJcblxyXG5NYXR0ZXIuQ29udGFjdCA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9Db250YWN0Jyk7XHJcbk1hdHRlci5EZXRlY3RvciA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9EZXRlY3RvcicpO1xyXG5NYXR0ZXIuR3JpZCA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9HcmlkJyk7XHJcbk1hdHRlci5QYWlycyA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9QYWlycycpO1xyXG5NYXR0ZXIuUGFpciA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9QYWlyJyk7XHJcbk1hdHRlci5RdWVyeSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9RdWVyeScpO1xyXG5NYXR0ZXIuUmVzb2x2ZXIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUmVzb2x2ZXInKTtcclxuTWF0dGVyLlNBVCA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9TQVQnKTtcclxuXHJcbk1hdHRlci5Db25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludC9Db25zdHJhaW50Jyk7XHJcbk1hdHRlci5Nb3VzZUNvbnN0cmFpbnQgPSByZXF1aXJlKCcuLi9jb25zdHJhaW50L01vdXNlQ29uc3RyYWludCcpO1xyXG5cclxuTWF0dGVyLkNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcbk1hdHRlci5FbmdpbmUgPSByZXF1aXJlKCcuLi9jb3JlL0VuZ2luZScpO1xyXG5NYXR0ZXIuRXZlbnRzID0gcmVxdWlyZSgnLi4vY29yZS9FdmVudHMnKTtcclxuTWF0dGVyLk1vdXNlID0gcmVxdWlyZSgnLi4vY29yZS9Nb3VzZScpO1xyXG5NYXR0ZXIuUnVubmVyID0gcmVxdWlyZSgnLi4vY29yZS9SdW5uZXInKTtcclxuTWF0dGVyLlNsZWVwaW5nID0gcmVxdWlyZSgnLi4vY29yZS9TbGVlcGluZycpO1xyXG5NYXR0ZXIuUGx1Z2luID0gcmVxdWlyZSgnLi4vY29yZS9QbHVnaW4nKTtcclxuXHJcbi8vIEBpZiBERUJVR1xyXG5NYXR0ZXIuTWV0cmljcyA9IHJlcXVpcmUoJy4uL2NvcmUvTWV0cmljcycpO1xyXG4vLyBAZW5kaWZcclxuXHJcbk1hdHRlci5Cb2RpZXMgPSByZXF1aXJlKCcuLi9mYWN0b3J5L0JvZGllcycpO1xyXG5NYXR0ZXIuQ29tcG9zaXRlcyA9IHJlcXVpcmUoJy4uL2ZhY3RvcnkvQ29tcG9zaXRlcycpO1xyXG5cclxuTWF0dGVyLkF4ZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9BeGVzJyk7XHJcbk1hdHRlci5Cb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcclxuTWF0dGVyLlN2ZyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1N2ZycpO1xyXG5NYXR0ZXIuVmVjdG9yID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XHJcbk1hdHRlci5WZXJ0aWNlcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlcnRpY2VzJyk7XHJcblxyXG5NYXR0ZXIuUmVuZGVyID0gcmVxdWlyZSgnLi4vcmVuZGVyL1JlbmRlcicpO1xyXG5NYXR0ZXIuUmVuZGVyUGl4aSA9IHJlcXVpcmUoJy4uL3JlbmRlci9SZW5kZXJQaXhpJyk7XHJcblxyXG4vLyBhbGlhc2VzXHJcblxyXG5NYXR0ZXIuV29ybGQuYWRkID0gTWF0dGVyLkNvbXBvc2l0ZS5hZGQ7XHJcbk1hdHRlci5Xb3JsZC5yZW1vdmUgPSBNYXR0ZXIuQ29tcG9zaXRlLnJlbW92ZTtcclxuTWF0dGVyLldvcmxkLmFkZENvbXBvc2l0ZSA9IE1hdHRlci5Db21wb3NpdGUuYWRkQ29tcG9zaXRlO1xyXG5NYXR0ZXIuV29ybGQuYWRkQm9keSA9IE1hdHRlci5Db21wb3NpdGUuYWRkQm9keTtcclxuTWF0dGVyLldvcmxkLmFkZENvbnN0cmFpbnQgPSBNYXR0ZXIuQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQ7XHJcbk1hdHRlci5Xb3JsZC5jbGVhciA9IE1hdHRlci5Db21wb3NpdGUuY2xlYXI7XHJcbk1hdHRlci5FbmdpbmUucnVuID0gTWF0dGVyLlJ1bm5lci5ydW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL21vZHVsZS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSA0Njhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvbW9kdWxlL21haW4uanMiLCIvKipcclxuKiBUaGUgYE1hdHRlci5SZW5kZXJQaXhpYCBtb2R1bGUgaXMgYW4gZXhhbXBsZSByZW5kZXJlciB1c2luZyBwaXhpLmpzLlxyXG4qIFNlZSBhbHNvIGBNYXR0ZXIuUmVuZGVyYCBmb3IgYSBjYW52YXMgYmFzZWQgcmVuZGVyZXIuXHJcbipcclxuKiBAY2xhc3MgUmVuZGVyUGl4aVxyXG4qIEBkZXByZWNhdGVkIHRoZSBNYXR0ZXIuUmVuZGVyUGl4aSBtb2R1bGUgd2lsbCBzb29uIGJlIHJlbW92ZWQgZnJvbSB0aGUgTWF0dGVyLmpzIGNvcmUuXHJcbiogSXQgd2lsbCBsaWtlbHkgYmUgbW92ZWQgdG8gaXRzIG93biByZXBvc2l0b3J5IChidXQgbWFpbnRlbmFuY2Ugd2lsbCBiZSBsaW1pdGVkKS5cclxuKi9cclxuXHJcbnZhciBSZW5kZXJQaXhpID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlclBpeGk7XHJcblxyXG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcbnZhciBDb21wb3NpdGUgPSByZXF1aXJlKCcuLi9ib2R5L0NvbXBvc2l0ZScpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4uL2NvcmUvRXZlbnRzJyk7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgX3JlcXVlc3RBbmltYXRpb25GcmFtZSxcclxuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKXsgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKENvbW1vbi5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcbiAgIFxyXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgUGl4aS5qcyBXZWJHTCByZW5kZXJlclxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHtSZW5kZXJQaXhpfSBBIG5ldyByZW5kZXJlclxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyUGl4aS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgQ29tbW9uLndhcm4oJ1JlbmRlclBpeGkuY3JlYXRlOiBNYXR0ZXIuUmVuZGVyUGl4aSBpcyBkZXByZWNhdGVkIChzZWUgZG9jcyknKTtcclxuXHJcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyOiBSZW5kZXJQaXhpLFxyXG4gICAgICAgICAgICBlbmdpbmU6IG51bGwsXHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXHJcbiAgICAgICAgICAgIGZyYW1lUmVxdWVzdElkOiBudWxsLFxyXG4gICAgICAgICAgICBjYW52YXM6IG51bGwsXHJcbiAgICAgICAgICAgIHJlbmRlcmVyOiBudWxsLFxyXG4gICAgICAgICAgICBjb250YWluZXI6IG51bGwsXHJcbiAgICAgICAgICAgIHNwcml0ZUNvbnRhaW5lcjogbnVsbCxcclxuICAgICAgICAgICAgcGl4aU9wdGlvbnM6IG51bGwsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYwMCxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjZmFmYWZhJyxcclxuICAgICAgICAgICAgICAgIHdpcmVmcmFtZUJhY2tncm91bmQ6ICcjMjIyJyxcclxuICAgICAgICAgICAgICAgIGhhc0JvdW5kczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgd2lyZWZyYW1lczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNob3dTbGVlcGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNob3dEZWJ1ZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93QnJvYWRwaGFzZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93Qm91bmRzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dWZWxvY2l0eTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93Q29sbGlzaW9uczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93QXhlczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93UG9zaXRpb25zOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dBbmdsZUluZGljYXRvcjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93SWRzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dTaGFkb3dzOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHJlbmRlciA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpLFxyXG4gICAgICAgICAgICB0cmFuc3BhcmVudCA9ICFyZW5kZXIub3B0aW9ucy53aXJlZnJhbWVzICYmIHJlbmRlci5vcHRpb25zLmJhY2tncm91bmQgPT09ICd0cmFuc3BhcmVudCc7XHJcblxyXG4gICAgICAgIC8vIGluaXQgcGl4aVxyXG4gICAgICAgIHJlbmRlci5waXhpT3B0aW9ucyA9IHJlbmRlci5waXhpT3B0aW9ucyB8fCB7XHJcbiAgICAgICAgICAgIHZpZXc6IHJlbmRlci5jYW52YXMsXHJcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cmFuc3BhcmVudCxcclxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJlbmRlci5tb3VzZSA9IG9wdGlvbnMubW91c2U7XHJcbiAgICAgICAgcmVuZGVyLmVuZ2luZSA9IG9wdGlvbnMuZW5naW5lO1xyXG4gICAgICAgIHJlbmRlci5yZW5kZXJlciA9IHJlbmRlci5yZW5kZXJlciB8fCBuZXcgUElYSS5XZWJHTFJlbmRlcmVyKHJlbmRlci5vcHRpb25zLndpZHRoLCByZW5kZXIub3B0aW9ucy5oZWlnaHQsIHJlbmRlci5waXhpT3B0aW9ucyk7XHJcbiAgICAgICAgcmVuZGVyLmNvbnRhaW5lciA9IHJlbmRlci5jb250YWluZXIgfHwgbmV3IFBJWEkuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgcmVuZGVyLnNwcml0ZUNvbnRhaW5lciA9IHJlbmRlci5zcHJpdGVDb250YWluZXIgfHwgbmV3IFBJWEkuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgcmVuZGVyLmNhbnZhcyA9IHJlbmRlci5jYW52YXMgfHwgcmVuZGVyLnJlbmRlcmVyLnZpZXc7XHJcbiAgICAgICAgcmVuZGVyLmJvdW5kcyA9IHJlbmRlci5ib3VuZHMgfHwgeyBcclxuICAgICAgICAgICAgbWluOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMFxyXG4gICAgICAgICAgICB9LCBcclxuICAgICAgICAgICAgbWF4OiB7IFxyXG4gICAgICAgICAgICAgICAgeDogcmVuZGVyLm9wdGlvbnMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICB5OiByZW5kZXIub3B0aW9ucy5oZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgIEV2ZW50cy5vbihyZW5kZXIuZW5naW5lLCAnYmVmb3JlVXBkYXRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFJlbmRlclBpeGkuY2xlYXIocmVuZGVyKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gY2FjaGVzXHJcbiAgICAgICAgcmVuZGVyLnRleHR1cmVzID0ge307XHJcbiAgICAgICAgcmVuZGVyLnNwcml0ZXMgPSB7fTtcclxuICAgICAgICByZW5kZXIucHJpbWl0aXZlcyA9IHt9O1xyXG5cclxuICAgICAgICAvLyB1c2UgYSBzcHJpdGUgYmF0Y2ggZm9yIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgcmVuZGVyLmNvbnRhaW5lci5hZGRDaGlsZChyZW5kZXIuc3ByaXRlQ29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgLy8gaW5zZXJ0IGNhbnZhc1xyXG4gICAgICAgIGlmIChDb21tb24uaXNFbGVtZW50KHJlbmRlci5lbGVtZW50KSkge1xyXG4gICAgICAgICAgICByZW5kZXIuZWxlbWVudC5hcHBlbmRDaGlsZChyZW5kZXIuY2FudmFzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBDb21tb24ud2FybignTm8gXCJyZW5kZXIuZWxlbWVudFwiIHBhc3NlZCwgXCJyZW5kZXIuY2FudmFzXCIgd2FzIG5vdCBpbnNlcnRlZCBpbnRvIGRvY3VtZW50LicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcHJldmVudCBtZW51cyBvbiBjYW52YXNcclxuICAgICAgICByZW5kZXIuY2FudmFzLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG4gICAgICAgIHJlbmRlci5jYW52YXMub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XHJcblxyXG4gICAgICAgIHJldHVybiByZW5kZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udGludW91c2x5IHVwZGF0ZXMgdGhlIHJlbmRlciBjYW52YXMgb24gdGhlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGV2ZW50LlxyXG4gICAgICogQG1ldGhvZCBydW5cclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIFJlbmRlclBpeGkucnVuID0gZnVuY3Rpb24ocmVuZGVyKSB7XHJcbiAgICAgICAgKGZ1bmN0aW9uIGxvb3AodGltZSl7XHJcbiAgICAgICAgICAgIHJlbmRlci5mcmFtZVJlcXVlc3RJZCA9IF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XHJcbiAgICAgICAgICAgIFJlbmRlclBpeGkud29ybGQocmVuZGVyKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuZHMgZXhlY3V0aW9uIG9mIGBSZW5kZXIucnVuYCBvbiB0aGUgZ2l2ZW4gYHJlbmRlcmAsIGJ5IGNhbmNlbGluZyB0aGUgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3QgZXZlbnQgbG9vcC5cclxuICAgICAqIEBtZXRob2Qgc3RvcFxyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyUGl4aS5zdG9wID0gZnVuY3Rpb24ocmVuZGVyKSB7XHJcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lKHJlbmRlci5mcmFtZVJlcXVlc3RJZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBzY2VuZSBncmFwaFxyXG4gICAgICogQG1ldGhvZCBjbGVhclxyXG4gICAgICogQHBhcmFtIHtSZW5kZXJQaXhpfSByZW5kZXJcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIFJlbmRlclBpeGkuY2xlYXIgPSBmdW5jdGlvbihyZW5kZXIpIHtcclxuICAgICAgICB2YXIgY29udGFpbmVyID0gcmVuZGVyLmNvbnRhaW5lcixcclxuICAgICAgICAgICAgc3ByaXRlQ29udGFpbmVyID0gcmVuZGVyLnNwcml0ZUNvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgLy8gY2xlYXIgc3RhZ2UgY29udGFpbmVyXHJcbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lci5jaGlsZHJlblswXSkgeyBcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5jaGlsZHJlblswXSk7IFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2xlYXIgc3ByaXRlIGJhdGNoXHJcbiAgICAgICAgd2hpbGUgKHNwcml0ZUNvbnRhaW5lci5jaGlsZHJlblswXSkgeyBcclxuICAgICAgICAgICAgc3ByaXRlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHNwcml0ZUNvbnRhaW5lci5jaGlsZHJlblswXSk7IFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJnU3ByaXRlID0gcmVuZGVyLnNwcml0ZXNbJ2JnLTAnXTtcclxuXHJcbiAgICAgICAgLy8gY2xlYXIgY2FjaGVzXHJcbiAgICAgICAgcmVuZGVyLnRleHR1cmVzID0ge307XHJcbiAgICAgICAgcmVuZGVyLnNwcml0ZXMgPSB7fTtcclxuICAgICAgICByZW5kZXIucHJpbWl0aXZlcyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBzZXQgYmFja2dyb3VuZCBzcHJpdGVcclxuICAgICAgICByZW5kZXIuc3ByaXRlc1snYmctMCddID0gYmdTcHJpdGU7XHJcbiAgICAgICAgaWYgKGJnU3ByaXRlKVxyXG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGRBdChiZ1Nwcml0ZSwgMCk7XHJcblxyXG4gICAgICAgIC8vIGFkZCBzcHJpdGUgYmF0Y2ggYmFjayBpbnRvIGNvbnRhaW5lclxyXG4gICAgICAgIHJlbmRlci5jb250YWluZXIuYWRkQ2hpbGQocmVuZGVyLnNwcml0ZUNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IGJhY2tncm91bmQgc3RhdGVcclxuICAgICAgICByZW5kZXIuY3VycmVudEJhY2tncm91bmQgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyByZXNldCBib3VuZHMgdHJhbnNmb3Jtc1xyXG4gICAgICAgIGNvbnRhaW5lci5zY2FsZS5zZXQoMSwgMSk7XHJcbiAgICAgICAgY29udGFpbmVyLnBvc2l0aW9uLnNldCgwLCAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBiYWNrZ3JvdW5kIG9mIHRoZSBjYW52YXMgXHJcbiAgICAgKiBAbWV0aG9kIHNldEJhY2tncm91bmRcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyUGl4aX0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFja2dyb3VuZFxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyUGl4aS5zZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24ocmVuZGVyLCBiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgaWYgKHJlbmRlci5jdXJyZW50QmFja2dyb3VuZCAhPT0gYmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgICB2YXIgaXNDb2xvciA9IGJhY2tncm91bmQuaW5kZXhPZiAmJiBiYWNrZ3JvdW5kLmluZGV4T2YoJyMnKSAhPT0gLTEsXHJcbiAgICAgICAgICAgICAgICBiZ1Nwcml0ZSA9IHJlbmRlci5zcHJpdGVzWydiZy0wJ107XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgc29saWQgYmFja2dyb3VuZCBjb2xvclxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gQ29tbW9uLmNvbG9yVG9OdW1iZXIoYmFja2dyb3VuZCk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXIucmVuZGVyZXIuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGJhY2tncm91bmQgc3ByaXRlIGlmIGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoYmdTcHJpdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyLmNvbnRhaW5lci5yZW1vdmVDaGlsZChiZ1Nwcml0ZSk7IFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGlzZSBiYWNrZ3JvdW5kIHNwcml0ZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGlmICghYmdTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZSA9IF9nZXRUZXh0dXJlKHJlbmRlciwgYmFja2dyb3VuZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJnU3ByaXRlID0gcmVuZGVyLnNwcml0ZXNbJ2JnLTAnXSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgICAgICBiZ1Nwcml0ZS5wb3NpdGlvbi54ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBiZ1Nwcml0ZS5wb3NpdGlvbi55ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXIuY29udGFpbmVyLmFkZENoaWxkQXQoYmdTcHJpdGUsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZW5kZXIuY3VycmVudEJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNjcmlwdGlvblxyXG4gICAgICogQG1ldGhvZCB3b3JsZFxyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyUGl4aS53b3JsZCA9IGZ1bmN0aW9uKHJlbmRlcikge1xyXG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxyXG4gICAgICAgICAgICB3b3JsZCA9IGVuZ2luZS53b3JsZCxcclxuICAgICAgICAgICAgcmVuZGVyZXIgPSByZW5kZXIucmVuZGVyZXIsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHJlbmRlci5jb250YWluZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcclxuICAgICAgICAgICAgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCksXHJcbiAgICAgICAgICAgIGFsbENvbnN0cmFpbnRzID0gQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKHdvcmxkKSxcclxuICAgICAgICAgICAgY29uc3RyYWludHMgPSBbXSxcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xyXG4gICAgICAgICAgICBSZW5kZXJQaXhpLnNldEJhY2tncm91bmQocmVuZGVyLCBvcHRpb25zLndpcmVmcmFtZUJhY2tncm91bmQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIFJlbmRlclBpeGkuc2V0QmFja2dyb3VuZChyZW5kZXIsIG9wdGlvbnMuYmFja2dyb3VuZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBoYW5kbGUgYm91bmRzXHJcbiAgICAgICAgdmFyIGJvdW5kc1dpZHRoID0gcmVuZGVyLmJvdW5kcy5tYXgueCAtIHJlbmRlci5ib3VuZHMubWluLngsXHJcbiAgICAgICAgICAgIGJvdW5kc0hlaWdodCA9IHJlbmRlci5ib3VuZHMubWF4LnkgLSByZW5kZXIuYm91bmRzLm1pbi55LFxyXG4gICAgICAgICAgICBib3VuZHNTY2FsZVggPSBib3VuZHNXaWR0aCAvIHJlbmRlci5vcHRpb25zLndpZHRoLFxyXG4gICAgICAgICAgICBib3VuZHNTY2FsZVkgPSBib3VuZHNIZWlnaHQgLyByZW5kZXIub3B0aW9ucy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmhhc0JvdW5kcykge1xyXG4gICAgICAgICAgICAvLyBIaWRlIGJvZGllcyB0aGF0IGFyZSBub3QgaW4gdmlld1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgIGJvZHkucmVuZGVyLnNwcml0ZS52aXNpYmxlID0gQm91bmRzLm92ZXJsYXBzKGJvZHkuYm91bmRzLCByZW5kZXIuYm91bmRzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBjb25zdHJhaW50cyB0aGF0IGFyZSBub3QgaW4gdmlld1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gYWxsQ29uc3RyYWludHNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEgPSBjb25zdHJhaW50LmJvZHlBLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCID0gY29uc3RyYWludC5ib2R5QixcclxuICAgICAgICAgICAgICAgICAgICBwb2ludEFXb3JsZCA9IGNvbnN0cmFpbnQucG9pbnRBLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50QldvcmxkID0gY29uc3RyYWludC5wb2ludEI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBKSBwb2ludEFXb3JsZCA9IFZlY3Rvci5hZGQoYm9keUEucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRBKTtcclxuICAgICAgICAgICAgICAgIGlmIChib2R5QikgcG9pbnRCV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlCLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50Qik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludEFXb3JsZCB8fCAhcG9pbnRCV29ybGQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKEJvdW5kcy5jb250YWlucyhyZW5kZXIuYm91bmRzLCBwb2ludEFXb3JsZCkgfHwgQm91bmRzLmNvbnRhaW5zKHJlbmRlci5ib3VuZHMsIHBvaW50QldvcmxkKSlcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gdGhlIHZpZXdcclxuICAgICAgICAgICAgY29udGFpbmVyLnNjYWxlLnNldCgxIC8gYm91bmRzU2NhbGVYLCAxIC8gYm91bmRzU2NhbGVZKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLnBvc2l0aW9uLnNldCgtcmVuZGVyLmJvdW5kcy5taW4ueCAqICgxIC8gYm91bmRzU2NhbGVYKSwgLXJlbmRlci5ib3VuZHMubWluLnkgKiAoMSAvIGJvdW5kc1NjYWxlWSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gYWxsQ29uc3RyYWludHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBSZW5kZXJQaXhpLmJvZHkocmVuZGVyLCBib2RpZXNbaV0pO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uc3RyYWludHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIFJlbmRlclBpeGkuY29uc3RyYWludChyZW5kZXIsIGNvbnN0cmFpbnRzW2ldKTtcclxuXHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKGNvbnRhaW5lcik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc2NyaXB0aW9uXHJcbiAgICAgKiBAbWV0aG9kIGNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcclxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyUGl4aS5jb25zdHJhaW50ID0gZnVuY3Rpb24ocmVuZGVyLCBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgdmFyIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXHJcbiAgICAgICAgICAgIGJvZHlBID0gY29uc3RyYWludC5ib2R5QSxcclxuICAgICAgICAgICAgYm9keUIgPSBjb25zdHJhaW50LmJvZHlCLFxyXG4gICAgICAgICAgICBwb2ludEEgPSBjb25zdHJhaW50LnBvaW50QSxcclxuICAgICAgICAgICAgcG9pbnRCID0gY29uc3RyYWludC5wb2ludEIsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHJlbmRlci5jb250YWluZXIsXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRSZW5kZXIgPSBjb25zdHJhaW50LnJlbmRlcixcclxuICAgICAgICAgICAgcHJpbWl0aXZlSWQgPSAnYy0nICsgY29uc3RyYWludC5pZCxcclxuICAgICAgICAgICAgcHJpbWl0aXZlID0gcmVuZGVyLnByaW1pdGl2ZXNbcHJpbWl0aXZlSWRdO1xyXG5cclxuICAgICAgICAvLyBpbml0aWFsaXNlIGNvbnN0cmFpbnQgcHJpbWl0aXZlIGlmIG5vdCBleGlzdGluZ1xyXG4gICAgICAgIGlmICghcHJpbWl0aXZlKVxyXG4gICAgICAgICAgICBwcmltaXRpdmUgPSByZW5kZXIucHJpbWl0aXZlc1twcmltaXRpdmVJZF0gPSBuZXcgUElYSS5HcmFwaGljcygpO1xyXG5cclxuICAgICAgICAvLyBkb24ndCByZW5kZXIgaWYgY29uc3RyYWludCBkb2VzIG5vdCBoYXZlIHR3byBlbmQgcG9pbnRzXHJcbiAgICAgICAgaWYgKCFjb25zdHJhaW50UmVuZGVyLnZpc2libGUgfHwgIWNvbnN0cmFpbnQucG9pbnRBIHx8ICFjb25zdHJhaW50LnBvaW50Qikge1xyXG4gICAgICAgICAgICBwcmltaXRpdmUuY2xlYXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWRkIHRvIHNjZW5lIGdyYXBoIGlmIG5vdCBhbHJlYWR5IHRoZXJlXHJcbiAgICAgICAgaWYgKENvbW1vbi5pbmRleE9mKGNvbnRhaW5lci5jaGlsZHJlbiwgcHJpbWl0aXZlKSA9PT0gLTEpXHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChwcmltaXRpdmUpO1xyXG5cclxuICAgICAgICAvLyByZW5kZXIgdGhlIGNvbnN0cmFpbnQgb24gZXZlcnkgdXBkYXRlLCBzaW5jZSB0aGV5IGNhbiBjaGFuZ2UgZHluYW1pY2FsbHlcclxuICAgICAgICBwcmltaXRpdmUuY2xlYXIoKTtcclxuICAgICAgICBwcmltaXRpdmUuYmVnaW5GaWxsKDAsIDApO1xyXG4gICAgICAgIHByaW1pdGl2ZS5saW5lU3R5bGUoY29uc3RyYWludFJlbmRlci5saW5lV2lkdGgsIENvbW1vbi5jb2xvclRvTnVtYmVyKGNvbnN0cmFpbnRSZW5kZXIuc3Ryb2tlU3R5bGUpLCAxKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoYm9keUEpIHtcclxuICAgICAgICAgICAgcHJpbWl0aXZlLm1vdmVUbyhib2R5QS5wb3NpdGlvbi54ICsgcG9pbnRBLngsIGJvZHlBLnBvc2l0aW9uLnkgKyBwb2ludEEueSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHJpbWl0aXZlLm1vdmVUbyhwb2ludEEueCwgcG9pbnRBLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJvZHlCKSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5saW5lVG8oYm9keUIucG9zaXRpb24ueCArIHBvaW50Qi54LCBib2R5Qi5wb3NpdGlvbi55ICsgcG9pbnRCLnkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5saW5lVG8ocG9pbnRCLngsIHBvaW50Qi55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaW1pdGl2ZS5lbmRGaWxsKCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIERlc2NyaXB0aW9uXHJcbiAgICAgKiBAbWV0aG9kIGJvZHlcclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyUGl4aS5ib2R5ID0gZnVuY3Rpb24ocmVuZGVyLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXHJcbiAgICAgICAgICAgIGJvZHlSZW5kZXIgPSBib2R5LnJlbmRlcjtcclxuXHJcbiAgICAgICAgaWYgKCFib2R5UmVuZGVyLnZpc2libGUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKGJvZHlSZW5kZXIuc3ByaXRlICYmIGJvZHlSZW5kZXIuc3ByaXRlLnRleHR1cmUpIHtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZUlkID0gJ2ItJyArIGJvZHkuaWQsXHJcbiAgICAgICAgICAgICAgICBzcHJpdGUgPSByZW5kZXIuc3ByaXRlc1tzcHJpdGVJZF0sXHJcbiAgICAgICAgICAgICAgICBzcHJpdGVDb250YWluZXIgPSByZW5kZXIuc3ByaXRlQ29udGFpbmVyO1xyXG5cclxuICAgICAgICAgICAgLy8gaW5pdGlhbGlzZSBib2R5IHNwcml0ZSBpZiBub3QgZXhpc3RpbmdcclxuICAgICAgICAgICAgaWYgKCFzcHJpdGUpXHJcbiAgICAgICAgICAgICAgICBzcHJpdGUgPSByZW5kZXIuc3ByaXRlc1tzcHJpdGVJZF0gPSBfY3JlYXRlQm9keVNwcml0ZShyZW5kZXIsIGJvZHkpO1xyXG5cclxuICAgICAgICAgICAgLy8gYWRkIHRvIHNjZW5lIGdyYXBoIGlmIG5vdCBhbHJlYWR5IHRoZXJlXHJcbiAgICAgICAgICAgIGlmIChDb21tb24uaW5kZXhPZihzcHJpdGVDb250YWluZXIuY2hpbGRyZW4sIHNwcml0ZSkgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgc3ByaXRlQ29udGFpbmVyLmFkZENoaWxkKHNwcml0ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgYm9keSBzcHJpdGVcclxuICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnggPSBib2R5LnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi55ID0gYm9keS5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBzcHJpdGUucm90YXRpb24gPSBib2R5LmFuZ2xlO1xyXG4gICAgICAgICAgICBzcHJpdGUuc2NhbGUueCA9IGJvZHlSZW5kZXIuc3ByaXRlLnhTY2FsZSB8fCAxO1xyXG4gICAgICAgICAgICBzcHJpdGUuc2NhbGUueSA9IGJvZHlSZW5kZXIuc3ByaXRlLnlTY2FsZSB8fCAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwcmltaXRpdmVJZCA9ICdiLScgKyBib2R5LmlkLFxyXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlID0gcmVuZGVyLnByaW1pdGl2ZXNbcHJpbWl0aXZlSWRdLFxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gcmVuZGVyLmNvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgYm9keSBwcmltaXRpdmUgaWYgbm90IGV4aXN0aW5nXHJcbiAgICAgICAgICAgIGlmICghcHJpbWl0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUgPSByZW5kZXIucHJpbWl0aXZlc1twcmltaXRpdmVJZF0gPSBfY3JlYXRlQm9keVByaW1pdGl2ZShyZW5kZXIsIGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLmluaXRpYWxBbmdsZSA9IGJvZHkuYW5nbGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGFkZCB0byBzY2VuZSBncmFwaCBpZiBub3QgYWxyZWFkeSB0aGVyZVxyXG4gICAgICAgICAgICBpZiAoQ29tbW9uLmluZGV4T2YoY29udGFpbmVyLmNoaWxkcmVuLCBwcmltaXRpdmUpID09PSAtMSlcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChwcmltaXRpdmUpO1xyXG5cclxuICAgICAgICAgICAgLy8gdXBkYXRlIGJvZHkgcHJpbWl0aXZlXHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5wb3NpdGlvbi54ID0gYm9keS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICBwcmltaXRpdmUucG9zaXRpb24ueSA9IGJvZHkucG9zaXRpb24ueTtcclxuICAgICAgICAgICAgcHJpbWl0aXZlLnJvdGF0aW9uID0gYm9keS5hbmdsZSAtIHByaW1pdGl2ZS5pbml0aWFsQW5nbGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBib2R5IHNwcml0ZVxyXG4gICAgICogQG1ldGhvZCBfY3JlYXRlQm9keVNwcml0ZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyUGl4aX0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEByZXR1cm4ge1BJWEkuU3ByaXRlfSBzcHJpdGVcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIHZhciBfY3JlYXRlQm9keVNwcml0ZSA9IGZ1bmN0aW9uKHJlbmRlciwgYm9keSkge1xyXG4gICAgICAgIHZhciBib2R5UmVuZGVyID0gYm9keS5yZW5kZXIsXHJcbiAgICAgICAgICAgIHRleHR1cmVQYXRoID0gYm9keVJlbmRlci5zcHJpdGUudGV4dHVyZSxcclxuICAgICAgICAgICAgdGV4dHVyZSA9IF9nZXRUZXh0dXJlKHJlbmRlciwgdGV4dHVyZVBhdGgpLFxyXG4gICAgICAgICAgICBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XHJcblxyXG4gICAgICAgIHNwcml0ZS5hbmNob3IueCA9IGJvZHkucmVuZGVyLnNwcml0ZS54T2Zmc2V0O1xyXG4gICAgICAgIHNwcml0ZS5hbmNob3IueSA9IGJvZHkucmVuZGVyLnNwcml0ZS55T2Zmc2V0O1xyXG5cclxuICAgICAgICByZXR1cm4gc3ByaXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBib2R5IHByaW1pdGl2ZVxyXG4gICAgICogQG1ldGhvZCBfY3JlYXRlQm9keVByaW1pdGl2ZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyUGl4aX0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IGdyYXBoaWNzXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICB2YXIgX2NyZWF0ZUJvZHlQcmltaXRpdmUgPSBmdW5jdGlvbihyZW5kZXIsIGJvZHkpIHtcclxuICAgICAgICB2YXIgYm9keVJlbmRlciA9IGJvZHkucmVuZGVyLFxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIHByaW1pdGl2ZSA9IG5ldyBQSVhJLkdyYXBoaWNzKCksXHJcbiAgICAgICAgICAgIGZpbGxTdHlsZSA9IENvbW1vbi5jb2xvclRvTnVtYmVyKGJvZHlSZW5kZXIuZmlsbFN0eWxlKSxcclxuICAgICAgICAgICAgc3Ryb2tlU3R5bGUgPSBDb21tb24uY29sb3JUb051bWJlcihib2R5UmVuZGVyLnN0cm9rZVN0eWxlKSxcclxuICAgICAgICAgICAgc3Ryb2tlU3R5bGVJbmRpY2F0b3IgPSBDb21tb24uY29sb3JUb051bWJlcihib2R5UmVuZGVyLnN0cm9rZVN0eWxlKSxcclxuICAgICAgICAgICAgc3Ryb2tlU3R5bGVXaXJlZnJhbWUgPSBDb21tb24uY29sb3JUb051bWJlcignI2JiYicpLFxyXG4gICAgICAgICAgICBzdHJva2VTdHlsZVdpcmVmcmFtZUluZGljYXRvciA9IENvbW1vbi5jb2xvclRvTnVtYmVyKCcjQ0Q1QzVDJyksXHJcbiAgICAgICAgICAgIHBhcnQ7XHJcblxyXG4gICAgICAgIHByaW1pdGl2ZS5jbGVhcigpO1xyXG5cclxuICAgICAgICAvLyBoYW5kbGUgY29tcG91bmQgcGFydHNcclxuICAgICAgICBmb3IgKHZhciBrID0gYm9keS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBib2R5LnBhcnRzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIHBhcnQgPSBib2R5LnBhcnRzW2tdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5iZWdpbkZpbGwoZmlsbFN0eWxlLCAxKTtcclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5saW5lU3R5bGUoYm9keVJlbmRlci5saW5lV2lkdGgsIHN0cm9rZVN0eWxlLCAxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5iZWdpbkZpbGwoMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVN0eWxlKDEsIHN0cm9rZVN0eWxlV2lyZWZyYW1lLCAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJpbWl0aXZlLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWzBdLnggLSBib2R5LnBvc2l0aW9uLngsIHBhcnQudmVydGljZXNbMF0ueSAtIGJvZHkucG9zaXRpb24ueSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHBhcnQudmVydGljZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5saW5lVG8ocGFydC52ZXJ0aWNlc1tqXS54IC0gYm9keS5wb3NpdGlvbi54LCBwYXJ0LnZlcnRpY2VzW2pdLnkgLSBib2R5LnBvc2l0aW9uLnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmltaXRpdmUubGluZVRvKHBhcnQudmVydGljZXNbMF0ueCAtIGJvZHkucG9zaXRpb24ueCwgcGFydC52ZXJ0aWNlc1swXS55IC0gYm9keS5wb3NpdGlvbi55KTtcclxuXHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5lbmRGaWxsKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBhbmdsZSBpbmRpY2F0b3JcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0FuZ2xlSW5kaWNhdG9yIHx8IG9wdGlvbnMuc2hvd0F4ZXMpIHtcclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5iZWdpbkZpbGwoMCwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5saW5lU3R5bGUoMSwgc3Ryb2tlU3R5bGVXaXJlZnJhbWVJbmRpY2F0b3IsIDEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVN0eWxlKDEsIHN0cm9rZVN0eWxlSW5kaWNhdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUubW92ZVRvKHBhcnQucG9zaXRpb24ueCAtIGJvZHkucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5saW5lVG8oKChwYXJ0LnZlcnRpY2VzWzBdLnggKyBwYXJ0LnZlcnRpY2VzW3BhcnQudmVydGljZXMubGVuZ3RoLTFdLngpIC8gMiAtIGJvZHkucG9zaXRpb24ueCksIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHBhcnQudmVydGljZXNbMF0ueSArIHBhcnQudmVydGljZXNbcGFydC52ZXJ0aWNlcy5sZW5ndGgtMV0ueSkgLyAyIC0gYm9keS5wb3NpdGlvbi55KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByZXF1ZXN0ZWQgdGV4dHVyZSAoYSBQSVhJLlRleHR1cmUpIHZpYSBpdHMgcGF0aFxyXG4gICAgICogQG1ldGhvZCBfZ2V0VGV4dHVyZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyUGl4aX0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VQYXRoXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IHRleHR1cmVcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIHZhciBfZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHJlbmRlciwgaW1hZ2VQYXRoKSB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSByZW5kZXIudGV4dHVyZXNbaW1hZ2VQYXRoXTtcclxuXHJcbiAgICAgICAgaWYgKCF0ZXh0dXJlKVxyXG4gICAgICAgICAgICB0ZXh0dXJlID0gcmVuZGVyLnRleHR1cmVzW2ltYWdlUGF0aF0gPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKGltYWdlUGF0aCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL3JlbmRlci9SZW5kZXJQaXhpLmpzXG4vLyBtb2R1bGUgaWQgPSA0Njlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlclBpeGkuanMiLCIvKipcclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogQSBwb2x5ZmlsbCBmb3IgQXJyYXkuZm9yRWFjaFxyXG4qIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2hcclxuKi9cclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaClcclxue1xyXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZnVuIC8qLCB0aGlzQXJnICovKVxyXG4gICAge1xyXG4gICAgICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XHJcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZ1biAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGkgaW4gdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9BcnJheS5mb3JFYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0NzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIEEgcG9seWZpbGwgZm9yIEFycmF5LmlzQXJyYXlcclxuKi9cclxuaWYgKCFBcnJheS5pc0FycmF5KVxyXG57XHJcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKGFyZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9BcnJheS5pc0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogQ29weXJpZ2h0IDIwMTMgQ2hyaXMgV2lsc29uXG5cbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLypcblxuVGhpcyBtb25rZXlwYXRjaCBsaWJyYXJ5IGlzIGludGVuZGVkIHRvIGJlIGluY2x1ZGVkIGluIHByb2plY3RzIHRoYXQgYXJlXG53cml0dGVuIHRvIHRoZSBwcm9wZXIgQXVkaW9Db250ZXh0IHNwZWMgKGluc3RlYWQgb2Ygd2Via2l0QXVkaW9Db250ZXh0KSxcbmFuZCB0aGF0IHVzZSB0aGUgbmV3IG5hbWluZyBhbmQgcHJvcGVyIGJpdHMgb2YgdGhlIFdlYiBBdWRpbyBBUEkgKGUuZy5cbnVzaW5nIEJ1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKSBpbnN0ZWFkIG9mIEJ1ZmZlclNvdXJjZU5vZGUubm90ZU9uKCkpLCBidXQgbWF5XG5oYXZlIHRvIHJ1biBvbiBzeXN0ZW1zIHRoYXQgb25seSBzdXBwb3J0IHRoZSBkZXByZWNhdGVkIGJpdHMuXG5cblRoaXMgbGlicmFyeSBzaG91bGQgYmUgaGFybWxlc3MgdG8gaW5jbHVkZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0c1xudW5wcmVmaXhlZCBcIkF1ZGlvQ29udGV4dFwiLCBhbmQvb3IgaWYgaXQgc3VwcG9ydHMgdGhlIG5ldyBuYW1lcy5cblxuVGhlIHBhdGNoZXMgdGhpcyBsaWJyYXJ5IGhhbmRsZXM6XG5pZiB3aW5kb3cuQXVkaW9Db250ZXh0IGlzIHVuc3VwcG9ydGVkLCBpdCB3aWxsIGJlIGFsaWFzZWQgdG8gd2Via2l0QXVkaW9Db250ZXh0KCkuXG5pZiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKSBpcyB1bmltcGxlbWVudGVkLCBpdCB3aWxsIGJlIHJvdXRlZCB0byBub3RlT24oKSBvclxubm90ZUdyYWluT24oKSwgZGVwZW5kaW5nIG9uIHBhcmFtZXRlcnMuXG5cblRoZSBmb2xsb3dpbmcgYWxpYXNlcyBvbmx5IHRha2UgZWZmZWN0IGlmIHRoZSBuZXcgbmFtZXMgYXJlIG5vdCBhbHJlYWR5IGluIHBsYWNlOlxuXG5BdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RvcCgpIGlzIGFsaWFzZWQgdG8gbm90ZU9mZigpXG5BdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpIGlzIGFsaWFzZWQgdG8gY3JlYXRlR2Fpbk5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZURlbGF5KCkgaXMgYWxpYXNlZCB0byBjcmVhdGVEZWxheU5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcigpIGlzIGFsaWFzZWQgdG8gY3JlYXRlSmF2YVNjcmlwdE5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZVBlcmlvZGljV2F2ZSgpIGlzIGFsaWFzZWQgdG8gY3JlYXRlV2F2ZVRhYmxlKClcbk9zY2lsbGF0b3JOb2RlLnN0YXJ0KCkgaXMgYWxpYXNlZCB0byBub3RlT24oKVxuT3NjaWxsYXRvck5vZGUuc3RvcCgpIGlzIGFsaWFzZWQgdG8gbm90ZU9mZigpXG5Pc2NpbGxhdG9yTm9kZS5zZXRQZXJpb2RpY1dhdmUoKSBpcyBhbGlhc2VkIHRvIHNldFdhdmVUYWJsZSgpXG5BdWRpb1BhcmFtLnNldFRhcmdldEF0VGltZSgpIGlzIGFsaWFzZWQgdG8gc2V0VGFyZ2V0VmFsdWVBdFRpbWUoKVxuXG5UaGlzIGxpYnJhcnkgZG9lcyBOT1QgcGF0Y2ggdGhlIGVudW1lcmF0ZWQgdHlwZSBjaGFuZ2VzLCBhcyBpdCBpc1xucmVjb21tZW5kZWQgaW4gdGhlIHNwZWNpZmljYXRpb24gdGhhdCBpbXBsZW1lbnRhdGlvbnMgc3VwcG9ydCBib3RoIGludGVnZXJcbmFuZCBzdHJpbmcgdHlwZXMgZm9yIEF1ZGlvUGFubmVyTm9kZS5wYW5uaW5nTW9kZWwsIEF1ZGlvUGFubmVyTm9kZS5kaXN0YW5jZU1vZGVsXG5CaXF1YWRGaWx0ZXJOb2RlLnR5cGUgYW5kIE9zY2lsbGF0b3JOb2RlLnR5cGUuXG5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZXhwb3J0cywgcGVyZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gZml4U2V0VGFyZ2V0KHBhcmFtKSB7XG4gICAgaWYgKCFwYXJhbSlcdC8vIGlmIE5ZSSwganVzdCByZXR1cm5cbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXBhcmFtLnNldFRhcmdldEF0VGltZSlcbiAgICAgIHBhcmFtLnNldFRhcmdldEF0VGltZSA9IHBhcmFtLnNldFRhcmdldFZhbHVlQXRUaW1lO1xuICB9XG5cbiAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0QXVkaW9Db250ZXh0JykgJiZcbiAgICAgICF3aW5kb3cuaGFzT3duUHJvcGVydHkoJ0F1ZGlvQ29udGV4dCcpKSB7XG4gICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdlYmtpdEF1ZGlvQ29udGV4dDtcblxuICAgIGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlR2FpbicpKVxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluTm9kZTtcbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZURlbGF5JykpXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5ID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheU5vZGU7XG4gICAgaWYgKCFBdWRpb0NvbnRleHQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjcmVhdGVTY3JpcHRQcm9jZXNzb3InKSlcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlU2NyaXB0UHJvY2Vzc29yID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVKYXZhU2NyaXB0Tm9kZTtcbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZVBlcmlvZGljV2F2ZScpKVxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVQZXJpb2RpY1dhdmUgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVdhdmVUYWJsZTtcblxuXG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZUdhaW4oKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmdhaW4pO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlRGVsYXkgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5O1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXkgPSBmdW5jdGlvbihtYXhEZWxheVRpbWUpIHtcbiAgICAgIHZhciBub2RlID0gbWF4RGVsYXlUaW1lID8gdGhpcy5pbnRlcm5hbF9jcmVhdGVEZWxheShtYXhEZWxheVRpbWUpIDogdGhpcy5pbnRlcm5hbF9jcmVhdGVEZWxheSgpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGVsYXlUaW1lKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUJ1ZmZlclNvdXJjZSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyU291cmNlO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyU291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcbiAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICggd2hlbiwgb2Zmc2V0LCBkdXJhdGlvbiApIHtcbiAgICAgICAgICBpZiAoIG9mZnNldCB8fCBkdXJhdGlvbiApXG4gICAgICAgICAgICB0aGlzLm5vdGVHcmFpbk9uKCB3aGVuIHx8IDAsIG9mZnNldCwgZHVyYXRpb24gKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm5vdGVPbiggd2hlbiB8fCAwICk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0ID0gbm9kZS5zdGFydDtcbiAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uKCB3aGVuLCBvZmZzZXQsIGR1cmF0aW9uICkge1xuICAgICAgICAgIGlmKCB0eXBlb2YgZHVyYXRpb24gIT09ICd1bmRlZmluZWQnIClcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCwgb2Zmc2V0LCBkdXJhdGlvbiApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCwgb2Zmc2V0IHx8IDAgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZS5zdG9wKSB7XG4gICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICB0aGlzLm5vdGVPZmYoIHdoZW4gfHwgMCApO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wID0gbm9kZS5zdG9wO1xuICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiggd2hlbiApIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AoIHdoZW4gfHwgMCApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUucGxheWJhY2tSYXRlKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS50aHJlc2hvbGQpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUua25lZSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5yYXRpbyk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5yZWR1Y3Rpb24pO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuYXR0YWNrKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLnJlbGVhc2UpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlQmlxdWFkRmlsdGVyID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCaXF1YWRGaWx0ZXI7XG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCaXF1YWRGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmZyZXF1ZW5jeSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5kZXR1bmUpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuUSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5nYWluKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBpZiAoQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSggJ2NyZWF0ZU9zY2lsbGF0b3InICkpIHtcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlT3NjaWxsYXRvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvcjtcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcbiAgICAgICAgICBub2RlLnN0YXJ0ID0gZnVuY3Rpb24gKCB3aGVuICkge1xuICAgICAgICAgICAgdGhpcy5ub3RlT24oIHdoZW4gfHwgMCApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdGFydCA9IG5vZGUuc3RhcnQ7XG4gICAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUuc3RvcCkge1xuICAgICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICAgIHRoaXMubm90ZU9mZiggd2hlbiB8fCAwICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AgPSBub2RlLnN0b3A7XG4gICAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24oIHdoZW4gKSB7XG4gICAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AoIHdoZW4gfHwgMCApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLnNldFBlcmlvZGljV2F2ZSlcbiAgICAgICAgICBub2RlLnNldFBlcmlvZGljV2F2ZSA9IG5vZGUuc2V0V2F2ZVRhYmxlO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5mcmVxdWVuY3kpO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5kZXR1bmUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCcpICYmXG4gICAgICAhd2luZG93Lmhhc093blByb3BlcnR5KCdPZmZsaW5lQXVkaW9Db250ZXh0JykpIHtcbiAgICB3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dCA9IHdlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gIH1cblxufSh3aW5kb3cpKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL0F1ZGlvQ29udGV4dE1vbmtleVBhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0NzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8vIEVTNiBNYXRoLnRydW5jIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90cnVuY1xyXG5pZiAoIU1hdGgudHJ1bmMpIHtcclxuICAgIE1hdGgudHJ1bmMgPSBmdW5jdGlvbiB0cnVuYyh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwID8gTWF0aC5jZWlsKHgpIDogTWF0aC5mbG9vcih4KTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4qIEEgcG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXHJcbiovXHJcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcclxuXHJcbiAgICAvKiBqc2hpbnQgZnJlZXplOiBmYWxzZSAqL1xyXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gdGhpcyA6IHRoaXNBcmcsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSAoZnVuY3Rpb24gRihwcm90bykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3RvKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEYucHJvdG90eXBlID0gcHJvdG87XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEYpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCBzdXBlcm5ldzogdHJ1ZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkodGFyZ2V0LnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYm91bmQ7XHJcbiAgICAgICAgfTtcclxuICAgIH0pKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEEgcG9seWZpbGwgZm9yIEFycmF5LmlzQXJyYXlcclxuKi9cclxuaWYgKCFBcnJheS5pc0FycmF5KVxyXG57XHJcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKGFyZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuKiBBIHBvbHlmaWxsIGZvciBBcnJheS5mb3JFYWNoXHJcbiogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaFxyXG4qL1xyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKVxyXG57XHJcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZ1biAvKiwgdGhpc0FyZyAqLylcclxuICAgIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XHJcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiB0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4qIExvdy1idWRnZXQgRmxvYXQzMkFycmF5IGtub2NrLW9mZiwgc3VpdGFibGUgZm9yIHVzZSB3aXRoIFAyLmpzIGluIElFOVxyXG4qIFNvdXJjZTogaHR0cDovL3d3dy5odG1sNWdhbWVkZXZzLmNvbS90b3BpYy81OTg4LXBoYXNlci0xMi1pZTkvXHJcbiogQ2FtZXJvbiBGb2FsZSAoaHR0cDovL3d3dy5raWJpYnUuY29tKVxyXG4qL1xyXG5pZiAodHlwZW9mIHdpbmRvdy5VaW50MzJBcnJheSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB3aW5kb3cuVWludDMyQXJyYXkgIT09IFwib2JqZWN0XCIpXHJcbntcclxuICAgIHZhciBDaGVhcEFycmF5ID0gZnVuY3Rpb24odHlwZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgcHJvdG8gPSBuZXcgQXJyYXkoKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG4gICAgICAgIHdpbmRvd1t0eXBlXSA9IGZ1bmN0aW9uKGFyZykge1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZihhcmcpID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5jYWxsKHRoaXMsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGFyZztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5jYWxsKHRoaXMsIGFyZy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gYXJnLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IGFyZ1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHdpbmRvd1t0eXBlXS5wcm90b3R5cGUgPSBwcm90bztcclxuICAgICAgICB3aW5kb3dbdHlwZV0uY29uc3RydWN0b3IgPSB3aW5kb3dbdHlwZV07XHJcbiAgICB9O1xyXG5cclxuICAgIENoZWFwQXJyYXkoJ0Zsb2F0MzJBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ1VpbnQzMkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnVWludDE2QXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdJbnQxNkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnQXJyYXlCdWZmZXInKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbHNvIGZpeCBmb3IgdGhlIGFic2VudCBjb25zb2xlIGluIElFOVxyXG4gKi9cclxuaWYgKCF3aW5kb3cuY29uc29sZSlcclxue1xyXG4gICAgd2luZG93LmNvbnNvbGUgPSB7fTtcclxuICAgIHdpbmRvdy5jb25zb2xlLmxvZyA9IHdpbmRvdy5jb25zb2xlLmFzc2VydCA9IGZ1bmN0aW9uKCl7fTtcclxuICAgIHdpbmRvdy5jb25zb2xlLndhcm4gPSB3aW5kb3cuY29uc29sZS5hc3NlcnQgPSBmdW5jdGlvbigpe307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBwZXJmb3JtYW5jZS5ub3dcclxuICovXHJcbihmdW5jdGlvbigpe1xyXG5cclxuICBpZiAoXCJwZXJmb3JtYW5jZVwiIGluIHdpbmRvdyA9PSBmYWxzZSkge1xyXG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7fTtcclxuICB9XHJcbiAgXHJcbiAgRGF0ZS5ub3cgPSAoRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkgeyAgLy8gdGhhbmtzIElFOFxyXG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChcIm5vd1wiIGluIHdpbmRvdy5wZXJmb3JtYW5jZSA9PSBmYWxzZSlcclxuICB7XHJcbiAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcclxuICAgIFxyXG4gICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KXtcclxuICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydFxyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiBub3coKXtcclxuICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL0Z1bmN0aW9uLmJpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDQ3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLy8gRVM2IE1hdGgudHJ1bmMgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jXHJcbmlmICghTWF0aC50cnVuYykge1xyXG4gICAgTWF0aC50cnVuYyA9IGZ1bmN0aW9uIHRydW5jKHgpIHtcclxuICAgICAgICByZXR1cm4geCA8IDAgPyBNYXRoLmNlaWwoeCkgOiBNYXRoLmZsb29yKHgpO1xyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvTWF0aC50cnVuYy5qc1xuLy8gbW9kdWxlIGlkID0gNDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG5cclxuLyoqXHJcbiogTG93LWJ1ZGdldCBGbG9hdDMyQXJyYXkga25vY2stb2ZmLCBzdWl0YWJsZSBmb3IgdXNlIHdpdGggUDIuanMgaW4gSUU5XHJcbiogU291cmNlOiBodHRwOi8vd3d3Lmh0bWw1Z2FtZWRldnMuY29tL3RvcGljLzU5ODgtcGhhc2VyLTEyLWllOS9cclxuKiBDYW1lcm9uIEZvYWxlIChodHRwOi8vd3d3LmtpYmlidS5jb20pXHJcbiovXHJcbmlmICh0eXBlb2Ygd2luZG93LlVpbnQzMkFycmF5ICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHdpbmRvdy5VaW50MzJBcnJheSAhPT0gXCJvYmplY3RcIilcclxue1xyXG4gICAgdmFyIENoZWFwQXJyYXkgPSBmdW5jdGlvbih0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwcm90byA9IG5ldyBBcnJheSgpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuXHJcbiAgICAgICAgd2luZG93W3R5cGVdID0gZnVuY3Rpb24oYXJnKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mKGFyZykgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LmNhbGwodGhpcywgYXJnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gYXJnO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LmNhbGwodGhpcywgYXJnLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBhcmcubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gYXJnW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgd2luZG93W3R5cGVdLnByb3RvdHlwZSA9IHByb3RvO1xyXG4gICAgICAgIHdpbmRvd1t0eXBlXS5jb25zdHJ1Y3RvciA9IHdpbmRvd1t0eXBlXTtcclxuICAgIH07XHJcblxyXG4gICAgQ2hlYXBBcnJheSgnRmxvYXQzMkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnVWludDMyQXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdVaW50MTZBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ0ludDE2QXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdBcnJheUJ1ZmZlcicpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvVWludDMyQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDQ3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEFsc28gZml4IGZvciB0aGUgYWJzZW50IGNvbnNvbGUgaW4gSUU5XHJcbiAqL1xyXG5pZiAoIXdpbmRvdy5jb25zb2xlKVxyXG57XHJcbiAgICB3aW5kb3cuY29uc29sZSA9IHt9O1xyXG4gICAgd2luZG93LmNvbnNvbGUubG9nID0gd2luZG93LmNvbnNvbGUuYXNzZXJ0ID0gZnVuY3Rpb24oKXt9O1xyXG4gICAgd2luZG93LmNvbnNvbGUud2FybiA9IHdpbmRvdy5jb25zb2xlLmFzc2VydCA9IGZ1bmN0aW9uKCl7fTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvY29uc29sZS5qc1xuLy8gbW9kdWxlIGlkID0gNDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuICogcGVyZm9ybWFuY2Uubm93XHJcbiAqL1xyXG4oZnVuY3Rpb24oKXtcclxuXHJcbiAgaWYgKFwicGVyZm9ybWFuY2VcIiBpbiB3aW5kb3cgPT0gZmFsc2UpIHtcclxuICAgICAgd2luZG93LnBlcmZvcm1hbmNlID0ge307XHJcbiAgfVxyXG4gIFxyXG4gIERhdGUubm93ID0gKERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHsgIC8vIHRoYW5rcyBJRThcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoXCJub3dcIiBpbiB3aW5kb3cucGVyZm9ybWFuY2UgPT0gZmFsc2UpXHJcbiAge1xyXG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XHJcbiAgICBcclxuICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCl7XHJcbiAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnRcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XHJcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9wZXJmb3JtYW5jZS5ub3cuanNcbi8vIG1vZHVsZSBpZCA9IDQ3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwiLy8gUmVmZXJlbmNlczpcclxuLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTU3OTY3MVxyXG4vLyBodHRwOi8vdXBkYXRlcy5odG1sNXJvY2tzLmNvbS8yMDEyLzA1L3JlcXVlc3RBbmltYXRpb25GcmFtZS1BUEktbm93LXdpdGgtc3ViLW1pbGxpc2Vjb25kLXByZWNpc2lvblxyXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90aW1oYWxsLzQwNzg2MTRcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0ZpbmFuY2lhbC1UaW1lcy9wb2x5ZmlsbC1zZXJ2aWNlL3RyZWUvbWFzdGVyL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuXHJcbi8vIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCBCcm93c2VyZml5XHJcbi8vIEJyb3dzZXJpZnkgYXV0b21hdGljYWxseSBkZXRlY3RzIHRoZSB1c2Ugb2YgYGdsb2JhbGAgYW5kIHBhc3NlcyB0aGVcclxuLy8gY29ycmVjdCByZWZlcmVuY2Ugb2YgYGdsb2JhbGAsIGBzZWxmYCwgYW5kIGZpbmFsbHkgYHdpbmRvd2BcclxuXHJcbi8vIERhdGUubm93XHJcbmlmICghKERhdGUubm93ICYmIERhdGUucHJvdG90eXBlLmdldFRpbWUpKSB7XHJcbiAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBwZXJmb3JtYW5jZS5ub3dcclxuaWYgKCEoZ2xvYmFsLnBlcmZvcm1hbmNlICYmIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cpKSB7XHJcbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIGlmICghZ2xvYmFsLnBlcmZvcm1hbmNlKSB7XHJcbiAgICAgICAgZ2xvYmFsLnBlcmZvcm1hbmNlID0ge307XHJcbiAgICB9XHJcbiAgICBnbG9iYWwucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xyXG4gICAgfTtcclxufVxyXG5cclxuLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbnZhciBsYXN0VGltZSA9IERhdGUubm93KCk7XHJcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcclxuXHJcbmZvcih2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XHJcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XHJcbiAgICAgICAgZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcbn1cclxuXHJcbmlmICghZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xyXG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICdpcyBub3QgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgZGVsYXkgPSAxNiArIGxhc3RUaW1lIC0gY3VycmVudFRpbWU7XHJcblxyXG4gICAgICAgIGlmIChkZWxheSA8IDApIHtcclxuICAgICAgICAgICAgZGVsYXkgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyZW50VGltZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsYXN0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcclxuICAgICAgICB9LCBkZWxheSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5pZiAoIWdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xyXG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA0Nzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcclxudmFyIERyYXdJbWFnZSA9IHJlcXVpcmUoJy4vdXRpbHMvRHJhd0ltYWdlJyk7XHJcbnZhciBCbGl0SW1hZ2UgPSByZXF1aXJlKCcuL3V0aWxzL0JsaXRJbWFnZScpO1xyXG52YXIgR2V0QmxlbmRNb2RlcyA9IHJlcXVpcmUoJy4vdXRpbHMvR2V0QmxlbmRNb2RlcycpO1xyXG52YXIgR2V0Q29udGV4dCA9IHJlcXVpcmUoJy4uLy4uL2NhbnZhcy9HZXRDb250ZXh0Jyk7XHJcblxyXG52YXIgQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAoZ2FtZSlcclxue1xyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgR2FtZS5cclxuICAgICovXHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG5cclxuICAgIC8vICBOZWVkZWQ/XHJcbiAgICB0aGlzLnR5cGUgPSBDT05TVC5DQU5WQVM7XHJcblxyXG4gICAgdGhpcy5kcmF3Q291bnQgPSAwO1xyXG5cclxuICAgIC8vICBSZWFkIGFsbCB0aGUgZm9sbG93aW5nIGZyb20gZ2FtZSBjb25maWcgKG9yIFN0YXRlIGNvbmZpZz8pXHJcbiAgICAvLyB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gdHJ1ZTtcclxuICAgIC8vIHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcclxuICAgIC8vIHRoaXMuYXV0b1Jlc2l6ZSA9IGZhbHNlO1xyXG4gICAgLy8gdGhpcy5zbW9vdGhQcm9wZXJ0eSA9IFBoYXNlci5DYW52YXMuZ2V0U21vb3RoaW5nUHJlZml4KHRoaXMuY29udGV4dCk7XHJcbiAgICAvLyB0aGlzLnJvdW5kUGl4ZWxzID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcblxyXG4gICAgdGhpcy5nYW1lQ2FudmFzID0gZ2FtZS5jYW52YXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FudmFzIDJkIGNvbnRleHQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHdpdGhcclxuICAgICAqIEBwcm9wZXJ0eSBjb250ZXh0XHJcbiAgICAgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgICAqL1xyXG4gICAgdGhpcy5nYW1lQ29udGV4dCA9IEdldENvbnRleHQodGhpcy5nYW1lQ2FudmFzKTtcclxuXHJcbiAgICB0aGlzLmdhbWVDb25maWcgPSBnYW1lLmNvbmZpZztcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gdGhpcy5nYW1lQ29udGV4dDtcclxuXHJcbiAgICAvLyAgTWFwIHRvIHRoZSByZXF1aXJlZCBmdW5jdGlvblxyXG4gICAgdGhpcy5kcmF3SW1hZ2UgPSBEcmF3SW1hZ2U7XHJcbiAgICB0aGlzLmJsaXRJbWFnZSA9IEJsaXRJbWFnZTtcclxuXHJcbiAgICB0aGlzLmJsZW5kTW9kZXMgPSBHZXRCbGVuZE1vZGVzKCk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50QWxwaGEgPSAxO1xyXG4gICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gMDtcclxuICAgIHRoaXMuY3VycmVudFNjYWxlTW9kZSA9IDA7XHJcblxyXG4gICAgLy8gdGhpcy50aW50TWV0aG9kID0gdGhpcy50aW50V2l0aFBlclBpeGVsO1xyXG5cclxuICAgIHRoaXMuaW5pdCgpO1xyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzUmVuZGVyZXI7XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzO1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVDYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuZ2FtZUNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZUNhbnZhcy5zdHlsZS53aWR0aCA9ICh0aGlzLndpZHRoIC8gcmVzKSArICdweCc7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZUNhbnZhcy5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgLyByZXMpICsgJ3B4JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmICh0aGlzLnNtb290aFByb3BlcnR5KVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5nYW1lQ29udGV4dFt0aGlzLnNtb290aFByb3BlcnR5XSA9ICh0aGlzLnNjYWxlTW9kZSA9PT0gU2NhbGVNb2Rlcy5MSU5FQVIpO1xyXG4gICAgICAgIC8vIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24gKGJsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmxlbmRNb2RlICE9PSBibGVuZE1vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gYmxlbmRNb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEJsZW5kTW9kZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0QWxwaGE6IGZ1bmN0aW9uIChhbHBoYSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QWxwaGEgIT09IGFscGhhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IGFscGhhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFscGhhO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbCBhdCB0aGUgc3RhcnQgb2YgdGhlIHJlbmRlciBsb29wXHJcbiAgICBwcmVSZW5kZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJyVjIHJlbmRlciBzdGFydCAnLCAnY29sb3I6ICNmZmZmZmY7IGJhY2tncm91bmQ6ICMwMGZmMDA7Jyk7XHJcblxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdhbWVDb250ZXh0O1xyXG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmdhbWVDb25maWc7XHJcblxyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmNsZWFyQmVmb3JlUmVuZGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY29uZmlnLnRyYW5zcGFyZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IucmdiYTtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEFkZCBQcmUtcmVuZGVyIGhvb2tcclxuXHJcbiAgICAgICAgdGhpcy5kcmF3Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIFN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5TdGF0ZX0gc3RhdGUgLSBUaGUgU3RhdGUgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UgLSBUaGUgY3VtdWxhdGl2ZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhc24ndCBiZWVuIHNpbXVsYXRlZCB5ZXQsIGRpdmlkZWRcclxuICAgICAqICAgYnkgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgd2lsbCBiZSBzaW11bGF0ZWQgdGhlIG5leHQgdGltZSB1cGRhdGUoKVxyXG4gICAgICogICBydW5zLiBVc2VmdWwgZm9yIGludGVycG9sYXRpbmcgZnJhbWVzLlxyXG4gICAgICovXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChzdGF0ZSwgY2hpbGRyZW4sIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHcgPSBzdGF0ZS5zeXMud2lkdGg7XHJcbiAgICAgICAgdmFyIGggPSBzdGF0ZS5zeXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5zeXMuY29udGV4dDtcclxuICAgICAgICB2YXIgc2V0dGluZ3MgPSBzdGF0ZS5zeXMuc2V0dGluZ3M7XHJcbiAgICAgICAgdmFyIHNjaXNzb3IgPSAoY2FtZXJhLnggIT09IDAgfHwgY2FtZXJhLnkgIT09IDAgfHwgY2FtZXJhLndpZHRoICE9PSBjdHguY2FudmFzLndpZHRoIHx8IGNhbWVyYS5oZWlnaHQgIT09IGN0eC5jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICB2YXIgbGlzdCA9IGNoaWxkcmVuLmxpc3Q7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBjdHg7XHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLyAgSWYgdGhlIGFscGhhIG9yIGJsZW5kIG1vZGUgZGlkbid0IGNoYW5nZSBzaW5jZSB0aGUgbGFzdCByZW5kZXIsIHRoZW4gZG9uJ3Qgc2V0IHRoZW0gYWdhaW4gKHNhdmVzIDIgb3BzKVxyXG5cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QWxwaGEgIT09IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmxlbmRNb2RlICE9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRTY2FsZU1vZGUgPSAwO1xyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MucmVuZGVyVG9UZXh0dXJlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNsZWFyQmVmb3JlUmVuZGVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRyYXdDb3VudCArPSBsaXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKHNjaXNzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZWN0KGNhbWVyYS54LCBjYW1lcmEueSwgY2FtZXJhLndpZHRoLCBjYW1lcmEuaGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LmNsaXAoKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFsyXSwgbWF0cml4WzNdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbGlzdC5sZW5ndGg7IGMrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGxpc3RbY107XHJcblxyXG4gICAgICAgICAgICBjaGlsZC5yZW5kZXJDYW52YXModGhpcywgY2hpbGQsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAgQ2FsbCB0aGUgU3RhdGUucmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgc3RhdGUucmVuZGVyLmNhbGwoc3RhdGUsIGN0eCwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcblxyXG4gICAgICAgIGlmIChjYW1lcmEuX2ZhZGVBbHBoYSA+IDAgfHwgY2FtZXJhLl9mbGFzaEFscGhhID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGZhZGUgcmVuZGVyaW5nXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKCcgKyAoY2FtZXJhLl9mYWRlUmVkICogMjU1KSArICcsJyArIChjYW1lcmEuX2ZhZGVHcmVlbiAqIDI1NSkgKyAnLCcgKyAoY2FtZXJhLl9mYWRlQmx1ZSAqIDI1NSkgKyAnKSc7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGNhbWVyYS5fZmFkZUFscGhhO1xyXG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoY2FtZXJhLngsIGNhbWVyYS55LCBjYW1lcmEud2lkdGgsIGNhbWVyYS5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gZmxhc2ggcmVuZGVyaW5nXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKCcgKyAoY2FtZXJhLl9mbGFzaFJlZCAqIDI1NSkgKyAnLCcgKyAoY2FtZXJhLl9mbGFzaEdyZWVuICogMjU1KSArICcsJyArIChjYW1lcmEuX2ZsYXNoQmx1ZSAqIDI1NSkgKyAnKSc7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGNhbWVyYS5fZmxhc2hBbHBoYTtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGNhbWVyYS54LCBjYW1lcmEueSwgY2FtZXJhLndpZHRoLCBjYW1lcmEuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBSZXNldCB0aGUgY2FtZXJhIHNjaXNzb3JcclxuICAgICAgICBpZiAoc2Npc3NvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vICBCbGFzdCBpdCB0byB0aGUgR2FtZSBDYW52YXMgKGlmIG5lZWRlZClcclxuICAgICAgICBpZiAoc2V0dGluZ3MucmVuZGVyVG9UZXh0dXJlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lQ29udGV4dC5kcmF3SW1hZ2Uoc3RhdGUuc3lzLmNhbnZhcywgMCwgMCwgdywgaCwgc2V0dGluZ3MueCwgc2V0dGluZ3MueSwgdywgaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwb3N0UmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCclYyByZW5kZXIgZW5kICcsICdjb2xvcjogI2ZmZmZmZjsgYmFja2dyb3VuZDogI2ZmMDAwMDsnKTtcclxuXHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2FtZUNvbnRleHQ7XHJcblxyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudEFscGhhID0gMTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSAwO1xyXG5cclxuICAgICAgICAvLyAgQWRkIFBvc3QtcmVuZGVyIGhvb2tcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgYW5kIG9wdGlvbmFsbHkgcmVtb3ZlcyB0aGUgQ2FudmFzIERPTSBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICogQHBhcmFtIFtyZW1vdmVnYW1lQ2FudmFzPXRydWVdIHtib29sZWFufSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIENhbnZhc1Bvb2xcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lQ2FudmFzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmdhbWVDb250ZXh0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJcclxuLy8gIE5vIHNjYWxpbmcsIGFuY2hvciwgcm90YXRpb24gb3IgZWZmZWN0cywgbGl0ZXJhbGx5IGRyYXdzIHRoZSBmcmFtZSBkaXJlY3RseSB0byB0aGUgY2FudmFzXHJcbnZhciBCbGl0SW1hZ2UgPSBmdW5jdGlvbiAoZHgsIGR5LCBmcmFtZSwgY2FtZXJhKVxyXG57XHJcbiAgICB2YXIgY3R4ID0gdGhpcy5jdXJyZW50Q29udGV4dDtcclxuICAgIHZhciBjZCA9IGZyYW1lLmNhbnZhc0RhdGE7XHJcblxyXG4gICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICBmcmFtZS5zb3VyY2UuaW1hZ2UsXHJcbiAgICAgICAgY2Quc3gsXHJcbiAgICAgICAgY2Quc3ksXHJcbiAgICAgICAgY2Quc1dpZHRoLFxyXG4gICAgICAgIGNkLnNIZWlnaHQsXHJcbiAgICAgICAgZHggLSBjYW1lcmEuc2Nyb2xsWCxcclxuICAgICAgICBkeSAtIGNhbWVyYS5zY3JvbGxZLFxyXG4gICAgICAgIGNkLmRXaWR0aCxcclxuICAgICAgICBjZC5kSGVpZ2h0XHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCbGl0SW1hZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL2NhbnZhcy91dGlscy9CbGl0SW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDQ4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIERyYXdJbWFnZSA9IGZ1bmN0aW9uIChzcmMsIGNhbWVyYSlcclxue1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY3VycmVudENvbnRleHQ7XHJcbiAgICB2YXIgZnJhbWUgPSBzcmMuZnJhbWU7XHJcbiAgICB2YXIgY2QgPSBmcmFtZS5jYW52YXNEYXRhO1xyXG5cclxuICAgIC8vICBCbGVuZCBNb2RlXHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEJsZW5kTW9kZSAhPT0gc3JjLmJsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSBzcmMuYmxlbmRNb2RlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmJsZW5kTW9kZXNbc3JjLmJsZW5kTW9kZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFscGhhXHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEFscGhhICE9PSBzcmMuYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTbW9vdGhpbmdcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50U2NhbGVNb2RlICE9PSBzcmMuc2NhbGVNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNjYWxlTW9kZSA9IHNyYy5zY2FsZU1vZGU7XHJcbiAgICAgICAgLy8gY3R4W3RoaXMuc21vb3RoUHJvcGVydHldID0gKHNvdXJjZS5zY2FsZU1vZGUgPT09IFNjYWxlTW9kZXMuTElORUFSKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZHggPSBmcmFtZS54IC0gc3JjLm9yaWdpblggLSBjYW1lcmEuc2Nyb2xsWDtcclxuICAgIHZhciBkeSA9IGZyYW1lLnkgLSBzcmMub3JpZ2luWSAtIGNhbWVyYS5zY3JvbGxZO1xyXG5cclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKHNyYy54LCBzcmMueSk7XHJcbiAgICBjdHgucm90YXRlKHNyYy5yb3RhdGlvbik7XHJcbiAgICBjdHguc2NhbGUoc3JjLnNjYWxlWCwgc3JjLnNjYWxlWSk7XHJcbiAgICBjdHguZHJhd0ltYWdlKGZyYW1lLnNvdXJjZS5pbWFnZSwgY2Quc3gsIGNkLnN5LCBjZC5zV2lkdGgsIGNkLnNIZWlnaHQsIGR4LCBkeSwgY2QuZFdpZHRoLCBjZC5kSGVpZ2h0KTtcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERyYXdJbWFnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0RyYXdJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtb2RlcyA9IHJlcXVpcmUoJy4uLy4uL0JsZW5kTW9kZXMnKTtcclxudmFyIENhbnZhc0ZlYXR1cmVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZGV2aWNlL0NhbnZhc0ZlYXR1cmVzJyk7XHJcblxyXG52YXIgR2V0QmxlbmRNb2RlcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBvdXRwdXQgPSBbXTtcclxuICAgIHZhciB1c2VOZXcgPSBDYW52YXNGZWF0dXJlcy5zdXBwb3J0TmV3QmxlbmRNb2RlcztcclxuXHJcbiAgICBvdXRwdXRbbW9kZXMuTk9STUFMXSA9ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuQUREXSA9ICdsaWdodGVyJztcclxuICAgIG91dHB1dFttb2Rlcy5NVUxUSVBMWV0gPSAodXNlTmV3KSA/ICdtdWx0aXBseScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLlNDUkVFTl0gPSAodXNlTmV3KSA/ICdzY3JlZW4nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5PVkVSTEFZXSA9ICh1c2VOZXcpID8gJ292ZXJsYXknIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5EQVJLRU5dID0gKHVzZU5ldykgPyAnZGFya2VuJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuTElHSFRFTl0gPSAodXNlTmV3KSA/ICdsaWdodGVuJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuQ09MT1JfRE9ER0VdID0gKHVzZU5ldykgPyAnY29sb3ItZG9kZ2UnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5DT0xPUl9CVVJOXSA9ICh1c2VOZXcpID8gJ2NvbG9yLWJ1cm4nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5IQVJEX0xJR0hUXSA9ICh1c2VOZXcpID8gJ2hhcmQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5TT0ZUX0xJR0hUXSA9ICh1c2VOZXcpID8gJ3NvZnQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5ESUZGRVJFTkNFXSA9ICh1c2VOZXcpID8gJ2RpZmZlcmVuY2UnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5FWENMVVNJT05dID0gKHVzZU5ldykgPyAnZXhjbHVzaW9uJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuSFVFXSA9ICh1c2VOZXcpID8gJ2h1ZScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLlNBVFVSQVRJT05dID0gKHVzZU5ldykgPyAnc2F0dXJhdGlvbicgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLkNPTE9SXSA9ICh1c2VOZXcpID8gJ2NvbG9yJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuTFVNSU5PU0lUWV0gPSAodXNlTmV3KSA/ICdsdW1pbm9zaXR5JyA6ICdzb3VyY2Utb3Zlcic7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0QmxlbmRNb2RlcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0dldEJsZW5kTW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci9jYW52YXMvdXRpbHMvR2V0QmxlbmRNb2Rlcy5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSAoQHBob3RvbnN0b3JtKVxyXG4qIEBhdXRob3IgICAgICAgRmVsaXBlIEFsZm9uc28gKEBiaXRuZW5mZXIpXHJcbiogQGNvcHlyaWdodCAgICAyMDE3IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBDcmVhdGVFbXB0eVRleHR1cmUgPSByZXF1aXJlKCcuL3V0aWxzL0NyZWF0ZUVtcHR5VGV4dHVyZScpO1xyXG52YXIgQ3JlYXRlVGV4dHVyZTJESW1hZ2UgPSByZXF1aXJlKCcuL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJESW1hZ2UnKTtcclxudmFyIEJsaXR0ZXJCYXRjaCA9IHJlcXVpcmUoJy4vYmF0Y2hlcy9ibGl0dGVyL0JsaXR0ZXJCYXRjaCcpO1xyXG52YXIgQUFRdWFkQmF0Y2ggPSByZXF1aXJlKCcuL2JhdGNoZXMvYWFxdWFkL0FBUXVhZEJhdGNoJyk7XHJcbnZhciBTcHJpdGVCYXRjaCA9IHJlcXVpcmUoJy4vYmF0Y2hlcy9zcHJpdGUvU3ByaXRlQmF0Y2gnKTtcclxudmFyIFNoYXBlQmF0Y2ggPSByZXF1aXJlKCcuL2JhdGNoZXMvc2hhcGUvU2hhcGVCYXRjaCcpO1xyXG52YXIgQmxlbmRNb2RlcyA9IHJlcXVpcmUoJy4uL0JsZW5kTW9kZXMnKTtcclxuXHJcbnZhciBXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKGdhbWUpXHJcbntcclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICB0aGlzLnR5cGUgPSBDT05TVC5XRUJHTDtcclxuICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XHJcblxyXG4gICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgIFdlYkdMQ29udGV4dE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNvbnRleHRMb3N0ID0gZmFsc2U7XHJcbiAgICB0aGlzLm1heFRleHR1cmVzID0gMTtcclxuICAgIHRoaXMubXVsdGlUZXh0dXJlID0gZmFsc2U7XHJcbiAgICB0aGlzLmJsZW5kTW9kZXMgPSBbXTtcclxuICAgIHRoaXMuZ2wgPSBudWxsO1xyXG4gICAgdGhpcy5leHRlbnNpb25zID0gbnVsbDtcclxuICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xyXG4gICAgdGhpcy5ibGl0dGVyQmF0Y2ggPSBudWxsO1xyXG4gICAgdGhpcy5hYVF1YWRCYXRjaCA9IG51bGw7XHJcbiAgICB0aGlzLnNwcml0ZUJhdGNoID0gbnVsbDtcclxuICAgIHRoaXMuc2hhcGVCYXRjaCA9IG51bGw7XHJcbiAgICB0aGlzLmJhdGNoID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudFRleHR1cmUyRCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5pbml0KCk7XHJcbn07XHJcblxyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYkdMUmVuZGVyZXI7XHJcblxyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdXZWJHTFJlbmRlcmVyLmluaXQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5nbCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCd3ZWJnbCcsIHRoaXMuY29uZmlnLldlYkdMQ29udGV4dE9wdGlvbnMpIHx8IHRoaXMudmlldy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCB0aGlzLmNvbmZpZy5XZWJHTENvbnRleHRPcHRpb25zKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmdsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0TG9zdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViR0wuIFRyeSB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdhbWUuY29uZmlnLmJhY2tncm91bmRDb2xvcjtcclxuICAgIFxyXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcihjb2xvci5yZWRHTCwgY29sb3IuZ3JlZW5HTCwgY29sb3IuYmx1ZUdMLCBjb2xvci5hbHBoYUdMKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICAvLyAgTWFwIEJsZW5kIE1vZGVzXHJcblxyXG4gICAgICAgIHZhciBhZGQgPSBbIGdsLlNSQ19BTFBIQSwgZ2wuRFNUX0FMUEhBIF07XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IFsgZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXTtcclxuICAgICAgICB2YXIgbXVsdGlwbHkgPSBbIGdsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSBdO1xyXG4gICAgICAgIHZhciBzY3JlZW4gPSBbIGdsLlNSQ19BTFBIQSwgZ2wuT05FIF07XHJcblxyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlcyA9IFtcclxuICAgICAgICAgICAgbm9ybWFsLCBhZGQsIG11bHRpcGx5LCBzY3JlZW4sIG5vcm1hbCxcclxuICAgICAgICAgICAgbm9ybWFsLCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsLFxyXG4gICAgICAgICAgICBub3JtYWwsIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwsXHJcbiAgICAgICAgICAgIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwsIG5vcm1hbFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gLTE7XHJcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpO1xyXG4gICAgICAgIHRoaXMuYmxpdHRlckJhdGNoID0gdGhpcy5hZGRCYXRjaChuZXcgQmxpdHRlckJhdGNoKHRoaXMuZ2FtZSwgZ2wsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLmFhUXVhZEJhdGNoID0gdGhpcy5hZGRCYXRjaChuZXcgQUFRdWFkQmF0Y2godGhpcy5nYW1lLCBnbCwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSB0aGlzLmFkZEJhdGNoKG5ldyBTcHJpdGVCYXRjaCh0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5zaGFwZUJhdGNoID0gdGhpcy5hZGRCYXRjaChuZXcgU2hhcGVCYXRjaCh0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVRleHR1cmUyRDogZnVuY3Rpb24gKHNvdXJjZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgICBpZiAoIXNvdXJjZS5nbFRleHR1cmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzb3VyY2UuZ2xUZXh0dXJlID0gQ3JlYXRlVGV4dHVyZTJESW1hZ2UoZ2wsIHNvdXJjZS5pbWFnZSwgZ2wuTkVBUkVTVCwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBzb3VyY2UuZ2xUZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUZXh0dXJlMkQ6IGZ1bmN0aW9uICh0ZXh0dXJlMkQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFRleHR1cmUyRCAhPT0gdGV4dHVyZTJEKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2guZmx1c2goKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlMkQpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gdGV4dHVyZTJEO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0QmF0Y2g6IGZ1bmN0aW9uIChiYXRjaCwgdGV4dHVyZTJELCBjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB0aGlzLnNldFRleHR1cmUyRCh0ZXh0dXJlMkQpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5iYXRjaCAhPT0gYmF0Y2gpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5iYXRjaClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiYXRjaC5iaW5kKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJhdGNoID0gYmF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlcztcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlcztcclxuXHJcbiAgICAgICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmF1dG9SZXNpemUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUud2lkdGggPSAodGhpcy53aWR0aCAvIHJlcykgKyAncHgnO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0IC8gcmVzKSArICdweCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkgPCBsOyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJhdGNoZXNbaV0uYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmJhdGNoZXNbaV0ucmVzaXplKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5iYXRjaCkgXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJhdGNoLmJpbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYWxsIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVuZGVyIGxvb3BcclxuICAgIHByZVJlbmRlcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgTm8gcG9pbnQgcmVuZGVyaW5nIGlmIG91ciBjb250ZXh0IGhhcyBiZWVuIGJsb3duIHVwIVxyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRMb3N0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEFkZCBQcmUtcmVuZGVyIGhvb2tcclxuXHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdhbWUuY29uZmlnLmJhY2tncm91bmRDb2xvcjtcclxuXHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcihjb2xvci5yZWRHTCwgY29sb3IuZ3JlZW5HTCwgY29sb3IuYmx1ZUdMLCBjb2xvci5hbHBoYUdMKTtcclxuICAgICAgICAvLyBTb21lIGRyaXZlcnMgcmVxdWlyZSB0byBjYWxsIGdsQ2xlYXJcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKEJsZW5kTW9kZXMuTk9STUFMKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgc2luZ2xlIFN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5TdGF0ZX0gc3RhdGUgLSBUaGUgU3RhdGUgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UgLSBUaGUgY3VtdWxhdGl2ZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhc24ndCBiZWVuIHNpbXVsYXRlZCB5ZXQsIGRpdmlkZWRcclxuICAgICAqICAgYnkgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgd2lsbCBiZSBzaW11bGF0ZWQgdGhlIG5leHQgdGltZSB1cGRhdGUoKVxyXG4gICAgICogICBydW5zLiBVc2VmdWwgZm9yIGludGVycG9sYXRpbmcgZnJhbWVzLlxyXG4gICAgICovXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChzdGF0ZSwgY2hpbGRyZW4sIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIENvdWxkIG1vdmUgdG8gdGhlIFN0YXRlIFN5c3RlbXMgb3IgTWFpbkxvb3BcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBzY2lzc29yID0gKGNhbWVyYS54ICE9PSAwIHx8IGNhbWVyYS55ICE9PSAwIHx8IGNhbWVyYS53aWR0aCAhPT0gZ2wuY2FudmFzLndpZHRoIHx8IGNhbWVyYS5oZWlnaHQgIT09IGdsLmNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICBpZiAoc2Npc3NvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xyXG4gICAgICAgICAgICBnbC5zY2lzc29yKGNhbWVyYS54LCAoZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAtIGNhbWVyYS55IC0gY2FtZXJhLmhlaWdodCksIGNhbWVyYS53aWR0aCwgY2FtZXJhLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGNvdWxkIGVpdGhlciBjbGVhciBjb2xvciBvciByZW5kZXIgYSBxdWFkXHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcblxyXG4gICAgICAgIHZhciBsaXN0ID0gY2hpbGRyZW4ubGlzdDtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgKytpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGxpc3RbaW5kZXhdO1xyXG4gICAgICAgICAgICAvLyBTZXR0aW5nIGJsZW5kIG1vZGUgaWYgbmVlZGVkICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2g7XHJcbiAgICAgICAgICAgIHZhciBuZXdCbGVuZE1vZGUgPSBjaGlsZC5ibGVuZE1vZGU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJsZW5kTW9kZSAhPT0gbmV3QmxlbmRNb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmF0Y2gpIFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxlbmQgPSB0aGlzLmJsZW5kTW9kZXNbbmV3QmxlbmRNb2RlXTtcclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxlbmQubGVuZ3RoID4gMilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShibGVuZFswXSwgYmxlbmRbMV0sIGJsZW5kWzJdLCBibGVuZFszXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGJsZW5kWzBdLCBibGVuZFsxXSk7ICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYmxlbmRNb2RlID0gbmV3QmxlbmRNb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGRyYXdpbmcgY2hpbGRcclxuICAgICAgICAgICAgY2hpbGQucmVuZGVyV2ViR0wodGhpcywgY2hpbGQsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpO1xyXG4gICAgICAgICAgICBiYXRjaCA9IHRoaXMuYmF0Y2g7XHJcbiAgICAgICAgICAgIGlmIChiYXRjaCAmJiBiYXRjaC5pc0Z1bGwoKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guZmx1c2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5iYXRjaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2guZmx1c2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhbWVyYS5fZmFkZUFscGhhID4gMCB8fCBjYW1lcmEuX2ZsYXNoQWxwaGEgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGFhUXVhZEJhdGNoID0gdGhpcy5hYVF1YWRCYXRjaDtcclxuICAgICAgICAgICAgYWFRdWFkQmF0Y2guYmluZCgpO1xyXG4gICAgICAgICAgICAvLyBmYWRlIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICBhYVF1YWRCYXRjaC5hZGQoXHJcbiAgICAgICAgICAgICAgICBjYW1lcmEueCwgY2FtZXJhLnksIGNhbWVyYS53aWR0aCwgY2FtZXJhLmhlaWdodCwgXHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuX2ZhZGVSZWQsIFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mYWRlR3JlZW4sIFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mYWRlQmx1ZSwgXHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuX2ZhZGVBbHBoYVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAvLyBmbGFzaCByZW5kZXJpbmdcclxuICAgICAgICAgICAgYWFRdWFkQmF0Y2guYWRkKFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLngsIGNhbWVyYS55LCBjYW1lcmEud2lkdGgsIGNhbWVyYS5oZWlnaHQsIFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaFJlZCwgXHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuX2ZsYXNoR3JlZW4sIFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaEJsdWUsIFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaEFscGhhXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGFhUXVhZEJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2guYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2Npc3NvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYWxsZWQgYXQgdGhlIGVuZCBvZiB0aGUgcmVuZGVyIGxvb3AgKHRpZHkgdGhpbmdzIHVwLCBldGMpXHJcbiAgICBwb3N0UmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmJhdGNoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5iYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAgQWRkIFBvc3QtcmVuZGVyIGhvb2tcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJyVjIHJlbmRlciBlbmQgJywgJ2NvbG9yOiAjZmZmZmZmOyBiYWNrZ3JvdW5kOiAjZmYwMDAwOycpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVGQk86IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24gKG5ld0JsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2g7XHJcbiAgICAgICAgdmFyIGJsZW5kID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYmxlbmRNb2RlICE9PSBuZXdCbGVuZE1vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoYmF0Y2gpXHJcbiAgICAgICAgICAgICAgICBiYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgICAgICBibGVuZCA9IHRoaXMuYmxlbmRNb2Rlc1tuZXdCbGVuZE1vZGVdO1xyXG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgICAgICBpZiAoYmxlbmQubGVuZ3RoID4gMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoYmxlbmRbMF0sIGJsZW5kWzFdLCBibGVuZFsyXSwgYmxlbmRbM10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGJsZW5kWzBdLCBibGVuZFsxXSk7ICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IG5ld0JsZW5kTW9kZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEJhdGNoOiBmdW5jdGlvbiAoYmF0Y2hJbnN0YW5jZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmJhdGNoZXMuaW5kZXhPZihiYXRjaEluc3RhbmNlKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSBcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlcy5wdXNoKGJhdGNoSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmF0Y2hJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyLmpzIiwidmFyIEJpbmRWZXJ0ZXhBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3Zhby9CaW5kVmVydGV4QXJyYXknKTtcclxudmFyIENyZWF0ZVByb2dyYW0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9zaGFkZXIvQ3JlYXRlUHJvZ3JhbScpO1xyXG52YXIgQ3JlYXRlU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlcicpO1xyXG52YXIgQ3JlYXRlQnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL0NyZWF0ZUJ1ZmZlcicpO1xyXG52YXIgQ3JlYXRlQXR0cmliRGVzYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3Zhby9DcmVhdGVBdHRyaWJEZXNjJyk7XHJcbnZhciBCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9CdWZmZXIzMicpO1xyXG52YXIgQnVmZmVyMTYgPSByZXF1aXJlKCcuLi8uLi91dGlscy9idWZmZXIvQnVmZmVyMTYnKTtcclxudmFyIFZlcnRleEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL1ZlcnRleEFycmF5Jyk7XHJcblxyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIEFBUXVhZEJhdGNoID0gZnVuY3Rpb24gKGdhbWUsIGdsLCBtYW5hZ2VyKVxyXG57XHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgdGhpcy50eXBlID0gUEhBU0VSX0NPTlNULldFQkdMO1xyXG4gICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICB0aGlzLm1heFF1YWRzID0gbnVsbDtcclxuICAgIHRoaXMudmVydFNoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLmZyYWdTaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuICAgIHRoaXMudmVydGV4QXJyYXkgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSBudWxsO1xyXG5cclxuICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcclxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xyXG59O1xyXG5cclxuQUFRdWFkQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQUFRdWFkQmF0Y2g7XHJcblxyXG5BQVF1YWRCYXRjaC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGdsKVxyXG4gICAge1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBCdWZmZXIzMihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULkFBUVVBRF9WRVJURVhfQ09VTlQgKiBDT05TVC5NQVhfQUFRVUFEKTtcclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IEJ1ZmZlcjE2KENPTlNULklOREVYX1NJWkUgKiBDT05TVC5BQVFVQURfSU5ERVhfQ09VTlQgKiBDT05TVC5NQVhfQUFRVUFEKTtcclxuICAgICAgICB2YXIgdmVydFNoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgQ09OU1QuVkVSVEVYX1NIQURFUl9TT1VSQ0UsIGdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgIHZhciBmcmFnU2hhZGVyID0gQ3JlYXRlU2hhZGVyKGdsLCBDT05TVC5GUkFHTUVOVF9TSEFERVJfU09VUkNFLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgIHZhciBwcm9ncmFtID0gQ3JlYXRlUHJvZ3JhbShnbCwgdmVydFNoYWRlciwgZnJhZ1NoYWRlcik7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0ID0gQ3JlYXRlQnVmZmVyKGdsLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG51bGwsIGluZGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICAgICAgdmFyIGF0dHJpYkFycmF5ID0gW1xyXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV9wb3NpdGlvbicsIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDApLFxyXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV9jb2xvcicsIDQsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgdmVydGV4QXJyYXkgPSBuZXcgVmVydGV4QXJyYXkoQ3JlYXRlQnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGdsLlNUUkVBTV9EUkFXLCBudWxsLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKSwgYXR0cmliQXJyYXkpO1xyXG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfdmlld19tYXRyaXgnKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBpbmRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9BQVFVQUQgKiBDT05TVC5BQVFVQURfSU5ERVhfQ09VTlQ7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBpbmRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy52ZXJ0U2hhZGVyID0gdmVydFNoYWRlcjtcclxuICAgICAgICB0aGlzLmZyYWdTaGFkZXIgPSBmcmFnU2hhZGVyO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmVydGV4QXJyYXkgPSB2ZXJ0ZXhBcnJheTtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuXHJcbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGluZGV4IGJ1ZmZlciBvbmx5IG9uY2VcclxuICAgICAgICBmb3IgKHZhciBpbmRleEEgPSAwLCBpbmRleEIgPSAwOyBpbmRleEEgPCBtYXg7IGluZGV4QSArPSBDT05TVC5BQVFVQURfSU5ERVhfQ09VTlQsIGluZGV4QiArPSBDT05TVC5BQVFVQURfVkVSVEVYX0NPVU5UKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMF0gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAxXSA9IGluZGV4QiArIDE7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDJdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgM10gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA0XSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDVdID0gaW5kZXhCICsgMztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4QnVmZmVyT2JqZWN0KTtcclxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCAwLCBpbmRleEJ1ZmZlcik7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24pO1xyXG4gICAgICAgIHRoaXMudW5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlTGVuZ3RoKCkgPj0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBjaGVjayBpZiB0aGUgYnVmZmVycyBhcmUgZnVsbCBiZWZvcmUgZmx1c2hpbmdcclxuICAgICAgICAvLyB0aGlzIGlzIHRvIGdpdmUgZnJlZWRvbSBvZiB3aGVuIHNob3VsZCB0aGUgcmVuZGVyZXIgZmx1c2guIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciBmbG9hdEJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKENPTlNULkFBUVVBRF9WRVJURVhfQ09NUE9ORU5UX0NPVU5UICogQ09OU1QuQUFRVUFEX1ZFUlRFWF9DT1VOVCk7XHJcblxyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHg7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geTtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSByZWQ7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gZ3JlZW47XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYmx1ZTtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geDtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHJlZDtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBncmVlbjtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBibHVlO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSByZWQ7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gZ3JlZW47XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYmx1ZTtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geCArIHdpZHRoO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHk7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gcmVkO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGdyZWVuO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGJsdWU7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IENPTlNULkFBUVVBRF9JTkRFWF9DT1VOVDtcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xyXG4gICAgICAgIEJpbmRWZXJ0ZXhBcnJheShnbCwgdGhpcy52ZXJ0ZXhBcnJheSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVuYmluZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShudWxsKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmVydGV4RGF0YUJ1ZmZlci5nZXRVc2VkQnVmZmVyQXNGbG9hdCgpKTtcclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmVsZW1lbnRDb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoXHJcbiAgICAgICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy5oZWlnaHQsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG5cclxuICAgICAgICBpZiAoZ2wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0U2hhZGVyKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ1NoYWRlcik7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhBcnJheS5idWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQUFRdWFkQmF0Y2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL0FBUXVhZEJhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0ODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9hYXF1YWQvQUFRdWFkQmF0Y2guanMiLCJtb2R1bGUuZXhwb3J0cyA9IFtcclxuICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxyXG4gICAgJ3ZhcnlpbmcgdmVjNCB2X2NvbG9yOycsXHJcbiAgICAndm9pZCBtYWluKCkgeycsXHJcbiAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjsnLFxyXG4gICAgJ30nXHJcbl0uam9pbignXFxuJyk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL0ZyYWdtZW50U2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0ODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgICAndW5pZm9ybSBtYXQ0IHVfdmlld19tYXRyaXg7JyxcclxuICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAnYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsnLFxyXG4gICAgJ3ZhcnlpbmcgdmVjNCB2X2NvbG9yOycsXHJcbiAgICAndm9pZCBtYWluICgpIHsnLFxyXG4gICAgJyAgIGdsX1Bvc2l0aW9uID0gdV92aWV3X21hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wLCAxLjApOycsXHJcbiAgICAnICAgdl9jb2xvciA9IGFfY29sb3I7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL1ZlcnRleFNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGcmFnbWVudFNoYWRlciA9IHJlcXVpcmUoJy4vRnJhZ21lbnRTaGFkZXInKTtcclxudmFyIFZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4vVmVydGV4U2hhZGVyJyk7XHJcblxyXG52YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgLy8gVkVSVEVYX1NJWkUgPSBzaXplb2YodmVjMikgKyBzaXplb2YodmVjNClcclxuICAgIFZFUlRFWF9TSVpFOiAyNCxcclxuICAgIElOREVYX1NJWkU6IDIsXHJcbiAgICBBQVFVQURfVkVSVEVYX0NPVU5UOiA0LFxyXG4gICAgQUFRVUFEX0lOREVYX0NPVU5UOiA2LFxyXG5cclxuICAgIC8vIEhvdyBtYW55IDMyLWJpdCBjb21wb25lbnRzIGRvZXMgdGhlIHZlcnRleCBoYXZlLlxyXG4gICAgQUFRVUFEX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDYsXHJcbiAgICBNQVhfQUFRVUFEOiAyMDAwLFxyXG5cclxuICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWZXJ0ZXhTaGFkZXIsXHJcbiAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGcmFnbWVudFNoYWRlclxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0ODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9hYXF1YWQvY29uc3QuanMiLCIvLyAgQ291bGQgeW91IG1vdmUgdGhlc2UgaW50byBzdWItZm9sZGVycyBwbGVhc2UsIGkuZS4gJ3ZhbycsICdzaGFkZXInIGV0Yz9cclxuXHJcbnZhciBCaW5kVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQmluZFZlcnRleEFycmF5Jyk7XHJcbnZhciBDcmVhdGVQcm9ncmFtID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc2hhZGVyL0NyZWF0ZVByb2dyYW0nKTtcclxudmFyIENyZWF0ZVNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3NoYWRlci9DcmVhdGVTaGFkZXInKTtcclxudmFyIENyZWF0ZUJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9DcmVhdGVCdWZmZXInKTtcclxudmFyIENyZWF0ZUF0dHJpYkRlc2MgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYycpO1xyXG52YXIgQnVmZmVyMzIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9idWZmZXIvQnVmZmVyMzInKTtcclxudmFyIEJ1ZmZlcjE2ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL0J1ZmZlcjE2Jyk7XHJcbnZhciBWZXJ0ZXhBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3Zhby9WZXJ0ZXhBcnJheScpO1xyXG5cclxudmFyIFBIQVNFUl9DT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBCbGl0dGVyQmF0Y2ggPSBmdW5jdGlvbiAoZ2FtZSwgZ2wsIG1hbmFnZXIpXHJcbntcclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICB0aGlzLnR5cGUgPSBQSEFTRVJfQ09OU1QuV0VCR0w7XHJcbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5nbENvbnRleHQgPSBnbDtcclxuICAgIHRoaXMubWF4UGFydGljbGVzID0gbnVsbDtcclxuICAgIHRoaXMudmVydFNoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLmZyYWdTaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuICAgIHRoaXMudmVydGV4QXJyYXkgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gbnVsbDtcclxuICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcclxuXHJcbiAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXHJcbiAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogdHJ1ZSxcclxuICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXHJcbiAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcclxuXHJcbiAgICAgICAgV2ViR0xDb250ZXh0T3B0aW9uczoge1xyXG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXHJcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XHJcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5pbml0KHRoaXMuZ2xDb250ZXh0KTtcclxufTtcclxuXHJcbkJsaXR0ZXJCYXRjaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbGl0dGVyQmF0Y2g7XHJcblxyXG5CbGl0dGVyQmF0Y2gucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChnbClcclxuICAgIHtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBuZXcgQnVmZmVyMzIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5QQVJUSUNMRV9WRVJURVhfQ09VTlQgKiBDT05TVC5NQVhfUEFSVElDTEVTKTtcclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IEJ1ZmZlcjE2KENPTlNULklOREVYX1NJWkUgKiBDT05TVC5QQVJUSUNMRV9JTkRFWF9DT1VOVCAqIENPTlNULk1BWF9QQVJUSUNMRVMpO1xyXG4gICAgICAgIHZhciB2ZXJ0U2hhZGVyID0gQ3JlYXRlU2hhZGVyKGdsLCBDT05TVC5WRVJURVhfU0hBREVSX1NPVVJDRSwgZ2wuVkVSVEVYX1NIQURFUik7XHJcbiAgICAgICAgdmFyIGZyYWdTaGFkZXIgPSBDcmVhdGVTaGFkZXIoZ2wsIENPTlNULkZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsIGdsLkZSQUdNRU5UX1NIQURFUik7XHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBDcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0U2hhZGVyLCBmcmFnU2hhZGVyKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXJPYmplY3QgPSBDcmVhdGVCdWZmZXIoZ2wsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnbC5TVEFUSUNfRFJBVywgbnVsbCwgaW5kZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcclxuICAgICAgICB2YXIgYXR0cmliQXJyYXkgPSBbXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3Bvc2l0aW9uJywgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCksXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3RleF9jb29yZCcsIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpLFxyXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV9hbHBoYScsIDEsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDE2KVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIHZlcnRleEFycmF5ID0gbmV3IFZlcnRleEFycmF5KENyZWF0ZUJ1ZmZlcihnbCwgZ2wuQVJSQVlfQlVGRkVSLCBnbC5TVFJFQU1fRFJBVywgbnVsbCwgdmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSksIGF0dHJpYkFycmF5KTtcclxuICAgICAgICB2YXIgdmlld01hdHJpeExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3ZpZXdfbWF0cml4Jyk7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciBtYXggPSBDT05TVC5NQVhfUEFSVElDTEVTICogQ09OU1QuUEFSVElDTEVfSU5ERVhfQ09VTlQ7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBpbmRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy52ZXJ0U2hhZGVyID0gdmVydFNoYWRlcjtcclxuICAgICAgICB0aGlzLmZyYWdTaGFkZXIgPSBmcmFnU2hhZGVyO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmVydGV4QXJyYXkgPSB2ZXJ0ZXhBcnJheTtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuICAgICAgICB0aGlzLm1heFBhcnRpY2xlcyA9IG1heDtcclxuXHJcbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGluZGV4IGJ1ZmZlciBvbmx5IG9uY2VcclxuICAgICAgICBmb3IgKHZhciBpbmRleEEgPSAwLCBpbmRleEIgPSAwOyBpbmRleEEgPCBtYXg7IGluZGV4QSArPSBDT05TVC5QQVJUSUNMRV9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULlBBUlRJQ0xFX1ZFUlRFWF9DT1VOVClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDBdID0gaW5kZXhCICsgMDtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMV0gPSBpbmRleEIgKyAxO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAyXSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDNdID0gaW5kZXhCICsgMDtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNF0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA1XSA9IGluZGV4QiArIDM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleEJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgMCwgaW5kZXhCdWZmZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmJpbmQoKTtcclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uKTtcclxuICAgICAgICB0aGlzLnVuYmluZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xyXG4gICAgICAgIEJpbmRWZXJ0ZXhBcnJheShnbCwgdGhpcy52ZXJ0ZXhBcnJheSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVuYmluZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShudWxsKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmVydGV4RGF0YUJ1ZmZlci5nZXRVc2VkQnVmZmVyQXNGbG9hdCgpKTtcclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmVsZW1lbnRDb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoXHJcbiAgICAgICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy5oZWlnaHQsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG5cclxuICAgICAgICBpZiAoZ2wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0U2hhZGVyKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ1NoYWRlcik7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhBcnJheS5idWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxpdHRlckJhdGNoO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvQmxpdHRlckJhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0ODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL0JsaXR0ZXJCYXRjaC5qcyIsIm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXHJcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9zYW1wbGVyMkQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICd2YXJ5aW5nIGZsb2F0IHZfYWxwaGE7JyxcclxuICAgICd2b2lkIG1haW4oKSB7JyxcclxuICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9zYW1wbGVyMkQsIHZfdGV4X2Nvb3JkKSAqIHZlYzQoMS4wLCAxLjAsIDEuMCwgdl9hbHBoYSk7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvRnJhZ21lbnRTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFtcclxuICAgICd1bmlmb3JtIG1hdDQgdV92aWV3X21hdHJpeDsnLFxyXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcclxuICAgICdhdHRyaWJ1dGUgdmVjMiBhX3RleF9jb29yZDsnLFxyXG4gICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2FscGhhOycsXHJcbiAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXHJcbiAgICAndmFyeWluZyBmbG9hdCB2X2FscGhhOycsXHJcbiAgICAndm9pZCBtYWluICgpIHsnLFxyXG4gICAgJyAgIGdsX1Bvc2l0aW9uID0gdV92aWV3X21hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wLCAxLjApOycsXHJcbiAgICAnICAgdl90ZXhfY29vcmQgPSBhX3RleF9jb29yZDsnLFxyXG4gICAgJ1x0dl9hbHBoYSA9IGFfYWxwaGE7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvVmVydGV4U2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZyYWdtZW50U2hhZGVyID0gcmVxdWlyZSgnLi9GcmFnbWVudFNoYWRlcicpO1xyXG52YXIgVmVydGV4U2hhZGVyID0gcmVxdWlyZSgnLi9WZXJ0ZXhTaGFkZXInKTtcclxuXHJcbnZhciBDT05TVCA9IHtcclxuXHJcbiAgICAvLyBWRVJURVhfU0laRSA9IHNpemVvZih2ZWMyKSArIHNpemVvZih2ZWMyKSArIHNpemVvZihmbG9hdClcclxuICAgIFZFUlRFWF9TSVpFOiAyMCxcclxuICAgIElOREVYX1NJWkU6IDIsXHJcbiAgICBQQVJUSUNMRV9WRVJURVhfQ09VTlQ6IDQsXHJcbiAgICBQQVJUSUNMRV9JTkRFWF9DT1VOVDogNixcclxuXHJcbiAgICAvLyBIb3cgbWFueSAzMi1iaXQgY29tcG9uZW50cyBkb2VzIHRoZSB2ZXJ0ZXggaGF2ZS5cclxuICAgIFBBUlRJQ0xFX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDUsXHJcblxyXG4gICAgLy8gQ2FuJ3QgYmUgYmlnZ2VyIHRoYW4gMTAsMDAwIHNpbmNlIGluZGV4IGFyZSAxNi1iaXRcclxuICAgIE1BWF9QQVJUSUNMRVM6IDIwMDAsXHJcblxyXG4gICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZlcnRleFNoYWRlcixcclxuICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZyYWdtZW50U2hhZGVyXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDT05TVDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0OTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL2NvbnN0LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzQgdl9jb2xvcjsnLFxyXG4gICAgJ3ZhcnlpbmcgZmxvYXQgdl9hbHBoYTsnLFxyXG4gICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodl9jb2xvci5iZ3IsIHZfYWxwaGEpOycsXHJcbiAgICAnfSdcclxuXS5qb2luKCdcXG4nKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9GcmFnbWVudFNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCaW5kVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQmluZFZlcnRleEFycmF5Jyk7XHJcbnZhciBDcmVhdGVQcm9ncmFtID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc2hhZGVyL0NyZWF0ZVByb2dyYW0nKTtcclxudmFyIENyZWF0ZVNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3NoYWRlci9DcmVhdGVTaGFkZXInKTtcclxudmFyIENyZWF0ZUJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9DcmVhdGVCdWZmZXInKTtcclxudmFyIENyZWF0ZUF0dHJpYkRlc2MgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYycpO1xyXG52YXIgQnVmZmVyMzIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9idWZmZXIvQnVmZmVyMzInKTtcclxudmFyIFZlcnRleEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL1ZlcnRleEFycmF5Jyk7XHJcbnZhciBFYXJjdXQgPSByZXF1aXJlKCcuL2VhcmN1dCcpO1xyXG5cclxudmFyIFBIQVNFUl9DT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBTaGFwZUJhdGNoID0gZnVuY3Rpb24gKGdhbWUsIGdsLCBtYW5hZ2VyKVxyXG57XHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgdGhpcy50eXBlID0gUEhBU0VSX0NPTlNULldFQkdMO1xyXG4gICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICB0aGlzLm1heFZlcnRpY2VzID0gbnVsbDtcclxuICAgIHRoaXMudmVydFNoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLmZyYWdTaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuICAgIHRoaXMudmVydGV4QXJyYXkgPSBudWxsO1xyXG4gICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gbnVsbDtcclxuICAgIHRoaXMudmVydGV4Q291bnQgPSAwO1xyXG4gICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSBudWxsO1xyXG4gICAgdGhpcy50ZW1wVHJpYW5nbGUgPSBbXHJcbiAgICAgICAge3g6IDAsIHk6IDB9LFxyXG4gICAgICAgIHt4OiAwLCB5OiAwfSxcclxuICAgICAgICB7eDogMCwgeTogMH0sXHJcbiAgICAgICAge3g6IDAsIHk6IDB9XHJcbiAgICBdO1xyXG5cclxuICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcclxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xyXG5cclxufTtcclxuXHJcblNoYXBlQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGVCYXRjaDtcclxuXHJcblNoYXBlQmF0Y2gucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChnbClcclxuICAgIHtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBCdWZmZXIzMihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULk1BWF9WRVJUSUNFUyk7XHJcbiAgICAgICAgdmFyIHZlcnRTaGFkZXIgPSBDcmVhdGVTaGFkZXIoZ2wsIENPTlNULlZFUlRFWF9TSEFERVJfU09VUkNFLCBnbC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgICB2YXIgZnJhZ1NoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgQ09OU1QuRlJBR01FTlRfU0hBREVSX1NPVVJDRSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IENyZWF0ZVByb2dyYW0oZ2wsIHZlcnRTaGFkZXIsIGZyYWdTaGFkZXIpO1xyXG4gICAgICAgIHZhciBhdHRyaWJBcnJheSA9IFtcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfcG9zaXRpb24nLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAwKSxcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfY29sb3InLCA0LCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCBDT05TVC5WRVJURVhfU0laRSwgOCksXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX2FscGhhJywgMSwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMTIpXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgdmVydGV4QXJyYXkgPSBuZXcgVmVydGV4QXJyYXkoQ3JlYXRlQnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGdsLlNUUkVBTV9EUkFXLCBudWxsLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKSwgYXR0cmliQXJyYXkpO1xyXG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfdmlld19tYXRyaXgnKTtcclxuICAgICAgICB2YXIgbWF4ID0gQ09OU1QuTUFYX1ZFUlRJQ0VTO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHRoaXMudmVydFNoYWRlciA9IHZlcnRTaGFkZXI7XHJcbiAgICAgICAgdGhpcy5mcmFnU2hhZGVyID0gZnJhZ1NoYWRlcjtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICAgIHRoaXMudmVydGV4QXJyYXkgPSB2ZXJ0ZXhBcnJheTtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuICAgICAgICB0aGlzLm1heFZlcnRpY2VzID0gbWF4O1xyXG4gICAgICAgIHRoaXMucG9seWdvbkNhY2hlID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24pO1xyXG4gICAgICAgIHRoaXMudW5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlTGVuZ3RoKCkgPj0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgQmluZFZlcnRleEFycmF5KGdsLCB0aGlzLnZlcnRleEFycmF5KTtcclxuICAgIH0sXHJcblxyXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG5cclxuICAgICAgICBnbC51c2VQcm9ncmFtKG51bGwpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmx1c2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldFVzZWRCdWZmZXJBc0Zsb2F0KCkpO1xyXG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgdGhpcy52ZXJ0ZXhDb3VudCk7XHJcbiAgICAgICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoXHJcbiAgICAgICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy5oZWlnaHQsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG5cclxuICAgICAgICBpZiAoZ2wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0U2hhZGVyKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ1NoYWRlcik7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QXJyYXkuYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZExpbmU6IGZ1bmN0aW9uIChcclxuICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzICovXHJcbiAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgIC8qIGxpbmUgcHJvcGVydGllcyAqL1xyXG4gICAgICAgIGF4LCBheSwgYngsIGJ5LCBsaW5lV2lkdGgsIGxpbmVDb2xvciwgbGluZUFscGhhLFxyXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xyXG4gICAgICAgIGEsIGIsIGMsIGQsIGUsIGZcclxuICAgICkge1xyXG4gICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ICsgNiA+IHRoaXMubWF4VmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ICs9IDY7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgZHggPSBieCAtIGF4O1xyXG4gICAgICAgIHZhciBkeSA9IGJ5IC0gYXk7XHJcbiAgICAgICAgdmFyIGxlbiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICAgICAgdmFyIGwwID0gbGluZVdpZHRoICogKGJ5IC0gYXkpIC8gbGVuO1xyXG4gICAgICAgIHZhciBsMSA9IGxpbmVXaWR0aCAqIChheCAtIGJ4KSAvIGxlbjtcclxuICAgICAgICB2YXIgbHgwID0gYnggLSBsMDtcclxuICAgICAgICB2YXIgbHkwID0gYnkgLSBsMTtcclxuICAgICAgICB2YXIgbHgxID0gYXggLSBsMDtcclxuICAgICAgICB2YXIgbHkxID0gYXkgLSBsMTtcclxuICAgICAgICB2YXIgbHgyID0gYnggKyBsMDtcclxuICAgICAgICB2YXIgbHkyID0gYnkgKyBsMTtcclxuICAgICAgICB2YXIgbHgzID0gYXggKyBsMDtcclxuICAgICAgICB2YXIgbHkzID0gYXkgKyBsMTtcclxuICAgICAgICB2YXIgeDAgPSBseDAgKiBhICsgbHkwICogYyArIGU7XHJcbiAgICAgICAgdmFyIHkwID0gbHgwICogYiArIGx5MCAqIGQgKyBmO1xyXG4gICAgICAgIHZhciB4MSA9IGx4MSAqIGEgKyBseTEgKiBjICsgZTtcclxuICAgICAgICB2YXIgeTEgPSBseDEgKiBiICsgbHkxICogZCArIGY7XHJcbiAgICAgICAgdmFyIHgyID0gbHgyICogYSArIGx5MiAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB5MiA9IGx4MiAqIGIgKyBseTIgKiBkICsgZjtcclxuICAgICAgICB2YXIgeDMgPSBseDMgKiBhICsgbHkzICogYyArIGU7XHJcbiAgICAgICAgdmFyIHkzID0gbHgzICogYiArIGx5MyAqIGQgKyBmO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUNvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQ29sb3I7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUNvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQ29sb3I7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgeDAsIHkwLFxyXG4gICAgICAgICAgICB4MSwgeTEsXHJcbiAgICAgICAgICAgIHgyLCB5MixcclxuICAgICAgICAgICAgeDMsIHkzXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFN0cm9rZVBhdGg6IGZ1bmN0aW9uIChcclxuICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzICovXHJcbiAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgIC8qIFBhdGggcHJvcGVydGllcyAqL1xyXG4gICAgICAgIHBhdGgsIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEsXHJcbiAgICAgICAgLyogdHJhbnNmb3JtICovXHJcbiAgICAgICAgYSwgYiwgYywgZCwgZSwgZixcclxuICAgICAgICAvKiBpcyBsYXN0IGNvbm5lY3Rpb24gKi9cclxuICAgICAgICBpc0xhc3RQYXRoXHJcbiAgICApIHtcclxuICAgICAgICB2YXIgcG9pbnQwLCBwb2ludDE7XHJcbiAgICAgICAgdmFyIHBhdGhMZW5ndGggPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICB2YXIgcG9seWxpbmVzID0gdGhpcy5wb2x5Z29uQ2FjaGU7XHJcbiAgICAgICAgdmFyIGhhbGZMaW5lV2lkdGggPSBsaW5lV2lkdGggKiAwLjU7XHJcbiAgICAgICAgdmFyIGxhc3QsIGN1cnI7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlckYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQ7XHJcbiAgICAgICAgdmFyIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTI7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHBhdGhJbmRleCA9IDA7IHBhdGhJbmRleCArIDEgPCBwYXRoTGVuZ3RoOyBwYXRoSW5kZXggKz0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBvaW50MCA9IHBhdGhbcGF0aEluZGV4XTtcclxuICAgICAgICAgICAgcG9pbnQxID0gcGF0aFtwYXRoSW5kZXggKyAxXTtcclxuICAgICAgICAgICAgcG9seWxpbmVzLnB1c2godGhpcy5hZGRMaW5lKFxyXG4gICAgICAgICAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgcG9pbnQwLngsIHBvaW50MC55LCBwb2ludDEueCwgcG9pbnQxLnksIGhhbGZMaW5lV2lkdGgsIGxpbmVDb2xvciwgbGluZUFscGhhLFxyXG4gICAgICAgICAgICAgICAgYSwgYiwgYywgZCwgZSwgZlxyXG4gICAgICAgICAgICApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChsaW5lV2lkdGggPCAxLjApXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKGlzTGFzdFBhdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIHBvbHlsaW5lc0xlbmd0aCA9IHBvbHlsaW5lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA8IHBvbHlsaW5lc0xlbmd0aDsgKytpbmRleClcclxuICAgICAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ICsgNiA+IHRoaXMubWF4VmVydGljZXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxhc3QgPSBwb2x5bGluZXNbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgICAgIGN1cnIgPSBwb2x5bGluZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyNClcclxuXHJcbiAgICAgICAgICAgICAgICB4MCA9IGxhc3RbMiAqIDIgKyAwXTtcclxuICAgICAgICAgICAgICAgIHkwID0gbGFzdFsyICogMiArIDFdO1xyXG4gICAgICAgICAgICAgICAgeDEgPSBsYXN0WzIgKiAwICsgMF07XHJcbiAgICAgICAgICAgICAgICB5MSA9IGxhc3RbMiAqIDAgKyAxXTtcclxuICAgICAgICAgICAgICAgIHgyID0gY3VyclsyICogMyArIDBdO1xyXG4gICAgICAgICAgICAgICAgeTIgPSBjdXJyWzIgKiAzICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgwO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkwO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVDb2xvcjtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDE7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTE7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUNvbG9yO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MjtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MjtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQ29sb3I7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICAgICAgICAgIHgwID0gbGFzdFsyICogMCArIDBdO1xyXG4gICAgICAgICAgICAgICAgeTAgPSBsYXN0WzIgKiAwICsgMV07XHJcbiAgICAgICAgICAgICAgICB4MSA9IGxhc3RbMiAqIDIgKyAwXTtcclxuICAgICAgICAgICAgICAgIHkxID0gbGFzdFsyICogMiArIDFdO1xyXG4gICAgICAgICAgICAgICAgeDIgPSBjdXJyWzIgKiAxICsgMF07XHJcbiAgICAgICAgICAgICAgICB5MiA9IGN1cnJbMiAqIDEgKyAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDA7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTA7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUNvbG9yO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MTtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MTtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQ29sb3I7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgyO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkyO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVDb2xvcjtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCArPSA2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgcG9seWxpbmVzTGVuZ3RoID0gcG9seWxpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGluZGV4IDwgcG9seWxpbmVzTGVuZ3RoOyArK2luZGV4KVxyXG4gICAgICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGV4Q291bnQgKyA2ID4gdGhpcy5tYXhWZXJ0aWNlcylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGFzdCA9IHBvbHlsaW5lc1tpbmRleCAtIDFdIHx8IHBvbHlsaW5lc1twb2x5bGluZXNMZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGN1cnIgPSBwb2x5bGluZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyNClcclxuXHJcbiAgICAgICAgICAgICAgICB4MCA9IGxhc3RbMiAqIDIgKyAwXTtcclxuICAgICAgICAgICAgICAgIHkwID0gbGFzdFsyICogMiArIDFdO1xyXG4gICAgICAgICAgICAgICAgeDEgPSBsYXN0WzIgKiAwICsgMF07XHJcbiAgICAgICAgICAgICAgICB5MSA9IGxhc3RbMiAqIDAgKyAxXTtcclxuICAgICAgICAgICAgICAgIHgyID0gY3VyclsyICogMyArIDBdO1xyXG4gICAgICAgICAgICAgICAgeTIgPSBjdXJyWzIgKiAzICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgwO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkwO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVDb2xvcjtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDE7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTE7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUNvbG9yO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MjtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MjtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQ29sb3I7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICAgICAgICAgIHgwID0gbGFzdFsyICogMCArIDBdO1xyXG4gICAgICAgICAgICAgICAgeTAgPSBsYXN0WzIgKiAwICsgMV07XHJcbiAgICAgICAgICAgICAgICB4MSA9IGxhc3RbMiAqIDIgKyAwXTtcclxuICAgICAgICAgICAgICAgIHkxID0gbGFzdFsyICogMiArIDFdO1xyXG4gICAgICAgICAgICAgICAgeDIgPSBjdXJyWzIgKiAxICsgMF07XHJcbiAgICAgICAgICAgICAgICB5MiA9IGN1cnJbMiAqIDEgKyAxXTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgwO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkwO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVDb2xvcjtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDE7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTE7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUNvbG9yO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MjtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MjtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQ29sb3I7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4Q291bnQgKz0gNjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwb2x5bGluZXMubGVuZ3RoID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkRmlsbFBhdGg6IGZ1bmN0aW9uIChcclxuICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzICovXHJcbiAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgIC8qIFBhdGggcHJvcGVydGllcyAqL1xyXG4gICAgICAgIHBhdGgsIGZpbGxDb2xvciwgZmlsbEFscGhhLFxyXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xyXG4gICAgICAgIGEsIGIsIGMsIGQsIGUsIGZcclxuICAgICkge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICB2YXIgcG9seWdvbkNhY2hlID0gdGhpcy5wb2x5Z29uQ2FjaGU7XHJcbiAgICAgICAgdmFyIHBvbHlnb25JbmRleEFycmF5O1xyXG4gICAgICAgIHZhciBwb2ludDtcclxuICAgICAgICB2YXIgdjAsIHYxLCB2MjtcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IHRoaXMudmVydGV4Q291bnQ7XHJcbiAgICAgICAgdmFyIG1heFZlcnRpY2VzID0gdGhpcy5tYXhWZXJ0aWNlcztcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyRjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlclUzMiA9IHZlcnRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTI7XHJcbiAgICAgICAgdmFyIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTI7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHBhdGhJbmRleCA9IDA7IHBhdGhJbmRleCA8IGxlbmd0aDsgKytwYXRoSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwb2ludCA9IHBhdGhbcGF0aEluZGV4XTtcclxuICAgICAgICAgICAgcG9seWdvbkNhY2hlLnB1c2gocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvbHlnb25JbmRleEFycmF5ID0gRWFyY3V0KHBvbHlnb25DYWNoZSk7XHJcbiAgICAgICAgbGVuZ3RoID0gcG9seWdvbkluZGV4QXJyYXkubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdjAgPSBwb2x5Z29uSW5kZXhBcnJheVtpbmRleCArIDBdICogMjtcclxuICAgICAgICAgICAgdjEgPSBwb2x5Z29uSW5kZXhBcnJheVtpbmRleCArIDFdICogMjtcclxuICAgICAgICAgICAgdjIgPSBwb2x5Z29uSW5kZXhBcnJheVtpbmRleCArIDJdICogMjtcclxuXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhDb3VudCArIDMgPiBtYXhWZXJ0aWNlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IHZlcnRleENvdW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4Q291bnQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMTIpO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhDb3VudCArPSAzO1xyXG5cclxuICAgICAgICAgICAgeDAgPSBwb2x5Z29uQ2FjaGVbdjAgKyAwXTtcclxuICAgICAgICAgICAgeTAgPSBwb2x5Z29uQ2FjaGVbdjAgKyAxXTtcclxuICAgICAgICAgICAgeDEgPSBwb2x5Z29uQ2FjaGVbdjEgKyAwXTtcclxuICAgICAgICAgICAgeTEgPSBwb2x5Z29uQ2FjaGVbdjEgKyAxXTtcclxuICAgICAgICAgICAgeDIgPSBwb2x5Z29uQ2FjaGVbdjIgKyAwXTtcclxuICAgICAgICAgICAgeTIgPSBwb2x5Z29uQ2FjaGVbdjIgKyAxXTtcclxuXHJcbiAgICAgICAgICAgIHR4MCA9IHgwICogYSArIHkwICogYyArIGU7XHJcbiAgICAgICAgICAgIHR5MCA9IHgwICogYiArIHkwICogZCArIGY7XHJcbiAgICAgICAgICAgIHR4MSA9IHgxICogYSArIHkxICogYyArIGU7XHJcbiAgICAgICAgICAgIHR5MSA9IHgxICogYiArIHkxICogZCArIGY7XHJcbiAgICAgICAgICAgIHR4MiA9IHgyICogYSArIHkyICogYyArIGU7XHJcbiAgICAgICAgICAgIHR5MiA9IHgyICogYiArIHkyICogZCArIGY7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxBbHBoYTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gdmVydGV4Q291bnQ7XHJcbiAgICAgICAgcG9seWdvbkNhY2hlLmxlbmd0aCA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEZpbGxSZWN0OiBmdW5jdGlvbiAoXHJcbiAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgcHJvcGVydGllcyAqL1xyXG4gICAgICAgIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcclxuICAgICAgICAvKiBSZWN0YW5nbGUgcHJvcGVydGllcyAqL1xyXG4gICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZpbGxDb2xvciwgZmlsbEFscGhhLFxyXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xyXG4gICAgICAgIGEsIGIsIGMsIGQsIGUsIGZcclxuICAgICkge1xyXG4gICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ICsgNiA+IHRoaXMubWF4VmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyNCk7XHJcbiAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xyXG4gICAgICAgIHZhciB5aCA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgdmFyIHR4MCA9IHggKiBhICsgeSAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB0eTAgPSB4ICogYiArIHkgKiBkICsgZjtcclxuICAgICAgICB2YXIgdHgxID0geCAqIGEgKyB5aCAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB0eTEgPSB4ICogYiArIHloICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4MiA9IHh3ICogYSArIHloICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5MiA9IHh3ICogYiArIHloICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4MyA9IHh3ICogYSArIHkgKiBjICsgZTtcclxuICAgICAgICB2YXIgdHkzID0geHcgKiBiICsgeSAqIGQgKyBmO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ICs9IDY7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEZpbGxUcmlhbmdsZTogZnVuY3Rpb24gKFxyXG4gICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IHByb3BlcnRpZXMgKi9cclxuICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgLyogVHJpYW5nbGUgcHJvcGVydGllcyAqL1xyXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGZpbGxDb2xvciwgZmlsbEFscGhhLFxyXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xyXG4gICAgICAgIGEsIGIsIGMsIGQsIGUsIGZcclxuICAgICkge1xyXG4gICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ICsgMyA+IHRoaXMubWF4VmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgxMik7XHJcbiAgICAgICAgdmFyIHR4MCA9IHgwICogYSArIHkwICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5MCA9IHgwICogYiArIHkwICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4MSA9IHgxICogYSArIHkxICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5MSA9IHgxICogYiArIHkxICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4MiA9IHgyICogYSArIHkyICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5MiA9IHgyICogYiArIHkyICogZCArIGY7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgKz0gMztcclxuICAgIH0sXHJcblxyXG4gICAgYWRkU3Ryb2tlVHJpYW5nbGU6IGZ1bmN0aW9uIChcclxuICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzICovXHJcbiAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgIC8qIFRyaWFuZ2xlIHByb3BlcnRpZXMgKi9cclxuICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIGxpbmVDb2xvciwgbGluZUFscGhhLFxyXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xyXG4gICAgICAgIGEsIGIsIGMsIGQsIGUsIGZcclxuICAgICkge1xyXG4gICAgICAgIHZhciB0ZW1wVHJpYW5nbGUgPSB0aGlzLnRlbXBUcmlhbmdsZTtcclxuXHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzBdLnggPSB4MDtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMF0ueSA9IHkwO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVsxXS54ID0geDE7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzFdLnkgPSB5MTtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMl0ueCA9IHgyO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVsyXS55ID0geTI7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzNdLnggPSB4MDtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbM10ueSA9IHkwO1xyXG5cclxuICAgICAgICB0aGlzLmFkZFN0cm9rZVBhdGgoXHJcbiAgICAgICAgICAgIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcclxuICAgICAgICAgICAgdGVtcFRyaWFuZ2xlLCBsaW5lV2lkdGgsIGxpbmVDb2xvciwgbGluZUFscGhhLFxyXG4gICAgICAgICAgICBhLCBiLCBjLCBkLCBlLCBmXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hhcGVCYXRjaDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9TaGFwZUJhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9TaGFwZUJhdGNoLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuICAgICd1bmlmb3JtIG1hdDQgdV92aWV3X21hdHJpeDsnLFxyXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcclxuICAgICdhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yOycsXHJcbiAgICAnYXR0cmlidXRlIGZsb2F0IGFfYWxwaGE7JyxcclxuICAgICd2YXJ5aW5nIHZlYzQgdl9jb2xvcjsnLFxyXG4gICAgJ3ZhcnlpbmcgZmxvYXQgdl9hbHBoYTsnLFxyXG4gICAgJ3ZvaWQgbWFpbiAoKSB7JyxcclxuICAgICcgICBnbF9Qb3NpdGlvbiA9IHVfdmlld19tYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCwgMS4wKTsnLFxyXG4gICAgJyAgIHZfY29sb3IgPSBhX2NvbG9yOycsXHJcbiAgICAnICAgdl9hbHBoYSA9IGFfYWxwaGE7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3NoYXBlL1ZlcnRleFNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGcmFnbWVudFNoYWRlciA9IHJlcXVpcmUoJy4vRnJhZ21lbnRTaGFkZXInKTtcclxudmFyIFZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4vVmVydGV4U2hhZGVyJyk7XHJcblxyXG52YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgVkVSVEVYX1NJWkU6IDE2LFxyXG5cclxuICAgIC8vIEhvdyBtYW55IDMyLWJpdCBjb21wb25lbnRzIGRvZXMgdGhlIHZlcnRleCBoYXZlLlxyXG4gICAgU0hBUEVfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVDogNCxcclxuXHJcbiAgICAvLyBDYW4ndCBiZSBiaWdnZXIgdGhhbiAxMCwwMDAgc2luY2UgaW5kZXggYXJlIDE2LWJpdFxyXG4gICAgTUFYX1ZFUlRJQ0VTOiAxNjAwMCxcclxuXHJcbiAgICBWRVJURVhfU0hBREVSX1NPVVJDRTogVmVydGV4U2hhZGVyLFxyXG4gICAgRlJBR01FTlRfU0hBREVSX1NPVVJDRTogRnJhZ21lbnRTaGFkZXJcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3NoYXBlL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0OTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9jb25zdC5qcyIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc2hhcGUvZWFyY3V0LmpzIiwiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgbjtuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxuLmVhcmN1dD1lKCl9fShmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiBlKG4sdCxyKXtmdW5jdGlvbiB4KHUsZil7aWYoIXRbdV0pe2lmKCFuW3VdKXt2YXIgbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZvKXJldHVybiBvKHUsITApO2lmKGkpcmV0dXJuIGkodSwhMCk7dmFyIHY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIit1K1wiJ1wiKTt0aHJvdyB2LmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsdn12YXIgbD10W3VdPXtleHBvcnRzOnt9fTtuW3VdWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciB0PW5bdV1bMV1bZV07cmV0dXJuIHgodD90OmUpfSxsLGwuZXhwb3J0cyxlLG4sdCxyKX1yZXR1cm4gdFt1XS5leHBvcnRzfWZvcih2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLHU9MDt1PHIubGVuZ3RoO3UrKyl4KHJbdV0pO3JldHVybiB4fSh7MTpbZnVuY3Rpb24oZSxuLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSxuLHQpe3Q9dHx8Mjt2YXIgcj1uJiZuLmxlbmd0aCxpPXI/blswXSp0OmUubGVuZ3RoLGY9eChlLDAsaSx0LCEwKSxvPVtdO2lmKCFmKXJldHVybiBvO3ZhciB2LGwscCxhLGgscyxjO2lmKHImJihmPXkoZSxuLGYsdCkpLGUubGVuZ3RoPjgwKnQpe3Y9cD1lWzBdLGw9YT1lWzFdO2Zvcih2YXIgZD10O2k+ZDtkKz10KWg9ZVtkXSxzPWVbZCsxXSx2PmgmJih2PWgpLGw+cyYmKGw9cyksaD5wJiYocD1oKSxzPmEmJihhPXMpO2M9TWF0aC5tYXgocC12LGEtbCl9cmV0dXJuIHUoZixvLHQsdixsLGMpLG99ZnVuY3Rpb24geChlLG4sdCxyLHgpe3ZhciBpLHU7aWYoeD09PV8oZSxuLHQscik+MClmb3IoaT1uO3Q+aTtpKz1yKXU9RShpLGVbaV0sZVtpKzFdLHUpO2Vsc2UgZm9yKGk9dC1yO2k+PW47aS09cil1PUUoaSxlW2ldLGVbaSsxXSx1KTtyZXR1cm4gdSYmeih1LHUubmV4dCkmJihOKHUpLHU9dS5uZXh0KSx1fWZ1bmN0aW9uIGkoZSxuKXtpZighZSlyZXR1cm4gZTtufHwobj1lKTt2YXIgdCxyPWU7ZG8gaWYodD0hMSxyLnN0ZWluZXJ8fCF6KHIsci5uZXh0KSYmMCE9PWIoci5wcmV2LHIsci5uZXh0KSlyPXIubmV4dDtlbHNle2lmKE4ocikscj1uPXIucHJldixyPT09ci5uZXh0KXJldHVybiBudWxsO3Q9ITB9d2hpbGUodHx8ciE9PW4pO3JldHVybiBufWZ1bmN0aW9uIHUoZSxuLHQscix4LHkscCl7aWYoZSl7IXAmJnkmJnMoZSxyLHgseSk7Zm9yKHZhciBhLGgsYz1lO2UucHJldiE9PWUubmV4dDspaWYoYT1lLnByZXYsaD1lLm5leHQseT9vKGUscix4LHkpOmYoZSkpbi5wdXNoKGEuaS90KSxuLnB1c2goZS5pL3QpLG4ucHVzaChoLmkvdCksTihlKSxlPWgubmV4dCxjPWgubmV4dDtlbHNlIGlmKGU9aCxlPT09Yyl7cD8xPT09cD8oZT12KGUsbix0KSx1KGUsbix0LHIseCx5LDIpKToyPT09cCYmbChlLG4sdCxyLHgseSk6dShpKGUpLG4sdCxyLHgseSwxKTticmVha319fWZ1bmN0aW9uIGYoZSl7dmFyIG49ZS5wcmV2LHQ9ZSxyPWUubmV4dDtpZihiKG4sdCxyKT49MClyZXR1cm4hMTtmb3IodmFyIHg9ZS5uZXh0Lm5leHQ7eCE9PWUucHJldjspe2lmKGcobi54LG4ueSx0LngsdC55LHIueCxyLnkseC54LHgueSkmJmIoeC5wcmV2LHgseC5uZXh0KT49MClyZXR1cm4hMTt4PXgubmV4dH1yZXR1cm4hMH1mdW5jdGlvbiBvKGUsbix0LHIpe3ZhciB4PWUucHJldixpPWUsdT1lLm5leHQ7aWYoYih4LGksdSk+PTApcmV0dXJuITE7Zm9yKHZhciBmPXgueDxpLng/eC54PHUueD94Lng6dS54OmkueDx1Lng/aS54OnUueCxvPXgueTxpLnk/eC55PHUueT94Lnk6dS55OmkueTx1Lnk/aS55OnUueSx2PXgueD5pLng/eC54PnUueD94Lng6dS54OmkueD51Lng/aS54OnUueCxsPXgueT5pLnk/eC55PnUueT94Lnk6dS55OmkueT51Lnk/aS55OnUueSx5PWQoZixvLG4sdCxyKSxwPWQodixsLG4sdCxyKSxhPWUubmV4dFo7YSYmYS56PD1wOyl7aWYoYSE9PWUucHJldiYmYSE9PWUubmV4dCYmZyh4LngseC55LGkueCxpLnksdS54LHUueSxhLngsYS55KSYmYihhLnByZXYsYSxhLm5leHQpPj0wKXJldHVybiExO2E9YS5uZXh0Wn1mb3IoYT1lLnByZXZaO2EmJmEuej49eTspe2lmKGEhPT1lLnByZXYmJmEhPT1lLm5leHQmJmcoeC54LHgueSxpLngsaS55LHUueCx1LnksYS54LGEueSkmJmIoYS5wcmV2LGEsYS5uZXh0KT49MClyZXR1cm4hMTthPWEucHJldlp9cmV0dXJuITB9ZnVuY3Rpb24gdihlLG4sdCl7dmFyIHI9ZTtkb3t2YXIgeD1yLnByZXYsaT1yLm5leHQubmV4dDsheih4LGkpJiZNKHgscixyLm5leHQsaSkmJnEoeCxpKSYmcShpLHgpJiYobi5wdXNoKHguaS90KSxuLnB1c2goci5pL3QpLG4ucHVzaChpLmkvdCksTihyKSxOKHIubmV4dCkscj1lPWkpLHI9ci5uZXh0fXdoaWxlKHIhPT1lKTtyZXR1cm4gcn1mdW5jdGlvbiBsKGUsbix0LHIseCxmKXt2YXIgbz1lO2Rve2Zvcih2YXIgdj1vLm5leHQubmV4dDt2IT09by5wcmV2Oyl7aWYoby5pIT09di5pJiZ3KG8sdikpe3ZhciBsPUQobyx2KTtyZXR1cm4gbz1pKG8sby5uZXh0KSxsPWkobCxsLm5leHQpLHUobyxuLHQscix4LGYpLHZvaWQgdShsLG4sdCxyLHgsZil9dj12Lm5leHR9bz1vLm5leHR9d2hpbGUobyE9PWUpfWZ1bmN0aW9uIHkoZSxuLHQscil7dmFyIHUsZixvLHYsbCx5PVtdO2Zvcih1PTAsZj1uLmxlbmd0aDtmPnU7dSsrKW89blt1XSpyLHY9Zi0xPnU/blt1KzFdKnI6ZS5sZW5ndGgsbD14KGUsbyx2LHIsITEpLGw9PT1sLm5leHQmJihsLnN0ZWluZXI9ITApLHkucHVzaChaKGwpKTtmb3IoeS5zb3J0KHApLHU9MDt1PHkubGVuZ3RoO3UrKylhKHlbdV0sdCksdD1pKHQsdC5uZXh0KTtyZXR1cm4gdH1mdW5jdGlvbiBwKGUsbil7cmV0dXJuIGUueC1uLnh9ZnVuY3Rpb24gYShlLG4pe2lmKG49aChlLG4pKXt2YXIgdD1EKG4sZSk7aSh0LHQubmV4dCl9fWZ1bmN0aW9uIGgoZSxuKXt2YXIgdCxyPW4seD1lLngsaT1lLnksdT0tKDEvMCk7ZG97aWYoaTw9ci55JiZpPj1yLm5leHQueSl7dmFyIGY9ci54KyhpLXIueSkqKHIubmV4dC54LXIueCkvKHIubmV4dC55LXIueSk7aWYoeD49ZiYmZj51KXtpZih1PWYsZj09PXgpe2lmKGk9PT1yLnkpcmV0dXJuIHI7aWYoaT09PXIubmV4dC55KXJldHVybiByLm5leHR9dD1yLng8ci5uZXh0Lng/cjpyLm5leHR9fXI9ci5uZXh0fXdoaWxlKHIhPT1uKTtpZighdClyZXR1cm4gbnVsbDtpZih4PT09dSlyZXR1cm4gdC5wcmV2O3ZhciBvLHY9dCxsPXQueCx5PXQueSxwPTEvMDtmb3Iocj10Lm5leHQ7ciE9PXY7KXg+PXIueCYmci54Pj1sJiZnKHk+aT94OnUsaSxsLHkseT5pP3U6eCxpLHIueCxyLnkpJiYobz1NYXRoLmFicyhpLXIueSkvKHgtci54KSwocD5vfHxvPT09cCYmci54PnQueCkmJnEocixlKSYmKHQ9cixwPW8pKSxyPXIubmV4dDtyZXR1cm4gdH1mdW5jdGlvbiBzKGUsbix0LHIpe3ZhciB4PWU7ZG8gbnVsbD09PXgueiYmKHguej1kKHgueCx4Lnksbix0LHIpKSx4LnByZXZaPXgucHJldix4Lm5leHRaPXgubmV4dCx4PXgubmV4dDt3aGlsZSh4IT09ZSk7eC5wcmV2Wi5uZXh0Wj1udWxsLHgucHJldlo9bnVsbCxjKHgpfWZ1bmN0aW9uIGMoZSl7dmFyIG4sdCxyLHgsaSx1LGYsbyx2PTE7ZG97Zm9yKHQ9ZSxlPW51bGwsaT1udWxsLHU9MDt0Oyl7Zm9yKHUrKyxyPXQsZj0wLG49MDt2Pm4mJihmKysscj1yLm5leHRaLHIpO24rKyk7Zm9yKG89djtmPjB8fG8+MCYmcjspMD09PWY/KHg9cixyPXIubmV4dFosby0tKTowIT09byYmcj90Lno8PXIuej8oeD10LHQ9dC5uZXh0WixmLS0pOih4PXIscj1yLm5leHRaLG8tLSk6KHg9dCx0PXQubmV4dFosZi0tKSxpP2kubmV4dFo9eDplPXgseC5wcmV2Wj1pLGk9eDt0PXJ9aS5uZXh0Wj1udWxsLHYqPTJ9d2hpbGUodT4xKTtyZXR1cm4gZX1mdW5jdGlvbiBkKGUsbix0LHIseCl7cmV0dXJuIGU9MzI3NjcqKGUtdCkveCxuPTMyNzY3KihuLXIpL3gsZT0xNjcxMTkzNSYoZXxlPDw4KSxlPTI1MjY0NTEzNSYoZXxlPDw0KSxlPTg1ODk5MzQ1OSYoZXxlPDwyKSxlPTE0MzE2NTU3NjUmKGV8ZTw8MSksbj0xNjcxMTkzNSYobnxuPDw4KSxuPTI1MjY0NTEzNSYobnxuPDw0KSxuPTg1ODk5MzQ1OSYobnxuPDwyKSxuPTE0MzE2NTU3NjUmKG58bjw8MSksZXxuPDwxfWZ1bmN0aW9uIFooZSl7dmFyIG49ZSx0PWU7ZG8gbi54PHQueCYmKHQ9biksbj1uLm5leHQ7d2hpbGUobiE9PWUpO3JldHVybiB0fWZ1bmN0aW9uIGcoZSxuLHQscix4LGksdSxmKXtyZXR1cm4oeC11KSoobi1mKS0oZS11KSooaS1mKT49MCYmKGUtdSkqKHItZiktKHQtdSkqKG4tZik+PTAmJih0LXUpKihpLWYpLSh4LXUpKihyLWYpPj0wfWZ1bmN0aW9uIHcoZSxuKXtyZXR1cm4gZS5uZXh0LmkhPT1uLmkmJmUucHJldi5pIT09bi5pJiYhbShlLG4pJiZxKGUsbikmJnEobixlKSYmTyhlLG4pfWZ1bmN0aW9uIGIoZSxuLHQpe3JldHVybihuLnktZS55KSoodC54LW4ueCktKG4ueC1lLngpKih0Lnktbi55KX1mdW5jdGlvbiB6KGUsbil7cmV0dXJuIGUueD09PW4ueCYmZS55PT09bi55fWZ1bmN0aW9uIE0oZSxuLHQscil7cmV0dXJuIHooZSxuKSYmeih0LHIpfHx6KGUscikmJnoodCxuKT8hMDpiKGUsbix0KT4wIT1iKGUsbixyKT4wJiZiKHQscixlKT4wIT1iKHQscixuKT4wfWZ1bmN0aW9uIG0oZSxuKXt2YXIgdD1lO2Rve2lmKHQuaSE9PWUuaSYmdC5uZXh0LmkhPT1lLmkmJnQuaSE9PW4uaSYmdC5uZXh0LmkhPT1uLmkmJk0odCx0Lm5leHQsZSxuKSlyZXR1cm4hMDt0PXQubmV4dH13aGlsZSh0IT09ZSk7cmV0dXJuITF9ZnVuY3Rpb24gcShlLG4pe3JldHVybiBiKGUucHJldixlLGUubmV4dCk8MD9iKGUsbixlLm5leHQpPj0wJiZiKGUsZS5wcmV2LG4pPj0wOmIoZSxuLGUucHJldik8MHx8YihlLGUubmV4dCxuKTwwfWZ1bmN0aW9uIE8oZSxuKXt2YXIgdD1lLHI9ITEseD0oZS54K24ueCkvMixpPShlLnkrbi55KS8yO2RvIHQueT5pIT10Lm5leHQueT5pJiZ4PCh0Lm5leHQueC10LngpKihpLXQueSkvKHQubmV4dC55LXQueSkrdC54JiYocj0hciksdD10Lm5leHQ7d2hpbGUodCE9PWUpO3JldHVybiByfWZ1bmN0aW9uIEQoZSxuKXt2YXIgdD1uZXcgVShlLmksZS54LGUueSkscj1uZXcgVShuLmksbi54LG4ueSkseD1lLm5leHQsaT1uLnByZXY7cmV0dXJuIGUubmV4dD1uLG4ucHJldj1lLHQubmV4dD14LHgucHJldj10LHIubmV4dD10LHQucHJldj1yLGkubmV4dD1yLHIucHJldj1pLHJ9ZnVuY3Rpb24gRShlLG4sdCxyKXt2YXIgeD1uZXcgVShlLG4sdCk7cmV0dXJuIHI/KHgubmV4dD1yLm5leHQseC5wcmV2PXIsci5uZXh0LnByZXY9eCxyLm5leHQ9eCk6KHgucHJldj14LHgubmV4dD14KSx4fWZ1bmN0aW9uIE4oZSl7ZS5uZXh0LnByZXY9ZS5wcmV2LGUucHJldi5uZXh0PWUubmV4dCxlLnByZXZaJiYoZS5wcmV2Wi5uZXh0Wj1lLm5leHRaKSxlLm5leHRaJiYoZS5uZXh0Wi5wcmV2Wj1lLnByZXZaKX1mdW5jdGlvbiBVKGUsbix0KXt0aGlzLmk9ZSx0aGlzLng9bix0aGlzLnk9dCx0aGlzLnByZXY9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLno9bnVsbCx0aGlzLnByZXZaPW51bGwsdGhpcy5uZXh0Wj1udWxsLHRoaXMuc3RlaW5lcj0hMX1mdW5jdGlvbiBfKGUsbix0LHIpe2Zvcih2YXIgeD0wLGk9bix1PXQtcjt0Pmk7aSs9cil4Kz0oZVt1XS1lW2ldKSooZVtpKzFdK2VbdSsxXSksdT1pO3JldHVybiB4fW4uZXhwb3J0cz1yLHIuZGV2aWF0aW9uPWZ1bmN0aW9uKGUsbix0LHIpe3ZhciB4PW4mJm4ubGVuZ3RoLGk9eD9uWzBdKnQ6ZS5sZW5ndGgsdT1NYXRoLmFicyhfKGUsMCxpLHQpKTtpZih4KWZvcih2YXIgZj0wLG89bi5sZW5ndGg7bz5mO2YrKyl7dmFyIHY9bltmXSp0LGw9by0xPmY/bltmKzFdKnQ6ZS5sZW5ndGg7dS09TWF0aC5hYnMoXyhlLHYsbCx0KSl9dmFyIHk9MDtmb3IoZj0wO2Y8ci5sZW5ndGg7Zis9Myl7dmFyIHA9cltmXSp0LGE9cltmKzFdKnQsaD1yW2YrMl0qdDt5Kz1NYXRoLmFicygoZVtwXS1lW2hdKSooZVthKzFdLWVbcCsxXSktKGVbcF0tZVthXSkqKGVbaCsxXS1lW3ArMV0pKX1yZXR1cm4gMD09PXUmJjA9PT15PzA6TWF0aC5hYnMoKHktdSkvdSl9LHIuZmxhdHRlbj1mdW5jdGlvbihlKXtmb3IodmFyIG49ZVswXVswXS5sZW5ndGgsdD17dmVydGljZXM6W10saG9sZXM6W10sZGltZW5zaW9uczpufSxyPTAseD0wO3g8ZS5sZW5ndGg7eCsrKXtmb3IodmFyIGk9MDtpPGVbeF0ubGVuZ3RoO2krKylmb3IodmFyIHU9MDtuPnU7dSsrKXQudmVydGljZXMucHVzaChlW3hdW2ldW3VdKTt4PjAmJihyKz1lW3gtMV0ubGVuZ3RoLHQuaG9sZXMucHVzaChyKSl9cmV0dXJuIHR9fSx7fV19LHt9LFsxXSkoMSl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3NoYXBlL2VhcmN1dC5qc1xuLy8gbW9kdWxlIGlkID0gNDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXHJcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9zYW1wbGVyMkQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzMgdl9jb2xvcjsnLFxyXG4gICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3NhbXBsZXIyRCwgdl90ZXhfY29vcmQpICogdmVjNCh2X2NvbG9yLCAxLjApOycsXHJcbiAgICAnfSdcclxuXS5qb2luKCdcXG4nKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvRnJhZ21lbnRTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmluZFZlcnRleEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL0JpbmRWZXJ0ZXhBcnJheScpO1xyXG52YXIgQ3JlYXRlUHJvZ3JhbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtJyk7XHJcbnZhciBDcmVhdGVTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9zaGFkZXIvQ3JlYXRlU2hhZGVyJyk7XHJcbnZhciBDcmVhdGVCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9idWZmZXIvQ3JlYXRlQnVmZmVyJyk7XHJcbnZhciBDcmVhdGVBdHRyaWJEZXNjID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MnKTtcclxudmFyIEJ1ZmZlcjMyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL0J1ZmZlcjMyJyk7XHJcbnZhciBCdWZmZXIxNiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9CdWZmZXIxNicpO1xyXG52YXIgVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vVmVydGV4QXJyYXknKTtcclxudmFyIFRyYW5zZm9ybU1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbXBvbmVudHMvVHJhbnNmb3JtTWF0cml4Jyk7XHJcblxyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIFNwcml0ZUJhdGNoID0gZnVuY3Rpb24gKGdhbWUsIGdsLCBtYW5hZ2VyKVxyXG57XHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgdGhpcy50eXBlID0gUEhBU0VSX0NPTlNULldFQkdMO1xyXG4gICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICB0aGlzLm1heFNwcml0ZXMgPSBudWxsO1xyXG4gICAgdGhpcy52ZXJ0U2hhZGVyID0gbnVsbDtcclxuICAgIHRoaXMuZnJhZ1NoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xyXG4gICAgdGhpcy52ZXJ0ZXhBcnJheSA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBudWxsO1xyXG4gICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSBudWxsO1xyXG4gICAgdGhpcy50ZW1wTWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG4gICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgIFdlYkdMQ29udGV4dE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuaW5pdCh0aGlzLmdsQ29udGV4dCk7XHJcbn07XHJcblxyXG5TcHJpdGVCYXRjaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJpdGVCYXRjaDtcclxuXHJcblNwcml0ZUJhdGNoLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZ2wpXHJcbiAgICB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gbmV3IEJ1ZmZlcjMyKENPTlNULlZFUlRFWF9TSVpFICogQ09OU1QuU1BSSVRFX1ZFUlRFWF9DT1VOVCAqIENPTlNULk1BWF9TUFJJVEVTKTtcclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IEJ1ZmZlcjE2KENPTlNULklOREVYX1NJWkUgKiBDT05TVC5TUFJJVEVfSU5ERVhfQ09VTlQgKiBDT05TVC5NQVhfU1BSSVRFUyk7XHJcbiAgICAgICAgdmFyIHZlcnRTaGFkZXIgPSBDcmVhdGVTaGFkZXIoZ2wsIENPTlNULlZFUlRFWF9TSEFERVJfU09VUkNFLCBnbC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgICB2YXIgZnJhZ1NoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgQ09OU1QuRlJBR01FTlRfU0hBREVSX1NPVVJDRSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IENyZWF0ZVByb2dyYW0oZ2wsIHZlcnRTaGFkZXIsIGZyYWdTaGFkZXIpO1xyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlck9iamVjdCA9IENyZWF0ZUJ1ZmZlcihnbCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXLCBudWxsLCBpbmRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpO1xyXG4gICAgICAgIHZhciBhdHRyaWJBcnJheSA9IFtcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfcG9zaXRpb24nLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAwKSxcclxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfdGV4X2Nvb3JkJywgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgOCksXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX2NvbG9yJywgMywgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDE2KVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIHZlcnRleEFycmF5ID0gbmV3IFZlcnRleEFycmF5KENyZWF0ZUJ1ZmZlcihnbCwgZ2wuQVJSQVlfQlVGRkVSLCBnbC5TVFJFQU1fRFJBVywgbnVsbCwgdmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSksIGF0dHJpYkFycmF5KTtcclxuICAgICAgICB2YXIgdmlld01hdHJpeExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3ZpZXdfbWF0cml4Jyk7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciBtYXggPSBDT05TVC5NQVhfU1BSSVRFUyAqIENPTlNULlNQUklURV9JTkRFWF9DT1VOVDtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnZlcnRTaGFkZXIgPSB2ZXJ0U2hhZGVyO1xyXG4gICAgICAgIHRoaXMuZnJhZ1NoYWRlciA9IGZyYWdTaGFkZXI7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gaW5kZXhCdWZmZXJPYmplY3Q7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheSA9IHZlcnRleEFycmF5O1xyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gdmlld01hdHJpeExvY2F0aW9uO1xyXG5cclxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULlNQUklURV9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULlNQUklURV9WRVJURVhfQ09VTlQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAwXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMl0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAzXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNV0gPSBpbmRleEIgKyAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhCdWZmZXJPYmplY3QpO1xyXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIDAsIGluZGV4QnVmZmVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbik7XHJcbiAgICAgICAgdGhpcy51bmJpbmQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgaXNGdWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVMZW5ndGgoKSA+PSB0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBiaW5kOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG5cclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcclxuICAgICAgICBCaW5kVmVydGV4QXJyYXkoZ2wsIHRoaXMudmVydGV4QXJyYXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0obnVsbCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmbHVzaDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50Q291bnQgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuXHJcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSk7XHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5lbGVtZW50Q291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgICAgICB2ZXJ0ZXhEYXRhQnVmZmVyLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbilcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihcclxuICAgICAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24sXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIDIgLyB0aGlzLndpZHRoLCAwLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgLTIgLyB0aGlzLmhlaWdodCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIDAsIDEsIDEsXHJcbiAgICAgICAgICAgICAgICAtMSwgMSwgMCwgMFxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcblxyXG4gICAgICAgIGlmIChnbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRTaGFkZXIpO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVTaGFkZXIodGhpcy5mcmFnU2hhZGVyKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEFycmF5LmJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRTcHJpdGU6IGZ1bmN0aW9uIChzcmMsIGNhbWVyYSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGVtcE1hdHJpeCA9IHRoaXMudGVtcE1hdHJpeDtcclxuICAgICAgICB2YXIgZnJhbWUgPSBzcmMuZnJhbWU7XHJcbiAgICAgICAgdmFyIGFscGhhID0gMTY3NzcyMTY7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlckYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciB1dnMgPSBmcmFtZS51dnM7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGZyYW1lLmhlaWdodDtcclxuICAgICAgICB2YXIgdHJhbnNsYXRlWCA9IHNyYy54IC0gY2FtZXJhLnNjcm9sbFg7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBzcmMueSAtIGNhbWVyYS5zY3JvbGxZO1xyXG4gICAgICAgIHZhciBzY2FsZVggPSBzcmMuc2NhbGVYO1xyXG4gICAgICAgIHZhciBzY2FsZVkgPSBzcmMuc2NhbGVZO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1zcmMucm90YXRpb247XHJcbiAgICAgICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgICAgICB2YXIgeCA9IC1zcmMub3JpZ2luWCArIGZyYW1lLng7XHJcbiAgICAgICAgdmFyIHkgPSAtc3JjLm9yaWdpblkgKyBmcmFtZS55O1xyXG4gICAgICAgIHZhciB4dyA9IHggKyB3aWR0aDtcclxuICAgICAgICB2YXIgeWggPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjYW1lcmFNYXRyaXggPSBjYW1lcmEubWF0cml4Lm1hdHJpeDtcclxuICAgICAgICB2YXIgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZiwgdHgwLCB0eTAsIHR4MSwgdHkxLCB0eDIsIHR5MiwgdHgzLCB0eTM7XHJcbiAgICAgICAgdmFyIHNyYSwgc3JiLCBzcmMsIHNyZCwgc3JlLCBzcmYsIGNtYSwgY21iLCBjbWMsIGNtZCwgY21lLCBjbWY7XHJcblxyXG4gICAgICAgIHRlbXBNYXRyaXguYXBwbHlJVFJTKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSk7XHJcblxyXG4gICAgICAgIHNyYSA9IHRlbXBNYXRyaXhNYXRyaXhbMF07XHJcbiAgICAgICAgc3JiID0gdGVtcE1hdHJpeE1hdHJpeFsxXTtcclxuICAgICAgICBzcmMgPSB0ZW1wTWF0cml4TWF0cml4WzJdO1xyXG4gICAgICAgIHNyZCA9IHRlbXBNYXRyaXhNYXRyaXhbM107XHJcbiAgICAgICAgc3JlID0gdGVtcE1hdHJpeE1hdHJpeFs0XTtcclxuICAgICAgICBzcmYgPSB0ZW1wTWF0cml4TWF0cml4WzVdO1xyXG5cclxuICAgICAgICBjbWEgPSBjYW1lcmFNYXRyaXhbMF07XHJcbiAgICAgICAgY21iID0gY2FtZXJhTWF0cml4WzFdO1xyXG4gICAgICAgIGNtYyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgICAgICBjbWQgPSBjYW1lcmFNYXRyaXhbM107XHJcbiAgICAgICAgY21lID0gY2FtZXJhTWF0cml4WzRdO1xyXG4gICAgICAgIGNtZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgbXZhID0gc3JhICogY21hICsgc3JiICogY21jO1xyXG4gICAgICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcclxuICAgICAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XHJcbiAgICAgICAgbXZkID0gc3JjICogY21iICsgc3JkICogY21kO1xyXG4gICAgICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcclxuICAgICAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7IFxyXG4gICAgICAgIFxyXG4gICAgICAgIHR4MCA9IHggKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MCA9IHggKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MSA9IHggKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTEgPSB4ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgyID0geHcgKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTIgPSB4dyAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MyA9IHh3ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTMgPSB4dyAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRCYXRjaCh0aGlzLCBmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlLCBjYW1lcmEpO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjApO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IDY7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gMHhGRkZGRkY7IC8vdmVydGV4Q29sb3IudG9wTGVmdDtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gMHhGRkZGRkY7IC8vdmVydGV4Q29sb3IuYm90dG9tTGVmdDtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gMHhGRkZGRkY7IC8vdmVydGV4Q29sb3IuYm90dG9tUmlnaHQ7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IDB4RkZGRkZGOyAvL3ZlcnRleENvbG9yLnRvcFJpZ2h0O1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ByaXRlQmF0Y2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL1Nwcml0ZUJhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0OThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvU3ByaXRlQmF0Y2guanMiLCJtb2R1bGUuZXhwb3J0cyA9IFtcclxuICAgICd1bmlmb3JtIG1hdDQgdV92aWV3X21hdHJpeDsnLFxyXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcclxuICAgICdhdHRyaWJ1dGUgdmVjMiBhX3RleF9jb29yZDsnLFxyXG4gICAgJ2F0dHJpYnV0ZSB2ZWMzIGFfY29sb3I7JyxcclxuICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzMgdl9jb2xvcjsnLFxyXG4gICAgJ3ZvaWQgbWFpbiAoKSB7JyxcclxuICAgICcgICBnbF9Qb3NpdGlvbiA9IHVfdmlld19tYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCwgMS4wKTsnLFxyXG4gICAgJyAgIHZfdGV4X2Nvb3JkID0gYV90ZXhfY29vcmQ7JyxcclxuICAgICcgICB2X2NvbG9yID0gYV9jb2xvcjsnLFxyXG4gICAgJ30nXHJcbl0uam9pbignXFxuJyk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL1ZlcnRleFNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGcmFnbWVudFNoYWRlciA9IHJlcXVpcmUoJy4vRnJhZ21lbnRTaGFkZXInKTtcclxudmFyIFZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4vVmVydGV4U2hhZGVyJyk7XHJcblxyXG52YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgLy8gVkVSVEVYX1NJWkUgPSAoc2l6ZW9mKHZlYzIpICogNCkgKyAoc2l6ZW9mKGZsb2F0KSArIHNpemVvZih1aW50MzIpKVxyXG4gICAgVkVSVEVYX1NJWkU6IDIwLFxyXG4gICAgSU5ERVhfU0laRTogMixcclxuICAgIFNQUklURV9WRVJURVhfQ09VTlQ6IDQsXHJcbiAgICBTUFJJVEVfSU5ERVhfQ09VTlQ6IDYsXHJcblxyXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXHJcbiAgICBTUFJJVEVfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVDogNSxcclxuXHJcbiAgICAvLyBDYW4ndCBiZSBiaWdnZXIgc2luY2UgaW5kZXggYXJlIDE2LWJpdFxyXG4gICAgTUFYX1NQUklURVM6IDIwMDAsXHJcblxyXG4gICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZlcnRleFNoYWRlcixcclxuICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZyYWdtZW50U2hhZGVyXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDT05TVDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDUwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9jb25zdC5qcyIsInZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vLi4vU2NhbGVNb2RlcycpO1xyXG5cclxudmFyIENyZWF0ZUVtcHR5VGV4dHVyZSA9IGZ1bmN0aW9uIChnbCwgd2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCB0ZXh0dXJlSW5kZXgpXHJcbntcclxuICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgdmFyIGdsU2NhbGVNb2RlID0gKHNjYWxlTW9kZSA9PT0gU2NhbGVNb2Rlcy5MSU5FQVIpID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVDtcclxuXHJcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZUluZGV4KTtcclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcblxyXG4gICAgLy8gIFdlJ2xsIHJlYWQgZnJvbSB0aGlzIHRleHR1cmUsIGJ1dCBpdCB3b24ndCBoYXZlIG1pcG1hcHMsIHNvIHR1cm4gdGhlbSBvZmY6XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xTY2FsZU1vZGUpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsU2NhbGVNb2RlKTtcclxuXHJcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVFbXB0eVRleHR1cmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0NyZWF0ZUVtcHR5VGV4dHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gNTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0NyZWF0ZUVtcHR5VGV4dHVyZS5qcyIsInZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vU2NhbGVNb2RlcycpO1xyXG52YXIgQ3JlYXRlVGV4dHVyZTJESW1hZ2UgPSByZXF1aXJlKCcuL0NyZWF0ZVRleHR1cmUyREltYWdlJyk7XHJcblxyXG52YXIgQ3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZSA9IGZ1bmN0aW9uIChnbCwgc291cmNlKVxyXG57XHJcbiAgICB2YXIgZmlsdGVyO1xyXG5cclxuICAgIGlmIChzb3VyY2Uuc2NhbGVNb2RlID09PSBTY2FsZU1vZGVzLkxJTkVBUilcclxuICAgIHtcclxuICAgICAgICBmaWx0ZXIgPSBnbC5MSU5FQVI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzb3VyY2Uuc2NhbGVNb2RlID09PSBTY2FsZU1vZGVzLk5FQVJFU1QpXHJcbiAgICB7XHJcbiAgICAgICAgZmlsdGVyID0gZ2wuTkVBUkVTVDtcclxuICAgIH1cclxuXHJcbiAgICBzb3VyY2UuZ2xUZXh0dXJlID0gQ3JlYXRlVGV4dHVyZTJESW1hZ2UoZ2wsIHNvdXJjZS5pbWFnZSwgZmlsdGVyLCBzb3VyY2UubWlwbWFwTGV2ZWwpXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVRleHR1cmUyREZyb21Tb3VyY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZS5qcyIsInZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobG9jYXRpb24sIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KVxyXG57XHJcbiAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgIHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XHJcbiAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcclxuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9BdHRyaWJ1dGUuanNcbi8vIG1vZHVsZSBpZCA9IDUwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIEJldHdlZW4gPSByZXF1aXJlKCcuLi8uLi9tYXRoL0JldHdlZW4nKTtcclxudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldE9iamVjdFZhbHVlJyk7XHJcblxyXG4vLyAgUGhhc2VyLlNvdW5kLkR5bmFtaWMuRlhcclxuXHJcbi8vICBCYXNlZCBvbiBTb3VuZC5qcyBieSBLaXR0eUthdEF0dGFja1xyXG4vLyAgaHR0cHM6Ly9naXRodWIuY29tL2tpdHR5a2F0YXR0YWNrL3NvdW5kLmpzXHJcblxyXG4vLyBmcmVxdWVuY3ksICAgICAgLy9UaGUgc291bmQncyBmZXF1ZW5jeSBwaXRjaCBpbiBIZXJ0elxyXG4vLyBhdHRhY2ssICAgICAgICAgICAgICAvL1RoZSB0aW1lLCBpbiBzZWNvbmRzLCB0byBmYWRlIHRoZSBzb3VuZCBpblxyXG4vLyBkZWNheSwgICAgICAgICAgICAgICAvL1RoZSB0aW1lLCBpbiBzZWNvbmRzLCB0byBmYWRlIHRoZSBzb3VuZCBvdXRcclxuLy8gdHlwZSwgICAgICAgICAgICAgICAgLy93YXZlZm9ybSB0eXBlOiBcInNpbmVcIiwgXCJ0cmlhbmdsZVwiLCBcInNxdWFyZVwiLCBcInNhd3Rvb3RoXCJcclxuLy8gdm9sdW1lLCAgICAgICAgIC8vVGhlIHNvdW5kJ3MgbWF4aW11bSB2b2x1bWVcclxuLy8gcGFuVmFsdWUsICAgICAgICAgICAgLy9UaGUgc3BlYWtlciBwYW4uIGxlZnQ6IC0xLCBtaWRkbGU6IDAsIHJpZ2h0OiAxXHJcbi8vIHdhaXQsICAgICAgICAgICAgICAgIC8vVGhlIHRpbWUsIGluIHNlY29uZHMsIHRvIHdhaXQgYmVmb3JlIHBsYXlpbmcgdGhlIHNvdW5kXHJcbi8vIHBpdGNoQmVuZCwgICAgIC8vVGhlIG51bWJlciBvZiBIeiBpbiB3aGljaCB0byBiZW5kIHRoZSBzb3VuZCdzIHBpdGNoIGRvd25cclxuLy8gcmV2ZXJzZSwgICAgICAgICAgICAgLy9JZiBgcmV2ZXJzZWAgaXMgdHJ1ZSB0aGUgcGl0Y2ggd2lsbCBiZW5kIHVwXHJcbi8vIHJhbmRvbSwgICAgICAgICAvL0EgcmFuZ2UsIGluIEh6LCB3aXRoaW4gd2hpY2ggdG8gcmFuZG9taXplIHRoZSBwaXRjaFxyXG4vLyBkaXNzb25hbmNlLCAgICAgICAgICAvL0EgdmFsdWUgaW4gSHouIEl0IGNyZWF0ZXMgMiBkaXNzb25hbnQgZnJlcXVlbmNpZXMgYWJvdmUgYW5kIGJlbG93IHRoZSB0YXJnZXQgcGl0Y2hcclxuLy8gZWNobywgICAgICAgICAgICAgICAgLy9BbiBhcnJheTogW2RlbGF5VGltZUluU2Vjb25kcywgZmVlZGJhY2tUaW1lSW5TZWNvbmRzLCBmaWx0ZXJWYWx1ZUluSHpdXHJcbi8vIHJldmVyYiwgICAgICAgICAgICAgIC8vQW4gYXJyYXk6IFtkdXJhdGlvbkluU2Vjb25kcywgZGVjYXlSYXRlSW5TZWNvbmRzLCByZXZlcnNlXVxyXG4vLyB0aW1lb3V0ICAgICAgICAgICAgICAvL0EgbnVtYmVyLCBpbiBzZWNvbmRzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBkdXJhdGlvbiBmb3Igc291bmQgZWZmZWN0c1xyXG5cclxudmFyIEZYID0gZnVuY3Rpb24gKGN0eCwgY29uZmlnKVxyXG57XHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGN0eDtcclxuXHJcbiAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZnJlcXVlbmN5JywgMjAwKTtcclxuICAgIHRoaXMuYXR0YWNrID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnYXR0YWNrJywgMCk7XHJcbiAgICB0aGlzLmRlY2F5ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZGVjYXknLCAxKTtcclxuICAgIHRoaXMudHlwZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3R5cGUnLCAnc2luZScpO1xyXG4gICAgdGhpcy52b2x1bWVWYWx1ZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3ZvbHVtZScsIDEpO1xyXG4gICAgdGhpcy5wYW5WYWx1ZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3BhbicsIDApO1xyXG4gICAgdGhpcy53YWl0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnd2FpdCcsIDApO1xyXG4gICAgdGhpcy5waXRjaEJlbmRBbW91bnQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdwaXRjaEJlbmQnLCAwKTtcclxuICAgIHRoaXMucmV2ZXJzZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyc2UnLCBmYWxzZSk7XHJcbiAgICB0aGlzLnJhbmRvbVZhbHVlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmFuZG9tJywgMCk7XHJcbiAgICB0aGlzLmRpc3NvbmFuY2UgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdkaXNzb25hbmNlJywgMCk7XHJcbiAgICB0aGlzLmVjaG8gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdlY2hvJywgZmFsc2UpO1xyXG4gICAgdGhpcy5lY2hvRGVsYXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdlY2hvLmRlbGF5JywgMCk7XHJcbiAgICB0aGlzLmVjaG9GZWVkYmFjayA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2VjaG8uZmVlZGJhY2snLCAwKTtcclxuICAgIHRoaXMuZWNob0ZpbHRlciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2VjaG8uZmlsdGVyJywgMCk7XHJcbiAgICB0aGlzLnJldmVyYiA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyYicsIGZhbHNlKTtcclxuICAgIHRoaXMucmV2ZXJiRHVyYXRpb24gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXZlcmIuZHVyYXRpb24nLCAwKTtcclxuICAgIHRoaXMucmV2ZXJiRGVjYXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXZlcmIuZGVjYXknLCAwKTtcclxuICAgIHRoaXMucmV2ZXJiUmV2ZXJzZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyYi5yZXZlcnNlJywgZmFsc2UpO1xyXG4gICAgdGhpcy50aW1lb3V0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndGltZW91dCcsIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLnZvbHVtZSA9IGN0eC5jcmVhdGVHYWluKCk7XHJcbiAgICB0aGlzLnBhbiA9ICghY3R4LmNyZWF0ZVN0ZXJlb1Bhbm5lcikgPyBjdHguY3JlYXRlUGFubmVyKCkgOiBjdHguY3JlYXRlU3RlcmVvUGFubmVyKCk7XHJcblxyXG4gICAgdGhpcy52b2x1bWUuY29ubmVjdCh0aGlzLnBhbik7XHJcbiAgICB0aGlzLnBhbi5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcblxyXG4gICAgLy8gIFNldCB0aGUgdmFsdWVzXHJcblxyXG4gICAgdGhpcy52b2x1bWUuZ2Fpbi52YWx1ZSA9IHRoaXMudm9sdW1lVmFsdWU7XHJcblxyXG4gICAgaWYgKCFjdHguY3JlYXRlU3RlcmVvUGFubmVyKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGFuLnNldFBvc2l0aW9uKHRoaXMucGFuVmFsdWUsIDAsIDEgLSBNYXRoLmFicyh0aGlzLnBhblZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYW4ucGFuLnZhbHVlID0gdGhpcy5wYW5WYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQ3JlYXRlIGFuIG9zY2lsbGF0b3IsIGdhaW4gYW5kIHBhbiBub2RlcywgYW5kIGNvbm5lY3QgdGhlbSB0b2dldGhlciB0byB0aGUgZGVzdGluYXRpb25cclxuXHJcbiAgICB2YXIgb3NjaWxsYXRvciA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcblxyXG4gICAgb3NjaWxsYXRvci5jb25uZWN0KHRoaXMudm9sdW1lKTtcclxuICAgIG9zY2lsbGF0b3IudHlwZSA9IHRoaXMudHlwZTtcclxuXHJcbiAgICAvLyAgT3B0aW9uYWxseSByYW5kb21pemUgdGhlIHBpdGNoIGlmIGByYW5kb21WYWx1ZWAgPiAwLlxyXG4gICAgLy8gIEEgcmFuZG9tIHBpdGNoIGlzIHNlbGVjdGVkIHRoYXQncyB3aXRoaW4gdGhlIHJhbmdlIHNwZWNpZmllZCBieSBgZnJlcXVlbmN5VmFsdWVgLlxyXG4gICAgLy8gIFRoZSByYW5kb20gcGl0Y2ggd2lsbCBiZSBlaXRoZXIgYWJvdmUgb3IgYmVsb3cgdGhlIHRhcmdldCBmcmVxdWVuY3kuXHJcblxyXG4gICAgaWYgKHRoaXMucmFuZG9tVmFsdWUgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gQmV0d2VlbihcclxuICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3lWYWx1ZSAtIHRoaXMucmFuZG9tVmFsdWUgLyAyLFxyXG4gICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlICsgdGhpcy5yYW5kb21WYWx1ZSAvIDJcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5mcmVxdWVuY3lWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQXBwbHkgZWZmZWN0c1xyXG5cclxuICAgIGlmICh0aGlzLmF0dGFjayA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mYWRlSW4odGhpcy52b2x1bWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZmFkZU91dCh0aGlzLnZvbHVtZSk7XHJcblxyXG4gICAgaWYgKHRoaXMucGl0Y2hCZW5kQW1vdW50ID4gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBpdGNoQmVuZChvc2NpbGxhdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5lY2hvKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWRkRWNobyh0aGlzLnZvbHVtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucmV2ZXJiKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWRkUmV2ZXJiKHRoaXMudm9sdW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kaXNzb25hbmNlID4gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFkZERpc3NvbmFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBsYXkob3NjaWxsYXRvcik7XHJcblxyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICBvc2NpbGxhdG9yLm9uZW5kZWQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdvbmVuZGVkJyk7XHJcbiAgICAgICAgX3RoaXMucGFuLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICBfdGhpcy52b2x1bWUuZGlzY29ubmVjdCgpO1xyXG4gICAgfTtcclxufTtcclxuXHJcbkZYLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZYO1xyXG5cclxuRlgucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHBsYXk6IGZ1bmN0aW9uIChvc2NpbGxhdG9yKVxyXG4gICAge1xyXG4gICAgICAgIG9zY2lsbGF0b3Iuc3RhcnQodGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQpO1xyXG5cclxuICAgICAgICAvL09zY2lsbGF0b3JzIGhhdmUgdG8gYmUgc3RvcHBlZCBvdGhlcndpc2UgdGhleSBhY2N1bXVsYXRlIGluIFxyXG4gICAgICAgIC8vbWVtb3J5IGFuZCB0YXggdGhlIENQVS4gVGhleSdsbCBiZSBzdG9wcGVkIGFmdGVyIGEgZGVmYXVsdFxyXG4gICAgICAgIC8vdGltZW91dCBvZiAyIHNlY29uZHMsIHdoaWNoIHNob3VsZCBiZSBlbm91Z2ggZm9yIG1vc3Qgc291bmQgXHJcbiAgICAgICAgLy9lZmZlY3RzLiBPdmVycmlkZSB0aGlzIGluIHRoZSBgc291bmRFZmZlY3RgIHBhcmFtZXRlcnMgaWYgeW91XHJcbiAgICAgICAgLy9uZWVkIGEgbG9uZ2VyIHNvdW5kXHJcblxyXG4gICAgICAgIG9zY2lsbGF0b3Iuc3RvcCh0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIDIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmYWRlSW46IGZ1bmN0aW9uICh2b2x1bWUpXHJcbiAgICB7XHJcbiAgICAgICAgdm9sdW1lLmdhaW4udmFsdWUgPSAwO1xyXG5cclxuICAgICAgICB2b2x1bWUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCk7XHJcblxyXG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMudm9sdW1lVmFsdWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2spO1xyXG4gICAgfSxcclxuXHJcbiAgICBmYWRlT3V0OiBmdW5jdGlvbiAodm9sdW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMudm9sdW1lVmFsdWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2spO1xyXG5cclxuICAgICAgICB2b2x1bWUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrICsgdGhpcy5kZWNheSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFJldmVyYjogZnVuY3Rpb24gKHZvbHVtZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgY29udm9sdmVyID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQ29udm9sdmVyKCk7XHJcblxyXG4gICAgICAgIGNvbnZvbHZlci5idWZmZXIgPSB0aGlzLmltcHVsc2VSZXNwb25zZSh0aGlzLnJldmVyYkR1cmF0aW9uLCB0aGlzLnJldmVyYkRlY2F5LCB0aGlzLnJldmVyYlJldmVyc2UsIHRoaXMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICAgICAgdm9sdW1lLmNvbm5lY3QoY29udm9sdmVyKTtcclxuXHJcbiAgICAgICAgY29udm9sdmVyLmNvbm5lY3QodGhpcy5wYW4pO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRFY2hvOiBmdW5jdGlvbiAodm9sdW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmZWVkYmFjayA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVEZWxheSgpO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcclxuXHJcbiAgICAgICAgLy8gIFNldCB0aGUgbm9kZSB2YWx1ZXNcclxuXHJcbiAgICAgICAgZmVlZGJhY2suZ2Fpbi52YWx1ZSA9IHRoaXMuZWNob0ZlZWRiYWNrO1xyXG4gICAgICAgIGRlbGF5LmRlbGF5VGltZS52YWx1ZSA9IHRoaXMuZWNob0RlbGF5O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lY2hvRmlsdGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmlsdGVyLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuZWNob0ZpbHRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBDcmVhdGUgdGhlIGRlbGF5IGZlZWRiYWNrIGxvb3AgKHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nKVxyXG5cclxuICAgICAgICBkZWxheS5jb25uZWN0KGZlZWRiYWNrKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWNob0ZpbHRlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZlZWRiYWNrLmNvbm5lY3QoZmlsdGVyKTtcclxuICAgICAgICAgICAgZmlsdGVyLmNvbm5lY3QoZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmZWVkYmFjay5jb25uZWN0KGRlbGF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBDb25uZWN0IHRoZSBkZWxheSBub2RlIHRvIHRoZSBvc2NpbGxhdG9yIHZvbHVtZSBub2RlXHJcblxyXG4gICAgICAgIHZvbHVtZS5jb25uZWN0KGRlbGF5KTtcclxuXHJcbiAgICAgICAgLy8gIENvbm5lY3QgdGhlIGRlbGF5IG5vZGUgdG8gdGhlIG1haW4gc291bmQgY2hhaW5zIHBhbiBub2RlLFxyXG4gICAgICAgIC8vICBzbyB0aGF0IHRoZSBlY2hvIGVmZmVjdCBpcyBkaXJlY3RlZCB0byB0aGUgY29ycmVjdCBzcGVha2VyXHJcblxyXG4gICAgICAgIGRlbGF5LmNvbm5lY3QodGhpcy5wYW4pO1xyXG4gICAgfSxcclxuXHJcbiAgICBwaXRjaEJlbmQ6IGZ1bmN0aW9uIChvc2NpbGxhdG9yKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmcmVxdWVuY3kgPSBvc2NpbGxhdG9yLmZyZXF1ZW5jeS52YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnJldmVyc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSWYgcmV2ZXJzZSBpcyBmYWxzZSwgbWFrZSB0aGUgc291bmQgZHJvcCBpbiBwaXRjaFxyXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3ksIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0KTtcclxuICAgICAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZnJlcXVlbmN5IC0gdGhpcy5waXRjaEJlbmRBbW91bnQsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2sgKyB0aGlzLmRlY2F5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIElmIHJldmVyc2UgaXMgdHJ1ZSwgbWFrZSB0aGUgc291bmQgcmlzZSBpbiBwaXRjaFxyXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3ksIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0KTtcclxuICAgICAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZnJlcXVlbmN5ICsgdGhpcy5waXRjaEJlbmRBbW91bnQsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2sgKyB0aGlzLmRlY2F5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhZGREaXNzb25hbmNlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBDcmVhdGUgdHdvIG1vcmUgb3NjaWxsYXRvcnMgYW5kIGdhaW4gbm9kZXNcclxuXHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG5cclxuICAgICAgICB2YXIgZDEgPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xyXG4gICAgICAgIHZhciBkMiA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcbiAgICAgICAgdmFyIGQxVm9sdW1lID0gY3R4LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB2YXIgZDJWb2x1bWUgPSBjdHguY3JlYXRlR2FpbigpO1xyXG5cclxuICAgICAgICAvLyAgU2V0IHRoZSB2b2x1bWUgdG8gdGhlIGB2b2x1bWVWYWx1ZWBcclxuICAgICAgICBkMVZvbHVtZS5nYWluLnZhbHVlID0gdGhpcy52b2x1bWVWYWx1ZTtcclxuICAgICAgICBkMlZvbHVtZS5nYWluLnZhbHVlID0gdGhpcy52b2x1bWVWYWx1ZTtcclxuXHJcbiAgICAgICAgLy8gIENvbm5lY3QgdGhlIG9zY2lsbGF0b3JzIHRvIHRoZSBnYWluIGFuZCBkZXN0aW5hdGlvbiBub2Rlc1xyXG4gICAgICAgIGQxLmNvbm5lY3QoZDFWb2x1bWUpO1xyXG4gICAgICAgIGQyLmNvbm5lY3QoZDJWb2x1bWUpO1xyXG5cclxuICAgICAgICBkMVZvbHVtZS5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgZDJWb2x1bWUuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xyXG5cclxuICAgICAgICAvLyAgU2V0IHRoZSB3YXZlZm9ybSB0byBcInNhd3Rvb3RoXCIgZm9yIGEgaGFyc2ggZWZmZWN0XHJcbiAgICAgICAgZDEudHlwZSA9ICdzYXd0b290aCc7XHJcbiAgICAgICAgZDIudHlwZSA9ICdzYXd0b290aCc7XHJcblxyXG4gICAgICAgIC8vICBNYWtlIHRoZSB0d28gb3NjaWxsYXRvcnMgcGxheSBhdCBmcmVxdWVuY2llcyBhYm92ZSBhbmQgYmVsb3cgdGhlIG1haW4gc291bmQncyBmcmVxdWVuY3kuXHJcbiAgICAgICAgLy8gIFVzZSB3aGF0ZXZlciB2YWx1ZSB3YXMgc3VwcGxpZWQgYnkgdGhlIGBkaXNzb25hbmNlYCBhcmd1bWVudFxyXG4gICAgICAgIGQxLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuZnJlcXVlbmN5VmFsdWUgKyB0aGlzLmRpc3NvbmFuY2U7XHJcbiAgICAgICAgZDIuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5mcmVxdWVuY3lWYWx1ZSAtIHRoaXMuZGlzc29uYW5jZTtcclxuXHJcbiAgICAgICAgLy8gIEZhZGUgaW4gLyBvdXQsIHBpdGNoIGJlbmQgYW5kIHBsYXkgdGhlIG9zY2lsbGF0b3JzIHRvIG1hdGNoIHRoZSBtYWluIHNvdW5kXHJcbiAgICAgICAgaWYgKHRoaXMuYXR0YWNrID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmFkZUluKGQxVm9sdW1lKTtcclxuICAgICAgICAgICAgdGhpcy5mYWRlSW4oZDJWb2x1bWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGVjYXkgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5mYWRlT3V0KGQxVm9sdW1lKTtcclxuICAgICAgICAgICAgdGhpcy5mYWRlT3V0KGQyVm9sdW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBpdGNoQmVuZEFtb3VudCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBpdGNoQmVuZChkMSk7XHJcbiAgICAgICAgICAgIHRoaXMucGl0Y2hCZW5kKGQyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVjaG8pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVjaG8oZDFWb2x1bWUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVjaG8oZDJWb2x1bWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucmV2ZXJiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRSZXZlcmIoZDFWb2x1bWUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFJldmVyYihkMlZvbHVtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBsYXkoZDEpO1xyXG4gICAgICAgIHRoaXMucGxheShkMik7XHJcbiAgICB9LFxyXG5cclxuICAgIGltcHVsc2VSZXNwb25zZTogZnVuY3Rpb24gKGR1cmF0aW9uLCBkZWNheSwgcmV2ZXJzZSlcclxuICAgIHtcclxuICAgICAgICAvLyAgVGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlICogZHVyYXRpb247XHJcblxyXG4gICAgICAgIC8vICBDcmVhdGUgYW4gYXVkaW8gYnVmZmVyIChhbiBlbXB0eSBzb3VuZCBjb250YWluZXIpIHRvIHN0b3JlIHRoZSByZXZlcmIgZWZmZWN0LlxyXG4gICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDIsIGxlbmd0aCwgdGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XHJcblxyXG4gICAgICAgIC8vICBVc2UgYGdldENoYW5uZWxEYXRhYCB0byBpbml0aWFsaXplIGVtcHR5IGFycmF5cyB0byBzdG9yZSBzb3VuZCBkYXRhIGZvciB0aGUgbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHMuXHJcbiAgICAgICAgdmFyIGxlZnQgPSBpbXB1bHNlLmdldENoYW5uZWxEYXRhKDApO1xyXG4gICAgICAgIHZhciByaWdodCA9IGltcHVsc2UuZ2V0Q2hhbm5lbERhdGEoMSk7XHJcblxyXG4gICAgICAgIC8vICBMb29wIHRocm91Z2ggZWFjaCBzYW1wbGUtZnJhbWUgYW5kIGZpbGwgdGhlIGNoYW5uZWwgZGF0YSB3aXRoIHJhbmRvbSBub2lzZS5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEFwcGx5IHRoZSByZXZlcnNlIGVmZmVjdCwgaWYgYHJldmVyc2VgIGlzIGB0cnVlYC5cclxuICAgICAgICAgICAgdmFyIG4gPSAocmV2ZXJzZSkgPyBsZW5ndGggLSBpIDogaTtcclxuXHJcbiAgICAgICAgICAgIC8vICBGaWxsIHRoZSBsZWZ0IGFuZCByaWdodCBjaGFubmVscyB3aXRoIHJhbmRvbSB3aGl0ZSBub2lzZSB3aGljaCBkZWNheXMgZXhwb25lbnRpYWxseS5cclxuICAgICAgICAgICAgbGVmdFtpXSA9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogTWF0aC5wb3coMSAtIG4gLyBsZW5ndGgsIGRlY2F5KTtcclxuICAgICAgICAgICAgcmlnaHRbaV0gPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIE1hdGgucG93KDEgLSBuIC8gbGVuZ3RoLCBkZWNheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgUmV0dXJuIHRoZSBgaW1wdWxzZWAuXHJcbiAgICAgICAgcmV0dXJuIGltcHVsc2U7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGWDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc291bmQvZHluYW1pYy9GWC5qc1xuLy8gbW9kdWxlIGlkID0gNTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NvdW5kL2R5bmFtaWMvRlguanMiLCIvLyAgUGhhc2VyLlNvdW5kLkR5bmFtaWNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEZYOiByZXF1aXJlKCcuL0ZYJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NvdW5kL2R5bmFtaWMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zb3VuZC9keW5hbWljL2luZGV4LmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIE5PT1AgPSByZXF1aXJlKCcuLi91dGlscy9OT09QJyk7XHJcbnZhciBTdGF0ZSA9IHJlcXVpcmUoJy4vU3RhdGUnKTtcclxudmFyIFN5c3RlbXMgPSByZXF1aXJlKCcuL1N5c3RlbXMnKTtcclxudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldE9iamVjdFZhbHVlJyk7XHJcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyJyk7XHJcbnZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9nZW9tL3JlY3RhbmdsZS9SZWN0YW5nbGUnKTtcclxudmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzUG9vbCcpO1xyXG52YXIgQ2FudmFzSW50ZXJwb2xhdGlvbiA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNJbnRlcnBvbGF0aW9uJyk7XHJcbnZhciBHZXRDb250ZXh0ID0gcmVxdWlyZSgnLi4vY2FudmFzL0dldENvbnRleHQnKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBTdGF0ZSBNYW5hZ2VyIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nLCBzZXR0aW5nIHVwIGFuZCBzd2l0Y2hpbmcgZ2FtZSBzdGF0ZXMuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLkdsb2JhbFN0YXRlTWFuYWdlclxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cclxuKi9cclxudmFyIEdsb2JhbFN0YXRlTWFuYWdlciA9IGZ1bmN0aW9uIChnYW1lLCBzdGF0ZUNvbmZpZylcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICAvLyAgRXZlcnl0aGluZyBrZXB0IGluIGhlcmVcclxuICAgIHRoaXMua2V5cyA9IHt9O1xyXG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcclxuXHJcbiAgICAvLyAgT25seSBhY3RpdmUgc3RhdGVzIGFyZSBrZXB0IGluIGhlcmVcclxuICAgIHRoaXMuYWN0aXZlID0gW107XHJcblxyXG4gICAgdGhpcy5fcGVuZGluZyA9IFtdO1xyXG5cclxuICAgIGlmIChzdGF0ZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZUNvbmZpZykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlQ29uZmlnLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgVGhlIGkgPT09IDAgcGFydCBqdXN0IHN0YXJ0cyB0aGUgZmlyc3QgU3RhdGUgZ2l2ZW5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnZGVmYXVsdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlQ29uZmlnW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9TdGFydDogKGkgPT09IDApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IDAsXHJcbiAgICAgICAgICAgICAgICBrZXk6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZUNvbmZpZyxcclxuICAgICAgICAgICAgICAgIGF1dG9TdGFydDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkdsb2JhbFN0YXRlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHbG9iYWxTdGF0ZU1hbmFnZXI7XHJcblxyXG5HbG9iYWxTdGF0ZU1hbmFnZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgQm9vdCBoYW5kbGVyIGlzIGNhbGxlZCBieSBQaGFzZXIuR2FtZSB3aGVuIGl0IGZpcnN0IHN0YXJ0cyB1cC5cclxuICAgICogVGhlIHJlbmRlcmVyIGlzIGF2YWlsYWJsZSBieSBub3cuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdsb2JhbFN0YXRlTWFuYWdlciNib290XHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgYm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BlbmRpbmcubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9wZW5kaW5nW2ldO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGQoZW50cnkua2V5LCBlbnRyeS5zdGF0ZSwgZW50cnkuYXV0b1N0YXJ0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBDbGVhciB0aGUgcGVuZGluZyBsaXN0XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZyA9IFtdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgcHJpdmF0ZVxyXG4gICAgZ2V0S2V5OiBmdW5jdGlvbiAoa2V5LCBzdGF0ZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAoIWtleSkgeyBrZXkgPSAnZGVmYXVsdCc7IH1cclxuXHJcbiAgICAgICAgaWYgKHN0YXRlQ29uZmlnIGluc3RhbmNlb2YgU3RhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXkgPSBzdGF0ZUNvbmZpZy5zZXR0aW5ncy5rZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGF0ZUNvbmZpZyA9PT0gJ29iamVjdCcgJiYgc3RhdGVDb25maWcuaGFzT3duUHJvcGVydHkoJ2tleScpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5ID0gc3RhdGVDb25maWcua2V5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEJ5IHRoaXMgcG9pbnQgaXQncyBlaXRoZXIgJ2RlZmF1bHQnIG9yIGV4dHJhY3RlZCBmcm9tIHRoZSBTdGF0ZVxyXG5cclxuICAgICAgICBpZiAodGhpcy5rZXlzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgYSBTdGF0ZSB3aXRoIGR1cGxpY2F0ZSBrZXk6ICcgKyBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFkZHMgYSBuZXcgU3RhdGUgaW50byB0aGUgR2xvYmFsU3RhdGVNYW5hZ2VyLiBZb3UgbXVzdCBnaXZlIGVhY2ggU3RhdGUgYSB1bmlxdWUga2V5IGJ5IHdoaWNoIHlvdSdsbCBpZGVudGlmeSBpdC5cclxuICAgICogVGhlIFN0YXRlIGNhbiBiZSBlaXRoZXIgYSBQaGFzZXIuU3RhdGUgb2JqZWN0IChvciBhbiBvYmplY3QgdGhhdCBleHRlbmRzIGl0KSwgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCBvciBhIGZ1bmN0aW9uLlxyXG4gICAgKiBJZiBhIGZ1bmN0aW9uIGlzIGdpdmVuIGEgbmV3IHN0YXRlIG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQgYnkgY2FsbGluZyBpdC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR2xvYmFsU3RhdGVNYW5hZ2VyI2FkZFxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gQSB1bmlxdWUga2V5IHlvdSB1c2UgdG8gcmVmZXJlbmNlIHRoaXMgc3RhdGUsIGkuZS4gXCJNYWluTWVudVwiLCBcIkxldmVsMVwiLlxyXG4gICAgKiBAcGFyYW0ge1BoYXNlci5TdGF0ZXxvYmplY3R8ZnVuY3Rpb259IHN0YXRlICAtIFRoZSBzdGF0ZSB5b3Ugd2FudCB0byBzd2l0Y2ggdG8uXHJcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9TdGFydD1mYWxzZV0gIC0gSWYgdHJ1ZSB0aGUgU3RhdGUgd2lsbCBiZSBzdGFydGVkIGltbWVkaWF0ZWx5IGFmdGVyIGFkZGluZyBpdC5cclxuICAgICovXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChrZXksIHN0YXRlQ29uZmlnLCBhdXRvU3RhcnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGF1dG9TdGFydCA9PT0gdW5kZWZpbmVkKSB7IGF1dG9TdGFydCA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIC8vICBpZiBub3QgYm9vdGVkLCB0aGVuIHB1dCBzdGF0ZSBpbnRvIGEgaG9sZGluZyBwYXR0ZXJuXHJcbiAgICAgICAgaWYgKCF0aGlzLmdhbWUuaXNCb290ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuX3BlbmRpbmcubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVDb25maWcsXHJcbiAgICAgICAgICAgICAgICBhdXRvU3RhcnQ6IGF1dG9TdGFydFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIgbm90IHlldCBib290ZWQsIGFkZGluZyB0byBsaXN0JywgdGhpcy5fcGVuZGluZy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5LCBzdGF0ZUNvbmZpZyk7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIuYWRkJywga2V5LCBzdGF0ZUNvbmZpZywgYXV0b1N0YXJ0KTtcclxuXHJcbiAgICAgICAgdmFyIG5ld1N0YXRlO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGVDb25maWcgaW5zdGFuY2VvZiBTdGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIuYWRkIGZyb20gaW5zdGFuY2U6Jywga2V5KTtcclxuICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmNyZWF0ZVN0YXRlRnJvbUluc3RhbmNlKGtleSwgc3RhdGVDb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhdGVDb25maWcgPT09ICdvYmplY3QnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0dsb2JhbFN0YXRlTWFuYWdlci5hZGQgZnJvbSBvYmplY3Q6Jywga2V5KTtcclxuXHJcbiAgICAgICAgICAgIHN0YXRlQ29uZmlnLmtleSA9IGtleTtcclxuXHJcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5jcmVhdGVTdGF0ZUZyb21PYmplY3Qoa2V5LCBzdGF0ZUNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGF0ZUNvbmZpZyA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIuYWRkIGZyb20gZnVuY3Rpb246Jywga2V5KTtcclxuXHJcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5jcmVhdGVTdGF0ZUZyb21GdW5jdGlvbihrZXksIHN0YXRlQ29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMua2V5c1trZXldID0gbmV3U3RhdGU7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2gobmV3U3RhdGUpO1xyXG5cclxuICAgICAgICBpZiAoYXV0b1N0YXJ0IHx8IG5ld1N0YXRlLnNldHRpbmdzLmFjdGl2ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdhbWUuaXNCb290ZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0LnB1c2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVTdGF0ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGtleSwgbmV3U3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgbmV3U3RhdGUuc2V0dGluZ3Mua2V5ID0ga2V5O1xyXG5cclxuICAgICAgICBuZXdTdGF0ZS5zeXMuaW5pdCh0aGlzLmdhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZVN0YXRlRGlzcGxheShuZXdTdGF0ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlU3RhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoa2V5LCBzdGF0ZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB2YXIgbmV3U3RhdGUgPSBuZXcgU3RhdGUoc3RhdGVDb25maWcpO1xyXG5cclxuICAgICAgICBuZXdTdGF0ZS5zeXMuaW5pdCh0aGlzLmdhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZVN0YXRlRGlzcGxheShuZXdTdGF0ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNldHVwQ2FsbGJhY2tzKG5ld1N0YXRlLCBzdGF0ZUNvbmZpZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVN0YXRlRnJvbUZ1bmN0aW9uOiBmdW5jdGlvbiAoa2V5LCBzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbmV3U3RhdGUgPSBuZXcgc3RhdGUoKTtcclxuXHJcbiAgICAgICAgaWYgKG5ld1N0YXRlIGluc3RhbmNlb2YgU3RhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdGF0ZUZyb21JbnN0YW5jZShrZXksIG5ld1N0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3U3RhdGUuc3lzID0gbmV3IFN5c3RlbXMobmV3U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgbmV3U3RhdGUuc3lzLmluaXQodGhpcy5nYW1lKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3RhdGVEaXNwbGF5KG5ld1N0YXRlKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBEZWZhdWx0IHJlcXVpcmVkIGZ1bmN0aW9uc1xyXG5cclxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5pbml0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5pbml0ID0gTk9PUDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5wcmVsb2FkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5wcmVsb2FkID0gTk9PUDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5jcmVhdGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLmNyZWF0ZSA9IE5PT1A7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghbmV3U3RhdGUuc2h1dGRvd24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLnNodXRkb3duID0gTk9PUDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS51cGRhdGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLnVwZGF0ZSA9IE5PT1A7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghbmV3U3RhdGUucmVuZGVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5yZW5kZXIgPSBOT09QO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXR1cENhbGxiYWNrczogZnVuY3Rpb24gKHN0YXRlLCBzdGF0ZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAoc3RhdGVDb25maWcgPT09IHVuZGVmaW5lZCkgeyBzdGF0ZUNvbmZpZyA9IHN0YXRlOyB9XHJcblxyXG4gICAgICAgIC8vICBFeHRyYWN0IGNhbGxiYWNrcyBvciBzZXQgTk9PUFxyXG5cclxuICAgICAgICBzdGF0ZS5pbml0ID0gR2V0T2JqZWN0VmFsdWUoc3RhdGVDb25maWcsICdpbml0JywgTk9PUCk7XHJcbiAgICAgICAgc3RhdGUucHJlbG9hZCA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAncHJlbG9hZCcsIE5PT1ApO1xyXG4gICAgICAgIHN0YXRlLmNyZWF0ZSA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAnY3JlYXRlJywgTk9PUCk7XHJcbiAgICAgICAgc3RhdGUuc2h1dGRvd24gPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ3NodXRkb3duJywgTk9PUCk7XHJcblxyXG4gICAgICAgIC8vICBHYW1lIExvb3AgbGV2ZWwgY2FsbGJhY2tzXHJcblxyXG4gICAgICAgIHN0YXRlLnVwZGF0ZSA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAndXBkYXRlJywgTk9PUCk7XHJcbiAgICAgICAgc3RhdGUucmVuZGVyID0gR2V0T2JqZWN0VmFsdWUoc3RhdGVDb25maWcsICdyZW5kZXInLCBOT09QKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVTdGF0ZURpc3BsYXk6IGZ1bmN0aW9uIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY3JlYXRlU3RhdGVEaXNwbGF5Jywgc3RhdGUuc2V0dGluZ3Mua2V5KTtcclxuXHJcbiAgICAgICAgdmFyIHNldHRpbmdzID0gc3RhdGUuc3lzLnNldHRpbmdzO1xyXG5cclxuICAgICAgICAvLyB2YXIgeCA9IHNldHRpbmdzLng7XHJcbiAgICAgICAgLy8gdmFyIHkgPSBzZXR0aW5ncy55O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHNldHRpbmdzLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBzZXR0aW5ncy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmdhbWUuY29uZmlnO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULkNBTlZBUylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXJUb1RleHR1cmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW5kZXJUb1RleHR1cmUnLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5jYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZShzdGF0ZSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMuY29udGV4dCA9IEdldENvbnRleHQoc3RhdGUuc3lzLmNhbnZhcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFBpeGVsIEFydCBtb2RlP1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5waXhlbEFydClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBDYW52YXNJbnRlcnBvbGF0aW9uLnNldENyaXNwKHN0YXRlLnN5cy5jYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3VzaW5nIGdhbWUgY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMubWFzayA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMuY2FudmFzID0gdGhpcy5nYW1lLmNhbnZhcztcclxuICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5jb250ZXh0ID0gdGhpcy5nYW1lLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULldFQkdMKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gc3RhdGUuc3lzLmZibyA9IHRoaXMuZ2FtZS5yZW5kZXJlci5jcmVhdGVGQk8oc3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c1trZXldO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTdGF0ZUluZGV4OiBmdW5jdGlvbiAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzLmluZGV4T2Yoc3RhdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBY3RpdmVTdGF0ZUluZGV4OiBmdW5jdGlvbiAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IHN0YXRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuYWN0aXZlW2ldLmluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoa2V5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChzdGF0ZSAmJiBzdGF0ZS5zZXR0aW5ncy5hY3RpdmUgJiYgdGhpcy5hY3RpdmUuaW5kZXhPZihzdGF0ZSkgIT09IC0xKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChrZXksIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkgeyBkYXRhID0ge307IH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3N0YXJ0OicsIGtleSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5kaXIoZGF0YSk7XHJcblxyXG4gICAgICAgIC8vICBpZiBub3QgYm9vdGVkLCB0aGVuIHB1dCBzdGF0ZSBpbnRvIGEgaG9sZGluZyBwYXR0ZXJuXHJcbiAgICAgICAgaWYgKCF0aGlzLmdhbWUuaXNCb290ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnR2xvYmFsU3RhdGVNYW5hZ2VyIG5vdCB5ZXQgYm9vdGVkLCBzZXR0aW5nIGF1dG9TdGFydCBvbiBwZW5kaW5nIGxpc3QnKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGVuZGluZy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fcGVuZGluZ1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkua2V5ID09PSBrZXkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuYXV0b1N0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZShrZXkpO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQWxyZWFkeSBzdGFydGVkPyBOb3RoaW5nIG1vcmUgdG8gZG8gaGVyZSAuLi5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoa2V5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5zZXR0aW5ncy5hY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuc2V0dGluZ3MuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gc3RhdGUuc3lzLmxvYWQ7XHJcblxyXG4gICAgICAgICAgICAvLyAgRmlsZXMgcGF5bG9hZD9cclxuICAgICAgICAgICAgaWYgKGxvYWRlciAmJiBBcnJheS5pc0FycmF5KHN0YXRlLnN5cy5zZXR0aW5ncy5maWxlcykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxvYWRlci5yZXNldCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsb2FkZXIubG9hZEFycmF5KHN0YXRlLnN5cy5zZXR0aW5ncy5maWxlcykpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyLmV2ZW50cy5vbmNlKCdMT0FERVJfQ09NUExFVEVfRVZFTlQnLCB0aGlzLnBheWxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib290U3RhdGUoc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib290U3RhdGUoc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwYXlsb2FkQ29tcGxldGU6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBldmVudC5sb2FkZXIuc3RhdGU7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXlsb2FkQ29tcGxldGUnLCBzdGF0ZS5zeXMuc2V0dGluZ3Mua2V5KTtcclxuXHJcbiAgICAgICAgdGhpcy5ib290U3RhdGUoc3RhdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBib290U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnYm9vdFN0YXRlJywgc3RhdGUuc3lzLnNldHRpbmdzLmtleSk7XHJcblxyXG4gICAgICAgIGlmIChzdGF0ZS5pbml0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3RhdGUuaW5pdC5jYWxsKHN0YXRlLCBzdGF0ZS5zeXMuc2V0dGluZ3MuZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbG9hZGVyID0gc3RhdGUuc3lzLmxvYWQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGxvYWRlci5yZXNldCgpO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGUucHJlbG9hZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0YXRlLnByZWxvYWQodGhpcy5nYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBJcyB0aGUgbG9hZGVyIGVtcHR5P1xyXG4gICAgICAgICAgICBpZiAobG9hZGVyLmxpc3Quc2l6ZSA9PT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFN0YXJ0IHRoZSBsb2FkZXIgZ29pbmcgYXMgd2UgaGF2ZSBzb21ldGhpbmcgaW4gdGhlIHF1ZXVlXHJcblxyXG4gICAgICAgICAgICAgICAgbG9hZGVyLmV2ZW50cy5vbmNlKCdMT0FERVJfQ09NUExFVEVfRVZFTlQnLCB0aGlzLmxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsb2FkZXIuc3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgTm8gcHJlbG9hZD8gVGhlbiB0aGVyZSB3YXMgbm90aGluZyB0byBsb2FkIGVpdGhlclxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZShzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkQ29tcGxldGU6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBldmVudC5sb2FkZXIuc3RhdGU7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdsb2FkQ29tcGxldGUnLCBzdGF0ZS5zeXMuc2V0dGluZ3Mua2V5KTtcclxuXHJcbiAgICAgICAgdGhpcy5jcmVhdGUoc3RhdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY3JlYXRlJywgc3RhdGUuc3lzLnNldHRpbmdzLmtleSk7XHJcblxyXG4gICAgICAgIC8vICBJbnNlcnQgYXQgdGhlIGNvcnJlY3QgaW5kZXgsIG9yIGl0IGp1c3QgYWxsIGdvZXMgd3JvbmcgOilcclxuXHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmdldFN0YXRlSW5kZXgoc3RhdGUpO1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY3JlYXRlLmluZGV4Jywgc3RhdGUuc3lzLnNldHRpbmdzLmtleSwgaSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWN0aXZlLnB1c2goeyBpbmRleDogaSwgc3RhdGU6IHN0YXRlIH0pO1xyXG5cclxuICAgICAgICAvLyAgU29ydCB0aGUgJ2FjdGl2ZScgYXJyYXkgYmFzZWQgb24gdGhlIGluZGV4IHByb3BlcnR5XHJcbiAgICAgICAgdGhpcy5hY3RpdmUuc29ydCh0aGlzLnNvcnRTdGF0ZXMpO1xyXG5cclxuICAgICAgICBzdGF0ZS5zeXMudXBkYXRlcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXRlLmNyZWF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0YXRlLmNyZWF0ZShzdGF0ZS5zeXMuc2V0dGluZ3MuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwYXVzZTogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEFjdGl2ZVN0YXRlSW5kZXgodGhpcy5nZXRTdGF0ZShrZXkpKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGtleSk7XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5zZXR0aW5ncy5hY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zb3J0KHRoaXMuc29ydFN0YXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzb3J0U3RhdGVzOiBmdW5jdGlvbiAoc3RhdGVBLCBzdGF0ZUIpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NvcnRTdGF0ZXMnLCBzdGF0ZUEuc3RhdGUuc3lzLnNldHRpbmdzLmtleSwgc3RhdGVBLmluZGV4LCBzdGF0ZUIuc3RhdGUuc3lzLnNldHRpbmdzLmtleSwgc3RhdGVCLmluZGV4KTtcclxuXHJcbiAgICAgICAgLy8gIFNvcnQgZGVzY2VuZGluZ1xyXG4gICAgICAgIGlmIChzdGF0ZUEuaW5kZXggPCBzdGF0ZUIuaW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXRlQS5pbmRleCA+IHN0YXRlQi5pbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHbG9iYWxTdGF0ZU1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL0dsb2JhbFN0YXRlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL0dsb2JhbFN0YXRlTWFuYWdlci5qcyIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIFNjYWxlTW9kZXMgPSByZXF1aXJlKCcuLi9yZW5kZXJlci9TY2FsZU1vZGVzJyk7XHJcbnZhciBHZXRPYmplY3RWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL29iamVjdC9HZXRPYmplY3RWYWx1ZScpO1xyXG5cclxudmFyIFNldHRpbmdzID0ge1xyXG5cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25maWcgPSB7IGtleTogY29uZmlnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFBhc3MgdGhlICdoYXNPd25Qcm9wZXJ0eScgY2hlY2tzXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgICAgIHN0YXR1czogQ09OU1QuUEVORElORyxcclxuXHJcbiAgICAgICAgICAgIG9wOiBDT05TVC5CT09ULFxyXG5cclxuICAgICAgICAgICAga2V5OiBHZXRPYmplY3RWYWx1ZShjb25maWcsICdrZXknLCAnJyksXHJcbiAgICAgICAgICAgIGFjdGl2ZTogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnYWN0aXZlJywgZmFsc2UpLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBHZXRPYmplY3RWYWx1ZShjb25maWcsICd2aXNpYmxlJywgdHJ1ZSksXHJcblxyXG4gICAgICAgICAgICAvLyAgTG9hZGVyIHBheWxvYWQgYXJyYXlcclxuXHJcbiAgICAgICAgICAgIGRhdGE6IHt9LFxyXG5cclxuICAgICAgICAgICAgZmlsZXM6IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2ZpbGVzJywgZmFsc2UpLFxyXG5cclxuICAgICAgICAgICAgLy8gIC0xIG1lYW5zIHRoZSBTdGF0ZSBNYW5hZ2VyIHdpbGwgc2V0IGl0IHRvIGJlIHRoZSBHYW1lIGRpbWVuc2lvbnNcclxuXHJcbiAgICAgICAgICAgIHg6IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3gnLCAwKSxcclxuICAgICAgICAgICAgeTogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAneScsIDApLFxyXG4gICAgICAgICAgICByb3RhdGlvbjogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncm90YXRpb24nLCAwKSxcclxuICAgICAgICAgICAgd2lkdGg6IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3dpZHRoJywgLTEpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2hlaWdodCcsIC0xKSxcclxuXHJcbiAgICAgICAgICAgIC8vICBTdGF0ZSBSZW5kZXIgU2V0dGluZ3MgKGFwcGxpZXMgb25seSB0byB0aGlzIFN0YXRlKVxyXG5cclxuICAgICAgICAgICAgc2NhbGVNb2RlOiBHZXRPYmplY3RWYWx1ZShjb25maWcsICdzY2FsZU1vZGUnLCBTY2FsZU1vZGVzLkRFRkFVTFQpLFxyXG4gICAgICAgICAgICByb3VuZFBpeGVsczogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncm91bmRQaXhlbHMnLCBmYWxzZSksXHJcblxyXG4gICAgICAgICAgICBkaXJ0eVJlbmRlcjogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZGlydHlSZW5kZXInLCBmYWxzZSksXHJcbiAgICAgICAgICAgIHJlbmRlclRvVGV4dHVyZTogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmVuZGVyVG9UZXh0dXJlJywgZmFsc2UpLFxyXG5cclxuICAgICAgICAgICAgLy8gIFRoZSBmb2xsb3dpbmcgb25seSBhcHBseSBpZiByZW5kZXJUb1RleHR1cmUgaXMgdHJ1ZVxyXG5cclxuICAgICAgICAgICAgYXV0b1Jlc2l6ZTogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnYXV0b1Jlc2l6ZScsIGZhbHNlKSxcclxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3RyYW5zcGFyZW50JywgZmFsc2UpLFxyXG4gICAgICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2xlYXJCZWZvcmVSZW5kZXInLCB0cnVlKSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBHZXRPYmplY3RWYWx1ZShjb25maWcsICdiYWNrZ3JvdW5kQ29sb3InLCBmYWxzZSlcclxuXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGNvbmZpZywgZ2FtZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAoY29uZmlnLndpZHRoID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbmZpZy53aWR0aCA9IGdhbWVDb25maWcud2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmhlaWdodCA9PT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25maWcuaGVpZ2h0ID0gZ2FtZUNvbmZpZy5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0dGluZ3M7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1NldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc3RhdGUvU2V0dGluZ3MuanMiLCJcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgUEVORElORzogMCxcclxuICAgIElOU1RBTExFRDogMSxcclxuXHJcbiAgICBCT09UOiAwLFxyXG4gICAgSU5JVDogMSxcclxuICAgIFBSRUxPQUQ6IDIsXHJcbiAgICBDUkVBVEU6IDMsXHJcbiAgICBVUERBVEU6IDQsXHJcbiAgICBSRU5ERVI6IDUsXHJcbiAgICBTSFVURE9XTjogNlxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDUwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FtZXJhID0gcmVxdWlyZSgnLi4vLi4vY2FtZXJhL0NhbWVyYScpO1xyXG5cclxudmFyIENhbWVyYU1hbmFnZXIgPSBmdW5jdGlvbiAoc3RhdGUpXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICB0aGlzLmNhbWVyYXMgPSBbXTtcclxuICAgIHRoaXMuY2FtZXJhUG9vbCA9IFtdO1xyXG5cclxuICAgIHRoaXMubWFpbiA9IHRoaXMuYWRkKCk7XHJcbn07XHJcblxyXG5DYW1lcmFNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbWVyYU1hbmFnZXI7XHJcblxyXG5DYW1lcmFNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSAwOyB9XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSB0aGlzLnN0YXRlLnN5cy53aWR0aDsgfVxyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSB0aGlzLnN0YXRlLnN5cy5oZWlnaHQ7IH1cclxuXHJcbiAgICAgICAgdmFyIGNhbWVyYSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNhbWVyYVBvb2wubGVuZ3RoID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbWVyYSA9IHRoaXMuY2FtZXJhUG9vbC5wb3AoKTtcclxuICAgICAgICAgICAgY2FtZXJhLnNldFZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW1lcmEgPSBuZXcgQ2FtZXJhKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FtZXJhLnNldFN0YXRlKHRoaXMuc3RhdGUpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbWVyYXMucHVzaChjYW1lcmEpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FtZXJhO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRSZWZlcmVuY2U6IGZ1bmN0aW9uIChjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jYW1lcmFzLmluZGV4T2YoY2FtZXJhKTtcclxuICAgICAgICB2YXIgcG9vbEluZGV4ID0gdGhpcy5jYW1lcmFQb29sLmluZGV4T2YoY2FtZXJhKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCAmJiBwb29sSW5kZXggPj0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhcy5wdXNoKGNhbWVyYSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhUG9vbC5zbGljZShwb29sSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FtZXJhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjYW1lcmFJbmRleCA9IHRoaXMuY2FtZXJhcy5pbmRleE9mKGNhbWVyYSk7XHJcblxyXG4gICAgICAgIGlmIChjYW1lcmFJbmRleCA+PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFQb29sLnB1c2godGhpcy5jYW1lcmFzW2NhbWVyYUluZGV4XSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhcy5zcGxpY2UoY2FtZXJhSW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRBbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuY2FtZXJhcy5sZW5ndGggPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFQb29sLnB1c2godGhpcy5jYW1lcmFzLnBvcCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWFpbiA9IHRoaXMuYWRkKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5jYW1lcmFzLmxlbmd0aDsgaSA8IGw7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhc1tpXS51cGRhdGUodGltZXN0ZXApO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAocmVuZGVyZXIsIGNoaWxkcmVuLCBpbnRlcnBvbGF0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjYW1lcmFzID0gdGhpcy5jYW1lcmFzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FtZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2FtZXJhID0gY2FtZXJhc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGNhbWVyYS5wcmVSZW5kZXIoKTtcclxuXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLnN0YXRlLCBjaGlsZHJlbiwgaW50ZXJwb2xhdGlvbiwgY2FtZXJhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFpbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNhbWVyYXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYXNbaV0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY2FtZXJhUG9vbC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhUG9vbFtpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNhbWVyYXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNhbWVyYVBvb2wgPSBbXTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FtZXJhTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9DYW1lcmFNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc3RhdGUvc3lzdGVtcy9DYW1lcmFNYW5hZ2VyLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG4vKipcclxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgcXVpY2sgd2F5IHRvIGNyZWF0ZSBtYW55IGNvbW1vbiBnYW1lIG9iamVjdHMuIFRoZSBGYWN0b3J5IGlzIG93bmVkIGJ5IHRoZSBTdGF0ZS5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuR2FtZU9iamVjdC5GYWN0b3J5XHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxyXG4qL1xyXG52YXIgR2FtZU9iamVjdENyZWF0b3IgPSBmdW5jdGlvbiAoc3RhdGUpXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICBGYWN0b3J5Q29udGFpbmVyLmxvYWQodGhpcywgZmFsc2UpO1xyXG59O1xyXG5cclxuR2FtZU9iamVjdENyZWF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2FtZU9iamVjdENyZWF0b3I7XHJcblxyXG5HYW1lT2JqZWN0Q3JlYXRvci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZU9iamVjdENyZWF0b3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdENyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDUxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RDcmVhdG9yLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG4vKipcclxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgcXVpY2sgd2F5IHRvIGNyZWF0ZSBtYW55IGNvbW1vbiBnYW1lIG9iamVjdHMuIFRoZSBGYWN0b3J5IGlzIG93bmVkIGJ5IHRoZSBTdGF0ZS5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuR2FtZU9iamVjdC5GYWN0b3J5XHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxyXG4qL1xyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiAoc3RhdGUpXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICBGYWN0b3J5Q29udGFpbmVyLmxvYWQodGhpcywgdHJ1ZSk7XHJcbn07XHJcblxyXG5HYW1lT2JqZWN0RmFjdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHYW1lT2JqZWN0RmFjdG9yeTtcclxuXHJcbkdhbWVPYmplY3RGYWN0b3J5LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lT2JqZWN0RmFjdG9yeTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9HYW1lT2JqZWN0RmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdEZhY3RvcnkuanMiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvY29uc3QnKTtcclxudmFyIEJhc2VMb2FkZXIgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvQmFzZUxvYWRlcicpO1xyXG52YXIgTnVtYmVyQXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hcnJheS9OdW1iZXJBcnJheScpO1xyXG5cclxudmFyIEltYWdlRmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlJyk7XHJcbnZhciBKU09ORmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvSlNPTkZpbGUnKTtcclxudmFyIFhNTEZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL1hNTEZpbGUnKTtcclxudmFyIEJpbmFyeUZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUnKTtcclxudmFyIEdMU0xGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9HTFNMRmlsZScpO1xyXG52YXIgVGV4dEZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL1RleHRGaWxlJyk7XHJcbnZhciBBdGxhc0pTT05GaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9BdGxhc0pTT05GaWxlJyk7XHJcbnZhciBCaXRtYXBGb250RmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvQml0bWFwRm9udEZpbGUnKTtcclxudmFyIFNwcml0ZVNoZWV0ID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9TcHJpdGVTaGVldCcpO1xyXG5cclxudmFyIFBhcnNlWE1MQml0bWFwRm9udCA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvUGFyc2VYTUxCaXRtYXBGb250Jyk7XHJcblxyXG52YXIgTG9hZGVyID0gZnVuY3Rpb24gKHN0YXRlKVxyXG57XHJcbiAgICBCYXNlTG9hZGVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlN0YXRlfSBzdGF0ZSAtIFRoZSBTdGF0ZSB0aGF0IG93bnMgdGhpcyBGYWN0b3J5XHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICovXHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5fbXVsdGlsaXN0ID0ge307XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlTG9hZGVyLnByb3RvdHlwZSk7XHJcbkxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXI7XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmxvYWRBcnJheSA9IGZ1bmN0aW9uIChmaWxlcylcclxue1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsZXMpKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGUoZmlsZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKHRoaXMubGlzdC5zaXplID4gMCk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmZpbGUgPSBmdW5jdGlvbiAoZmlsZSlcclxue1xyXG4gICAgdmFyIGVudHJ5O1xyXG5cclxuICAgIHN3aXRjaCAoZmlsZS50eXBlKVxyXG4gICAge1xyXG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcclxuICAgICAgICBjYXNlICdqc29uJzpcclxuICAgICAgICBjYXNlICd4bWwnOlxyXG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6XHJcbiAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgY2FzZSAnZ2xzbCc6XHJcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpc1tmaWxlLnR5cGVdKGZpbGUua2V5LCBmaWxlLnVybCwgZmlsZS54aHJTZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlICdzcHJpdGVzaGVldCc6XHJcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5zcHJpdGVzaGVldChmaWxlLmtleSwgZmlsZS51cmwsIGZpbGUuY29uZmlnLCBmaWxlLnhoclNldHRpbmdzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgJ2F0bGFzJzpcclxuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmF0bGFzKGZpbGUua2V5LCBmaWxlLnRleHR1cmVVUkwsIGZpbGUuYXRsYXNVUkwsIGZpbGUudGV4dHVyZVhoclNldHRpbmdzLCBmaWxlLmF0bGFzWGhyU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAnYml0bWFwRm9udCc6XHJcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5iaXRtYXBGb250KGZpbGUua2V5LCBmaWxlLnRleHR1cmVVUkwsIGZpbGUueG1sVVJMLCBmaWxlLnRleHR1cmVYaHJTZXR0aW5ncywgZmlsZS54bWxYaHJTZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlICdtdWx0aWF0bGFzJzpcclxuICAgICAgICAgICAgZW50cnkgPSB0aGlzLm11bHRpYXRsYXMoZmlsZS5rZXksIGZpbGUudGV4dHVyZVVSTHMsIGZpbGUuYXRsYXNVUkxzLCBmaWxlLnRleHR1cmVYaHJTZXR0aW5ncywgZmlsZS5hdGxhc1hoclNldHRpbmdzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVudHJ5O1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBmaWxlID0gbmV3IEltYWdlRmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcclxufTtcclxuXHJcbkxvYWRlci5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBmaWxlID0gbmV3IEpTT05GaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS54bWwgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBYTUxGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS5iaW5hcnkgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBCaW5hcnlGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGZpbGUgPSBuZXcgVGV4dEZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmdsc2wgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBHTFNMRmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcclxufTtcclxuXHJcbi8vICBjb25maWcgY2FuIGluY2x1ZGU6IGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgbWFyZ2luLCBzcGFjaW5nXHJcbkxvYWRlci5wcm90b3R5cGUuc3ByaXRlc2hlZXQgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIGNvbmZpZywgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBmaWxlID0gbmV3IFNwcml0ZVNoZWV0KGtleSwgdXJsLCBjb25maWcsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmF0bGFzID0gZnVuY3Rpb24gKGtleSwgdGV4dHVyZVVSTCwgYXRsYXNVUkwsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcclxue1xyXG4gICAgLy8gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXM6ICd0ZXh0dXJlJyBhbmQgJ2RhdGEnXHJcbiAgICB2YXIgZmlsZXMgPSBuZXcgQXRsYXNKU09ORmlsZShrZXksIHRleHR1cmVVUkwsIGF0bGFzVVJMLCB0aGlzLnBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncyk7XHJcblxyXG4gICAgdGhpcy5hZGRGaWxlKGZpbGVzLnRleHR1cmUpO1xyXG4gICAgdGhpcy5hZGRGaWxlKGZpbGVzLmRhdGEpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS5iaXRtYXBGb250ID0gZnVuY3Rpb24gKGtleSwgdGV4dHVyZVVSTCwgeG1sVVJMLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIHhtbFhoclNldHRpbmdzKVxyXG57XHJcbiAgICAvLyAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczogJ3RleHR1cmUnIGFuZCAnZGF0YSdcclxuICAgIHZhciBmaWxlcyA9IG5ldyBCaXRtYXBGb250RmlsZShrZXksIHRleHR1cmVVUkwsIHhtbFVSTCwgdGhpcy5wYXRoLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIHhtbFhoclNldHRpbmdzKTtcclxuXHJcbiAgICB0aGlzLmFkZEZpbGUoZmlsZXMudGV4dHVyZSk7XHJcbiAgICB0aGlzLmFkZEZpbGUoZmlsZXMuZGF0YSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLm11bHRpYXRsYXMgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMcywgYXRsYXNVUkxzLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIGF0bGFzWGhyU2V0dGluZ3MpXHJcbntcclxuICAgIGlmICh0eXBlb2YgdGV4dHVyZVVSTHMgPT09ICdudW1iZXInKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0b3RhbCA9IHRleHR1cmVVUkxzO1xyXG5cclxuICAgICAgICB0ZXh0dXJlVVJMcyA9IE51bWJlckFycmF5KDAsIHRvdGFsLCBrZXkgKyAnLScsICcucG5nJyk7XHJcbiAgICAgICAgYXRsYXNVUkxzID0gTnVtYmVyQXJyYXkoMCwgdG90YWwsIGtleSArICctJywgJy5qc29uJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRleHR1cmVVUkxzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRleHR1cmVVUkxzID0gWyB0ZXh0dXJlVVJMcyBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGF0bGFzVVJMcykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhdGxhc1VSTHMgPSBbIGF0bGFzVVJMcyBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmlsZTtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBtdWx0aUtleTtcclxuXHJcbiAgICB0aGlzLl9tdWx0aWxpc3Rba2V5XSA9IFtdO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0ZXh0dXJlVVJMcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBtdWx0aUtleSA9ICdfTUFfSU1HXycgKyBrZXkgKyAnXycgKyBpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIGZpbGUgPSBuZXcgSW1hZ2VGaWxlKG11bHRpS2V5LCB0ZXh0dXJlVVJMc1tpXSwgdGhpcy5wYXRoLCB0ZXh0dXJlWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX211bHRpbGlzdFtrZXldLnB1c2gobXVsdGlLZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBhdGxhc1VSTHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgbXVsdGlLZXkgPSAnX01BX0pTT05fJyArIGtleSArICdfJyArIGkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgZmlsZSA9IG5ldyBKU09ORmlsZShtdWx0aUtleSwgYXRsYXNVUkxzW2ldLCB0aGlzLnBhdGgsIGF0bGFzWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX211bHRpbGlzdFtrZXldLnB1c2gobXVsdGlLZXkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gIFRoZSBMb2FkZXIgaGFzIGZpbmlzaGVkXHJcbkxvYWRlci5wcm90b3R5cGUucHJvY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKHRoaXMuc3RvcmFnZS5zaXplID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgVGhlIGdsb2JhbCBUZXh0dXJlIE1hbmFnZXJcclxuICAgIHZhciBjYWNoZSA9IHRoaXMuc3RhdGUuc3lzLmNhY2hlO1xyXG4gICAgdmFyIHRleHR1cmVzID0gdGhpcy5zdGF0ZS5zeXMudGV4dHVyZXM7XHJcblxyXG4gICAgLy8gIFByb2Nlc3MgbXVsdGlhdGxhcyBncm91cHMgZmlyc3RcclxuXHJcbiAgICB2YXIgZmlsZTtcclxuICAgIHZhciBmaWxlQTtcclxuICAgIHZhciBmaWxlQjtcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fbXVsdGlsaXN0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gW107XHJcbiAgICAgICAgdmFyIGltYWdlcyA9IFtdO1xyXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5fbXVsdGlsaXN0W2tleV07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLnN0b3JhZ2UuZ2V0KCdrZXknLCBrZXlzW2ldKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmaWxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS50eXBlID09PSAnaW1hZ2UnKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlcy5wdXNoKGZpbGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWxlLnR5cGUgPT09ICdqc29uJylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsZXRlKGZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgRG8gd2UgaGF2ZSBldmVyeXRoaW5nIG5lZWRlZD9cclxuICAgICAgICBpZiAoaW1hZ2VzLmxlbmd0aCArIGRhdGEubGVuZ3RoID09PSBrZXlzLmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBZdXAsIGFkZCB0aGVtIHRvIHRoZSBUZXh0dXJlIE1hbmFnZXJcclxuXHJcbiAgICAgICAgICAgIC8vICBJcyB0aGUgZGF0YSBKU09OIEhhc2ggb3IgSlNPTiBBcnJheT9cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVswXS5mcmFtZXMpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhc0pTT05BcnJheShrZXksIGltYWdlcywgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhc0pTT05IYXNoKGtleSwgaW1hZ2VzLCBkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0b3JhZ2UuZWFjaChmdW5jdGlvbiAoZmlsZSlcclxuICAgIHtcclxuICAgICAgICBzd2l0Y2ggKGZpbGUudHlwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcclxuICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZEltYWdlKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdhdGxhc2pzb24nOlxyXG5cclxuICAgICAgICAgICAgICAgIGZpbGVBID0gZmlsZS5maWxlQTtcclxuICAgICAgICAgICAgICAgIGZpbGVCID0gZmlsZS5maWxlQjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUEudHlwZSA9PT0gJ2ltYWdlJylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhcyhmaWxlQS5rZXksIGZpbGVBLmRhdGEsIGZpbGVCLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZEF0bGFzKGZpbGVCLmtleSwgZmlsZUIuZGF0YSwgZmlsZUEuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2JpdG1hcGZvbnQnOlxyXG5cclxuICAgICAgICAgICAgICAgIGZpbGVBID0gZmlsZS5maWxlQTtcclxuICAgICAgICAgICAgICAgIGZpbGVCID0gZmlsZS5maWxlQjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUEudHlwZSA9PT0gJ2ltYWdlJylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5iaXRtYXBGb250LmFkZChmaWxlQi5rZXksIFBhcnNlWE1MQml0bWFwRm9udChmaWxlQi5kYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkSW1hZ2UoZmlsZUEua2V5LCBmaWxlQS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5iaXRtYXBGb250LmFkZChmaWxlQS5rZXksIFBhcnNlWE1MQml0bWFwRm9udChmaWxlQS5kYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkSW1hZ2UoZmlsZUIua2V5LCBmaWxlQi5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnc3ByaXRlc2hlZXQnOlxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkU3ByaXRlU2hlZXQoZmlsZS5rZXksIGZpbGUuZGF0YSwgZmlsZS5jb25maWcpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdqc29uJzpcclxuICAgICAgICAgICAgICAgIGNhY2hlLmpzb24uYWRkKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICd4bWwnOlxyXG4gICAgICAgICAgICAgICAgY2FjaGUueG1sLmFkZChmaWxlLmtleSwgZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgICAgICAgICBjYWNoZS50ZXh0LmFkZChmaWxlLmtleSwgZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnYmluYXJ5JzpcclxuICAgICAgICAgICAgICAgIGNhY2hlLmJpbmFyeS5hZGQoZmlsZS5rZXksIGZpbGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ3NvdW5kJzpcclxuICAgICAgICAgICAgICAgIGNhY2hlLnNvdW5kLmFkZChmaWxlLmtleSwgZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnZ2xzbCc6XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5zaGFkZXIuYWRkKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zdG9yYWdlLmNsZWFyKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9Mb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qcyIsIi8vICBBIHByb3h5IGNsYXNzIHRvIHRoZSBHbG9iYWwgU3RhdGUgTWFuYWdlclxyXG5cclxudmFyIFN0YXRlTWFuYWdlciA9IGZ1bmN0aW9uIChzdGF0ZSwgZ2FtZSlcclxue1xyXG4gICAgLy8gIFRoZSBTdGF0ZSB0aGF0IG93bnMgdGhpcyBTdGF0ZU1hbmFnZXJcclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICB0aGlzLmtleSA9IHN0YXRlLnN5cy5zZXR0aW5ncy5rZXk7XHJcblxyXG4gICAgLy8gIEdsb2JhbFN0YXRlTWFuYWdlclxyXG4gICAgdGhpcy5tYW5hZ2VyID0gZ2FtZS5zdGF0ZTtcclxufTtcclxuXHJcblN0YXRlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGF0ZU1hbmFnZXI7XHJcblxyXG5TdGF0ZU1hbmFnZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8vICBTdGFydCB0aGlzIFN0YXRlIChvciB0aGUgb25lIGdpdmVuIHZpYSBrZXkpXHJcbiAgICBzdGFydDogZnVuY3Rpb24gKGtleSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHsga2V5ID0gdGhpcy5rZXk7IH1cclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnN0YXJ0KGtleSwgZGF0YSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBQYXVzZSB0aGlzIFN0YXRlIChvciB0aGUgb25lIGdpdmVuIHZpYSBrZXkpXHJcbiAgICBwYXVzZTogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHsga2V5ID0gdGhpcy5rZXk7IH1cclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnBhdXNlKGtleSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBTdG9wIHRoaXMgU3RhdGUgYW5kIHN0YXJ0IHRoZSBvbmUgZ2l2ZW5cclxuICAgIHN3YXA6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnBhdXNlKHRoaXMua2V5KTtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnN0YXJ0KGtleSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVVcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVEb3duOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYnJpbmdUb1RvcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNlbmRUb0JhY2s6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgVE9ET1xyXG4gICAgdHJhbnNpdGlvblRvOiBmdW5jdGlvbiAoa2V5LCBkdXJhdGlvbilcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucGF1c2UodGhpcy5rZXkpO1xyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIuc3RhcnQoa2V5KTtcclxuICAgIH0sXHJcblxyXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7IGtleSA9IHRoaXMua2V5OyB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuaXNBY3RpdmUoa2V5KTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9TdGF0ZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBEaXJ0eSEgTWFuYWdlclxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcbnZhciBVcGRhdGVNYW5hZ2VyID0gZnVuY3Rpb24gKHN0YXRlKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5saXN0ID0gW107XHJcblxyXG4gICAgLy8gdGhpcy5pID0gMTtcclxuXHJcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgdGhpcy5wcm9jZXNzZWQgPSAwO1xyXG59O1xyXG5cclxuVXBkYXRlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVcGRhdGVNYW5hZ2VyO1xyXG5cclxuVXBkYXRlTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc3RvcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMucnVubmluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuaSwgJ1VwZGF0ZU1hbmFnZXIuc3RvcCcsIHRoaXMucHJvY2Vzc2VkKTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0Lmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIC8vIHRoaXMuaSsrO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMucnVubmluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxpc3QubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAobGVuID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5pLCAnVXBkYXRlTWFuYWdlci5zdGFydCcsIGxlbik7XHJcblxyXG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBCZWNhdXNlIGl0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQgKGFzIGEgY2hpbGQgb2YgYW5vdGhlciBUcmFuc2Zvcm0gdGhhdCB3YXMgdXBkYXRlZClcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdFtpXSAmJiB0aGlzLmxpc3RbaV0uX2RpcnR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2ldLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh0cmFuc2Zvcm0pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5saXN0LnB1c2godHJhbnNmb3JtKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVwZGF0ZU1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL3N5c3RlbXMvVXBkYXRlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCcuLi91dGlscy9hcnJheS9RdWlja1NlbGVjdCcpO1xyXG5cclxuLyoqXHJcbiAqIFJCdXNoIGlzIGEgaGlnaC1wZXJmb3JtYW5jZSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIDJEIHNwYXRpYWwgaW5kZXhpbmcgb2YgcG9pbnRzIGFuZCByZWN0YW5nbGVzLlxyXG4gKiBJdCdzIGJhc2VkIG9uIGFuIG9wdGltaXplZCBSLXRyZWUgZGF0YSBzdHJ1Y3R1cmUgd2l0aCBidWxrIGluc2VydGlvbiBzdXBwb3J0LlxyXG4gKlxyXG4gKiBTcGF0aWFsIGluZGV4IGlzIGEgc3BlY2lhbCBkYXRhIHN0cnVjdHVyZSBmb3IgcG9pbnRzIGFuZCByZWN0YW5nbGVzIHRoYXQgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHF1ZXJpZXMgbGlrZVxyXG4gKiBcImFsbCBpdGVtcyB3aXRoaW4gdGhpcyBib3VuZGluZyBib3hcIiB2ZXJ5IGVmZmljaWVudGx5IChlLmcuIGh1bmRyZWRzIG9mIHRpbWVzIGZhc3RlciB0aGFuIGxvb3Bpbmcgb3ZlciBhbGwgaXRlbXMpLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHJidXNoIChtYXhFbnRyaWVzLCBmb3JtYXQpXHJcbntcclxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcclxuXHJcbiAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxyXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XHJcbiAgICB0aGlzLl9taW5FbnRyaWVzID0gTWF0aC5tYXgoMiwgTWF0aC5jZWlsKHRoaXMuX21heEVudHJpZXMgKiAwLjQpKTtcclxuXHJcbiAgICBpZiAoZm9ybWF0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNsZWFyKCk7XHJcbn1cclxuXHJcbnJidXNoLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBhbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoYmJveClcclxuICAgIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcclxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXHJcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xyXG5cclxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXHJcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcclxuXHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICBjb2xsaWRlczogZnVuY3Rpb24gKGJib3gpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXHJcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xyXG5cclxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcclxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xyXG5cclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGxvYWQ6IGZ1bmN0aW9uIChkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS5sZW5ndGgpKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc2NyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDAsIGRhdGEubGVuZ3RoIC0gMSwgMCk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBzYXZlIGFzIGlzIGlmIHRyZWUgaXMgZW1wdHlcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGVpZ2h0ID09PSBub2RlLmhlaWdodCkge1xyXG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XHJcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxyXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSlcclxuICAgIHtcclxuICAgICAgICBpZiAoaXRlbSkgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbXSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0ZuKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxyXG4gICAgICAgICAgICBiYm94ID0gdGhpcy50b0JCb3goaXRlbSksXHJcbiAgICAgICAgICAgIHBhdGggPSBbXSxcclxuICAgICAgICAgICAgaW5kZXhlcyA9IFtdLFxyXG4gICAgICAgICAgICBpLCBwYXJlbnQsIGluZGV4LCBnb2luZ1VwO1xyXG5cclxuICAgICAgICAvLyBkZXB0aC1maXJzdCBpdGVyYXRpdmUgdHJlZSB0cmF2ZXJzYWxcclxuICAgICAgICB3aGlsZSAobm9kZSB8fCBwYXRoLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCFub2RlKSB7IC8vIGdvIHVwXHJcbiAgICAgICAgICAgICAgICBub2RlID0gcGF0aC5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGkgPSBpbmRleGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLCBiYm94KSkgeyAvLyBnbyBkb3duXHJcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIG5vZGUgPSBudWxsOyAvLyBub3RoaW5nIGZvdW5kXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgdG9CQm94OiBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbTsgfSxcclxuXHJcbiAgICBjb21wYXJlTWluWDogY29tcGFyZU5vZGVNaW5YLFxyXG4gICAgY29tcGFyZU1pblk6IGNvbXBhcmVOb2RlTWluWSxcclxuXHJcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGF0YTsgfSxcclxuXHJcbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgX2FsbDogZnVuY3Rpb24gKG5vZGUsIHJlc3VsdClcclxuICAgIHtcclxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoLmFwcGx5KG5vZGVzVG9TZWFyY2gsIG5vZGUuY2hpbGRyZW4pO1xyXG5cclxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIF9idWlsZDogZnVuY3Rpb24gKGl0ZW1zLCBsZWZ0LCByaWdodCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBOID0gcmlnaHQgLSBsZWZ0ICsgMSxcclxuICAgICAgICAgICAgTSA9IHRoaXMuX21heEVudHJpZXMsXHJcbiAgICAgICAgICAgIG5vZGU7XHJcblxyXG4gICAgICAgIGlmIChOIDw9IE0pIHtcclxuICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxyXG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZShpdGVtcy5zbGljZShsZWZ0LCByaWdodCArIDEpKTtcclxuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIC8vIHRhcmdldCBoZWlnaHQgb2YgdGhlIGJ1bGstbG9hZGVkIHRyZWVcclxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gdGFyZ2V0IG51bWJlciBvZiByb290IGVudHJpZXMgdG8gbWF4aW1pemUgc3RvcmFnZSB1dGlsaXphdGlvblxyXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XHJcbiAgICAgICAgbm9kZS5sZWFmID0gZmFsc2U7XHJcbiAgICAgICAgbm9kZS5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xyXG5cclxuICAgICAgICB2YXIgTjIgPSBNYXRoLmNlaWwoTiAvIE0pLFxyXG4gICAgICAgICAgICBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSksXHJcbiAgICAgICAgICAgIGksIGosIHJpZ2h0MiwgcmlnaHQzO1xyXG5cclxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xyXG5cclxuICAgICAgICAgICAgcmlnaHQyID0gTWF0aC5taW4oaSArIE4xIC0gMSwgcmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGksIHJpZ2h0MiwgTjIsIHRoaXMuY29tcGFyZU1pblkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSByaWdodDI7IGogKz0gTjIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICByaWdodDMgPSBNYXRoLm1pbihqICsgTjIgLSAxLCByaWdodDIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHBhY2sgZWFjaCBlbnRyeSByZWN1cnNpdmVseVxyXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKGl0ZW1zLCBqLCByaWdodDMsIGhlaWdodCAtIDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xyXG5cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH0sXHJcblxyXG4gICAgX2Nob29zZVN1YnRyZWU6IGZ1bmN0aW9uIChiYm94LCBub2RlLCBsZXZlbCwgcGF0aClcclxuICAgIHtcclxuICAgICAgICB2YXIgaSwgbGVuLCBjaGlsZCwgdGFyZ2V0Tm9kZSwgYXJlYSwgZW5sYXJnZW1lbnQsIG1pbkFyZWEsIG1pbkVubGFyZ2VtZW50O1xyXG5cclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgbWluQXJlYSA9IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQpIC0gYXJlYTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5FbmxhcmdlbWVudCA9IGVubGFyZ2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlIHx8IG5vZGUuY2hpbGRyZW5bMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH0sXHJcblxyXG4gICAgX2luc2VydDogZnVuY3Rpb24gKGl0ZW0sIGxldmVsLCBpc05vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxyXG4gICAgICAgICAgICBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRvQkJveChpdGVtKSxcclxuICAgICAgICAgICAgaW5zZXJ0UGF0aCA9IFtdO1xyXG5cclxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xyXG5cclxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxyXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcclxuICAgICAgICBleHRlbmQobm9kZSwgYmJveCk7XHJcblxyXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIHdoaWxlIChsZXZlbCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XHJcbiAgICAgICAgICAgICAgICBsZXZlbC0tO1xyXG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxyXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xyXG4gICAgX3NwbGl0OiBmdW5jdGlvbiAoaW5zZXJ0UGF0aCwgbGV2ZWwpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcclxuICAgICAgICAgICAgTSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoLFxyXG4gICAgICAgICAgICBtID0gdGhpcy5fbWluRW50cmllcztcclxuXHJcbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xyXG5cclxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XHJcblxyXG4gICAgICAgIHZhciBuZXdOb2RlID0gY3JlYXRlTm9kZShub2RlLmNoaWxkcmVuLnNwbGljZShzcGxpdEluZGV4LCBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIHNwbGl0SW5kZXgpKTtcclxuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xyXG4gICAgICAgIG5ld05vZGUubGVhZiA9IG5vZGUubGVhZjtcclxuXHJcbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xyXG4gICAgICAgIGNhbGNCQm94KG5ld05vZGUsIHRoaXMudG9CQm94KTtcclxuXHJcbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcclxuICAgICAgICBlbHNlIHRoaXMuX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKTtcclxuICAgIH0sXHJcblxyXG4gICAgX3NwbGl0Um9vdDogZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gc3BsaXQgcm9vdCBub2RlXHJcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbbm9kZSwgbmV3Tm9kZV0pO1xyXG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XHJcbiAgICAgICAgdGhpcy5kYXRhLmxlYWYgPSBmYWxzZTtcclxuICAgICAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcclxuICAgIH0sXHJcblxyXG4gICAgX2Nob29zZVNwbGl0SW5kZXg6IGZ1bmN0aW9uIChub2RlLCBtLCBNKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpLCBiYm94MSwgYmJveDIsIG92ZXJsYXAsIGFyZWEsIG1pbk92ZXJsYXAsIG1pbkFyZWEsIGluZGV4O1xyXG5cclxuICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xyXG5cclxuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcclxuICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XHJcbiAgICAgICAgICAgIGJib3gyID0gZGlzdEJCb3gobm9kZSwgaSwgTSwgdGhpcy50b0JCb3gpO1xyXG5cclxuICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcclxuICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGJib3gxKSArIGJib3hBcmVhKGJib3gyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcclxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuXHJcbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcmxhcCA9PT0gbWluT3ZlcmxhcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcclxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBzb3J0cyBub2RlIGNoaWxkcmVuIGJ5IHRoZSBiZXN0IGF4aXMgZm9yIHNwbGl0XHJcbiAgICBfY2hvb3NlU3BsaXRBeGlzOiBmdW5jdGlvbiAobm9kZSwgbSwgTSlcclxuICAgIHtcclxuICAgICAgICB2YXIgY29tcGFyZU1pblggPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5YIDogY29tcGFyZU5vZGVNaW5YLFxyXG4gICAgICAgICAgICBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiBjb21wYXJlTm9kZU1pblksXHJcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcclxuICAgICAgICAgICAgeU1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblkpO1xyXG5cclxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J3MgYWxyZWFkeSBzb3J0ZWQgYnkgbWluWVxyXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcclxuICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiAobm9kZSwgbSwgTSwgY29tcGFyZSlcclxuICAgIHtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XHJcblxyXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcclxuICAgICAgICAgICAgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpLFxyXG4gICAgICAgICAgICByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KSxcclxuICAgICAgICAgICAgbWFyZ2luID0gYmJveE1hcmdpbihsZWZ0QkJveCkgKyBiYm94TWFyZ2luKHJpZ2h0QkJveCksXHJcbiAgICAgICAgICAgIGksIGNoaWxkO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgTSAtIG07IGkrKykge1xyXG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcclxuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4obGVmdEJCb3gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gTSAtIG0gLSAxOyBpID49IG07IGktLSkge1xyXG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XHJcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWFyZ2luO1xyXG4gICAgfSxcclxuXHJcbiAgICBfYWRqdXN0UGFyZW50QkJveGVzOiBmdW5jdGlvbiAoYmJveCwgcGF0aCwgbGV2ZWwpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBleHRlbmQocGF0aFtpXSwgYmJveCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfY29uZGVuc2U6IGZ1bmN0aW9uIChwYXRoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcclxuICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9pbml0Rm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KVxyXG4gICAge1xyXG4gICAgICAgIC8vIGRhdGEgZm9ybWF0IChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIGFjY2Vzc29ycylcclxuXHJcbiAgICAgICAgLy8gdXNlcyBldmFsLXR5cGUgZnVuY3Rpb24gY29tcGlsYXRpb24gaW5zdGVhZCBvZiBqdXN0IGFjY2VwdGluZyBhIHRvQkJveCBmdW5jdGlvblxyXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGFsZ29yaXRobXMgYXJlIHZlcnkgc2Vuc2l0aXZlIHRvIHNvcnRpbmcgZnVuY3Rpb25zIHBlcmZvcm1hbmNlLFxyXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXHJcblxyXG4gICAgICAgIHZhciBjb21wYXJlQXJyID0gWydyZXR1cm4gYScsICcgLSBiJywgJzsnXTtcclxuXHJcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWCA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFswXSkpO1xyXG4gICAgICAgIHRoaXMuY29tcGFyZU1pblkgPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMV0pKTtcclxuXHJcbiAgICAgICAgdGhpcy50b0JCb3ggPSBuZXcgRnVuY3Rpb24oJ2EnLFxyXG4gICAgICAgICAgICAncmV0dXJuIHttaW5YOiBhJyArIGZvcm1hdFswXSArXHJcbiAgICAgICAgICAgICcsIG1pblk6IGEnICsgZm9ybWF0WzFdICtcclxuICAgICAgICAgICAgJywgbWF4WDogYScgKyBmb3JtYXRbMl0gK1xyXG4gICAgICAgICAgICAnLCBtYXhZOiBhJyArIGZvcm1hdFszXSArICd9OycpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZmluZEl0ZW0gKGl0ZW0sIGl0ZW1zLCBlcXVhbHNGbilcclxue1xyXG4gICAgaWYgKCFlcXVhbHNGbikgcmV0dXJuIGl0ZW1zLmluZGV4T2YoaXRlbSk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHJldHVybiBpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXHJcbmZ1bmN0aW9uIGNhbGNCQm94IChub2RlLCB0b0JCb3gpXHJcbntcclxuICAgIGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gsIG5vZGUpO1xyXG59XHJcblxyXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxyXG5mdW5jdGlvbiBkaXN0QkJveCAobm9kZSwgaywgcCwgdG9CQm94LCBkZXN0Tm9kZSlcclxue1xyXG4gICAgaWYgKCFkZXN0Tm9kZSkgZGVzdE5vZGUgPSBjcmVhdGVOb2RlKG51bGwpO1xyXG4gICAgZGVzdE5vZGUubWluWCA9IEluZmluaXR5O1xyXG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xyXG4gICAgZGVzdE5vZGUubWF4WCA9IC1JbmZpbml0eTtcclxuICAgIGRlc3ROb2RlLm1heFkgPSAtSW5maW5pdHk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IGssIGNoaWxkOyBpIDwgcDsgaSsrKSB7XHJcbiAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGV4dGVuZChkZXN0Tm9kZSwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGVzdE5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dGVuZCAoYSwgYilcclxue1xyXG4gICAgYS5taW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xyXG4gICAgYS5taW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xyXG4gICAgYS5tYXhYID0gTWF0aC5tYXgoYS5tYXhYLCBiLm1heFgpO1xyXG4gICAgYS5tYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWCAoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9XHJcbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWSAoYSwgYikgeyByZXR1cm4gYS5taW5ZIC0gYi5taW5ZOyB9XHJcblxyXG5mdW5jdGlvbiBiYm94QXJlYSAoYSkgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKiAoYS5tYXhZIC0gYS5taW5ZKTsgfVxyXG5mdW5jdGlvbiBiYm94TWFyZ2luIChhKSB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSArIChhLm1heFkgLSBhLm1pblkpOyB9XHJcblxyXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEgKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoTWF0aC5tYXgoYi5tYXhYLCBhLm1heFgpIC0gTWF0aC5taW4oYi5taW5YLCBhLm1pblgpKSAqXHJcbiAgICAgICAgICAgKE1hdGgubWF4KGIubWF4WSwgYS5tYXhZKSAtIE1hdGgubWluKGIubWluWSwgYS5taW5ZKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEgKGEsIGIpXHJcbntcclxuICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYS5taW5YLCBiLm1pblgpLFxyXG4gICAgICAgIG1pblkgPSBNYXRoLm1heChhLm1pblksIGIubWluWSksXHJcbiAgICAgICAgbWF4WCA9IE1hdGgubWluKGEubWF4WCwgYi5tYXhYKSxcclxuICAgICAgICBtYXhZID0gTWF0aC5taW4oYS5tYXhZLCBiLm1heFkpO1xyXG5cclxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxyXG4gICAgICAgICAgIE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29udGFpbnMgKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBhLm1pblggPD0gYi5taW5YICYmXHJcbiAgICAgICAgICAgYS5taW5ZIDw9IGIubWluWSAmJlxyXG4gICAgICAgICAgIGIubWF4WCA8PSBhLm1heFggJiZcclxuICAgICAgICAgICBiLm1heFkgPD0gYS5tYXhZO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnRlcnNlY3RzIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gYi5taW5YIDw9IGEubWF4WCAmJlxyXG4gICAgICAgICAgIGIubWluWSA8PSBhLm1heFkgJiZcclxuICAgICAgICAgICBiLm1heFggPj0gYS5taW5YICYmXHJcbiAgICAgICAgICAgYi5tYXhZID49IGEubWluWTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTm9kZSAoY2hpbGRyZW4pXHJcbntcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxyXG4gICAgICAgIGhlaWdodDogMSxcclxuICAgICAgICBsZWFmOiB0cnVlLFxyXG4gICAgICAgIG1pblg6IEluZmluaXR5LFxyXG4gICAgICAgIG1pblk6IEluZmluaXR5LFxyXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcclxuICAgICAgICBtYXhZOiAtSW5maW5pdHlcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIHNvcnQgYW4gYXJyYXkgc28gdGhhdCBpdGVtcyBjb21lIGluIGdyb3VwcyBvZiBuIHVuc29ydGVkIGl0ZW1zLCB3aXRoIGdyb3VwcyBzb3J0ZWQgYmV0d2VlbiBlYWNoIG90aGVyO1xyXG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcclxuXHJcbmZ1bmN0aW9uIG11bHRpU2VsZWN0IChhcnIsIGxlZnQsIHJpZ2h0LCBuLCBjb21wYXJlKVxyXG57XHJcbiAgICB2YXIgc3RhY2sgPSBbbGVmdCwgcmlnaHRdLFxyXG4gICAgICAgIG1pZDtcclxuXHJcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xyXG5cclxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG4pIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcclxuICAgICAgICBxdWlja3NlbGVjdChhcnIsIG1pZCwgbGVmdCwgcmlnaHQsIGNvbXBhcmUpO1xyXG5cclxuICAgICAgICBzdGFjay5wdXNoKGxlZnQsIG1pZCwgbWlkLCByaWdodCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmJ1c2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0cnVjdHMvUlRyZWUuanNcbi8vIG1vZHVsZSBpZCA9IDUxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdHJ1Y3RzL1JUcmVlLmpzIiwiLy8gQSBTZXQgaXMgYSBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBlbGVtZW50cy5cclxuXHJcbnZhciBTZXQgPSBmdW5jdGlvbiAoZWxlbWVudHMpXHJcbntcclxuICAgIHRoaXMuZW50cmllcyA9IFtdO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnRzKSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hZGQoZWxlbWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXQ7XHJcblxyXG5TZXQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmVudHJpZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlbnRyeVtwcm9wZXJ0eV0gPT09IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGV0ZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZW50cmllcy5pbmRleE9mKHZhbHVlKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBkdW1wOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUuZ3JvdXAoJ1NldCcpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZW50cnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLy8gIEZvciB3aGVuIHlvdSBrbm93IHRoaXMgU2V0IHdpbGwgYmUgbW9kaWZpZWQgZHVyaW5nIHRoZSBpdGVyYXRpb25cclxuICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuZW50cmllcy5zbGljZSgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodGVtcFtpXSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBGb3Igd2hlbiB5b3UgYWJzb2x1dGVseSBrbm93IHRoaXMgU2V0IHdvbid0IGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgaXRlcmF0aW9uXHJcbiAgICBpdGVyYXRlOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodGhpcy5lbnRyaWVzW2ldKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb250YWluczogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5lbnRyaWVzLmluZGV4T2YodmFsdWUpID4gLTEpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1bmlvbjogZnVuY3Rpb24gKHNldClcclxuICAgIHtcclxuICAgICAgICB2YXIgbmV3U2V0ID0gbmV3IFNldCgpO1xyXG5cclxuICAgICAgICBzZXQudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3U2V0LmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3U2V0O1xyXG4gICAgfSxcclxuXHJcbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChzZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHNldC5jb250YWlucyh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdTZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uIChzZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFzZXQuY29udGFpbnModmFsdWUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3U2V0O1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNldC5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBzaXplOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5sZW5ndGggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RydWN0cy9TZXQuanNcbi8vIG1vZHVsZSBpZCA9IDUxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgRXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0V4dGVuZCcpO1xyXG5cclxuLyoqXHJcbiogQSBGcmFtZSBpcyBhIHNlY3Rpb24gb2YgYSBUZXh0dXJlLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5GcmFtZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgVGV4dHVyZSB0aGlzIEZyYW1lIGJlbG9uZ3MgdG8uXHJcbiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgdW5pcXVlICh3aXRoaW4gdGhlIFRleHR1cmUpIG5hbWUgb2YgdGhpcyBGcmFtZS5cclxuKiBAcGFyYW0ge251bWJlcn0geCAtIFggcG9zaXRpb24gb2YgdGhlIGZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZS5cclxuKiBAcGFyYW0ge251bWJlcn0geSAtIFkgcG9zaXRpb24gb2YgdGhlIGZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZS5cclxuKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0aGUgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIGZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZS5cclxuKi9cclxudmFyIEZyYW1lID0gZnVuY3Rpb24gKHRleHR1cmUsIG5hbWUsIHNvdXJjZUluZGV4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBUZXh0dXJlIHRoaXMgZnJhbWUgYmVsb25ncyB0by5cclxuICAgICovXHJcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoaXMgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxyXG4gICAgKi9cclxuICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgdGhpcy5zb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XHJcblxyXG4gICAgdGhpcy5zb3VyY2VJbmRleCA9IHNvdXJjZUluZGV4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gY3V0WCAtIFggcG9zaXRpb24gd2l0aGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0IGZyb20uXHJcbiAgICAqL1xyXG4gICAgdGhpcy5jdXRYID0geDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGN1dFkgLSBZIHBvc2l0aW9uIHdpdGhpbiB0aGUgc291cmNlIGltYWdlIHRvIGN1dCBmcm9tLlxyXG4gICAgKi9cclxuICAgIHRoaXMuY3V0WSA9IHk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgYXJlYSBpbiB0aGUgc291cmNlIGltYWdlIHRvIGN1dC5cclxuICAgICovXHJcbiAgICB0aGlzLmN1dFdpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBhcmVhIGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0LlxyXG4gICAgKi9cclxuICAgIHRoaXMuY3V0SGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0geCAtIFRoZSBYIHJlbmRlcmluZyBvZmZzZXQgb2YgdGhpcyBGcmFtZSwgdGFraW5nIHRyaW0gaW50byBhY2NvdW50LlxyXG4gICAgKi9cclxuICAgIHRoaXMueCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gVGhlIFkgcmVuZGVyaW5nIG9mZnNldCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXHJcbiAgICAqL1xyXG4gICAgdGhpcy55ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gVGhlIHJlbmRlcmluZyB3aWR0aCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXHJcbiAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gVGhlIHJlbmRlcmluZyBoZWlnaHQgb2YgdGhpcyBGcmFtZSwgdGFraW5nIHRyaW0gaW50byBhY2NvdW50LlxyXG4gICAgKi9cclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBUaGUgcmVuZGVyaW5nIHdpZHRoIG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cclxuICAgICovXHJcbiAgICB0aGlzLmNlbnRlclggPSBNYXRoLmZsb29yKHdpZHRoIC8gMik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVuZGVyaW5nIGhlaWdodCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5jZW50ZXJZID0gTWF0aC5mbG9vcihoZWlnaHQgLyAyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogSXMgdGhpcyBmcmFtZSBpcyByb3RhdGVkIG9yIG5vdCBpbiB0aGUgVGV4dHVyZT9cclxuICAgICogUm90YXRpb24gYWxsb3dzIHlvdSB0byB1c2Ugcm90YXRlZCBmcmFtZXMgaW4gdGV4dHVyZSBhdGxhcyBwYWNraW5nLlxyXG4gICAgKiBJdCBoYXMgbm90aGluZyB0byBkbyB3aXRoIFNwcml0ZSByb3RhdGlvbi5cclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSByb3RhdGVkXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5yb3RhdGVkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIElzIHRoaXMgYSB0aWxpbmcgdGV4dHVyZT8gQXMgdXNlZCBieSB0aGUgbGlrZXMgb2YgYSBUaWxpbmdTcHJpdGUuXHJcbiAgICAqIFRPRE86IFRyeSBhbmQgcmVtb3ZlIHRoaXMsIGl0IHNob3VsZG4ndCBiZSBoZXJlXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNUaWxpbmdcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLmlzVGlsaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoaXMgd2lsbCBsZXQgYSByZW5kZXJlciBrbm93IHRoYXQgYSB0aW50ZWQgcGFyZW50IGhhcyB1cGRhdGVkIGl0cyB0ZXh0dXJlLlxyXG4gICAgKiBUT0RPOiBUcnkgYW5kIHJlbW92ZSB0aGlzLCBpdCBzaG91bGRuJ3QgYmUgaGVyZVxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlcXVpcmVzUmVUaW50XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5yZXF1aXJlc1JlVGludCA9IGZhbHNlO1xyXG5cclxuICAgIC8vICBPdmVyLXJpZGVzIHRoZSBSZW5kZXJlciBzZXR0aW5nPyAtMSA9IHVzZSBSZW5kZXJlciBTZXR0aW5nLCAwID0gTm8gcm91bmRpbmcsIDEgPSBSb3VuZFxyXG4gICAgdGhpcy5hdXRvUm91bmQgPSAtMTtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIHVuLW1vZGlmaWVkIHNvdXJjZSBmcmFtZSwgdHJpbSBhbmQgVVYgZGF0YS5cclxuICAgICpcclxuICAgICogQHByaXZhdGVcclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGFcclxuICAgICovXHJcbiAgICB0aGlzLmRhdGEgPSB7XHJcbiAgICAgICAgY3V0OiB7XHJcbiAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgIHc6IHdpZHRoLFxyXG4gICAgICAgICAgICBoOiBoZWlnaHQsXHJcbiAgICAgICAgICAgIHI6IHggKyB3aWR0aCxcclxuICAgICAgICAgICAgYjogeSArIGhlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJpbTogZmFsc2UsXHJcbiAgICAgICAgc291cmNlU2l6ZToge1xyXG4gICAgICAgICAgICB3OiB3aWR0aCxcclxuICAgICAgICAgICAgaDogaGVpZ2h0XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcHJpdGVTb3VyY2VTaXplOiB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHc6IHdpZHRoLFxyXG4gICAgICAgICAgICBoOiBoZWlnaHRcclxuICAgICAgICB9LFxyXG4gICAgICAgIHV2czoge1xyXG4gICAgICAgICAgICB4MDogMCxcclxuICAgICAgICAgICAgeTA6IDAsXHJcbiAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICB5MTogMCxcclxuICAgICAgICAgICAgeDI6IDAsXHJcbiAgICAgICAgICAgIHkyOiAwLFxyXG4gICAgICAgICAgICB4MzogMCxcclxuICAgICAgICAgICAgeTM6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJhZGl1czogMC41ICogTWF0aC5zcXJ0KHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpLFxyXG4gICAgICAgIGRyYXdJbWFnZToge1xyXG4gICAgICAgICAgICBzeDogeCxcclxuICAgICAgICAgICAgc3k6IHksXHJcbiAgICAgICAgICAgIHNXaWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIHNIZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgZFdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgZEhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZVVWcygpO1xyXG59O1xyXG5cclxuRnJhbWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJhbWU7XHJcblxyXG5GcmFtZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIElmIHRoZSBmcmFtZSB3YXMgdHJpbW1lZCB3aGVuIGFkZGVkIHRvIHRoZSBUZXh0dXJlIEF0bGFzLCB0aGlzIHJlY29yZHMgdGhlIHRyaW0gYW5kIHNvdXJjZSBkYXRhLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5UZXh0dXJlRnJhbWUjc2V0VHJpbVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYWN0dWFsV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGZyYW1lIGJlZm9yZSBiZWluZyB0cmltbWVkLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYWN0dWFsSGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgZnJhbWUgYmVmb3JlIGJlaW5nIHRyaW1tZWQuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0WCAtIFRoZSBkZXN0aW5hdGlvbiBYIHBvc2l0aW9uIG9mIHRoZSB0cmltbWVkIGZyYW1lIGZvciBkaXNwbGF5LlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdFkgLSBUaGUgZGVzdGluYXRpb24gWSBwb3NpdGlvbiBvZiB0aGUgdHJpbW1lZCBmcmFtZSBmb3IgZGlzcGxheS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc3RXaWR0aCAtIFRoZSBkZXN0aW5hdGlvbiB3aWR0aCBvZiB0aGUgdHJpbW1lZCBmcmFtZSBmb3IgZGlzcGxheS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc3RIZWlnaHQgLSBUaGUgZGVzdGluYXRpb24gaGVpZ2h0IG9mIHRoZSB0cmltbWVkIGZyYW1lIGZvciBkaXNwbGF5LlxyXG4gICAgKi9cclxuICAgIHNldFRyaW06IGZ1bmN0aW9uIChhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0LCBkZXN0WCwgZGVzdFksIGRlc3RXaWR0aCwgZGVzdEhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgICAgICB2YXIgc3MgPSBkYXRhLnNwcml0ZVNvdXJjZVNpemU7XHJcblxyXG4gICAgICAgIC8vICBTdG9yZSBhY3R1YWwgdmFsdWVzXHJcblxyXG4gICAgICAgIGRhdGEudHJpbSA9IHRydWU7XHJcblxyXG4gICAgICAgIGRhdGEuc291cmNlU2l6ZS53ID0gYWN0dWFsV2lkdGg7XHJcbiAgICAgICAgZGF0YS5zb3VyY2VTaXplLmggPSBhY3R1YWxIZWlnaHQ7XHJcblxyXG4gICAgICAgIHNzLnggPSBkZXN0WDtcclxuICAgICAgICBzcy55ID0gZGVzdFk7XHJcbiAgICAgICAgc3MudyA9IGRlc3RXaWR0aDtcclxuICAgICAgICBzcy5oID0gZGVzdEhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gIEFkanVzdCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgdGhpcy54ID0gZGVzdFg7XHJcbiAgICAgICAgdGhpcy55ID0gZGVzdFk7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSBkZXN0V2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkZXN0SGVpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLmNlbnRlclggPSBNYXRoLmZsb29yKGRlc3RXaWR0aCAvIDIpO1xyXG4gICAgICAgIHRoaXMuY2VudGVyWSA9IE1hdGguZmxvb3IoZGVzdEhlaWdodCAvIDIpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVVWcygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIHVwZGF0ZVVWc1xyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHVwZGF0ZVVWczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgdHcgPSB0aGlzLnNvdXJjZS53aWR0aDtcclxuICAgICAgICB2YXIgdGggPSB0aGlzLnNvdXJjZS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHV2cyA9IHRoaXMuZGF0YS51dnM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdXZzLngwID0gdGhpcy5jdXRYIC8gdHc7XHJcbiAgICAgICAgdXZzLnkwID0gdGhpcy5jdXRZIC8gdGg7XHJcblxyXG4gICAgICAgIHV2cy54MSA9IHRoaXMuY3V0WCAvIHR3O1xyXG4gICAgICAgIHV2cy55MSA9ICh0aGlzLmN1dFkgKyB0aGlzLmN1dEhlaWdodCkgLyB0aDtcclxuXHJcbiAgICAgICAgdXZzLngyID0gKHRoaXMuY3V0WCArIHRoaXMuY3V0V2lkdGgpIC8gdHc7XHJcbiAgICAgICAgdXZzLnkyID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0SGVpZ2h0KSAvIHRoO1xyXG5cclxuICAgICAgICB1dnMueDMgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRXaWR0aCkgLyB0dztcclxuICAgICAgICB1dnMueTMgPSB0aGlzLmN1dFkgLyB0aDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCB1cGRhdGVVVnNJbnZlcnRlZFxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHVwZGF0ZVVWc0ludmVydGVkOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0dyA9IHRoaXMuc291cmNlLndpZHRoO1xyXG4gICAgICAgIHZhciB0aCA9IHRoaXMuc291cmNlLmhlaWdodDtcclxuICAgICAgICB2YXIgdXZzID0gdGhpcy5kYXRhLnV2cztcclxuICAgICAgICBcclxuICAgICAgICB1dnMueDMgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRIZWlnaHQpIC8gdHc7XHJcbiAgICAgICAgdXZzLnkzID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0V2lkdGgpIC8gdGg7XHJcblxyXG4gICAgICAgIHV2cy54MiA9IHRoaXMuY3V0WCAvIHR3OyAgICAgICAgXHJcbiAgICAgICAgdXZzLnkyID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0V2lkdGgpIC8gdGg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdXZzLngxID0gdGhpcy5jdXRYIC8gdHc7XHJcbiAgICAgICAgdXZzLnkxID0gdGhpcy5jdXRZIC8gdGg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdXZzLngwID0gKHRoaXMuY3V0WCArIHRoaXMuY3V0SGVpZ2h0KSAvIHR3O1xyXG4gICAgICAgIHV2cy55MCA9IHRoaXMuY3V0WSAvIHRoO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNsb25lID0gbmV3IEZyYW1lKHRoaXMudGV4dHVyZSwgdGhpcy5uYW1lLCB0aGlzLnNvdXJjZUluZGV4KTtcclxuXHJcbiAgICAgICAgY2xvbmUuY3V0WCA9IHRoaXMuY3V0WDtcclxuICAgICAgICBjbG9uZS5jdXRZID0gdGhpcy5jdXRZO1xyXG4gICAgICAgIGNsb25lLmN1dFdpZHRoID0gdGhpcy5jdXRXaWR0aDtcclxuICAgICAgICBjbG9uZS5jdXRIZWlnaHQgPSB0aGlzLmN1dEhlaWdodDtcclxuXHJcbiAgICAgICAgY2xvbmUueCA9IHRoaXMueDtcclxuICAgICAgICBjbG9uZS55ID0gdGhpcy55O1xyXG5cclxuICAgICAgICBjbG9uZS53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgY2xvbmUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGNsb25lLmNlbnRlclggPSB0aGlzLmNlbnRlclg7XHJcbiAgICAgICAgY2xvbmUuY2VudGVyWSA9IHRoaXMuY2VudGVyWTtcclxuXHJcbiAgICAgICAgY2xvbmUucm90YXRlZCA9IHRoaXMucm90YXRlZDtcclxuXHJcbiAgICAgICAgY2xvbmUuZGF0YSA9IEV4dGVuZCh0cnVlLCBjbG9uZS5kYXRhLCB0aGlzLmRhdGEpO1xyXG5cclxuICAgICAgICBjbG9uZS51cGRhdGVVVnMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZyYW1lLnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgd2lkdGggb2YgdGhlIEZyYW1lIGluIGl0cyB1bi10cmltbWVkLCB1bi1wYWRkZWQgc3RhdGUsIGFzIHByZXBhcmVkIGluIHRoZSBhcnQgcGFja2FnZSxcclxuICAgICogYmVmb3JlIGJlaW5nIHBhY2tlZC5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSNyZWFsV2lkdGhcclxuICAgICogQHByb3BlcnR5IHthbnl9IHJlYWxXaWR0aFxyXG4gICAgKi9cclxuICAgIHJlYWxXaWR0aDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZVNpemUudztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGhlaWdodCBvZiB0aGUgRnJhbWUgaW4gaXRzIHVuLXRyaW1tZWQsIHVuLXBhZGRlZCBzdGF0ZSwgYXMgcHJlcGFyZWQgaW4gdGhlIGFydCBwYWNrYWdlLFxyXG4gICAgKiBiZWZvcmUgYmVpbmcgcGFja2VkLlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI3JlYWxIZWlnaHRcclxuICAgICogQHByb3BlcnR5IHthbnl9IHJlYWxIZWlnaHRcclxuICAgICovXHJcbiAgICByZWFsSGVpZ2h0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlU2l6ZS5oO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBVVnNcclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSN1dnNcclxuICAgICogQHByb3BlcnR5IHtPYmplY3R9IHV2c1xyXG4gICAgKi9cclxuICAgIHV2czoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnV2cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIHJhZGl1cyBvZiB0aGUgRnJhbWUgKGRlcml2ZWQgZnJvbSBzcXJ0KHcgKiB3ICsgaCAqIGgpIC8gMilcclxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSNyYWRpdXNcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1c1xyXG4gICAgKi9cclxuICAgIHJhZGl1czoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnJhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQ2FudmFzIERyYXcgSW1hZ2UgZGF0YVxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI2NhbnZhc0RhdGFcclxuICAgICogQHByb3BlcnR5IHtPYmplY3R9IGNhbnZhc0RhdGFcclxuICAgICovXHJcbiAgICBjYW52YXNEYXRhOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuZHJhd0ltYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL0ZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA1MTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvRnJhbWUuanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgRnJhbWUgPSByZXF1aXJlKCcuL0ZyYW1lJyk7XHJcbnZhciBUZXh0dXJlU291cmNlID0gcmVxdWlyZSgnLi9UZXh0dXJlU291cmNlJyk7XHJcblxyXG4vKipcclxuKiBBIFRleHR1cmUgY29uc2lzdHMgb2YgYSBzb3VyY2UsIHVzdWFsbHkgYW4gSW1hZ2UgZnJvbSB0aGUgQ2FjaGUsIG9yIGEgQ2FudmFzLCBhbmQgYSBjb2xsZWN0aW9uXHJcbiogb2YgRnJhbWVzLiBUaGUgRnJhbWVzIHJlcHJlc2VudCB0aGUgZGlmZmVyZW50IGFyZWFzIG9mIHRoZSBUZXh0dXJlLiBGb3IgZXhhbXBsZSBhIHRleHR1cmUgYXRsYXNcclxuKiBtYXkgaGF2ZSBtYW55IEZyYW1lcywgb25lIGZvciBlYWNoIGVsZW1lbnQgd2l0aGluIHRoZSBhdGxhcy4gV2hlcmUtYXMgYSBzaW5nbGUgaW1hZ2Ugd291bGQgaGF2ZVxyXG4qIGp1c3Qgb25lIGZyYW1lLCB0aGF0IGVuY29tcGFzc2VzIHRoZSB3aG9sZSBpbWFnZS5cclxuKlxyXG4qIFRleHR1cmVzIGFyZSBtYW5hZ2VkIGJ5IHRoZSBnbG9iYWwgVGV4dHVyZU1hbmFnZXIuIFRoaXMgaXMgYSBzaW5nbGV0b24gY2xhc3MgdGhhdCBpc1xyXG4qIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgZGVsaXZlcmluZyBUZXh0dXJlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBGcmFtZXMgdG8gR2FtZSBPYmplY3RzLlxyXG4qXHJcbiogU3ByaXRlcyBhbmQgb3RoZXIgR2FtZSBPYmplY3RzIGdldCB0aGUgdGV4dHVyZSBkYXRhIHRoZXkgbmVlZCBmcm9tIHRoZSBUZXh0dXJlTWFuYWdlci5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcclxuKiBAcGFyYW0ge251bWJlcn0gc2NhbGVNb2RlXHJcbiovXHJcbnZhciBUZXh0dXJlID0gZnVuY3Rpb24gKG1hbmFnZXIsIGtleSwgc291cmNlKVxyXG57XHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2UpKVxyXG4gICAge1xyXG4gICAgICAgIHNvdXJjZSA9IFsgc291cmNlIF07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5rZXkgPSBrZXk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBzb3VyY2UgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZS5cclxuICAgICogVXN1YWxseSBhbiBJbWFnZSwgYnV0IGNhbiBhbHNvIGJlIGEgQ2FudmFzLlxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkgc291cmNlXHJcbiAgICAqIEB0eXBlIGFycmF5XHJcbiAgICAqL1xyXG4gICAgdGhpcy5zb3VyY2UgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IGZyYW1lcyAtIEZyYW1lc1xyXG4gICAgKi9cclxuICAgIHRoaXMuZnJhbWVzID0ge307XHJcblxyXG4gICAgdGhpcy5mcmFtZVRvdGFsID0gMDtcclxuXHJcbiAgICAvLyAgTG9hZCB0aGUgU291cmNlc1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UucHVzaChuZXcgVGV4dHVyZVNvdXJjZSh0aGlzLCBzb3VyY2VbaV0pKTtcclxuICAgIH1cclxufTtcclxuXHJcblRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dHVyZTtcclxuXHJcblRleHR1cmUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKG5hbWUsIHNvdXJjZUluZGV4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBmcmFtZSA9IG5ldyBGcmFtZSh0aGlzLCBuYW1lLCBzb3VyY2VJbmRleCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVzW25hbWVdID0gZnJhbWU7XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVUb3RhbCsrO1xyXG5cclxuICAgICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKG5hbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCBuYW1lID09PSBudWxsIHx8IHRoaXMuZnJhbWVUb3RhbCA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWUgPSAnX19CQVNFJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVzW25hbWVdO1xyXG5cclxuICAgICAgICBpZiAoIWZyYW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyBUZXh0dXJlLmZyYW1lIGZvdW5kIHdpdGggbmFtZSAnICsgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXNbJ19fQkFTRSddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTb3VyY2VJbWFnZTogZnVuY3Rpb24gKG5hbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCBuYW1lID09PSBudWxsIHx8IHRoaXMuZnJhbWVUb3RhbCA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWUgPSAnX19CQVNFJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVzW25hbWVdO1xyXG5cclxuICAgICAgICBpZiAoIWZyYW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyBUZXh0dXJlLmZyYW1lIGZvdW5kIHdpdGggbmFtZSAnICsgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXNbJ19fQkFTRSddLnNvdXJjZS5pbWFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZyYW1lLnNvdXJjZS5pbWFnZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmVJbmRleDogZnVuY3Rpb24gKGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zb3VyY2UubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZVtpXS5nbFRleHR1cmVJbmRleCA9IGluZGV4O1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5zb3VyY2VbaV0uaW1hZ2UuY3VycmVudFNyYywgJ2luZGV4ID0gJywgaW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIERlc3Ryb3lzIHRoaXMgYmFzZSB0ZXh0dXJlXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE5lZWQgdG8gaXRlcmF0ZSB0aG91Z2ggdGhlIFRleHR1cmVTb3VyY2VzLCBhbmQgdW5sb2FkIGVhY2ggb25lXHJcbiAgICAgICAgLy8gIHRoZW4gY2xlYXIgb3V0IHRoZSBmcmFtZXNcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICBpZiAodGhpcy5zb3VyY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQaGFzZXIuQ2FudmFzUG9vbC5yZW1vdmVCeUNhbnZhcyh0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XHJcbiAgICAgICAgKi9cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGZyb20gdGhlIGdpdmVuIGNhbnZhcyBlbGVtZW50LlxyXG4qXHJcbiogQHN0YXRpY1xyXG4qIEBtZXRob2QgZnJvbUNhbnZhc1xyXG4qIEBwYXJhbSBjYW52YXMge0NhbnZhc30gVGhlIGNhbnZhcyBlbGVtZW50IHNvdXJjZSBvZiB0aGUgdGV4dHVyZVxyXG4qIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2VlIHt7I2Nyb3NzTGluayBcIlBJWEkvc2NhbGVNb2Rlczpwcm9wZXJ0eVwifX1QaGFzZXIuc2NhbGVNb2Rlc3t7L2Nyb3NzTGlua319IGZvciBwb3NzaWJsZSB2YWx1ZXNcclxuKiBAcmV0dXJuIHtCYXNlVGV4dHVyZX1cclxuUGhhc2VyLlRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uIChjYW52YXMsIHNjYWxlTW9kZSlcclxue1xyXG4gICAgaWYgKGNhbnZhcy53aWR0aCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICBjYW52YXMud2lkdGggPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYW52YXMuaGVpZ2h0ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgUGhhc2VyLlRleHR1cmUoY2FudmFzLCBzY2FsZU1vZGUpO1xyXG59O1xyXG4qL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9UZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvVGV4dHVyZS5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcnMnKTtcclxudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuL1RleHR1cmUnKTtcclxudmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzUG9vbCcpO1xyXG5cclxuLyoqXHJcbiogVGV4dHVyZXMgYXJlIG1hbmFnZWQgYnkgdGhlIGdsb2JhbCBUZXh0dXJlTWFuYWdlci4gVGhpcyBpcyBhIHNpbmdsZXRvbiBjbGFzcyB0aGF0IGlzXHJcbiogcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGFuZCBkZWxpdmVyaW5nIFRleHR1cmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIEZyYW1lcyB0byBHYW1lIE9iamVjdHMuXHJcbipcclxuKiBTcHJpdGVzIGFuZCBvdGhlciBHYW1lIE9iamVjdHMgZ2V0IHRoZSB0ZXh0dXJlIGRhdGEgdGhleSBuZWVkIGZyb20gdGhlIFRleHR1cmVNYW5hZ2VyLlxyXG4qXHJcbiogQWNjZXNzIGl0IHZpYSBgc3RhdGUudGV4dHVyZXNgLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlTWFuYWdlclxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qL1xyXG52YXIgVGV4dHVyZU1hbmFnZXIgPSBmdW5jdGlvbiAoZ2FtZSlcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICB0aGlzLmxpc3QgPSB7fTtcclxuXHJcbiAgICB0aGlzLmFkZEJhc2U2NCgnX19ERUZBVUxUJywgZ2FtZS5jb25maWcuZGVmYXVsdEltYWdlKTtcclxuICAgIHRoaXMuYWRkQmFzZTY0KCdfX01JU1NJTkcnLCBnYW1lLmNvbmZpZy5taXNzaW5nSW1hZ2UpO1xyXG59O1xyXG5cclxuVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dHVyZU1hbmFnZXI7XHJcblxyXG5UZXh0dXJlTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkQmFzZTY0OiBmdW5jdGlvbiAoa2V5LCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IF90aGlzLmNyZWF0ZShrZXksIGltYWdlKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgUGFyc2VyLkltYWdlKHRleHR1cmUsIDApO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGltYWdlLnNyYyA9IGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEltYWdlOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgUGFyc2VyLkltYWdlKHRleHR1cmUsIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlQ2FudmFzOiBmdW5jdGlvbiAoa2V5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7IHdpZHRoID0gMjU2OyB9XHJcbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IDI1NjsgfVxyXG5cclxuICAgICAgICB2YXIgY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGUodGhpcywgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZENhbnZhcyhrZXksIGNhbnZhcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZENhbnZhczogZnVuY3Rpb24gKGtleSwgc291cmNlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFBhcnNlci5DYW52YXModGV4dHVyZSwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRBdGxhczogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBJcyBpdCBhIEhhc2ggb3IgYW4gQXJyYXk/XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuZnJhbWVzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEF0bGFzSlNPTkFycmF5KGtleSwgc291cmNlLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQXRsYXNKU09OSGFzaChrZXksIHNvdXJjZSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRBdGxhc0pTT05BcnJheTogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUGFyc2VyLkpTT05BcnJheSh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQYXJzZXIuSlNPTkFycmF5KHRleHR1cmUsIDAsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEF0bGFzSlNPTkhhc2g6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5KU09OSGFzaCh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQYXJzZXIuSlNPTkhhc2godGV4dHVyZSwgMCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBbYWRkU3ByaXRlU2hlZXQgZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0ga2V5ICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBzb3VyY2UgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IGNvbmZpZyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLmZyYW1lV2lkdGggLSBUaGUgZml4ZWQgd2lkdGggb2YgZWFjaCBmcmFtZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmZyYW1lSGVpZ2h0XSAtIFRoZSBmaXhlZCBoZWlnaHQgb2YgZWFjaCBmcmFtZS4gSWYgbm90IHNldCBpdCB3aWxsIHVzZSB0aGUgZnJhbWVXaWR0aCBhcyB0aGUgaGVpZ2h0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuc3RhcnRGcmFtZT0wXSAtIFNraXAgYSBudW1iZXIgb2YgZnJhbWVzLiBVc2VmdWwgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgc3ByaXRlIHNoZWV0cyBpbiBvbmUgVGV4dHVyZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmVuZEZyYW1lPS0xXSAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIHRvIGV4dHJhY3QgZnJvbSB0aGUgU3ByaXRlIFNoZWV0LiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiAtMSBtZWFucyBcImV4dHJhY3QgYWxsIGZyYW1lc1wiLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubWFyZ2luPTBdIC0gSWYgdGhlIGZyYW1lcyBoYXZlIGJlZW4gZHJhd24gd2l0aCBhIG1hcmdpbiwgc3BlY2lmeSB0aGUgYW1vdW50IGhlcmUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5zcGFjaW5nPTBdIC0gSWYgdGhlIGZyYW1lcyBoYXZlIGJlZW4gZHJhd24gd2l0aCBzcGFjaW5nIGJldHdlZW4gdGhlbSwgc3BlY2lmeSB0aGUgYW1vdW50IGhlcmUuXHJcbiAgICAgKi9cclxuICAgIGFkZFNwcml0ZVNoZWV0OiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGV4dHVyZS5zb3VyY2VbMF0ud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRleHR1cmUuc291cmNlWzBdLmhlaWdodDtcclxuXHJcbiAgICAgICAgUGFyc2VyLlNwcml0ZVNoZWV0KHRleHR1cmUsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRTcHJpdGVTaGVldEZyb21BdGxhczogZnVuY3Rpb24gKGtleSwgYXRsYXNLZXksIGF0bGFzRnJhbWUsIGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB2YXIgYXRsYXMgPSB0aGlzLmdldChhdGxhc0tleSk7XHJcbiAgICAgICAgdmFyIHNoZWV0ID0gYXRsYXMuZ2V0KGF0bGFzRnJhbWUpO1xyXG5cclxuICAgICAgICBpZiAoc2hlZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc2hlZXQuc291cmNlLmltYWdlKTtcclxuXHJcbiAgICAgICAgICAgIFBhcnNlci5TcHJpdGVTaGVldCh0ZXh0dXJlLCAwLCBzaGVldC5jdXRYLCBzaGVldC5jdXRZLCBzaGVldC5jdXRXaWR0aCwgc2hlZXQuY3V0SGVpZ2h0LCBjb25maWcpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRBdGxhc1N0YXJsaW5nWE1MOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQYXJzZXIuU3RhcmxpbmdYTUwodGV4dHVyZSwgaSwgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUGFyc2VyLlN0YXJsaW5nWE1MKHRleHR1cmUsIDAsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEF0bGFzUHl4ZWw6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5QeXhlbCh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQYXJzZXIuUHl4ZWwodGV4dHVyZSwgMCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZSh0aGlzLCBrZXksIHNvdXJjZSk7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdFtrZXldID0gdGV4dHVyZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGV4aXN0czogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubGlzdC5oYXNPd25Qcm9wZXJ0eShrZXkpKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgeyBrZXkgPSAnX19ERUZBVUxUJzsgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5saXN0W2tleV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbJ19fTUlTU0lORyddO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmVGcmFtZTogZnVuY3Rpb24gKGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtrZXldLmdldChmcmFtZSkuY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZyYW1lOiBmdW5jdGlvbiAoa2V5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0W2tleV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W2tleV0uZ2V0KGZyYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmU6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QudGV4dHVyZSA9IHRoaXMubGlzdFtrZXldO1xyXG4gICAgICAgICAgICBnYW1lT2JqZWN0LmZyYW1lID0gZ2FtZU9iamVjdC50ZXh0dXJlLmdldChmcmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFBhc3NlcyBhbGwgVGV4dHVyZXMgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIGVhY2hcclxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cclxuICAgICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXHJcbiAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3VtZW50c10gLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjaywgYWZ0ZXIgdGhlIGNoaWxkLlxyXG4gICAgKi9cclxuICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZylcclxuICAgIHtcclxuICAgICAgICB2YXIgYXJncyA9IFsgbnVsbCBdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgdGV4dHVyZSBpbiB0aGlzLmxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhcmdzWzBdID0gdGhpcy5saXN0W3RleHR1cmVdO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZU1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL1RleHR1cmVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvVGV4dHVyZU1hbmFnZXIuanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgU2NhbGVNb2RlcyA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL1NjYWxlTW9kZXMnKTtcclxudmFyIElzU2l6ZVBvd2VyT2ZUd28gPSByZXF1aXJlKCcuLi9tYXRoL3BvdzIvSXNTaXplUG93ZXJPZlR3bycpO1xyXG52YXIgQ3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZSA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZScpO1xyXG5cclxuLyoqXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVTb3VyY2VcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge29iamVjdH0gc291cmNlXHJcbiogQHBhcmFtIHtudW1iZXJ9IHNjYWxlTW9kZVxyXG4qL1xyXG52YXIgVGV4dHVyZVNvdXJjZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2UpXHJcbntcclxuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XHJcblxyXG4gICAgdGhpcy5pbWFnZSA9IHNvdXJjZTtcclxuXHJcbiAgICB0aGlzLmNvbXByZXNzaW9uQWxnb3JpdGhtID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIFJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUuXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSByZXNvbHV0aW9uXHJcbiAgICAqIEB0eXBlIE51bWJlclxyXG4gICAgKi9cclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgKiBUaGUgd2lkdGggb2YgdGhlIFRleHR1cmUuXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSB3aWR0aFxyXG4gICAgKiBAdHlwZSBOdW1iZXJcclxuICAgICogQHJlYWRPbmx5XHJcbiAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHNvdXJjZS5uYXR1cmFsV2lkdGggfHwgc291cmNlLndpZHRoIHx8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIFRleHR1cmUuXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcclxuICAgICogQHR5cGUgTnVtYmVyXHJcbiAgICAqIEByZWFkT25seVxyXG4gICAgKi9cclxuICAgIHRoaXMuaGVpZ2h0ID0gc291cmNlLm5hdHVyYWxIZWlnaHQgfHwgc291cmNlLmhlaWdodCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgc2NhbGUgbW9kZSB0byBhcHBseSB3aGVuIHNjYWxpbmcgdGhpcyB0ZXh0dXJlLlxyXG4gICAgKiBORUFSRVNUIG9yIERFRkFVTFRcclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHNjYWxlTW9kZVxyXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgKiBAZGVmYXVsdCBQaGFzZXIuc2NhbGVNb2Rlcy5ERUZBVUxUO1xyXG4gICAgKi9cclxuICAgIHRoaXMuc2NhbGVNb2RlID0gU2NhbGVNb2Rlcy5ERUZBVUxUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDb250cm9scyBpZiBSR0IgY2hhbm5lbHMgc2hvdWxkIGJlIHByZS1tdWx0aXBsaWVkIGJ5IEFscGhhICAoV2ViR0wgb25seSlcclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHByZW11bHRpcGxpZWRBbHBoYVxyXG4gICAgKiBAdHlwZSBCb29sZWFuXHJcbiAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICovXHJcbiAgICB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgYSBtaXBtYXAgb2YgdGhpcyB0ZXh0dXJlIG5lZWRzIHRvIGJlIGdlbmVyYXRlZC4gVGhpcyB2YWx1ZSBuZWVkcyB0byBiZSBzZXQgYmVmb3JlIHRoZSB0ZXh0dXJlIGlzIHVzZWRcclxuICAgICogQWxzbyB0aGUgdGV4dHVyZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIHNpemUgdG8gd29ya1xyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkgbWlwbWFwTGV2ZWxcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgdGhpcy5taXBtYXBMZXZlbCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEEgQmFzZVRleHR1cmUgY2FuIGJlIHNldCB0byBza2lwIHRoZSByZW5kZXJpbmcgcGhhc2UgaW4gdGhlIFdlYkdMIFNwcml0ZSBCYXRjaC5cclxuICAgICpcclxuICAgICogWW91IG1heSB3YW50IHRvIGRvIHRoaXMgaWYgeW91IGhhdmUgYSBwYXJlbnQgU3ByaXRlIHdpdGggbm8gdmlzaWJsZSB0ZXh0dXJlIChpLmUuIHVzZXMgdGhlIGludGVybmFsIGBfX2RlZmF1bHRgIHRleHR1cmUpXHJcbiAgICAqIHRoYXQgaGFzIGNoaWxkcmVuIHRoYXQgeW91IGRvIHdhbnQgdG8gcmVuZGVyLCB3aXRob3V0IGNhdXNpbmcgYSBiYXRjaCBmbHVzaCBpbiB0aGUgcHJvY2Vzcy5cclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHJlbmRlcmFibGVcclxuICAgICogQHR5cGUgQm9vbGVhblxyXG4gICAgKi9cclxuICAgIHRoaXMucmVuZGVyYWJsZSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSBpc1Bvd2VyT2YyXHJcbiAgICAqIEB0eXBlIGJvb2xlYW5cclxuICAgICovXHJcbiAgICB0aGlzLmlzUG93ZXJPZjIgPSBJc1NpemVQb3dlck9mVHdvKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IGdsVGV4dHVyZVxyXG4gICAgKi9cclxuICAgIHRoaXMuZ2xUZXh0dXJlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIG11bHRpIHRleHR1cmUgYmF0Y2hpbmcgaW5kZXggbnVtYmVyLlxyXG4gICAgKiBAcHJvcGVydHkgZ2xUZXh0dXJlSW5kZXhcclxuICAgICogQHR5cGUgTnVtYmVyXHJcbiAgICAqL1xyXG4gICAgdGhpcy5nbFRleHR1cmVJbmRleCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSB0aW1lc3RhbXAgd2hlbiB0aGlzIHRleHR1cmUgd2FzIGxhc3QgdXNlZCBieSB0aGUgV2ViR0wgcmVuZGVyZXIuXHJcbiAgICAqIENhbiBiZSB1c2VkIHRvIHB1cmdlIG91dCAnZGVhZCcgdGV4dHVyZXMgZnJvbSBHUFUgbWVtb3J5LlxyXG4gICAgKiBAcHJvcGVydHkgZ2xMYXN0VXNlZFxyXG4gICAgKiBAdHlwZSBOdW1iZXJcclxuICAgICovXHJcbiAgICB0aGlzLmdsTGFzdFVzZWQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkgZ2xEaXJ0eVxyXG4gICAgKi9cclxuICAgIHRoaXMuZ2xEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgdmFyIGdhbWUgPSB0ZXh0dXJlLm1hbmFnZXIuZ2FtZTtcclxuXHJcbiAgICBpZiAoZ2FtZS5jb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuV0VCR0wpXHJcbiAgICB7XHJcbiAgICAgICAgQ3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZShnYW1lLnJlbmRlcmVyLmdsLCB0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZVNvdXJjZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvVGV4dHVyZVNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RleHR1cmVzL1RleHR1cmVTb3VyY2UuanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBQYXJzZSBhIFNwcml0ZSBTaGVldCBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5JbWFnZVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBGcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUgdGhhdCB0aGUgU3ByaXRlIFNoZWV0IGlzIHN0b3JlZCBpbi5cclxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cclxuKi9cclxudmFyIENhbnZhc1RleHR1cmVQYXJzZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgpXHJcbntcclxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XHJcblxyXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNUZXh0dXJlUGFyc2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL0NhbnZhc1RleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBQYXJzZSBhIFNwcml0ZSBTaGVldCBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5JbWFnZVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBGcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUgdGhhdCB0aGUgU3ByaXRlIFNoZWV0IGlzIHN0b3JlZCBpbi5cclxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cclxuKi9cclxudmFyIEltYWdlVGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2VJbmRleClcclxue1xyXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuXHJcbiAgICB0ZXh0dXJlLmFkZCgnX19CQVNFJywgc291cmNlSW5kZXgsIDAsIDAsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlVGV4dHVyZVBhcnNlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9JbWFnZVRleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBQYXJzZXMgYSBKU09OIEFycmF5IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkpTT05BcnJheVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIEpTT04gZGF0YSBmcm9tIHRoZSBUZXh0dXJlIEF0bGFzLiBNdXN0IGJlIGluIEFycmF5IGZvcm1hdC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cclxuKi9cclxudmFyIEpTT05BcnJheVRleHR1cmVQYXJzZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIGpzb24pXHJcbntcclxuICAgIC8vICBNYWxmb3JtZWQ/XHJcbiAgICBpZiAoIWpzb25bJ2ZyYW1lcyddKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBUZXh0dXJlIEF0bGFzIEpTT04gQXJyYXkgZ2l2ZW4sIG1pc3NpbmcgXFwnZnJhbWVzXFwnIGFycmF5Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBZGQgaW4gYSBfX0JBU0UgZW50cnkgKGZvciB0aGUgZW50aXJlIGF0bGFzKVxyXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuXHJcbiAgICAvLyAgQnkgdGhpcyBzdGFnZSBmcmFtZXMgaXMgYSBmdWxseSBwYXJzZWQgYXJyYXlcclxuICAgIHZhciBmcmFtZXMgPSBqc29uWydmcmFtZXMnXTtcclxuICAgIHZhciBuZXdGcmFtZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3JjID0gZnJhbWVzW2ldO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGZyYW1lIHZhbHVlcyBhcmUgdGhlIGV4YWN0IGNvb3JkaW5hdGVzIHRvIGN1dCB0aGUgZnJhbWUgb3V0IG9mIHRoZSBhdGxhcyBmcm9tXHJcbiAgICAgICAgbmV3RnJhbWUgPSB0ZXh0dXJlLmFkZChzcmMuZmlsZW5hbWUsIHNvdXJjZUluZGV4LCBzcmMuZnJhbWUueCwgc3JjLmZyYW1lLnksIHNyYy5mcmFtZS53LCBzcmMuZnJhbWUuaCk7XHJcblxyXG4gICAgICAgIC8vICBUaGVzZSBhcmUgdGhlIG9yaWdpbmFsIChub24tdHJpbW1lZCkgc3ByaXRlIHZhbHVlc1xyXG4gICAgICAgIGlmIChzcmMudHJpbW1lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnNldFRyaW0oXHJcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS53LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNvdXJjZVNpemUuaCxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLngsXHJcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS55LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUudyxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLmhcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzcmMucm90YXRlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnJvdGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBuZXdGcmFtZS51cGRhdGVVVnNJbnZlcnRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSlNPTkFycmF5VGV4dHVyZVBhcnNlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9KU09OQXJyYXlUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogUGFyc2VzIGEgSlNPTiBBcnJheSBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5KU09OQXJyYXlcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBwYXJlbnQgVGV4dHVyZS5cclxuKiBAcGFyYW0ge29iamVjdH0ganNvbiAtIFRoZSBKU09OIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBKU09OIEhhc2ggZm9ybWF0LlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgSlNPTkhhc2hUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4LCBqc29uKVxyXG57XHJcbiAgICAvLyAgTWFsZm9ybWVkP1xyXG4gICAgaWYgKCFqc29uWydmcmFtZXMnXSlcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgVGV4dHVyZSBBdGxhcyBKU09OIEhhc2ggZ2l2ZW4sIG1pc3NpbmcgXFwnZnJhbWVzXFwnIE9iamVjdCcpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQWRkIGluIGEgX19CQVNFIGVudHJ5IChmb3IgdGhlIGVudGlyZSBhdGxhcylcclxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XHJcbiAgICB0ZXh0dXJlLmFkZCgnX19CQVNFJywgc291cmNlSW5kZXgsIDAsIDAsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcblxyXG4gICAgLy8gIEJ5IHRoaXMgc3RhZ2UgZnJhbWVzIGlzIGEgZnVsbHkgcGFyc2VkIE9iamVjdFxyXG4gICAgdmFyIGZyYW1lcyA9IGpzb25bJ2ZyYW1lcyddO1xyXG4gICAgdmFyIG5ld0ZyYW1lO1xyXG5cclxuICAgIGZvciAodmFyIGtleSBpbiBmcmFtZXMpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHNyYyA9IGZyYW1lc1trZXldO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGZyYW1lIHZhbHVlcyBhcmUgdGhlIGV4YWN0IGNvb3JkaW5hdGVzIHRvIGN1dCB0aGUgZnJhbWUgb3V0IG9mIHRoZSBhdGxhcyBmcm9tXHJcbiAgICAgICAgbmV3RnJhbWUgPSB0ZXh0dXJlLmFkZChrZXksIHNvdXJjZUluZGV4LCBzcmMuZnJhbWUueCwgc3JjLmZyYW1lLnksIHNyYy5mcmFtZS53LCBzcmMuZnJhbWUuaCk7XHJcblxyXG4gICAgICAgIC8vICBUaGVzZSBhcmUgdGhlIG9yaWdpbmFsIChub24tdHJpbW1lZCkgc3ByaXRlIHZhbHVlc1xyXG4gICAgICAgIGlmIChzcmMudHJpbW1lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnNldFRyaW0oXHJcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS53LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNvdXJjZVNpemUuaCxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLngsXHJcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS55LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUudyxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLmhcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzcmMucm90YXRlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnJvdGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBuZXdGcmFtZS51cGRhdGVVVnNJbnZlcnRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSlNPTkhhc2hUZXh0dXJlUGFyc2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL0pTT05IYXNoVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gNTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlcyBhIFB5eGVsIEpTT04gRmlsZSBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5KU09OQXJyYXlcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBwYXJlbnQgVGV4dHVyZS5cclxuKiBAcGFyYW0ge29iamVjdH0ganNvbiAtIFRoZSBKU09OIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBQeXhlbCBKU09OIGZvcm1hdC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cclxuKi9cclxudmFyIFB5eGVsVGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBqc29uKVxyXG57XHJcbiAgICAvLyAgTWFsZm9ybWVkPyBUaGVyZSBhcmUgYSBmZXcga2V5cyB0byBjaGVjayBoZXJlLlxyXG4gICAgdmFyIHNpZ25hdHVyZSA9IFsgJ2xheWVycycsICd0aWxld2lkdGgnLCAndGlsZWhlaWdodCcsICd0aWxlc3dpZGUnLCAndGlsZXNoaWdoJyBdO1xyXG5cclxuICAgIHNpZ25hdHVyZS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFqc29uW2tleV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ1BoYXNlci5BbmltYXRpb25QYXJzZXIuSlNPTkRhdGFQeXhlbDogSW52YWxpZCBQeXhlbCBUaWxlbWFwIEpTT04gZ2l2ZW4sIG1pc3NpbmcgXCInICsga2V5ICsgJ1wiIGtleS4nKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coanNvbik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBGb3IgdGhpcyBwdXJwb3NlLCBJIG9ubHkgY2FyZSBhYm91dCBwYXJzaW5nIHRpbGVtYXBzIHdpdGggYSBzaW5nbGUgbGF5ZXIuXHJcbiAgICBpZiAoanNvblsnbGF5ZXJzJ10ubGVuZ3RoICE9PSAxKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignUGhhc2VyLkFuaW1hdGlvblBhcnNlci5KU09ORGF0YVB5eGVsOiBUb28gbWFueSBsYXllcnMsIHRoaXMgcGFyc2VyIG9ubHkgc3VwcG9ydHMgZmxhdCBUaWxlbWFwcy4nKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhqc29uKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRhdGEgPSBuZXcgUGhhc2VyLkZyYW1lRGF0YSgpO1xyXG5cclxuICAgIHZhciB0aWxlaGVpZ2h0ID0ganNvblsndGlsZWhlaWdodCddO1xyXG4gICAgdmFyIHRpbGV3aWR0aCA9IGpzb25bJ3RpbGV3aWR0aCddO1xyXG5cclxuICAgIHZhciBmcmFtZXMgPSBqc29uWydsYXllcnMnXVswXVsndGlsZXMnXTtcclxuICAgIHZhciBuZXdGcmFtZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBuZXdGcmFtZSA9IGRhdGEuYWRkRnJhbWUobmV3IFBoYXNlci5GcmFtZShcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgZnJhbWVzW2ldLngsXHJcbiAgICAgICAgICAgIGZyYW1lc1tpXS55LFxyXG4gICAgICAgICAgICB0aWxld2lkdGgsXHJcbiAgICAgICAgICAgIHRpbGVoZWlnaHQsXHJcbiAgICAgICAgICAgIFwiZnJhbWVfXCIgKyBpICAvLyBObyBuYW1lcyBhcmUgaW5jbHVkZWQgaW4gcHl4ZWwgdGlsZW1hcCBkYXRhLlxyXG4gICAgICAgICkpO1xyXG5cclxuICAgICAgICAvLyBObyB0cmltIGRhdGEgaXMgaW5jbHVkZWQuXHJcbiAgICAgICAgbmV3RnJhbWUuc2V0VHJpbShmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFB5eGVsVGV4dHVyZVBhcnNlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9QeXhlbFRleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgR2V0T2JqZWN0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0T2JqZWN0VmFsdWUnKTtcclxuXHJcbi8qKlxyXG4qIFBhcnNlIGEgU3ByaXRlIFNoZWV0IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLlNwcml0ZVNoZWV0XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIEZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZSB0aGF0IHRoZSBTcHJpdGUgU2hlZXQgaXMgc3RvcmVkIGluLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBmcmFtZVdpZHRoIC0gVGhlIGZpeGVkIHdpZHRoIG9mIGVhY2ggZnJhbWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IGZyYW1lSGVpZ2h0IC0gVGhlIGZpeGVkIGhlaWdodCBvZiBlYWNoIGZyYW1lLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRGcmFtZT0wXSAtIFNraXAgYSBudW1iZXIgb2YgZnJhbWVzLiBVc2VmdWwgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgc3ByaXRlIHNoZWV0cyBpbiBvbmUgVGV4dHVyZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW2VuZEZyYW1lPS0xXSAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIHRvIGV4dHJhY3QgZnJvbSB0aGUgU3ByaXRlIFNoZWV0LiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiAtMSBtZWFucyBcImV4dHJhY3QgYWxsIGZyYW1lc1wiLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbbWFyZ2luPTBdIC0gSWYgdGhlIGZyYW1lcyBoYXZlIGJlZW4gZHJhd24gd2l0aCBhIG1hcmdpbiwgc3BlY2lmeSB0aGUgYW1vdW50IGhlcmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtzcGFjaW5nPTBdIC0gSWYgdGhlIGZyYW1lcyBoYXZlIGJlZW4gZHJhd24gd2l0aCBzcGFjaW5nIGJldHdlZW4gdGhlbSwgc3BlY2lmeSB0aGUgYW1vdW50IGhlcmUuXHJcbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXHJcbiovXHJcbnZhciBTcHJpdGVTaGVldFRleHR1cmVQYXJzZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbmZpZylcclxue1xyXG4gICAgdmFyIGZyYW1lV2lkdGggPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdmcmFtZVdpZHRoJywgbnVsbCk7XHJcbiAgICB2YXIgZnJhbWVIZWlnaHQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdmcmFtZUhlaWdodCcsIGZyYW1lV2lkdGgpO1xyXG5cclxuICAgIC8vICBJZiBtaXNzaW5nIHdlIGNhbid0IHByb2NlZWRcclxuICAgIGlmIChmcmFtZVdpZHRoID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZU1hbmFnZXIuU3ByaXRlU2hlZXRUZXh0dXJlUGFyc2VyOiBJbnZhbGlkIGZyYW1lV2lkdGggZ2l2ZW4uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0YXJ0RnJhbWUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdzdGFydEZyYW1lJywgMCk7XHJcbiAgICB2YXIgZW5kRnJhbWUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdlbmRGcmFtZScsIC0xKTtcclxuICAgIHZhciBtYXJnaW4gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdtYXJnaW4nLCAwKTtcclxuICAgIHZhciBzcGFjaW5nID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnc3BhY2luZycsIDApO1xyXG5cclxuICAgIHZhciByb3cgPSBNYXRoLmZsb29yKCh3aWR0aCAtIG1hcmdpbikgLyAoZnJhbWVXaWR0aCArIHNwYWNpbmcpKTtcclxuICAgIHZhciBjb2x1bW4gPSBNYXRoLmZsb29yKChoZWlnaHQgLSBtYXJnaW4pIC8gKGZyYW1lSGVpZ2h0ICsgc3BhY2luZykpO1xyXG4gICAgdmFyIHRvdGFsID0gcm93ICogY29sdW1uO1xyXG5cclxuICAgIGlmIChzdGFydEZyYW1lID4gdG90YWwgfHwgc3RhcnRGcmFtZSA8IC10b3RhbClcclxuICAgIHtcclxuICAgICAgICBzdGFydEZyYW1lID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhcnRGcmFtZSA8IDApXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEFsbG93IG5lZ2F0aXZlIHNraXBmcmFtZXMuXHJcbiAgICAgICAgc3RhcnRGcmFtZSA9IHRvdGFsICsgc3RhcnRGcmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZW5kRnJhbWUgIT09IC0xKVxyXG4gICAge1xyXG4gICAgICAgIHRvdGFsID0gc3RhcnRGcmFtZSArIChlbmRGcmFtZSArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmeCA9IG1hcmdpbjtcclxuICAgIHZhciBmeSA9IG1hcmdpbjtcclxuICAgIHZhciBheCA9IDA7XHJcbiAgICB2YXIgYXkgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcclxuICAgIHtcclxuICAgICAgICBheCA9IDA7XHJcbiAgICAgICAgYXkgPSAwO1xyXG5cclxuICAgICAgICB2YXIgdyA9IGZ4ICsgZnJhbWVXaWR0aDtcclxuICAgICAgICB2YXIgaCA9IGZ5ICsgZnJhbWVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh3ID4gd2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBheCA9IHcgLSB3aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoID4gaGVpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXkgPSBoIC0gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGV4dHVyZS5hZGQoaSwgc291cmNlSW5kZXgsIHggKyBmeCwgeSArIGZ5LCBmcmFtZVdpZHRoIC0gYXgsIGZyYW1lSGVpZ2h0IC0gYXkpO1xyXG5cclxuICAgICAgICBmeCArPSBmcmFtZVdpZHRoICsgc3BhY2luZztcclxuXHJcbiAgICAgICAgaWYgKGZ4ICsgZnJhbWVXaWR0aCA+IHdpZHRoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZnggPSBtYXJnaW47XHJcbiAgICAgICAgICAgIGZ5ICs9IGZyYW1lSGVpZ2h0ICsgc3BhY2luZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZVNoZWV0VGV4dHVyZVBhcnNlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9TcHJpdGVTaGVldFRleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90ZXh0dXJlcy9wYXJzZXJzL1Nwcml0ZVNoZWV0VGV4dHVyZVBhcnNlci5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlcyB0aGUgWE1MIGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLlN0YXJsaW5nWE1MXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtvYmplY3R9IHhtbCAtIFRoZSBYTUwgZGF0YSBmcm9tIHRoZSBUZXh0dXJlIEF0bGFzLiBNdXN0IGJlIGluIFN0YXJsaW5nIFhNTCBmb3JtYXQuXHJcbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXHJcbiovXHJcbnZhciBTdGFybGluZ1hNTFRleHR1cmVQYXJzZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgeG1sKVxyXG57XHJcbiAgICAvLyAgTWFsZm9ybWVkP1xyXG4gICAgaWYgKCF4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1RleHR1cmVBdGxhcycpKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybihcIlBoYXNlci5BbmltYXRpb25QYXJzZXIuWE1MRGF0YTogSW52YWxpZCBUZXh0dXJlIEF0bGFzIFhNTCBnaXZlbiwgbWlzc2luZyA8VGV4dHVyZUF0bGFzPiB0YWdcIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBMZXQncyBjcmVhdGUgc29tZSBmcmFtZXMgdGhlblxyXG4gICAgdmFyIGRhdGEgPSBuZXcgUGhhc2VyLkZyYW1lRGF0YSgpO1xyXG4gICAgdmFyIGZyYW1lcyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnU3ViVGV4dHVyZScpO1xyXG4gICAgdmFyIG5ld0ZyYW1lO1xyXG5cclxuICAgIHZhciBuYW1lO1xyXG4gICAgdmFyIGZyYW1lO1xyXG4gICAgdmFyIHg7XHJcbiAgICB2YXIgeTtcclxuICAgIHZhciB3aWR0aDtcclxuICAgIHZhciBoZWlnaHQ7XHJcbiAgICB2YXIgZnJhbWVYO1xyXG4gICAgdmFyIGZyYW1lWTtcclxuICAgIHZhciBmcmFtZVdpZHRoO1xyXG4gICAgdmFyIGZyYW1lSGVpZ2h0O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGZyYW1lID0gZnJhbWVzW2ldLmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIG5hbWUgPSBmcmFtZS5uYW1lLnZhbHVlO1xyXG4gICAgICAgIHggPSBwYXJzZUludChmcmFtZS54LnZhbHVlLCAxMCk7XHJcbiAgICAgICAgeSA9IHBhcnNlSW50KGZyYW1lLnkudmFsdWUsIDEwKTtcclxuICAgICAgICB3aWR0aCA9IHBhcnNlSW50KGZyYW1lLndpZHRoLnZhbHVlLCAxMCk7XHJcbiAgICAgICAgaGVpZ2h0ID0gcGFyc2VJbnQoZnJhbWUuaGVpZ2h0LnZhbHVlLCAxMCk7XHJcblxyXG4gICAgICAgIGZyYW1lWCA9IG51bGw7XHJcbiAgICAgICAgZnJhbWVZID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKGZyYW1lLmZyYW1lWClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZyYW1lWCA9IE1hdGguYWJzKHBhcnNlSW50KGZyYW1lLmZyYW1lWC52YWx1ZSwgMTApKTtcclxuICAgICAgICAgICAgZnJhbWVZID0gTWF0aC5hYnMocGFyc2VJbnQoZnJhbWUuZnJhbWVZLnZhbHVlLCAxMCkpO1xyXG4gICAgICAgICAgICBmcmFtZVdpZHRoID0gcGFyc2VJbnQoZnJhbWUuZnJhbWVXaWR0aC52YWx1ZSwgMTApO1xyXG4gICAgICAgICAgICBmcmFtZUhlaWdodCA9IHBhcnNlSW50KGZyYW1lLmZyYW1lSGVpZ2h0LnZhbHVlLCAxMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuZXdGcmFtZSA9IGRhdGEuYWRkRnJhbWUobmV3IFBoYXNlci5GcmFtZShpLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBuYW1lKSk7XHJcblxyXG4gICAgICAgIC8vICBUcmltbWVkP1xyXG4gICAgICAgIGlmIChmcmFtZVggIT09IG51bGwgfHwgZnJhbWVZICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUuc2V0VHJpbSh0cnVlLCB3aWR0aCwgaGVpZ2h0LCBmcmFtZVgsIGZyYW1lWSwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXJsaW5nWE1MVGV4dHVyZVBhcnNlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9TdGFybGluZ1hNTFRleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBDYW52YXM6IHJlcXVpcmUoJy4vQ2FudmFzVGV4dHVyZVBhcnNlcicpLFxyXG4gICAgSW1hZ2U6IHJlcXVpcmUoJy4vSW1hZ2VUZXh0dXJlUGFyc2VyJyksXHJcbiAgICBTcHJpdGVTaGVldDogcmVxdWlyZSgnLi9TcHJpdGVTaGVldFRleHR1cmVQYXJzZXInKSxcclxuICAgIEpTT05BcnJheTogcmVxdWlyZSgnLi9KU09OQXJyYXlUZXh0dXJlUGFyc2VyJyksXHJcbiAgICBKU09OSGFzaDogcmVxdWlyZSgnLi9KU09OSGFzaFRleHR1cmVQYXJzZXInKSxcclxuICAgIFN0YXJsaW5nWE1MOiByZXF1aXJlKCcuL1N0YXJsaW5nWE1MVGV4dHVyZVBhcnNlcicpLFxyXG4gICAgUHl4ZWw6IHJlcXVpcmUoJy4vUHl4ZWxUZXh0dXJlUGFyc2VyJylcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RleHR1cmVzL3BhcnNlcnMvaW5kZXguanMiLCJ2YXIgR2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJYJyk7XHJcbnZhciBHZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Qm90dG9tJyk7XHJcbnZhciBTZXRDZW50ZXJYID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclgnKTtcclxudmFyIFNldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRCb3R0b20nKTtcclxuXHJcbnZhciBJbkJvdHRvbUNlbnRlciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRDZW50ZXJYKGdhbWVPYmplY3QsIEdldENlbnRlclgoY29udGFpbmVyKSArIG9mZnNldFgpO1xyXG4gICAgU2V0Qm90dG9tKGdhbWVPYmplY3QsIEdldEJvdHRvbShjb250YWluZXIpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluQm90dG9tQ2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9JbkJvdHRvbUNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luQm90dG9tQ2VudGVyLmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xyXG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xyXG52YXIgU2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRMZWZ0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgSW5Cb3R0b21MZWZ0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNvbnRhaW5lciwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldExlZnQoZ2FtZU9iamVjdCwgR2V0TGVmdChjb250YWluZXIpIC0gb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0Qm90dG9tKGNvbnRhaW5lcikgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5Cb3R0b21MZWZ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9JbkJvdHRvbUxlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDUzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9JbkJvdHRvbUxlZnQuanMiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgSW5Cb3R0b21SaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChjb250YWluZXIpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0Qm90dG9tKGNvbnRhaW5lcikgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5Cb3R0b21SaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vSW5Cb3R0b21SaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luQm90dG9tUmlnaHQuanMiLCJ2YXIgR2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJYJyk7XHJcbnZhciBHZXRDZW50ZXJZID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldENlbnRlclknKTtcclxudmFyIENlbnRlck9uID0gcmVxdWlyZSgnLi4vYm91bmRzL0NlbnRlck9uJyk7XHJcblxyXG52YXIgSW5DZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgQ2VudGVyT24oZ2FtZU9iamVjdCwgR2V0Q2VudGVyWChjb250YWluZXIpICsgb2Zmc2V0WCwgR2V0Q2VudGVyWShjb250YWluZXIpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluQ2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9JbkNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luQ2VudGVyLmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xyXG52YXIgR2V0Q2VudGVyWSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJZJyk7XHJcbnZhciBTZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldExlZnQnKTtcclxudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWScpO1xyXG5cclxudmFyIEluTGVmdENlbnRlciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldExlZnQoY29udGFpbmVyKSAtIG9mZnNldFgpO1xyXG4gICAgU2V0Q2VudGVyWShnYW1lT2JqZWN0LCBHZXRDZW50ZXJZKGNvbnRhaW5lcikgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5MZWZ0Q2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9JbkxlZnRDZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9JbkxlZnRDZW50ZXIuanMiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWScpO1xyXG52YXIgU2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0UmlnaHQnKTtcclxudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWScpO1xyXG5cclxudmFyIEluUmlnaHRDZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0UmlnaHQoZ2FtZU9iamVjdCwgR2V0UmlnaHQoY29udGFpbmVyKSArIG9mZnNldFgpO1xyXG4gICAgU2V0Q2VudGVyWShnYW1lT2JqZWN0LCBHZXRDZW50ZXJZKGNvbnRhaW5lcikgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5SaWdodENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vSW5SaWdodENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luUmlnaHRDZW50ZXIuanMiLCJ2YXIgR2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJYJyk7XHJcbnZhciBHZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0VG9wJyk7XHJcbnZhciBTZXRDZW50ZXJYID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclgnKTtcclxudmFyIFNldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRUb3AnKTtcclxuXHJcbnZhciBJblRvcENlbnRlciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRDZW50ZXJYKGdhbWVPYmplY3QsIEdldENlbnRlclgoY29udGFpbmVyKSArIG9mZnNldFgpO1xyXG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldFRvcChjb250YWluZXIpIC0gb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluVG9wQ2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9JblRvcENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luVG9wQ2VudGVyLmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xyXG52YXIgR2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFRvcCcpO1xyXG52YXIgU2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRMZWZ0Jyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgSW5Ub3BMZWZ0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNvbnRhaW5lciwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldExlZnQoZ2FtZU9iamVjdCwgR2V0TGVmdChjb250YWluZXIpIC0gb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0VG9wKGNvbnRhaW5lcikgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5Ub3BMZWZ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9JblRvcExlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDUzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9JblRvcExlZnQuanMiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgSW5Ub3BSaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChjb250YWluZXIpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0VG9wKGNvbnRhaW5lcikgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5Ub3BSaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vSW5Ub3BSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luVG9wUmlnaHQuanMiLCJ2YXIgR2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJYJyk7XHJcbnZhciBHZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Qm90dG9tJyk7XHJcbnZhciBTZXRDZW50ZXJYID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclgnKTtcclxudmFyIFNldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRUb3AnKTtcclxuXHJcbnZhciBUb0JvdHRvbUNlbnRlciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRDZW50ZXJYKGdhbWVPYmplY3QsIEdldENlbnRlclgocGFyZW50KSArIG9mZnNldFgpO1xyXG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldEJvdHRvbShwYXJlbnQpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvQm90dG9tQ2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9Ub0JvdHRvbUNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvQm90dG9tQ2VudGVyLmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xyXG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xyXG52YXIgU2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRMZWZ0Jyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgVG9Cb3R0b21MZWZ0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldExlZnQoZ2FtZU9iamVjdCwgR2V0TGVmdChwYXJlbnQpIC0gb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0Qm90dG9tKHBhcmVudCkgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Cb3R0b21MZWZ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9Ub0JvdHRvbUxlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDUzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9Ub0JvdHRvbUxlZnQuanMiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgVG9Cb3R0b21SaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0Qm90dG9tKHBhcmVudCkgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Cb3R0b21SaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vVG9Cb3R0b21SaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvQm90dG9tUmlnaHQuanMiLCJ2YXIgR2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRMZWZ0Jyk7XHJcbnZhciBHZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Qm90dG9tJyk7XHJcbnZhciBTZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRSaWdodCcpO1xyXG52YXIgU2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldEJvdHRvbScpO1xyXG5cclxudmFyIFRvTGVmdEJvdHRvbSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRMZWZ0KHBhcmVudCkgLSBvZmZzZXRYKTtcclxuICAgIFNldEJvdHRvbShnYW1lT2JqZWN0LCBHZXRCb3R0b20ocGFyZW50KSArIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb0xlZnRCb3R0b207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL1RvTGVmdEJvdHRvbS5qc1xuLy8gbW9kdWxlIGlkID0gNTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvTGVmdEJvdHRvbS5qcyIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWScpO1xyXG52YXIgU2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0UmlnaHQnKTtcclxudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWScpO1xyXG5cclxudmFyIFRvTGVmdENlbnRlciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRMZWZ0KHBhcmVudCkgLSBvZmZzZXRYKTtcclxuICAgIFNldENlbnRlclkoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWShwYXJlbnQpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvTGVmdENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vVG9MZWZ0Q2VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYWxpZ24vVG9MZWZ0Q2VudGVyLmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xyXG52YXIgR2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFRvcCcpO1xyXG52YXIgU2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0UmlnaHQnKTtcclxudmFyIFNldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRUb3AnKTtcclxuXHJcbnZhciBUb0xlZnRUb3AgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0UmlnaHQoZ2FtZU9iamVjdCwgR2V0TGVmdChwYXJlbnQpIC0gb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0VG9wKHBhcmVudCkgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9MZWZ0VG9wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9Ub0xlZnRUb3AuanNcbi8vIG1vZHVsZSBpZCA9IDU0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9Ub0xlZnRUb3AuanMiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldEJvdHRvbScpO1xyXG5cclxudmFyIFRvUmlnaHRCb3R0b20gPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0TGVmdChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0Qm90dG9tKHBhcmVudCkgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9SaWdodEJvdHRvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vVG9SaWdodEJvdHRvbS5qc1xuLy8gbW9kdWxlIGlkID0gNTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvUmlnaHRCb3R0b20uanMiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWScpO1xyXG52YXIgU2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRMZWZ0Jyk7XHJcbnZhciBTZXRDZW50ZXJZID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclknKTtcclxuXHJcbnZhciBUb1JpZ2h0VG9wID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldExlZnQoZ2FtZU9iamVjdCwgR2V0UmlnaHQocGFyZW50KSArIG9mZnNldFgpO1xyXG4gICAgU2V0Q2VudGVyWShnYW1lT2JqZWN0LCBHZXRDZW50ZXJZKHBhcmVudCkgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9SaWdodFRvcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vVG9SaWdodENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvUmlnaHRDZW50ZXIuanMiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFRvcCcpO1xyXG5cclxudmFyIFRvUmlnaHRUb3AgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0TGVmdChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0VG9wKHBhcmVudCkgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9SaWdodFRvcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vVG9SaWdodFRvcC5qc1xuLy8gbW9kdWxlIGlkID0gNTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvUmlnaHRUb3AuanMiLCJ2YXIgR2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJYJyk7XHJcbnZhciBHZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0VG9wJyk7XHJcbnZhciBTZXRDZW50ZXJYID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclgnKTtcclxudmFyIFNldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRCb3R0b20nKTtcclxuXHJcbnZhciBUb1RvcENlbnRlciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRDZW50ZXJYKGdhbWVPYmplY3QsIEdldENlbnRlclgocGFyZW50KSArIG9mZnNldFgpO1xyXG4gICAgU2V0Qm90dG9tKGdhbWVPYmplY3QsIEdldFRvcChwYXJlbnQpIC0gb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvVG9wQ2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9Ub1RvcENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvVG9wQ2VudGVyLmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xyXG52YXIgR2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFRvcCcpO1xyXG52YXIgU2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRMZWZ0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgVG9Ub3BMZWZ0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldExlZnQoZ2FtZU9iamVjdCwgR2V0TGVmdChwYXJlbnQpIC0gb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0VG9wKHBhcmVudCkgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Ub3BMZWZ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9Ub1RvcExlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDU0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9Ub1RvcExlZnQuanMiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgVG9Ub3BSaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0VG9wKHBhcmVudCkgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Ub3BSaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vVG9Ub3BSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvVG9wUmlnaHQuanMiLCIvKipcclxuKiBTbmFwcyBhIHZhbHVlIHRvIHRoZSBuZWFyZXN0IHZhbHVlIGluIGFuIGFycmF5LlxyXG4qIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgaW4gdGhlIHJhbmdlIGBbZmlyc3RfdmFsdWUsIGxhc3RfdmFsdWVdYC5cclxuKlxyXG4qIEBtZXRob2RcclxuKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgc2VhcmNoIHZhbHVlXHJcbiogQHBhcmFtIHtudW1iZXJbXX0gYXJyIC0gVGhlIGlucHV0IGFycmF5IHdoaWNoIF9tdXN0XyBiZSBzb3J0ZWQuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgbmVhcmVzdCB2YWx1ZSBmb3VuZC5cclxuKi9cclxudmFyIEZpbmRDbG9zZXN0SW5Tb3J0ZWQgPSBmdW5jdGlvbiAodmFsdWUsIGFycmF5KVxyXG57XHJcbiAgICBpZiAoIWFycmF5Lmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXJyYXkubGVuZ3RoID09PSAxIHx8IHZhbHVlIDwgYXJyYXlbMF0pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpID0gMTtcclxuXHJcbiAgICB3aGlsZSAoYXJyYXlbaV0gPCB2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxvdyA9IGFycmF5W2kgLSAxXTtcclxuICAgIHZhciBoaWdoID0gKGkgPCBhcnJheS5sZW5ndGgpID8gYXJyYXlbaV0gOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblxyXG4gICAgcmV0dXJuICgoaGlnaCAtIHZhbHVlKSA8PSAodmFsdWUgLSBsb3cpKSA/IGhpZ2ggOiBsb3c7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpbmRDbG9zZXN0SW5Tb3J0ZWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L0ZpbmRDbG9zZXN0SW5Tb3J0ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDU1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBGZXRjaCBhIHJhbmRvbSBlbnRyeSBmcm9tIHRoZSBnaXZlbiBhcnJheS5cclxuKlxyXG4qIFdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgYXJlIG5vIGFycmF5IGl0ZW1zIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHNwZWNpZmllZCByYW5nZVxyXG4qIG9yIGlmIHRoZXJlIGlzIG5vIGl0ZW0gZm9yIHRoZSByYW5kb21seSBjaG9zZW4gaW5kZXguXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHthbnlbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydEluZGV4IC0gT3B0aW9uYWwgb2Zmc2V0IG9mZiB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LiBEZWZhdWx0IHZhbHVlIGlzIDAsIG9yIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIC0gT3B0aW9uYWwgcmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiB2YWx1ZXMgeW91IHdhbnQgdG8gcmFuZG9tbHkgc2VsZWN0IGZyb20uXHJcbiogQHJldHVybiB7b2JqZWN0fSBUaGUgcmFuZG9tIG9iamVjdCB0aGF0IHdhcyBzZWxlY3RlZC5cclxuKi9cclxuXHJcbnZhciBHZXRSYW5kb21FbGVtZW50ID0gZnVuY3Rpb24gKGFycmF5LCBzdGFydCwgbGVuZ3RoKVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSBhcnJheS5sZW5ndGg7IH1cclxuXHJcbiAgICB2YXIgcmFuZG9tSW5kZXggPSBzdGFydCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCk7XHJcblxyXG4gICAgcmV0dXJuIChhcnJheVtyYW5kb21JbmRleF0gPT09IHVuZGVmaW5lZCkgPyBudWxsIDogYXJyYXlbcmFuZG9tSW5kZXhdO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRSYW5kb21FbGVtZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9HZXRSYW5kb21FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1NTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJvdW5kQXdheUZyb21aZXJvID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9Sb3VuZEF3YXlGcm9tWmVybycpO1xyXG5cclxuLyoqXHJcbiogQ3JlYXRlIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbSBgc3RhcnRgXHJcbiogdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgYGVuZGAgYnkgYWR2YW5jaW5nIGJ5IGBzdGVwYC5cclxuKlxyXG4qIElmIGBzdGFydGAgaXMgbGVzcyB0aGFuIGBlbmRgIGEgemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxyXG4qXHJcbiogQ2VydGFpbiB2YWx1ZXMgZm9yIGBzdGFydGAgYW5kIGBlbmRgIChlZy4gTmFOL3VuZGVmaW5lZC9udWxsKSBhcmUgY3VycmVudGx5IGNvZXJjZWQgdG8gMDtcclxuKiBmb3IgZm9yd2FyZCBjb21wYXRpYmlsaXR5IG1ha2Ugc3VyZSB0byBwYXNzIGluIGFjdHVhbCBudW1iZXJzLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQXJyYXlVdGlscyNudW1iZXJBcnJheVN0ZXBcclxuKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbZW5kXSAtIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSAtIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxyXG4qIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIG51bWJlcnMuXHJcbiogQGV4YW1wbGVcclxuKiBOdW1iZXJBcnJheVN0ZXAoNCk7XHJcbiogLy8gPT4gWzAsIDEsIDIsIDNdXHJcbipcclxuKiBOdW1iZXJBcnJheVN0ZXAoMSwgNSk7XHJcbiogLy8gPT4gWzEsIDIsIDMsIDRdXHJcbipcclxuKiBOdW1iZXJBcnJheVN0ZXAoMCwgMjAsIDUpO1xyXG4qIC8vID0+IFswLCA1LCAxMCwgMTVdXHJcbipcclxuKiBOdW1iZXJBcnJheVN0ZXAoMCwgLTQsIC0xKTtcclxuKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cclxuKlxyXG4qIE51bWJlckFycmF5U3RlcCgxLCA0LCAwKTtcclxuKiAvLyA9PiBbMSwgMSwgMV1cclxuKlxyXG4qIE51bWJlckFycmF5U3RlcCgwKTtcclxuKiAvLyA9PiBbXVxyXG4qL1xyXG52YXIgTnVtYmVyQXJyYXlTdGVwID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0ZXApXHJcbntcclxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxyXG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7IGVuZCA9IG51bGw7IH1cclxuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDE7IH1cclxuXHJcbiAgICBpZiAoZW5kID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIGVuZCA9IHN0YXJ0O1xyXG4gICAgICAgIHN0YXJ0ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgdmFyIHRvdGFsID0gTWF0aC5tYXgoUm91bmRBd2F5RnJvbVplcm8oKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHN0YXJ0KTtcclxuICAgICAgICBzdGFydCArPSBzdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlckFycmF5U3RlcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXlTdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSA1NTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXlTdGVwLmpzIiwidmFyIFNwbGljZU9uZSA9IHJlcXVpcmUoJy4vU3BsaWNlT25lJyk7XHJcblxyXG4vKipcclxuKiBSZW1vdmVzIGEgcmFuZG9tIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheSBhbmQgcmV0dXJucyBpdC5cclxuKlxyXG4qIFdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgYXJlIG5vIGFycmF5IGl0ZW1zIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHNwZWNpZmllZCByYW5nZVxyXG4qIG9yIGlmIHRoZXJlIGlzIG5vIGl0ZW0gZm9yIHRoZSByYW5kb21seSBjaG9zZW4gaW5kZXguXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHthbnlbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydEluZGV4IC0gT3B0aW9uYWwgb2Zmc2V0IG9mZiB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LiBEZWZhdWx0IHZhbHVlIGlzIDAsIG9yIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIC0gT3B0aW9uYWwgcmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiB2YWx1ZXMgeW91IHdhbnQgdG8gcmFuZG9tbHkgc2VsZWN0IGZyb20uXHJcbiogQHJldHVybiB7b2JqZWN0fSBUaGUgcmFuZG9tIG9iamVjdCB0aGF0IHdhcyByZW1vdmVkLlxyXG4qL1xyXG5cclxudmFyIFJlbW92ZVJhbmRvbUVsZW1lbnQgPSBmdW5jdGlvbiAoYXJyYXksIHN0YXJ0LCBsZW5ndGgpXHJcbntcclxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxyXG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgfVxyXG5cclxuICAgIHZhciByYW5kb21JbmRleCA9IHN0YXJ0ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuZ3RoKTtcclxuXHJcbiAgICByZXR1cm4gU3BsaWNlT25lKGFycmF5LCByYW5kb21JbmRleCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW92ZVJhbmRvbUVsZW1lbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L1JlbW92ZVJhbmRvbUVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDU1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hcnJheS9SZW1vdmVSYW5kb21FbGVtZW50LmpzIiwiLyoqXHJcbiogTW92ZXMgdGhlIGVsZW1lbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheSB0byB0aGUgZW5kLCBzaGlmdGluZyBhbGwgaXRlbXMgaW4gdGhlIHByb2Nlc3MuXHJcbiogVGhlIFwicm90YXRpb25cIiBoYXBwZW5zIHRvIHRoZSBsZWZ0LlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQXJyYXlVdGlscy5yb3RhdGVcclxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaGlmdC9yb3RhdGUuIFRoZSBhcnJheSBpcyBtb2RpZmllZC5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IFt0b3RhbD0xXSAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gc2hpZnQgdGhlIGFycmF5LiBPbmx5IHRoZSBtb3N0IHJlY2VudGx5IHNoaWZ0ZWQgZWxlbWVudCBpcyByZXR1cm5lZC5cclxuKiBAcmV0dXJuIHthbnl9IFRoZSBzaGlmdGVkIHZhbHVlLlxyXG4qL1xyXG52YXIgUm90YXRlTGVmdCA9IGZ1bmN0aW9uIChhcnJheSwgdG90YWwpXHJcbntcclxuICAgIGlmICh0b3RhbCA9PT0gdW5kZWZpbmVkKSB7IHRvdGFsID0gMTsgfVxyXG5cclxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgZWxlbWVudCA9IGFycmF5LnNoaWZ0KCk7XHJcbiAgICAgICAgYXJyYXkucHVzaChlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlTGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvUm90YXRlTGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gNTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIE1vdmVzIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIHRoZSBzdGFydCwgc2hpZnRpbmcgYWxsIGl0ZW1zIGluIHRoZSBwcm9jZXNzLlxyXG4qIFRoZSBcInJvdGF0aW9uXCIgaGFwcGVucyB0byB0aGUgcmlnaHQuXHJcbipcclxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaGlmdC9yb3RhdGUuIFRoZSBhcnJheSBpcyBtb2RpZmllZC5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IFt0b3RhbD0xXSAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gc2hpZnQgdGhlIGFycmF5LiBPbmx5IHRoZSBtb3N0IHJlY2VudGx5IHNoaWZ0ZWQgZWxlbWVudCBpcyByZXR1cm5lZC5cclxuKiBAcmV0dXJuIHthbnl9IFRoZSBzaGlmdGVkIHZhbHVlLlxyXG4qL1xyXG52YXIgUm90YXRlUmlnaHQgPSBmdW5jdGlvbiAoYXJyYXksIHRvdGFsKVxyXG57XHJcbiAgICBpZiAodG90YWwgPT09IHVuZGVmaW5lZCkgeyB0b3RhbCA9IDE7IH1cclxuXHJcbiAgICB2YXIgZWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGVsZW1lbnQgPSBhcnJheS5wb3AoKTtcclxuICAgICAgICBhcnJheS51bnNoaWZ0KGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVSaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvUm90YXRlUmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDU1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBBIHN0YW5kYXJkIEZpc2hlci1ZYXRlcyBBcnJheSBzaHVmZmxlIGltcGxlbWVudGF0aW9uIHdoaWNoIG1vZGlmaWVzIHRoZSBhcnJheSBpbiBwbGFjZS5cclxuKlxyXG4qIEBtZXRob2RcclxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaHVmZmxlLlxyXG4qIEByZXR1cm4ge2FueVtdfSBUaGUgb3JpZ2luYWwgYXJyYXksIG5vdyBzaHVmZmxlZC5cclxuKi9cclxudmFyIFNodWZmbGUgPSBmdW5jdGlvbiAoYXJyYXkpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBhcnJheVtpXTtcclxuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xyXG4gICAgICAgIGFycmF5W2pdID0gdGVtcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNodWZmbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L1NodWZmbGUuanNcbi8vIG1vZHVsZSBpZCA9IDU1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYW1vdW50IHRoZSBHYW1lIE9iamVjdCBpcyB2aXN1YWxseSBvZmZzZXQgZnJvbSBpdHMgeCBjb29yZGluYXRlLlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHdpZHRoICogYW5jaG9yLnhgLlxyXG4qIEl0IHdpbGwgb25seSBiZSA+IDAgaWYgYW5jaG9yLnggaXMgbm90IGVxdWFsIHRvIHplcm8uXHJcbipcclxuKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0WFxyXG4qIEByZWFkT25seVxyXG4qL1xyXG5cclxudmFyIEdldE9mZnNldFggPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxue1xyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Qud2lkdGggKiBnYW1lT2JqZWN0LmFuY2hvclg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE9mZnNldFg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2JvdW5kcy9HZXRPZmZzZXRYLmpzXG4vLyBtb2R1bGUgaWQgPSA1NTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGFtb3VudCB0aGUgR2FtZSBPYmplY3QgaXMgdmlzdWFsbHkgb2Zmc2V0IGZyb20gaXRzIHggY29vcmRpbmF0ZS5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB3aWR0aCAqIGFuY2hvci54YC5cclxuKiBJdCB3aWxsIG9ubHkgYmUgPiAwIGlmIGFuY2hvci54IGlzIG5vdCBlcXVhbCB0byB6ZXJvLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFhcclxuKiBAcmVhZE9ubHlcclxuKi9cclxuXHJcbnZhciBHZXRPZmZzZXRZID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHJldHVybiBnYW1lT2JqZWN0LmhlaWdodCAqIGdhbWVPYmplY3QuYW5jaG9yWTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0T2Zmc2V0WTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYm91bmRzL0dldE9mZnNldFkuanNcbi8vIG1vZHVsZSBpZCA9IDU1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUYWtlcyB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCBwYWRzIGl0IG91dCwgdG8gdGhlIGxlbmd0aCByZXF1aXJlZCwgdXNpbmcgdGhlIGNoYXJhY3RlclxyXG4qIHNwZWNpZmllZC4gRm9yIGV4YW1wbGUgaWYgeW91IG5lZWQgYSBzdHJpbmcgdG8gYmUgNiBjaGFyYWN0ZXJzIGxvbmcsIHlvdSBjYW4gY2FsbDpcclxuKlxyXG4qIGBwYWQoJ2JvYicsIDYsICctJywgMilgXHJcbipcclxuKiBUaGlzIHdvdWxkIHJldHVybjogYGJvYi0tLWAgYXMgaXQgaGFzIHBhZGRlZCBpdCBvdXQgdG8gNiBjaGFyYWN0ZXJzLCB1c2luZyB0aGUgYC1gIG9uIHRoZSByaWdodC5cclxuKlxyXG4qIFlvdSBjYW4gYWxzbyB1c2UgaXQgdG8gcGFkIG51bWJlcnMgKHRoZXkgYXJlIGFsd2F5cyByZXR1cm5lZCBhcyBzdHJpbmdzKTpcclxuKiBcclxuKiBgcGFkKDUxMiwgNiwgJzAnLCAxKWBcclxuKlxyXG4qIFdvdWxkIHJldHVybjogYDAwMDUxMmAgd2l0aCB0aGUgc3RyaW5nIHBhZGRlZCB0byB0aGUgbGVmdC5cclxuKlxyXG4qIElmIHlvdSBkb24ndCBzcGVjaWZ5IGEgZGlyZWN0aW9uIGl0J2xsIHBhZCB0byBib3RoIHNpZGVzOlxyXG4qIFxyXG4qIGBwYWQoJ2M2NCcsIDcsICcqJylgXHJcbipcclxuKiBXb3VsZCByZXR1cm46IGAqKmM2NCoqYFxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuVXRpbHMucGFkXHJcbiogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSB0YXJnZXQgc3RyaW5nLiBgdG9TdHJpbmcoKWAgd2lsbCBiZSBjYWxsZWQgb24gdGhlIHN0cmluZywgd2hpY2ggbWVhbnMgeW91IGNhbiBhbHNvIHBhc3MgaW4gY29tbW9uIGRhdGEgdHlwZXMgbGlrZSBudW1iZXJzLlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gW2xlbj0wXSAtIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBiZSBhZGRlZC5cclxuKiBAcGFyYW0ge3N0cmluZ30gW3BhZD1cIiBcIl0gLSBUaGUgc3RyaW5nIHRvIHBhZCBpdCBvdXQgd2l0aCAoZGVmYXVsdHMgdG8gYSBzcGFjZSkuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBbZGlyPTNdIC0gVGhlIGRpcmVjdGlvbiBkaXIgPSAxIChsZWZ0KSwgMiAocmlnaHQpLCAzIChib3RoKS5cclxuKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYWRkZWQgc3RyaW5nLlxyXG4qL1xyXG52YXIgUGFkID0gZnVuY3Rpb24gKHN0ciwgbGVuLCBwYWQsIGRpcilcclxue1xyXG4gICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB7IHZhciBsZW4gPSAwOyB9XHJcbiAgICBpZiAocGFkID09PSB1bmRlZmluZWQpIHsgdmFyIHBhZCA9ICcgJzsgfVxyXG4gICAgaWYgKGRpciA9PT0gdW5kZWZpbmVkKSB7IHZhciBkaXIgPSAzOyB9XHJcblxyXG4gICAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgdmFyIHBhZGxlbiA9IDA7XHJcblxyXG4gICAgaWYgKGxlbiArIDEgPj0gc3RyLmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICBzd2l0Y2ggKGRpcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHN0ciA9IG5ldyBBcnJheShsZW4gKyAxIC0gc3RyLmxlbmd0aCkuam9pbihwYWQpICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBNYXRoLmNlaWwoKHBhZGxlbiA9IGxlbiAtIHN0ci5sZW5ndGgpIC8gMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHBhZGxlbiAtIHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgc3RyID0gbmV3IEFycmF5KGxlZnQrMSkuam9pbihwYWQpICsgc3RyICsgbmV3IEFycmF5KHJpZ2h0KzEpLmpvaW4ocGFkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ciArIG5ldyBBcnJheShsZW4gKyAxIC0gc3RyLmxlbmd0aCkuam9pbihwYWQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL3N0cmluZy9QYWQuanNcbi8vIG1vZHVsZSBpZCA9IDU1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUYWtlcyB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXZlcnNlcyBpdCwgcmV0dXJuaW5nIHRoZSByZXZlcnNlZCBzdHJpbmcuXHJcbiogRm9yIGV4YW1wbGUgaWYgZ2l2ZW4gdGhlIHN0cmluZyBgQXRhcmkgNTIwU1RgIGl0IHdvdWxkIHJldHVybiBgVFMwMjUgaXJhdEFgLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuVXRpbHMucmV2ZXJzZVN0cmluZ1xyXG4qIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIGJlIHJldmVyc2VkLlxyXG4qIEByZXR1cm4ge3N0cmluZ30gVGhlIHJldmVyc2VkIHN0cmluZy5cclxuKi9cclxudmFyIFJldmVyc2VTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nKVxyXG57XHJcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJldmVyc2VTdHJpbmc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL3N0cmluZy9SZXZlcnNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGQ6L3dhbXAvd3d3L3BoYXNlci92My9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoYXNlci5qcyIsInJlcXVpcmUoJy4vcG9seWZpbGxzJyk7XHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBFeHRlbmQgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdC9FeHRlbmQnKTtcclxuXHJcbi8vICBUaGlzIG9iamVjdCBpcyBleHBvcnRlZCBnbG9iYWxseVxyXG5cclxudmFyIFBoYXNlciA9IHtcclxuXHJcbiAgICBET006IHJlcXVpcmUoJy4vZG9tLycpLFxyXG5cclxuICAgIEdhbWU6IHJlcXVpcmUoJy4vYm9vdC9HYW1lJyksXHJcblxyXG4gICAgRXZlbnQ6IHJlcXVpcmUoJy4vZXZlbnRzL0V2ZW50JyksXHJcbiAgICBFdmVudERpc3BhdGNoZXI6IHJlcXVpcmUoJy4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpLFxyXG5cclxuICAgIE1hdGg6IHJlcXVpcmUoJy4vbWF0aCcpLFxyXG5cclxuICAgIENvbXBvbmVudHM6IHJlcXVpcmUoJy4vY29tcG9uZW50cycpLFxyXG5cclxuICAgIEdlb206IHJlcXVpcmUoJy4vZ2VvbScpLFxyXG5cclxuICAgIEdyYXBoaWNzOiByZXF1aXJlKCcuL2dyYXBoaWNzJyksXHJcblxyXG4gICAgSW5wdXQ6IHJlcXVpcmUoJy4vaW5wdXQnKSxcclxuXHJcbiAgICBHYW1lT2JqZWN0czogcmVxdWlyZSgnLi9nYW1lb2JqZWN0cycpLFxyXG5cclxuICAgIFN0YXRlOiByZXF1aXJlKCcuL3N0YXRlL1N0YXRlJyksXHJcblxyXG4gICAgTG9hZGVyOiB7XHJcblxyXG4gICAgICAgIEltYWdlRmlsZTogcmVxdWlyZSgnLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZScpXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBTb3VuZDogcmVxdWlyZSgnLi9zb3VuZCcpLFxyXG5cclxuICAgIFBoeXNpY3M6IHJlcXVpcmUoJy4vcGh5c2ljcycpLFxyXG5cclxuICAgIENsYXNzOiByZXF1aXJlKCcuL3V0aWxzL0NsYXNzJyksXHJcblxyXG4gICAgVXRpbHM6IHtcclxuXHJcbiAgICAgICAgQWxpZ246IHJlcXVpcmUoJy4vdXRpbHMvYWxpZ24vJyksXHJcbiAgICAgICAgQXJyYXk6IHJlcXVpcmUoJy4vdXRpbHMvYXJyYXkvJyksXHJcbiAgICAgICAgQm91bmRzOiByZXF1aXJlKCcuL3V0aWxzL2JvdW5kcy8nKSxcclxuICAgICAgICBPYmplY3RzOiByZXF1aXJlKCcuL3V0aWxzL29iamVjdC8nKSxcclxuICAgICAgICBTdHJpbmc6IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5nLycpXHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vICAgTWVyZ2UgaW4gdGhlIGNvbnN0c1xyXG5cclxuUGhhc2VyID0gRXh0ZW5kKGZhbHNlLCBQaGFzZXIsIENPTlNUKTtcclxuXHJcbi8vICBFeHBvcnQgaXRcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGhhc2VyO1xyXG5cclxuZ2xvYmFsLlBoYXNlciA9IFBoYXNlcjtcclxuXHJcbi8qXHJcbiAqIOKAnFNvbWV0aW1lcywgdGhlIGVsZWdhbnQgaW1wbGVtZW50YXRpb24gaXMganVzdCBhIGZ1bmN0aW9uLlxyXG4gKiBOb3QgYSBtZXRob2QuIE5vdCBhIGNsYXNzLiBOb3QgYSBmcmFtZXdvcmsuIEp1c3QgYSBmdW5jdGlvbi7igJ1cclxuICogLSBKb2huIENhcm1hY2tcclxuICovXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoYXNlci5qc1xuLy8gbW9kdWxlIGlkID0gNTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=